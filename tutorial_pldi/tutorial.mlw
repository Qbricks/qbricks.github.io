(**************************************************************************)
(***  This file is part of QBRICKS.                                         *)
(***                                                                        *)
(***  Copyright (C) 2020-2022                                               *)
(***    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(***         alternatives)                                                  *)
(***    Université Paris-Saclay                                             *)
(***                                                                        *)
(***  you can redistribute it and/or modify it under the terms of the GNU   *)
(***  Lesser General Public License as published by the Free Software       *)
(***  Foundation, version 2.1.                                              *)
(***                                                                        *)
(***  It is distributed in the hope that it will be useful,                 *)
(***  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(***  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(***  GNU Lesser General Public License for more details.                   *)
(***                                                                        *)
(***  See the GNU Lesser General Public License version 2.1                 *)
(***  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(***                                                                        *)
(***************************************************************************)

(**{1 Exercises} *)
(** This file consists in two exercises : the GHZ states preparation and the Quantum Fourier Transform.  File tool_box.mlw aside  provides the material necessary to write the code and specicifations.*)

(** {6 Qbricks provide a Docker installation for Why3 and its dependencies : at Qbricks do
make build
make container
make start.}*)

(** {6 In the docker, use command  make filename_type_check to type check your code and command make filemane_ide to open the ide and enter interactive mode.}*)

(** Here you access the proof obligations generated by your specifications. You can:*) 
(**     -  directly call SMT solvers (eg. : command cvc5 in the window) *) 
(**  - perform a set of proof obligation transformations, the main useful ones for our examples are listed below:*)


(** {4 List of required interactive commands}
*)

(**{6   "rewrite" + Hypothesis_name}*)
(**     substitutes a term along the equality from the Hypothesis *)
    
(** {6 "case" + cond} *)
(**     performs a case distinction *)
    
(** {6 "compute_specified" }*)
 (**   performs alpha reduction *)
   
(** {6 "split_vc" }*)
(**    detructs conjonctions and universal quantification in goals *)
   
(** {6 "split_all_full" }*)
(**    detructs conjonctions and universal quantification in context *)
   
(** {6 "replace" + term1 + term2} *)
(**    replaces term1 by term2 and raises "term1 = term2" as proof obligation*)
   
(** {6 "eliminate_if"} *)
(**    reduces an if statement to a conjunction *)
   
(** {6 "further transformations : tools/Transformations"} *)
(**    reduces an if statement to a conjunction *)
   
(** {2 Greenberger–Horne–Zeilinger (GHZ) state} *)

module GHZ
(** This exercise brings the basic Qbricks constructors: it introduces unary and binary gate applications, sequencing composition and loops *)
       use tool_box.Tool_box_Real

(** A quantum circuit is a structured sequence of quantum gates. The most simple example are unary gate. In particular, Hadamard gate introduces quantum supoersition. We start by a single Hadamard gate declaration, specified with post-conditions describing the width, range (ie, number of path-branching), basis_ket and angle (phase function) function *)

(** {5 Ex. Specify a single Hadamard gate declaration}*)

(* let constant hadamard : circuit *)
(*   = ... *)
  
(** This gate constitute a brick in the calculus, to be applied to a register. Therefore, we commonly refer to its tensorial extension, representing the application of gate hadamard, eg., at qubit "k" in of a size "n" register. The related Qbricks constructor is the "place" function. As preconditions, this constructor requires indexes "k" and "n" to be both positive, and "k" to be less tan "n" -- in Qbricks a register of size "n" gathers qubits indexed from 0 to n-1. *)


(** {5 Ex. Implement and specify "place_hadamard", an n-ary gate, applying hadamard on qubit indexed k. Define, define an instance of "place_hadamard" for k = 0 and n =2}*)

(* let function place_hadamard   (k n:int)  : circuit *)
(*       = ... *)

(** {5 Instantiate input parameters from the above construction, building a two qubits circuit with a single Hadamard gate on the first qubit.} *)

(* let constant place_hadamard_b  : circuit *)
(*       = ... *)
      
(** To introduce quantum entanglement, the calculus requires poly-ary gates. A standard instance is to rely on the "cnot" gate. It is a binary gate, performing  a bit flip operation on its second --target -- qubits when the first -- control-- qubit holds value 1. In this tutorial, we directly use an n-ary version of this gate. Note that the cnot function from file tool_box.mlw provides specifications paving the way for its use as a right sequencing component.*)

(** {5 Ex. Specify cnot_b, a single cnot instanciation operating on a two qubits register, with control qubit at "0" and target qubit at "1".}*)

(* let constant cnot_b : circuit *)
(* = ... *)


(** Now, we have two binary gate, one applying the Hadamard gate on the first qubit, and a controlled not. We can sequence them together to build a bell state preparation *)

(** {5 Ex. Compose a Bell state preparation circuit.}*)

(* let constant bell *)
(* = ... *)

(** A composed circuit represents a unitary program, callable from another program. Constructor "place" is not limited to gates but can take a circuit of arbitrary arity parameter. Consider a register "r" of size "n" and a circuit C of size "n'", then for any k such that 0<=k<n-n', 'placing' C on qubit "k" in r will practically paste it as a n'-ary gate applied on qubits "k" to "k+n'". *)

(** {5 Ex. Operate the Bell preparation from previous question as a 3 qbit circuit}*)

(* let constant bell_size_three *)
(* = ... *)

(** Now, a GHZ preparation of size 3 is obtained from a Bell circuit, by adding a control not linking the third qubit*)

(** {5 Ex. Build a GHZ state preparation circuit of size 3}*)

(* let constant ghz3 *)
(* = ...		    *)

(** This mechanism is generic : a GHZ circuit of size k+1 is a GHZ circuit of size "k" plus a cnot gate. *)

(** {5 Build a recursive function, with a positive integer "n" as entry parameter, it outputs a GHZ circuit of size "n". Note that being recursive, it requires declaring a variant. Syntax for recursivity: "let rec _name(_parameters) = if _ground_case then else ...}*)

(* let rec ghz_rec(n:int) *)
(* 		   = if ... then ... *)
(* 		   else ... *)

(** WhyML language also enables explicitly declaring mutable objects, called "references". This enable a more imperative style programmation, where recursive loops can be turned into for. *)

(** {5 Specify and prove the imperative styled generic GHZ circuit below.}*)

(* let ghz(n:int) *)
(* = let cnot_reg = ref (m_skip n  ) *)
(*   in for q = 1 to n-1 do *)
(*  place_hadamard 0 n -- !cnot_reg *)
end


(** {2 Quantum Fourier  (QFT) circuit} *)
module Qft
(** The Quantum Fourier Transform -- QFT -- is a standard quantum routine, at the heart of, eg, Quantum Phase Estimation (unitary operator eigenvalue estimation) or the Shor order finding algorithm. Basically, it shifts the input basis state information into the phase. You can refer to the dedicated slide for full path-sum specification and circuit description. *)


         use tool_box.Tool_box_Real

(** {5 Build the generic QFT circuit of size "n", for positive integer "n". The exercise is left completely unguided. The key point is to use the circuit's recursive structure. File "tool_box.mlw" provides a specified "crz" construct, for controlled Z rotations. Note that this construct brings a non-branching circuit (range = 0) and an "x-identity" basis ket function, so that iterated sequences of crz instances semantically reduce to iteration in the phase (ang_ind) path-sum component. File "tool_box.mlw" also contains some proving material for this treatment of iterations. }*)



end
