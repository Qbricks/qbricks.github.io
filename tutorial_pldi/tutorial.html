<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<link rel="stylesheet" href="style.css" type="text/css">
<title>tutorial.html</title>
</head>
<body>
<p>why3doc index <a href="index.html">index</a></p>
<hr>
<div class="why3doc">
<h1>Exercises</h1>
<p>This file consists in two exercises : the GHZ states preparation and the Quantum Fourier Transform.  File tool_box.mlw aside  provides the material necessary to write the code and specicifations.</p>
<h6>Qbricks provide a Docker installation for Why3 and its dependencies : at Qbricks do
make build
make container
make start.</h6>
<h6>In the docker, use command  make filename_type_check to type check your code and command make filemane_ide to open the ide and enter interactive mode.</h6>
<p>Here you access the proof obligations generated by your specifications. You can:</p>
<p>-  directly call SMT solvers (eg. : command cvc5 in the window)</p>
<p>- perform a set of proof obligation transformations, the main useful ones for our examples are listed below:</p>
<h4>List of required interactive commands</h4>

<h6>&quot;rewrite&quot; + Hypothesis_name</h6>
<p>substitutes a term along the equality from the Hypothesis</p>
<h6>&quot;case&quot; + cond</h6>
<p>performs a case distinction</p>
<h6>&quot;compute_specified&quot; </h6>
<p>performs alpha reduction</p>
<h6>&quot;split_vc&quot; </h6>
<p>detructs conjonctions and universal quantification in goals</p>
<h6>&quot;split_all_full&quot; </h6>
<p>detructs conjonctions and universal quantification in context</p>
<h6>&quot;replace&quot; + term1 + term2</h6>
<p>replaces term1 by term2 and raises &quot;term1 = term2&quot; as proof obligation</p>
<h6>&quot;eliminate_if&quot;</h6>
<p>reduces an if statement to a conjunction</p>
<h6>&quot;further transformations : tools/Transformations&quot;</h6>
<p>reduces an if statement to a conjunction</p>
<h2>Greenberger–Horne–Zeilinger (GHZ) state</h2>
<pre><span class="keyword">module</span> <a name="GHZ_">GHZ</a>
</pre>
<div class="info"><p>This exercise brings the basic Qbricks constructors: it introduces unary and binary gate applications, sequencing composition and loops</p>
</div><pre>       <span class="keyword">use</span> tool_box.Tool_box_Real

</pre>
<p>A quantum circuit is a structured sequence of quantum gates. The most simple example are unary gate. In particular, Hadamard gate introduces quantum supoersition. We start by a single Hadamard gate declaration, specified with post-conditions describing the width, range (ie, number of path-branching), basis_ket and angle (phase function) function</p>
<h5>Ex. Specify a single Hadamard gate declaration</h5>
<pre><span class="comment">(* let constant hadamard : circuit *)</span>
<span class="comment">(*   = ... *)</span>

</pre>
<p>This gate constitute a brick in the calculus, to be applied to a register. Therefore, we commonly refer to its tensorial extension, representing the application of gate hadamard, eg., at qubit &quot;k&quot; in of a size &quot;n&quot; register. The related Qbricks constructor is the &quot;place&quot; function. As preconditions, this constructor requires indexes &quot;k&quot; and &quot;n&quot; to be both positive, and &quot;k&quot; to be less tan &quot;n&quot; -- in Qbricks a register of size &quot;n&quot; gathers qubits indexed from 0 to n-1.</p>
<h5>Ex. Implement and specify &quot;place_hadamard&quot;, an n-ary gate, applying hadamard on qubit indexed k. Define, define an instance of &quot;place_hadamard&quot; for k = 0 and n =2</h5>
<pre><span class="comment">(* let function place_hadamard   (k n:int)  : circuit *)</span>
<span class="comment">(*       = ... *)</span>

</pre>
<h5>Instantiate input parameters from the above construction, building a two qubits circuit with a single Hadamard gate on the first qubit.</h5>
<pre><span class="comment">(* let constant place_hadamard_b  : circuit *)</span>
<span class="comment">(*       = ... *)</span>

</pre>
<p>To introduce quantum entanglement, the calculus requires poly-ary gates. A standard instance is to rely on the &quot;cnot&quot; gate. It is a binary gate, performing  a bit flip operation on its second --target -- qubits when the first -- control-- qubit holds value 1. In this tutorial, we directly use an n-ary version of this gate. Note that the cnot function from file tool_box.mlw provides specifications paving the way for its use as a right sequencing component.</p>
<h5>Ex. Specify cnot_b, a single cnot instanciation operating on a two qubits register, with control qubit at &quot;0&quot; and target qubit at &quot;1&quot;.</h5>
<pre><span class="comment">(* let constant cnot_b : circuit *)</span>
<span class="comment">(* = ... *)</span>

</pre>
<p>Now, we have two binary gate, one applying the Hadamard gate on the first qubit, and a controlled not. We can sequence them together to build a bell state preparation</p>
<h5>Ex. Compose a Bell state preparation circuit.</h5>
<pre><span class="comment">(* let constant bell *)</span>
<span class="comment">(* = ... *)</span>

</pre>
<p>A composed circuit represents a unitary program, callable from another program. Constructor &quot;place&quot; is not limited to gates but can take a circuit of arbitrary arity parameter. Consider a register &quot;r&quot; of size &quot;n&quot; and a circuit C of size &quot;n&#39;&quot;, then for any k such that 0&lt;=k&lt;n-n&#39;, &#39;placing&#39; C on qubit &quot;k&quot; in r will practically paste it as a n&#39;-ary gate applied on qubits &quot;k&quot; to &quot;k+n&#39;&quot;.</p>
<h5>Ex. Operate the Bell preparation from previous question as a 3 qbit circuit</h5>
<pre><span class="comment">(* let constant bell_size_three *)</span>
<span class="comment">(* = ... *)</span>

</pre>
<p>Now, a GHZ preparation of size 3 is obtained from a Bell circuit, by adding a control not linking the third qubit</p>
<h5>Ex. Build a GHZ state preparation circuit of size 3</h5>
<pre><span class="comment">(* let constant ghz3 *)</span>
<span class="comment">(* = ...		    *)</span>

</pre>
<p>This mechanism is generic : a GHZ circuit of size k+1 is a GHZ circuit of size &quot;k&quot; plus a cnot gate.</p>
<h5>Build a recursive function, with a positive integer &quot;n&quot; as entry parameter, it outputs a GHZ circuit of size &quot;n&quot;. Note that being recursive, it requires declaring a variant. Syntax for recursivity: &quot;let rec _name(_parameters) = if _ground_case then else ...</h5>
<pre><span class="comment">(* let rec ghz_rec(n:int) *)</span>
<span class="comment">(* 		   = if ... then ... *)</span>
<span class="comment">(* 		   else ... *)</span>

</pre>
<p>WhyML language also enables explicitly declaring mutable objects, called &quot;references&quot;. This enable a more imperative style programmation, where recursive loops can be turned into for.</p>
<h5>Specify and prove the imperative styled generic GHZ circuit below.</h5>
<pre><span class="comment">(* let ghz(n:int) *)</span>
<span class="comment">(* = let cnot_reg = ref (m_skip n  ) *)</span>
<span class="comment">(*   in for q = 1 to n-1 do *)</span>
<span class="comment">(*  place_hadamard 0 n -- !cnot_reg *)</span>
<span class="keyword">end</span>

<span class="keyword">module</span> <a name="Qft_">Qft</a>
</pre>
<div class="info"><h2>Quantum Fourier  (QFT) circuit</h2>
<p>The Quantum Fourier Transform -- QFT -- is a standard quantum routine, at the heart of, eg, Quantum Phase Estimation (unitary operator eigenvalue estimation) or the Shor order finding algorithm. Basically, it shifts the input basis state information into the phase. You can refer to the dedicated slide for full path-sum specification and circuit description.</p>
</div><pre>         <span class="keyword">use</span> tool_box.Tool_box_Real

</pre>
<h5>Build the generic QFT circuit of size &quot;n&quot;, for positive integer &quot;n&quot;. The exercise is left completely unguided. The key point is to use the circuit&#39;s recursive structure. File &quot;tool_box.mlw&quot; provides a specified &quot;crz&quot; construct, for controlled Z rotations. Note that this construct brings a non-branching circuit (range = 0) and an &quot;x-identity&quot; basis ket function, so that iterated sequences of crz instances semantically reduce to iteration in the phase (ang_ind) path-sum component. File &quot;tool_box.mlw&quot; also contains some proving material for this treatment of iterations. </h5>
<pre><span class="keyword">end</span>
</pre>

</div>
<hr>
<p>Generated by why3doc 1.8.0</p>
</body>
</html>
