(**************************************************************************)
(*  This file is part of QBRICKS.                                         *)
(*                                                                        *)
(*  Copyright (C) 2020-2022                                               *)
(*    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*    Université Paris-Saclay                                             *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

module Cont_del

  use int.Int
  use wired_circuits.Circuit_c
  use wired_circuits.Qbricks_prim
  use qbricks.Circuit_macros
  use reversion.Circuit_reverse
  use circuits_equiv_pre.Circuit_equivalence_impl
  use circuits_equiv_pre.Wiring_equiv
  use circuits_equiv_pre.Neutral_circuit 
  use circuits_equiv_pre.Gate_decomp as GD
  use circuits_equiv_pre.Wiring_equiv 
  use remarkable_fragments.Diag_circuits
  use remarkable_fragments.Flat_circuits 
  use commuting_lemmas.Ancilla_pre
  use atomic_place.Atomic_place
  use ternary_gates_delete.Ternary_gates_del     
  use commuting_lemmas.Cont_depth_pre
  use parallel_delete.Parallel_del

  predicate control_requires (co ta n: int) = 0 <= ta < n && 0 <= co < n && ta <> co
  
  predicate general_specifications (c: wired_circuit) = 
    correct c && ancilla_free c && parallel_free c && atomic_place c && 
    ternary_gates_free c && cont_depth c = 0

  let function cont_hadamard (co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont Hadamard co1 ta1 n1}
    = GD.cont_hadamard co1 ta1 n1
    
  let function cont_ry (k co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont (Ry k) co1 ta1 n1}
    = GD.cont_ry k co1 ta1 n1
    
  use binary.Binary_Op
  use arit.Incr_abs
  use unit_circle.Angle
  
  let function cont_rz (k co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont (Rz k) co1 ta1 n1}
    = GD.cont_rz k co1 ta1 n1
    
  let function cont_phase (k co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont (Phase k) co1 ta1 n1}
    = GD.cont_phase k co1 ta1 n1
    
  let function cont_rzp (k co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    ensures{general_specifications (cont_rz k co1 ta1 n1)}
    ensures{general_specifications (cont_phase (incr_abs k) co1 ta1 n1)}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont (Rzp k) co1 ta1 n1}
    = GD.cont_rzp k co1 ta1 n1
    
  let function cont_rx (k co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    ensures{general_specifications (cont_hadamard co1 ta1 n1)}
    ensures{general_specifications (cont_rz k co1 ta1 n1)}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont (Rx k) co1 ta1 n1}
    = GD. cont_rx k co1 ta1 n1

  predicate ternary_requires (i j k n: int) = 
    0 <= i < n && 0 <= j < n && 0 <= k < n && 
    i <> j && i <> k && j <> k


  let function ccz (co1 co2 ta1 n1: int) : wired_circuit
    requires{ternary_requires co1 co2 ta1 n1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    = 
    assert{GD.cont_xor_rz (-2) co1 co2 ta1 n1 = Sequence 
      (Sequence (Cnot co1 co2 n1) (GD.cont_rzp (-2) co2 ta1 n1)) (Cnot co1 co2 n1)};

    assert{control_requires co1 ta1 n1};
    assert{general_specifications (cont_rz 2 co1 ta1 n1)};
    assert{general_specifications (cont_phase 3 co1 ta1 n1)};
    assert{general_specifications (cont_rzp 2 co1 ta1 n1)};

    assert{control_requires co2 ta1 n1};
    assert{general_specifications (cont_rz 2 co2 ta1 n1)};
    assert{general_specifications (cont_phase 3 co2 ta1 n1)};
    assert{general_specifications (cont_rzp 2 co2 ta1 n1)};

    assert{control_requires co1 co2 n1};
    assert{general_specifications (Cnot co1 co2 n1)};

    assert{general_specifications (cont_rz (- 2) co2 ta1 n1)};
    assert{general_specifications (cont_phase (-3) co2 ta1 n1)};
    assert{general_specifications (cont_rzp (- 2) co2 ta1 n1)};

    assert{general_specifications (GD.cont_xor_rz (-2) co1 co2 ta1 n1)};

    GD.ccz co1 co2 ta1 n1

  let function toffoli_decomp (co1 co2 ta1 n1: int) : wired_circuit
    requires{ternary_requires co1 co2 ta1 n1}
    ensures{general_specifications (Place Hadamard ta1 n1)}
    ensures{general_specifications (ccz co1 co2 ta1 n1)}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Toffoli co1 co2 ta1 n1}
    = GD.toffoli_decomp co1 co2 ta1 n1
    
 let function fredkin_decomp (co1 ta1 ta2 n1: int) : wired_circuit
    requires{ternary_requires co1 ta1 ta2 n1}
    ensures{general_specifications (Cnot ta2 ta1 n1)}
    ensures{general_specifications (toffoli_decomp co1 ta1 ta2 n1)}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Fredkin co1 ta1 ta2 n1}
 = GD.fredkin_decomp_toffoli co1 ta1 ta2 n1
     
  let function cont_s (co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont S co1 ta1 n1}
  = cont_rzp 2 co1 ta1 n1
  
  let function cont_t (co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont T co1 ta1 n1}
  = cont_rzp 3 co1 ta1 n1
  
  let function cont_zz (co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont Z co1 ta1 n1}
  = cont_rzp 1 co1 ta1 n1
  
  let function cont_xx (co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    requires{ta1 <= co1 -> (ta1 + 1) <= co1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont X co1 ta1 n1}
  = 
    Sequence 
      (Sequence (cont_hadamard co1 ta1 n1)  (cont_zz co1 ta1 n1 )) 
      (cont_hadamard co1 ta1 n1)
  
  let function cont_yy (co1 ta1 n1: int) : wired_circuit
    requires{control_requires co1 ta1 n1}
    requires{ta1 <= co1 -> (ta1 + 1) <= co1}
    ensures{general_specifications result}
    ensures{width_pre result = n1}
    ensures{result <=> Cont Y co1 ta1 n1}
  = Sequence (cont_phase 2 co1 ta1 n1) (cont_ry 1 co1 ta1 n1)

  clone export cont_decomp.Cont_del_implem with
    val cont_rx = cont_rx,
    val cont_ry = cont_ry,
    val cont_rz = cont_rz,
    val cont_rzp = cont_rzp,
    val cont_phase = cont_phase,
    val cont_hadamard = cont_hadamard,
    val toffoli_decomp = toffoli_decomp,
    val fredkin_decomp = fredkin_decomp,
    val cont_s = cont_s,
    val cont_t = cont_t,
    val cont_zz = cont_zz,
    val cont_xx = cont_xx,
    val cont_yy = cont_yy,
    val ccz = ccz
                     
end 

module Subcircuit_control

  use int.Int
  use wired_circuits.Circuit_c
  use wired_circuits.Qbricks_prim
  use circuits_equiv_pre.Circuit_equivalence_impl
  use circuits_equiv_pre.Gate_decomp
  use circuits_equiv_pre.Neutral_circuit
  use reversion.Circuit_reverse
  use commuting_lemmas.Ancilla_pre
  use parallel_delete.Parallel_del
  use ternary_gates_delete.Ternary_gates_del
  use atomic_place.Atomic_place
  use commuting_lemmas.Cont_depth_pre
  use Cont_del   
  use commuting_lemmas.Place_atomic_def
  use qbricks.Circuit_macros
  use circuits_equiv_pre.Neutral_circuit 

  let lemma cont_depth_cont_neq (co ta n: int) (c: wired_circuit)
    requires{correct c}
    requires{0 <= co /\ co < n}
    requires{0 <= ta /\ ta <= (n - width_pre c)}
    requires{ta <= co -> (ta + width_pre c) <= co}
    ensures{(cont_depth (Cont c co ta n) <> 0)}
    = 
      cont_depth_cont c co ta n;
      ()

  let rec function control_delete_step (c: wired_circuit) (co t n: int)
    requires{correct c}
    requires{0 <= co /\ co < n}
    requires{0 <= t /\ t <= (n - width_pre c)}
    requires{t <= co -> (t + width_pre c) <= co}
    requires{general_specifications c}
    requires{correct (Cont c co t n)}
    ensures{general_specifications result}
    ensures {result <=> (Cont c co t n)}
  = match c with
    | Sequence c1 c2 -> 
        let c1' = control_delete_step c1 co t n in
        assert{general_specifications c1'};
        assert{Cont c1 co t n <=> c1'};
        let c2' = control_delete_step c2 co t n in
        assert{general_specifications c2'};
        assert{Cont c2 co t n <=> c2'};
        assert{Cont (Sequence c1 c2) co t n <=> Sequence (Cont c1 co t n) (Cont c2 co t n)}; 
        assert{Sequence (Cont c1 co t n) (Cont c2 co t n) <=> Sequence c1' c2'};
        Sequence c1' c2'
    | Place c1 ta1 n1 -> 
        let c1' = control_delete_step c1 co (ta1 + t) n in
        assert{general_specifications c1'};
        assert{Cont c1 co (ta1 + t) n <=> c1'};
        assert{Cont (Place c1 ta1 n1) co t n <=> Cont c1 co (ta1 + t) n};
        assert{Cont c1 co (ta1 + t) n <=> c1'};
        c1'
    | Phase k -> cont_phase k co t n
    | Rx k -> cont_rx k co t n
    | Ry k -> cont_ry k co t n
    | Rz k -> cont_rz k co t n
    | Rzp k -> cont_rzp k co t n
    | Hadamard -> cont_hadamard co t n
    | S -> cont_s co t n
    | T -> cont_t co t n
    | X -> cont_xx co t n
    | Y -> cont_yy co t n
    | Z -> cont_zz co t n
    | Cnot co1 t1 n1 ->
        let c' = toffoli_decomp co (t + co1) (t + t1) n in
        assert{general_specifications c'};
        assert {Cont (Cnot co1 t1 n1) co t n <=> toffoli_as_cont_cnot co (t + co1) (t + t1) t n1 n};
        assert {toffoli_as_cont_cnot co (t + co1) (t + t1) t n1 n <=> Toffoli co (t + co1) (t + t1) n};
        assert {Toffoli co (t + co1) (t + t1) n <=> c'};
        assert {Cont (Cnot co1 t1 n1) co t n <=> c'};
        c'
    | Swap t1 t2 n2 ->
        let c' = fredkin_decomp co (t + t1) (t + t2) n in
        assert{general_specifications c'};
        assert {Cont (Swap t1 t2 n2) co t n <=> fredkin_as_cont_swap co (t + t1) (t + t2) t n2 n};
        assert {fredkin_as_cont_swap co (t + t1) (t + t2) t n2 n <=> Fredkin co (t + t1) (t + t2) n};
        assert {Fredkin co (t + t1) (t + t2) n <=> c'};
        assert {Cont (Swap t1 t2 n2) co t n <=> c'};
        c'
    | Bricks_Cnot ->
        let c' = toffoli_decomp co t (t + 1) n in
        assert{general_specifications c'};
        assert {Cont Bricks_Cnot co t n <=> Cont (Cnot 0 1 2) co t n};
        assert {Cont (Cnot 0 1 2) co t n <=> toffoli_as_cont_cnot co t (t + 1) t 2 n};
        assert {toffoli_as_cont_cnot co t (t + 1) t 2 n <=> Toffoli co t (t + 1) n};
        assert {Toffoli co t (t + 1) n <=> c'};
        transitive_circuit_equiv (Cont Bricks_Cnot co t n) (Cont (Cnot 0 1 2) co t n) (toffoli_as_cont_cnot co t (t + 1) t 2 n);
        transitive_circuit_equiv (toffoli_as_cont_cnot co t (t + 1) t 2 n) (Toffoli co t (t + 1) n) c';
        assert {Cont Bricks_Cnot co t n <=> c'};
        c'
    | Bricks_Swap ->
        let c' = fredkin_decomp co t (t + 1) n in
        assert{general_specifications c'};
        assert {Cont Bricks_Swap co t n <=> Cont (Swap 0 1 2) co t n};
        assert {Cont (Swap 0 1 2) co t n <=> fredkin_as_cont_swap co t (t + 1) t 2 n};
        assert {fredkin_as_cont_swap co t (t + 1) t 2 n <=> Fredkin co t (t + 1) n};
        assert {Fredkin co t (t + 1) n <=> c'};
        transitive_circuit_equiv (Cont Bricks_Swap co t n) (Cont (Swap 0 1 2) co t n) (fredkin_as_cont_swap co t (t + 1) t 2 n);
        transitive_circuit_equiv (fredkin_as_cont_swap co t (t + 1) t 2 n) (Fredkin co t (t + 1) n) c';
        assert {Cont Bricks_Swap co t n <=> c'};
        c'
    | Skip ->
        let c' = cont_skip_to_place co t n in
        assert{general_specifications c'};
        assert {Cont c co t n <=> c'};
        c'
    | Parallel _ _ -> 
        assert{parallel_free c};
        c
    | Ancillas _ _ -> 
      assert{ancilla_free c};
      c
    | Cont _ _ _ _ -> 
        assert{cont_depth c = 0};
        c
    | _ -> 
        assert{general_specifications c};
        c
  end

  use commuting_lemmas.Lemmas_correct_circuit_pre

  let rec function control_delete (c: wired_circuit)
    requires{ancilla_free c}
    requires{correct c}
    requires{parallel_free c}
    requires{ternary_gates_free c}
    requires{atomic_place c}
    ensures{general_specifications result}
    ensures {c <=> result}
  = match c with
    | Sequence c1 c2 ->
        let c1' = control_delete c1 in
        assert{general_specifications c1'};
        assert {c1 <=> c1'};
        let c2' = control_delete c2 in
        assert{general_specifications c2'};
        assert {c2 <=> c2'};
        let c' = Sequence c1' c2' in
        assert{general_specifications c'};
        assert {Sequence c1 c2 <=> c'};
        c'
    | Cont c1 co k n ->
      assert{correct (Cont c1 co k n)};
      correct_cont_rev c1 co k n;
      assert{k < n};
      if cont_depth c1 = 0 then (
        assert{cont_depth c1 = 0};
        let c' = control_delete_step c1 co k n in 
        assert{general_specifications c'};
        assert {Cont c1 co k n <=> c'};
        c')
      else (
        let c1' = control_delete c1 in
        assert{general_specifications c1'};
        assert {c1 <=> c1'};
        let c' = control_delete_step c1' co k n in
        assert{general_specifications c'};
        assert {Cont c1 co k n <=> Cont c1' co k n};
        assert {Cont c1' co k n <=> c'};
        c')
    | Place c1 ta n1 -> 
        assert{cont_depth c1 = 0};
        assert{general_specifications c};
        assert {c <=> Place c1 ta n1};
        Place c1 ta n1
    | _ -> c
  end

  use ref.Ref
     
  let function to_oqasm (c : wired_circuit) : wired_circuit
    requires{ancilla_free c}
    requires{correct c}
    ensures{general_specifications result}
   = 
    let ref c  = parallel_del c in 
      c := ternary_gates_del c;
      c := place_atomic c;
      c := control_delete c;
      return c 

end


