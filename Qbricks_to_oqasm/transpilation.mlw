(**************************************************************************)
(*  This file is part of QBRICKS.                                         *)
(*                                                                        *)
(*  Copyright (C) 2020-2022                                               *)
(*    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*    Université Paris-Saclay                                             *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

module To_OqenQASM_2

  use int.Int
  use wired_circuits.Circuit_c
  use wired_circuits.Qbricks_prim
  use reversion.Circuit_reverse
  use circuits_equiv_pre.Gate_decomp
  use draw_circuits.Draw
  use subcircuit_control.Subcircuit_control
  use subcircuit_control.Cont_del

  (* TODO: Redo the proof by removing ERROR. *)

  type openqasm = 
  | RX string | RY string | RZ string | U1 string
  | H | SS | TT | XX | YY | ZZ | ID
  | CX string string 
  | SWAP string string
  | SEQUENCE openqasm openqasm | PLACE openqasm string
  | ERROR
  
  let function string_rotation_oq_pos (k : int) : string
  = "(2 * pi / 2^("^(i_to_s k)^"))"

  let function string_rotation_oq_neg (k : int) : string
  = "(- 2 * pi / 2^("^(i_to_s (-k))^"))"

  use commuting_lemmas.Ancilla_pre
  use commuting_lemmas.Cont_depth_pre
  use commuting_lemmas.Lemmas_correct_circuit_pre

  let rec function qbricks_to_openqasm (c : wired_circuit) : openqasm
    variant{c} 
    = 
    match c with 
    | Phase _ -> ERROR
    | Skip -> ID
    | Rx k -> 
      RX (if k < 0 then string_rotation_oq_neg k else string_rotation_oq_pos k)
    | Ry k -> 
      RY (if k < 0 then string_rotation_oq_neg k else string_rotation_oq_pos k)
    | Rz k -> 
      RZ (if k < 0 then string_rotation_oq_neg k else string_rotation_oq_pos k)
    | Rzp k -> 
      U1 (if k < 0 then string_rotation_oq_neg k else string_rotation_oq_pos k)
    | Hadamard -> H
    | S -> SS
    | T -> TT
    | X -> XX
    | Y -> YY
    | Z -> ZZ
    | Cnot co t _ -> CX (i_to_s co) (i_to_s t)
    | Bricks_Cnot -> CX (i_to_s 0) (i_to_s 1)
    | Swap t1 t2 _ -> SWAP (i_to_s t1) (i_to_s t2)
    | Bricks_Swap -> SWAP (i_to_s 0) (i_to_s 1)
    | Place c1 p _ ->
      match c1 with
      | Cnot co1 ta1 _ -> CX (i_to_s (co1 + p)) (i_to_s (ta1 + p)) 
      | Bricks_Cnot  -> CX (i_to_s p) (i_to_s (1 + p))
      | Swap ta1 ta2 _ -> SWAP (i_to_s (ta1 + p)) (i_to_s (ta2 + p)) 
      | Bricks_Swap -> SWAP (i_to_s p) (i_to_s (1 + p)) 
      | _ -> PLACE (qbricks_to_openqasm c1) (i_to_s p)
      end
    | Sequence d e -> SEQUENCE (qbricks_to_openqasm d) (qbricks_to_openqasm e)
    | _ -> 
      (* TODO: Redo the proof without using this branch *)
      ERROR
    end

  let rec function string_oq_rec (c : openqasm) : string
  =
    match c with
    | RX k -> "rx "^k 
    | RY k -> "ry "^k 
    | RZ k -> "rz "^k 
    | U1 k -> "u1 "^k
    | H -> "h" | SS -> "s" | TT -> "t" 
    | XX -> "x" | YY -> "y" | ZZ -> "z" 
    | ID -> ""
    | CX co t -> "cx q["^co^"], q["^t^"];\n"
    | SWAP t1 t2 -> "swap q["^t1^"], q["^t2^"];\n"
    | SEQUENCE d e -> string_oq_rec d ^ string_oq_rec e
    | PLACE (SEQUENCE _ _) _ 
    | PLACE (SWAP _ _) _ 
    | PLACE (CX _ _) _ -> 
      (* TODO: Redo the proof without using this branch *)
      "Error"
    | PLACE ID _ -> ""
    | PLACE c1 p -> string_oq_rec c1 ^ " q[" ^ p ^ "];\n"
    | _ -> 
      (* TODO: Redo the proof without using this branch *)
      "Error"
    end


  let function print_oq (c : wired_circuit) : string
    requires{correct c}
  = "OPENQASM 2.0;\ninclude \"qelib1.inc\";\nqreg q["^(i_to_s (width_pre c))^"];\n"^(string_oq_rec (qbricks_to_openqasm c))

  let function string_oq (c : circuit) : string
    requires{ancilla_free (pre c)}
  = print_oq (to_oqasm (pre c))

end
