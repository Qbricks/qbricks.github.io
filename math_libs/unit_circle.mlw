(**************************************************************************)
(*  This file is part of QBRICKS.                                         *)
(*                                                                        *)
(*  Copyright (C) 2020-2022                                               *)
(*    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*    Université Paris-Saclay                                             *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

module Angle
         use  complex.Complex
         use int.Int
         use  int_expo.Int_Exponentiation
         use complex_expo.Complex_exp
         use extr_int.Ind_isum
     
type angle
   
val function ang_inv angle:angle

val function ang_add angle angle:angle   

let function (+.+) (a b:angle):angle
  = ang_add a b

val function ang_meas (_:angle): complex
                                   ensures{c_zero <=. result <. c_one}

let lemma real_ang_meas (o:angle)
      ensures{real_ (ang_meas o)}
  =()

val function real_to_ang (phi: complex):angle
                                          requires{real_ phi}

val constant ang_zero :angle

clone algebra.CommutativeGroup with type t = angle,
 function inv = ang_inv,
 function op = ang_add,
 constant unit = ang_zero,
 axiom Assoc, axiom Unit_def_l,
 axiom Unit_def_r, axiom Inv_def_l,
 axiom Inv_def_r,axiom Comm                                 
 axiom Real_To_Ang_one:forall phi: complex.  real_ phi -> real_to_ang c_one = ang_zero             axiom Real_To_Ang_inv:forall phi: complex.  real_ phi -> ang_inv (real_to_ang phi) = real_to_ang (-. phi)               
 axiom Real_To_Ang_add: forall phi phi' : complex. real_ phi -> real_ phi'  ->  (real_to_ang phi) +.+ (real_to_ang phi') = real_to_ang (phi +. phi')              
 axiom meas_value: forall phi: complex. real_ phi -> c_zero <=. phi <. c_one -> ang_meas (real_to_ang phi) = phi
 axiom Equal_angle: forall o o':angle. exp (two_pi_i *. ang_meas o) = exp (two_pi_i *. ang_meas o') <-> o = o'                                  

let lemma set_equal_angle_meas (o o':angle)
      requires{o = o'}
      ensures{ang_meas o = ang_meas o'}
  =()
  
let lemma get_equal_angle_meas (o o':angle)
      requires{ang_meas o = ang_meas o'}
      ensures{o = o'}
  =()

let lemma meas_real_to_ang (o:angle)
      ensures{real_to_ang (ang_meas o) = o}
  =()
  
let lemma meas_real_to_ang_rev (o:angle)
      ensures{ o = real_to_ang (ang_meas o)}
  =()

let lemma ang_add_rev(o o':angle)
      ensures{o +.+  o' = o' +.+ o}
  =()
  
let lemma real_to_ang_zero()
      ensures{real_to_ang c_zero = ang_zero}
  = assert{forall o: angle. o +.+  (real_to_ang c_zero) = o };
    assert{forall o: angle.  ang_zero +.+ o = o };
    assert{ang_zero +.+ (real_to_ang c_zero) = ang_zero = real_to_ang c_zero}
    
let function ang_exp (o:angle): complex
                                  ensures{result <> c_zero}
  =  exp (two_pi_i *. ang_meas o)

let lemma set_equal_angle_exp (o o':angle)
      requires{o = o'} 
      ensures{ang_exp o = ang_exp o'}
  =()
  
let lemma get_equal_angle_exp (o o':angle)
      requires{ang_exp o = ang_exp o'}
      ensures{o = o'}
  =()

let lemma meas_value_plus_one (phi: complex)
      requires{real_ phi}
      ensures{exp (two_pi_i *. ang_meas (real_to_ang phi)) = exp (two_pi_i *. (ang_meas (real_to_ang phi) +. c_one))}
  =()
     
     use complex_operations.FromInt
     use  complex_expo.Complex_Exponentiation
  
let lemma ang_exp_pi_over_four()
      ensures{ang_exp (real_to_ang (c_one /.(i_to_c 8))) = ( squarert_two /. ttwo) +. (im *. ( squarert_two /. ttwo))}
  =()
  
let lemma ang_exp_pi_over_two()
      ensures{ang_exp (real_to_ang (c_one/. (i_to_c 4))) = im}
  =()

let lemma ang_exp_pi()
      ensures{ang_exp (real_to_ang (c_one /. (i_to_c 2))) = -. c_one}
  =()

let lemma real_to_ang_c_one()
      ensures{real_to_ang c_one = ang_zero}
  = ()

let lemma set_ang_meas_eq (o o':angle)
      requires{o = o'}
      ensures{ang_meas o = ang_meas o'}
  =()

let lemma get_ang_meas_eq (o o':angle)
      requires{ang_meas o = ang_meas o'}
      ensures{o = o'}
  =()

let lemma ang_exp_zero ()
      ensures{ang_exp ang_zero = c_one}
  =()

let lemma ang_exp_two_pi()
      ensures{ang_exp (real_to_ang (i_to_c 1)) =  c_one}
  =()

let lemma ang_exp_c_one()
      ensures{ang_exp (real_to_ang c_one) =  c_one}
  =()

let lemma ang_meas_add_inf_c_one (o o':angle)
      requires{ang_meas o +. ang_meas o' <. c_one}
      ensures{ang_meas (o +.+ o') = ang_meas o +. ang_meas o' }
  =()

let lemma set_ang_exp_eq (o o':angle)
      requires{o = o'}
      ensures{ang_exp o = ang_exp o'}
  =()

let lemma get_ang_exp_meas_eq (o o':angle)
      requires{ang_exp o = ang_exp o'}
      ensures{ang_meas o = ang_meas o'}
  =()
  
let lemma get_ang_exp_eq (o o':angle)
      requires{ang_exp o = ang_exp o'}
      ensures{o = o'}
  =()
  
let lemma ang_meas_zero ()
      ensures{ang_meas ang_zero = c_zero}
  =()

let lemma real_to_ang_add_one(x: complex)
      requires{real_ x}
      ensures{real_to_ang (x+.c_one) = real_to_ang x}
  =()
     
     use complex_operations.Int_dec_parts

let lemma ang_exp_add_b (o o':angle)
      requires{ang_meas o +. ang_meas o' <. c_one}
      ensures{ang_exp (o +.+ o') = ang_exp o *. ang_exp o'}
  = ()

let lemma ang_exp_add_b_rev (o o':angle)
      requires{ang_meas o +. ang_meas o' <. c_one}
      ensures{ang_exp o *. ang_exp o' = ang_exp (o +.+ o')}
  = ()

let lemma real_to_ang_add(x x': complex)
      requires{real_ x}
      requires{real_ x'}
      ensures{real_to_ang (x+.x') = (real_to_ang x)+.+ (real_to_ang x')}
  = ()

let lemma real_to_ang_add_rev (x x': complex)
      requires{real_ x}
      requires{real_ x'}
      ensures{  (real_to_ang x) +.+ (real_to_ang x')=real_to_ang (x+.x')}
  = ()

let lemma ang_inv_add (o o':angle)
      ensures{ang_inv (o +.+ o') =  (ang_inv o)+.+ (ang_inv o') }
  =()
  
let lemma ang_inv_add_rev (o o':angle)
      ensures{ (ang_inv o) +.+(ang_inv o') =ang_inv (o +.+ o')}
  =()
  
let lemma ang_exp_add_pre (o o':angle)
      requires{c_one <=. ang_meas o +. ang_meas o'}
      requires{ang_meas o <=. ang_meas o'}
      ensures{ang_exp (o +.+ o') = ang_exp o *. ang_exp o'}
  =  assert{o +.+ o' = (real_to_ang c_one) +.+ (real_to_ang (ang_meas o+. ang_meas o' -. c_one))};
     let toto = ang_meas o' +. ang_meas o -. c_one
     in ang_exp_add_b ang_zero (real_to_ang toto)
          ensures{c_zero +. toto = ang_meas o' +. ang_meas o -. c_one}
          ensures{c_zero<=.toto <. c_one}
          ensures{ang_exp (o +.+ o') = ang_exp (real_to_ang toto) *. ang_exp ang_zero}
          ensures{ang_exp (o +.+ o') = ang_exp o *. ang_exp o'}  
      
let lemma ang_exp_add (o o':angle)
      ensures{ang_exp (o +.+ o') = ang_exp o *. ang_exp o'}
  = if   ang_meas o +. ang_meas o' <. c_one then 
      ang_exp_add_b o o'
    else if ang_meas o <=. ang_meas o'
    then ang_exp_add_pre o o'
    else ang_exp_add_pre o' o

let lemma ang_meas_add (o o':angle)
      ensures{real_to_ang (ang_meas (o +.+ o')) = o +.+  o'}
  = ()
  
let lemma ang_exp_add_rev (o o':angle)
      ensures{ang_exp o *. ang_exp o' =ang_exp (o +.+ o')}
  = ang_exp_add o o'

let rec lemma real_to_ang_int_pre  (k:int)
          requires{0<=k}
          ensures{ang_exp (real_to_ang ( i_to_c k)) = c_one}
          variant{k}
  = if k = 0 then ()
    else
      begin
        real_to_ang_int_pre (k-1);
        ang_exp_add (real_to_ang c_one) (real_to_ang (i_to_c k))
      end
  
let  lemma real_to_ang_int  (k:int)
       ensures{ang_exp (real_to_ang ( i_to_c k)) = c_one}
  = if  0 <= k then real_to_ang_int_pre k else real_to_ang_int_pre (-k)
  
let  lemma real_to_ang_int_  (k:int)
       ensures{real_to_ang ( i_to_c k) = ang_zero}
  = ()
  
let lemma real_to_ang_value_add ( phi: complex) (k:int)
      requires{c_zero <=.  phi <. c_one}
      ensures{ang_exp (real_to_ang (phi +. i_to_c k)) = exp (two_pi_i *. phi)}
  = ang_exp_add (real_to_ang phi) (real_to_ang (i_to_c k))
  
let lemma real_to_ang_value ( phi: complex) 
      requires{real_ phi}
      ensures{ang_exp (real_to_ang phi) = exp (two_pi_i *. phi)}
  = real_to_ang_value_add (dec_part phi)(int_part_int phi)
      
      lemma ang_exp_zero_: ang_exp ang_zero = c_one
  
let rec function ang_mult_int_  (theta:angle) (i:int): angle
                                                         requires{0<= i}
                                                         ensures{result = real_to_ang (ang_meas theta *. i_to_c i)}
                                                         variant{i}
  = if i = 0 then ang_zero
    else  (ang_mult_int_ theta (i-1)) +.+ theta                                                     
let  function ang_mult_int  (theta:angle) (i:int): angle
  = if 0 <= i  then ang_mult_int_ theta i
    else ang_inv (ang_mult_int_ theta (-i))

let function ( *.* ) (i:int) (theta:angle): angle
  = ang_mult_int  theta i
  
let  lemma ang_mult_int_to_real_to_ang  (theta:angle) (i:int)
       ensures{i *.* theta=  real_to_ang (ang_meas theta *. i_to_c i)}     
  = ()

let lemma ang_mult_int_eq (i i':int) (theta theta':angle)
      requires{i = i'}
      requires{theta= theta'}
      ensures{i*.*theta = i'*.* theta'}
  = ()
  
let lemma ang_mult_int_plus_one_pos  (theta:angle) (i:int)
      requires{0<i}                     
      ensures{i *.* theta=  ((i-1) *.* theta ) +.+ theta}
  =()
  
let lemma ang_mult_int_inv  (theta:angle) (i:int)
      requires{i<0}                     
      ensures{i *.* theta= ang_inv ((-i) *.*  theta)}
  =()
     
     use int.EuclideanDivision
     use complex_operations.Conjugate

let lemma real_to_ang_eq  (phi phi': complex)
      requires{real_ phi}
      requires{phi = phi'}
      ensures{real_to_ang phi = real_to_ang phi' }
  =()

let lemma set_equal_angle_by_exp (o o':angle)
      requires{ang_exp o = ang_exp o'}
      ensures{o = o'}
  =()

let  lemma real_to_ang_int_dec_part  (x:complex)
       requires{real_ x}
       ensures{real_to_ang x = real_to_ang (dec_part x)}
  = ()
  
let lemma set_equal_exp_by_ang (o o':angle)
      requires{o = o'}
      ensures{ang_exp o = ang_exp o'}
  =()

use arit.Div_Mod
  
let function int_to_ang (k n: int): angle
                                      requires{n >=0}
                                      ensures{result = real_to_ang (i_to_c (mod k (power 2 n)) /. i_to_c (power 2 n))}
                                      ensures{0<= k < power 2 n-> ang_meas  result = (i_to_c k /. i_to_c (power 2 n))}
  =
  assert{(i_to_c k /. i_to_c (power 2 n)) = (i_to_c (mod k (power 2 n)) /. i_to_c (power 2 n))+. i_to_c (div k (power 2 n))};
  real_to_ang (i_to_c k /. i_to_c (power 2 n))

let function (/./) (k:int) (n:int) :angle
                                      ensures{0<=n -> result = real_to_ang (i_to_c (mod k (power 2 n)) /. i_to_c (power 2 n))}
                                      ensures{0<=n -> 0<= k < power 2 n-> ang_meas  result = (i_to_c k /. i_to_c (power 2 n))}
                                      ensures{n <0 -> result = real_to_ang (i_to_c (mod (-k) (power 2 (-n))) /. i_to_c (power 2 (-n)))}
                                      ensures{n <0 -> 0<= k < power 2 n-> ang_meas  result = (i_to_c (-k) /. i_to_c (power 2 (-n)))}
  = if 0<= n then int_to_ang k n else int_to_ang (-k) (-n)

let lemma int_to_ang_pos (k n: int)
      requires{0<=n}
      ensures{k/./n = real_to_ang (i_to_c k /. i_to_c (power 2 n))}
  =()

let lemma int_to_ang_real_mod (k n: int)
      requires{0<=n}
      ensures{k/./n = real_to_ang (i_to_c (mod k (power 2 n)) /. i_to_c (power 2 n))}
  =()

let lemma real_to_ang_inv(x : complex)
      requires{real_ x}
      ensures{real_to_ang (-. x) = ang_inv (real_to_ang x)}
  = ()
  
let lemma real_to_ang_inv_rev (x : complex)
      requires{real_ x}
      ensures{ ang_inv (real_to_ang x) = real_to_ang (-. x)}
  = ()
  
let lemma involutive_ang_inv (o : angle)
      ensures{ ang_inv (ang_inv o) = o}
  = ()
      
      lemma Real_To_Ang_inv_add:forall phi: complex. real_ phi ->  (real_to_ang phi) +.+ (real_to_ang (-. phi)) = ang_zero             
                                                                                                                    lemma Real_To_Ang_up: forall phi: complex. real_ phi -> real_to_ang phi = real_to_ang (c_one +. phi)
  
let rec lemma real_To_Ang_cyclic_pos (phi: complex) ( k:int)
          requires{real_ phi}
          requires{0<=k}
          ensures{real_to_ang phi = real_to_ang ((i_to_c k) +. phi)}
          variant{k}
  = if k = 0 then ()
    else real_To_Ang_cyclic_pos phi (k-1)
  
let  lemma real_To_Ang_cyclic_neg (phi: complex) ( k:int)
       requires{real_ phi}
       requires{0<=k}
       ensures{real_to_ang ((i_to_c k) -. phi) = real_to_ang (-.phi) }
  = real_To_Ang_cyclic_pos (-. phi) k

let lemma real_to_ang_equiv (x x':complex)
      requires{real_ x}
      requires{exists k:int. x' = x+. i_to_c k}
      ensures{real_to_ang x = real_to_ang x'}
  =()
     
     lemma Real_zero_n: real_to_ang c_zero  = ang_zero
  
let rec lemma real_ang_mult_pos (phi: complex)  (i:int)
          requires{real_ phi}
          requires{0<=i}
          ensures{i *.* (real_to_ang phi) = real_to_ang (phi *. (i_to_c i))}
          variant{i}
  = if i = 0 then ()
    else real_ang_mult_pos phi (i-1)

let lemma real_ang_mult (phi: complex)  (i:int)
      requires{real_ phi}
      ensures{i *.* (real_to_ang phi) = real_to_ang (phi *. (i_to_c i))}
  = if   0<= i then real_ang_mult_pos phi i
    else
      begin
        real_ang_mult_pos phi (-i);
        real_to_ang_inv  (phi *. (i_to_c i));
      end

let lemma real_to_ang_down_cucles (phi : complex) (x: complex)
      requires{real_ phi}
      requires{x = c_one}
      ensures{real_to_ang (phi-. x) = real_to_ang phi}
  =()

     use qdata.Sqrt_two
  
let lemma int_to_ang_to_real_to_ang (theta:angle) (k n :int)
      requires{n>=0}
      requires{theta = k /./ n}
      ensures{theta = real_to_ang (i_to_c k *. pow_inv_2 n)}
  =()
  
let lemma real_to_ang_to_int_to_ang  (k n :int)
      requires{n>=0}
      ensures{real_to_ang (i_to_c k *. pow_inv_2 n) = k /./ n}
  =()
  
let lemma real_to_ang_to_int_to_ang_add  (k k' n :int)
      requires{n>=0}
      ensures{real_to_ang ((i_to_c k +. i_to_c k') *. pow_inv_2 n) = (k+k') /./ n}
  =()
  
let lemma int_to_ang_to_real_to_ang_gen (k n :int) (kx: complex)
      requires{n>=0}
      requires{kx = i_to_c k}
      ensures{k /./ n = real_to_ang (kx *. pow_inv_2 n)}
  =()
     
     lemma Int_To_Ang_inv: forall k n: int. ang_inv (k /./ n) = ((-k) /./ n)              
                                                                  lemma Int_To_Ang_inv_add: forall k n: int.  (k /./ n) +.+ ((-k) /./ n) = ang_zero             
                                                                                                                                             lemma Int_To_Ang_add: forall k k' n: int.  (k /./ n)  +.+ (k' /./ n) = (k+k') /./ n             
                                                                                                                                                                                                                                 lemma Int_To_Ang_up: forall k n:int.  0<=n -> k /./ n = (2*k) /./ (n+1)
                                                                                                                                                                                                                                                                                                     lemma Int_To_Ang_cyclic: forall k n: int. 0<=n ->  k /./ n = (k + (power 2 n)) /./ n              lemma Zero_n: forall n:int. 0 /./ n = ang_zero

let constant ang_minus_one
  = 1 /./ 1                                                       

let lemma set_ang_minus_one_by_int (a b : int)
      requires{a = 1}
      requires{b = 1}
      ensures{a /./ b = ang_minus_one}
  =()
  
let lemma ang_minus_one_from_real()
      ensures{ang_minus_one = real_to_ang (c_one/.ttwo)}
  =()
  
let lemma ang_exp_minus_one()
      ensures{ang_exp ang_minus_one = -. c_one}
  =()

let lemma set_ang_zero_by_int (a b : int)
      requires{a = 0}
      requires{0<=b}
      ensures{a /./ b = ang_zero}
  =()

let lemma ang_minus_one_twice( a1 a2 :angle)
      requires{a1 = ang_minus_one}
      requires{a2 = ang_minus_one}
      ensures{a1 +.+ a2  = ang_zero}
  =()
  
let function  div_two (d:angle):angle
                                  ensures{ang_meas result = ang_meas d /. ttwo}
                                  ensures{result +.+ result =  d }
  =
  real_to_ang (ang_meas d/. ttwo)
    
    lemma Div_two: forall d: angle.  (div_two d)+.+ (div_two d)  = d
                                                                     lemma div_two_int_to_ang: forall k n:int. n>=0 -> 0<=k < (power 2 n) -> div_two (k /./ n)   = k /./ (n+1)

let lemma ang_exp_mult (x x':angle)
      ensures{ang_exp x *. ang_exp x' = ang_exp (x +.+  x')}
  =()

let lemma ang_exp_modulus (x :angle)
      ensures{modulus (ang_exp x)= c_one}
  =()

let lemma ang_exp_not_one (i: complex)
      requires{c_zero<. i <. c_one}
      ensures{ang_exp (real_to_ang i) <> c_one}
  =()
  
let lemma ang_exp_not_by_modulus (i: complex)
      requires{c_zero<. i <. c_one}
      ensures{ang_exp (real_to_ang (modulus i)) <> c_one}
  =()
  
let function k_int_to_ang (k:int) : angle
                                      requires{0<= k}
  = 1 /./ k

            lemma K_int_to_angplus_one: forall k:int. k > 0 ->  (k_int_to_ang k)+.+ (k_int_to_ang k) = k_int_to_ang (k-1)

let rec function  phase_inv_pre (i :int) (d:angle): angle
                                                      requires{0<=i}
                                                      ensures{mod i 2 = 0 -> result = d}
                                                      ensures{mod i 2 = 1 -> result = ang_inv d}
                                                      variant{i}
  = if i = 0 then d
    else   ang_inv (phase_inv_pre (i-1) d)
  
let  function  phase_inv_ (i :int) (d:angle): angle
                                                ensures{mod i 2 = 0 -> result = d}
                                                ensures{mod i 2 = 1 -> result = ang_inv d}
  = if 0<=i  then phase_inv_pre i d
    else phase_inv_pre (-i) d

let function (-^) (d:angle)  (i :int) :angle 
                                         ensures{mod i 2 = 0 -> result = d}
                                         ensures{mod i 2 = 1 -> result = ang_inv d}
  = phase_inv_ i d
      
lemma Even_phase_inv: forall d:angle. forall i:int.  mod i 2 = 0 -> d -^ i = d
lemma Odd_phase_inv: forall d:angle. forall i:int. mod i 2 = 1 -> d -^ i = ang_inv d
lemma Gen_phase_inv:  forall k n i:int. n>=0 -> i>= 0 ->  (k /./ n) -^ i =  (power (-1) i * k)/./n
lemma Gen_phase_inv_neg:  forall k n i:int. n>=0 -> i< 0 ->   (k /./ n) -^ i =  (power (-1) (-i) * k)/./ n
lemma Ang_exp_inv: forall o:angle. ang_exp (ang_inv o) = c_one /. (ang_exp o)

let lemma ang_inv_to_conjugate (o:angle)
      ensures{ang_exp (ang_inv o) = conjugate (ang_exp o)}
  =()

let lemma exp_minus (x:complex)
      requires{real_ x}
      ensures{exp (im *. (-. x)) = conjugate (exp (im *. x))}
  =()

let lemma conjugate_to_ang_inv (o:angle)
      ensures{conjugate (ang_exp o) = ang_exp (ang_inv o)}
  =()
  
let lemma conjugate_inv_elim (o:angle)
      ensures{conjugate (ang_exp (ang_inv o)) = ang_exp o}
  =()

let lemma ang_exp_neg_conjugate (x: complex)
      requires{real_ x}
      ensures{ang_exp (real_to_ang (-.x)) = conjugate (ang_exp (real_to_ang x))}
  =()

let lemma ang_exp_neg_conjugate_rev (x: complex)
      requires{real_ x}
      ensures{conjugate (ang_exp (real_to_ang x)) = ang_exp (real_to_ang (-.x))}
  =()

let lemma ang_mult_int_in (i k n:int)
      ensures{i *.* (k /./ n) =  (i *k) /./ n}
  =()
  
let lemma ang_mult_int_out (i k n:int)
      requires{0<=n}
      ensures{(i*k) /./ n =  i *.*(k /./ n) }
  =()
  
let rec lemma int_to_ang_cycles (k n i:int)
          requires{0<=n}
          requires{0<=i}
          ensures{ (k + (i* power 2 n)) /./ n = k /./ n}
          variant{i}
  = if (i = 0) then ()
    else
      int_to_ang_cycles k n (i-1)

        use p_int.Int_comp
        use arit.Div_Mod

let lemma int_to_ang_eq (k1 k2 n1 n2: int)
      requires{k1=k2}
      requires{n1=n2}
      ensures{k1 /./ n1 = k2 /./ n2}
  =()

let rec lemma int_to_ang_cycles_neg (k n i:int)
          requires{0<=n}
          requires{0>=i}
          ensures{ (k + (i* power 2 n)) /./ n = k /./ n}
          variant{-i}
  = if (i = 0) then ()
    else
      int_to_ang_cycles_neg k n (i+1)
  
let  lemma int_to_ang_cycles_gen (k n i:int)
       requires{0<=n}
       ensures{ (k + (i* power 2 n)) /./ n = k /./ n}
  = if (i >= 0) then int_to_ang_cycles k n i else int_to_ang_cycles_neg k n i

let lemma int_to_ang_cycles_zero (n' n:int)
      requires{0<= n <= n'}
      ensures{(power 2 n') /./ n = ang_zero}
  = int_to_ang_cycles 0 n (power 2 (n'-n));
    power_sum 2 (n'-n) n

let lemma int_to_ang_cycles_zero_mult (k n' n:int)
      requires{0<= n <= n'}
      ensures{ (k * power 2 n') /./ n = ang_zero}
  = int_to_ang_cycles_zero n' n;
    assert{ (k * power 2 n') /./ n =  (k*0) /./ 1}
    
let lemma int_to_ang_cycles_zero_mult_ (k n' n:int)
      requires{0<= n <= n'}
      ensures{ (k * power 2 n') /./ n = ang_zero}
  = int_to_ang_cycles_zero n' n;
    assert{ (k * power 2 n') /./ n = (k*0)/./ 1}
    
let rec lemma int_to_ang_up (k n n':int)
          requires{0<=n}
          requires{0<=n'}
          ensures{(k * power 2 n') /./ (n+n') = k /./ n}
          variant{n'}
  = if n' = 0 then ()
    else begin
        power_plus_one 2 (n'-1);
        int_to_ang_up k n (n'-1);
      end
  
let lemma int_to_ang_mod (k n:int)
      requires{0<= n}
      ensures{(k /./ n) = ((mod k (power 2 n)) /./ n)}
  = decomp k (power 2 n);
    int_to_ang_cycles_gen (mod k (power 2 n))  n (div k (power 2 n))

let lemma int_to_ang_equiv (k1 k2 n1 n2: int)
      requires{0<=n1}
      requires{mod k1 (power 2 n1 )= mod  k2 (power 2 n1)}
      requires{n1=n2}
      ensures{k1 /./ n1 = k2 /./ n2}
  =()

let lemma int_to_ang_red (k n:int)
      requires{1<=n}
      requires{0 <> k}
      requires{mod k 2 = 0}
      ensures{k /./ n = (div k 2) /./ (n-1)}
  =()
  
let  lemma int_to_ang_bin_rev (n i j:int)
       requires{0<=n}
       requires{0<=i}
       requires{j=n-1}
       ensures{ (-(i* power 2 j))/./ n =  (i* power 2 (n-1)) /./n}
  = if (i = 0) then ()
    else ()

let  lemma int_to_ang_bin_rev_ (n i j:int)
       requires{0<=n}
       requires{0<=i}
       requires{j=n-1}
       ensures{ (-(i* power 2 j)) /./ n =  (i* power 2 (n-1))/./ n}
  = if (i = 0) then ()
    else ()
  
let lemma int_to_ang_add_rev (i j n:int)
      requires{0<= n}
      ensures{(i + j) /./ n =  (i /./ n)+.+ (j /./ n) }
  =()

let lemma int_to_ang_ind_isum_plus_one (f: int -> int) (i j n:int)
      requires{i < j}
      requires{0<= n}
      ensures{(ind_isum f i j) /./ n =  ((f i) /./ n)+.+ ((ind_isum f (i+1) j) /./ n)}
  = ()
  
let lemma int_to_ang_ind_isum_plus_one_rev (f: int -> int) (i j n:int)
      requires{i < j}
      requires{0<= n}
      ensures{(ind_isum f i j) /./ n =   ((ind_isum f (i+1) j) /./ n) +.+ ((f i) /./ n)}
  = ()

let lemma int_to_ang_ind_isum_right_extension (f: int -> int) (i j n:int)
      requires{i < j}
      requires{0<= n}
      ensures{(ind_isum f i j) /./ n =   ( (ind_isum f i (j-1))/./ n) +.+((f (j-1)) /./n)}
  = ()

let lemma int_to_ang_ind_isum_right_extension_rev (f: int -> int) (i j n:int)
      requires{i < j}
      requires{0<= n}
      ensures{(ind_isum f i j) /./ n =   (  (f (j-1))/./n) +.+ ( (ind_isum f i (j-1)) /./n)}
  = ()

let lemma minus_int_to_ang_ind_isum_plus_one (f: int -> int) (i j n:int)
      requires{i < j}
      requires{0<= n}
      ensures{ (-(ind_isum f i j))/./ n =  ( (- f i)/./ n)+.+ ( (-(ind_isum f (i+1) j)) /./n)}
  = ()
  
let lemma minus_int_to_ang_ind_isum_plus_one_rev (f: int -> int) (i j n:int)
      requires{i < j}
      requires{0<= n}
      ensures{ (-(ind_isum f i j))/./ n =   ( (-(ind_isum f (i+1) j)) /./n) +.+( (-f i) /./n)}
  = ()

let lemma minus_int_to_ang_ind_isum_right_extension (f: int -> int) (i j n:int)
      requires{i < j}
      requires{0<= n}
      ensures{ (-(ind_isum f i j)) /./ n =   ( (-(ind_isum f i (j-1)))/./ n) +.+(  (-f (j-1)) /./n)}
  = ()

let lemma minus_int_to_ang_ind_isum_right_extension_rev (f: int -> int) (i j n:int)
      requires{i < j}
      requires{0<= n}
      ensures{ (-(ind_isum f i j)) /./ n =   (  (- f (j-1))/./n)+.+ ((-(ind_isum f i (j-1)))/./ n)}
  = ()

let lemma int_to_ang_simpl (k n1 n2 :int)
      requires{n1 >= 0}
      requires{n2 >= 0}
      ensures{ (k * (power 2 n1)) /./(n2 + n1) =  (k /./ n2)}
  =()
  
let lemma ang_add_eq (d1 d2 e1 e2:angle)
      requires{d1 = e1}
      requires{d2 = e2}
      ensures{d1 +.+ d2 = e1 +.+ e2}
  =()

let lemma ang_add_comm (d1 d2 : angle)
      ensures{d1 +.+ d2 = d2 +.+ d1}
  = ()

let lemma ang_add_eq_comm (d1 d2 d3 d4: angle)
      requires{d1 = d3}
      requires{d2 = d4}
      ensures{d1 +.+ d2 =  d4 +.+ d3}
  = ang_add_comm d1 d2

let lemma ang_add_switch (a b c d: angle)
      ensures{(a +.+ b) +.+ (c +.+ d) = (a +.+ c) +.+ (b +.+ d)}
  = ()
  
let lemma ang_mult_int_zero (theta:angle)
      ensures{0*.* theta  = ang_zero}
  =()
  
let lemma ang_div (k n i:int)
      requires{n>=0}
      requires{i>=0}
      ensures{k /./ n =  (power 2 i)*.*  (k /./ (n+i))}
  = ()

let lemma ang_zero_add (d' d:angle)
      requires{d' = ang_zero}
      ensures{d' +.+  d = d}
  =()
  
let lemma int_to_ang_rev (k l n m:int)
      requires{0<n}
      requires{0<=k}
      requires{n = m+1}
      ensures{(- k * l *  power 2 m) /./ n =  (k * l*power 2 m) /./  n}
  = assert{(- k * l *  power 2 m) /./ n  =  (- k * l ) /./  1 };
    if (mod (-k *l) 2) = 0 then
      begin
        assert{(- k * l *  power 2 m) /./ n  = 0 /./ 1 };
        assert{mod (-k *l) 2 = 0};
        assert{( k * l *  power 2 m) /./ n  = 0 /./ 1 };
      end
    else
      begin
        assert{(- k * l *  power 2 m) /./ n  = (-1) /./ 1  = 1 /./ 1 };
        assert{mod (-k *l) 2 = 1};
        assert{( k * l *  power 2 m) /./ n  = 1 /./ 1 };
      end
    
let lemma int_to_ang_rev_ (k l n m:int)
      requires{0<n}
      requires{0<=k}
      requires{0<=l}
      requires{n = m+1}
      ensures{(- k * l *  power 2 m) /./ n =  (k * l*power 2 m)/./ n}
  =
  assert{power 2 m = power 2 m};
  assert{power 2 n = power 2 n};
  int_to_ang_rev k l n m 
  
let lemma ang_add_zero_d (d' d:angle)
      requires{d' = ang_zero}
      ensures{d +.+  d' = d}
  =()

let lemma real_to_ang_distr_minus()
      ensures{forall x z t: complex. forall y:int. real_ x -> real_ z -> real_ t ->    (real_to_ang (x*.(i_to_c y)))+.+ (real_to_ang ((i_to_c y)*. -. z *. t))
                                                                                       = y *.* (real_to_ang (x-. (z *. t))) }
  =()
  
let rec lemma ang_mult_int_exp_pos  (o: angle) ( i:int)
          requires{0<=i}
          ensures{ang_exp (i*.* o ) = cpower (ang_exp o) i}
          variant{i}
  = if i = 0 then ()
    else
      begin
        assert{0<i};
        ang_mult_int_exp_pos o (i-1)
      end
  
let  lemma ang_mult_int_exp  (o: angle) ( i:int)
       ensures{ang_exp (i *.* o ) = cpower (ang_exp o) i}
  = if  0<=i then ang_mult_int_exp_pos o i
    else ang_mult_int_exp_pos o  (-i)

let lemma ang_mult_int_exp_rev (o:angle) (i:int)
      ensures{cpower (ang_exp o) i = ang_exp (i *.* o)}
  =()

let lemma cpower_ang_exp_real (x: complex) (i:int)
      requires{real_ x}
      ensures{cpower (ang_exp (real_to_ang x)) i = ang_exp (real_to_ang  (x *. i_to_c i))}
  =()

let lemma ang_mult_int_add (o:angle) (i i':int)
      ensures{ (i+i') *.* o= (i *.* o) +.+  ( i' *.* o)}
  =()

let lemma ang_mult_int_plus_one (o:angle) (i :int)
      ensures{o +.+ (i *.* o) = (i+1) *.* o}
  =()

let lemma ang_mult_int_plus_one_rev (o:angle) (i :int)
      ensures{(1+i) *.* o = o +.+ (i *.* o)}
  =()
  
let lemma ang_mult_int_double (o:angle)(i:int)
      ensures{(2*i) *.* o = (i *.* o) +.+  (i *.* o)}
  =()

let lemma ang_mult_int_inv_one (o:angle)
      ensures{(-1) *.* o = ang_inv o}
  =()

let lemma ang_mult_int_one (o:angle)(n:int)
      requires{n = 1}
      ensures{n *.* o =  o}
  =()

let lemma ang_mult_int_inv_rev (o:angle)
      ensures{ang_inv o = (-1) *.* o}
  =()

let lemma ang_mult_int_comp (o:angle) (i j:int)
      ensures{j *.* (i *.* o)  =  (i*j)*.*o}
  =()

let lemma ang_mult_int_comp_rev (o:angle) (i j:int)
      ensures{ (i*j)*.*o = j*.* (i *.* o) }
  =()

let rec lemma add_ang_mult_int_pos (o o':angle) (i:int)
          requires{0<=i}
          ensures{(i *.* o) +.+  (i *.*  o' ) =  (i *.* (o +.+ o') )}
          variant{i}
  = if i = 0 then ()
    else
      begin
        assert {0<i};
        add_ang_mult_int_pos o o' (i-1)
      end
  
let lemma add_ang_mult_int (o o':angle) (i:int)
      ensures{(i *.* o) +.+  (i *.* o') =  (i *.* (o +.+ o'))}
  = if 0<=i  then  add_ang_mult_int_pos o o' i
    else  add_ang_mult_int_pos o o' (-i)
  
let function ang_substr (o o':angle)
  = o +.+ (ang_inv o')

let function (-.-) (o o':angle)
  = ang_substr o o'
  
let lemma ang_substr_inv (o o':angle)
      ensures{ o -.- ((-1) *.* o' ) = o +.+ o'}
  =()
  
let lemma ang_mult_int_distr (o o':angle) (n:int)
      ensures{ang_mult_int  (o +.+ o') n  =  (n *.* o)+.+ (n *.* o' ) }
  =()

let lemma ang_mult_int_distr_rev (o :angle) (n1 n2:int)
      ensures{ (n1 *.* o)+.+ (n2 *.* o) =  (n1 +n2) *.*o}
  =()

let lemma ang_add_assoc (o o' o'':angle)
      ensures{o +.+ (o' +.+  o'') =  (o +.+ o') +.+ o'' }
  =()

let lemma ang_add_assoc_rev (o o' o'':angle)
      ensures{(o +.+ o')+.+ o'' = o +.+ (o' +.+  o'')}
  =()

let lemma ang_add_own_inv (o :angle)
      ensures{((-1) *.* o) +.+ o = ang_zero }
  =()

let lemma ang_exp_inv (o:angle)
      ensures{ang_exp(ang_inv o) = conjugate (ang_exp o)}
  =()

     use arit.Evenness
  
let lemma ang_exp_one_one()
      ensures{ang_exp (1/./1) =  -. c_one}
  =()

let lemma int_to_ang_one_even(k:int)
      requires{even k}
      ensures{k/./1 = ang_zero}
  =()

let lemma int_to_ang_one_odd(k:int)
      requires{odd k}
      ensures{k/./1 = ang_minus_one}
  =()

let lemma ang_exp_one_one_expo(i:int)
      requires{0<=i}
      ensures{ang_exp (i *.* (1/./1) ) =  if even i then c_one else -. c_one}
  =()

let  lemma int_to_ang_zero_den  (k n:int)
       requires {n=0}
       ensures{k/./n=ang_zero}
  = real_to_ang_int_ k
  
let lemma int_to_ang_minus_up (k n :int)
      ensures{k/./ (-n) = (-k) /./ n}
  =()


let lemma int_to_ang_minus_down (k n :int)
      ensures{(-k)/./ (-n) = k /./ n}
  =()
  
let lemma int_to_ang_inv (k n :int)
      ensures{ang_inv (k/./ n) = k /./ (-n)}
  =()

let lemma int_to_ang_inv_rev (k n :int)
      ensures{k/./ (-n) = ang_inv (k /./ n)}
  =()

let lemma int_to_ang_inv_add (k n :int)
      ensures{(k/./ n) +.+ (k /./ (-n)) = ang_zero}
  =()

let lemma ang_mult_int_neutral (theta : angle) (n:int)
      requires{theta= ang_zero}
      ensures{n*.*theta = ang_zero}
  =()
  
let lemma phase_inv_neutral (theta : angle) (n:int)
      requires{theta= ang_zero}
      ensures{theta-^n = ang_zero}
  =()
end
     
module Ang_sum

         use Angle
         use int.Int
         use fsum.Iterations
         use complex.Complex
         use fsum.Int_iter
         use p_set.IndexestoSet
         use functions.MapInjection
         use int_expo.Int_Exponentiation
         use complex_operations.FromInt
         use binary.Bit_vector_inversions
         use extr_int.Ind_isum
        
let  function ang_sum (f : int -> angle) (i j:int):angle
  =
  if j<= i then ang_zero else int_iterate (+.+) f i j
  
let lemma ang_sumto_int_iterate (f: int -> angle) (i j:int)
      requires{i < j}
      ensures{ang_sum f i j = int_iterate (+.+) f i j}
  =()
  
let lemma ang_sum_plus_one (f :int -> angle) (i:int) (j:int) 
      requires{i +1 < j}
      ensures{ ang_sum f i j =  (f i)+.+(ang_sum f (i+1) j)}
  = int_iterate_def_plus_one (+.+) f i j

let lemma ang_sum_cardone (f :int -> angle) (i:int) (j:int) 
      requires{j = i+1}
      ensures{ang_sum f i j =  f i}
  =int_iterate_cardone (+.+) f i j

let lemma ang_sum_cardone_p (f :int -> angle) (i:int) (j:int)  (r: angle)
      requires{j = i+1}
      requires{f i = r}
      ensures{r =ang_sum f i j}
  =int_iterate_cardone (+.+) f i j

let rec lemma ang_sum_neutral (f :int -> angle) (i:int) (j:int) 
          requires{i <= j}
          requires{forall k:int. i<= k < j -> f k = ang_zero}
          ensures{ang_sum f i j =  ang_zero}
          variant{j-i}
  =
  if j = i then ()
  else  if j = i +1
  then ang_sum_cardone f i j
  else
    begin
      ang_sum_plus_one f i j;
      ang_sum_neutral f (i+1) j;
    end

let lemma ang_sum_def_plus_one_com (f :int -> angle) (i:int) (j:int) 
      requires{i +1 < j}
      ensures{  (f i)+.+( ang_sum f (i+1) j) = ang_sum f i j }
  =int_iterate_def_plus_one_com (+.+) f i j
  
let rec lemma ang_sum_right_extension  (f : int -> angle) (i j : int)
          requires{i +1 < j }
          ensures  { (ang_sum f i j) =  ( (ang_sum f i (j-1)) +.+ (f (j-1))) }
          variant{j - (i+1)}
  = if i+ 2 = j then ()
    else begin
        ang_sum_plus_one f i j;
        ang_sum_plus_one f i (j-1);
        ang_sum_right_extension f (i+1) j;
      end

let  lemma ang_sum_re  (f : int -> angle) (i j : int)
          requires{i +1 <= j }
          ensures  { (ang_sum f i j) =  ( (ang_sum f i (j-1)) +.+ (f (j-1))) }
  = if i+1 < j then ang_sum_right_extension f i j
    else     ()
  
let  lemma ang_sum_transitivity  (f : int -> angle) (i k j : int)
       requires {i < k < j}
       ensures  { ang_sum f i j =   (ang_sum f i k) +.+ (ang_sum f k j) }
  = int_iterate_transitivity_ (+.+) f i k j
  
let lemma ang_sum_eq  (f g : int -> angle) (i j:int)
      requires{i <= j}
      requires{forall k : int. i <= k < j -> f k = g k}
      ensures{ ang_sum  f i j = ang_sum  g i j}
  = if i = j then () else
      int_iterate_eq (+.+) f g i j

let lemma ang_sum_int_to_ang  (f g : int -> angle) (i j :int)
      requires{i < j}
      requires{forall k : int. i <= k < j -> f k = g k}
      requires{exists n. forall k : int. exists j j'. f k = j /./ n /\ g k = j' /./ n /\ j = j'}
      ensures{ ang_sum f i j = ang_sum  g i j}
  = ()

let lemma vang_sum_eq  (f g : int -> angle) (i j:int)
      requires{i < j}
      requires{forall k : int. i <= k < j -> f k = g k}
      ensures{ang_exp (ang_sum  f i j) = ang_exp (ang_sum  g i j)}
  = ()

      use matrices.Matrix
      use matrices.Matrix_scalar

let lemma vang_sum_scal_eq  (f g : int -> angle) (m n: matrix complex) (i j:int)
      requires{i < j}
      requires{m = n}
      requires{forall k : int. i <= k < j -> f k = g k}
      ensures{ang_exp (ang_sum  f i j) *.. m = ang_exp (ang_sum  g i j) *.. n}
  = ()

let rec lemma ang_sum_inv  (f  :int -> angle) (i j:int)
          ensures{ang_inv (ang_sum f i j) = ang_sum (fun k -> ang_inv (f k)) i j}
          variant{j-i}
  = if (j<= i) then ()
    else
      if ( i+1=j) then ()
      else
        begin
          assert{i+1<j};
          ang_sum_plus_one f i j;
          ang_sum_plus_one (fun k -> ang_inv (f k))  i j;
          ang_inv_add (ang_sum f (i+1) j) (f i);
          ang_sum_inv f (i+1) j;
        end
  
let lemma ang_sum_plus_one_p (f g :int -> angle) (i:int) (j l m:int) (r:angle)
      requires{i +1 < j}
      requires{l = i+1}
      requires{m = j}
      requires{ g i = r}
      requires{forall k : int. i+1 <= k < j -> f k = g k} 
      ensures{   r +.+ ( ang_sum f l m) = ang_sum g i j} 
  =()

let lemma vang_sum_plus_one_p (f g :int -> angle) (i:int) (j l m:int) (r:angle)
      requires{i +1 < j}
      requires{l = i+1}
      requires{m = j}
      requires{ g i = r}
      requires{forall k : int. i+1 <= k < j -> f k = g k} 
      ensures{  ang_exp r *. ang_exp ( ang_sum f l m) = ang_exp (ang_sum g i j)} 
  =()

let lemma vang_sum_plus_one_rev (f g :int -> angle) (i:int) (j l m:int) (r:angle)
      requires{i +1 < j}
      requires{l = i+1}
      requires{m = j}
      requires{ g i = r}
      requires{forall k : int. i+1 <= k < j -> f k = g k} 
      ensures{ang_exp (ang_sum g i j) =   ang_exp r *. ang_exp ( ang_sum f l m)} 
  =()

let lemma ang_sum_right_extension_p (f g :int -> angle) (i:int) (j l m:int) (r:angle)
      requires{i +1 < j}
      requires{m = j-1}
      requires{l = i}
      requires{ g (j-1) = r}
      requires{forall k : int. i <= k < j -1 -> f k = g k} 
      ensures{( ang_sum f l m) +.+ r = ang_sum g i j} 
  =()

let lemma vang_sum_right_extension_p (f g :int -> angle) (i:int) (j l m:int) (r:angle)
      requires{i +1 < j}
      requires{m = j-1}
      requires{l = i}
      requires{ g (j-1) = r}
      requires{forall k : int. i <= k < j -1 -> f k = g k} 
      ensures{  ang_exp  ( ang_sum f l m) *. ang_exp r = ang_exp ( ang_sum g i j)} 
  =()

let lemma vang_sum_right_extension_rev (f g :int -> angle) (i:int) (j l m:int) (r:angle)
      requires{i +1 < j}
      requires{m = j-1}
      requires{l = i}
      requires{ g (j-1) = r}
      requires{forall k : int. i <= k < j -1 -> f k = g k} 
      ensures{ ang_exp ( ang_sum g i j) =  ang_exp  ( ang_sum f l m) *. ang_exp r} 
  =()

let lemma ang_sum_cardzero (f: int -> angle) (i j:int)
      requires{j <= i}
      ensures{ang_sum f i j = ang_zero}
  = ()

let lemma ang_sum_eq_gen  (f g : int -> angle) (i j i' j':int)
      requires{i < j}
      requires{i = i'}
      requires{j = j'}
      requires{forall k : int. i <= k < j -> f k = g k}
      ensures{ ang_sum  f i j = ang_sum  g i' j'}
  = ang_sum_eq f g i j

      use p_int.Int_comp

let lemma ang_sum_sum_eq_vl  (f g : int -> (int -> angle)) (i j i' j' l  l':int)
      requires{i < j}
      requires{j <= l}
      requires{i = i'}
      requires{j = j'}
      requires{l = l'}
      requires{forall x x' : int. i <= x < j ->  x <= x' < l -> f x x' = g x x'}
      ensures{ ang_sum  (fun x -> ang_sum (f x) x l ) i j = ang_sum  (fun x -> ang_sum (g x) x l' ) i' j' }
  = ()

let rec lemma ang_sum_minus  (f : int -> int) (i j n: int)
          requires{n>=0}
          requires{i  < j }
          ensures  { (ang_sum (fun k ->  (-  f k) /./ n) i j) =  (- ind_isum f i j) /./ n }
          variant{j - (i+1)}
  = if i+ 1 = j then
      begin
        ang_sum_cardone (fun k ->  (-  f k) /./ n) i j;
        ind_isum_one f i j;
      end
    else
      begin
        ang_sum_plus_one (fun k ->  (-  f k) /./ n) i j;
        ind_isum_plus_one f i j;
        ang_sum_minus f (i+1) j n;
        ang_sum_minus f i (i+1) n;
      end

        use binary.Bit_vector
  
let lemma multiple_control_as_ang_sum (n:int)
      requires{0<n}
      ensures{forall x: bitvec. length x = n -> (if (forall j . 0<= j< n -> getbv x j = 1) then ang_minus_one else ang_zero) =  ( (ind_iproduct ( getbv x ) 0 n)*.*  ang_minus_one)}
  =()

let lemma multiple_control_as_ang_sum_rev (n:int)
      requires{0<n}
      ensures{forall x: bitvec. length x = n -> ((ind_iproduct (getbv x) 0 n)) *.*  ang_minus_one  = (if (forall j . 0<= j< n -> getbv x j = 1) then ang_minus_one else ang_zero)}
  =()

let  lemma ang_sum_map  (i j k l:int)(f: int -> int)(t: int -> angle)
       requires{i < j}
       requires{p_bijective f (to_fset i j)  (to_fset k l) }
       ensures{ang_sum t k l    = ang_sum (fun b -> t (f b))  i j}
  = int_iterate_map (+.+)  i j k l f t

let rec lemma ang_sum_break (f: int -> angle) (i j y:int)
          requires{i <= y <= j}
          ensures{ang_sum f i j = (ang_sum f i y) +.+ (ang_sum f y j)}
          variant{y - i}
  = if (y = i) then ()
    else
      if (y = j-1)
      then ()
      else
        if (y = i + 1)
        then
          ang_sum_cardone f i y
        else
          begin
            ang_sum_right_extension f i y;
          end

let rec lemma ang_sum_break_zero_l (f: int -> angle) (i j y:int)
          requires{i <= y <=j}
          requires{forall k:int. i<= k < y -> f k = ang_zero}
          ensures{ang_sum f y j = ang_sum f i j}
  =ang_sum_break f i j y

let rec lemma ang_sum_break_zero_lg (f g: int -> angle) (i j y:int)
          requires{i <= y <=j}
          requires{forall k:int. i<= k < y -> f k = ang_zero}
          requires{forall k:int. i <= k < j -> f k = g  k}
          ensures{ang_sum f y j = ang_sum g i j}
  =ang_sum_break f i j y
  
let rec lemma ang_sum_break_zero_lg_params (f g: bitvec -> bitvec-> int -> int -> angle) (i j  s r:int)
          requires{s>=0}
          requires{r>=0}
          requires{forall x z: bitvec. forall  a k:int. length x = s -> length z = r -> i<= a < j-> i<= k < a -> g x z a k = ang_zero}
          requires{forall x z: bitvec. forall  a k:int. length x = s -> length z = r ->  i<= a < j-> a<= k < j -> f x z a k = g x z a k}
          ensures{forall x z: bitvec. forall a:int. length x = s -> length z = r -> i<= a < j ->  ang_sum (fun k -> f x z a k) a j = ang_sum  (fun k -> g x z a k) i j}
  =()

let rec lemma ang_sum_break_zero_l_params (f g:  'a -> 'a -> int -> angle) (i j l:int)
          requires{i <= l <=j}
          ensures{forall x y :'a. (forall k:int. i <= k < l -> f x y k = ang_zero) ->
                              (forall k:int. i <= k < j -> f x y k = g x y k) ->
                              ang_sum (g x y) i j = ang_sum (f x y) l j }
  =()
  
let lemma ang_sum_break_param (f: int -> int -> angle) (i j:int)
      requires{i < j}
      ensures{forall y:int. i <= y < j -> ang_sum (f y) i j =  (ang_sum (f y) i y)+.+ (ang_sum (f y) y j)}
  = ()            

let lemma ang_sum_neutral_param_r (f :int -> int -> angle) (i:int) (j:int) 
      requires{i < j}
      ensures{forall y:int. i<= y < j ->  (forall k:int.   y<= k < j -> f y k = ang_zero) -> ang_sum (f y) y j = ang_zero}
  =  ()

let lemma ang_sum_neutral_param_l (f :int -> int -> angle) (i:int) (j:int) 
      requires{i < j}
      ensures{forall y:int. i<= y < j ->  (forall k:int.   i<= k < y -> f y k = ang_zero ) -> ang_sum (f y) i y = ang_zero}
  =  ()  
   
let rec lemma ang_sum_transl (f: int -> angle)(i j k:int)
          requires{i < j}
          ensures{ang_sum f i j  = ang_sum (fun b ->  f (b + k))  (i-k) (j-k)}
          variant{j-i}
  =
  if (i + 1 = j) then
    begin
      ang_sum_cardone f i j;
      ang_sum_cardone (fun b ->  f (b + k))  (i-k) (j-k);
    end
  else
    begin
      ang_sum_plus_one f i j;
      ang_sum_plus_one (fun b ->  f (b + k))  (i-k) (j-k);
      ang_sum_transl f (i+1) j k;
    end
  
let lemma ang_sum_transl_one (f: int -> angle)(i j:int)
      requires{i < j}
      ensures{ang_sum f i j  = ang_sum (fun b ->  f (b - 1))  (i+1) (j+1)}
  = ang_sum_transl  f i j (-1)

let rec lemma ang_sum_to_ind_isum (f: int-> int) (n i j:int)
          requires{0<=n}
          requires{i < j}
          ensures{ang_sum (fun k ->  (f k) /./ n) i j = (ind_isum f i j) /./ n}
          variant{j-i}
  =
  if (j = i+1)
  then ()
  else
    begin
      ang_sum_plus_one (fun k ->  (f k) /./ n) i j;
      ind_isum_plus_one f i j;
      ang_sum_to_ind_isum f n (i+1) j;
    end
  
let  lemma ind_isum_to_d_sum (f: int-> int) (n i j:int)
       requires{0<=n}
       requires{i < j}
       ensures{(ind_isum f i j) /./ n = ang_sum (fun k ->  (f k) /./ n) i j}
  = ()

      use binary.Bit_vector_decomp
      use binary.Binary_Op
  
let lemma ang_sum_int_decomp (bvx : int-> int) (k n :int)
      requires{0<n}
      requires{binary bvx}
      ensures{ang_sum (fun x ->  ((bvx x) * power 2 (n- x-1) * k) /./n) 0 n
              =  (bin_to_int bvx n * k) /./ n}
  =()
  
let lemma ang_sum_int_decomp_gen (bvx : int-> int) (n :int)
      requires{0<n}
      requires{binary bvx}
      ensures{forall k: int. ang_sum (fun x ->  ((bvx x) * power 2 (n- x-1) * k) /./n) 0 n
                        =  (bin_to_int bvx n * k) /./n}
  =()  

let lemma ang_sum_bv_to_int  (n :int)
      requires{0<n}
      ensures{forall x:bitvec. forall k: int.length x = n ->  ang_sum (fun i ->  (getbv  x i * power 2 (n- i-1) * k) /./n) 0 n
                                                              = (bv_to_int x  * k) /./n}
  = ()
  
let lemma ang_sum_bv_to_int_  (n :int)
      requires{0<n}
      ensures{forall x:bitvec. forall k: int.length x = n ->  ang_sum (fun i -> (getbv  x i * power 2 (n- i-1) * k) /./n) 0 n
                                                              = (bv_to_int x  * k) /./n}
  = ()

let lemma ang_sum_sum_bv_to_int_mult (n:int) (x y: bitvec)
      requires{0<n}
      requires{length x = n}
      requires{length y = n}
      ensures{ang_sum  (fun target -> ang_sum  (fun k ->   ( getbv y k  * getbv x  target 
                                                             * power 2 ((n-k-1)+(n-target-1)) )/./ n ) (n-target-1) n) 0 n
              =  (bv_to_int x * bv_to_int y) /./n}
  =
  assert{ang_sum  (fun target -> ang_sum  (fun k ->  ( getbv y k  * getbv x  target 
                                                       * power 2 ((n-k-1)+(n-target-1)) )/./ n ) (n-target-1) n) 0 n =
           ang_sum  (fun target ->    ( getbv x  target* power 2 (n-target-1) * bv_to_int y)/./ n) 0 n}

let lemma ang_sum_sum_bv_to_int_mult_gen (n:int)
      requires{0<n}
      ensures{forall x y: bitvec. length x = n -> length y = n ->
                          ang_sum  (fun target -> ang_sum  (fun k ->   ( getbv y k  * getbv x  target 
                                                                         * power 2 ((n-k-1)+(n-target-1)) )/./ n ) (n-target-1) n) 0 n
                          =  (bv_to_int x * bv_to_int y) /./n}
  =()

let lemma ang_sum_int_decomp_gen_rev (bvx : int-> int) (n :int)
      requires{0<n}
      requires{binary bvx}
      ensures{forall k: int.
                        (bin_to_int bvx n * k) /./n
                        = ang_sum (fun x ->  ((bvx x) * power 2 (n- x-1) * k)/./ n) 0 n}
  =()  

let rec lemma sum_ang_mult_int_e  (o: angle) (f: int-> int)( l h:int)
          ensures{ang_sum (fun i ->  ( f i)*.*o) l h =
                    (ind_isum f l h)*.*o}
          requires{l < h}
          variant{h-l}
  =
  if l + 1 = h
  then
    begin
      ang_sum_cardone (fun x ->  (f x)*.*o ) l h;
      ind_isum_one f l h;
    end
  else
    begin
      ang_sum_plus_one (fun x ->   (f x)*.*o )l h;          
      ind_isum_plus_one f l h ;         
      ang_mult_int_add o (f l) (ind_isum f (l+1) h);
      sum_ang_mult_int_e o f  (l+1) h;
    end

      use complex_operations.Base_type

let rec lemma real_to_ang_sum (phi : int -> complex) (l h:int)
          requires{l<h}
          requires{forall i: int. l<= i < h -> real_ (phi i)}
          ensures{ang_sum (fun i-> real_to_ang (phi i)) l h = real_to_ang (ind_sum phi l h)}
          variant{h-l}
  =
  if l + 1 = h then
    begin
      ind_sum_cardone phi l h;
    end
  else
    begin
      real_to_ang_sum phi (l+1) h;
      ind_sum_plus_one phi l h
    end
  
let rec lemma real_to_ang_sum_int (f : int -> int) (l h:int) (x: complex)
          requires{l<h}
          requires{real_ x}
          ensures{ang_sum (fun i-> real_to_ang (x *. i_to_c (f i)) ) l h = real_to_ang ( x *. i_to_c (ind_isum f l h))}
          variant{h-l}
  =
  if l + 1 = h then
    begin
      ang_sum_cardone (fun i-> real_to_ang (x *. i_to_c (f i) )) l h;
      ind_isum_one f l h;
    end
  else
    begin
      real_to_ang_sum_int f (l+1) h x;
      ang_sum_plus_one (fun i-> real_to_ang (x *. i_to_c (f i) )) l h;
      ind_isum_plus_one f l h
    end

let lemma real_to_ang_sum_int_gen (f : int -> int) (l h:int) 
      requires{l<h}
      ensures{forall x. real_ x -> ang_sum (fun i-> real_to_ang (x *. i_to_c (f i)) ) l h = real_to_ang ( x *. i_to_c (ind_isum f l h))}
  = ()
  
let  lemma real_to_ang_bv_inversion (ft:int) (x: complex) (y : bitvec)
       requires{0<ft}
       requires{real_ x}
       requires{length y = ft}
       ensures{ang_sum (fun i-> real_to_ang (x *. i_to_c (power 2 i) *. i_to_c (getbv y i) )) 0 ft = real_to_ang ( x *. i_to_c (bv_to_int (bv_inversion y)))}
  =
  bv_to_int_inversion_sum_inc y;
  real_to_ang_sum_int (fun i -> getbv y i * power 2 i) 0 ft x

let rec lemma sum_ang_mult_int  (f : int -> angle) (i l h:int)
          requires{l < h}
          ensures{ang_sum (fun x -> i *.* (f x) ) l h = i *.* (ang_sum f l h) }
          variant{h-l}
  =
  if l + 1 = h
  then
    begin
      ang_sum_cardone (fun x -> i *.* (f x) ) l h;
      ang_sum_cardone f l h;
    end
  else
    begin
      ang_sum_plus_one (fun x -> i *.* (f x) ) l h;          
      ang_sum_plus_one f l h ;         
      add_ang_mult_int (f l) ( ang_sum f (l+1) h) i;
      add_ang_mult_int (i *.* (f l)) ( ang_sum (fun x -> i *.* (f x) ) (l+1) h) i;
      sum_ang_mult_int f i (l+1) h;
    end

let lemma ang_sum_bv_to_int_inversion_pre  (n :int) (x:bitvec)
      requires{0<n}
      requires{length x = n}
      ensures{forall theta: complex. real_ theta ->
                            real_to_ang (theta *. i_to_c (bv_to_int (bv_inversion x)))  =
                              ang_sum (fun i -> real_to_ang ((theta *. i_to_c  ( power 2 i)) *. i_to_c (getbv  x i ))) 0 n}
  =   real_to_ang_sum_int_gen (fun i -> power 2 i * getbv x i) 0 n 

let lemma ang_sum_bv_to_int_inversion  (n :int)
      requires{0<n}      
      ensures{forall x:bitvec.forall theta: complex.length x = n -> real_ theta ->
                                            real_to_ang (theta *. i_to_c (bv_to_int (bv_inversion x)))  =
                                              ang_sum (fun i -> real_to_ang ((theta *. i_to_c  ( power 2 i)) *. i_to_c (getbv  x i ))) 0 n}
  = ()
  
let lemma ang_sum_bv_to_int_opp_pre  (n :int) (x:bitvec)
      requires{0<n}
      requires{length x = n}
      ensures{forall theta: complex. real_ theta ->
                            real_to_ang (theta *.  (i_to_c (- (bv_to_int x))))  =
                              ang_sum (fun i -> real_to_ang ((theta *. i_to_c  ( power 2 (n-i-1))) *. i_to_c (- getbv  x i ))) 0 n}
  =   real_to_ang_sum_int_gen (fun i -> power 2 (n-i-1) * (- getbv x i)) 0 n 

let lemma ang_sum_bv_to_int_opp  (n :int) 
      requires{0<n}
      ensures{forall x:bitvec.forall theta: complex.length x = n -> real_ theta ->
                                            real_to_ang (theta *.  (i_to_c (- (bv_to_int x))))  =
                                              ang_sum (fun i -> real_to_ang ((theta *. i_to_c  ( power 2 (n-i-1))) *. i_to_c (- getbv  x i ))) 0 n}
  =   ()
    
let lemma ang_sum_bv_to_int_mult_pre  (n :int) (x:bitvec)
      requires{0<n}
      requires{length x = n}
      ensures{forall theta: complex. real_ theta ->
                            real_to_ang (theta *.  (i_to_c ( (bv_to_int x))))  =
                              ang_sum (fun i -> real_to_ang ((theta *. i_to_c  ( power 2 (n-i-1))) *. i_to_c ( getbv  x i ))) 0 n}
  =   real_to_ang_sum_int_gen (fun i -> power 2 (n-i-1) * (getbv x i)) 0 n 

let lemma ang_sum_bv_to_int_mult  (n :int) 
      requires{0<n}
      ensures{forall x:bitvec.forall theta: complex.length x = n -> real_ theta ->
                                            real_to_ang (theta *.  (i_to_c ((bv_to_int x))))  =
                                              ang_sum (fun i -> real_to_ang ((theta *. i_to_c  ( power 2 (n-i-1))) *. i_to_c (getbv  x i ))) 0 n}
  =   ()

let lemma rewrite_ang_sum_sum_to_bv_and_inversion (n:int) (x y: bitvec)
      requires{0<n}
      requires{length x = n}
      requires{length y = n}
      ensures{ang_sum (fun j -> ang_sum (fun i ->   (- getbv x i * getbv y j * power 2 (n-i-1+j)) /./ n) j n) 0 n
              = real_to_ang ((i_to_c (- bv_to_int x)) *. i_to_c (bv_to_int (bv_inversion y)) /. (i_to_c (power 2 n))) }
  = ang_sum_break_zero_lg_params  (fun x y j i ->   (- getbv x i * getbv y j * power 2 (n-i-1+j)) /./ n)
      (fun x y j i ->  ((- getbv x i * power 2 (n-i-1)) * (getbv y j * power 2 j)) /./n)
      0 n n n;
    assert{ang_sum (fun j -> ang_sum (fun i ->   (- getbv x i * getbv y j * power 2 (n-i-1+j)) /./ n) j n) 0 n =
             ang_sum (fun j -> ang_sum (fun i -> real_to_ang  ( (( i_to_c (power 2  j * getbv y j)  *.  i_to_c (power 2 (n-i-1))) *. i_to_c (- getbv x i))/. i_to_c (power 2 n))) 0 n) 0 n};
    ang_sum_bv_to_int_opp n;
    assert{ang_sum (fun j -> ang_sum (fun i ->   (- getbv x i * getbv y j * power 2 (n-i-1+j)) /./ n) j n) 0 n =
             ang_sum (fun j ->  real_to_ang ( i_to_c (power 2  j * getbv y j)  *.  i_to_c (- (bv_to_int x)) /. i_to_c (power 2 n))  ) 0 n};
    ang_sum_bv_to_int_inversion n
      
      use qdata.Sqrt_two

let lemma rewrite_ang_sum_sum_to_bv_and_inversion_gen (n:int)
      requires{0<n}
      ensures{forall x y: bitvec. length x = n -> length y = n ->
                          ang_sum (fun j -> ang_sum (fun i ->   (- getbv x i * getbv y j * power 2 (n-i-1+j)) /./ n) j n) 0 n
                          = real_to_ang ((i_to_c (- bv_to_int x)) *. i_to_c (bv_to_int (bv_inversion y)) *.pow_inv_2 n) }
  =()

let lemma int_to_ang_by_sum_mult_break(n:int) (x y: bitvec)
      requires{0<n}
      requires{length x = n}
      requires{length y = n}
      ensures{ (ind_isum (fun j -> ind_isum (fun i ->  getbv x i * getbv y j * power 2 (n-i-1+j)) j n) 0 n) /./n
               =  (bv_to_int x * bv_to_int (bv_inversion y)) /./n}
  = rewrite_ang_sum_sum_to_bv_and_inversion n x y
  
let lemma int_to_ang_by_sum_mult_break_gen (n:int) 
      requires{0<n}
      ensures{forall x y: bitvec. length x = n -> length y = n ->
                          (ind_isum (fun j -> ind_isum (fun i -> getbv x i * getbv y j * power 2 (n-i-1+j)) j n) 0 n)  /./n
                          =  ( bv_to_int x * bv_to_int (bv_inversion y))  /./ n}
  = ()

let lemma int_to_ang_by_sum_mult_break_neg (n:int) 
      requires{0<n}
      ensures{forall x y: bitvec. length x = n -> length y = n ->
                          (ind_isum (fun j -> - ind_isum (fun i -> getbv x i * getbv y j * power 2 (n-i-1+j)) j n) 0 n)  /./n
                          =  (- bv_to_int x * bv_to_int (bv_inversion y)) /./ n}
  = ()
end


module Bin_check_zero
         
         use Angle
         use int.Int
         use binary.Binary_Op
         use binary.Bit_vector_decomp
         use int_expo.Int_Exponentiation
         use binary.Bv_to_int_ext
     
let rec function bin_check_zero (x:int -> int) (n:int)
                   requires{0<=n}
                   requires{binary_l x n}
                   ensures{result = if (forall j . 0<= j< n ->  x j = 1) then ang_minus_one else ang_zero}
                   variant{ n}
  = if n  = 0 then  ang_minus_one else 
      if n  = 1 then if  x 0 = 1 then ang_minus_one else ang_zero
      else if  x 0 = 1 then (bin_check_zero (fun i ->  x (i+1)) (n-1)) else ang_zero

  
let lemma bin_check_zero_int  (i n:int)
      requires{0<= n}
      requires{0<= i < power 2 n}
      ensures{bin_check_zero (int_to_bin i n) n =  if i = power 2 n -1  then ang_minus_one else ang_zero}
  = ()
  
let lemma  bin_check_zero_plus_one (x:int -> int) (n:int)
      requires{binary_l x n}
      requires{1< n }
      ensures{bin_check_zero x n = if  x 0 = 1 then (bin_check_zero (fun i ->  x (i+1)) (n-1)) else ang_zero}
  =()
  
  
let lemma  bin_check_zero_two  (x:int -> int)
      requires{ binary_l x  2}
      ensures{bin_check_zero x 2 = if  x 0 =  x 1 = 1 then ang_minus_one else ang_zero}
  =()
  
end

module Real_to_complex_trig
         use  complex.Complex
         use  complex_operations.FromInt
         use complex_expo.Complex_exp
         use complex_expo.Complex_Exponentiation
         use matrices.Matrix
         use int.Int
         use qdata.Qreg
         use Angle
     
let function complex_as_a_vector (x: complex): matrix complex
                                                 ensures{is_a_ket_l result 1}
                                                 ensures{ket_norm_l result 1 = modulus x}
  = make_f 2 1 (fun i _ -> if i = 0 then t_real_part x else t_im_part x)
  
let function sin    (x: complex)
               requires{real_ x}
               ensures{real_ result}
  =  t_im_part (exp (im *. x))

let function cos    (x: complex)
               requires{real_ x}
               ensures{real_ result}
  =  t_real_part (exp (im *. x))

       lemma euler_real_r : forall x: complex. real_ x -> cos x = r_to_c (real_part (exp (im *. x)))
                                                                    lemma euler_im_r : forall x: complex. real_ x -> sin x = r_to_c (im_part (exp (im *. x)))
                                                                                                                               lemma cos_zero : cos c_zero = c_one
                                                                                                                                                               lemma cos_half_pi : cos (pi /. ttwo) = c_zero
                                                                                                                                                                                                        lemma cos_quarter_pi : cos (pi /. (i_to_c 4)) = (squarert_two /. ttwo)
                                                                                                                                                                                                                                                          lemma cos_pi : cos pi = -. c_one
                                                                                                                                                                                                                                                                                       lemma sin_zero : sin c_zero = c_zero
                                                                                                                                                                                                                                                                                                                       lemma sin_half_pi : sin (pi /. ttwo) = c_one

let lemma sin_ang_exp(x: complex)
      requires{real_ x}
      ensures{sin (ttwo *.pi  *. x) = t_im_part (ang_exp (real_to_ang x))}
  =()

let lemma cos_ang_exp(x: complex)
      requires{real_ x}
      ensures{cos (ttwo *.pi *. x) = t_real_part (ang_exp (real_to_ang x))}
  =()

let lemma sin_ang_exp_(x: complex)
      requires{real_ x}
      ensures{sin x = t_im_part (ang_exp (real_to_ang (x /. (ttwo*.pi))))}
  =()

let lemma cos_ang_exp_(x: complex)
      requires{real_ x}
      ensures{cos x = t_real_part (ang_exp (real_to_ang (x/. (ttwo*.pi))))}
  =()

let lemma cos_sin_square_add (x: complex)
      requires{real_ x}
      ensures{cpower (cos x) 2 +. cpower (sin x) 2 = c_one}
  = ang_exp_modulus  (real_to_ang (x/. (ttwo*.pi)))

let lemma c_one_minus_sin_square (x: complex)
      requires{real_ x}
      ensures{c_one -. cpower (sin x) 2 = cpower (cos x) 2}
  =()

let lemma c_one_minus_cos_square (x: complex)
      requires{real_ x}
      ensures{c_one -. cpower (cos x) 2 = cpower (sin x) 2}
  =()

let function cos_ang (theta:angle)
               ensures{result = t_real_part (ang_exp theta)}
  = cos (ang_meas theta *. (ttwo*.pi))

let function sin_ang (theta:angle)
               ensures{result = t_im_part (ang_exp theta)}
  = sin (ang_meas theta *. (ttwo*.pi))
  
let lemma euler_moivre_cos (theta:angle)
      ensures{cos_ang theta = (c_one/.ttwo) *. ((ang_exp theta) +. (ang_exp (ang_inv theta)))}
  =()

let lemma euler_moivre_cos_rev (theta:angle)
      ensures{ ((ang_exp theta) +. (ang_exp (ang_inv theta))) = ttwo *. cos_ang theta }
  =()

let lemma euler_moivre_cos_int (k n:int)
      ensures{cos_ang (k/./n) = (c_one/.ttwo) *. ((ang_exp  (k/./n)) +. (ang_exp  (-k/./n)))}
  =()

let lemma euler_moivre_cos_rev_int (k n :int)
      ensures{ ((ang_exp  (k/./n)) +. (ang_exp  (-k/./n))) = ttwo *. cos_ang  (k/./n) }
  =()

let lemma euler_moivre_sin (theta:angle)
      ensures{sin_ang theta = (c_one/.(ttwo*. im)) *. ((ang_exp theta) -. (ang_exp (ang_inv theta)))}
  =()

let lemma euler_moivre_sin_rev (theta:angle)
      ensures{ ((ang_exp theta) -. (ang_exp (ang_inv theta))) = ttwo *. im *. sin_ang theta }
  =()

let lemma euler_moivre_sin_int (k n:int)
      ensures{sin_ang (k/./n) = (c_one/.(ttwo*.im)) *. ((ang_exp  (k/./n)) -. (ang_exp  (-k/./n)))}
  =()

let lemma euler_moivre_sin_rev_int (k n :int)
      ensures{ ((ang_exp  (k/./n)) -. (ang_exp  (-k/./n))) = ttwo *. im *. sin_ang  (k/./n) }
  =()
  
let lemma euler_real (x: complex)
      requires{real_ x}
      ensures{cos x = t_real_part (exp (im *. x))}
  =()
  
let lemma euler_im (x: complex)
      requires{real_ x}
      ensures{sin x = t_im_part (exp (im *. x))}
  =()

val function arc_cos_ang (x:complex):angle
                                       requires{-. c_one <=. x <=. c_one}
                                       ensures{cos_ang result = x}
                                       ensures{c_zero <=. ang_meas result <=. c_one/.ttwo}
                                       ensures{forall t. c_zero <=. ang_meas t <=. c_one/.ttwo -> cos_ang t = x -> t = result}

let lemma set_arc_cos_ang_exp (x:complex)(o: angle)
      requires{-. c_one <=. x <=. c_one}
      requires{c_zero <=. ang_meas o <=. c_one/.ttwo}
      requires{cos_ang o = x }
      ensures{ arc_cos_ang x = o}
  =()
  
let lemma arc_cos_ang_exp_plus_inv (x:complex)
      requires{-. c_one <=. x <=. c_one}
      ensures{ang_exp (arc_cos_ang x) +. ang_exp (ang_inv (arc_cos_ang x))=  ttwo *.  x}
  =()
  
let lemma arc_cos_ang_add_inv (x:complex)
      requires{-. c_one <=. x <=. c_one}
      ensures{ang_add (arc_cos_ang x)  (ang_inv (arc_cos_ang x)) = ang_zero}
  =()

     use arit.Incr_abs

let lemma ang_add_incr (k i:int)
      ensures{ang_add (i/./incr_abs k) (i/./incr_abs k) = i/./k}
  =()
end

     
module Trigo_form
         use int_expo.Int_Exponentiation
         use complex.Complex
         use  complex_expo.Complex_Exponentiation
         use complex_operations.FromInt
         use Angle
         use Real_to_complex_trig
         use int.Int     
         use qdata.Sqrt_two
         use  int.EuclideanDivision

let lemma cos_add (x x': complex)
      requires{real_ x}
      requires{real_ x'}
      ensures{cos (x+. x') = cos x *. cos x' -. sin x *. sin x'}
  =()
  
let lemma sin_add (x x': complex)
      requires{real_ x}
      requires{real_ x'}
      ensures{sin ( x +. x') = sin x *. cos x' +. cos x *. sin x'}
  =()

let lemma cos_ang_add (theta theta': angle)
      ensures{cos_ang (theta +.+ theta') = cos_ang theta *. cos_ang theta' -. sin_ang theta *. sin_ang theta'}
  =()
  
let lemma sin_ang_add  (theta theta': angle)
      ensures{sin_ang ( theta +.+ theta') = sin_ang theta *. cos_ang theta' +. cos_ang theta *. sin_ang theta'}
  =()

let lemma cos_ang_add_rev (theta theta': angle)
      ensures{cos_ang theta *. cos_ang theta' -. sin_ang theta *. sin_ang theta' = cos_ang (theta +.+ theta') }
  =()
  
let lemma sin_ang_add_rev  (theta theta': angle)
      ensures{sin_ang theta *. cos_ang theta' +. cos_ang theta *. sin_ang theta'= sin_ang ( theta +.+ theta') }
  =()

let lemma sin_ang_add_rev_rev  (theta theta': angle)
      ensures{ cos_ang theta *. sin_ang theta' +. sin_ang theta *. cos_ang theta' = sin_ang ( theta +.+ theta') }
  =()

let lemma sin_ang_inv (theta:angle)
      ensures{sin_ang (ang_inv theta) = -. sin_ang theta}
  =()

let lemma cos_ang_inv (theta:angle)
      ensures{cos_ang (ang_inv theta) = cos_ang theta}
  =()

let lemma sin_ang_inv_int (k n :int)
      ensures{sin_ang (-k/./n)  = -. sin_ang (k/./n) }
  =()

let lemma cos_ang_inv_int (k n :int)
      ensures{cos_ang (k/./n) = cos_ang (k/./n)}
  =()

let lemma sin_ang_zero()
      ensures{sin_ang (1/./0)  =c_zero}
  =()

let lemma sin_ang_one()
      ensures{sin_ang (1/./1)  =c_zero}
  =()

let lemma sin_ang_two()
      ensures{sin_ang (1/./2)  =c_one}
  =()

let lemma sin_ang_three()
      ensures{sin_ang (1/./3)  = pow_inv_sqrt_2 1}
  =()

let lemma cos_ang_zero()
      ensures{cos_ang (1/./0)  =c_one}
  =()

let lemma cos_ang_one()
      ensures{cos_ang (1/./1)  = -. c_one}
  =()

let lemma cos_ang_two()
      ensures{cos_ang (1/./2)  =c_zero}
  =()

let lemma cos_ang_three()
      ensures{cos_ang (1/./3)  = pow_inv_sqrt_2 1}
  =()
  
let lemma cos_two_x (x : complex)
      requires{real_ x}
      ensures{cos (ttwo *. x) = cpower (cos x) 2 -. cpower (sin x) 2}
  = cos_add x x
  
let lemma sin_two_x (x x': complex)
      requires{real_ x}
      requires{real_ x'}
      ensures{sin (ttwo *. x) = ttwo *. sin x *. cos x}
  = sin_add x x

let lemma cos_minus (x: complex)
      requires{real_ x}
      ensures{cos (-.x) = cos x}
  =   ang_exp_neg_conjugate x

let lemma sin_minus (x: complex)
      requires{real_ x}
      ensures{sin (-.x) = -. (sin  x)}
  =  ang_exp_neg_conjugate x
   
let lemma symetries_vert (x : complex)
      requires{real_ x}
      ensures{sin (pi/. ttwo +. x) = sin  (pi/. ttwo -. x)}
      ensures{cos (pi/. ttwo +. x) = -. cos  (pi/. ttwo -. x)}
  =()                        

let lemma pi_minus  (x : complex)
      requires{real_ x}
      ensures{sin (pi-. x) = sin  x}
      ensures{cos (pi-. x) = -. cos  x}
  = symetries_vert ((pi/.ttwo)-.x)

      use arit.Evenness
  
let rec lemma sin_plus_pi_pos (x : complex) (k:int)
          requires{real_ x}
          requires{0<=k}
          ensures{even k -> sin (pi *. (x+. i_to_c k)) = sin  (pi *. x)}
          ensures{odd k -> sin (pi *. (x+. i_to_c k)) = -. sin  (pi *. x)}
          variant{k}
  = if k = 0 then ()
    else sin_plus_pi_pos x (k-1)

let  lemma sin_plus_pi (x : complex) (k:int)
       requires{real_ x}
       ensures{even k -> sin (pi *. (x+. i_to_c k)) = sin  (pi *. x)}
       ensures{odd k -> sin (pi *. (x+. i_to_c k)) = -. sin  (pi *. x)}
  = if  0 <= k then sin_plus_pi_pos x k 
    else sin_plus_pi_pos (x +. i_to_c k) (-k)

let rec lemma cos_plus_pi_pos (x : complex) (k:int)
          requires{real_ x}
          requires{0<=k}
          ensures{even k -> cos (pi *. (x+. i_to_c k)) = cos  (pi *. x)}
          ensures{odd k -> cos (pi *. (x+. i_to_c k)) = -. cos  (pi *. x)}
          variant{k}
  = if k = 0 then ()
    else cos_plus_pi_pos x (k-1)

let  lemma cos_plus_pi (x : complex) (k:int)
       requires{real_ x}
       ensures{even k -> cos (pi *. (x+. i_to_c k)) = cos  (pi *. x)}
       ensures{odd k -> cos (pi *. (x+. i_to_c k)) = -. cos  (pi *. x)}
  = if  0 <= k then cos_plus_pi_pos x k 
    else cos_plus_pi_pos (x +. i_to_c k) (-k)

let  lemma mod_sin_plus_pi (x : complex) (k:int)
       requires{real_ x}
       ensures{modulus ( sin (pi *. (x+. i_to_c k))) = modulus (sin  (pi *. x))}
  = ()

let  lemma mod_cos_plus_pi (x : complex) (k:int)
       requires{real_ x}
       ensures{modulus ( cos (pi *. (x+. i_to_c k))) = modulus (cos  (pi *. x))}
  = ()

      use complex_operations.Int_dec_parts

let lemma sin_mod_two_pi (x:complex)
      requires{real_ x}
      ensures{sin (ttwo *. pi *. x) = sin (ttwo *. pi *. (dec_part x))}
  =()

let lemma cos_mod_two_pi (x:complex)
      requires{real_ x}
      ensures{cos (ttwo *. pi *. x) = cos (ttwo *. pi *.(dec_part x))}
  =()
  
let lemma square_modulus_c_one_minus (phi: complex)
      requires{real_ phi}
      ensures{cpower (modulus (c_one -. ang_exp (real_to_ang phi))) 2 = (i_to_c 4) *. cpower (modulus (sin (pi *. phi ))) 2 }
  =()
  
val lemma growing_sine (a b: complex)
      requires{c_zero <=. a <. b <=. c_one/.ttwo}
      ensures{sin (pi *. a) <. sin (pi *. b)}

let lemma non_null_sine (x: complex)
      requires{c_zero <. x <. pi}
      ensures{ c_zero <. sin x }
  =if
    x<=. pi/. ttwo then growing_sine c_zero (x/.pi)
  else
    begin
      pi_minus x;
      growing_sine c_zero ( c_one -. (x/.pi));
    end

val lemma bounded_by_sine (x:complex)
      requires{real_ x}
      requires{c_zero <=. modulus x <=. c_one/. ttwo}
      ensures{modulus (ttwo *. x)  <=. modulus (sin(pi *.  x )) }
  
let lemma bounded_by_sine_one (x: complex) (k:int)
      requires{0<=k}
      requires{real_ x}
      requires{ modulus (x-. c_one)  <=. c_one/. (i_to_c (power 2 (k+1)))}
      ensures{modulus (ttwo *. (x -. c_one) *. (i_to_c (power 2 k))) <=. modulus (sin(pi *. (i_to_c (power 2 k)) *. x )) }
  =bounded_by_sine (modulus (x -. c_one) *. (i_to_c (power 2 k)))
  
val lemma bounded_sine (x: complex)
      requires{real_ x}
      ensures{modulus (sin x) <=. modulus x }

let lemma non_c_zero_sin (x: complex)
      requires{real_ x}
      requires{c_zero <. dec_part x}
      ensures{sin (pi*.x) <> c_zero}
  = mod_sin_plus_pi (dec_part x) (int_part_int x)
  
let lemma non_c_zero_sin_bounded_mod (x: complex)
      requires{real_ x}
      requires{ c_zero <. modulus x <.c_one}
      ensures{sin (pi*.x) <> c_zero}
  = non_c_zero_sin x
  
let lemma non_ang_zero_bounded_mod (x: complex)
      requires{real_ x}
      requires{ c_zero <. modulus x <. c_one}
      ensures{real_to_ang x <> ang_zero}
  = non_c_zero_sin_bounded_mod x
  
let lemma non_ang_zero_int_to_ang (k n: int)
      requires{0<=n}
      requires{mod k (power 2 n) <> 0}
      ensures{k /./ n <> ang_zero}
  = non_ang_zero_bounded_mod  (i_to_c (mod k (power 2 n) )*. pow_inv_2 n)
  
let lemma modulus_ang_exp (a:angle)
      ensures{modulus (ang_exp a) = c_one}
  =()
  
end         


module Rotations
         use Angle
         use complex.Complex
         use int.Int
         use int_expo.Int_Exponentiation
         use Real_to_complex_trig
         use Trigo_form
     
let lemma sin_pos (x: complex)
      requires{c_zero <. x <. pi }
      ensures{ c_zero <. sin x}
  = non_null_sine x
      
      use complex_operations.FromInt
      use complex_expo.Complex_Exponentiation
      
lemma sin_pos_leq : forall x: complex. c_zero <=. x <=. pi -> c_zero <=. sin x
lemma sin_quarter_pi : sin (pi /. (i_to_c 4)) = (squarert_two /. ttwo)
lemma sin_pi : sin pi = -. c_zero

let lemma cos_inv (x: complex)
      requires{real_ x}
      ensures{cos (-. x) = cos x}
  =()
  
let lemma sin_inv (x: complex)
      requires{real_ x}
      ensures{sin ( -. x) = -. sin x}
  =()


let lemma cos_ang_mult_plus_one (x: complex) (i:int)
      requires{real_ x}
      ensures{cos (x *. i_to_c i) = cos (x *. (i_to_c (i-1))) *. cos x -. sin (x *. i_to_c (i-1)) *. sin x }
  = cos_add (x *. i_to_c (i-1)) x

let lemma cos_ang_mult_minus_one (x: complex) (i:int)
      requires{real_ x}
      ensures{cos (x*. i_to_c  (i-1)) = cos (x *.  i_to_c i) *. cos x +. sin (x *. i_to_c i) *. sin x }
  = cos_add (x *. i_to_c i) (-.x)

let lemma sin_ang_mult_plus_one (x: complex) (i:int)
      requires{real_ x}
      ensures{sin (x *. i_to_c i) = sin (x *. i_to_c (i-1)) *. cos x +. cos (x *. i_to_c (i-1)) *. sin x }
  = sin_add (x *. i_to_c (i-1)) x

let lemma sin_ang_mult_minus_one (x: complex) (i:int)
      requires{real_ x}
      ensures{sin (x *. i_to_c (i-1)) = sin (x *. i_to_c i) *. cos x -. cos (x *. i_to_c i) *. sin x }
  = sin_add (x *. i_to_c i) (-.x)

let lemma cos_ang_mult_inv (x: complex) (i:int)
      requires{real_ x}
      ensures{cos (x *. i_to_c (-i)) = cos (x *. i_to_c i)}
  =()

let lemma sin_ang_mult_inv (x: complex) (i:int)
      requires{real_ x}
      ensures{sin (x *. i_to_c (-i)) = -. sin (x *. i_to_c i)}
  =()

let lemma modulus_one_over_pow_n (k n:int)
      requires{0<=n}
      requires{0<= k < power 2 n}
      ensures{modulus (square_rt (i_to_c k) /. (square_rt (i_to_c k)+.square_rt (i_to_c (power 2 n - k)))) +.
                ( modulus (square_rt (i_to_c (power 2 n - k)) /.  (square_rt (i_to_c k)+.square_rt (i_to_c (power 2 n - k))))) = c_one}
  =()

     use complex_expo.Complex_exp
  
let lemma get_cos (x: complex) (r i: complex)
      requires{real_ x}
      requires{real_ r}
      requires{real_ i}
      requires{modulus (r +. im *. i) = c_one}
      requires{exp (im *. x) = r +. im *. i}
      ensures{cos x = r}
  =()

let lemma get_sin (x: complex) (r i: complex)
      requires{real_ x}
      requires{real_ r}
      requires{real_ i}
      requires{modulus (r +. im *. i) = c_one}
      requires{exp (im *. x) = r +. im *. i}
      ensures{sin x = i}
  =()

let lemma unic_ang_meas (x x':complex)
      requires{real_ x}
      requires{real_ x'}
      requires{c_zero <=. x <. c_one}
      requires{c_zero <=. x' <. c_one}
      requires{real_to_ang x = real_to_ang x'}
      ensures{ x =  x'}
  =()
  
val function arg (x:complex):complex
                               requires{modulus x = c_one}
                               ensures{exp (result *. im)  = x}
                               ensures{real_ result}
                               ensures{cos result = t_real_part x}
                               ensures{sin result = t_im_part x}
end
