module Assert_equal

val  predicate (==) (a b :'a)
    ensures{result <->   (a = b)}
     
let lemma assert_equal (a b:'a)
      requires{a = b}
      ensures{a = b}
  =()

let lemma goal_comm (a b:'a)
      requires{a = b}
      ensures{b = a}
  =()

end

module False
let lemma set_false (p:bool)
      requires{p}
      requires{not p}
      ensures{false}
  =()
end
     
module Constant
     
let function p_id (a:'a) = a                                    
let ghost function const (a: 'a) (b :'b)= a
 predicate constant_f (f: 'a -> 'b) = exists a. f = const a

end

module Pairs

val function fir (o: ('a,'b)) :'a
val function sec (o: ('a,'b)) :'b

axiom projections: forall o: ('a,'b). o = (fir o, sec o)

let lemma get_fir (a:'a) (b:'b)
      ensures{ fir (a,b) = a}
  =()
  
let lemma get_sec (a:'a) (b:'b)
      ensures{ sec (a,b) = b}
  =()

end

module P_real
         use real.Real(* Infix *)
use Assert_equal
let function  (/*) (x y: real):real
                                 requires{y <> 0.0}
                               = x / y
let predicate (=*) (x y : real)
  ensures{result = (x = y)}
                   = x==y
             
let predicate (<>*) (x y : real)
  ensures{result = (x <> y)}
                    =
                      not (x==y)
             
let function  (+*) (x y: real)  = x + y
let function  (-*) (x y: real)  = x - y
let function  ( ** ) (x y: real)  = x * y
let predicate  (<=*) (x y: real)  = x <= y
                     let function  (-*_) ( y: real):real  = - y
let predicate (<*) (x y : real) = x <=* y && x <>* y
let predicate (>*)  (x y : real) = y <* x
let predicate (>=*) (x y : real) = y <=* x
                                       
use int.Int
use real.FromInt
             
val function from_int (x:int) : real
  ensures{result =  from_int x}
    
lemma Zero: from_int 0 = 0.0
lemma Add:forall x y:int. from_int (Int.(+) x y) = from_int x +* from_int y
lemma One: from_int 1 = 1.0
lemma Sub:forall x y:int. from_int (Int.(-) x y) = from_int x -* from_int y

let rec lemma mul_pos ( x y:int)
          ensures{from_int (Int.( *) x y) = from_int x ** from_int y}
                    requires{0<= y}
                    variant{y}
                  =if (y=0) then ()
                   else
                     begin
                       assert{from_int x ** from_int y = (from_int x ** from_int (y- 1)) +* from_int x};
                       assert{ x *y = (x * (y-1)) + x};
                       mul_pos x (y-1)
                     end
                     
let  lemma mul ( x y:int)
          ensures{from_int (Int.( *) x y) = from_int x ** from_int y}
                    requires{0<= y}
                  =if (y>=0) then mul_pos x y
                   else mul_pos x (- y)

let  lemma mul_rev ( x y:int)
          ensures{from_int x ** from_int y = from_int ( x * y) }
                    requires{0<= y}
                  = ()
                    
lemma neg:forall x:int. from_int (Int.(-_) (x)) = -* from_int x
lemma injective:forall x y: int. from_int x = from_int y -> x = y
lemma Monotonic:forall x y:int. Int.(<=) x y -> from_int x <=* from_int y

axiom positive_inv: forall x: real. 0.0 <* x -> 0.0 <* 1.0 /* x 
                                        
let lemma r_zeroLessOne ()
      ensures{0.0 <=* 1.0}
  =()
  
  
let lemma r_compatOrderAdd  (x y z : real)
      requires{x <=* y}
      ensures{ x +* z <=* y +* z}
  = ()
  
let lemma r_compatOrderMult  (x y z : real)
      requires{x <=* y}
      requires{0.0 <=* z}
      ensures{ x ** z <=* y ** z}
  = ()

let lemma inv_order (a b: real)
  requires{0.0 <* a}
  requires{0.0 <* b}
  requires{a<=* b}
  ensures{1.0/b <=* 1.0/a}
  = assert{1.0/b = a / (a**b) = a** (1.0 / (a**b))};
    assert{1.0/a = b / (a**b) = b** (1.0 / (a**b) )};
    r_compatOrderMult a b (1.0 / (a**b))

let lemma inv_strict_order (a b: real)
  requires{0.0 <* a}
  requires{0.0 <* b}
  requires{a<* b}
  ensures{1.0/b <* 1.0/a}
  = assert{1.0/b = a / (a**b) = a** (1.0 / (a**b))};
    assert{1.0/a = b / (a**b) = b** (1.0 / (a**b)) }

(* let lemma compat_inf_order_real (a b : real)
 *       requires{a<=*b}
 *       requires{a<>0.0}
 *       requires{b<>0.0}
 *       ensures{1.0 /*b <=* 1.0 /* a}
 *   = assert{a**a <=* b**b } *)

                  end

module Complex
     use export Assert_equal

type complex

let predicate teq (x y : complex)
  ensures{result = (x = y)}
  = (x==y)
  
val  constant c_zero : complex
 val constant c_one : complex
   
val function  (-._) complex : complex
val function  (+.)  complex complex : complex
val function  ( *.)  complex complex : complex
val function inv complex: complex
                             
clone (* export *) algebra.Field with type t = complex,
constant zero = c_zero, constant one = c_one,
                function (-_) = (-._),
                function inv = inv,
                         function (+) = (+.),function ( *) = ( *. ),axiom .
  
let function  (-.) (x y: complex)  = x +. (-. y)

 let function  (/.) (x y : complex) : complex 
                                 requires{y <> c_zero}
                                 ensures{result = x *. inv y}
= x *. inv y
                                 use P_real

let lemma invol_neg (a: complex)
      ensures{-. (-. a) = a }
  =()
  
let lemma injective_neg (a b: complex)
      requires{-. a = -. b }
      ensures{a = b }
  =()
  
let lemma find_opposite (a b: complex)
      requires{ a  -. b =  c_zero}      
      ensures{a = b }
  =()

let lemma div_as_mult_inv (a b:complex)
      requires{a<> c_zero}
  ensures{b/.a = b*. (c_one/.a)}
  =()
  
let lemma add_opposite (a: complex)
      ensures{a +.  (-. a) = c_zero }
  =()
  
let lemma opposite (a: complex)
      ensures{a -. a = c_zero }
  =()
  
let lemma mult_num (a b c: complex)
      requires{c <> c_zero}
      ensures{(a*. b)/. c = a *. (b /. c)}
  =()

  
let lemma div_rev (a b : complex)
      requires{b <> c_zero}
      ensures{a *. (c_one /.b) = a /. b}
  =()
  
let lemma mult_div_num (a b c: complex)
      requires{c <> c_zero}
      ensures{(a/. c) *. b = (a *. b) /. c}
  =()
  
let lemma mult_denom (a b c: complex)
      requires{c <> c_zero}
      requires{b <> c_zero}
      ensures{ a/. (b *. c) = (a /. b) *. (c_one /. c)}
  = ()
  
let lemma mult_simpl (a b c : complex)
      requires{c <> c_zero}
      requires{b <> c_zero}
      ensures{ (a*.b)/. (c *. b) = a /. c}
  = mult_denom (a*.b) c b;
    mult_num a b (c*. b)

let lemma dic_simpl (a b c : complex)
      requires{c <> c_zero}
      requires{b <> c_zero}
      ensures{ (a/. (c *. b)) *. b = a /. c}
               = ()
               
let lemma simpl_with_c_one (a b: complex)
  requires{a<> c_zero}
  requires{b<> c_zero}
  ensures{(a/.b) *. (c_one /.a) = c_one /. b}
  =()

let lemma add_op (a1 a2 : complex)
      requires{a1 = -. a2}
      ensures{a1 +. a2 = c_zero}
  =()
  
let lemma mult_eq_t (a1 a2 b1 b2: complex)
      requires{a1 = a2}
      requires{b1 = b2}
      ensures{a1 *.b1 = a2 *.b2}
  =()  
  
let lemma mult_eq_t_rev (a1 a2 b1 b2: complex)
      requires{a1 = a2}
      requires{b1 = b2}
      ensures{a1 *.b1 = b2 *.a2}
  =()  

  
let lemma mult_comm (a b: complex)
      ensures{a *.b = b *. a}
  =()

let lemma mult_assoc (a b c: complex)
      ensures{(a*. b) *.c = a *. (b*.c)}
  =()
  
  
let lemma mult_abc_to_acb (a b c: complex)
      ensures{(a*. b) *.c = (a *. c) *.b}
  =()



let lemma zero_mult_t (a1 a2: complex)
      requires{a1 = c_zero}
      ensures{a1 *. a2 = c_zero}
  =()
  
let lemma mult_zero_t (a1 a2: complex)
      requires{a1 = c_zero}
      ensures{a2 *. a1 = c_zero}
  =()  
  
let lemma mult_one_t (a1 a2: complex)
      requires{a2 = c_one}
      ensures{a1 *. a2 = a1}
  =()
  
let lemma add_eq_t (a1 a2 b1 b2: complex)
      requires{a1 = a2}
      requires{b1 = b2}
      ensures{a1 +.b1 = a2 +.b2}
  =()
  
let lemma add_eq_t_rev (a1 a2 b1 b2: complex)
      requires{a1 = a2}
      requires{b1 = b2}
      ensures{a1 +.b1 = b2 +.a2}
  =()
  

let lemma substr_eq_t (a1 a2 b1 b2: complex)
      requires{a1 = a2}
      requires{b1 = b2}
      ensures{a1 -.b1 = a2 -.b2}
  =()

  
val constant im: complex
axiom im_Def: im *. im = -.c_one
let constant ttwo: complex  = c_one +. c_one

                           
val function r_to_c (i:real): complex
axiom r_to_c_zero: r_to_c 0.0 = c_zero
axiom r_to_c_one: r_to_c 1.0 = c_one
axiom r_to_c_add : forall i j : real. r_to_c i +. r_to_c j = r_to_c (i+*j)
lemma r_to_c_add_rev : forall i j : real. r_to_c (i+*j) = r_to_c i +. r_to_c j
axiom r_to_c_opp : forall i : real. r_to_c (-* i)  = -. r_to_c i
axiom r_to_c_div : forall i j: real. j<> 0.0 -> r_to_c (i/* j)  = (r_to_c i)/. (r_to_c j)
axiom r_to_c_mult: forall i j : real. r_to_c i *. r_to_c j = r_to_c (i**j)
lemma r_to_c_mult_rev: forall i j : real.   r_to_c (i**j) = r_to_c i *. r_to_c j
lemma r_to_c_sub : forall i j : real. r_to_c i -. r_to_c j = r_to_c (i-*j)
  
val function real_part (i: complex):real
val function im_part (i: complex): real
axiom Real_part_add : forall i j: complex. real_part (i +. j) = real_part i +* real_part j                               
axiom Im_part_add : forall i j: complex. im_part (i +. j) = im_part i +* im_part j                               
lemma Real_part_opposite : forall i : complex. real_part (-. i ) = -* (real_part i)                               
lemma Im_part_opposite : forall i : complex. im_part (-.i) = -* (im_part i)                               

axiom Complex_decomp : forall i: complex. i = (r_to_c (real_part i) +. (im *.r_to_c (im_part i)))
axiom Unic_decomp : forall i : complex. forall x y : real. i = (r_to_c x +. (im *.r_to_c y)) -> x = real_part i /\ y = im_part i

let     predicate real_ (x: complex)= im_part x == 0.0
let predicate pure_im_ (x: complex)= real_part x == 0.0


                             
                                                       
let lemma unic_decomp (i: complex) (x y:real)
      requires{i = (r_to_c x +. (im *.r_to_c y))}
      ensures{x = real_part i}
      ensures{ y = im_part i}
  =()

let lemma r_to_c_real (x: complex)
      requires{real_ x}
      ensures{x = r_to_c (real_part x)}
  =()  

let lemma real_r_to_c (x:real)
      ensures{real_ (r_to_c x)}
  =  unic_decomp (r_to_c x) x 0.0

let lemma r_to_c_pure_im (x: complex)
      requires{pure_im_ x}
      ensures{x = im *. r_to_c (im_part x)}
  =()
  
                                                       
let lemma decomp_mult (a b: complex)
      ensures{a *. b = ((r_to_c (real_part a) *. r_to_c (real_part b)) -. (r_to_c (im_part a) *. r_to_c (im_part b)))
                                                                          +. im *. ((r_to_c (real_part a) *. r_to_c (im_part b)) +. (r_to_c (real_part b) *. r_to_c (im_part a)))}
                  =  assert{a *. b = (r_to_c (real_part a) *. r_to_c (real_part b)) +. im *. (r_to_c (real_part a) *. r_to_c (im_part b))
                                     +. im *. (r_to_c (real_part b) *. r_to_c (im_part a)) +. im *. im *. (r_to_c (im_part a) *. r_to_c (im_part b))};
                     assert{im *. im *. (r_to_c (im_part a) *. r_to_c (im_part b)) = -. (r_to_c (im_part a) *. r_to_c (im_part b))};                     
assert{im *. (r_to_c (real_part a) *. r_to_c (im_part b))
       +. im *. (r_to_c (real_part b) *. r_to_c (im_part a)) =im *. ((r_to_c (real_part a) *. r_to_c (im_part b)) +. (r_to_c (real_part b) *. r_to_c (im_part a)))}                     

let function t_real_part (x: complex)
               ensures{real_ result}
           = r_to_c (real_part x)

let lemma t_real_part_inv (x: complex)
  ensures{t_real_part (-. x) = -. (t_real_part x)}
  =()
  
let function t_im_part (x: complex)
               ensures{real_ result}
           = r_to_c (im_part x)

let lemma t_im_part_inv (x: complex)
  ensures{t_im_part (-. x) = -. (t_im_part x)}
  =()


let lemma decomp_mult_as_reals (a b: complex)
      ensures{a *. b = ((t_real_part a) *. (t_real_part b) -.  (t_im_part a) *.  (t_im_part b))
                                                                          +. im *.  ((t_real_part a) *.  (t_im_part b) +.  (t_real_part b) *.  (t_im_part a))}
= decomp_mult a b 


let lemma decomp_mult_real_part (a b: complex)
      ensures{real_part (a *. b) = (real_part a) ** (real_part b) -*  (im_part a) **  (im_part b)}
  = decomp_mult a b;
    unic_decomp   (a *. b) ((real_part a) ** (real_part b) -*  (im_part a) **  (im_part b))
      ((real_part a) **  (im_part b) +* (real_part b) ** (im_part a))



    
let lemma decomp_mult_im_part (a b: complex)
      ensures{im_part (a *. b) =   (real_part a) **  (im_part b)
                                   +* (real_part b) ** (im_part a)}  =
  decomp_mult a b;
    unic_decomp   (a *. b) ((real_part a) ** (real_part b) -*  (im_part a) **  (im_part b))
      ((real_part a) **  (im_part b) +* (real_part b) ** (im_part a))

  let lemma t_mult_real (a b: complex)
  ensures{t_real_part (a*.b) = (t_real_part a *. t_real_part b) -. (t_im_part a *. t_im_part b) }
= decomp_mult_real_part a b

  let lemma t_mult_im (a b: complex)
  ensures{t_im_part (a*.b) = (t_real_part a *. t_im_part b) +. (t_im_part a *. t_real_part b) }
= decomp_mult_real_part a b

let lemma mult_real_real (a b: complex)
      requires{real_ a}
      requires{real_ b}
      ensures{a*.b = (r_to_c (real_part a) *. r_to_c (real_part b)) = r_to_c (real_part a ** real_part b)}
      ensures{real_part (a*.b) =  (real_part a ** real_part b)}
      ensures{im_part (a*.b) =  0.0}
  = decomp_mult a b;
    unic_decomp (a*.b ) (real_part a ** real_part b) 0.0

let lemma complex_squared (a: complex)
      ensures{a*.a = t_real_part a *.  t_real_part a -. t_im_part a *.  t_im_part a +. im *. ttwo *. t_real_part a *. t_im_part a}
  ensures{t_real_part (a*.a) = t_real_part a *.  t_real_part a -. t_im_part a *.  t_im_part a }
  ensures{t_im_part (a*.a) = ttwo *. t_real_part a *. t_im_part a }
  = decomp_mult_as_reals a a
  
let lemma complex_real_squared (a: complex)
      requires{real_ a}
      ensures{a*.a = t_real_part a *.  t_real_part a }
  = complex_squared a  

    
let lemma decomp_div (a b: complex)
      requires{b <>c_zero}
  ensures{a/.b = t_real_part (a*. b)/.  (b *.b) +. im *. (t_im_part (a*. b)/.  (b *.b))}
  =
  assert{a/.b = (a*. b)/.(b *.b)}
  
let lemma decomp_div_real (a b: complex)
      requires{real_ b}
      requires{b <>c_zero}
  ensures{a/.b = t_real_part a *. b/.  (b *.b) +. im *. ((t_im_part a *. b) /.  (b *.b))}
  =
  assert{a/.b = (a*. b)/.(b *.b)}
  

    
(* let lemma mult_real_real (a b: complex)
 *       requires{real_ a}
 *       requires{real_ b}
 *       ensures{a*.b = (r_to_c (real_part a) *. r_to_c (real_part b)) = r_to_c (real_part a ** real_part b)}
 *       ensures{real_part (a*.b) =  (real_part a ** real_part b)}
 *       ensures{im_part (a*.b) =  0.0}
 *   = decomp_mult a b;
 *     unic_decomp (a*.b ) (real_part a ** real_part b) 0.0 *)
    
let lemma complex_prod_fact (a b: complex)
  ensures{a*.b = r_to_c (real_part a) *. b +. im *.  r_to_c (im_part a) *. b }
  =()

  let lemma non_zero_prod_pre (a b: complex)
      requires{a<> c_zero}
      requires{a*. b = c_zero}
      ensures{im_part b = real_part b = 0.0}
    =
    unic_decomp c_zero 0.0 0.0;
    assert{real_part (a*.b) = 0.0};
    assert{im_part (a*.b) = 0.0};
    assert{(real_part a) **  (real_part b)
       -* (im_part a) ** (im_part b) = 0.0};
    assert{(real_part a) **  (im_part b)
           +* (real_part b) ** (im_part a) = 0.0};
    if im_part a = 0.0 then
      begin
        assert{im_part b = 0.0};
          assert{real_part b <> 0.0 -> real_part a = 0.0};
      end else
      begin
        assert{(real_part b)  = -* ((real_part a) **  (im_part b))/* im_part a};
        if real_part a = 0.0 then
          begin
        assert{real_part b = 0.0};
          assert{im_part b <> 0.0 -> im_part a = 0.0};
          end
        else begin
        assert{(real_part b)  =  ((im_part a) **  (im_part b))/* real_part a = im_part b ** (im_part a/* real_part a)};
        assert{(real_part b)  =  (-*(real_part a) **  (im_part b))/* im_part a = im_part b ** ((-*(real_part a))/* im_part a)= im_part b ** (-*(real_part a/* im_part a))};
        assert{im_part b <> 0.0 -> (im_part a/* real_part a) = -* (im_part a/* real_part a) = 0.0};
        assert{(im_part b)  =  ((real_part a) **  (real_part b))/* im_part a = real_part b ** (real_part a/* im_part a)};
        assert{(im_part b)  =  (-*(im_part a) **  (real_part b))/* real_part a = real_part b ** ((-*im_part a)/* real_part a)= real_part b ** (-*(im_part a/* real_part a))};
        assert{real_part b <> 0.0 -> (im_part a/* real_part a) = -* (im_part a/* real_part a) = 0.0};
        assert{real_part b = im_part b = 0.0};
      end
      end
        

let lemma non_zero_prod (a b: complex)
      requires{a<> c_zero}
      requires{b<> c_zero}
      ensures{a*. b <> c_zero}
  = ()
                                                       
let lemma minus_c_one (a : complex)
      ensures{(-.a)  = (-. c_one) *. a}
      =()

let lemma mult_neg_l (a b: complex)
      ensures{(-.a) *. b = -. (a*.b)}
  =
        minus_c_one a;
    minus_c_one (a*.b)

let lemma mult_neg_r (a b: complex)
      ensures{a *. (-. b) = -. (a*.b)}
      =()     
     
let lemma neg_neg_out (a: complex)
  ensures{-. (-. a) = a}
  =()

let lemma div_neg_l (a b: complex)
      requires{b <> c_zero}
      ensures{(-.a) /. b = -. (a/.b)}
  =()
  
let lemma eq_to_real  (a b: complex)
      requires{real_ a}
      requires{real_ b}
      requires{a = b}
      ensures{real_part a = real_part b}
  =()

  let lemma eq_by_real  (a b: complex)
      requires{real_ a}
      requires{real_ b}
      requires{real_part a = real_part b}
      ensures{a = b}
  =()
 
let lemma div_neg_r (a b: complex)
      requires{b <> c_zero}
      ensures{a /. (-. b) = -. (a/.b)}
      =()
     
lemma invadd: forall i: complex. (-. i) = (-.c_one) *. i
                                                       
 let   lemma noc_zeroAdd  ( x y  : complex)
         requires{x <> c_zero}
         ensures{x +. y <> y}
   =
   assert{x+.y = y <-> (real_part (x+.y) = real_part y /\im_part (x+.y) = im_part y )};
   if x+. y = y
    then if real_part x = 0.0 then
 if im_part x = 0.0 then ()
else()
else()
else()

lemma Absorbing_zero: forall a b: complex. a *. b = c_zero <->( (a <> c_zero) -> (b = c_zero))
   
let lemma real_part_add (i j : complex)
      ensures{real_part (i +. j) = real_part i +* real_part j}
  = ()

let lemma mult_im_rev (a: complex)
      ensures{a *. im = im *. a}
  =()

let lemma im_im_elim (a: complex)
      ensures{im *. (im *. a) = -.a}
  =()
  
let lemma im_im_fact (a b: complex)
      ensures{(im *. a) *. (im *. b) = -. (a*. b)}
  =()
  
let lemma minus_minus_fact (a b: complex)
      ensures{(-. a) *. (-. b) =  (a*. b)}
  =()
  
let lemma minus_minus_add (a b: complex)
      ensures{(-. a) +. (-. b) =  -. (a+. b)}
  =()
  
let lemma minus_minus_add_rev (a b: complex)
      ensures{-. (a+. b) = (-. a) +. (-. b) }
  =()
  
let lemma minus_out_left (a b: complex)
      ensures{(-. a) *. b = -. (a*. b)}
  =()
  
let lemma minus_out_right (a b: complex)
      ensures{a *. (-.  b) = -. (a*. b)}
  =()
  
let lemma minus_in_left (a b: complex)
      ensures{-. (a*. b)= (-. a) *. b }
  =()
  
let lemma minus_in_right (a b: complex)
      ensures{ -. (a*. b) = a *. (-.  b)}
  =()
  
  let lemma minus_add_out_left (a b: complex)
      ensures{(-. a) +. b = -. (a+. (-.b))}
  =()
  
  let lemma minus_as_add_opp (a b: complex)
      ensures{a -. b = a+. (-.b)}
  =()
  
let lemma minus_add_out_right (a b: complex)
      ensures{a +. (-.  b) = -. ((-.a) +. b)}
  =()
  
let lemma minus_add_in (a b: complex)
      ensures{-. (a+. b)= (-. a) +. (-. b) }
  =()
  
let lemma minus_add_out (a b: complex)
      ensures{ (-. a) +. (-. b) = -. (a+. b) }
  =()
  
  
let lemma minus_eq (a b : complex)
      requires{a = b}
      ensures{-.a  = -.  b}
  =()

let lemma im_out_right (a b: complex)
      ensures{(im *. a) *. b = im *.  (a *. b)}
  =()
  
let lemma im_out_left (a b: complex)
      ensures{a *. (im *. b) = im *.  (a *. b)}
  =()
  
let lemma im_part_add (i j : complex)
      ensures{im_part (i +. j) = im_part i +* im_part j}
  = ()

  let lemma injective_real_part (i j: complex)
      requires{real_part i <> real_part j}
      ensures{i<> j}
  =()
  
let lemma injective_im_part (i j: complex)
      requires{im_part i <> im_part j}
      ensures{i<> j}
  =()

let lemma minus_distr_four (a b c d: complex)
      ensures{ ((a *. b) +. (((-. b) *. c) *. d)) = ((a -. (c *. d)) *. b)}
  =()
  
let lemma complex_decomp (i: complex) 
      ensures{i = (r_to_c (real_part i) +. (im *.r_to_c (im_part i)))}
  =()
     
let lemma simpl_frac  (x y : complex)
      requires{y<> c_zero}
      ensures{(x*. y) /. y = x}
  =() 

let lemma simpl_frac_  (x y z: complex)
      requires{y<> c_zero}
      requires{z<> c_zero}
      ensures{(x*. y) /. (z *. y) = x /. z}
  =() 
  
let lemma fact_frac  (x y z: complex)
      requires{z<> c_zero}
      ensures{(x*. y) /. z = x*. (y /. z)}
  =() 

let lemma fact_frac_rev  (x y z: complex)
      requires{z<> c_zero}
      ensures{ x*. (y /. z) = (x*. y) /. z}
  =() 

let lemma mult_sym (x y: complex)
      ensures{x*.y = y*.x}
  =()
  
let lemma inv_mult (x y : complex)
      requires{x <> c_zero}
      requires{y <> c_zero}
      ensures{(c_one /. x) *. (c_one /. y) = c_one/. (x *. y)}
  = ()

let lemma div_div  (x y z : complex)
      requires{y<> c_zero}
      requires{z<> c_zero}
      ensures{(x /. y) /. z = x /. (y*.z)}
  =() 

let lemma div_div_rev  (x y z : complex)
      requires{y<> c_zero}
      requires{z<> c_zero}
      ensures{ x /. (y*.z) = (x /. y) /. z}
  =()


(* let lemma mult_real_real (a b: complex)
 *       requires{real_ a}
 *       requires{real_ b}
 *       ensures{a*.b = (r_to_c (real_part a) *. r_to_c (real_part b)) = r_to_c (real_part a ** real_part b)}
 *       ensures{real_part (a*.b) =  (real_part a ** real_part b)}
 *       ensures{im_part (a*.b) =  0.0}
 *   = decomp_mult a b;
 *     unic_decomp (a*.b ) (real_part a ** real_part b) 0.0 *)



let lemma involutive_inv (a: complex)
      requires{a<> c_zero}
      ensures{c_one /. (c_one /. a) = a}
  =()

let lemma twice(i: complex)
      ensures{ttwo *. i = i+.i}
  =()
  
let lemma twice_half()
      ensures{ttwo*. (c_one /. ttwo) = c_one}
  =()
  
let lemma half_plus_half(i: complex)
      ensures{ (i /. ttwo) +. (i /. ttwo) = i}
  =()


  
let lemma decomp_inv_real (a : complex)
      requires{real_ a}
      requires{a <> c_zero}
  ensures{c_one /. a = c_one /. t_real_part a}
  ensures{real_ (c_one /. a)}
  ensures{t_real_part  (c_one /. a) = c_one /. t_real_part a}
  ensures{real_part  (c_one /. a) = 1.0 /* real_part a}
  =
assert{c_one /.a = c_one /. t_real_part a = r_to_c (1.0 /* real_part a) }
  

let lemma mult_div_comm (x y z t: complex)
      requires{z <> c_zero}
      requires{t <> c_zero}
      ensures{(x*.y) /. (z*.t) = (x/.z) *. (y/.t)}
  = ()

let lemma mult_div_comm_rev (x y z t: complex)
      requires{z <> c_zero}
      requires{t <> c_zero}
      ensures{ (x/.z) *. (y/.t) = (x*.y) /. (z*.t)}
  = ()

     
use Assert_equal

  
let predicate (<=.)  (x y: complex): bool
=  (real_ x && real_ y && real_part x <=* real_part y)|| x ==y

let predicate (<.)  (x y: complex): bool
  = x <=. y && not (x == y) 
  
let predicate (>=.)  (x y: complex): bool
  = y <=. x
  
let predicate (>.)  (x y: complex): bool
  = x >=. y && not (x == y)

let lemma leq_left_real (a b : complex)
      requires{a<=. b}
      requires{real_ a}
      ensures{real_ b}
      =()
  
let lemma leq_right_real (a b : complex)
      requires{a<=. b}
      requires{real_ b}
      ensures{real_ a}
      =()
  
  
let lemma inf_left_real (a b : complex)
      requires{a<. b}
      ensures{real_ a}
      =()
  
let lemma inf_right_real (a b : complex)
      requires{a<. b}
      ensures{real_ b}
      =()
  
let lemma inf_from_real (a b : complex)
      requires{real_ a }
      requires{real_ b }
      requires{real_part a<* real_part b}
      ensures{ a <.  b}
      =()
  
let lemma inf_to_real (a b : complex)
      requires{a<. b}
      ensures{real_part a <* real_part b}
      =()
  
let lemma leq_left_not_real_a (a b : complex)
      requires{a<=. b}
      requires{not (real_ a)}
      ensures{a = b}
      =()
                 
let lemma leq_left_not_real_b (a b : complex)
      requires{a<=. b}
      requires{not (real_ b)}
      ensures{a = b}
      =()
                 
                 
(* let lemma leq_right_is_real (a b : complex)
 *       requires{a<=. b}
 *       ensures{real_ b}
 *       =()
 *                  
 * let lemma inf_left_is_real (a b : complex)
 *       requires{a<. b}
 *       ensures{real_ a}
 *       =()
 *                  
 * let lemma inf_right_is_real (a b : complex)
 *       requires{a<. b}
 *       ensures{real_ b}
 *       =() *)
                 
clone  relations.PartialOrder with type t =complex, predicate rel = (<=.)
clone  relations.PartialOrder as Supeq  with type t =complex, predicate rel = (>=.)
clone  relations.PartialStrictOrder as Inf with type t =complex, predicate rel = (<.)
clone  relations.PartialStrictOrder as Infeq with type t =complex, predicate rel = (>.)

lemma r_to_c_inf: forall i j : real. r_to_c i <=. r_to_c j <->  i <=*   j

let lemma reali_is_its_real_part (a : complex)
  requires{real_ a}
  ensures{a = r_to_c (real_part a)}
  =()
                                                                           
let lemma inf_from_r (a b: complex)
  requires{real_ a}
  requires{real_ b}
  requires{real_part a <=* real_part b}
  ensures{a<=.b}
  =()
                                                                           
let lemma strict_inf_from_r (a b: complex)
  requires{real_ a}
  requires{real_ b}
  requires{real_part a <* real_part b}
  ensures{a<.b}
  =()

let lemma positive_inv_t ( x: complex)
      requires{c_zero <. x}
      ensures{c_zero <. c_one /.x}
  = assert{real_ x};
  assert{0.0 <* 1.0 /* (real_part x)}

  
val constant pi: complex
ensures{r_to_c 3.0 <. result}

lemma real_pi : real_ pi
lemma pi_sup_one : c_one <. pi
lemma pi_sup_zero : c_zero <. pi


  let lemma compat_order_mult  (x y z : complex)
      requires{x <=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <=. z}
      ensures{ x *. z <=. y *. z}
  = mult_real_real x z;
    mult_real_real y z;
    r_compatOrderMult (real_part x) (real_part y) (real_part z); 
    assert {real_part x ** real_part z <=* real_part y ** real_part z };
    assert {real_part (x *. z) <=* real_part (y *. z) }

  let lemma compat_order_add  (x y z : complex)
      requires{x <=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      ensures{ x +. z <=. y +. z}
  = mult_real_real x z;
    mult_real_real y z;
    r_compatOrderAdd (real_part x) (real_part y) (real_part z); 
    assert {real_part x +* real_part z <=* real_part y +* real_part z };
    assert {real_part (x +. z) <=* real_part (y +. z) }

  let lemma compat_order_add_left  (x y z : complex)
      requires{x <=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      ensures{ z +. x <=.  z +. y}
  = compat_order_add x y z

  let lemma compat_order_add_both  (x y z  t: complex)
      requires{x <=. y}
      requires{z <=. t}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{real_ t}
      ensures{ z +. x <=.  t +. y}
    = compat_order_add_left x y z;
      compat_order_add z t y

     
  let lemma compat_order_substr  (x y z : complex)
      requires{x <=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      ensures{ x -. z <=. y -. z}
    = compat_order_add x y (-.z)
    
  let lemma compat_inf_mult  (x y z : complex)
      requires{x <. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ x *. z <. y *. z}
    = ()

    let lemma transitive_infeq (a b c : complex)
  requires{a <=. b}
  requires{b <=. c}
  ensures{a<=.c}
    =()


let lemma transitive_infeq_inf (a b c : complex)
  requires{a <=. b}
  requires{b <. c}
  ensures{a<.c}
    =()

let lemma transitive_inf_infeq (a b c : complex)
  requires{a <. b}
  requires{b <=. c}
  ensures{a<.c}
    =()

let lemma transitive_inf (a b c : complex)
  requires{a <. b}
  requires{b <. c}
  ensures{a<.c}
    =()

let lemma pi_sup_ttwo()
    ensures{ ttwo <. pi}
= transitive_inf ttwo (r_to_c 3.0) pi

    
let lemma transitive_leq_inv_r (a b c : complex)
      requires{real_ a}
      requires{real_ b}
      requires{real_ c}
      requires{a <=. b}
  requires{b <=. c_one /. c}
  requires{c_one <=. c}
  ensures{a<=. b <=. c_one}
  =
  compat_order_mult c_one c (c_one/.c);
  transitive_infeq b (c_one /.c) c_one

  let lemma compat_inf_mult_left  (x y z : complex)
      requires{x <. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ z *. x <. z *. y}
    = ()
    
  let lemma compat_inf_mult_both  (x y z t: complex)
      requires{x <. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z <.t}
      requires{c_zero <. y}
      ensures{ z *. x <. t *. y}
    = transitive_inf (z *. x) (z*.y) (t *. y)
    
    
  let lemma compat_inf_add  (x y z : complex)
      requires{x <. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      ensures{ x +. z <. y +. z}
    = ()
    
  let lemma compat_inf_add_left  (x y z : complex)
      requires{x <. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      ensures{ z +. x <. z +. y}
    = ()
    
  let lemma compat_inf_add_both  (x y z t : complex)
      requires{x <. y}
      requires{z <. t}
      ensures{ x +. z <. y +. t}
    = compat_inf_add x y z;
    compat_inf_add_left   z t y;
    transitive_inf (x+. z) (y+.z) (y+.t)

  let lemma compat_inf_substr  (x y z : complex)
      requires{x <. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      ensures{ x -. z <. y -. z}
    = compat_inf_add x y (-.z)
    
let lemma real_inv (x: complex)
      requires{real_ x}
      requires{x <> c_zero}
  ensures{real_ (c_one /.  x)}
  = assert{x *. (c_one /. x) = c_one};
    decomp_mult x (c_one /. x)

  let lemma compat_order_mult_rev  (x y z : complex)
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      requires{ x *. z <=. y *. z}
      ensures{x <=. y}
    =
    assert{0.0 <=* real_part (z)};
    assert{0.0 <=* real_part (c_one/.z)};
    compat_order_mult (x *.z) (y*.z) (c_one /. z)
    


  let lemma compat_order_mult_left  (x y z : complex)
      requires{x <=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <=. z}
      ensures{  z *. x <=.  z *. y}
  = ()



  
let lemma strict_compat_order_mult  (x y z : complex)
      requires{x <. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ x *. z <. y *. z}
  = compat_order_mult x y z;
    assert { x *. z = y *. z -> x = y}

  
let lemma strict_compat_order_mult_left  (x y z : complex)
      requires{x <. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ z *. x <. z *. y}
  = ()

let lemma complete_order_real (x y: complex)
  requires{real_ x}
  requires{real_ y}
  requires{x<>y}
  requires{not (x<.y)}
  ensures{y <. x}
  =()
    
let lemma complete_order_real_ (x y: complex)
  requires{real_ x}
  requires{real_ y}
  requires{not (x<.y)}
  requires{not (y<.x)}
  ensures{y = x}
  =()
    
  let lemma compat_order_mult_both  (x y z t : complex)
      requires{c_zero <=. x <=. y}
      requires{c_zero <=. z <=. t}
      ensures{  z *. x <=.  t *. y}
  = compat_order_mult z t y;
    compat_order_mult_left x y z;
    transitive_infeq (z *. x) (z*.y) (t*.y)
  
let lemma inf_to_non_sup_eq (x y : complex)
      requires{real_ x}
      requires{real_ y}
      requires{x<.y}
      ensures{not x>=.y }
  =()
  
let lemma sup_eq_to_non_inf (x y : complex)
      requires{real_ x}
      requires{real_ y}
      requires{ x >=.y }
      ensures{not x<.y}
  =()

let lemma sup_to_inf (x y : complex)
      requires{real_ x}
      requires{real_ y}
      requires{ x >.y }
      ensures{ y<.x}
  =()

let lemma inf_to_sup (x y : complex)
      requires{real_ x}
      requires{real_ y}
      requires{ x <.y }
      ensures{ y>.x}
  =()

let lemma sup_to_non_inf_eq (x y : complex)
      requires{real_ x}
      requires{real_ y}
      requires{x>.y}
      ensures{not x<=.y }
  =()
  
let lemma inf_eq_to_non_sup (x y : complex)
      requires{real_ x}
      requires{real_ y}
      requires{ x <=.y }
      ensures{not x>.y}
  =()

let lemma non_inf_eq_to_sup (x y : complex)
      requires{real_ x}
      requires{real_ y}
      requires{not x<=.y }
      ensures{x>.y}
  =()

  let lemma non_sup_toinf_eq (x y : complex)
      requires{real_ x}
      requires{real_ y}
      requires{not x>.y}
      ensures{ x <=.y }
  =()

let lemma real_mult (x y: complex)
  requires{real_ x}
  requires{real_ y}
  ensures{real_ (x *. y)}
  =()

let lemma real_add (x y: complex)
  requires{real_ x}
  requires{real_ y}
  ensures{real_ (x +. y)}
  =()

let lemma real_substr (x y: complex)
  requires{real_ x}
  requires{real_ y}
  ensures{real_ (x -. y)}
  =()

(* let lemma real_inv (x: complex)
 *       requires{real_ x}
 *       requires{x <> c_zero}
 *   ensures{real_ (c_one /.  x)}
 *   = assert{x *. (c_one /. x) = c_one};
 *     decomp_mult x (c_one /. x) *)

    let lemma inv_pos (x : complex)
      requires{real_ x}
      requires{ c_zero <. x  }
      ensures{ c_zero <. c_one /.  x }
  = assert{0.0 <* real_part (c_one /.  x)}

let lemma lower_over_cons (a b c : complex)
      requires{c_zero <. c}
  requires{c_zero <=. a}
  requires{a<=.b}
  ensures{a/.c <=. b/. c}
    =()
  
let lemma eq_to_leq_t (a b : complex)
      requires{real_ a}
      requires{a =b}
  ensures{a<=. b}
  =()

let lemma real_minus (a: complex)
      requires{real_ a}
      ensures{real_ (-.a)}
  =()
  
let lemma compat_r_to_c_infeq (a b :real)
  requires{a <=* b}
  ensures{r_to_c a <=. r_to_c b}
=()
  
let lemma compat_r_to_c_inf (a b :real)
  requires{a <* b}
  ensures{r_to_c a <. r_to_c b}
=()
  
let lemma compat_r_to_c_supeq (a b :real)
  requires{a >=* b}
  ensures{r_to_c a >=. r_to_c b}
=()
  
let lemma compat_r_to_c_sup (a b :real)
  requires{a >* b}
  ensures{r_to_c a >. r_to_c b}
=()
  
let lemma unic_inv (i j: complex)
      requires{i<>c_zero}
      requires{i *. j = c_one}
      ensures{j = inv i}
  =
  if (j<>inv i) then assert{i*.j = i*. (inv i +. (j-. inv i)) = i*. inv i +. i*.(j-. inv i) = c_one *.(j-. inv i)  }
                                                                           
let lemma inf_eq_def (x y : complex)
      ensures{x <=. y <-> (real_ x /\ real_ y /\ real_part x <=* real_part y) \/ x =y}
  =()

let lemma inf_minus (x y: complex)
  requires{x<.y}
  ensures{-. y <. -. x}
  =  assert{ y =  x +.  (y -. x)};
     assert{x-.x<. y -. x};
     assert{(x-.x) -. y<. (y -. x) -. y}


 let lemma absorbing_zero (a b: complex)
      requires{a*. b = c_zero}
      ensures{(a <> c_zero) -> (b = c_zero)}
      ensures{b <> c_zero -> a = c_zero}
  =()
  


  let lemma inf_zero_inv (z: complex)
    requires{c_zero <. z}
    ensures{c_zero <. c_one /. z}
    ensures{c_zero <=. c_one /. z}
    =
    assert{0.0 <* real_part z};
    assert{0.0 <* 1.0 /* real_part z};
    assert{real_part (c_one /. z) = 1.0 /* real_part z }

  
let lemma mult_pos (x y: complex)
  requires{c_zero<=. x}
  requires{c_zero<=. y}
  ensures{c_zero <=. x*.y}
  =()



  let lemma simpl_leq_mult_div  (a b c: complex)
        requires{real_ a}
        requires{ c_zero <. b}
      requires{a*. b <=.  c}
      ensures{a<=. (c_one /. b)*.c}
  = compat_order_mult (a*.b) c (c_one /.b)

let lemma mult_leq_c_one_leq  (a b c: complex)
      requires{ c_zero <=. a}
      requires{ c_zero <=. b <=. c_one}
      ensures{a*. b <=.  a}
  =() 

let lemma mult_leq_c_one_leq_gen  (a a' b c: complex)
      requires{ c_zero <=. a}
      requires{ c_zero <=. b <=. c_one}
      requires{a=a'}
      ensures{a*. b <=.  a'}
  =() 

let lemma mult_leq_c_one  (a b : complex)
      requires{ c_zero <=. a}
      requires{exists c. a <=. c && b = c_one /. c}
      requires{c_zero<.b}
      ensures{a*. b <=.  c_one}
  = compat_order_mult a (c_one/.b) b

let lemma mult_leq_c_one_expl  (a b  d : complex)
      requires{ c_zero <=. a}
      requires{a <=.  d}
      requires{c_zero <. d}
      requires{b <=. c_one /. d}
      ensures{a*. b <=.  c_one}
  =() 

let lemma mult_leq_c_one_rev  (a b  : complex)
      requires{ c_zero <=. a}
      requires{ c_zero <. b}
      requires{a*.b <=. c_one}
    ensures{a <=. c_one /. b}
  = mult_leq_c_one_expl a b (c_one /. b)

let lemma simpl_leq_mult  (a b c: complex)
      requires{ c_zero <. b}
      requires{a <=.  c}
      ensures{a *. b <=. c*. b}
  =() 

let lemma simpl_leq_mult_inv  (a b c: complex)
      requires{ c_zero <. a}
      requires{ c_zero <. b}
      requires{ c_zero <. c}
      requires{a <=.  c_one /.(b*.c)}
      ensures{a *. b<=. (c_one /. c)}
  = simpl_leq_mult a b (c_one /.(b*.c))

let lemma mult_to_div_leq(a b c: complex)
      requires{real_ a}
      requires{ c_zero <. b}
      requires{a*. b <=. c}
  ensures{ a <=. (c_one /. b) *.c }
  = compat_order_mult (a*. b) c (c_one/.b)

let lemma mult_div (x y: complex)
  requires{c_zero<=. x}
  requires{c_zero<. y}
  ensures{c_zero <=. x/.y}
  = mult_pos x (c_one /. y)

let lemma strict_mult_pos (x y: complex)
  requires{c_zero<. x}
  requires{c_zero<. y}
  ensures{c_zero <. x*.y}
  =()

let lemma rewrite_supeq (x y: complex)
      requires{x<=. y}
      ensures{y>=.x}
  =()

let lemma rewrite_sup (x y: complex)
      requires{x<. y}
      ensures{y>.x}
  =()

let lemma inv_order_complex (a b: complex)
requires{c_zero <. a}
requires{c_zero <. b}
requires{a<=.b}
ensures{c_one/.b <=.c_one /.a}
= assert{c_one/.b = a /. (a*.b) = a*. (c_one /. (a*.b))};
    assert{c_one/.a = b /. (a*.b) = b*. (c_one /. (a*.b) )};
    compat_order_mult a b (c_one /. (a*.b))


  
let lemma compat_inv_order  (a b c : complex)
  requires{c_zero <. a <=. b}
  requires{c <=. c_one /. b}
  ensures{c <=. c_one /. a}
    =()

  
let lemma leq_by_div_simpl (a b c: complex)
  requires{c_zero <=. a}
  requires{c_zero <. b <=. c}
  ensures{a /. c <=. a /. b}
  = compat_order_mult (c_one/.c) (c_one/.b) a
  
let lemma leq_by_div (a b c: complex)
  requires{c_zero <=. a}
  requires{c_zero <. b <=. c}
  ensures{a /. c <=. a /. b}
  =()


let lemma strict_pos_div (x y: complex)
  requires{c_zero<. x}
  requires{c_zero<. y}
  ensures{c_zero <. x/.y}
  = strict_mult_pos x (c_one/.y)
  
let lemma inf_def (x y : complex)
      ensures{x <. y <-> real_ x /\ real_ y /\ real_part x <* real_part y}
  =inf_eq_def x y
  
let lemma sup_eq_def (x y : complex)
      ensures{x >=. y <-> (real_ x /\ real_ y /\ real_part x >=* real_part y) \/ x =y}
  =inf_eq_def x y
  
let lemma sup_def (x y : complex)
      ensures{x >. y <-> real_ x /\ real_ y /\ real_part x >* real_part y}
  =sup_eq_def x y  
  
let lemma assoc_mult_div (x y z: complex)
      requires{z<> c_zero}
  ensures{x*. (y/.z) = (x*.y)/.z}
  =()
  
let lemma assoc_mult_div_rev (x y z: complex)
      requires{z<> c_zero}
  ensures{(x*.y)/.z = x*. (y/.z) }
  =()
  
let lemma subst_zero (a  : complex)
  ensures{a -. c_zero = a}
    =()

  let lemma subst_zero_gen (a b : complex)
      requires{b=c_zero}
      ensures{a -. b = a}
    =()


let lemma transitive_inf_inv_r (a b c : complex)
  requires{a <=. b}
  requires{b <=. c_one /. c}
  requires{c_one <. c}
  ensures{a<=. b <. c_one}
    =()

let lemma infeq_scal_r (a b c : complex)
  requires{a <=. c}
  requires{c_zero <=. b}
  ensures{a *. b<=.c*.b}
    =()

let lemma infeq_scal_l (a b c : complex)
  requires{a <=. c}
  requires{c_zero <=. b}
  ensures{b *. a<=. b *.c}
    =()

let lemma transitive_supeq (a b c : complex)
  requires{a >=. b}
  requires{b >=. c}
  ensures{a>=.c}
    =()

let lemma transitive_inf_l (a b c : complex)
  requires{a <. b}
  requires{b <=. c}
  ensures{a<.c}
    =()

let lemma transitive_sup_l (a b c : complex)
  requires{a >. b}
  requires{b >=. c}
  ensures{a>.c}
    =()

let lemma transitive_inf_r (a b c : complex)
  requires{a <=. b}
  requires{b <. c}
  ensures{a<.c}
    =()

let lemma transitive_sup_r (a b c : complex)
  requires{a >=. b}
  requires{b >. c}
  ensures{a>.c}
    =()

let lemma simpl_frac_r (x y: complex)
      requires{x<> c_zero}
      ensures{x*. (y/.x) = y}
  =()
    
let lemma compat_mult_sup_eq_right (a b c : complex)
requires{c_zero<=.a}
      requires{b >=. c}
  ensures{a*. b >=. a*.c}
    =()

let lemma compat_mult_sup_right (a b c : complex)
requires{c_zero<.a}
      requires{b >. c}
  ensures{a*. b >. a*.c}
    =()

let lemma compat_mult_inf_right (a b c : complex)
requires{c_zero<.a}
      requires{b <. c}
  ensures{a*. b <. a*.c}
    =()

let lemma infeq_to_supeq (a b  : complex)
  requires{a <=. b}
  ensures{b>=.a}
    =()

let lemma infeq_inv (a b  : complex)
  requires{a <=. b}
  ensures{-. b <=. -.a}
    =()

let lemma infeq_inv_add_l (a b c : complex)
  requires{a +. c <=. b}
  requires{real_ a}
  requires{real_ c}
  ensures{a <=. b -. c}
    = compat_order_substr (a+.c) b c

let lemma infeq_inv_add_r (a b c : complex)
      requires{real_ a}
      requires{real_ c}
      requires{a  <=. b +. c}
  ensures{a -. c <=. b }
    = compat_order_substr a (b+.c) c

  let lemma r_to_c_surj (x y:real)
        requires{x <> y}
        ensures{r_to_c x <> r_to_c y}
    = assert{r_to_c (x-* y) = r_to_c x -. r_to_c y}
    (* ;
     *  assert{r_to_c (x-* y) <> c_zero} *)

  let lemma r_to_c_inf_rev (x y:real)
        requires{x <* y}
        ensures{r_to_c x <. r_to_c y}
    = assert{r_to_c (y-* x) = r_to_c (y +* (-*x ))};
      assert{r_to_c (y-* x) = r_to_c y -. r_to_c x};
     assert{ c_zero <. r_to_c (y-* x)}

let lemma div_simpl (a b: complex)
  requires{c_zero <. a}
  requires{c_zero <. b}
  ensures{c_one /. b = a /. (a*.b)}
  =()
    
let lemma infeq_inv_subs_l (a b c : complex)
      requires{real_ a}
      requires{real_ b}
      requires{real_ c}
      requires{a -. c <=. b}
  ensures{a <=. b +. c}
    = compat_order_add (a -. c)  b c

let lemma infeq_inv_subs_r (a b c : complex)
      requires{real_ a}
      requires{real_ b}
      requires{real_ c}
  requires{a  <=. b -. c}
  ensures{a +. c <=. b }
    =()

let lemma infeq_pos_elim (a b : complex)
      requires{real_ a}
      requires{c_zero <=. b}
  ensures{a  <=. a+.b }
    =()

let lemma infeq_pos_elim_add (a b c : complex)
      requires{real_ a}
      requires{real_ b}
      requires{real_ c}
       requires{c_zero <=. b}
       requires{c <=. a}
       ensures{c <=. a+.b}
=()
  
let lemma supeq_elim_left (a b: complex)
      requires{real_ a}
      requires{real_ b}
      requires{a>=.b}
      ensures{c_zero >=. b -.a}
  =()

let lemma sup_elim_left (a b: complex)
      requires{a>.b}
      ensures{c_zero >. b -.a}
  =()

let lemma infeq_elim_left (a b: complex)
      requires{real_ a}
      requires{real_ b}
      requires{a<=.b}
      ensures{c_zero <=. b -.a}
  =()

let lemma inf_elim_left (a b: complex)
      requires{a<.b}
      ensures{c_zero <. b -.a}
  =()
           
let lemma t_im_real (a b: complex)
  ensures{t_im_part (a*.b) = (t_real_part a *. t_im_part b) +. (t_im_part a *. t_real_part b) }
= decomp_mult_im_part a b

let lemma t_decomp_mult (a b : complex)
      ensures{a*. b = ((t_real_part a *. t_real_part b) -. (t_im_part a *. t_im_part b))
      +. (im *. ((t_real_part a *. t_im_part b) +. (t_im_part a *. t_real_part b)))}
=()  

let lemma t_complex_decomp (i: complex)
      ensures{i = t_real_part i +. im *. t_im_part i}
  =()
  
let lemma t_unic_decomp (i a b: complex)
      requires{real_ a}
      requires{real_ b}
      requires{i = a +. im *. b}
      ensures{a = t_real_part i}
      ensures{b = t_im_part i}
  = unic_decomp i (real_part a)  (real_part b)  

let lemma t_decomp_minus (i a b: complex)
      requires{real_ a}
      requires{real_ b}
      requires{i = a -. im *. b}
      ensures{a = t_real_part i}
      ensures{-. b = t_im_part i}
  =()
  
let lemma real_sum (x y: complex)
  requires{real_ x}
  requires{real_ y}
  ensures{real_ (x +. y)}
  =()

     use set.Fset
      
let lemma real_diff (x y: complex)
  requires{real_ x}
  requires{real_ y}
  ensures{real_ (x -. y)}
  =()
  
let lemma pure_im_sum (x y: complex)
  requires{pure_im_ x}
  requires{pure_im_ y}
  ensures{pure_im_ (x +. y)}
  =()

let lemma equal_decomp (x y: complex) 
      requires{ real_part x =  real_part y }
      requires{ im_part x =  im_part y }
      ensures{ x = y}
  =()
     
let lemma t_equal_decomp (x y: complex) 
      requires{ t_real_part x =  t_real_part y }
      requires{ t_im_part x =  t_im_part y }
      ensures{ x = y}
  =()
  
let lemma pure_im_diff (x y: complex)
  requires{pure_im_ x}
  requires{pure_im_ y}
  ensures{pure_im_ (x -. y)}
  =()
  
    
let lemma real_div (x y: complex)
      requires{real_ x}
      requires{y <> c_zero}
  requires{real_ y}
  ensures{real_ (x /. y)}
  =()

let lemma mult_im_im (a b: complex)
      requires{pure_im_ a}
      requires{pure_im_ b}
      ensures{a*.b = im *. im *. (r_to_c (im_part a) *. r_to_c (im_part b))}
      ensures{a*.b = -. r_to_c (im_part a ** im_part b)}
      ensures{real_part (a*.b) =  -* (im_part a ** im_part b)}
      ensures{im_part (a*.b) =  0.0}
  = decomp_mult a b;
    unic_decomp (a*.b ) (-* (im_part a ** im_part b)) 0.0

let lemma mult_real_im (a b: complex)
      requires{real_ a}
      requires{pure_im_ b}
      ensures{a*.b = im *. (r_to_c (real_part a) *. r_to_c (im_part b))}
      ensures{a*.b = im *. r_to_c (real_part a ** im_part b)}
      ensures{real_part (a*.b) =  0.0}
      ensures{im_part (a*.b) =  (real_part a ** im_part b)}
  = decomp_mult a b;
    unic_decomp (a*.b )  0.0 (real_part a ** im_part b)

let lemma mult_im_real (a b: complex)
      requires{pure_im_ a}
      requires{real_ b}
      ensures{a*.b = im *. (r_to_c (im_part a) *. r_to_c (real_part b))}
      ensures{a*.b = im *. r_to_c (im_part a ** real_part b)}
      ensures{real_part (a*.b) =  0.0}
      ensures{im_part (a*.b) =  (im_part a ** real_part b)}
  = decomp_mult a b;
    unic_decomp (a*.b) 0.0 (im_part a ** real_part b)

let lemma decomp_mult_gen (a b: complex)
      ensures{real_part (a*. b) = (real_part a ** real_part b) -* (im_part a ** im_part b)}
      ensures{im_part (a*. b) = (real_part a ** im_part b) +* (im_part a ** real_part b)}
  =  assert{a *. b = r_to_c (real_part a ** real_part b) +. im *. (r_to_c (real_part a ** im_part b))
                     +. im *. (r_to_c (real_part b ** im_part a)) +. -. (r_to_c (im_part a  ** im_part b))};
     unic_decomp (a*. b) ((real_part a ** real_part b) -* (im_part a ** im_part b))
       ((real_part a ** im_part b) +* (im_part a ** real_part b))


let lemma inv_real (a: complex)
      requires{a <> c_zero}
      requires{real_ a}
      ensures{real_part (c_one /. a) = (1.0 /* real_part a)}
      ensures{real_  (c_one /. a)}
  =
  assert{real_part a <> 0.0};
  assert{a *. c_one /.  a = c_one};
  decomp_mult_gen a (c_one /.  a);
  assert{im_part (c_one /.  a) = 0.0}

  
let lemma div_real_real (a b: complex)
      requires{real_ a}
      requires{real_ b}
      requires{b <> c_zero}
      ensures{real_part (a/.b) =  (real_part a /* real_part b)}
  =
  mult_real_real a (c_one/.b)

     

let lemma zeroLessOne ()
      ensures{c_zero <=. c_one}
  =()

let lemma compatOrderAdd  (x y z : complex)
      requires{x <=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      ensures{ x +. z <=. y +. z}
  = assert {real_part x +* real_part z <=* real_part y +* real_part z };
    assert {real_part (x +. z) <=* real_part (y +. z) }

let lemma positive_add  (x y  : complex)
      requires{c_zero <=. x}
      requires{c_zero <=. y}
      ensures{ c_zero <=. x +. y}
  =  transitive_infeq c_zero x (x+.y)
  
let lemma strict_positive_add_l  (x y  : complex)
      requires{c_zero <. x}
      requires{c_zero <=. y}
      ensures{ c_zero <. x +. y}
  =  transitive_infeq c_zero x (x+.y)

let lemma strict_compatOrderAdd  (x y z t : complex)
      requires{x <. y}
      requires{z <. t}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{real_ t}
      ensures{ x +. z <. y +. t}
  = ()
  
let lemma compat_sup_add  (x y z t : complex)
      requires{x >. y}
      requires{z >. t}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{real_ t}
      ensures{ x +. z >. y +. t}
  = ()
  
let lemma compat_supeq_mult  (x y z : complex)
      requires{x >=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <=. z}
      ensures{ x *. z >=. y *. z}
  = ()
  
let lemma compat_supeq_div  (x y z : complex)
      requires{x >=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ x /. z >=. y /. z}
  = ()
  
let lemma compat_infeq_div  (x y z : complex)
      requires{x <=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ x /. z <=. y /. z}
  = ()
  
let lemma compat_sup_div  (x y z : complex)
      requires{x >. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ x /. z >. y /. z}
  = ()
  
let lemma compat_inf_div  (x y z : complex)
      requires{x <. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ x /. z <. y /. z}
  = ()
  

let lemma positive_prod_itself  (x   : complex)
      requires{real_ x}
      ensures{c_zero <=. x *. x}
  =  if (c_zero <=. x)
        then  compat_order_mult c_zero x x
     else
       begin
         assert{x *. x = (-. x) *. (-. x)};
         compat_order_mult c_zero (-. x) (-. x);
       end
   
let lemma strict_positive_prod_itself  (x   : complex)
      requires{real_ x}
      requires{x<>c_zero}
      ensures{c_zero <. x *. x}
  =  if (c_zero <=. x)
        then  strict_compat_order_mult c_zero x x
     else
       begin
         assert{x *. x = (-. x) *. (-. x)};
         strict_compat_order_mult c_zero (-. x)(-. x);
       end
  
let lemma compat_sup_mult  (x y z : complex)
      requires{x >=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <=. z}
      ensures{ x *. z >=. y *. z}
  = ()
  
let lemma strict_compat_sup_mult  (x y z : complex)
      requires{x >. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ x *. z >. y *. z}
  = ()

let lemma compat_sup_mult_left  (x y z : complex)
      requires{x >=. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <=. z}
      ensures{z *. x  >=. z *. y }
  = ()
  
let lemma strict_compat_sup_mult_left  (x y z : complex)
      requires{x >. y}
      requires{real_ x}
      requires{real_ y}
      requires{real_ z}
      requires{c_zero <. z}
      ensures{ z *. x  >. z*. y }
  = ()

let lemma inv_inf_eq (a b: complex)
  requires{c_zero <. a}
  requires{c_zero <. b}
  requires{a<=. b}
  ensures{c_one/.b <=. c_one/.a}
  = assert{c_one/b = a /. (a*.b) = a*. (c_one /. (a*.b))};
    assert{c_one/a = b /. (a*.b) = b*. (c_one /. (a*.b) )};
compat_order_mult_left  a b (c_one /. (a*.b))

let lemma inv_sup_eq (a b: complex)
  requires{c_zero <. a}
  requires{c_zero <. b}
  requires{a>=. b}
  ensures{c_one/.b >=. c_one/.a}
  = ()

let lemma inv_sup (x y: complex)
      requires{real_ x}
      requires{real_ y}
      requires{c_zero <. x <. y}
      ensures{c_one /.  x >. c_one /.  y}
  =  if (c_one /.  x <=. c_one /.  y) then
       assert{x *. (c_one /.  x) <. y *. (c_one /.  y)}
  
let lemma inv_eqinf (x y: complex)
      requires{real_ x}
      requires{real_ y}
      requires{c_zero <. x <=. y}
      ensures{c_one /.  x >=. c_one /.  y}
  =
  if (c_one /.  x <. c_one /.  y) then
    assert{x *. (c_one /.  x) <. x *. (c_one /.  y)}
  else ()

let lemma inv_eqsup (x y: complex)
      requires{real_ x}
      requires{real_ y}
      requires{x >=. y >. c_zero}
      ensures{c_one /.  x <=. c_one /.  y}
  =()

let lemma inv_inf (x y: complex)
      requires{real_ x}
      requires{real_ y}
      requires{x >. y  >. c_zero  }
      ensures{c_one /.  x <. c_one /.  y}
  =()
  
let lemma inv_neg (x : complex)
      requires{real_ x}
      requires{x<.  c_zero  }
      ensures{c_one /.  x <. c_zero}
  = assert{ c_zero <=.c_one /. x ->c_zero <=.  x *. (c_one /. x) }

let lemma lower_inv (a b c : complex)
  requires{c_zero <. b}
  requires{c_zero <=. a}
  requires{b<=.c}
  ensures{a/.b >=. a/. c}
  =
  if
    a/.b <. a/. c
  then
    begin
      assert{(a/.b) *. b <. (a/. c) *. c};
      assert{a <. a}
      end

let lemma lower_inv_ (a b c : complex)
  requires{c_zero <. b}
  requires{c_zero <=. a}
  requires{b<=.c}
  ensures{ a/. c <=. a/.b }
  =
  if
    a/.b <. a/. c
  then
    begin
      assert{(a/.b) *. b <. (a/. c) *. c};
      assert{a <. a}
      end
  
let lemma zero_add_t (a1 a2: complex)
      requires{a1 = c_zero}
      ensures{a1 +. a2 = a2}
  =()
  
let lemma add_zero_t (a1 a2: complex)
      requires{a2 = c_zero}
      ensures{a1 +. a2 = a1}
  =()
  
let lemma one_mult_t (a1 a2: complex)
      requires{a1 = c_one}
      ensures{a1 *. a2 = a2}
  =()
  
let lemma one_mult_t_const (a: complex)
      ensures{c_one *. a = a}
  =()
  
let lemma zero_mult_t_const (a: complex)
      ensures{c_zero *. a = c_zero}
  =()
  
let lemma mult_zero_t_const (a: complex)
      ensures{ a *. c_zero = c_zero}
  =()
  
let lemma subs_eq (a1 a2 b1 b2: complex)
      requires{a1 = a2}
      requires{b1 = b2}
      ensures{a1 -. b1 = a2 -. b2}
  =()
  
let lemma subst_itself (a1 a2 : complex)
      requires{a1 = a2}
      ensures{a1 -. a2 = c_zero}
  =()
  

  
let lemma mult_assoc_four (a b c d: complex)
      ensures{(a*. (b *.c) *.d) = (a *. b) *. (c *. d)}
  =()
  
let lemma mult_assoc_rev (a b c: complex)
      ensures{a *. (b*.c) = (a*. b) *.c}
  =()

  

let lemma add_assoc (a b c: complex)
      ensures{(a+. b) +.c = a +. (b+.c)}
  =()
  
let lemma add_assoc_rev (a b c: complex)
      ensures{a +. (b+.c) = (a+. b) +.c}
  =()

  
let lemma div_mult (a b c: complex)
      requires{c <> c_zero}
      ensures{a *. (b /.c) = (a*. b) /.c}
  =()

let lemma div_mult_rev (a b c: complex)
      requires{c <> c_zero}
      ensures{ (a*. b) /.c =a *. (b /.c)}
  =()

let lemma triang_p (a b : complex)
  ensures{(a +. b) *. (a +. b) =  a*.a  +. b*. b +. ttwo *. a*. b}
  =()
  
let lemma triang_n (a b : complex)
  ensures{(a -. b) *. (a -. b) =  a*.a +. b*. b  -. ttwo *. a*. b}
  =()
  
let lemma triang_s (a b c d e: complex)
  ensures{(a +. b +. c) +. (d -. b +. e) =  (a +. c) +. (d +. e)}
  =()

let lemma triang_t (a b : complex)
  ensures{(a +. b ) *. (a -. b) =  a*.a -. b*.b}
  =  assert{a*. (a -. b) +. b*. (a-.b) = (a +. b ) *. (a -. b)};
     assert{ a*. (a -. b)  = a*. a -. a*. b};
     assert{ b*. (a -. b)  = a*. b -. b*. b};
     assert{forall a b c: complex. (a -. b) +. (b -. c) = a-.c }

let lemma triang_sr (a b c d e: complex)
  ensures{(a -. b +. c) +. (d +. b +. e) =  (a +. c) +. (d +. e)}
  =()

let lemma add_pos (x y: complex)
  requires{c_zero <=. x}
  requires{c_zero <=. y}
  ensures{c_zero <=. x+.y}
  =()

let lemma add_pos_strit_l (x y: complex)
  requires{c_zero <. x}
  requires{c_zero <=. y}
  ensures{c_zero <. x+.y}
  =()

let lemma add_pos_strit_r (x y: complex)
  requires{c_zero <=. x}
  requires{c_zero <. y}
  ensures{c_zero <. x+.y}
  =()

let lemma modulus_pre_pre (a b c d : complex)
      ensures{((a*. b) +. (c*. d)) +. ((a*. d) +. (c*. b)) 
            = a*. (b +. d) +.  c *. (b+.d)}
      ensures{((a*. b) +. (c*. d)) +. ((a*. d) +. (c*. b)) 
            = (a +. c)*. (b +. d) }
  =()
  
let lemma modulus_pre (a b c d : complex)
      ensures{((a*. b) *. (a*. b) +. (c*. d) *. (c*. d)) +. ( (a*.d)*.(a*.d) +. (c*.b)*.(c*.b))
            = (a*.a +. c*. c) *. (b *. b +. d*.d)}
  =()

     use real.Square

val function  real_sqrt (x:real):real
                                   requires{0.0<=*x}
                                   ensures{ result ** result = x}
            ensures{result = sqrt x}
  
let function square_rt (x: complex): complex
                               requires{c_zero <=. x}
                               ensures{real_ result}
                               ensures{result *. result = x}
                               ensures{c_zero <=. result}
  = r_to_c (real_sqrt (real_part x))
  
let lemma square_rt_eq (a b: complex)
                               requires{c_zero <=. a}
                               requires{c_zero <=. b}
      requires{a = b
      }
      ensures{square_rt a = square_rt b}
      =()

         
lemma real_square_rt: forall x: complex. real_ x -> c_zero <=. x -> real_ (square_rt x)
lemma pos_square_rt: forall x: complex. real_ x -> c_zero <=. x ->  (square_rt x >=. c_zero)

let lemma square_rt_square (x: complex)
      requires{c_zero <=. x}
      ensures{square_rt x *. square_rt x = x}
  =()

let lemma square_rt_infeq (x y: complex)
      requires{real_ x}
      requires{real_ y}
      requires{c_zero <=. x <=.y}
      ensures{square_rt x <=. square_rt y}
      =()
      
      
let lemma square_rt_inf (x y: complex)
      requires{c_zero <=. x <.y}
      ensures{square_rt x <. square_rt y}
      =()
      
let lemma injective_square_rt (x y: complex)
      requires{real_ x}
      requires{real_ y}
      requires{c_zero <=. x}
      requires{c_zero <=. y}
      requires{square_rt x = square_rt y}
      ensures{ x =  y}
      =()

let lemma injective_square (x y: complex)
      requires{real_ x}
      requires{real_ y}
      requires{c_zero <=. x}
      requires{c_zero <=. y}
      requires{ x *. x = y *. y}
      ensures{ x =  y}
      =()

let lemma square_rt_c_one()
      ensures{square_rt c_one = c_one}
      = assert{sqrt 1.0 = 1.0}

         
lemma  square_rt_mult: forall t t': complex. real_ t -> c_zero <=. t ->   real_ t' -> c_zero <=. t' ->  square_rt t *.  square_rt t' =   square_rt (t*.t')
lemma  square_rt_mult_rev: forall t t': complex. real_ t -> c_zero <=. t ->   real_ t' -> c_zero <=. t' ->   square_rt (t*.t') = square_rt t *.  square_rt t' 
  
let function modulus (x: complex): complex
                               (* ensures{result = r_to_c (modulus x)} *)
                               ensures{c_zero <=. result }
           = square_rt (t_real_part x *. t_real_part x +. t_im_part x *. t_im_part x)
               
 predicate c_one_modulus (x: complex)
   = modulus x = c_one

let lemma modulus_eq (x y: complex)
  requires{t_real_part x *. t_real_part x = t_real_part y *. t_real_part y}
  requires{t_im_part x *. t_im_part x = t_im_part y *. t_im_part y}
  ensures{modulus x = modulus y}
  =()

let lemma modulus_minus (x : complex)
  ensures{modulus (-.x) = modulus x}
  =()


  
  let lemma square_rt_simpl (x: complex)
        requires{c_zero <. x}
        ensures{ x *. (c_one/. (square_rt x)) = square_rt x}
    = ()
    
  let lemma square_rt_simpl_fact (x a: complex)
        requires{c_zero <. x}
        ensures{ a *.  (c_one/. (square_rt x)) *. x  = a *. square_rt x}
    =()
    
  let lemma square_rt_simpl_mult (x a: complex)
        requires{c_zero <. x}
        ensures{square_rt x *. a *.  (c_one/. (square_rt x))   = a }
    =()
    
  let lemma square_rt_simpl_fact_assoc (x a: complex)
        requires{c_zero <. x}
        ensures{ x *. (a *. (c_one/. (square_rt x))) = a *. square_rt x}
    =()
    
let lemma modulus_itself (x y: complex)
  requires{x= y}
  ensures{modulus x = modulus y}
  =() 

let lemma modulus_real_pos (x : complex)
  requires{real_ x}
  requires{c_zero<=. x}
  ensures{modulus x = x}
  =() 


let lemma modulus_real_pos_inv (x : complex)
  requires{real_ x}
  requires{c_zero<=. x}
  ensures{modulus (-. x) = x}
  =() 

  let lemma modulus_real_neg (x : complex)
  requires{real_ x}
  requires{x<=.c_zero}
  ensures{modulus x = -.x}
  =() 

let lemma strict_positive_modulus (x : complex)
  requires{x <> c_zero }
  ensures{ c_zero <. modulus x}
  =() 

let lemma not_modulus_zero (x : complex)
  requires{x <> c_zero }
  ensures{modulus x <> c_zero}
  =() 

let lemma modulus_real (x : complex)
  ensures{real_ (modulus  x)}
  =() 

  (* let lemma t_mult_real (a b: complex)
 *   ensures{t_real_part (a*.b) = (t_real_part a *. t_real_part b) -. (t_im_part a *. t_im_part b) }
 * = decomp_mult_real_part a b
 * 
 *   let lemma t_mult_im (a b: complex)
 *   ensures{t_im_part (a*.b) = (t_real_part a *. t_im_part b) +. (t_im_part a *. t_im_part b) }
 * = decomp_mult_real_part a b *)

  let lemma t_mult_real_square (a b: complex)
        ensures{t_real_part (a*.b) *. t_real_part (a*.b) = (t_real_part a *. t_real_part a) *. (t_real_part b *. t_real_part b) +.
                                                             (t_im_part a *. t_im_part a) *. (t_im_part b *. t_im_part b)
                                                           -. ttwo *. (t_real_part a *. t_real_part b *. t_im_part a *. t_im_part b) }
    = t_mult_real a b;
      triang_n (t_real_part a *. t_real_part b)  (t_im_part a *. t_im_part b);
      assert{forall a b  : complex. (a*.b)*.(a*.b) = (a*.a)*.(b*.b)}
      
  let lemma t_mult_im_square (a b: complex)
        ensures{t_im_part (a*.b) *. t_im_part (a*.b) = (t_real_part a *. t_real_part a) *. (t_im_part b *. t_im_part b) +.
                                                             (t_im_part a *. t_im_part a) *. (t_real_part b *. t_real_part b)
                                                           +. ttwo *. (t_real_part a *. t_real_part b *. t_im_part a *. t_im_part b) }
    = t_mult_im a b;
      triang_p (t_real_part a *. t_im_part b)  (t_im_part a *. t_real_part b);
      assert{forall a b : complex. (a*.b)*.(a*.b) = (a*.a)*.(b*.b)}
      

let lemma mult_modulus_pre (a b: complex)
      ensures{(t_real_part (a*.b) *. t_real_part (a*.b)) +. (t_im_part (a*.b) *. t_im_part (a*.b)) =  (((t_real_part a *. t_real_part a) +. (t_im_part a *. t_im_part a))
                                                                                                 *. ((t_real_part b *. t_real_part b) +. (t_im_part b *. t_im_part b)))}
  =t_mult_real_square a b;
   t_mult_im_square a b;
   assert{forall a b c d x. (a*.c +. b*.d -. x)+. (a*. d+. b*.c +. x)= (a+.b)*.(c+.d)}
=()  

  
let lemma mult_modulus (x y: complex)
ensures{modulus (x*.y) = modulus x *. modulus y}
  =()

let lemma mult_modulus_rev (x y: complex)
ensures{modulus x *. modulus y = modulus (x*.y)}
  =()

     let lemma modulus_real_minus_bound (a b c : complex)
           requires{real_ a}
           requires{real_ b}
           requires{real_ c}
           requires{c_zero<=.a}
           requires{c_zero<=.b}
           requires{c_zero<=.c}
           requires{modulus (a-b) <=. c}
           ensures{a-.c <=. b <=. a+.c}
       =()
       
let lemma mult_real_modulus (x y: complex)
      requires{real_ x}
      requires{c_zero <=. x}
      ensures{modulus (x*.y) =  x *. modulus y}
  =mult_modulus x y;
   modulus_real_pos x

let lemma mult_real_modulus_rev (x y: complex)
      requires{real_ x}
      requires{c_zero <=. x}
      ensures{ x *. modulus y = modulus (x*.y)}
  =mult_modulus x y;
   modulus_real_pos x

let lemma modulus_real_div (x y: complex)
      requires{real_ x}
      requires{c_zero <. x}
      ensures{modulus y /.x =   modulus (y/.x)}
  =mult_modulus x y;
   modulus_real_pos x

let lemma mult_modulus_real (x y: complex)
      requires{real_ y}
      requires{c_zero <=. y}
      ensures{modulus (x*.y) = modulus x *.  y}
  =mult_modulus x y;
   modulus_real_pos y


  
let lemma mult_modulus_non_null (x y: complex)
      requires{x<>c_zero}
      requires{y<>c_zero}
      ensures{modulus (x*.y) <> c_zero}
  =()
  
let lemma modulus_to_non_null (x y: complex)
      requires{c_zero <. modulus x}
      ensures{x <> c_zero}
  =()
  
let lemma mult_c_one_modulus (x y: complex)
requires{c_one_modulus x}
requires{c_one_modulus y}
ensures{c_one_modulus (x*.y)}
  =()

let lemma modulus_pos (x: complex)
      requires{x <> c_zero}
      ensures{c_zero <=. modulus x}
  =()

let lemma modulus_infeq (x b c: complex)
             requires{real_ x}
             requires{b<=. c}
             requires{modulus x <=. b}
             ensures{x <=. c}
=()    

let lemma modulus_inf (x b c: complex)
             requires{real_ x}
             requires{b<. c}
             requires{modulus x <=. b}
             ensures{x <. c}
=()    

let lemma modulus_diff_rev (a b: complex)
      ensures{modulus (a-.b) = modulus (b-.a)}
  =()

let lemma modulus_simpl_leq (a b c: complex)
      requires{real_ a}
      requires{real_ b}
      requires{real_ c}
      requires{c_zero<.c}
requires{modulus (a*. c) <=. b *.  c}     
  ensures{modulus a <=. b}
  =()
  
let lemma modulus_simpl_leq_rev (a b c: complex)
      requires{real_ a}
      requires{real_ b}
      requires{real_ c}
     requires{c_zero<=.c}
  requires{modulus a <=. b}
ensures{modulus (a*. c) <=. b *.  c}     
  =()
  
let lemma div_eq (a1 a2 b1 b2 : complex)
      requires{a1 =a2}
      requires{b1 =b2}  
      requires{b1 <> c_zero}
      ensures{a1 /. b1 = a2 /. b2}
  =()  
  
let lemma add_eq_inv_t (a1 a2 b1 b2: complex)
      requires{a1 = a2}
      requires{b1 = b2}
      ensures{a1 +.b1 = b2 +. a2}
  =()
  
let lemma mult_eq_inv_t (a1 a2 b1 b2: complex)
      requires{a1 = a2}
      requires{b1 = b2}
      ensures{a1 *. b1 = b2 *. a2}
  =()

  
let lemma sum_frac (a1 a2 b: complex)
      requires{b<>c_zero}
      ensures{a1/. b +. a2 /. b = (a1 +. a2)/. b}
  =()

let lemma sum_frac_rev (a1 a2 b: complex)
      requires{b<>c_zero}
      ensures{(a1 +. a2)/. b =a1/. b +. a2 /. b}
  =()

let lemma div_pos (x y: complex)
  requires{c_zero<=. x}
  requires{c_zero<. y}
  ensures{c_zero <=. x/.y}
  = mult_pos x (c_one /.y)
                                                           end

                                                      
                                                      
                                                             
