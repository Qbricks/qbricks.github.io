module Simpl_op
         use complex.Complex
         use complex.P_real
 use set.FsetComprehension
         use  fsum.Int_iter
         use  set.Fset
         (* use export Base_type *)
         use int.Int

let lemma add_im_re (i j:complex)
  ensures{i +. j = t_real_part i +. t_real_part j +. im *.(t_im_part i +. t_im_part j)}
  ensures{t_real_part (i+.j) = t_real_part i +. t_real_part j}
  ensures{t_im_part (i+.j) = t_im_part i +. t_im_part j}
  =
assert{i+.j = (t_real_part i +.  im *. t_im_part i) +. (t_real_part j  +. im*. t_im_part j) };
assert{i+.j = t_real_part i +.  im *. t_im_part i +. t_real_part j  +. im*. t_im_part j };
  unic_decomp (i+.j) (real_part i +* real_part j) (im_part i +* im_part j)
  
let lemma add_real_part (i j:complex)
      ensures{t_real_part i +. t_real_part j = t_real_part (i+. j)}
  = ()
  
let lemma add_im_part (i j:complex)
      ensures{t_im_part i +. t_im_part j = t_im_part (i+. j)}
  = ()
  
let lemma add_real_part_rev (i j:complex)
      ensures{ t_real_part (i+. j) = t_real_part i +. t_real_part j}
  = ()
  
let lemma add_im_part_rev (i j:complex)
      ensures{t_im_part (i+. j) = t_im_part i +. t_im_part j }
  = ()

let lemma mult_distr_add_r (a b c:complex)
  ensures{a *. (b+.c) = a*. b+. a*. c}
  =()

let lemma add_add_minus (a b c:complex)
  ensures{a +. (b -.c) = a+. b -. c}
  =()

let lemma mult_distr_minus (a b c:complex)
  ensures{a *. (b -.c) = a*. b -. a*. c}
  =()

let lemma minus_out (a b c:complex)
  ensures{-.a *. b = -. (a*. b) }
  =()


let lemma mult_distr_add_r_rev (a b c:complex)
  ensures{a*. b+. a*. c = a *. (b+.c)}
  =()

let lemma mult_distr_minus_rev (a b c:complex)
  ensures{a*. b -. a*. c = a *. (b -.c) }
  =()


  
let lemma div_distr_add (a b c:complex)
      requires{a <> c_zero}
      ensures{ (b+.c) /.a = b /. a+.  c /. a}
  =()
  
let lemma div_distr_minus (a b c:complex)
      requires{a <> c_zero}
      ensures{ (b-.c) /.a = b /. a -.  c /. a}
  =()
  

let lemma div_distr_add_rev (a b c:complex)
      requires{a <> c_zero}
      ensures{ b /. a+.  c /. a = (b+.c) /.a}
  =()
  
let lemma div_distr_minus_rev (a b c:complex)
      requires{a <> c_zero}
      ensures{b /. a -.  c /. a = (b-.c) /.a  }
  =()
  
let lemma mult_distr_add_l (a b c:complex)
  ensures{(b+.c) *. a = a*. b +. a*. c}
  =()
  
let lemma mult_distr_add_l_rev (a b c:complex)
  ensures{b*. a +. c*. a = (b+.c) *. a}
  =()
  
let lemma mult_distr_minus_r (a b c:complex)
  ensures{a *. (b-.c) = a*. b-. a*. c}
  =()

let lemma mult_distr_minus_ll (a b c:complex)
  ensures{(-. b +.c) *. a = (-.a*. b) +. a*. c}
  =()

let lemma mult_distr_minus_ri (a b c:complex)
  ensures{ (b -.c) *. a = a*. b -. a*. c}
  =()

  
let lemma minus_distr_op (a b c:complex)
  ensures{a -. (b +.c) = a -. b -.  c}
  =()

let lemma mult_distr_minus_l (a b c:complex)
  ensures{(b-.c) *. a = a*. b -. a*. c}
  =()
  
let lemma assoc_right (a b c:complex)
  ensures{a+. (b+.c)   = a +. b+.c}
  =()
  
let lemma assoc_right_mult (a b c:complex)
  ensures{a *. (b*.c)   = a *. b*.c}
  =()
  
let lemma minus_elim (a b c:complex)
  ensures{a -. b = a +. (-.b)}
  =()

let lemma minus_eq_t (a b a' b':complex)
requires{a=a'}
requires{b=b'}
      ensures{a -. b = a' -. b'}
  =()

let lemma minus_distr_elim (a b c:complex)
  ensures{a -. (b +.c) = a +. (-. b)  +. (-.  c)}
  =()
  
let lemma plus_minus_distr_elim (a b c:complex)
  ensures{a +. (-. (b +.c)) = a +. (-. b)  +. (-.  c)}
  =()
  

let lemma def_by_minus (x y z:complex)
    requires{x= y-.z}
    ensures{y= x+.z}
  =()


  
let lemma switch (a b c:complex)
  ensures{a +. b +. c = a +. c+.b}
  =()
  
let lemma meet_a_c (a b c d:complex)
  ensures{a +. b +. c +. d= a +. c+.b +. d}
  =()
  
let lemma meet_a_d (a b c d:complex)
  ensures{a +. b +. c +. d= a +. d+.b +. c}
  =()
  
let lemma meet_b_c (a b c d:complex)
  ensures{a +. b +. c +. d= b +. c+.a +. d}
  =()
  
let lemma meet_b_d (a b c d:complex)
  ensures{a +. b +. c +. d= b +. d+.a +. c}
  =()
  
let lemma meet_c_d (a b c d:complex)
  ensures{a +. b +. c +. d= c +. d+.a +. b}
  =()
  
let lemma inv_add (a b  :complex)
  ensures{a +. (-.a) +. b = b }
  =()
  
let lemma switch_m (a b c:complex)
  ensures{a +. b +. c = a +. c+.b}
  =()
  
let lemma meet_a_c_m (a b c d:complex)
  ensures{a +. b +. c +. d= a +. c+.b +. d}
  =()
  
let lemma meet_a_d_m (a b c d:complex)
  ensures{a +. b +. c +. d= a +. d+.b +. c}
  =()
  
let lemma meet_b_c_m (a b c d:complex)
  ensures{a +. b +. c +. d= b +. c+.a +. d}
  =()
  
let lemma meet_b_d_m (a b c d:complex)
  ensures{a +. b +. c +. d= b +. d+.a +. c}
  =()
  
let lemma meet_c_d_m (a b c d:complex)
  ensures{a +. b +. c +. d= c +. d+.a +. b}
  =()


let lemma t_real_part_add (a b:complex)
      ensures{t_real_part (a+.b) = t_real_part a +. t_real_part b}
  =()

let lemma t_real_part_subs (a b:complex)
      ensures{t_real_part (a-.b) = t_real_part a -. t_real_part b}
  =()

let lemma t_im_part_add (a b:complex)
      ensures{t_im_part (a+.b) = t_im_part a +. t_im_part b}
  =()

let lemma t_im_part_subs (a b:complex)
      ensures{t_im_part (a-.b) = t_im_part a -. t_im_part b}
  =()

let lemma t_real_part_real (a:complex)
  requires{real_ a}
  ensures{t_real_part a = a}
  =()

let lemma t_real_part_im (a:complex)
  requires{pure_im_ a}
  ensures{t_real_part a = c_zero}
  =()

let lemma im_t_im_part_im (a:complex)
  requires{pure_im_ a}
  ensures{im *. t_im_part a =  a}
  =()

let lemma t_im_part_im (a:complex)
  requires{pure_im_ a}
  ensures{ t_im_part a =  -. im *. a}
  = assert{a = im *. t_im_part a};
    assert{im *. a = (im *. im) *. t_im_part a}

let lemma t_im_part_real (a:complex)
  requires{real_ a}
  ensures{t_im_part a = c_zero}
  =()

let lemma a_div_b_mult_a (a b c d:complex)
  requires{b <> c_zero}
  requires{c <> c_zero}
  requires{d = c_one /. b}
  requires{a = c}
  ensures{(a/.b) *. (c_one /. c) = d}
  =()
  
end


module Base_type
         use Simpl_op
         use  int.Int
         use export complex.Complex
         use  fsum.Iterations
         use  fsum.Set_iter
         use  set.FsetComprehension
         use  fsum.Int_iter
         use  set.Fset
         use  p_set.Fset_comp
         use  p_set.IndexestoSet
         clone  fsum.Fset_iter_Pos
         use  ref.Ref
         use  functions.MapInjection
         use  complex.Pairs
     
let function couple (f: 'a -> 'b -> 'im) (o :('a,'b)):  'im
  =  let (a,b) = o in f a b

                        lemma null_product: forall a b:complex. a*. b = c_zero ->
                               a = c_zero \/ b = c_zero

let lemma couple_value (f: 'a -> 'b -> 'im) (o :('a,'b))
  ensures{couple f o = f (fir o) (sec o)}
  =()
  
let lemma couple_value_dev (f: 'a -> 'b -> 'im) (o :('a,'b)) (a:'a) (b:'b)
      requires{o = (a,b)}
      ensures{couple f o = f a b}
  =()
  
let lemma neutral_c_zero  ()
      ensures{neutral  (+.) c_zero}
      ensures{iterable (+.)}
  = set_neutral  (+.) c_zero
  
let  function sum (s: set 'a) (t : 'a -> complex):complex
  = iterate (+.) s t

      predicate eq_t (a a' :complex)= a = a'

let lemma sum_empty  (s:set 'a) (t : 'a -> complex)
      requires{is_empty s}
      ensures{sum s t = c_zero}
  = iterate_empty (+.) s t
  
let lemma sum_one   (s:set 'a) (t : 'a -> complex)
      requires{cardinal  s = 1}
      (* requires{iterable op} *)
      ensures{sum s t = t (choose s)}
  = iterate_one (+.) s t

let   lemma sum_add (s: set 'b)(f: 'b -> complex)(x: 'b)
        requires{not mem x s}
        ensures{sum (add x s) f  = (f x) +. sum s f}
  = iterate_add (+.) s f x

let   lemma sum_plus_one (s: set 'b)(f: 'b -> complex)
        requires{cardinal s >1}
        ensures{sum s f  = (f (choose s)) +. sum (remove (choose s)s) f}
  = sum_add (remove (choose s)s) f (choose s)

let rec  lemma sum_partition  (s s': set 'b)(f: 'b -> complex)
        (* requires{cardinal s >1} *)
        requires{forall e. mem e s -> not (mem e s')}
        ensures{sum (union s s') f  = sum s f +. sum s' f}
       variant{cardinal s'}
  = if cardinal s' = 0 then ()
    else
      if cardinal s' = 1 then sum_add s f (choose s')
      else
      begin
        assert{union s s' = union (add (choose s' ) s) (remove (choose s') s')};
        sum_partition (add (choose s') s) (remove (choose s') s') f;
        sum_plus_one s' f;
        sum_add s f (choose s');
      end



let rec lemma sum_real (s: set 'a) (f: 'a -> complex)
  requires{forall a. mem a s -> real_ (f a)}
  ensures{real_ (sum s f)}
  requires{cardinal s >0}
  variant{cardinal s}
  = if cardinal s = 1 then sum_one s f
  else
begin
    sum_real (remove (choose s) s) f;
    sum_add  (remove (choose s) s) f  (choose s);
    real_sum (f (choose s)) (sum (remove (choose s) s) f)
end

  
let   lemma map_sum_eq (s: set 'b)(f: 'b -> 'a)(t: 'a -> complex)
        requires{p_injective f s}
        ensures{sum  (map  f s) t  = sum s (fun b -> t (f b))}
  = iterate_map (+.) s f t

let lemma sum_comp (s: set 'b)(f g: 'b -> complex)
      ensures{sum s (fun k -> f k +. g k) = sum s f +. sum s g}
  = iterate_comp_iterate (+.) s f g
  
let lemma sum_comp_rev (s: set 'b)(f g: 'b -> complex)
      ensures{sum s f +. sum s g = sum s (fun k -> f k +. g k)}
  = sum_comp s f g
  
let lemma sum_iter_ ()
      ensures{opposite_n (+.) (-.) c_zero}
      ensures{opposite (+.) (-.)}
      ensures{opposite_com (+.) (-.)} 
      ensures{inverse_tuple (+.) (-.) c_zero}
  = ()

      lemma neutral_zero: neutral_elt (+.) = c_zero

let lemma sum_eq (s: set 'a) (f g : 'a -> complex)
      requires{forall x. mem x s -> f x = g x}
      ensures{sum s f = sum s g}
  = iterate_eq (+.)s f g

let lemma sum_eq_gen (s s': set 'a) (f g : 'a -> complex)
      requires{s = s'}
      requires{forall x. mem x s -> f x = g x}
      ensures{sum s f = sum s' g}
  = sum_eq s f g

let   lemma sum_disjoint_transitivity  (s1 s2: set 'a)(t: 'a -> complex)
        requires{inter s1 s2 = empty}
        ensures{sum (union s1 s2) t =  (sum s1 t)  +. ( sum s2 t)}
  = iterate_disjoint_transitivity (+.) s1 s2 t

let lemma sum_to_cartesian_product  (s1: set 'a)(s2: set 'b)(f : 'a -> 'b -> complex) 
      ensures{sum s1 (fun a -> sum s2 (f a) ) = sum (cartesian_product s1 s2) (fun o -> f (fir o) (sec o))}
  = iterate_cartesian_product (+.) s1 s2 f
  
let lemma sum_from_cartesian_product  (s1: set 'a)(s2: set 'b)(f : 'a -> 'b -> complex) 
      ensures{sum (cartesian_product s1 s2) (fun o -> f (fir o) (sec o)) = sum s1 (fun a -> sum s2 (f a) )}
  = sum_to_cartesian_product s1 s2 f
  
let  function ind_sum  (f :int -> complex) (i:int) (j:int) 
  = int_iterate ( +.) f i j


  
let lemma ind_sum_to_int_iterate  (f :int -> complex) (i:int) (j:int) 
      ensures{ind_sum f i j  = int_iterate ( +.) f i j}
  =()

let lemma ind_sum_cardone (f :int -> complex) (i:int) (j:int)  
      requires{j = i+1}
      ensures{ ind_sum f i j =  f i}
  = int_iterate_cardone (+.) f i j

let lemma ind_sum_right_extension   (f :int -> complex) (i:int) (j:int)
      ensures{i< j -> ind_sum f i j = ind_sum f i (j-1) +. (f (j-1))}
  = int_iterate_right_extension (+.) f i j

let rec lemma ind_sum_trans (f :int -> complex) (i k j:int)
          requires{i<=k<=j}
          ensures{ind_sum f i j  = ind_sum f i k +. ind_sum f k j }
          variant{(j-k)}
=      if (j-k = 0) then ()
      else if (j-k = 1) then ind_sum_right_extension f i j
      else
        begin
          ind_sum_right_extension f i j;
          ind_sum_trans f i k (j-1)
        end
  
let lemma ind_sum_plus_one (f :int -> complex) (i:int) (j:int) 
      requires{i < j}
      ensures{ ind_sum f i j =  (f i) +. ( ind_sum f (i+1) j)}
  = int_iterate_def_plus_one (+.) f i j

let rec lemma real_ind_sum (f :int -> complex) (i:int) (j:int)
          requires{i<j}
          requires{forall k. i<= k < j -> real_ (f k)}
          ensures{real_ (ind_sum f i j)}
      variant{j - i}
  = if i + 1 = j
    then ind_sum_cardone f i j
    else
      begin
        real_ind_sum f (i+1) j;
        real_ind_sum f i (i+1);
        ind_sum_plus_one f i j;
      end
  
let rec lemma positive_ind_sum (f :int -> complex) (i:int) (j:int)
          requires{i<j}
          requires{forall k. i<= k < j -> c_zero <=. (f k)}
          ensures{c_zero <=. ind_sum f i j}
      variant{j - i}
  = if i + 1 = j
    then ind_sum_cardone f i j
    else
      begin
        positive_ind_sum f (i+1) j;
        ind_sum_plus_one f i j;
      end
  
let rec lemma positive_sum (s: set 'a) (f :'a -> complex) 
          requires{forall k. mem k s -> c_zero <=. f k}
          ensures{c_zero <=. sum s f }
      variant{cardinal s}
  = if cardinal s = 0 then ()
    else
      begin
        positive_sum (remove (choose s) s) f ;
        sum_add (remove (choose s)s)  f (choose s) ;
      end
  
let rec lemma ind_sum_eq  (f g : int -> complex) i j
          requires{forall k : int. i <= k < j -> f k = g k}
          ensures{ ind_sum f i j = ind_sum   g i j}
          variant {j - i}=
  int_iterate_eq (+.)  f g i j
  
let  lemma ind_sum_eq_del_bound  (f : int -> complex) (g:complex) i j
       ensures{ ind_sum (fun k -> if  i<= k < j then f k else g) i j = ind_sum   f i j}
  = ind_sum_eq (fun k -> if  i<= k < j then f k else g) f  i j

let  lemma ind_sum_eq_del_bound_rev  (f : int -> complex) (g:complex) i j
       ensures{ind_sum   f i j =  ind_sum (fun k -> if  i<= k < j then f k else g) i j}
  = ind_sum_eq_del_bound f g i j

let  lemma ind_sum_eq_gen  (f g : int -> complex) (i1 j1 i2 j2:int)
       requires{i1 = i2}
       requires{j1 = j2}
       requires{forall k : int. i1 <= k < j1 -> f k = g k}
       ensures{ ind_sum f i1 j1 = ind_sum   g i2 j2}
  = ind_sum_eq  f g i1 j1

let lemma ind_sum_eq_bound  (f g : int -> complex) (i j:int)
      requires{i = j}
      requires{forall k : int. 0 <= k < j -> f k = g k}
      ensures{ ind_sum f 0 i = ind_sum   g 0 j}
  = ind_sum_eq f g 0 i

let lemma ind_sum_comp (f g:int -> complex) (i j:int)
      ensures{ind_sum (fun k -> f k +. g k) i j = (ind_sum f i j) +. (ind_sum g i j)}
  = int_iterate_comp_iterate (+.) f g i j


let lemma ind_sum_comp_rev (f g:int -> complex) (i i' j j':int)
      requires{i = i'}
      requires{j = j'}
      ensures{ind_sum f i j +. ind_sum g i' j' = ind_sum (fun k -> f k +. g k) i j }
  = ind_sum_comp f g i j

let lemma ind_sum_to_iterate  (f :int -> complex) (i:int) (j:int) 
      ensures{ind_sum f i j = iterate ( +.) (to_fset  i j) f}
  = int_iterate_to_iterate (+.) f i j 
  
let lemma ind_sum_to_sum  (f :int -> complex) (i:int) (j:int) 
      ensures{ind_sum f i j = sum (to_fset  i j) f}
  = () 
  
  
  
let   lemma map_ind_sum_eq (i j k l:int)(f: int -> int)(t: int -> complex)
        requires{p_bijective f (to_fset i j) (to_fset k l )}
        ensures{ind_sum  t k l  = ind_sum  (fun b -> t (f b)) i j}
  = map_sum_eq  (to_fset i j) f t

let rec lemma sum_scal(f: 'a-> complex)  (s:set 'a) (c:complex)
          ensures{sum s (fun x -> c*. (f x)) = c *. (sum s f)}
          variant{cardinal s}
  = if (is_empty s) then
      begin
        sum_empty s f;
        sum_empty s (fun x -> c*. (f x));
      end
    else
      begin
        sum_add (remove (choose s)s)  f (choose s) ;
        sum_add (remove (choose s)s)  (fun x -> c*. (f x)) (choose s); 
        sum_scal f (remove (choose s)s)  c;
      end

let rec lemma sum_scal_right(f: 'a-> complex)  (s:set 'a) (c:complex)
          ensures{sum s (fun x ->  (f x) *. c) = (sum s f) *. c}
          variant{cardinal s}
  = if (is_empty s) then
      begin
        sum_empty s f;
        sum_empty s (fun x ->  (f x) *. c);
      end
    else
      begin
        sum_add (remove (choose s)s)  f (choose s) ;
        sum_add (remove (choose s)s)  (fun x ->  (f x) *. c) (choose s); 
        sum_scal_right f (remove (choose s)s)  c;
      end

(* let rec lemma sum_scal(f: 'a-> complex)  (s:set 'a) (c:complex)
 *           ensures{sum s (fun x -> c*. (f x)) = c *. (sum s f)}
 *           variant{cardinal s}
 *   = if (is_empty s) then
 *       begin
 *         sum_empty s f;
 *         sum_empty s (fun x -> c*. (f x));
 *       end
 *     else
 *       begin
 *         sum_add (remove (choose s)s)  f (choose s) ;
 *         sum_add (remove (choose s)s)  (fun x -> c*. (f x)) (choose s); 
 *         sum_scal f (remove (choose s)s)  c;
 *       end *)

(* let lemma sum_scal_right (f: 'a-> complex)  (s:set 'a) (c:complex)
 *           ensures{sum s (fun x ->  (f x) *. c) =  (sum s f) *. c}
 *   = sum_scal f s c *)
  
let lemma sum_scal_rev_right (f: 'a-> complex)  (s:set 'a) (c:complex)
          ensures{ (sum s f) *. c = sum s (fun x ->  (f x) *.c)  }
  = sum_scal_right f s c
  
let lemma sum_scal_rev (f: 'a-> complex)  (s:set 'a) (c:complex)
          ensures{ c*. (sum s f) = sum s (fun x -> c*.  (f x) )  }
  = sum_scal f s c
  
let lemma ind_sum_scal  (f :int -> complex) (i j:int) (a:complex) 
      ensures{ind_sum  (fun i -> a*. (f i)) i j = a*. (ind_sum  f i j)}      
  = sum_scal f (to_fset i j) a

let lemma ind_sum_scal_rev  (f :int -> complex) (i j:int) (a:complex) 
      ensures{ a*. (ind_sum  f i j) =   ind_sum (fun i -> a*. (f i)) i j}      
  = ind_sum_scal f i j a

let lemma scal_ind_sum  (f :int -> complex) (i j:int) (a:complex) 
      ensures{ind_sum  (fun i -> (f i) *. a) i j =  (ind_sum  f i j) *. a}      
  = ind_sum_scal f  i j a

let lemma scal_ind_sum_rev  (f :int -> complex) (i j:int) (a:complex) 
      ensures{ (ind_sum  f i j) *. a =   ind_sum (fun i ->  (f i) *. a) i j}      
  = ind_sum_scal_rev f i j a

let  lemma sum_scal_gen  (f :int -> complex) (s : set int)  
       ensures{forall a:complex.sum s (fun i -> a*. (f i)) = a*. (sum s f)}      
  = ()

let  lemma ind_sum_scal_gen  (f :int -> complex) (i j:int)  
       ensures{forall a:complex. ind_sum  (fun i -> a*. (f i)) i j = a*. (ind_sum f i j)}      
  = ()

      use  fsum.Int_int_iter
  
let lemma ind_sum_commute  (f:int -> int -> complex)(i j k l:int)
      requires{i <=j}
      requires{k <=l}
      ensures{ ind_sum (fun k1 -> ind_sum (f k1) k l) i j
               = ind_sum (fun k1 -> ind_sum (fun k2 -> f k2 k1) i j) k l}
  = 
  int_iterate_commute (+.) f i j k l
  
let lemma sum_commute  (f:'a -> 'b -> complex)( sa: set 'a)( sb: set 'b)
      ensures{ sum sa (fun a -> sum sb (f a)) = sum sb (fun b -> sum sa (fun a -> f a b) )}
  = 
  iterate_commute_ (+.) sa sb f
  
let ghost function non_c_zero   (s: set 'a) (t:  'a -> complex) 
                     ensures{forall e: 'a. mem e result <-> mem e s /\  t e <> c_zero}
  = nonn_part (+. ) s t

let lemma get_non_c_zero_member   (s: set 'a) (t:  'a -> complex)  (e:'a)
      requires{mem e (non_c_zero s t)}
      ensures{mem e s}
      ensures{ t e <> c_zero}
  = ()

let lemma set_non_c_zero_member   (s: set 'a) (t:  'a -> complex)  (e:'a)
      requires{mem e s}
      requires{ t e <> c_zero}
      ensures{mem e (non_c_zero s t)}
  = ()

let lemma set_non_c_zero_member_gen   (s: set 'a) (t:  'a -> complex)  
      ensures{forall e: 'a. mem e s &&  t e <> c_zero ->mem e (non_c_zero s t)}
  = ()
  
let lemma set_non_c_zero_member_gen_   (s: set 'a) (t:  'a -> complex)  
      ensures{forall e: 'a. mem e s &&  t e <> c_zero ->mem e (non_c_zero s t)}
      ensures{forall e: 'a. mem e s &&  t e <> c_zero ->mem e (non_c_zero s t)}
  = ()
  
let lemma sum_nullity_partition  (s: set 'a) (t:  'a -> complex)
      ensures{sum  s t = sum (non_c_zero  s t) t}
  = iterate_nullity_partition (+.) s t
  
let lemma non_null_map (s: set 'a)(f: 'a -> 'a)(t: 'a -> complex)
      ensures{non_c_zero (map f s) t = map f (non_c_zero s (fun b -> t (f b)))}
  = map_antec_gen f s;
    set_equal (non_c_zero (map f s) t) ( map f (non_c_zero s (fun b -> t (f b))))
    
let   lemma map_sum_eq_nonnull (s: set 'a)(f: 'a -> 'a)(t: 'a -> complex)
        requires{p_bijective f (non_c_zero s (fun b -> t (f b)))
                   (non_c_zero (map f s) t)}
        ensures{sum  (non_c_zero (map  f s) t) t  = sum (non_c_zero s (fun b -> t (f b))) (fun b -> t (f b))}
  =
  bijective_is_injective   f (non_c_zero s (fun b -> t (f b))) (non_c_zero (map f s) t);
  map_sum_eq  (non_c_zero s (fun b -> t (f b))) f  t;
  sum_nullity_partition (map f s) t;
  sum_nullity_partition s (fun b -> t (f b));
  assert{sum  ( map f (non_c_zero s (fun b -> t (f b)))) t  = sum (non_c_zero s (fun b -> t (f b))) (fun b -> t (f b))};
  set_equal (map f (non_c_zero s (fun b -> t  (f  b)))) (non_c_zero (map  f s) t);
  non_null_map s f t
  
let lemma sum_null_but_one  (s: set 'a) (t:  'a -> complex)
      requires{cardinal (non_c_zero  s t) =1}
      ensures{sum  s t = t (element (non_c_zero  s t))}
  = iterate_cardone (+.) (non_c_zero  s t) t
  
let lemma sum_null  (s: set 'a) (t:  'a -> complex)
      requires{cardinal (non_c_zero  s t) = 0}
      ensures{sum  s t = c_zero}
  = iterate_cardzero (+.) (non_c_zero  s t) t
      
let lemma sum_null_  (s: set 'a) (t:  'a -> complex)
      requires{forall e. mem e s -> t e = c_zero}
      ensures{sum  s t = c_zero}
  = sum_null s t
      
let rec lemma sum_null_forall  (s: set 'a) (t:  'a -> complex)
      requires{forall e:'a. mem e s -> t e = c_zero}
      ensures{sum  s t = c_zero}
      variant{cardinal s}
  = if cardinal s = 0 then ()
    else begin
        sum_add (remove (choose s) s) t (choose s) ;
        sum_null_forall (remove (choose s) s) t;
        end

  
let lemma ind_sum_null   (t:  int -> complex) (i j:int)
      requires{forall k. i<= k < j -> t k  = c_zero}
      ensures{ind_sum  t i j = c_zero}
  = sum_null (to_fset i j) t

let lemma sum_null_but_one_elt  (s: set 'a) (t:  'a -> complex) (elt: 'a)
      requires{mem elt s /\ t elt <> c_zero}
      requires{forall a: 'a. mem a s -> a <> elt -> t a = c_zero}
      ensures{sum  s t = t elt}
  =
  set_cardone_elt (non_c_zero  s t) elt;
  sum_null_but_one s t;
  iterate_cardone (+.) (non_c_zero  s t) t
  
let lemma sum_null_but_maybe_one_elt   (t:  'a -> complex) (s:set 'a) (elt:'a)
      requires{mem elt s}
      requires{forall k:'a. mem k s -> k<> elt -> t k = c_zero}
      ensures{sum s  t = t elt}
  = if (eq_t (t elt)  c_zero ) then
      iterate_cardzero (+.)  (non_c_zero  s t) t 
    else sum_null_but_one_elt    (non_c_zero  s t) t elt

let lemma sum_null_but_maybe_two_elt   (t:  'a -> complex) (s:set 'a) (elt elt':'a)
      requires{mem elt s}
      requires{mem elt' s}
      requires{ elt <> elt' }
      requires{forall k:'a. mem k s -> k<> elt -> k<> elt' -> t k = c_zero}
      ensures{sum s  t = t elt +. t elt'}
  = sum_add (remove elt s) t elt;
    sum_null_but_maybe_one_elt t (remove elt  s) elt'


  
let lemma ind_sum_null_but_maybe_one_elt   (t:  int -> complex) (i j ind:int)
      requires{i<= ind <j}
      requires{forall k:int. i <= k < j-> k<> ind-> t k = c_zero}
      ensures{ind_sum   t i j = t ind}
  = sum_null_but_maybe_one_elt t (to_fset i j) ind

let lemma ind_sum_null_but_maybe_two_elt   (t:  int -> complex) (i j ind ind':int)
      requires{i<= ind <j}
      requires{i<= ind' <j}
      requires{ind <> ind'}
      requires{forall k:int. i <= k < j-> k<> ind-> k<> ind'->  t k= c_zero}
      ensures{ind_sum   t i j = t ind +. t ind' }
  =  sum_null_but_maybe_two_elt t (to_fset i j) ind ind'

       use p_set.Choose_filter
   
let lemma ind_sum_map_filter (n n':int) (g: int->int) (f: int-> complex) (p: int->bool)
      requires{0<=n'<=n}
      requires{p_injective g (to_fset 0 n')}
      requires{forall k. 0 <= k < n -> not (p k) -> f k  = c_zero}
      requires{forall k. 0 <= k < n' -> 0<= g k < n}
      requires{forall k. 0 <= k < n ->  (p k <-> exists ant. (0<= ant < n' /\ k = g ant))}
      ensures{ind_sum f 0 n = ind_sum (fun k -> f (g k)) 0 n'}
  = ind_sum_to_sum f 0 n;
    sum_disjoint_transitivity (my_filter (to_fset 0 n) p) (my_filter (to_fset 0 n) (fun x -> not p x)) f;
    set_equal (my_filter (to_fset 0 n) p)  (map g (to_fset 0 n'));
    sum_null  (my_filter (to_fset 0 n) (fun x -> not p x)) f;
    map_sum_eq (to_fset 0 n') g f

    (* let   lemma map_sum_eq (s: set 'b)(f: 'b -> 'a)(t: 'a -> complex)
   *       requires{p_injective f s}
   *       ensures{sum  (map  f s) t  = sum s (fun b -> complex (f b))}
   * = iterate_map (+.) s f t *)

    
(* let   lemma sum_disjoint_transitivity  (s1 s2: set 'a)(t: 'a -> complex)
 *         requires{inter s1 s2 = empty}
 *         ensures{sum (union s1 s2) t =  (sum s1 t)  +. ( sum s2 t)}
 *   = iterate_disjoint_transitivity (+.) s1 s2 t *)

  
(* let lemma ind_sum_null_but_maybe_one   (t:  'a -> complex) (s:set 'a)
 *       requires{i<= ind <j}
 *       requires{forall k:int. i <= k < j-> k<> ind-> t k = c_zero}
 *       ensures{ind_sum   t i j = t ind}
 *   = ind_sum_null_but_maybe_one_elt t (to_fset i j) ind *)

let lemma neutral_c_one ()
      ensures{neutral ( *.) c_one}
      ensures{iterable ( *.)}
  = set_neutral  ( *.) c_one
  
let  lemma product_iter()
       ensures{op_neutral_left ( *.) c_one}
       ensures{op_neutral_right ( *.) c_one /\ op_assoc ( *.)}
       ensures{commut ( *.)}
       ensures{  iterates ( *.) c_one}
  = ()
  
let ghost function product (s: set 'a) (t : 'a -> complex):complex
  = iterate ( *.) s t

let lemma product_eq (s: set 'a) (t t' : 'a -> complex)
      requires{forall e: 'a. mem e s -> t e = t' e}
      ensures{product s t = product s t'}
  = iterate_eq ( *. ) s t t' 
  
let lemma product_eq_gen (s s': set 'a) (t t' : 'a -> complex)
      requires{s = s'}
      requires{forall e: 'a. mem e s -> t e = t' e}
      ensures{product s t = product s' t'}
  = product_eq s t t' 
  
let lemma product_empty (s: set 'a) (f : 'a  -> complex)  
      requires{is_empty s}
      ensures{ product s f =  c_one}
  =
  iterate_empty ( *.)  s f ;
  ()

let  lemma product_iter_()
       ensures{iterable ( *.) }
  = assert{iterates ( *.) c_one}

let lemma add_product (s: set 'a)(f: 'a -> complex)(x: 'a)
            requires{not (mem x s) }
      ensures{product (add x s) f =  ( f x) *.  (product s f)}
  = iterate_add ( *. ) s f x

let lemma product_add (s: set 'a)(f: 'a -> complex)(x: 'a)
            requires{not (mem x s) }
      ensures{product (add x s) f =    (product s f) *. f x}
  =   ()

      lemma neutral_one: neutral_elt ( *.) = c_one

let ghost function ind_product  (f :int -> complex) (i:int) (j:int) 
  = int_iterate ( *.) f i j

let lemma  ind_product_eq  (f g:int -> complex) (i:int) (j:int) 
      requires{forall k : int. i <= k < j -> f k = g k}
      ensures{ ind_product  f i j = ind_product  g i j}
  = int_iterate_eq ( *.) f g i j

let lemma ind_product_cardone (f :int -> complex) (i:int) (j:int)  
      requires{j = i+1}
      ensures{ ind_product f i j =  f i}
  = int_iterate_cardone ( *. ) f i j

let lemma  ind_product_eq_gen  (f g:int -> complex) (i1 j1 i2 j2:int) 
      requires{forall k : int. i1 <= k < j1 -> f k = g k}
      requires{i1=i2}
      requires{j1=j2}
      ensures{ ind_product  f i1 j1 = ind_product  g i2 j2}
  = ind_product_eq f g i1 j1

let lemma ind_product_right_extension (f :int -> complex) (i:int) (j:int)
      ensures{ind_product f i j = ind_product f i (j-1) *. f (j-1)}
      requires { i < j }
  =
  assert{assoc ( *.)};
  int_iterate_right_extension ( *.) f i j;
  ()

let lemma ind_product_left_extension (f :int -> complex) (i:int) (j:int)
      requires { i < j }
      ensures{ind_product f i j =  f i  *. ind_product f (i+1) j}
  =
  ()
  
let lemma ind_product_to_product  (f :int -> complex) (i:int) (j:int) 
      ensures{ind_product f i j = product (to_fset  i j) f}
  = () 

let   lemma map_product_eq (s: set 'b)(f: 'b -> 'a)(t: 'a -> complex)
        requires{p_injective f s}
        ensures{product  (map  f s) t  = product s (fun b -> t (f b))}
  = iterate_map ( *.) s f t

let   lemma map_ind_product_eq (i j k l:int)(f: int -> int)(t: int -> complex)
        requires{p_bijective f (to_fset i j) (to_fset k l )}
        ensures{ind_product  t k l  = ind_product  (fun b -> t (f b)) i j}
  =
  bijective_is_injective    f (to_fset i j) (to_fset k l );
  map_product_eq  (to_fset i j) f t;
  ind_product_to_product  t k l;
  ind_product_to_product  (fun b -> t (f b)) i j

let lemma ind_product_right_extension_comm (f :int -> complex) (i:int) (j:int)
      ensures{ind_product f i (j-1) *. f (j-1) = ind_product f i j }
      requires { i < j }
  =()

let lemma ind_product_eq_func  (i j :int)(f1: int -> complex)(f2: int -> complex)
      requires{p_injective f1 (to_fset i j)}
      requires{p_injective f2 (to_fset i j)}
      requires{map f1 (to_fset i j)  = map f2 (to_fset i j) }
      ensures{ind_product  f1 i j = ind_product   f2 i j}
  = int_iterate_eq_func ( *.)  i j f1 f2

let lemma ind_product_trans (f : int -> complex ) (i k j : int)
      requires {i <= k <= j}
      ensures{ind_product f i j = ind_product f i k *. ind_product f k j}
  = int_iterate_transitivity ( *.) f i k j

let  lemma ind_product_zero_pre (f : int -> complex ) (i t j : int)
       requires {i <= t < j}
       requires{f t = c_zero}
       ensures{ind_product f i j = c_zero}
  =
  if ( i = t) then ()
  else
    begin
      ind_product_right_extension f i (t+1);
      ind_product_trans f i (t+1) j
    end
  
let  lemma ind_product_zero (f : int -> complex ) (i  j : int)
       requires {i <=  j}
       requires{exists t:int. i<= t < j && f t = c_zero}
       ensures{ind_product f i j = c_zero}
  = ()

let  lemma ind_product_zero_elt (f : int -> complex ) (i  j t: int)
       requires {i <=  j}
       requires{ i<= t < j}
       requires{f t = c_zero}
       ensures{ind_product f i j = c_zero}
  = ()

let rec lemma ind_product_const_c_one (f : int -> complex ) (i  j : int)
          requires{i <= j}
          requires{forall t:int. i<= t < j -> f t = c_one}
          ensures{ind_product f i j = c_one}
          variant{j-i}
  = if (i = j) then ()
    else
      begin
        ind_product_right_extension f i j;
        ind_product_const_c_one f i (j-1);
      end


end
     
module Indic
         use  complex.Complex
         use  Base_type
         use  fsum.Iterations
         use  fsum.Set_iter
         use  set.Fset
         use  p_set.Fset_comp
         use  p_set.IndexestoSet
         use  fsum.Fset_iter_Pos
         use  ref.Ref
use complex.Assert_equal
     
let  function indic  (a a' :'a):complex 
  ensures{result = if (a = a') then c_one else c_zero}
  =if (a == a') then c_one else c_zero
  
let lemma get_indic  (a a' :'a)
      ensures{indic a a'=  if (a = a') then c_one else c_zero}
  =()

let  function indic_bool  (a a' :'a): bool 
  ensures{result = if (a = a') then true else false}
  = if (a == a') then true else false
  
let lemma indic_comm (a a' : 'a)
      ensures{indic a a' = indic a' a}
  =()
  
let lemma indic_transl_r (a b c : 'a)
      requires{b = c}
      ensures{indic a b = indic a c}
  =()
  
let lemma indic_transl_l (a b c : 'a)
      requires{b = c}
      ensures{indic b a = indic c a}
  =()
  
let  function indic_2 (a a': 'a) (b b' : 'b):complex
                                                ensures{result =   indic a a' *. indic b b'}                                                
                                                     ensures{result =   indic (a,b) (a',b')}
  = if indic_bool a  a' && indic_bool  b  b'
    then
      assert{indic a a' *. indic b b' = ( c_one :complex)}
    else
      assert {indic a a' *. indic b b' = (c_zero :complex)} ;
    if indic_bool a  a' && indic_bool  b  b'
    then
      c_one
    else
      c_zero

let lemma indic_2_if (i k : 'a) (j l :'b)
      ensures{indic_2 i k j l = if (i = k && j = l) then c_one else c_zero}
  =()
    
let lemma indic_2_comm (a a' : 'a)( b b': 'b)
      ensures{indic_2 a a' b b' = indic_2 a' a b b'}
      ensures{indic_2 a a' b b' = indic_2 a a' b' b}
      ensures{indic_2 a a' b b' = indic_2 a' a b' b}
  =()
  
let ghost function sum_indic (s: set 'a) (t : 'a -> complex) (i: 'a):complex
  = sum s (fun e -> (t e) *. indic i e)

      use  int.Int

let function bool_to_c (a:bool) :complex
           = if a then c_one else c_zero
  
let ghost function ind_sum_indic (t : int -> complex)  (l h i: int):complex
                                                                 requires{l < h}
                                                                 ensures{result = sum_indic (to_fset l h) t i}
  = ind_sum  (fun e -> (t e) *. indic i e) l h
  
let lemma sum_indic_t (s: set 'a) (t : 'a -> complex) (i: 'a)
      requires{mem i s}
      ensures{ sum_indic s t i   = t i}
  =   sum_null_but_maybe_one_elt  (fun e -> (t e) *. indic i e ) s i

let lemma sum_indic_ts (s: set 'a) (t : 'a -> complex) (i: 'a)
      requires{mem i s}
      ensures{sum s (fun e -> t e *. indic i e) = t i}  
  = sum_indic_t s t i
  
let lemma ind_sum_indic_t (t : int -> complex) (l h i: int)
      requires{l<= i < h}
      (* requires{t i <> c_zero} *)
      ensures{ ind_sum_indic t  l h i   = t i}
      ensures{  ind_sum  (fun e -> (t e) *. indic i e) l h   = t i}
  =  sum_indic_t (to_fset l h) t i
   
let lemma ind_sum_indic_t_quant (t : int -> complex) (l h: int)
      ensures{forall i. l<= i < h -> ind_sum (fun e -> (t e) *. indic i e)  l h    = t i}
  = 
  assert{forall i. l<= i < h -> t i <> c_zero -> ind_sum_indic t  l h i   = t i};
  assert{forall i. l<= i < h -> ind_sum_indic t  l h i   =   ind_sum (fun e -> (t e) *. indic i e)  l h   }
end

module Inv_func

         use  functions.MapInjection
         use  set.FsetComprehension
         use  p_set.Fset_comp
         use  p_set.Card_one_set
         use  Indic 
         use p_set.Choose_filter
     
let  function inv_func (f: 'a -> 'b) (s : set 'a) ( s': set 'b)(e': 'b):'a
                                                                               requires{p_bijective f s s'}
                                                                               requires{mem e' s'}
                                                                               ensures{mem  result s}
                                                                               ensures{f result = e'}
  =
  let s_indic = (my_filter s (fun e -> indic_bool (f e) e') ) in
  begin
    get_surjective f s s';
    set_non_empty s_indic;
    get_injective f s ;
    assert {forall e e': 'a. mem e s_indic -> mem e' s_indic -> e = e'};
    set_cardone s_indic;
    element s_indic
  end

let lemma bijective_inv_func (f: 'a -> 'b) (s : set 'a) ( s': set 'b)
      requires{p_bijective f s s'}
      ensures{p_bijective (fun x -> inv_func f s s' x) s' s}
  =()
  
let lemma inv_rec (f: 'a -> 'b) (s : set 'a) ( s': set 'b)(e: 'a)
      requires{p_bijective f s s'}
      requires{mem e s}
      ensures{inv_func f s s' (f e) = e}
  = ()
  
let ghost function inv_ (f: 'a -> 'b) (s : set 'a) (s' : set 'b)(e: 'b):'a
                                                                          requires{p_bijective f s s'}
                                                                          requires{mem e s'}
                                                                          ensures{mem  result s}
                                                                          ensures{f result = e}
  = inv_func f s s' e

let lemma inv_bijective (f: 'a -> 'b) (s : set 'a) (s' : set 'b)
      requires{p_bijective f s s'}
      ensures{p_bijective (inv_ f s s') s' s}
  = set_bijective (fun e -> if mem e s' then (inv_ f s s' e) else (choose s)) s'  s

let lemma set_bijective_inv (f: 'a -> 'b) (g:'b-> 'a) (s : set 'a)(b:'b)
      requires{mem b (map f s)}
      requires{    forall e e': 'a. mem e s -> mem e' s -> e <> e' -> f e <> f e'}
      requires{    forall e' : 'b. mem e' (map f s) ->  mem (g e') s /\ f (g e') = e'}
      ensures{p_bijective f s (map f s)}
      ensures{(inv_func f s (map f s)) b = g b}
  =
  set_bijective f s (map f s)

let lemma set_bij_inv (f: 'a -> 'b) (g:'b-> 'a) (s : set 'a)
      requires{    forall e e': 'a. mem e s -> mem e' s -> e <> e' -> f e <> f e'}
      requires{    forall e' : 'b. mem e' (map f s) ->  mem (g e') s /\ f (g e') = e'}
      ensures{p_bijective f s (map f s)}
      ensures{p_bijective g  (map f s) s}
      ensures{forall b:'b. mem b (map f s) -> (inv_func f s (map f s)) b = g b}
  =
  ()

let  function inv_f (f: 'a -> 'b) (s : set 'a) (s' : set 'b): ('b -> 'a)
                                                                     requires{p_bijective f s s'}
                                                                     ensures{forall e: 'b. mem e s' -> mem  (result e) s}
                                                                     ensures{forall e: 'b. mem e s' -> f (result e) = e}
                                                                     ensures{p_bijective result s' s}
  = 
  set_bijective (fun k -> if mem k s' then inv_func f s s' k else any 'a) s' s;
  fun k -> if mem k s' then inv_func f s s' k else any 'a

         let lemma inv_f_back (f: 'a -> 'b) (s : set 'a) (s' : set 'b) (e:'b)
               requires{mem e s'}
               requires{p_bijective f s s'}
               ensures{f (inv_f f s s' e) = e}
           =()

         let lemma inv_f_back_rev (f: 'a -> 'b) (s : set 'a) (s' : set 'b) (e:'a)
               requires{mem e s}
               requires{p_bijective f s s'}
               ensures{inv_f f s s' (f e) = e}
           =()

let rec lemma injective_is_bijective (f: 'a -> 'b)  (s : set 'a)(s' : set 'b)
          requires{p_injective f s }
          requires{forall e. mem e s -> mem (f e) s'}
          requires{cardinal s = cardinal s'}
          ensures{p_bijective f s s'}
      variant{cardinal s}
  =
  if cardinal s = 0 then set_bijective f s s'
  else
    begin
      injective_is_bijective f (remove (choose s) s) (remove (f(choose s)) s');
    get_surjective f (remove (choose s) s) (remove (f(choose s)) s');
      set_equal s' (map f s);
  bij_equal_card f s;
  card_image_injective f s  

    end

let  lemma injective_is_bijective_auto (f: 'a -> 'a)  (s : set 'a)
          requires{p_injective f s }
          requires{forall e. mem e s -> mem (f e) s}
          ensures{p_bijective f s s}
          ensures{map f s = s}
  = injective_is_bijective f s s

let function inv_auto (f: 'a -> 'a)  (s : set 'a) : ('a->'a)
               requires{p_injective f s }
               requires{forall e. mem e s -> mem (f e) s}
               ensures{forall e: 'a. mem e s -> mem  (result e) s}
               ensures{forall e: 'a. mem e s -> f (result e) = e}
               ensures{p_bijective result s s}
  = injective_is_bijective_auto f s;
    inv_f f s s


end

module Im_re

         use  complex.Complex
         use  complex.P_real
use Simpl_op
let lemma real (x:complex)
      requires{real_ x}
      ensures{x = r_to_c (real_part x)}
  = complex_decomp x
  
let lemma pure_im (x:complex)
      requires{pure_im_ x}
      ensures{x = im *. r_to_c ( im_part x)}
  =complex_decomp x
  
let lemma im_dec ()
      ensures{real_part im = 0.0 /\ im_part im = 1.0}
  = unic_decomp im 0.0  1.0
  
let lemma c_one_dec ()
      ensures{real_part c_one = 1.0 /\ im_part c_one = 0.0}
  = unic_decomp c_one 1.0 0.0

let lemma c_zero_dec ()
      ensures{real_part c_zero = 0.0 /\ im_part c_zero = 0.0}
  = unic_decomp c_zero 0.0 0.0
  
let lemma ttwo_dec ()
      ensures{real_part ttwo = 2.0 /\ im_part ttwo = 0.0}
  = real_part_add c_one c_one;
    im_part_add c_one c_one;
    complex_decomp ttwo
end

module FromInt
         use  complex.P_real
         use  complex.Complex
         use  Im_re
         use  int.Int
use Simpl_op

let (* ghost *)  function i_to_c (i:int)
                        ensures{real_ result}
  =  (r_to_c (from_int i))

let lemma i_to_c_zero()
      ensures{i_to_c 0 = c_zero}
  = ()

let lemma i_to_c_surj( i j:int)
      requires{i<>j}
      ensures{i_to_c i <> i_to_c j}
  = ()


let lemma i_to_c_eq (i j:int)
      requires{i = j}
      ensures{i_to_c i = i_to_c j}
  =()

let lemma i_to_c_inf( i j:int)
      requires{i<j}
      ensures{i_to_c i <. i_to_c j}
  = assert{i_to_c (j-i) = i_to_c j-. i_to_c i}

  
let lemma i_to_c_nzero (i:int)
      requires{i <> 0}
      ensures{i_to_c i <> c_zero}
  = assert {from_int i <> 0.0}
  
let lemma i_to_c_one ()
      ensures{i_to_c 1 = c_one}
  =()

let lemma i_to_c_add ( i j : int)
      ensures{i_to_c i +. i_to_c j = i_to_c (i+j)}
  =()

  
  
let lemma i_to_c_add_rev ( i j : int)
      ensures{ i_to_c (i+j) = i_to_c i +. i_to_c j}
  =()

let lemma i_to_c_ttwo ()
      ensures{i_to_c 2 = ttwo}
  =i_to_c_add 1 1
  
let lemma i_to_c_pos (a:int)
      requires{0<=a}
      ensures{c_zero <=. i_to_c a}
  = ()
  
let lemma i_to_c_minus (a:int)
      ensures{i_to_c (-a) = -. (i_to_c a)}
  = ()
  
let lemma i_to_c_strict_pos (a:int)
      requires{0<a}
      ensures{c_zero <. i_to_c a}
  = ()
  
let rec lemma i_to_c_mult_pos ( i j : int)
          requires{0<=j}
          ensures{i_to_c i *. i_to_c j = i_to_c (i*j)}
variant{j}      
  =
  if j = 0 then ()
  else
    begin
      assert{i_to_c i *. i_to_c j  = (i_to_c i *. i_to_c (j-1)) +. i_to_c i};
      assert{i*j = i * (j-1)+i};
      i_to_c_mult_pos i (j-1);
    end

let  lemma i_to_c_mult ( i j : int)
          ensures{i_to_c i *. i_to_c j = i_to_c (i*j)}
  =
  if 0<=j then i_to_c_mult_pos i j
  else begin
      
assert{i_to_c i *. i_to_c j = -. (i_to_c i *. i_to_c (-j))};
assert{i_to_c (i*j) = -. i_to_c (i*(-j))};
i_to_c_mult_pos i (-j);
end

  
let lemma i_to_c_mult_rev ( i j : int)
      ensures{ i_to_c (i*j) =i_to_c i *. i_to_c j}
  =()

let lemma i_to_c_mult_assoc (x:complex)( i j : int)
      ensures{x*. (i_to_c (i*j)) = (x *. (i_to_c i)) *. i_to_c j}
  =()

let lemma i_to_c_mult_assoc_rev (x:complex)( i j : int)
      ensures{ (x *. (i_to_c i)) *. i_to_c j = x*. (i_to_c (i*j))}
  =()

let lemma i_to_c_sub ( i j : int)
      ensures{ i_to_c i -. i_to_c j = i_to_c (i-j)}
  =()
  
let lemma i_to_c_sub_rev ( i j : int)
      ensures{i_to_c (i-j) =  i_to_c i -. i_to_c j}
  =()
  
let lemma i_to_c_opp ( i  : int)
      ensures{ i_to_c (- i)  = -. i_to_c i}
  = i_to_c_add 0 (-i)
  
let lemma i_to_c_div ( i j : int)
      requires{j <> 0}
      ensures{ i_to_c (i * j) /. i_to_c j = i_to_c i}
  =()  

let lemma i_to_c_minus_mult (i j:int)
    ensures{i_to_c (-i) *. i_to_c j = i_to_c i *. i_to_c (-j) }
=()


let lemma i_to_c_div_leq_c_one (a b:int)
      requires{0<= a < b}
      ensures{i_to_c a /. i_to_c b <=. c_one}
  =()

let lemma compat_i_to_c_infeq (a b :int)
  requires{a <= b}
  ensures{i_to_c a <=. i_to_c b}
=()
  
let lemma compat_i_to_c_inf (a b :int)
  requires{a < b}
  ensures{i_to_c a <. i_to_c b}
=()
  
let lemma compat_i_to_c_inf_rev (a b :int)
  requires{i_to_c a <. i_to_c b}
  ensures{a < b}
=()
  
  
let lemma compat_i_to_c_sup (a b :int)
  requires{a > b}
  ensures{i_to_c a >. i_to_c b}
=()
  
use p_set.Fset_comp

let lemma positive_int_squrt (i:int)
      requires{i >0}
      ensures{square_rt (i_to_c i) >. c_zero}
      =()
   
let lemma non_null_int_squrt (i:int)
      requires{i >0}
      ensures{square_rt (i_to_c i) <> c_zero}
      =()
   
use Base_type
let rec lemma ind_sum_constant  (f :int -> complex) (valu:complex) (i:int) (j:int) 
          requires{i<=j}
          requires{forall k. i<= k< j -> f k = valu}
          ensures{ind_sum f i j = valu *. i_to_c (j-i)}
      variant{j-i}
  = if i = j then ()
    else begin
        ind_sum_right_extension f i j;
        ind_sum_constant f valu i (j-1);
        end

let rec lemma ind_sum_constant_from_z  (f :int -> complex) (valu:complex)  (j:int) 
          requires{0<=j}
          requires{forall k. 0<= k< j -> f k = valu}
          ensures{ind_sum f 0 j = valu *. i_to_c j}
  = ind_sum_constant f valu 0 j

      use p_set.IndexestoSet
      use p_set.Choose_filter
           use  set.FsetComprehension

  
let rec lemma sum_constant_lower_bound (s: set 'a) (t:  'a -> complex) (x:complex)
          requires{ forall e. mem e s -> real_ (t e)}
          requires{ forall e. mem e s -> t e <=. x}
          requires{real_ x}
          ensures{sum s t <=. i_to_c (cardinal s) *. x}
      variant{cardinal s}
  = if cardinal s = 0 then() else
    if cardinal s = 1 then sum_one s t
    else begin 
        sum_constant_lower_bound (remove (choose s) s) t x;
        sum_plus_one s t;
        assert{cardinal s = cardinal (remove (choose s)s) +1};
        mult_distr_add_r x (i_to_c (cardinal (remove (choose s)s))) c_one;
      end  

let rec lemma sum_inf (s: set 'a) (t t':  'a -> complex) 
          requires{ forall e. mem e s -> real_ (t e)}
          requires{ forall e. mem e s -> real_ (t' e)}
          requires{ forall e. mem e s -> t e <=. t' e}
          ensures{sum s t <=. sum s t'}
      variant{cardinal s}
  = if cardinal s = 0 then() else
      if cardinal s = 1 then
        begin
        sum_one s t;
        sum_one s t';
        end
      else
        begin 
        sum_inf (remove (choose s) s) t t';
        sum_plus_one s t;
        sum_plus_one s t';
        assert{cardinal s = cardinal (remove (choose s)s) +1};
        end;
    ()

  
let rec lemma sum_constant (s: set 'a) (t:  'a -> complex) (x:complex)
          requires{ forall e. mem e s -> t e = x}
          ensures{sum s t = i_to_c (cardinal s) *. x}
      variant{cardinal s}
  = if cardinal s = 0 then() else
    if cardinal s = 1 then sum_one s t
    else begin 
        sum_constant (remove (choose s) s) t x;
        sum_plus_one s t;
        assert{cardinal s = cardinal (remove (choose s)s) +1};
        mult_distr_add_r x (i_to_c (cardinal (remove (choose s)s))) c_one;
      end

  
let lemma ind_sum_constant_case  (n:int)(t:  int -> complex) (p: int -> bool) (x y:complex) (k1:int)
      requires{0<=n}
      requires{cardinal (my_filter  (to_fset 0 n) p) = k1}
      requires{ forall e. 0<= e < n -> p e -> t e = x}
      requires{ forall e. 0<= e < n -> not p e -> t e = y}
  ensures{ind_sum t 0 n  = i_to_c k1 *. x +. i_to_c (n-k1) *. y  }
  =
  set_empty (inter (my_filter  (to_fset 0 n) p) (my_filter  (to_fset 0 n) (fun x -> not p x)));
  union_members (my_filter  (to_fset 0 n) p) (my_filter  (to_fset 0 n) (fun x -> not p x));
  set_equal (to_fset 0 n) (union (my_filter  (to_fset 0 n) p) (my_filter  (to_fset 0 n) (fun x -> not p x)));
  cardinal_sum_empty_inter (my_filter  (to_fset 0 n) p) (my_filter  (to_fset 0 n) (fun x -> not p x));
  sum_disjoint_transitivity (my_filter  (to_fset 0 n) p) (my_filter  (to_fset 0 n) (fun x -> not p x)) t;
      sum_constant (my_filter (to_fset 0 n) p) t x;
    sum_constant (my_filter  (to_fset 0 n) (fun x -> not p x)) t y


  
  


let lemma sum_const_one (s: set 'a) (t:  'a -> complex)
          requires{ forall e. mem e s -> t e = c_one}
          ensures{sum s t = i_to_c (cardinal s)}
  = sum_constant s t c_one
  
end

     
module Conjugate
         use complex.Complex
 use set.FsetComprehension
         use  fsum.Int_iter
         use  set.Fset
         use Base_type
         use int.Int
         (* use Real_im_ops *)
         use Simpl_op
     
let function conjugate (i:complex):complex
  = t_real_part i -. (im*. t_im_part i)

let lemma real_part_conjugate  (i:complex)
      ensures{t_real_part (conjugate i) = t_real_part i}
  =()
  
let lemma im_part_conjugate  (i:complex)
      ensures{t_im_part (conjugate i) = -. t_im_part i}
  = t_im_part_im (im *. t_im_part i)
  
let lemma invol_conjugate (i:complex)
      ensures{conjugate (conjugate i) = i}
  =()
  
let lemma add_conjugate (i j:complex)
  ensures{conjugate (i +. j) = conjugate i +. conjugate j}
  =()
  
let lemma add_own_conjugate (i:complex)
      ensures{i +. conjugate i = ttwo *. t_real_part i}
  =()

let lemma itself_times_conjugate (i:complex)
  ensures{real_ (i *. conjugate i)}
  ensures{i *. conjugate i = t_real_part i *. t_real_part i +.  (t_im_part i *. t_im_part i)}
  =
  assert{t_real_part (conjugate i) = t_real_part i};
  assert{t_im_part (conjugate i) = -. (t_im_part i)};
  decomp_mult i (conjugate i)

let lemma conjugate_to_modulus (i:complex)
      ensures{modulus i = square_rt (i *. conjugate i)}
  =()

let lemma conjugate_times_itself_pos (i:complex)
      ensures{c_zero <=.i *. conjugate i}
  =()


  
  let rec lemma sum_conjugate (s: set 'a) (f : 'a -> complex)
            ensures{conjugate (sum s f) = sum s (fun x-> conjugate (f x))}
            variant{cardinal s}
    =
    if cardinal s = 0 then sum_empty s f else
    if cardinal s = 1 then sum_one s f
      else
        begin
          sum_add (remove (choose s) s) f (choose s);
          sum_add (remove (choose s) s) (fun x -> conjugate (f x)) (choose s);
          add_conjugate (f(choose s)) (sum  (remove (choose s) s) f);
          sum_conjugate  (remove (choose s) s) f;
        end

  let lemma conjugate_module_one (i:complex)
        requires{modulus i = c_one}
        ensures{conjugate i = inv i}
    =conjugate_to_modulus i;
injective_square_rt (i *. conjugate i) c_one
    
  let lemma conjugate_module_one_rev (i:complex)
        requires{not (i= c_zero)}
        requires{conjugate i = inv i}
        ensures{modulus i = c_one}
    = unic_inv i (conjugate i)

  let lemma conjugate_real(i:complex)
        requires{real_ i}
        ensures{conjugate i = i}
    =()
    
  let lemma conjugate_real_gen()
        ensures{forall i. real_ i -> conjugate i = i}
    =()
    
  let lemma conjugate_one(x:complex)
        requires{x= c_one}
        ensures{conjugate x = c_one}
    = conjugate_real c_one
    
  let lemma conjugate_c_zero(x:complex)
        requires{x= c_zero}
        ensures{conjugate x = c_zero}
    = conjugate_real c_zero

        use Indic
    
  let lemma conjugate_indic (i j :'a)
        ensures{conjugate (indic i j) = indic i j}
    = ()
    
  let lemma conjugate_indic_rev (i j :'a)
        ensures{indic i j = conjugate (indic i j) }
    = ()
    
  let lemma conjugate_indic_gen_int() 
        ensures{forall i j:int. conjugate (indic i j) = indic i j}
    = ()
    
  let lemma conjugate_pure_im(i:complex)
        requires{pure_im_ i}
        ensures{conjugate i = -.i}
    =()
    
  let lemma conjugate_im()
        ensures{conjugate im = -. im}
    =unic_decomp im 0.0 1.0;

    conjugate_pure_im im

  let lemma conjugate_value (c a b:complex)
    requires{real_ a}
    requires{real_ b}
    requires{c = a +. im *. b}
    ensures{conjugate c = a -. im *. b}
    =()
    
  let lemma conjugate_minus_value (c a b:complex)
    requires{real_ a}
    requires{real_ b}
    requires{c = a -. im *. b}
    ensures{conjugate c = a +. im *. b}
    = t_decomp_minus c a b


    
  let lemma prod_conjugate (a b:complex)
          ensures{a*. conjugate  b = ((t_real_part a *. t_real_part b) +. (t_im_part a *. t_im_part b)) +. im *. ( t_real_part b *. t_im_part a -. t_im_part b *. t_real_part a ) }
    = t_mult_real a (conjugate b);
  t_im_real a (conjugate b)
    
  let lemma mult_conjugate (a b:complex)
          ensures{conjugate (a*.   b) = conjugate  a *. conjugate b}
    =
    t_mult_real a b;
    t_im_real a b;
    t_mult_real (conjugate a) (conjugate b);
    t_im_real  (conjugate a) (conjugate b);
    equal_decomp (conjugate (a*.   b)) (conjugate  a *. conjugate b)

  let lemma conjugate_prod (a b:complex)
      ensures{conjugate  a*.  b = (t_real_part a *. t_real_part b) +. (t_im_part a *. t_im_part b)  +. im *. (t_real_part a *. t_im_part b -. t_real_part b *. t_im_part a )}
= t_mult_real  (conjugate a) b;
  t_im_real (conjugate a) b
  
let lemma conj_conj_prod (a b:complex)
      ensures{conjugate (conjugate  a*.  b) = a *. conjugate b }
  = conjugate_prod a b;
    prod_conjugate a b
  
let lemma conj_prod_conj (a b:complex)
      ensures{conjugate (  a*. conjugate b) = conjugate a *. b }
  = conjugate_prod a b;
    prod_conjugate a b
  
    
  let lemma itself_prod_conjugate_modulus_one (a :complex)
        requires{modulus a = c_one}
        ensures{a *. conjugate  a  = c_one}
    = prod_conjugate a a;
      injective_square_rt (a *. conjugate  a) c_one
    
    
  let lemma conjugate_prod_itself_modulus_one (a :complex)
        requires{modulus a = c_one}
        ensures{a *. conjugate  a  = c_one}
    = () 

  let lemma modulus_opposite (a :complex)
        requires{real_ a }
        requires{c_zero<=.a }
        ensures{modulus a = modulus (-. a)}
    = () 

  let lemma modulus_conjugate (a :complex)
        (* requires{real_ a }
         * requires{c_zero<=.a } *)
        ensures{modulus a = modulus (conjugate a)}
    = () 


  let lemma modulus_pos (a :complex)
        requires{real_ a }
        requires{c_zero<=.a }
        ensures{modulus a = a}
    = () 

 let lemma modulus_neg (a :complex)
        requires{real_ a }
        requires{a <=. c_zero }
        ensures{modulus a = -. a}
    = modulus_opposite (-.a)




end
                                                      
module Int_dec_parts
use complex.Complex
use FromInt
use real.Truncate
     
let ghost function int_part (x:complex):complex
      requires{real_ x}
      ensures{real_ result}
      ensures{exists i. result = i_to_c i}
      ensures{result <=. x  <.result +.c_one}
  = i_to_c (floor (real_part x))

let ghost function int_part_int (x:complex):int
      requires{real_ x}
      ensures{ i_to_c result = int_part x}
      ensures{i_to_c result <=. x  <. i_to_c (result ) +. c_one}
  = floor (real_part x)


let ghost function dec_part (x:complex):complex
      requires{real_ x}
      ensures{real_ result}
      ensures{exists i. result = x-. i_to_c i}
      ensures{c_zero <=. result <. c_one}
  = x-. int_part x

let lemma dec_part_decomp (x:complex)
    requires{real_ x}
    ensures{x = dec_part x +. int_part x}
  =()

let lemma dec_part_decomp_rev (x:complex)
    requires{real_ x}
    ensures{dec_part x +. int_part x = x}
  =()

  
let lemma dec_part_decomp_int (x:complex)
    requires{real_ x}
    ensures{x = dec_part x +. i_to_c (int_part_int x)}
  =()

let lemma dec_part_decomp_int_rev (x:complex)
    requires{real_ x}
    ensures{dec_part x +. i_to_c (int_part_int x) = x}
  =()

end


     
