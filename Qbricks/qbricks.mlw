(**************************************************************************)
(*  This file is part of QBRICKS.                                         *)
(*                                                                        *)
(*  Copyright (C) 2020-2022                                               *)
(*    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*    Université Paris-Saclay                                             *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)


module Circuit_semantics
         use  wired_circuits.Qbricks_prim
         use  wired_circuits.Circuit_c
         use  unwire_circuits.Pre_wire
         use binary.Bit_vector_decomp
         use  int_expo.Int_Exponentiation
         use  binary.Bit_vector
         use  matrices.Matrix
         use  pps.Pps         
         use binary.Bv_concat       
         use  qdata.Qreg
         use matrices.Matrix_scalar
         use  complex.Complex
         use  int.Int
         use   qdata.Bv_to_ket
         use   qdata.Ket_basis
         use   qdata.Kronecker_Qbit
         use  unit_circle.Angle
         use   matrices.Kronecker_product
         use  qdata.Sqrt_two
         use int.MinMax
         use complex.Assert_equal     
         use unwire_circuits.Wire_unwire
     
let lemma positive_width (c:circuit)
      ensures{0<= width c}
  =()

let lemma circ_to_pps_width (c:circuit)
      ensures{h_width (circ_to_pps c) = width c}
  =()
  
let lemma circ_to_pps_range (c:circuit)
      ensures{h_range (circ_to_pps c) = range c}
  =()
  
let lemma circ_to_pps_basis_ket (c:circuit) (x y: int-> int) (i:int)
      ensures{h_basis_ket (circ_to_pps c) x y i = basis_ket c x y i}
  =()
  
let lemma circ_to_pps_basis_ket_gen (c:circuit) (x y: int-> int) 
      ensures{h_basis_ket (circ_to_pps c) x y  = basis_ket c x y }
  =()
  
let lemma circ_to_pps_angle (c:circuit) (x y: int-> int) 
      ensures{h_angle (circ_to_pps c) x y  = ang_ind c x y }
  =()
  
let ghost predicate sem (c: circuit) (x y: matrix complex) 
  = is_a_ket_l x (width c) && y == path_sem c x

let lemma path_sem_to_sem (c:circuit)(x y: matrix complex)
      requires{is_a_ket_l x (width c)}
      requires{path_sem c x = y}
      ensures{sem c x y}
  =()
  
let lemma sem_to_path_sem (c:circuit)(x y: matrix complex)
      requires{sem c x y}
      ensures{path_sem c x = y}
  =()

let   lemma get_path_sem (c: circuit) (x: matrix complex)
        requires{is_a_ket_l x (width c)}
        ensures{path_sem c x  = ket_sum_l  (n_bvs (width c)) (fun y -> get_ket x (bv_to_int y) *.. path_sem_basis c (bv_to_ket y)) (width c)}
  =()
  
let   lemma get_path_sem_gen (c: circuit) 
        ensures{forall x. is_a_ket_l x (width c) -> path_sem c x  = ket_sum_l  (n_bvs (width c)) (fun y -> get_ket x (bv_to_int y) *.. path_sem_basis c (bv_to_ket y)) (width c)}
  =()
  
let lemma path_sem_decomp (c: circuit)  (x:matrix complex)
      requires{is_a_ket_l x  (width c)}
      ensures{path_sem c x = ket_sum_l (n_bvs (width c)) (fun z -> get_ket x (bv_to_int z)
                                                                   *.. path_sem c   (bv_to_ket z)) (width c)}
  =()
  
let function ancilla_g (c: circuit) (i:int) ( ghost path_sem_target :  matrix complex -> matrix complex):circuit
                                                                                                           requires{1<=i}
                                                                                                           requires{i+1<= width c} 
                                                                                                           requires{forall x:matrix complex. is_a_ket_l x (width c -i ) ->  path_sem c (kronecker x (ket i 0)) =  (kronecker (path_sem_target x) (ket i 0))}
                                                                                                           ensures{ancillas result =  ancillas c+i}
                                                                                                           ensures{size result = size c}
                                                                                                           ensures{range result = range c}
                                                                                                           ensures{width result = width c-i }
                                                                                                           ensures{forall x y: int->int. forall ii:int. basis_ket result x y ii = basis_ket c (fun k -> if  k < width c- i then x k else 0) y ii}
                                                                                                           ensures{forall x y: int->int. ang_ind result x y  = ang_ind c (fun k -> if  k < width c- i then x k else 0) y}
  =  ancilla c i
   
let function  sequence_ghost_pps (  c c': circuit)  (ghost h h' h'': pps) :circuit
                                                                             requires{correct_path_sum c h}
                                                                             requires{correct_path_sum c' h'}
                                                                             requires{width c = width c'}
                                                                             requires{h_width h'' = width c }
                                                                             requires{h_range h'' = h_range h + h_range h'}
                                                                             requires{forall x y: int->int. (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                                                                                                  (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                                                                                                  h_angle h'' x y =  (h_angle h x y) +.+ (h_angle h' (h_basis_ket h x y) (fun k ->  y (k  + h_range h)))}
                                                                             requires{forall x y: int->int. forall i:int.  (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                                                                                                                     (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                                                                                                                     0<= i < h_width h'' ->
                                                                                                                     h_basis_ket h'' x y i =  h_basis_ket h' (h_basis_ket h x y) (fun k ->  y (k  + h_range h)) i}
                                                                             ensures{width result = width c}
                                                                             ensures{size result = size c + size c'}
                                                                             ensures{ancillas result = max (ancillas c) (ancillas c')}
                                                                             ensures{correct_path_sum result h''}
  = c--c'
  
let function parallel_ghost_pps (c c': circuit)  (ghost h h' h'': pps):circuit
                                                                         requires{correct_path_sum c h}
                                                                         requires{correct_path_sum c' h'}
                                                                         requires{h_width h'' = width c + width c'}
                                                                         requires{h_range h'' = h_range h + h_range h'}
                                                                         requires{forall x y: int->int.
                                                                                                   (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                                                                                              (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                                                                                              h_angle h'' x y =  (h_angle h x y) +.+ (h_angle h'  (fun k ->  x (k  + h_width h)) (fun k ->  y (k  + h_range h)))}
                                                                         requires{forall x y: int->int. forall i:int.  (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                                                                                                                 (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                                                                                                                 0<= i < h_width h ->
                                                                                                                 h_basis_ket h'' x y i = h_basis_ket h x y i} 
                                                                         requires{forall x y: int->int. forall i:int.  (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                                                                                                                 (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                                                                                                                 h_width h <= i < h_width h'' ->
                                                                                                                 h_basis_ket h'' x y i = h_basis_ket h' (fun k ->  x (k  + h_width h)) (fun k ->  y (k  + h_range h)) (i- h_width h)} 
                                                                         ensures{correct_path_sum result h''}
                                                                         ensures{width result = width c + width c'}
                                                                         ensures{size result = size c + size c'}
                                                                         ensures{ancillas result =  (ancillas c) + (ancillas c')}
  = c//c'
  
let lemma path_sem_scal_ (c : circuit) (x  y : matrix complex) (sc: complex)
      requires{is_a_ket_l x (width c)}
      requires{path_sem c x = y}
      ensures{path_sem c (sc *.. x) = (sc *.. y)}
  =()
  
let lemma path_sem_scal (c : circuit) (x   : matrix complex) (sc: complex)
      requires{is_a_ket_l x (width c)}
      ensures{path_sem c (sc *.. x) = (sc *.. path_sem c x)}
  =()
  
let lemma path_sem_scal_rev (c : circuit) (x   : matrix complex) (sc: complex)
      requires{is_a_ket_l x (width c)}
      ensures{ (sc *.. path_sem c x) = path_sem c (sc *.. x) }
  =()

let lemma parallel_basis_ket (d e: circuit)  (x y : int-> int) (i:int)
      ensures{basis_ket (d // e) x y i = 
                if i < width d  
                then basis_ket d x y i
                else basis_ket e  (fun k -> x (k + width d)) (fun k -> y (k + range d))  (i - width d)}
  = ()

let lemma parallel_angle (d e: circuit)  (x y : int->int) 
      ensures{ang_ind (d // e) x y  =  
                (ang_ind d x y) +.+ (ang_ind e  (fun k -> x (k + width d)) (fun k -> y (k + range d)) ) }
  = ()
  
let lemma path_sem_add  (c : circuit)  (x x' y y': matrix complex)
      requires{is_a_ket_l x (width c)}
      requires{is_a_ket_l x' (width c)}
      requires{path_sem c x =  y}
      requires{path_sem c x' =  y'}
      ensures{path_sem c (add_ket_l x x' (width c)) = (add_ket_l y y' (width c))}
  =()
  
let lemma path_sem_add_  (c : circuit)  (x x' : matrix complex) (n:int)
      requires{is_a_ket_l x (width c)}
      requires{is_a_ket_l x' (width c)}
      requires{width c = n}
      ensures{path_sem c (add_ket_l x x' n) = (add_ket_l (path_sem c x) (path_sem c x') n)}
  =()
  
let lemma path_sem_scal_add_ket_l  (c : circuit)  (x x': matrix complex) (a a': complex) (n:int)
      requires{width c = n}
      requires{is_a_ket_l x n}
      requires{is_a_ket_l x' n}
      ensures{path_sem c (add_ket_l (a*..x ) (a' *.. x') n) =  add_ket_l (a*.. path_sem c x) (a'*.. path_sem c x') n}
  =()
  
let lemma path_sem_substr  (c : circuit)  (x x' y y': matrix complex)
      requires{is_a_ket_l x (width c)}
      requires{is_a_ket_l x' (width c)}
      requires{path_sem c x =  y}
      requires{path_sem c x' =  y'}
      ensures{path_sem c (mat_substr x x') = (mat_substr y y')}
  =()

let lemma path_sem_scal_add  (c : circuit)  (x x' y y': matrix complex)(scal: complex)
      requires{is_a_ket_l x (width c)}
      requires{is_a_ket_l x' (width c)}
      requires{path_sem c x =  y}
      requires{path_sem c x' =  y'}
      ensures{path_sem c (scal*.. (add_ket_l x x' (width c))) = (scal*.. (add_ket_l  y y' (width c)))}
  =()

let  lemma path_sem_basis_apply  (c: circuit)  (x:matrix complex)
       requires{is_a_ket_l x (width c)}
       requires{is_a_ket_basis_elt x }
       ensures{path_sem_basis c x =  pps_apply_basis (circ_to_pps c) (ket_to_bv x)}
  =()
  
let  lemma path_sem_basis_value  (c: circuit)  (x:matrix complex)
       requires{is_a_ket_l x (width c)}
       requires{is_a_ket_basis_elt x }
       ensures{path_sem_basis c x =    pow_inv_sqrt_2 (range c) *.. ket_sum_l (n_bvs (range c))
                                                                      (fun y ->  ang_exp (ang_ind c (getbv (ket_to_bv x)) (getbv y)) *.. bv_to_ket (make_bv (basis_ket c   (getbv (ket_to_bv x)) (getbv y)) (width c))) (width c)}
  =()

let  lemma path_sem_value_for_basis  (c: circuit)  (x:matrix complex)
       requires{is_a_ket_l x (width c)}
       requires{is_a_ket_basis_elt x }
       ensures{path_sem c x =    pow_inv_sqrt_2 (range c) *.. ket_sum_l (n_bvs (range c))
                                                                (fun y ->  ang_exp (ang_ind c (getbv (ket_to_bv x)) (getbv y)) *.. bv_to_ket (make_bv (basis_ket c   (getbv (ket_to_bv x)) (getbv y)) (width c))) (width c)}
  =()

let  lemma apply_path_sem_basis  (c: circuit)  (x:matrix complex)
       requires{is_a_ket_l x (width c)}
       requires{is_a_ket_basis_elt x }
       ensures{pps_apply_basis (circ_to_pps c) (ket_to_bv x) = path_sem_basis c x}
  =()
    
let lemma path_sem_ket_l (c: circuit)  (x:matrix complex) (l:int)
      requires{is_a_ket_l x (width c)}
      requires{l = width c}
      ensures{is_a_ket_l (path_sem c x) l}
  =()
     
     use  p_set.Fset_comp
    
let lemma path_sem_scal_substr  (c : circuit)  (x x' y y': matrix complex)(scal: complex)
      requires{is_a_ket_l x (width c)}
      requires{is_a_ket_l x' (width c)}
      requires{path_sem c x =  y}
      requires{path_sem c x' =  y'}
      ensures{path_sem c (scal*.. (mat_substr x x')) = (scal*.. (mat_substr y y'))}
  =()

let rec lemma path_sem_sum (c: circuit)  (s: set 'a) (f : 'a -> matrix complex) (g : 'a -> matrix complex) (n:int) 
          requires{cardinal s >=1}
          requires{n = width c}
          requires{forall x: 'a. mem x s -> is_a_ket_l (f x) (width c)}
          requires{forall x:'a. mem x s -> path_sem c (f x) = g x}
          ensures{ path_sem c (ket_sum_l s f n) = (ket_sum_l s g n) }
          variant{cardinal s}
  = if cardinal s = 1 then ()
    else
      begin
        ket_sum_l_plus_one (remove (choose s) s) (choose s) f n;
        ket_sum_l_plus_one (remove (choose s) s) (choose s) g n;
        path_sem_sum c (remove (choose s) s) f g n;
      end
  
let lemma path_sem_sum_diag (c: circuit)  (s: set bitvec)  (f : bitvec  -> complex)  (l:int) 
      requires{ s = n_bvs l}
      requires{l = width c}
      ensures{ path_sem c (ket_sum_l_diag  f  l) = ket_sum_l s (fun x ->  f x *.. path_sem c (bv_to_ket x)) l }
  = ()
  
let lemma path_sem_sum_ (c: circuit)  (s: set 'a) (f : 'a -> matrix complex) (n:int) 
      requires{cardinal s >=1}
      requires{n = width c}
      requires{forall x: 'a. mem x s -> is_a_ket_l (f x) (width c)}
      ensures{ path_sem c (ket_sum_l s f n) = (ket_sum_l s (fun x -> path_sem c (f x)) n) }
  = ()
  
let lemma path_sem_sum_gen (c: circuit)  (s: set 'a) (f g : 'a -> matrix complex) (n:int) 
      requires{cardinal s >=1}
      requires{n = width c}
      requires{forall x: 'a. mem x s -> is_a_ket_l (f x) (width c)}
      requires{forall x: 'a. mem x s -> path_sem c (f x)  = g x}
      ensures{ path_sem c (ket_sum_l s f n) = (ket_sum_l s g n) }
  = ()
  
let lemma scal_path_sem_sum_gen (c: circuit)  (s: set 'a) (f g : 'a -> matrix complex) (n n':int) (a b: complex)
      requires{cardinal s >=1}
      requires{n = width c}
      requires{forall x: 'a. mem x s -> is_a_ket_l (f x) (width c)}
      requires{forall x: 'a. mem x s -> path_sem c (f x)  = g x}
      requires{a = b}
      requires{n = n'}
      ensures{a*.. path_sem c (ket_sum_l s f n) = b*.. (ket_sum_l s g n') }
  = ()
  
let lemma scal_path_sem_sum (c: circuit)  (s: set 'a) (f  : 'a -> matrix complex) (n :int) (a : complex)
      requires{cardinal s >=1}
      requires{n = width c}
      requires{forall x: 'a. mem x s -> is_a_ket_l (f x) (width c)}
      ensures{a*.. path_sem c (ket_sum_l s f n) = a*.. (ket_sum_l s (fun x -> path_sem c  (f x)) n) }
  = ()
  
let lemma path_sem_scal_sum (c: circuit)  (s: set 'a) (f  : 'a -> matrix complex) (n :int) (a : complex)
      requires{cardinal s >=1}
      requires{n = width c}
      requires{forall x: 'a. mem x s -> is_a_ket_l (f x) (width c)}
      ensures{ path_sem c (a*.. ket_sum_l s f n) = a*.. (ket_sum_l s (fun x -> path_sem c  (f x)) n) }
  = ()  
  
let lemma path_sem_sequence_parallel_basis (a b d e:circuit)  (x:matrix complex)
      requires{is_a_ket_l x (width a+width b)}
      requires{width a = width d}
      requires{width b = width e}
      requires{is_a_ket_basis_elt x}
      ensures{path_sem ((a // b) -- (d // e)) x = path_sem ( ( a -- d) // (b -- e)) x }
  =()

let lemma path_sem_sequence_parallel (a b d e:circuit)  (x:matrix complex)
      requires{is_a_ket_l x (width a+width b)}
      requires{width a = width d}
      requires{width b = width e}
      ensures{path_sem ((a // b) -- (d // e)) x = path_sem ( ( a -- d) // (b -- e)) x }
  =()
  
let lemma path_sem_phase_basis (x:matrix complex) (k:int)
      requires{is_a_ket_l x 1}
      requires{is_a_ket_basis_elt x}
      ensures{path_sem (phase k) x = if 0<= k then ang_exp (int_to_ang 1 k) *.. x else ang_exp (int_to_ang (-1) (-k)) *.. x }
  =()
  
let lemma path_sem_phase_basis_inv (x:matrix complex) (k:int)
      requires{is_a_ket_l x 1}
      requires{is_a_ket_basis_elt x}
      ensures{path_sem (phase k) (path_sem (phase (-k))x) = x}
  =()

let lemma path_sem_phase_inv (x:matrix complex) (k:int)
      requires{is_a_ket_l x 1}
      ensures{path_sem (phase k) (path_sem (phase (-k))x) = x}
  = ket_decomp_ x 1

let lemma path_sem_rz_basis (x:matrix complex) (k:int)
      requires{is_a_ket_l x 1}
      requires{is_a_ket_basis_elt x}
      ensures{path_sem (rzp k) x = ang_exp (getbv (ket_to_bv x) 0/./k) *.. x }
  =()

let lemma path_sem_rz_basis_inv (x:matrix complex) (k:int)
      requires{is_a_ket_l x 1}
      requires{is_a_ket_basis_elt x}
      ensures{path_sem (rzp k) (path_sem (rzp (-k))x) = x}
  =()

let lemma path_sem_rz_inv (x:matrix complex) (k:int)
      requires{is_a_ket_l x 1}
      ensures{path_sem (rzp k) (path_sem (rzp (-k))x) = x}
  = ket_decomp_ x 1
      
      use kets.Superpositions
  
let lemma path_sem_hadamard_zero (x:matrix complex)
      requires{x = qbit_zero()}
      ensures{path_sem hadamard x = qbit_plus()}
  =()
  
let lemma path_sem_hadamard_one (x:matrix complex)
      requires{x = qbit_one()}
      ensures{path_sem hadamard x = qbit_minus()}
  =()
  
let lemma path_sem_hadamard_plus (x:matrix complex)
      requires{x = qbit_plus()}
      ensures{path_sem hadamard x = qbit_zero()}
  =()
  
let lemma path_sem_hadamard_minus (x:matrix complex)
      requires{x = qbit_minus()}
      ensures{path_sem hadamard x = qbit_one()}
  =()

let lemma path_semnot_basis (x:matrix complex)
      requires{is_a_ket_l x 2}
      requires{is_a_ket_basis_elt x}
      ensures{path_sem bricks_cnot x = if ket_to_int x = 0 then ket 2 0
                                       else  if ket_to_int x = 1 then ket 2 1
                                       else  if ket_to_int x = 2 then ket 2 3
                                       else ket 2 2
      }
  =()

let lemma path_sem_swap_basis (x:matrix complex)
      requires{is_a_ket_l x 2}
      requires{is_a_ket_basis_elt x}
      ensures{path_sem bricks_swap x = if ket_to_int x = 0 then ket 2 0
                                       else  if ket_to_int x = 1 then ket 2 2
                                       else  if ket_to_int x = 2 then ket 2 1
                                       else ket 2 3
      }
  =()

let lemma hadamard_invol (x:matrix complex)
      requires{is_a_ket_l x 1}
      ensures{path_sem hadamard (path_sem hadamard x) = x}
  =()
  
let   lemma correct_seq (  c c': circuit)  ( h h' h'': pps)
        requires{correct_path_sum c h}
        requires{correct_path_sum c' h'}
        requires{width c = width c'}
        requires{h_width h'' = width c }
        requires{h_range h'' = h_range h + h_range h'}
        requires{forall x y: int->int. (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                             (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                             h_angle h'' x y =  (h_angle h x y) +.+ (h_angle h' (h_basis_ket h x y) (fun k ->  y (k  + h_range h)))}
        requires{forall x y: int->int. forall i:int.  (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                                                (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                                                0<= i < h_width h'' ->
                                                h_basis_ket h'' x y i =  h_basis_ket h' (h_basis_ket h x y) (fun k ->  y (k  + h_range h)) i}
        ensures{correct_path_sum (c--c') h''}
  =()
  
let     lemma correct_par (  c c': circuit)  ( h h' h'': pps)
          requires{correct_path_sum c h}
          requires{correct_path_sum c' h'}
          requires{h_width h'' = width c + width c'}
          requires{h_range h'' = h_range h + h_range h'}
          requires{forall x y: int->int.
                                    (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                               (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                               h_angle h'' x y =  (h_angle h x y) +.+ (h_angle h'  (fun k ->  x (k  + h_width h)) (fun k ->  y (k  + h_range h)))}
          requires{forall x y: int->int. forall i:int.  (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                                                  (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                                                  0<= i < h_width h ->
                                                  h_basis_ket h'' x y i = h_basis_ket h x y i} 
          requires{forall x y: int->int. forall i:int.  (forall j. 0 <= j < h_width h'' -> 0<= x j <2)->
                                                  (forall j. 0 <= j < h_range h'' -> 0<= y j <2)->
                                                  h_width h <= i < h_width h'' ->
                                                  h_basis_ket h'' x y i = h_basis_ket h' (fun k ->  x (k  + h_width h)) (fun k ->  y (k  + h_range h)) (i- h_width h)} 
          ensures{correct_path_sum (c//c') h''}
  = ()
  
let lemma set_correct_main_path_sum (c: circuit) (h:pps)
      requires{h_width h = width c}
      requires{h_range h = range c}
      requires{forall x y. length x = width c -> length y = range c -> h_angle h (getbv x) (getbv y)  = ang_ind c (getbv x) (getbv y) }
      requires{forall x y. forall i :int. 0<= i < width c -> length x = width c -> length y = range c ->
                                     h_basis_ket h (getbv x) (getbv y) i  = basis_ket c (getbv x) (getbv y) i}
      ensures{correct_path_sum c h}
  =()  
  
let lemma set_path_sem_by_correct_pps (c: circuit) (h:pps)(x:matrix complex)
      requires{correct_path_sum c h}
      requires{is_a_ket_l x (width c)}
      requires{is_a_ket_basis_elt x }
      ensures{path_sem c x  = pps_apply h x}
  = ()

let lemma set_path_sem_by_main_pps (c: circuit) (x:bitvec)
      requires{length x = width c}
      ensures{path_sem c (bv_to_ket x)  = pow_inv_sqrt_2 (range c) *.. ket_sum_l (n_bvs (range c)) (fun y -> ang_exp (ang_ind c (getbv x) (getbv y)) *.. bv_to_ket (make_bv (basis_ket c (getbv x) (getbv y)) (width c))) (width c)}
  = set_path_sem_by_correct_pps c (circ_to_pps c) (bv_to_ket x)
  
let lemma set_path_sem_by_correct_pps_gen (c: circuit) (h:pps)
      requires{correct_path_sum c h}
      ensures{forall x. is_a_ket_l x (width c) ->  is_a_ket_basis_elt x  -> path_sem c x  = pps_apply h x}
  = ()
  
let lemma set_correct_path_sum_sim  (c: circuit)  (h h':pps) 
      requires{h_range h = h_range h'}
      requires{h_width h = h_width h'}
      requires{forall x y :bitvec.
                           length x = width c -> length y = h_range h -> h_angle h (getbv x) (getbv y)  = h_angle h' (getbv x) (getbv y)}
      requires{forall x y :bitvec.  forall i:int. length x = width c -> length y = h_range h -> 0<= i < width c ->
                                             h_basis_ket h (getbv x) (getbv y) i = h_basis_ket h' (getbv x) (getbv y) i}
      requires{correct_path_sum c h}
      ensures{correct_path_sum c h'}
  = ()

let lemma path_sum_equiv  (c: circuit)  (h h': pps) 
      requires{h_range h>=0}
      requires{h_range h = h_range h'}
      requires{h_width h = h_width h'}
      requires{forall x y :bitvec. length x = width c -> length y = h_range h -> h_angle h (getbv x) (getbv y) = h_angle h' (getbv x) (getbv y)}
      requires{forall x y :bitvec. forall i:int. 0<= i < width c -> length x = width c -> length y = h_range h -> h_basis_ket h (getbv x) (getbv y) i  = h_basis_ket h' (getbv x) (getbv y)i}
      ensures{correct_path_sum c h <-> correct_path_sum c h'}
  = if correct_path_sum c h then set_correct_path_sum_sim c h h'
    else if  correct_path_sum c h' then set_correct_path_sum_sim c h' h
    else ()

let lemma correct_to_path_sem (c:circuit) (h:pps)
      requires{correct_path_sum c h}
      ensures{forall x: matrix complex. is_a_ket_l x (width c) -> pps_apply h x = path_sem c x}
  =()

let lemma swap_invol_basis (x:matrix complex)      
      requires{is_a_ket_l x 2}
      requires{is_a_ket_basis_elt x }
      ensures{path_sem bricks_swap (path_sem bricks_swap x) = x}
  = assert{x = ket 2 (ket_to_int x)};
    path_sem_swap_basis (ket 2 0);
    path_sem_swap_basis (ket 2 1);
    path_sem_swap_basis (ket 2 2);
    path_sem_swap_basis (ket 2 3);
    assert{path_sem bricks_swap (ket 2 0) = ket 2 0};
    assert{path_sem bricks_swap (ket 2 1) = ket 2 2};
    assert{path_sem bricks_swap (ket 2 2) = ket 2 1};
    assert{path_sem bricks_swap (ket 2 3) = ket 2 3};
    if  ket_to_int x =   0 then ()
    else if ket_to_int x =  1 then ()
    else if ket_to_int x =  2 then ()
    else assert{ ket_to_int x =  3}

let lemma path_sem_to_correct (c:circuit) (h:pps)
      requires{h_width h = width c}
      requires{forall x: matrix complex. is_a_ket_l x (width c) ->
                         is_a_ket_basis_elt x -> pps_apply h x = path_sem c x}
      ensures{correct_path_sum c h}
  =()
  
let lemma  correct_main_path_sum ( c: circuit)
      ensures{correct_path_sum  c (circ_to_pps c)}
  =()
  
let ghost predicate correct_path_sum_bv (c:circuit) (r:int) (k: bitvec -> bitvec ->  bitvec) (a: bitvec -> bitvec -> angle)
      requires{0<=r}
      requires{forall x y. length x = width c -> length y = r -> length (k x y) = width c}
  = 
  correct_path_sum c (build_pps_bv  (width c) r k a)

let lemma  correct_path_sum_to_bv (c:circuit) (r:int) (k: bitvec -> bitvec ->  bitvec) (a: bitvec -> bitvec -> angle)
      requires{0<=r}
      requires{forall x y. length x = width c -> length y = r -> length (k x y) = width c}
      requires{correct_path_sum c (build_pps_bv  (width c) r k a)}
      ensures{correct_path_sum_bv c r k a}
  =()

let lemma unwire_correct_bv (c:circuit)  (r:int) (k: bitvec -> bitvec ->  bitvec) (a: bitvec -> bitvec -> angle)
      requires{0<=r}
      requires{forall x y. length x = width c -> length y = r -> length (k x y) = width c}
      requires{ correct_path_sum_bv c r k a}
      ensures{ P.correct_path_sum_bv  (unwire c) r k a}
  =()

let lemma unwire_correct_bv_rev (c:circuit)  (r:int) (k: bitvec -> bitvec ->  bitvec) (a: bitvec -> bitvec -> angle)
      requires{0<=r}
      requires{forall x y. length x = width c -> length y = r -> length (k x y) = width c}
      requires{ P.correct_path_sum_bv (unwire c)  r k a}
      ensures{ correct_path_sum_bv c r k a}
  = ()
  
let lemma wire_correct_bv (c:P.circuit)  (r:int) (k: bitvec -> bitvec ->  bitvec) (a: bitvec -> bitvec -> angle)
      requires{0<=r}
      requires{forall x y. length x = P.width c -> length y = r -> length (k x y) = P.width c}
      requires{ P.correct_path_sum_bv c r k a}
      ensures{ correct_path_sum_bv (wire c) r k a}
  =()
  
let lemma  correct_path_sum_by_bv (c:circuit) (r:int) (k: bitvec -> bitvec ->  bitvec) (a: bitvec -> bitvec -> angle)
      requires{0<=r}
      requires{forall x y. length x = width c -> length y = r -> length (k x y) = width c}
      requires{correct_path_sum_bv c r k a}
      ensures{correct_path_sum c (build_pps_bv  (width c) r k a)}
  =()  
  
let lemma correct_path_sum_bv_main (c:circuit) (r:int) (k: bitvec -> bitvec ->  bitvec) (a: bitvec -> bitvec -> angle)
      requires{0<=r}
      requires{forall x y. length x = width c -> length y = r -> length (k x y) = width c}
      requires{forall x y. forall i. length x = width c -> length y = r -> 0<= i < width c ->
                                                getbv (k x y) i = basis_ket c (getbv x) (getbv y) i}
      requires{forall x y. length x = width c -> length y = r -> 
                                      a x y = ang_ind c (getbv x) (getbv y) }
      requires{r = range c}
      ensures{correct_path_sum_bv c r k a}
  = 
  ()
  
let lemma correct_path_sum_bv_apply (c:circuit) (r:int) (k: bitvec -> bitvec ->  bitvec) (a: bitvec -> bitvec -> angle) (x:bitvec)
      requires{0<=r}
      requires{forall x y. length x = width c -> length y = r -> length (k x y) = width c}
      requires{length x = width c}
      requires{correct_path_sum_bv c r k a}
      ensures{path_sem c (bv_to_ket x) = pow_inv_sqrt_2 r *.. ket_sum_l (n_bvs r) (fun y -> ang_exp (a x y) *.. bv_to_ket (k x y)) (width c) }
  = ()

let function  seq_pps_bv (  c c': circuit)  (ghost r1 r2 r3:int) (ghost k1 k2 k3: bitvec -> bitvec ->  bitvec) (ghost a1 a2 a3: bitvec -> bitvec -> angle) : circuit
                                                                                                                                                               requires{0<=r1}
                                                                                                                                                               requires{0<=r2}
                                                                                                                                                               requires{forall x y. length x = width c -> length y = r1 -> length (k1 x y) = width c}
                                                                                                                                                               requires{forall x y. length x = width c -> length y = r2 -> length (k2 x y) = width c}
                                                                                                                                                               requires{forall x y. length x = width c -> length y = r3 -> length (k3 x y) = width c}
                                                                                                                                                               requires{width c = width c'}
                                                                                                                                                               requires{r3 = r1+r2}
                                                                                                                                                               requires{correct_path_sum_bv c r1 k1 a1}
                                                                                                                                                               requires{correct_path_sum_bv c' r2 k2 a2}
                                                                                                                                                               requires{forall x y: bitvec. length x = width c -> length y = r3 -> a3 x y = 
                                                                                                                                                                                                                                     (a1 x (hpart y r1)) +.+ (a2 (k1 x (hpart y r1))(tpart y r1))}
                                                                                                                                                               requires{forall x y: bitvec. length x = width c -> length y = r3 ->
                                                                                                                                                                                    k3 x y =   (k2 (k1 x (hpart y r1))(tpart y r1))}
                                                                                                                                                               ensures{result = c--c'}
                                                                                                                                                               ensures{width result = width c}
                                                                                                                                                               ensures{size result = size c + size c'}
                                                                                                                                                               ensures{ancillas result = max (ancillas c) (ancillas c')}
                                                                                                                                                               ensures{correct_path_sum_bv result r3 k3 a3}
  = correct_seq c c' (build_pps_bv  (width c) r1 k1 a1) (build_pps_bv  (width c) r2 k2 a2) (build_pps_bv  (width c) r3 k3 a3);
    c--c'            

let lemma  correct_path_sum_bv_sim (c:circuit) (r1 :int) (k1 : bitvec -> bitvec ->  bitvec) (a1 : bitvec -> bitvec -> angle)
      (r2 :int) (k2 : bitvec -> bitvec ->  bitvec) (a2 : bitvec -> bitvec -> angle)
      requires{r1 = r2}
      requires{0<=r1}
      requires{forall x y. length x = width c -> length y = r1 -> length (k1 x y) = width c}
      requires{forall x y. length x = width c -> length y = r1 ->  k1 x y = k2 x y}
      requires{forall x y. length x = width c -> length y = r1 ->  a1 x y = a2 x y}
      requires{correct_path_sum_bv c r1 k1 a1}
      ensures{correct_path_sum_bv  c r2 k2 a2}
  =()
  
let lemma path_sem_comp (d e: circuit) (x y z: matrix complex)
      requires{is_a_ket_l x (width d)}
      requires{path_sem d x = y}
      requires{path_sem e y = z}
      requires{width d = width e}
      ensures{path_sem (d -- e) x = z}
  =()
  
let function path_seq (d e: circuit) (ghost x y z: matrix complex) (ghost w:int)
      requires{is_a_ket_l x w}
      requires{path_sem d x = y}
      requires{path_sem e y = z}
      requires{width d = width e = w}
      ensures{width result = w}
      ensures{path_sem result x = z}
      ensures{is_a_ket_l  z w}
      ensures{result = d -- e}
  = d --e
  
let lemma path_sem_comp_ (d e: circuit) (x : matrix complex)
      requires{is_a_ket_l x (width d)}
      requires{width d = width e}
      ensures{path_sem (d -- e) x = path_sem e (path_sem d x)}
  =()
  
let lemma sem_comp (d e: circuit) (x y z: matrix complex)
      requires{sem d x  y}
      requires{sem e y  z}
      requires{width d = width e}
      ensures{sem (d -- e) x  z}
  =()

let lemma path_sem_cnot_basis (x:matrix complex)
      requires{is_a_ket_l x 2}
      requires{is_a_ket_basis_elt x}
      ensures{path_sem bricks_cnot x = if ket_to_int x = 0 then ket 2 0
                                       else  if ket_to_int x = 1 then ket 2 1
                                       else  if ket_to_int x = 2 then ket 2 3
                                       else ket 2 2}
  =()

let lemma place_kron (c:circuit) (k n: int) (x y y' z: matrix complex)
      requires{0<=k}
      requires{ width c+ k<= n}
      requires{is_a_ket_l x k}
      requires{is_a_ket_l y (width c)}
      requires{is_a_ket_l z (n- (width c) -k)}
      requires{path_sem c y = y'}
      ensures{path_sem (place c k n) (kronecker x (kronecker y z))  = kronecker x (kronecker y' z)}
  =()
  
let lemma place_width (c:circuit) (k n: int)
      requires{0<=k}
      requires{ width c+ k<= n}
      ensures{width (place c k n) = n}
  =()
     
     use binary.Binary_Op
  
let lemma place_bv_in (c:circuit) (k n: int)
      requires{0<=k}
      requires{ width c+ k<= n}
      ensures{forall x y i. binary_l x n  -> k<= i < k + width c -> basis_ket  (place c k n) x y i = basis_ket c (fun j -> x (j+k)) y (i-k)}
  =()
  
let lemma place_bv_out (c:circuit) (k n: int)
      requires{0<=k}
      requires{ width c+ k<= n}
      ensures{forall x y i. binary_l x n   -> 0<= i < n -> not (k<= i < k + width c) -> basis_ket  (place c k n) x y i = x i}
  =()
  
let lemma sequence_width (c d:circuit) 
      requires{width c = width d}
      ensures{width (c--d) = width c}
  =()

let lemma place_kron_bv (c:circuit) (k n: int) (bv : bitvec)
      requires{0<=k}
      requires{ width c+ k<= n}
      requires{length bv =n}
      ensures{path_sem (place c k n) (bv_to_ket bv) =  kronecker (kronecker (bv_to_ket (hpart bv k )) (path_sem c (bv_to_ket (htpart bv k (width c) )))) (bv_to_ket (tpart bv (k + width c) ))}
  = place_kron c k n (bv_to_ket (hpart bv k )) (bv_to_ket (htpart bv k (width c))) (path_sem c (bv_to_ket (htpart bv k (width c)))) (bv_to_ket (tpart bv (k + width c) ))

let lemma place_kron_exp (c:circuit) (k n: int) (x y  z: matrix complex)
      requires{0<=k}
      requires{ width c+ k<= n}
      requires{is_a_ket_l x k}
      requires{is_a_ket_l y (width c)}
      requires{is_a_ket_l z (n- (width c) -k)}
      ensures{path_sem (place c k n) (kronecker x (kronecker y z))  = kronecker x (kronecker (path_sem c y) z)}
  =()
  
let lemma place_kron_left (c:circuit) (n: int) (y y' z: matrix complex)
      requires{width c<=n}
      requires{is_a_ket_l y (width c)}
      requires{is_a_ket_l z (n- (width c))}
      requires{path_sem c y = y'}
      ensures{path_sem (place c 0 n) (kronecker y z) =  (kronecker y' z)}
  =()
  
let lemma place_kron_right (c:circuit) (k n: int) 
      requires{0<k}
      requires{n= width c +k}
      ensures{forall y  x : matrix complex. is_a_ket_l x k ->is_a_ket_l y (n-k) ->
                            path_sem (place c k n) (kronecker x y)   = kronecker x  (path_sem c y)}
  =()
  
let lemma place_place (c:circuit) (k k' n n': int) (x:bitvec)
      requires{0<=k}
      requires{ width c+ k <=n}
      requires{0<=k'}
      requires{ n+ k' <=n'}
      requires{length x = n'}
      ensures{path_sem (place (place c k n) k' n') (bv_to_ket x) =
                path_sem (place c (k+k') n') (bv_to_ket x)}
  =()

let lemma place_get_ket (c:circuit) (k n: int) (x y: bitvec)
      requires{0<=k}
      requires{ width c+ k<= n}
      requires{length x = n}
      requires{length y = n}
      requires{hpart x k = hpart y k}
      requires{tpart x (k + width c) = tpart y (k + width c)}
      ensures{get_ket (path_sem (place c k n) (bv_to_ket x)) (bv_to_int y)
              = get_ket (path_sem c (bv_to_ket (make_bv (fun i -> getbv x (i+k))(width c))))
                  (bv_to_int (make_bv (fun i -> getbv y (i+k))(width c)))}
  =()

let lemma place_get_ket_hpart_null (c:circuit) (k n: int) (x y: bitvec)
      requires{0<=k}
      requires{ width c+ k<= n}
      requires{length x = n}
      requires{length y = n}
      requires{hpart x k <> hpart y k}
      ensures{get_ket (path_sem (place c k n) (bv_to_ket x)) (bv_to_int y) = c_zero}
  =()

let lemma place_get_ket_tpart_null (c:circuit) (k n: int) (x y: bitvec)
      requires{0<=k}
      requires{ width c+ k<= n}
      requires{length x = n}
      requires{length y = n}
      requires{tpart x (k + width c) <> tpart y (k + width c)}
      ensures{get_ket (path_sem (place c k n) (bv_to_ket x)) (bv_to_int y) = c_zero}
  =()

let function place_hadamard   (k n:int)  : circuit
                                             requires{0<= k <n}
                                             ensures{range result = 1}
                                             ensures{size result = 1}
                                             ensures{width result = n}
                                             ensures{ancillas result = 0}
                                             ensures{forall x y: int->int. forall i:int. 0<=i<n ->basis_ket result x y i = if i = k then y 0 else x i}
                                             ensures{forall x y: int->int.  ang_ind result x y  = (x k *y 0)/./1}
                                             ensures{forall m:int. forall x y: int->int.   1<=m ->  ang_ind result x y  =  (x k * y 0 * power 2 (m-1)) /./ m}
                                             ensures{forall m:int. forall x y: int->int.   1<=m ->  ang_ind result x y  =  (-(x k * y 0 * power 2 (m-1))) /./ m}
  = place  hadamard  k n

let function place_hadamard_bv (k n:int)  
               requires{0<= k <n}
               ensures{range result = 1}
               ensures{width result = n}
               ensures{size result =1}
               ensures{ancillas result =0}
               ensures{forall x y: int->int. forall i:int. 0<=i<n ->basis_ket result x y i = if i = k then y 0 else x i}
               ensures{forall x y: int->int.  ang_ind result x y  = (x k *y 0)/./1}
               ensures{forall x y: int->int. forall m:int. m>= 1 ->  ang_ind result x y  =  (x k * y 0 * power 2 (m-1)) /./  m }
               ensures{correct_path_sum_bv result 1 (fun x y -> make_bv (fun i -> if i = k then getbv y 0 else getbv x i) n)
                         (fun x y ->  (getbv x k * getbv y 0 * power 2 (n-1)) /./ n )}
  = place_hadamard k n
  
let lemma path_cont  (c:circuit) (co k  n:int)
      requires{0<= co < n}
      requires{0<= k <= n - (width c)}
      requires{k <= co -> k + width c <= co}
      ensures{forall bv. length bv = n -> getbv bv co  = 0 -> path_sem (cont c co k n)  (bv_to_ket bv) = (bv_to_ket bv)}
      ensures{forall bv. length bv = n  -> getbv bv co  = 1 -> path_sem (cont c co k n) (bv_to_ket bv) =  (path_sem (place c k n) (bv_to_ket bv))}
  = () 

let lemma cont_width  (c:circuit) (co k  n:int)
      requires{0<= co < n}
      requires{0<= k <= n - (width c)}
      requires{k <= co -> k + width c <= co}
      ensures{width (cont c co k n) = n}
  = () 
  
let lemma path_cont_ketz  (c:circuit) (co k  n:int) (x:matrix complex)
      requires{0<= co < n}
      requires{0<= k <= n - (width c)}
      requires{k <= co -> k + width c <= co}
      requires{is_a_ket_l x n}
      requires{is_a_ket_basis_elt x}
      requires{getbv (ket_to_bv x) co = 0}
      ensures{path_sem (cont c co k n)  x = x}
  = path_cont c co k n

let lemma path_cont_keto  (c:circuit) (co k  n:int) (x:matrix complex)
      requires{0<= co < n}
      requires{0<= k <= n - (width c)}
      requires{k <= co -> k + width c <= co}
      requires{is_a_ket_l x n}
      requires{is_a_ket_basis_elt x}
      requires{getbv (ket_to_bv x) co = 1}
      ensures{path_sem (cont c co k n) x =  (path_sem (place c k n) x)}
  = path_cont c co k n

let lemma path_cont_ketz_gen  (c:circuit) (co k  n:int) 
      requires{0<= co < n}
      requires{0<= k <= n - (width c)}
      requires{k <= co -> k + width c <= co}
      ensures{forall x: matrix complex. is_a_ket_l x n -> is_a_ket_basis_elt x ->getbv  (ket_to_bv x) co = 0 ->path_sem (cont c co k n)  x = x}
  = ()

let lemma path_cont_keto_gen  (c:circuit) (co k  n:int) 
      requires{0<= co < n}
      requires{0<= k <= n - (width c)}
      requires{k <= co -> k + width c <= co}
      ensures{forall x: matrix complex. is_a_ket_l x n -> is_a_ket_basis_elt x ->getbv  (ket_to_bv x) co = 1 ->
                        path_sem (cont c co k n) x =  (path_sem (place c k n) x)}
  = () 

let lemma cont_kron_left_bv_to_ket (c:circuit) (  n: int) (x : matrix complex)
      requires{0<=  width c = n-1}
      requires{is_a_ket_l x  (width c)}
      ensures{forall y: bitvec. length y = 1 -> getbv y 0 = 0 -> path_sem (cont c (n-1) 0 n) (kronecker x (bv_to_ket y)) =   (kronecker x (bv_to_ket y))}
      ensures{forall y: bitvec. length y = 1 -> getbv y 0 = 1 -> path_sem (cont c (n-1) 0 n) (kronecker x (bv_to_ket y)) =   (kronecker (path_sem c x) (bv_to_ket y))}
  =   ()

let lemma place_kron_left_path (c:circuit) (  n: int)
      requires{width c < n}
      ensures{forall x y: matrix complex. is_a_ket_l x (width c) -> is_a_ket_l y (n- width c) -> path_sem (place c 0 n) (kronecker x y) = kronecker (path_sem c x) y}
  =()

let lemma place_kron_left_sem (c:circuit) (  n: int)
      requires{width c < n}
      ensures{forall x y z: matrix complex.  is_a_ket_l y (n- width c) -> sem c x z -> sem (place c 0 n) (kronecker x y) (kronecker z y)}
  =()
  
let lemma cont_kron_pat_right (c:circuit) (co k  n:int) (y :matrix complex)
      requires{0<= co < k }
      requires{ n = k + (width c)}
      requires{is_a_ket_l y (width c)}
      ensures{forall x: matrix complex. is_a_ket_basis_elt x  -> is_a_ket_l x k ->
                        getbv (ket_to_bv x) co  = 0 -> path_sem (cont c co k n) (kronecker x y) =  kronecker x y}
      ensures{forall x: matrix complex. is_a_ket_basis_elt x  -> is_a_ket_l x k ->
                        getbv (ket_to_bv x) co  = 1 -> path_sem (cont c co k n) (kronecker x y) =  kronecker x (path_sem c y)}
  =()
  
let lemma cont_kron_zero (c:circuit) (co k  n:int) (x y z:matrix complex)
      requires{0<= co < n}
      requires{0<= k <= n - (width c)}
      requires{k <= co -> k + width c <= co}
      requires{is_a_ket_l x k}
      requires{is_a_ket_l y (width c)}
      requires{is_a_ket_l z (n - k - width c)}
      requires{is_a_ket_basis_elt x}
      requires{is_a_ket_basis_elt z}
      requires{co < k -> getbv (ket_to_bv x) co = 0}
      requires{ k<= co -> getbv (ket_to_bv z) (co - k -width c) = 0}
      ensures{path_sem (cont c co k n) (kronecker(kronecker  x y) z) = (kronecker(kronecker  x y) z)}
  =()

let lemma cont_kron_one (c:circuit) (co k  n:int) (x y z:matrix complex)
      requires{0<= co < n}
      requires{0<= k <= n - (width c)}
      requires{k <= co -> k + width c <= co}
      requires{is_a_ket_l x k}
      requires{is_a_ket_l y (width c)}
      requires{is_a_ket_l z (n - k - width c)}
      requires{is_a_ket_basis_elt x}
      requires{is_a_ket_basis_elt z}
      requires{co < k -> getbv (ket_to_bv x) co = 1}
      requires{ k<= co -> getbv (ket_to_bv z) (co - k -width c) = 1}
      ensures{path_sem (cont c co k n) (kronecker(kronecker  x y) z) = path_sem (place c k n) (kronecker(kronecker  x y) z) }
  =()

let lemma cont_kron_pat_right_gen (circ:circuit) (c k  n:int) 
      requires{0<= c < k }
      requires{ n = k + (width circ)}
      ensures{forall y: matrix complex. forall x: bitvec.  is_a_ket_l y (width circ) -> length x = k ->
                                                  getbv x c  = 0 -> path_sem (cont circ c k n) (kronecker (bv_to_ket x) y) =  kronecker (bv_to_ket x) y}
      ensures{forall y: matrix complex. forall x: bitvec.  is_a_ket_l y (width circ) -> length x = k ->
                                                  getbv x c  = 1 -> path_sem (cont circ c k n) (kronecker (bv_to_ket x) y) =  kronecker (bv_to_ket x) (path_sem circ y)}
  =()

let lemma cont_kron_pat_right_gen_ket (circ:circuit) (c k  n:int) 
      requires{0<= c < k }
      requires{ n = k + (width circ)}
      ensures{forall x y : matrix complex. is_a_ket_l y (width circ) -> is_a_ket_l x  k -> is_a_ket_basis_elt x ->
                                                  getbv (ket_to_bv x) c  = 0 -> path_sem (cont circ c k n) (kronecker x y) =  kronecker x y}
      ensures{forall x y : matrix complex. is_a_ket_l y (width circ) -> is_a_ket_l x  k -> is_a_ket_basis_elt x ->
                                                  getbv (ket_to_bv x) c = 1 -> path_sem (cont circ c k n) (kronecker x y) =  kronecker x (path_sem circ y)}
  =()

let function cont_last_qbit_kron (c:circuit) :circuit
                                                ensures{size result <= size c * cont_size}
                                                ensures{ancillas result = ancillas c}
                                                ensures{range result = range c}
                                                ensures{width result = width c +1}
                                                ensures{forall x y: matrix complex. sem c x y -> 
                                                                    sem result (kronecker x (ket 1 1)) (kronecker y (ket 1 1))}
                                                ensures{forall x : matrix complex. is_a_ket_l x (width c) ->  
                                                                   sem result (kronecker x (ket 1 0)) (kronecker x (ket 1 0))}
  = cont c (width c) 0 (width c +1)

let function cont_last_qbit_kron_path (c:circuit) :circuit
                                                ensures{size result <= size c * cont_size}
                                                ensures{ancillas result = ancillas c}
                                                ensures{range result = range c}
                                                ensures{width result = width c +1}
                                                ensures{forall x y: matrix complex. is_a_ket_l x (width c) ->  path_sem c x = y -> 
                                                                    path_sem result (kronecker x (ket 1 1))= (kronecker y (ket 1 1))}
                                                ensures{forall x : matrix complex. is_a_ket_l x (width c) ->  
                                                                   path_sem result (kronecker x (ket 1 0)) = (kronecker x (ket 1 0))}
  = cont c (width c) 0 (width c +1)

end

module Circuit_macros

         use  wired_circuits.Qbricks_prim
         use  wired_circuits.Circuit_c
         use  int_expo.Int_Exponentiation
         use  matrices.Matrix
         use  qdata.Qreg
         use binary.Bit_vector
         use qdata.Bv_to_ket
         use  complex.Complex
         use  int.Int
         use  unit_circle.Angle
         use p_set.IndexestoSet
         use functions.MapInjection
         use derived_circuits_c.Qbit_permutations as P
         use Circuit_semantics
         use extr_int.Ind_isum
     use binary.Int_to_bv
     
let rec function m_skip (k:int): circuit
                                   requires{0<k}
                                   variant{k}
                                   ensures{size result = 0}
                                   ensures{unwire result = P.ids k}
                                   ensures{ancillas  result = 0}
                                   ensures{size result = 0}
                                   ensures{range result = 0}
                                   ensures{width result = k}
                                   ensures{forall x y: int->int. forall i:int. basis_ket result x y i = x i}
                                   ensures{forall x y: int->int. ang_ind result x y  =  1 /./ 0}
                                   ensures{forall x y: int->int. forall k:int. ang_ind result x y  =  0 /./ k}
  = if k= 1 then skip
    else (m_skip (k-1)) // skip
  
let lemma m_skip_path_sem(k:int) (x:matrix complex)
      requires{0<k}
      requires{is_a_ket_l x k}
      ensures{path_sem (m_skip k) x = x}
  =()

let swap_gen (k k' n:int)
      requires{0<= k < n}
      requires{0<= k' < n}
      ensures{ancillas result = 0}
      ensures{size result <= 1}      
      ensures{unwire result = P.permute_atom k k' n}
      ensures{width result = n}
      ensures{range result = 0}
      ensures{forall x y. ang_ind result x y = ang_zero}
      ensures{forall x y i. 0<=i < n -> basis_ket result x y i = if i = k then x k' else if i = k' then x k else x i}
  = if k = k' then m_skip n
    else swap k k' n
  
let rec function permutation_circuit_pre (k:int)(n:int) (f:int->int)
                   requires{0<= k < n}
                   requires{p_bijective f (to_fset 0 n) (to_fset 0 n)}
                   ensures{unwire result = P.permutation_circuit_pre k n f}
                   ensures{width result = n}
                   ensures{size result <= n-k}
                   ensures{ancillas result = 0}
                   ensures{range result = 0}
                   ensures{forall x y. ang_ind result x y = P.ang_ind (P.permutation_circuit_pre k n f) x y}
                   ensures{forall x y. forall i:int. 0 <= i < n -> basis_ket result x y i = P.basis_ket (P.permutation_circuit_pre k n f) x y i}
                   variant{n-k}
  = if k = n-1 then
      swap_gen (P.c_inv_func_int f n (n-1)) (n-1) n
    else
      (swap_gen  k  (P.qbit_permutation (P.permutation_circuit_pre (k + 1) n f)
                       (P.c_inv_func_int f n  k)) n) -- (permutation_circuit_pre (k+1) n f)

let function permutation_circuit (n:int) (f:int->int): circuit
                                                         requires{0<n}
                                                         requires{p_bijective f (to_fset 0 n) (to_fset 0 n)}
                                                         ensures{unwire result = P.permutation_circuit n f}
                                                         ensures{width result = n}
                                                         ensures{size result <=n}
                                                         ensures{ancillas result = 0}
                                                         ensures{range result = 0}
                                                         ensures{forall x y. ang_ind result x y = ang_zero}
                                                         ensures{forall x y. forall i:int. 0 <= i < n -> basis_ket result x y i = x (f i)}
                                                         ensures{forall x:bitvec. length x = n -> path_sem  result (bv_to_ket x)=  bv_to_ket (make_bv (fun i -> getbv x (f i)) n)}
  = permutation_circuit_pre 0 n f
  
let function gen_phase (k n:int):circuit
                                   requires{0<n}
                                   requires{0<=k}
                                   ensures{size result = 1}
                                   ensures{range result = 0}
                                   ensures{width result = n}
                                   ensures{forall x y: int->int. forall i:int. basis_ket result x y i = x i}
                                   ensures{forall x y: int->int. ang_ind result x y  =  1 /./ k}
  =
  place (phase k) 0 n 
  
let function crz (c t k n:int):circuit
                                 requires{0<= c < n}
                                 requires{0<= t < n}
                                 requires{c<>t}
                                 ensures{width result = n}
                                 ensures{size result = cont_size}
                                 ensures{range result = 0}
                                 ensures{ancillas result = 0}
                                 ensures{forall x y i. basis_ket result x y i = x i}
                                 ensures{forall x y. ang_ind result x y  = (x c * x t )/./k}
                                 ensures{forall x y k'. 0<= k<= k' ->  ang_ind result x y  = (x c * x t *power 2 (k'-k))/./k'}
  = cont (rzp k) c t n

let function prz (k t n:int):circuit
                               requires{0<= t < n}
                               ensures{width result = n}
                               ensures{size result = 1}
                               ensures{range result = 0}
                               ensures{ancillas result = 0}
                               ensures{forall x y i. basis_ket result x y i = x i}
                               ensures{forall x y.  0<=k<=n -> ang_ind result x y  = (x t * power 2 (n-k)) /./n}
  = place (rzp k)  t n

let function crzn (c t k n:int):circuit
                                  requires{0<= c < n}
                                  requires{0<= t < n}
                                  requires{c<>t}
                                  requires{k<=0}
                                  ensures{width result = n}
                                  ensures{size result = cont_size}
                                  ensures{range result = 0}
                                  ensures{forall x y i. basis_ket result x y i = x i}
                                  ensures{ancillas result = 0}
                                  ensures{forall x y k'. -k<= k' ->  ang_ind result x y  = (-(x c * x t *power 2 (k'+k)))/./k'}
  = cont (rzp k) c t n

let function crzn_up (c t k n:int) (ghost den:int):circuit
                                                     requires{0<= c < n}
                                                     requires{0<= t < n}
                                                     requires{c<>t}
                                                     requires{k<=0}
                                                     requires{-k<= den}
                                                     ensures{width result = n}
                                                     ensures{size result = cont_size}
                                                     ensures{range result = 0}
                                                     ensures{forall x y i. basis_ket result x y i = x i}
                                                     ensures{ancillas result = 0}
                                                     ensures{forall x y. ang_ind result x y  = (-(x c * x t *power 2 (den+k)))/./den}
  = cont (rzp k) c t n

      use unit_circle.Bin_check_zero
      use binary.Binary_Op

let function c_rzp_one (c t  n:int):circuit
                                      requires{0<= c < n}
                                      requires{0<= t < n}
                                      requires{c<>t}
                                      ensures{width result = n}
                                      ensures{size result = cont_size}
                                      ensures{range result = 0}
                                      ensures{forall x y i. basis_ket result x y i = x i}
                                      ensures{ancillas result = 0}
                                      ensures{forall x y. ang_ind result x y  = (x c * x t) /./1}
                                      ensures{forall x y. n= 2 -> binary_l x 2 -> ang_ind result x y  = bin_check_zero x 2}
  = crz  c t 1 n

      use qdata.Ket_basis
      use unit_circle.Ang_sum
      use kets.Superpositions
      use qdata.Kronecker_Qbit
      use qdata.Sqrt_two
      use binary.Bit_vector_decomp
      use p_int.Int_comp
      use complex_expo.Complex_Exponentiation
      use matrices.Matrix_scalar

let rec function repeat_had (n:int):circuit
                                      requires{1<=n}
                                      ensures{width result = n}
                                      ensures{range result = n}
                                      ensures{size result = n}
                                      ensures{ancillas result = 0}
                                      ensures{circ_to_pps result = repeat_pps_had n}
                                      ensures{forall x y: int->int.  forall i :int. 0<= i < n -> 
                                                                               basis_ket result x y i =   y i}
                                      ensures{forall x y. binary_l x n -> binary_l y n -> ang_ind result x y   = ang_sum(fun i -> int_to_ang (if  x i =  y i = 1 then 1 else 0) 1) 0 n}
                                      variant{n}               
  =  if n = 1 then
       hadamard
     else
       (repeat_had (n-1)) // hadamard

let lemma repeat_had_basis_bv (n :int) (x:bitvec)
      requires{1<=n}
      requires{length x = n}
      ensures{path_sem (repeat_had n) (bv_to_ket x) =
                pow_inv_sqrt_2 n *.. ket_sum_l (n_bvs n) (fun y ->  cpower (-. c_one)   (ind_isum (fun k -> getbv  x k * getbv y k)  0 n) *.. bv_to_ket y) n}
  =()
  
let lemma repeat_had_basis (n i :int)
      requires{1<=n}
      requires{0<=i <power 2 n}
      ensures{path_sem (repeat_had n) (ket n i) =
                pow_inv_sqrt_2 n *.. ket_sum_l (n_bvs n) (fun y ->  cpower (-. c_one)   (ind_isum (fun k -> getbv  (int_to_bv i n) k * getbv y k)  0 n) *.. bv_to_ket y) n}
  =()
       
let lemma path_sem_repeat_had_superposition (n:int)
      requires{1<=n}
      ensures{ path_sem  (repeat_had n) (superposition_state n) = (ket n 0)}
  =repeat_had_superposition n

let lemma path_sem_repeat_had_invol (n:int) (x:matrix complex)
      requires{is_a_ket_l x n}
      requires{1<=n}
      ensures{ path_sem  (repeat_had n) (path_sem (repeat_had n) x) = x}
  =repeat_had_superposition n

let lemma path_sem_repeat_had_to_superposition (n:int)
      requires{1<=n}
      ensures{ path_sem  (repeat_had n)  (ket n 0) = (superposition_state n)}
  =repeat_had_superposition n

     use remarkable_fragments.Flat_mute_circuits

let lemma sem_ind_cnot (c k n:int)
      requires{0<= c < n}
      requires{0<= k < n}
      requires{k<> c}
      ensures{forall ket : matrix complex. is_a_ket_l ket n -> is_a_ket_basis_elt ket  ->
                           getbv (ket_to_bv ket) c = 0 -> path_sem (cnot c k n) ket = ket}
      ensures{forall ket : matrix complex. is_a_ket_l ket n -> is_a_ket_basis_elt ket  ->
                           getbv (ket_to_bv ket) c = 1 -> path_sem (cnot c k n) ket = bv_to_ket (make_bv (fun i -> if i = k then 1 - getbv (ket_to_bv ket) i else getbv  (ket_to_bv ket) i) n)}
  =()

     use matrices.Kronecker_product  

let lemma sem_ind_cnot_zero ( n:int)
      requires{1 < n}
      ensures{forall ket1 : matrix complex.forall i:int. is_a_ket_l ket1 (n-1) -> is_a_ket_basis_elt ket1  -> 0<=i <2 ->
                                                    getbv (ket_to_bv ket1) 0 = 1 -> path_sem (cnot 0 (n-1) n) (kronecker ket1 (ket 1 i)) = kronecker ket1 (ket 1 (1-i))}
      ensures{forall ket1 : matrix complex.forall i:int. is_a_ket_l ket1 (n-1) -> is_a_ket_basis_elt ket1  -> 0<=i <2 ->
                                                    getbv (ket_to_bv ket1) 0 = 0 -> path_sem (cnot 0 (n-1) n) (kronecker ket1 (ket 1 i)) = kronecker ket1 (ket 1 i)}
  = ()

let function ind_neg_cnot c k n:circuit
                                  requires{0<= c < n}
                                  requires{0<= k < n}
                                  requires{k<> c}
                                  ensures{range result = 0}
                                  ensures{ancillas result = 0}
                                  ensures{size result = 3}
                                  ensures{forall x y i. binary_l x n -> 0<= i < n -> basis_ket result x y i =   if i = k then if x c = 0 then 1 - x i else x i else x i}
                                  ensures{forall x y . binary_l x n -> ang_ind result x y  = ang_zero}
                                  ensures{forall x. length x = n  -> path_sem result (bv_to_ket x)
                                                                     = bv_to_ket (make_bv (fun i -> if i = k then if getbv x c = 0 then 1 - getbv x i else getbv x i else getbv x i) n)}
                                  ensures{width result = n}
  = let ind_neg_cnot_pre c k n
          requires{0<= c < n}
          requires{0<= k < n}
          requires{k<> c}
          ensures{width result = n}
          ensures{range result = 0}
          ensures{forall x y i. binary_l x n -> 0<= i < n -> basis_ket result x y i = if i = c then 1 - x i else
                                                                                        if i = k then if x c = 0 then 1 - x i else x i else x i}
          ensures{forall x y . binary_l x n -> ang_ind result x y  = ang_zero}
          ensures{ancillas result = 0}
          ensures{size result = 2}
          ensures{width result = n}
      =  seq_flat_mute (place xx c n)  (cnot c k n)
    in 
    seq_flat_mute (ind_neg_cnot_pre c k n)  (place xx c n)
    
let lemma sem_ind_neg_cnot_zero (n:int)
      requires{0 < n}
      ensures{forall i : int. 0<= i < power 2 (n-1)   ->
                         path_sem (ind_neg_cnot 0  n (n+1)) (kronecker (ket n i) (ket 1 1)) = (kronecker (ket n i) (ket 1 0))}
      ensures{forall i : int.  power 2 (n-1) <= i < power 2 n   ->
                         path_sem (ind_neg_cnot 0 n (n+1) ) (kronecker (ket n i) (ket 1 0)) = (kronecker (ket n i) (ket 1 0))}
      ensures{forall ket : matrix complex. is_a_ket_l ket (n+1) -> is_a_ket_basis_elt ket  ->
                           getbv (ket_to_bv ket) 0 = 1 -> path_sem (ind_neg_cnot 0 n (n+1) ) ket = ket}
      ensures{forall ket : matrix complex. is_a_ket_l ket (n+1) -> is_a_ket_basis_elt ket  ->
                           getbv (ket_to_bv ket) 0 = 0 -> path_sem (ind_neg_cnot 0 n (n+1) ) ket = bv_to_ket (make_bv (fun i -> if i = n then 1 - getbv (ket_to_bv ket) i else getbv  (ket_to_bv ket) i) (n+1))}
  = path_sem_flat_mute_ket (ind_neg_cnot 0 n (n+1) )

let rec function repeat_xx (n:int):circuit
                                     requires{1<=n}
                                     ensures{width result = n}
                                     ensures{range result = 0}
                                     ensures{size result = n}
                                     ensures{ancillas result = 0}
                                     ensures{forall x y: int->int.  forall i :int. 0<= i < n -> 
                                                                              basis_ket result x y i =   1 - (x i)}
                                     ensures{forall x y: int->int. ang_ind result x y   = ang_zero}
                                     variant{n}               
  =  if n = 1 then
       xx
     else
       (repeat_xx (n-1)) // xx
   
let function with_permutation (c: circuit) (f:int->int)
               requires{p_bijective f (to_fset 0 (width c)) (to_fset 0 (width c))}
               ensures{unwire result = P.with_permutation (unwire c) f}
               ensures{size result <= 2* width c + size c}
               ensures{ancillas result = ancillas c}
               ensures{width result = width c}
               ensures{range result = range c}
               ensures{forall x y: int->int. ang_ind result x y = ang_ind c (fun i -> x (f i)) y}
               ensures{forall x y: int->int. forall i:int. 0 <= i < width c -> basis_ket result x y i
                                                                               = basis_ket c (fun i -> x (f i)) y ((P.c_inv_func_int f  (width c)) i)}
               ensures{forall x y: int->int. forall i:int. 0 <= i < width c -> basis_ket result (fun i -> x (P.c_inv_func_int f   (width c) i))
                                                                                 y i
                                                                               = basis_ket c x y (P.c_inv_func_int f   (width c) i)}
               ensures{result =  ( (permutation_circuit (width c) f)-- c) -- (permutation_circuit (width c)  (P.c_inv_func_int f  (width c)))}
  = let permut_apply()
          ensures{size result <= width c + size c}
          ensures{ancillas result = ancillas c}
          ensures{width result = width c}
          ensures{range result = range c}
          ensures{forall x y: int->int. ang_ind result x y = ang_ind c (fun i -> x (f i)) y}
          ensures{forall x y: int->int. forall i:int. 0 <= i < width c -> basis_ket result x y i
                                                                          = basis_ket c (fun i -> x (f i)) y i}
          ensures{result =  (permutation_circuit (width c) f) -- c}
      =  (permutation_circuit (width c) f) -- c
    in  (permut_apply()) -- (permutation_circuit (width c) (P.c_inv_func_int f  (width c)))

let function unwire_with_permutation (c: circuit) (f:int->int)
               requires{p_bijective f (to_fset 0 (width c)) (to_fset 0 (width c))}
               ensures{forall x. is_a_ket_l x (width c) -> path_sem (with_permutation c f) x = P.path_sem (P.with_permutation (unwire c) f) x}
  =()
  
let lemma with_permutation_kronecker_gen (c :circuit)  (k n:int)
      requires{width c = n}
      requires{0<=k < n}
      ensures{forall im im_d ant ant_d: matrix complex.
                                        is_a_ket_l ant k -> is_a_ket_l ant_d (n-k) ->
                                        is_a_ket_l im k -> is_a_ket_l im_d (n-k) ->
                                        is_a_ket_basis_elt ant  -> is_a_ket_basis_elt ant_d ->
                                        path_sem c  (kronecker ant ant_d) = kronecker im im_d -> 
                                        path_sem (with_permutation c (fun i -> if i< k then i + n-k else  i - k)) (kronecker ant_d ant) = kronecker  im_d im }
  = P.with_permutation_kronecker_gen (unwire c) k n;
    unwire_with_permutation c (fun i -> if i< k then i + n-k else  i - k)

let function permutation_three_blocks(n1 n2 n3 n:int)
               requires{0<=n1}
               requires{0<=n2}
               requires{0<=n3}
               requires{0<n}
               requires{n = n1 +n2+n3}
               ensures{size result <= n}
               ensures{ancillas  result =0}
               ensures{width result = n}
               ensures{forall x y z. length x = n1 -> length y = n2 -> length z = n3 ->
                                                path_sem result
                                                  (kronecker (kronecker (bv_to_ket x) (bv_to_ket y))(bv_to_ket z) ) = (kronecker (kronecker (bv_to_ket x) (bv_to_ket z))(bv_to_ket y) )}
  = permutation_circuit  n (fun j -> if j < n1 then j else if j < n1 + n3 then j + n2 else j-n3)
  
  
let function insert_qbits (c :circuit)  (k n i:int):circuit
                                                      requires{width c = n}
                                                      requires{0<=k < n}
                                                      requires{0<i}
                                                      ensures{ancillas result = ancillas c}
                                                      ensures{width result = n +i }
                                                      ensures{size result <= 2* (n+i) + size c }
                                                      ensures{range result = range c} 
                                                      ensures{forall x y: int->int. ang_ind result x y = ang_ind c (fun j -> x (if j < k then j else if j < n then j + i else j-n+k)) y}
                                                      ensures{forall x y: int->int. forall j:int. 0 <= j < k ->
                                                                                             basis_ket result x y j = 
                                                                                               basis_ket c (fun ii -> x (if ii < k then ii else if ii < n then ii + i else ii-n+k))
                                                                                                 y j}
                                                      ensures{forall x y: int->int. forall j:int.  k+i <= j < n+i ->
                                                                                             basis_ket result x y j = 
                                                                                               basis_ket c (fun ii -> x (if ii < k then ii else if ii < n then ii + i else ii-n+k))
                                                                                                 y (j-i)}
                                                      ensures{forall x y: int->int. forall j:int. k <= j < k+i ->
                                                                                             basis_ket result x y j =  x j}
  =
  set_bijective_auto (fun j -> if j < k then j else if j < n then j + i else j-n+k) (to_fset 0 (n+i));
  assert{width (with_permutation (  c // (m_skip i)) (fun j -> if j < k then j else if j < n then j + i else j-n+k)) = n +i};
  P.unic_inverse_c_int (fun j -> if j < k then j else if j < n then j + i else j-n+k)
    (fun j -> if j < k then j else if j < k+i then j + n-k else j-i)   (n+i) ;
  with_permutation (  c // (m_skip i)) (fun j -> if j < k then j else if j < n then j + i else j-n+k)

    use binary.Bv_concat

let lemma insert_qbits_path_sem (c :circuit)  (k n i:int)(x:bitvec) (im im_d: matrix complex)
      requires{width c = n}
      requires{0<=k < n}
      requires{0<i}
      requires{length x = n+i}
      requires{is_a_ket_l im k}
      requires{is_a_ket_l im_d (n-k)}
      requires{path_sem c   (bv_to_ket (concat (hpart x k) (tpart x (k+i)))) = (kronecker im im_d)}
      ensures{path_sem (insert_qbits c k n i) (bv_to_ket x) = kronecker im (kronecker (bv_to_ket (htpart x k i)) im_d)}
  = P.insert_qbits_path_sem (unwire c) k n i x im im_d

let lemma insert_qbits_path_sem_basis (c :circuit)  (k n i:int)(x y z x' z': matrix complex)
      requires{width c = n}
      requires{0<=k < n}
      requires{0<i}
      requires{is_a_ket_l x  k}
      requires{is_a_ket_basis_elt x }
      requires{is_a_ket_basis_elt y }
      requires{is_a_ket_basis_elt z }
      requires{is_a_ket_l x' k}
      requires{is_a_ket_l y i}
      requires{is_a_ket_l z (n-k)}
      requires{is_a_ket_l z' (n-k)}
      requires{path_sem c   (kronecker x z) = kronecker x' z'}
      ensures{path_sem (insert_qbits c k n i) (kronecker x (kronecker y z)) = (kronecker x' (kronecker y z')) }
  = insert_qbits_path_sem c k n i (ket_to_bv (kronecker(kronecker x y)z)) x' z'
  
let function insert_qbits_gen (c :circuit)  (k n i:int):circuit
                                                          requires{width c = n}
                                                          requires{0<=k < n}
                                                          requires{0<=i}
                                                          ensures{ancillas result = ancillas c}
                                                          ensures{width result = n +i }
                                                          ensures{size result <= 2* (n+i) + size c }
                                                          ensures{range result = range c} 
                                                          ensures{forall x y: int->int. ang_ind result x y = ang_ind c (fun j -> x (if j < k then j else if j < n then j + i else j-n+k)) y}                                                          
                                                          ensures{forall x y: int->int. forall j:int. 0 <= j < k ->
                                                                                                 basis_ket result x y j = 
                                                                                                   basis_ket c (fun ii -> x (if ii < k then ii else if ii < n then ii + i else ii-n+k))
                                                                                                     y j}
                                                          ensures{forall x y: int->int. forall j:int.  k+i <= j < n+i ->
                                                                                                 basis_ket result x y j = 
                                                                                                   basis_ket c (fun ii -> x (if ii < k then ii else if ii < n then ii + i else ii-n+k))
                                                                                                     y (j-i)}
                                                          ensures{forall x y: int->int. forall j:int. k <= j < k+i ->
                                                                                                 basis_ket result x y j =  x j}
                                                          ensures{forall im im_d inserted x.is_a_ket_l im k -> is_a_ket_l im_d (n-k) -> inserted = (bv_to_ket (htpart x k i)) -> length x = n + i -> 
                                                                  path_sem c   (bv_to_ket (concat (hpart x k) (tpart x (k+i)))) = (kronecker im im_d) -> 
                                                                  path_sem result (bv_to_ket x) = kronecker im (kronecker inserted  im_d)}
  = if 0< i then insert_qbits c k n i else  c
  
let  function swap_lists  (c1 c2 l n :int) 
                requires{0<= c1 <  n}
                requires{0< l }
                requires{ c2 + l <= n}
                requires{c1 + l <= c2}
                requires{c1<> c2}
                ensures{size result <= 2* (2* l + c2) }
                ensures{ancillas result = 0}
                ensures{width result = n}
  =
  place (insert_qbits_gen (permutation_three_blocks 0 l l (2*l)) l (2*l) (c2-l)) 0 n

let lemma  swap_lists_kets_basis  (c2 l n :int) 
      requires{0< l }
      requires{0<= c2 + l <= n}
      ensures{forall a x y z. is_a_ket_l a (c2-l) -> is_a_ket_l x l -> is_a_ket_l y l -> is_a_ket_l z (n- c2-l) ->
              is_a_ket_basis_elt x ->
              is_a_ket_basis_elt y ->
              is_a_ket_basis_elt a ->
              is_a_ket_basis_elt z ->
              path_sem (swap_lists 0 c2 l n) (kronecker x (kronecker  (kronecker a y )z))
              = (kronecker y (kronecker  (kronecker a x )z)) }
  = ()

let lemma  swap_lists_kets  (c2 l n :int) 
      requires{0< l }
      requires{0<= c2 + l <= n}
      ensures{forall a x y z. is_a_ket_l a (c2-l) -> is_a_ket_l x l -> is_a_ket_l y l -> is_a_ket_l z (n- c2-l) ->
              path_sem (swap_lists 0 c2 l n) (kronecker x (kronecker  (kronecker a y )z))
              = (kronecker y (kronecker  (kronecker a x )z)) }
  = let lemma pre_x()
          ensures{forall a x y z. is_a_ket_l a (c2-l) -> is_a_ket_l x l -> is_a_ket_l y l -> is_a_ket_l z (n- c2-l) ->
                  is_a_ket_basis_elt x ->
                  path_sem (swap_lists 0 c2 l n) (kronecker x (kronecker  (kronecker a y )z))
                  = (kronecker y (kronecker  (kronecker a x )z)) }
      = let lemma pre_xy()
              ensures{forall a x y z. is_a_ket_l a (c2-l) -> is_a_ket_l x l -> is_a_ket_l y l -> is_a_ket_l z (n- c2-l) ->
                      is_a_ket_basis_elt x ->
                      is_a_ket_basis_elt y ->
                      path_sem (swap_lists 0 c2 l n) (kronecker x (kronecker  (kronecker a y )z))
                      = (kronecker y (kronecker  (kronecker a x )z)) }
          = let lemma pre_xya()
                  ensures{forall a x y z. is_a_ket_l a (c2-l) -> is_a_ket_l x l -> is_a_ket_l y l -> is_a_ket_l z (n- c2-l) ->
                          is_a_ket_basis_elt x ->
                          is_a_ket_basis_elt y ->
                          is_a_ket_basis_elt a ->
                          path_sem (swap_lists 0 c2 l n) (kronecker x (kronecker  (kronecker a y )z))
                          = (kronecker y (kronecker  (kronecker a x )z)) }
              =
              swap_lists_kets_basis c2 l n
            in pre_xya()
        in pre_xy()
    in pre_x()
         
let constant notc = cnot 1 0 2

end
