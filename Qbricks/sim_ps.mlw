
module Discrete_angles_ps
    use wired_circuits.Circuit_c

    (* use wired_circuits.Circuit_c this bad boy does NOT behave well with extract command *)
    use unit_circle.Angle
    (* use qbricks.Circuit_macros *)
    use binary_clone.Bit_vector
    use binary_clone.Bit_vector_decomp

    use ref.Ref
    use int.Int 
    use arit.Incr_abs
    use matrices.Matrix

    use int.ComputerDivision as CDiv
    use int.Abs 
    use int.EuclideanDivision

    (* use exponentiation.Int_Exponentiation *)
    use int_expo.Int_Exponentiation
    use reversion.Circuit_reverse
    (* use pairs.Pairs *)


    (* use  sim_cont_del.Cont_del *)
    use sim_cont_del.Cont_helpers



    use angle_list.Angle_list
    use  list.List 
    use  list.Mem

    lemma fir_pair:  forall i1 i2:int.  fir (i1,i2) = i1
    lemma sec_pair:  forall i1 i2:int.  sec (i1,i2) = i2

    let function pair_phase_inv (k n i : int): (int,int)
        requires{0<=n}
        (* this is practically an adapted version of the operator: function (-^) from `unit_circle.mlw` *)
    = let k_inv = (if 0 <i then
            ((power (-1) i) * k)
        else 
            ((power (-1) (-i) )* k)) in
            ( k_inv , n)
                

        (* ensures{ED.mod i 2 = 0 ->  k_inv = k} *)
        (* ensures{ED.mod i 2 = 1 -> k_inv = -k} *)
        (* ensures { (k /./n  -^ i )= k_inv /./ n} *)
        ensures { (k /./n  -^ i )= (fir result) /./ (sec result)}
        (* provable with Gen_phase_inv and   Gen_phase_inv_neg from unit circle*)


    let anglezero_list  () : angle_list
    = angle_list_pair_maker 0 1


    let rec function ang_ind_list (c:circuit) (x y : int->int ) :  angle_list
    variant{ (pre c)  }
    requires{cont_depth c = 0}
    = 
    
    match  (pre c) with
      Skip ->  anglezero_list ()
    | Phase k ->  angle_list_pair_maker  1 k
    | Rx k -> 
            let l1 = angle_list_pair_maker ( x 0 * y 0   ) 1    in
            let l2  = ((y 0 * y 1),  1) +@+ l1 in
            (pair_phase_inv 1  (incr_abs k) (y 0 -1)) +@+ l2 
        
    | Ry k -> 
            let l1 = angle_list_pair_maker (x 0 * y 0 ) 1 in
            let l2 = ((y 0 * y 1 ) , 1) +@+ l1 in
            let l3 = (pair_phase_inv 1 (incr_abs k) (y 0 -1) ) +@+ l2 in
            ((y 1 - x 0) , 2) +@+ l3
        
    | Rz k ->   angle_list_maker (pair_phase_inv 1  (incr_abs k) (x 0 -1)  )


    | Rzp k -> angle_list_pair_maker (x 0 ) k
    | Hadamard -> angle_list_pair_maker (x 0  * y 0) 1


    | S -> angle_list_pair_maker  (x 0) 2
    | T -> angle_list_pair_maker  (x 0) 3
    | Y -> angle_list_maker (pair_phase_inv 1 2 (1-x 0) )
    | Z -> angle_list_pair_maker (x 0) 1
    | X
    | Bricks_Cnot
    | Bricks_Toffoli
    | Bricks_Fredkin
    | Bricks_Swap
    | Cnot _ _ _
    | Swap _ _ _
    | Toffoli _ _ _ _
    | Fredkin _ _ _ _ -> anglezero_list ()
    | Place  c t _ -> ang_ind_list (to_qc c)   (fun j -> x (j+t))   y
    | Cont _ _ _ _  -> anglezero_list ()
    | Sequence d e ->   let l1 = ang_ind_list (to_qc d) x y  in 
                        let l2  = ang_ind_list (to_qc e)   ( basis_ket (to_qc d) x y)      (fun k -> (y (k+range (to_qc d)  )))    in
                        l1 +@@+  l2
    | Parallel d e ->  let l1 = ang_ind_list (to_qc d) x y  in 
                        let l2  = ang_ind_list (to_qc e)  (fun k -> (x (k+width (to_qc d)  )))   (fun k -> (y (k+range (to_qc d)  )))    in
                        l1 +@@+  l2
    | Ancillas d _ -> (ang_ind_list (to_qc d)  x y  ) 

    end

    
    let rec ghost function  sum_list_to_angle (l: list(int,int)) : angle
        variant { Llength.length l} 
        = 
        match l with
        | Nil      -> 0 /./ 1
        | Cons x r -> ( (fir x) /./(sec x) ) +.+ (sum_list_to_angle r) 
        end

        (* normalized Sum of the pairs of angles   *)
        let rec  function list_of_angles_sum (l: list(int,int)) (max_n:int) : int
        variant { Llength.length l} 
        ensures { (result /./  max_n) = sum_list_to_angle l   }
        = 
        match l with
        | Nil      -> 0 
        | Cons x r ->   let k = (fir x)  in 
                        let n = (sec x) in 
                        let circ = power 2 max_n in 
                        let mult = power 2 (max_n - (abs n)) in 
                        let signed_k =   if 0 <= n  then k else -k in
                        
                        let skm = (    signed_k *  mult )  in
                        (* tbc check is this conversion correct? *)
                        let non_neg_k = if 0 <= skm then  skm else circ+skm in

                        non_neg_k + (list_of_angles_sum r max_n) 
        end

    (* normalized Sum of an angle_list that contains pairs of angles combined as 1 pair   *) 
    
    (* returns the normalized k only *)
    let function  angle_list_sum_k (al: angle_list)  : int
        ensures { (result /./  al.max_sec) = sum_list_to_angle al.a_list   }
        = 
        list_of_angles_sum  al.a_list  al.max_sec


    let function  angle_list_sum (al: angle_list) : angle_list
        = 
        let n = al.max_sec in
        let k_normalized = angle_list_sum_k al in 
        let p_mod = power 2  n in
        angle_list_pair_maker (mod k_normalized p_mod ) n
        (* postcondition: any 2 elements of the output list will alway have the same sec (k1,n) and (k2,n) *)
        ensures{ forall x y: (int,int)  .  mem x result.a_list /\ mem y result.a_list -> sec x = sec y   }


    let comp (c:circuit)  :matrix (list (int,int))
        (* ensures{ (forall i:int. 0<= i < width c -> 0<= (getbv x) i < 2)}
        ensures{ (forall i:int. 0<= i < range c -> 0<= (getbv y) i < 2)}*)
        (* requires { length x >0 } *)
    =

        let w = (width c) in
        let r = (range c) in

        let xl = power 2 w in
        let yl = power 2 r in
        let out_matrix = ref (make  xl xl  Nil) in 

        for i=0 to xl-1 do 
          invariant {0 <= i < xl }
            for j=0 to (yl-1) do 
                invariant {0 <= j< yl } 

                    let bv_i =  getbv (int_to_bv i w) in  

                    let bv_j =  getbv (int_to_bv (j) r) in

                    let bk =   (basis_ket c bv_i bv_j )  in 
                    let bv_bk = makes_bv bk w in
                    let y_id  = bv_to_int bv_bk in 
                    
                    let comp = (ang_ind_list c   bv_i  bv_j  ) in 
                    let s_comp =  (angle_list_sum comp  )  in 

                    let g = get (!out_matrix ) i y_id in 
                    
                    out_matrix :=  set (!out_matrix ) i y_id  (s_comp.a_list ++ g );
            
            done;

        done;
        return !out_matrix

   


    (******  execution, rewrting and equivalence checking  part  ******)

    
    use wired_circuits.Qbricks_prim   (* for -- *)

    
                
    (* functions for sanity check and further post-processing *)

    let pair_list_merge (elem:('a,'b)) (lp: (bool, list ('a,'b) ))  : (bool, list ('a,'b) )
    = 
        let b = fir lp in 
        let l = sec lp in 
        (b, Cons elem l )
        ensures {(fir result = fir lp)}
        ensures {Llength.length ( sec result) = 1 + Llength.length (sec lp) }
    
    let rec find_and_rm (v: int)(l: list (int,int)) : (bool, list (int,int) )
        variant { Llength.length l} 
        =
        match l with
            | Nil      -> (false, l)
            | Cons x r ->  let k = (fir x)  in
                if (k = v) then (true, r)
                else  pair_list_merge  x (find_and_rm v r)
            end
        ensures {  Llength.length  (sec result ) <= Llength.length l }


    (* simplification rule 2 in the first version of internship report*)
    let  rec sum_comp (l: list (int,int)) : list (int,int)
        variant { Llength.length l} 

        =
          match l with
            | Nil      -> Nil
            | Cons x r ->  
                        let k = (fir x)  in
                        let n = (sec x)  in
                        (* let k_comp = if 0 < k  then (power 2 n) - k else -k in  wrong condition *)
                        (* also no need to check if k is negative at this point, it is already handled by list_of_angles_sum *)
    
                        let k_comp = mod (power 2 (n-1) +k) (power 2 n) in 
                        
                        let b_lo = find_and_rm k_comp r in 
                        
                        let b = fir b_lo in 
                        let lo = sec b_lo in 
                        if b then sum_comp lo
                        (* @TBF for the -99998 *)
                            else (Cons x (sum_comp lo)) 
            end
    
    
    
    (* currently calls rule 2 directly, but may be extended with other list reduction rules  *)
    let  sum_simplify_list (l: list (int,int))     : list (int,int)
    =
    sum_comp l

    (* returns -1,0,1 if undetermined, not equivalent, equivalent respectively *)
    let is_id_final_matrix ( mat : matrix (list (int,int))  ):int 
    =
        let xl =  mat.rows in
        let yl = mat.columns in
        (* let out_str = ref "\n" in  *)
        (* if found elem not on diag, set to false , if curr element on diag =/= last elem diag *)
        (* let elem_diag = ref 0 in  *)
        let elem_diag_list = ref Nil in 
        for ij=0 to xl-1 do 
            invariant {0 <= ij < xl }
            let curr =  get mat ij ij  in 
            let sl2 = sum_simplify_list curr in
            let llen = (Llength.length sl2) in  
            (* out_str := (!out_str)  ^ "   " ^ (i_to_s (ij )) ^","^(i_to_s (ij )) ^ ":["^(str_list sl2)^"]"; *)

            let case00 =  (ij = 0) &&  (ij = 0) in
            elem_diag_list:= if case00 then sl2 else (!elem_diag_list);

            (* if i = j then  *)
                    (* let cond1 = sl <> !elem_diag  in  *)
            let cond1 = (llen =0)  in
            let cond2 = not(l_isequal sl2 (!elem_diag_list)) in
            if ( cond1 || cond2  ) then  return 0
            
        done;

        (* out_str := (!out_str)  ^"\n\n\n"; *)
        
        for i=0 to xl-1 do 
            for j=0 to (yl-1) do 
                let curr =  get mat i j  in 
                let reduced_l = sum_simplify_list curr in 
                (* out_str := (!out_str)  ^"["^(str_list reduced_l)^"]"; *)
                
                let llen = (Llength.length reduced_l) in 
                
                let cond2 = llen <> 0 in
                if ((i<>j) &&  cond2) then 
                    return -1
            done;
            (* out_str := (!out_str) ^ "\n"; *)
        done;
        (* out_str := (!out_str) ^ "" ^ "multiplied by 1/sqrt(" ^ (i_to_s (power 2 (range c)) )^ ") \n"; *)
        return 1


    (* returns -1,0,1 if undetermined, not equivalent, equivalent respectively *)
    let function is_circ_equiv (c1 c2 :circuit): int
        (* requires{cont_depth c1 = 0}
        requires{cont_depth c2 = 0} *)

        =  
            if width c1 <> width c2 then 0 
            else
                let r = reverse c2 in 
                let cr =  c1--r in 
                let circ =  zero_cont (cr) in 
                let mat = comp circ  in 
                is_id_final_matrix mat

        use circuits_equiv.Circuit_equivalence_impl
        lemma  simulatated_equiv:forall c1 c2 : circuit. is_circ_equiv c1 c2 = 1 -> c1 <=> c2

    
end