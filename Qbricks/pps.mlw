(**************************************************************************)
(*  This file is part of QBRICKS.                                         *)
(*                                                                        *)
(*  Copyright (C) 2020-2022                                               *)
(*    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*    Université Paris-Saclay                                             *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

module Pps

         use binary.Bit_vector
         use unit_circle.Angle
         use matrices.Matrix
         use matrices.Matrix_scalar
         use complex.Complex
         use qdata.Bv_to_ket
         use binary.Bit_vector_decomp
         use qdata.Ket_basis
         use qdata.Qreg
         use int.Int
         use complex_expo.Complex_exp
         use qdata.Sqrt_two
         use int_expo.Int_Exponentiation
         use complex_operations.Indic
         use complex_operations.Base_type
         use  int.EuclideanDivision
         use p_set.IndexestoSet
         use  functions.MapInjection
         use binary.Binary_Op
         use binary.Int_to_bv
     
type pps =
  {h_width: int;
   h_range: int;
   h_basis_ket: (int-> int) -> (int-> int) -> (int-> int);
   h_angle: (int-> int) -> (int-> int) -> angle}
    invariant{0<=h_width}
    invariant{0<= h_range}
    invariant{forall x y: int->int. (forall i:int. 0<= i < h_width -> 0<= x i < 2) ->
                          (forall i:int. 0<= i < h_range -> 0<= y i < 2) ->
                          forall i:int. 0<= i < h_width -> 0<= h_basis_ket x y i <2}
    invariant{ forall x x' y y' : int->int.  (forall i:int. 0<= i < h_width -> x i = x' i) -> 
                                  (forall i:int. 0<= i < h_range -> y i = y' i) -> forall  i:int. 0<= i < h_width ->
                                                                                             h_basis_ket x y i = h_basis_ket x' y' i } 
    invariant{ forall x x' y y' : int->int.  (forall i:int. 0<= i < h_width -> x i = x' i) -> 
                                  (forall i:int. 0<= i < h_range -> y i = y' i)  ->
                                  h_angle x y  = h_angle x' y' } 
    by {h_width =0;h_range =0; h_basis_ket = (fun _ _ _ -> 0); h_angle = (fun _ _  -> ang_zero)}

let function inv_func_int (f: int -> int) (n :  int) 
               requires{p_bijective f (to_fset 0 n) (to_fset 0 n)}
               ensures{p_bijective result (to_fset 0 n) (to_fset 0 n)}
               ensures{forall a. 0<= a <n -> 0<= result a <n}
               ensures{forall a. 0<= a <n -> f (result  a) = a}
               ensures{forall a. 0<= a <n -> result (f  a) = a}
               ensures{forall a b. 0<= a < n -> 0<= b < n -> f a = b -> result b = a}
  = inverse f  (to_fset 0 n) (to_fset 0 n)

let lemma binary_h_basis_ket (p: pps) (w:int) (x y :int->int)
      requires{w = h_width p}
      requires{binary_l x w}
      requires{binary_l y (h_range p)}
      ensures{binary_l (h_basis_ket p x y) w}
  =()
  
let function swap_int ( t1 t2 n :  int)
               requires{0<=t1<n}
               requires{0<=t2<n}
               ensures{forall a. a = t1  ->  result a = t2}
               ensures{forall a. a = t2  ->  result a = t1}
               ensures{forall a. a <> t1 -> a <> t2 -> result a = a}
               ensures{p_bijective result (to_fset 0 n) (to_fset 0 n)}
               ensures{forall i. 0<= i < n ->inv_func_int result n i = result i}
  =  fun i -> if i = t1 then t2 else if i = t2 then t1 else i

let function build_pps (w r:int) (k : (int-> int) -> (int-> int) -> (int-> int)) (a:(int-> int) -> (int-> int) -> angle)
               requires{0<= w}
               requires{0<= r}
               requires{forall x y: int->int. (forall i:int. 0<= i < w -> 0<= x i < 2) ->
                                    (forall i:int. 0<= i < r -> 0<= y i < 2) ->
                                    forall i:int. 0<= i < w -> 0<= k x y i <2}
               requires{ forall x x' y y' : int->int.  (forall i:int. 0<= i < w -> x i = x' i) -> 
                                            (forall i:int. 0<= i < r -> y i = y' i) -> forall  i:int. 0<= i < w ->
                                                                                                 k x y i = k x' y' i } 
               requires{ forall x x' y y' : int->int.  (forall i:int. 0<= i < w -> x i = x' i) -> 
                                            (forall i:int. 0<= i < r -> y i = y' i)  ->
                                            a x y  = a x' y' } 
               ensures{h_width result = w}
               ensures{h_range result = r}
               ensures{forall x y:bitvec. forall i:int. length x = w -> length y = r -> 0<= i < w ->
                                                   h_basis_ket result (getbv x) (getbv y) i = mod (k (getbv x) (getbv y) i) 2}
               ensures{forall x y:bitvec. length x = w -> length y = r ->
                                  h_angle result (getbv x) (getbv y)  = a (getbv x) (getbv y)}
  = {h_width =w;h_range =r; h_basis_ket = (fun x y i ->   mod (k (fun i -> if 0<= i < w then x i else 0)
                                                                 (fun i -> if 0<= i < r then y i else 0) i) 2);
     h_angle = (fun x y -> a (fun i -> if 0<= i < w then x i else 0)
                             (fun i -> if 0<= i < r then y i else 0))}

let function build_pps_bv  (w r:int) (k: bitvec -> bitvec ->  bitvec) (a: bitvec -> bitvec -> angle):pps
                                                                                                       requires{0<= w}
                                                                                                       requires{0<= r}
                                                                                                       requires{forall x y. length x = w -> length y = r -> length (k x y) = w}
                                                                                                       ensures{h_width result = w}
                                                                                                       ensures{h_range result = r}
                                                                                                       ensures{forall x y:bitvec. forall i:int. length x = w -> length y = r -> 0<= i < w ->
                                                                                                                                           h_basis_ket result (getbv x) (getbv y) i = getbv (k x y) i }
                                                                                                       ensures{forall x y:bitvec. length x = w -> length y = r ->
                                                                                                                          h_angle result (getbv x) (getbv y)  = a x y}
  =  (build_pps w r (fun x y -> getbv (k (make_bv (fun i -> mod (x i) 2) w) (make_bv (fun i -> mod (y i) 2) r)))
        (fun x y -> a (make_bv (fun i -> mod (x i) 2) w) (make_bv (fun i -> mod (y i) 2) r)))
   
let function h_basis_ket_bv (h:pps) (x y: bitvec): bitvec
                                                     requires{length x = h_width h}
                                                     requires{length y = h_range h}
                                                     ensures{length result = h_width h}
                                                     ensures{forall i. 0 <= i < h_width h -> getbv result i = h_basis_ket h (getbv x) (getbv y) i}
  = make_bv (fun k -> h_basis_ket h (getbv x) (getbv y) k) (h_width h)
  
let function h_angle_bv (h:pps) (x y: bitvec): angle
                                                 requires{length x = h_width h}
                                                 requires{length y = h_range h}
  = h_angle h (getbv x) (getbv y) 
  
let lemma pps_ket_bound (h:pps)(x y: int -> int) (i:int)
      requires{0<= i < h_width h}
      requires{forall i:int. 0<= i < h_width h -> 0<= x i < 2}
      requires{forall i:int. 0<= i < h_range h -> 0<= y i < 2}
      ensures{0<= h_basis_ket h x y i <2}
  =()
  
let lemma low_pps_ket_bound (h:pps)(x y: int -> int) (i:int)
      requires{0<= i < h_width h}
      requires{forall i:int. 0<= i < h_width h -> 0<= x i < 2}
      requires{forall i:int. 0<= i < h_range h -> 0<= y i < 2}
      ensures{0<= h_basis_ket h x y i}
  =()
  
let lemma high_pps_ket_bound (h:pps)(x y: int -> int) (i:int)
      requires{0<= i < h_width h}
      requires{forall i:int. 0<= i < h_width h -> 0<= x i < 2}
      requires{forall i:int. 0<= i < h_range h -> 0<= y i < 2}
      ensures{h_basis_ket h x y i <2}
  =()
  
let function pps_apply_basis (h:pps)(x : bitvec):matrix complex
                                                   requires{length x = h_width h}
                                                   ensures{is_a_ket_l result (h_width h)}
                                                   ensures{forall i:int. 0<= i < power 2 (h_width h) -> get_ket result i = pow_inv_sqrt_2 (h_range h) *. sum (n_bvs (h_range h)) (fun y -> ang_exp ( h_angle h (getbv x) (getbv y))
                                                                                                                                                                                           *. indic (bv_to_int (make_bv ( h_basis_ket h (getbv x) (getbv y) )(h_width h)) ) i) }
  = pow_inv_sqrt_2 (h_range h) *.. ket_sum_l (n_bvs (h_range h)) (fun y -> ang_exp ( h_angle h (getbv x) (getbv y)) *.. bv_to_ket ((make_bv ( h_basis_ket h (getbv x) (getbv y) )) (h_width h))) (h_width h)

use qdata.Kronecker_Qbit

let lemma pps_apply_basis_decomp  (h:pps)(x : bitvec)
      requires{length x = h_width h}
      ensures{pps_apply_basis h x = ket_sum_l (n_bvs (h_width h)) (fun z -> pow_inv_sqrt_2 (h_range h) *. sum (n_bvs (h_range h)) (fun y -> ang_exp ( h_angle h (getbv x) (getbv y))
                                                                                                                                            *. indic ( h_basis_ket_bv h x y ) z)
                                                                            *.. ket (h_width h) (bv_to_int z)) (h_width h)}
  =()
  
let lemma pps_apply_basis_ket_l (h:pps)(x : bitvec) (l:int)
      requires{length x = l}
      requires{l = h_width h}
      ensures{is_a_ket_l (pps_apply_basis h x) l}
  = ()
  
let lemma pps_apply_basis_ket_length (h:pps)(x : bitvec) (l:int)
      requires{length x = l}
      requires{l = h_width h}
      ensures{ket_length (pps_apply_basis h x) =  l}
  = ()
  
let lemma pps_apply_basis_bv (h:pps)(x : bitvec)
      requires{length x = h_width h}
      ensures{pps_apply_basis h x = pow_inv_sqrt_2 (h_range h) *.. ket_sum_l (n_bvs (h_range h)) (fun y -> ang_exp ( h_angle_bv h x y) *.. bv_to_ket  ( h_basis_ket_bv h x y)) (h_width h)}
  =()

let lemma pps_apply_basis_value (h:pps)(x : bitvec)
      requires{length x = h_width h}
      ensures{forall i:int. 0<= i < power 2 (h_width h) -> get_ket (pps_apply_basis h x) i = pow_inv_sqrt_2 (h_range h) *.
                                                                                               sum (n_bvs (h_range h)) (fun y -> ang_exp ( h_angle_bv h x y)
                                                                                                                                 *. indic ( h_basis_ket_bv h x y) (int_to_bv i (h_width h))) }
  = ()

      use p_set.Choose_filter

let lemma pps_apply_basis_value_filter  (h:pps)(x : bitvec) (k:int)
      requires{length x = h_width h}
      requires{0<= k < power 2 (h_width h)}
      ensures{get_ket (pps_apply_basis h x) k  =   pow_inv_sqrt_2 (h_range h)*. sum (my_filter (n_bvs (h_range h)) (fun y -> h_basis_ket_bv h x y = int_to_bv k (h_width h)))
                                                                                  (fun y -> ang_exp ( h_angle h (getbv x) (getbv y)))}
  =()

let lemma pps_apply_basis_value_filter_gen  (h:pps)(x : bitvec) 
      requires{length x = h_width h}
      ensures{forall k. 0<= k < power 2 (h_width h) ->
              get_ket (pps_apply_basis h x) k  =   pow_inv_sqrt_2 (h_range h)*. sum (my_filter (n_bvs (h_range h)) (fun y -> h_basis_ket_bv h x y = int_to_bv k (h_width h)))
                                                                                  (fun y -> ang_exp ( h_angle h (getbv x) (getbv y)))}
  =()

     use binary.Bv_concat
     use qdata.Bv_mat_sum
  
let lemma pps_apply_basis_ht  (h:pps)(x : bitvec) (s:int)
      requires{length x = h_width h}
      requires{1<= s<=  h_width h}
      ensures{pps_apply_basis h x  =     ket_sum_l (n_bvs s) (fun z ->
                                             ket_sum_l (n_bvs (h_width h-s)) (fun t ->
                                                 get_ket (pps_apply_basis h x) (bv_to_int (concat z t)) *.. bv_to_ket(concat z t))(h_width h))(h_width h)}
  =pps_apply_basis_decomp h x;
   ket_sum_bin_comp (fun z t -> get_ket (pps_apply_basis h x) (bv_to_int (concat z t)) *.. bv_to_ket(concat z t)) (h_width h)  (h_width h -s) s
   
let function pps_apply (h:pps)(x : matrix complex):matrix complex
                                                     requires{is_a_ket_l x (h_width h)}
                                                     ensures{is_a_ket_l result (h_width h)}
  =  ket_sum_l (n_bvs (h_width h)) (fun y -> if length y = h_width h then  get_ket x (bv_to_int y) *..  pps_apply_basis h y else x) (h_width h)

let lemma get_pps_apply (h:pps)(x : matrix complex)
      requires{is_a_ket_l x (h_width h)}
      ensures{pps_apply h x =   ket_sum_l (n_bvs (h_width h)) (fun y ->   get_ket x (bv_to_int y) *..  pps_apply_basis h y ) (h_width h)}
  =()

let lemma rewrite_pps_apply_basis (h:pps)(x : matrix complex)
      requires{is_a_ket_l x (h_width h)}
      requires{is_a_ket_basis_elt x}
      ensures{pps_apply h x = pps_apply_basis h (ket_to_bv x)}
  =  ()

let lemma rewrite_pps_apply_basis_ (h:pps)(x : matrix complex)
      requires{is_a_ket_l x (h_width h)}
      requires{is_a_ket_basis_elt x}
      ensures{pps_apply h x =
                pow_inv_sqrt_2 (h_range h) *..
                  ket_sum_l (n_bvs (h_range h))
                    (fun y -> ang_exp ( h_angle h (getbv (ket_to_bv x)) (getbv y)) *..
                                bv_to_ket ((make_bv ( h_basis_ket h (getbv (ket_to_bv x)) (getbv y) )) (h_width h)))
                    (h_width h)}
  =  rewrite_pps_apply_basis h x

let lemma rewrite_pps_apply_basis_rev (h:pps)(x : bitvec)
      requires{length x =  (h_width h)}
      ensures{pps_apply_basis h x =pps_apply h (bv_to_ket x)}
  =  ()

let lemma pps_apply_decomp (h:pps) (x:matrix complex)
      requires{is_a_ket_l x  (h_width h)}
      ensures{pps_apply h x =  ket_sum_l (n_bvs (h_width h)) (fun z -> get_ket x (bv_to_int z)
                                                                       *.. pps_apply h  (bv_to_ket z)) (h_width h)}
  =()
  
let lemma pps_apply_scal (h:pps) (x:matrix complex) (a:complex)
      requires{is_a_ket_l x  (h_width h)}
      ensures{pps_apply h (a*..x) = a*.. pps_apply h x}
  =()
  
let lemma pps_apply_add (h:pps) (x y:matrix complex) (l:int)
      requires{is_a_ket_l x  (h_width h)}
      requires{is_a_ket_l y  (h_width h)}
      requires{l = h_width h}
      ensures{pps_apply h (add_ket_l x y l) = add_ket_l (pps_apply h x) (pps_apply h y) l}
  =()

     use  p_set.Fset_comp
  
let rec lemma pps_apply_sum (h:pps) (s: set 'a) (f :'a -> matrix complex) (l:int)
          requires{1<= cardinal s}
          requires{forall e. mem e s -> is_a_ket_l (f e)  (h_width h)}
          requires{l = h_width h}
          ensures{pps_apply h (ket_sum_l s f l) = ket_sum_l s (fun e -> pps_apply h (f e) ) l }
          variant{cardinal s}
  = if cardinal s = 1 then ()
    else
      begin
        assert{2<= cardinal s};
        ket_sum_l_plus_one (remove (choose s) s) (choose s) f l;
        pps_apply_sum h (remove (choose s) s) f  l;
      end

let constant pps_id  : pps
  ={h_width  = 1;
    h_range   = 0;
    h_basis_ket = (fun x _ i -> x i);
    h_angle  = (fun _ _  ->  ang_zero)}
     ensures{h_width result  = 1}
     ensures{h_range result  = 0}
     ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = x i}
     ensures{forall x y: int-> int.  h_angle result x y  = ang_zero}

let function pps_swap (t1 t2 n:int) : pps
                                        requires{0<= t1<n}
                                        requires{0<= t2<n}
                                        requires{t1<>t2}
  ={h_width  = n;
    h_range   = 0;
    h_basis_ket = (fun x _ i -> x (swap_int t1 t2 n i));
    h_angle  = (fun _ _  ->  ang_zero)}
     ensures{h_width result  = n}
     ensures{h_range result  = 0}
     ensures{forall x y: int-> int.  forall i:int. h_basis_ket result x y i = x  (swap_int t1 t2 n i)}
     ensures{forall x y: int-> int.  h_angle result x y  = ang_zero}
  
let function pps_phase (k:int) : pps
                                   ensures{h_width result  = 1}
                                   ensures{h_range result  = 0}
                                   ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = x i}
                                   ensures{forall x y: int-> int.  h_angle result x y  = 1 /./ k}
  ={h_width  = 1;
    h_range   = 0;
    h_basis_ket = (fun x _ i ->  x  i);
    h_angle  = (fun _ _  ->  1 /./ k)}

let function pps_rz (k:int) : pps
                                ensures{h_width result  = 1}
                                ensures{h_range result  = 0}
                                ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = x i}
                                ensures{forall x y: int-> int.  h_angle result x y  =  x 0  /./ k  }
  ={h_width  = 1;
    h_range   = 0;
    h_basis_ket = (fun x _ i ->  x  i);
    h_angle  = (fun x _  ->   x 0 /./k)}

     use arit.Incr_abs
  
let function pps_rx (k:int) : pps
                                ensures{h_width result  = 1}
                                ensures{h_range result  = 2}
                                ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = y 1}
                                ensures{forall x y: int-> int.  h_angle result x y  =
                                                            (x 0 * y 0 /./1) +.+  (y 0 * y 1 /./1) +.+ ((1 /./incr_abs k)-^ (y 0 -1)  )}
  ={h_width  = 1;
    h_range   = 2;
    h_basis_ket = (fun _ y _ ->  y 1);
    h_angle  = (fun x y  ->  (x 0 * y 0 /./1) +.+  (y 0 * y 1 /./1) +.+ ((1 /./ (incr_abs k)) -^ (y 0 -1)))}

let constant pps_xx  : pps
  ={h_width  = 1;
    h_range   = 0;
    h_basis_ket = (fun x _ i -> 1- x  i);
    h_angle  = (fun _ _  -> 1 /./ 0)}
     ensures{h_width result  = 1}
     ensures{h_range result  = 0}
     ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = 1- x i}
     ensures{forall x y: int-> int.  h_angle result x y  = 1 /./ 0   }

let constant pps_yy  : pps
  ={h_width  = 1;
    h_range   = 0;
    h_basis_ket = (fun x _ i -> 1- x  i);
    h_angle  = (fun x _ -> (1/./2) -^(x 0))}
     ensures{h_width result  = 1}
     ensures{h_range result  = 0}
     ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = 1- x i}
     ensures{forall x y: int-> int.  h_angle result x y  =  (1/./2) -^(x 0)  }

let constant pps_zz  : pps
  ={h_width  = 1;
    h_range   = 0;
    h_basis_ket = (fun x _ i ->  x  i);
    h_angle  = (fun x _  ->  x 0 /./1)}
     ensures{h_width result  = 1}
     ensures{h_range result  = 0}
     ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = x i}
     ensures{forall x y: int-> int.  h_angle result x y  = x 0 /./1  }
  
let function pps_ry (k:int) : pps
                                ensures{h_width result  = 1}
                                ensures{h_range result  = 2}
                                ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = y 1}
                                ensures{forall x y: int-> int.  h_angle result x y  = (x 0 * y 0 /./1) +.+  (y 0 * y 1 /./1) +.+ ((1 /./ (incr_abs k)) -^ (y 0 -1)) +.+ ((y 1 - x 0) /./2)}
  ={h_width  = 1;
    h_range   = 2;
    h_basis_ket = (fun _ y _  ->  y 1);
    h_angle  = (fun x y -> (x 0 * y 0 /./1) +.+  (y 0 * y 1 /./1) +.+ ((1 /./ (incr_abs k)) -^ (y 0 -1)) +.+ ((y 1 - x 0) /./2))}

let function pps_rz_b (k:int) : pps
                                  ensures{h_width result  = 1}
                                  ensures{h_range result  = 0}
                                  ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = x i}
                                  ensures{forall x y: int-> int.  h_angle result x y  =   1 /./ (incr_abs k) -^ (x 0 -1)  }
  ={h_width  = 1;
    h_range   = 0;
    h_basis_ket = (fun x _ i  ->  x i);
    h_angle  =  (fun x _  ->   1 /./ (incr_abs k) -^ (x 0 -1) )}
  
let function pps_hadamard  : pps
  ={h_width  = 1;
    h_range   = 1;
    h_basis_ket = (fun _ y i -> y  i);
    h_angle  = (fun x y  ->  (x 0 *y 0) /./1 )}
     ensures{h_width result  = 1}
     ensures{h_range result  = 1}
     ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = y i}
     ensures{forall x y: int-> int.  h_angle result x y  = (x 0 *y 0) /./1 }

     use  int.EuclideanDivision
  
let function pps_cnot (c t n :int) : pps
                                       requires{0<= c<n}
                                       requires{0<= t<n}
                                       requires{t<>c}
  ={h_width  = n;
    h_range   = 0;
    h_basis_ket = (fun x _ i ->  if i = t then x c *  (1 - x t) + ((1- x c) * x t) else x i );
    h_angle  = (fun _ _  ->   1/./0)}
     ensures{h_width result  = n}
     ensures{h_range result  = 0}
     ensures{forall x y : int->int. forall i: int. i<> t -> h_basis_ket result x y i = x i}
     ensures{forall x y : int->int.forall i: int. i= t -> h_basis_ket result x y i = x c *  (1 - x t) + ((1- x c) * x t)}
     ensures{forall x y: int-> int.  h_angle result x y  =  1/./0}

use p_int.Int_comp
  
let function pps_toffoli (c1 c2 t n :int) : pps
                                              requires{0<= c1<n}
                                              requires{0<= c2<n}
                                              requires{0<= t<n}
                                              requires{t<>c1}
                                              requires{t<>c2}
                                              requires{c2<>c1}
  ={h_width  = n;
    h_range   = 0;
    h_basis_ket = (fun x _ i ->  if i = t  then x c1 * x c2 *  (1 - x t)  + x t * (1- x c1 * x c2 ) else x i );
    h_angle  = (fun _ _  ->   1/./0)}
     ensures{h_width result  = n}
     ensures{h_range result  = 0}
     ensures{forall x y : int->int. forall i: int. i<> t -> h_basis_ket result x y i = x i}
     ensures{forall x y : int->int.forall i: int. i= t ->h_basis_ket result x y i = x c1 * x c2 * (1-x i) + x t * (1- x c1 * x c2 )}
     ensures{forall x y: int-> int.  h_angle result x y  =  1/./0}

let function pps_fredkin (c t1 t2  n :int) : pps
                                               requires{0<= t1<n}
                                               requires{0<= t2<n}
                                               requires{0<= c<n}
                                               requires{c<>t1}
                                               requires{c<>t2}
                                               requires{t2<>t1}
  ={h_width  = n;
    h_range   = 0;
    h_basis_ket = (fun x _ i -> if i = t1 then x c * x t2 + (1- x c) * x t1
                                else if i = t2 then x c * x t1 + (1- x c) * x t2
                                else x i);
    h_angle  = (fun _ _  ->   1/./0)}
     ensures{h_width result  = n}
     ensures{h_range result  = 0}
     ensures{forall x y : int->int. forall i: int. i = t1 -> 
                                              h_basis_ket result x y i = x c * x t2 + (1- x c) * x t1}
     ensures{forall x y : int->int. forall i: int. i = t2 -> 
                                              h_basis_ket result x y i = x c * x t1 + (1- x c) * x t2}
     ensures{forall x y : int->int. forall i: int. i <> t1 -> i <> t2 -> 
                                              h_basis_ket result x y i = x i}
     ensures{forall x y: int-> int.  h_angle result x y  =  1/./0}
  
let lemma pps_id_apply_basis (x:bitvec)
      requires{length x = 1}
      ensures{pps_apply_basis (pps_id) x = bv_to_ket x}
  =()

let lemma pps_swap_apply_basis (x:bitvec)
      requires{length x = 2}
      ensures{pps_apply_basis (pps_swap 0 1 2) x = ket 2 (
                                                       if bv_to_int x = 0 then  0 else
                                                         if bv_to_int x = 1 then  2 else
                                                           if bv_to_int x = 2 then  1 else 3)}
  =
  assert{getbv x 0 = if 0<= bv_to_int x  < 2 then  0 else 1};
  assert{getbv x 1 =  mod (bv_to_int x) 2}
  
let lemma pps_cnot_apply_basis (x:bitvec)
      requires{length x = 2}
      ensures{pps_apply_basis (pps_cnot 0 1 2) x = ket 2 (
                                                       if bv_to_int x = 0 then  0 else
                                                         if bv_to_int x = 1 then  1 else
                                                           if bv_to_int x = 2 then  3 else 2)}
  =   assert{getbv x 0 = if 0<= bv_to_int x  < 2 then  0 else 1};
      assert{getbv x 1 =  mod (bv_to_int x) 2}
      
let lemma pps_phase_apply_basis (k:int)(x:bitvec)
      requires{length x = 1}
      ensures{pps_apply_basis (pps_phase k) x =   ang_exp ( 1 /./ k) *.. bv_to_ket x}
  =()
  
let lemma pps_rz_apply_basis (k:int)(x:bitvec)
      requires{length x = 1}
      ensures{pps_apply_basis (pps_rz k) x = ang_exp (getbv x 0 /./ k) *.. bv_to_ket x}
  =()

let lemma pps_hadamard_apply_basis (x:bitvec)
      requires{length x = 1}
      ensures{pps_apply_basis (pps_hadamard) x = pow_inv_sqrt_2 1 *..    add_ket_l (ket 1 0) (ang_exp((getbv x 0) /./1 ) *.. (ket 1 1)) 1}
  =()
  
let function pps_seq (h1 h2:pps)
               requires{h_width h1 = h_width h2}
               ensures{h_width result  = h_width h1}
               ensures{h_range result  = h_range h1 + h_range h2}
               ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = h_basis_ket h2 (h_basis_ket h1 x y) (fun k -> y (k + h_range h1)) i}
               ensures{forall x y: int-> int.  h_angle result x y  =  (h_angle h1 x y) +.+ (h_angle h2 (h_basis_ket h1 x y) (fun k -> y (k + h_range h1)))}
  = {h_width  = h_width h1;
     h_range   = h_range h1 + h_range h2;
     h_basis_ket = (fun x y i -> h_basis_ket h2 (h_basis_ket h1 x y) (fun k -> y (k + h_range h1)) i);
     h_angle  = (fun x y  ->   (h_angle h1 x y) +.+ (h_angle h2 (h_basis_ket h1 x y) (fun k -> y (k + h_range h1))))}

let function pps_place (h :pps) (t n:int)
               requires{0<= t}
               requires{t+ h_width h <= n}
               ensures{h_width result  = n}
               ensures{h_range result  = h_range h}
               ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i = if t<= i < t + h_width h then h_basis_ket h (fun j -> x (j+t)) y (i-t)
                                                                                       else x i}
               ensures{forall x y: int-> int.  h_angle result x y  =  h_angle h (fun j -> x (j+t)) y}
  = {h_width   = n;
     h_range   = h_range h;
     h_basis_ket  = (fun x y i -> if t<= i < t + h_width h then h_basis_ket h (fun j -> x (j+t)) y (i-t)
                                  else x i);
     h_angle   = fun x y ->   h_angle h (fun j -> x (j+t)) y}

      use unit_circle.Real_to_complex_trig
  
let function pps_cont (h :pps) (co t n:int)
               requires{0<= t<= n - h_width h}
               requires{0<= co <n}
               requires{t<=co ->   t + h_width h  <= co}
               ensures{h_width result  = n}
               ensures{h_range result  = h_range h}
               ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i =  if x co = 1 && t<= i < t + h_width h then h_basis_ket h (fun j -> x (j+t)) y (i-t)
                                                                                        else x i}
               ensures{forall x y: int-> int.  h_angle result x y  = x co *.*  h_angle h (fun j -> x (j+t)) y
                                                                     +.+ ((1- x co)*.*  ((arc_cos_ang (pow_inv_sqrt_2 (h_range h))) -^ (y 0)))}
  = {h_width   = n;
     h_range   = h_range h;
     h_basis_ket  = (fun x y i -> if x co = 1 && t<= i < t + h_width h then h_basis_ket h (fun j -> x (j+t)) y (i-t)
                                  else x i);
     h_angle   = fun x y ->  x co *.*  h_angle h (fun j -> x (j+t)) y
                             +.+ ((1- x co)*.*  ((arc_cos_ang (pow_inv_sqrt_2 (h_range h))) -^ (y 0)))}

let lemma pps_apply_cont (h :pps) (co t n:int)
      requires{0<= t<= n - h_width h}
      requires{0<= co <n}
      requires{t<=co ->   t + h_width h  <= co}
      ensures{forall bv . length bv = n -> getbv bv co  = 0 -> pps_apply_basis (pps_cont h co t n)  bv = (bv_to_ket bv)}
      ensures{forall bv. length bv = n  -> getbv bv co  = 1 -> pps_apply_basis (pps_cont h co t n)   bv = pps_apply_basis (pps_place h  t n)   bv}
  = ()

      use binary.Bv_concat
  
let lemma h_basis_ket_bv_seq (h1 h2:pps) (x y:bitvec)
      requires{h_width h1 = h_width h2}
      requires{length x = h_width h1}
      requires{length y = h_range h1 + h_range h2}
      ensures{h_basis_ket_bv (pps_seq h1 h2) x y = h_basis_ket_bv h2 (h_basis_ket_bv h1 x (hpart y (h_range h1))) (tpart y (h_range h1))}
  =()

let lemma h_angle_bv_seq (h1 h2:pps) (x y:bitvec)
      requires{h_width h1 = h_width h2}
      requires{length x = h_width h1}
      requires{length y = h_range h1 + h_range h2}
      ensures{h_angle_bv (pps_seq h1 h2) x y =  (h_angle_bv h1 x (hpart y (h_range h1))) +.+ (h_angle_bv h2 (h_basis_ket_bv h1 x (hpart y (h_range h1))) (tpart y (h_range h1)))}
  =()
  
let function pps_par (h1 h2:pps)
               ensures{h_width result  = h_width h1 + h_width h2}
               ensures{h_range result  = h_range h1 + h_range h2}
               ensures{forall x y: int-> int. forall i:int. h_basis_ket result x y i =
                                                         if i < h_width h1 then h_basis_ket h1 x y i
                                                         else h_basis_ket h2 (fun k -> x (k+ h_width h1)) (fun k -> y (k+ h_range h1))  (i - h_width h1)}
               ensures{forall x y: int-> int.  h_angle result x y  =  (h_angle h1 x y) +.+ (h_angle h2 (fun k -> x (k+ h_width h1)) (fun k -> y (k + h_range h1)))}
  = {h_width  = h_width h1+ h_width h2;
     h_range   = h_range h1 + h_range h2;
     h_basis_ket = (fun x y i -> if i < h_width h1 then h_basis_ket h1 x y i
                                 else h_basis_ket h2 (fun k -> x (k+ h_width h1)) (fun k -> y (k+ h_range h1))  (i - h_width h1));
     h_angle  = (fun x y  ->   (h_angle h1 x y) +.+ (h_angle h2 (fun k -> x (k+ h_width h1)) (fun k -> y (k + h_range h1))))}

let lemma h_basis_ket_bv_par (h1 h2:pps) (x y:bitvec)
      requires{length x = h_width h1 + h_width h2}
      requires{length y = h_range h1 + h_range h2}
      ensures{h_basis_ket_bv (pps_par h1 h2) x y = concat (h_basis_ket_bv h1   (hpart x (h_width h1)) (hpart y (h_range h1)))
                                                     (h_basis_ket_bv h2   (tpart x (h_width h1)) (tpart y (h_range h1)))}
  =()

let lemma h_angle_bv_par (h1 h2:pps) (x y:bitvec)
      requires{length x = h_width h1 + h_width h2}
      requires{length y = h_range h1 + h_range h2}
      ensures{h_angle_bv (pps_par h1 h2) x y =  (h_angle_bv h1 (hpart x (h_width h1))  (hpart y (h_range h1))) +.+ (h_angle_bv h2 (tpart x (h_width h1))  (tpart y (h_range h1)) )}
  =()

     use matrices.Kronecker_product
  
let lemma kron_to_ket_l (x:matrix complex) (l:int)
      requires{0<=l}
      requires{is_a_ket_l (kronecker x (ket 1 0)) (l+1)}
      ensures{is_a_ket_l x l}
  =
  assert{columns (kronecker x (ket 1 0)) = 1};
  assert{rows (kronecker x (ket 1 0)) = power 2 (l+1)};
  kronecker_columns x (ket 1 0);
  kronecker_rows x (ket 1 0);
  set_is_a_ket_l x l
  
let function pps_ancs (h1 :pps) (i:int)
               requires{1<=i}
               requires{i<= h_width h1 }
               ensures{h_width result  = h_width h1 - i}
               ensures{h_range result  = h_range h1 }
               ensures{forall x y: int-> int. forall ii:int. h_basis_ket result x y ii =
                                                          h_basis_ket h1 (fun k -> if k < h_width h1 -i then x k else 0) y ii}
               ensures{forall x y: int-> int.  h_angle result x y  = h_angle h1 (fun k -> if k < h_width h1 -i then x k else 0) y}
  = {h_width  = h_width h1 -i;
     h_range   = h_range h1 ;
     h_basis_ket = (fun x y ii -> h_basis_ket h1 (fun k -> if k < h_width h1 -i then x k else 0) y ii);
     h_angle  = (fun x y  ->  h_angle h1 (fun k -> if k < h_width h1 -i then x k else 0) y)}

let lemma h_basis_ket_bv_anc (h :pps) (x y:bitvec) (i:int)
      requires{1<=i}
      requires{i<= h_width h }
      requires{length x = h_width h -i}
      requires{length y = h_range h}
      ensures{h_basis_ket_bv (pps_ancs h i) x y = hpart (h_basis_ket_bv h (concat x (int_to_bv 0 i)) y) (h_width h -i)}
  =()

let lemma h_basis_ket_bv_anc_ (h :pps) (x y:bitvec)(l:int) (i:int)
      requires{1<=i}
      requires{i<= h_width h }
      requires{tpart x l = int_to_bv 0 i}
      requires{length x = h_width h}
      requires{l = h_width h -i}
      requires{length y = h_range h}
      ensures{h_basis_ket_bv (pps_ancs h i) (hpart x l) y = hpart (h_basis_ket_bv h x y) (h_width h -i)}
  =()

let lemma h_angle_bv_anc (h :pps) (x y:bitvec) (i:int)
      requires{1<=i}
      requires{i<= h_width h }
      requires{length x = h_width h -i}
      requires{length y = h_range h}
      ensures{h_angle_bv (pps_ancs h i) x y = h_angle_bv h (concat x (int_to_bv 0 i)) y}
  =()

let lemma h_angle_bv_anc_ (h :pps) (x y:bitvec) (l:int) (i:int)
      requires{1<=i}
      requires{i<= h_width h }
      requires{tpart x l = int_to_bv 0 i}
      requires{length x = h_width h }
      requires{l = h_width h -i}
      requires{length y = h_range h}
      ensures{h_angle_bv (pps_ancs h i) (hpart x l) y = h_angle_bv h x y}
  =()
     
     use qdata.Kronecker_Qbit
     use qdata.Bv_mat_sum
     use matrices.Kronecker_product
     use kronecker_comm.Kronecker_comm
     use kronecker_comm.Kronecker_distr  

     predicate pps_apply_equiv (h1 h2:pps)
   = h_width h1 = h_width h2 &&
     forall x: matrix complex. is_a_ket_l x (h_width h1) ->
               pps_apply h1 x = pps_apply h2 x 

let lemma set_pps_apply_equiv (h1 h2:pps)
      requires{h_width h1 = h_width h2}
      requires{forall x: bitvec. length x =  h_width h1 ->
                         pps_apply_basis h1 x = pps_apply_basis h2 x}
      ensures{pps_apply_equiv h1 h2}
  =()

let lemma set_pps_apply_equiv_sim (h1 h2:pps)
      requires{h_width h1 = h_width h2}
      requires{h_range h1 = h_range h2}
      requires{forall x y : int->int. forall i. 
                                 (forall j . 0<= j <  (h_width h1) -> 0<= x j <2) ->
                            (forall j . 0<= j <  (h_range h1) -> 0<= y j <2) ->
                            0<=i< h_width h1 ->
                            h_basis_ket h1 x y i = h_basis_ket h2 x y i}
      requires{forall x y : int->int.
                                 (forall j . 0<= j <  (h_width h1) -> 0<= x j <2) ->
                            (forall j . 0<= j <  (h_range h1) -> 0<= y j <2) ->
                            h_angle h1 x y = h_angle h2 x y}
      ensures{pps_apply_equiv h1 h2}
  =()

let lemma get_pps_apply_equiv (h1 h2:pps) (x:matrix complex)
      requires{h_width h1 = h_width h2}
      requires{pps_apply_equiv h1 h2}
      requires{ is_a_ket_l x  (h_width h1)}
      ensures{pps_apply h1 x = pps_apply h2 x}
  =()

let lemma get_pps_apply_basis_equiv (h1 h2:pps) (x:bitvec)
      requires{h_width h1 = h_width h2}
      requires{pps_apply_equiv h1 h2}
      requires{length x =  (h_width h1)}
      ensures{pps_apply_basis h1 x = pps_apply_basis h2 x}
  =()

let lemma reflexive_pps_apply_equiv (h:pps)
      ensures{pps_apply_equiv h h}
  = set_pps_apply_equiv h h
  
let lemma commut_pps_apply_equiv (h h':pps)
      requires{pps_apply_equiv h h'}
      ensures{pps_apply_equiv h' h}
  = set_pps_apply_equiv h' h
  
let lemma transitive_pps_apply_equiv (h h' h'':pps)
      requires{pps_apply_equiv h h'}
      requires{pps_apply_equiv h' h''}
      ensures{pps_apply_equiv h h''}
  = set_pps_apply_equiv h h''
  
let lemma pps_apply_basis_seq (h1 h2:pps)(x : bitvec)
      requires{length x  = h_width h1}
      requires{h_width h1 = h_width h2}
      ensures{pps_apply_basis (pps_seq h1 h2) x = pps_apply h2 (pps_apply_basis h1 x)}
  =  
  assert{pps_apply h2 (pps_apply_basis h1 x) = ket_sum_l (n_bvs (h_range h1 ))
                                                 ( fun y -> (pow_inv_sqrt_2 (h_range h1)
                                                             *.  ang_exp (h_angle_bv h1  x y)
                                                             *.. (pow_inv_sqrt_2 (h_range h2 ) *.. (ket_sum_l (n_bvs (h_range h2 ))
                                                                                                      (fun y1 -> ang_exp (h_angle_bv h2  (h_basis_ket_bv h1  x y)  y1) *.. 
                                                                                                                   bv_to_ket (( h_basis_ket_bv h2 (h_basis_ket_bv h1  x y) y1)) ) (h_width h1))))) (h_width h1)}
  
let lemma pps_apply_seq (h1 h2:pps)(x : matrix complex)
      requires{h_width h1 = h_width h2}
      requires{is_a_ket_l x  (h_width h1)}
      ensures{pps_apply (pps_seq h1 h2) x = pps_apply h2 (pps_apply h1 x)}
  =  ()
   
let lemma pps_seq_pred (h1 h2 h3:pps)
      requires{h_width h1 = h_width h2 = h_width h3}
      requires{h_range h3  = h_range h1 + h_range h2}
      requires{forall x y : int->int. forall i:int.
                                               (forall j . 0<= j <  (h_width h3) -> 0<= x j <2) ->
                                               (forall j . 0<= j <  (h_range h3) -> 0<= y j <2) ->
                                               0<=i< h_width h3 ->
                                               h_basis_ket h3 x y i = h_basis_ket h2 (h_basis_ket h1 x y) (fun k -> y (k + h_range h1)) i}
      requires{forall x y: int-> int.
                                 (forall j . 0<= j <  (h_width h3) -> 0<= x j <2) ->
                           (forall j . 0<= j <  (h_range h3) -> 0<= y j <2) ->
                           h_angle h3 x y  =  (h_angle h1 x y)+.+  (h_angle h2 (h_basis_ket h1 x y) (fun k -> y (k + h_range h1)))}
      ensures{forall x. is_a_ket_l x (h_width h3) ->  pps_apply h3 x = pps_apply h2 (pps_apply h1 x)}
  = set_pps_apply_equiv_sim h3 (pps_seq h1 h2)
  
let lemma pps_apply_basis_par (h1 h2:pps)(x : bitvec)
      requires{length x  = h_width h1 + h_width h2}
      ensures{pps_apply_basis (pps_par h1 h2) x = kronecker (pps_apply_basis h1 (hpart x (h_width h1)))  (pps_apply_basis h2 (tpart x (h_width h1))) }
  =  assert{pps_apply_basis (pps_par h1 h2) x =
              (pow_inv_sqrt_2 (h_range (pps_par h1 h2))
               *.. ket_sum_l (n_bvs (h_range (pps_par h1 h2)))
                     (fun (y:bitvec) ->
                       ang_exp ((h_angle_bv h1 (hpart x (h_width h1)) (hpart y (h_range h1))) +.+ (h_angle_bv h2 (tpart x (h_width h1))  (tpart y (h_range h1))))
                       *.. bv_to_ket (concat (h_basis_ket_bv h1   (hpart x (h_width h1)) (hpart y (h_range h1)))
                                        (h_basis_ket_bv h2   (tpart x (h_width h1)) (tpart y (h_range h1)))))
                     (h_width (pps_par h1 h2)))}

let lemma pps_apply_par (h1 h2:pps)(x y : matrix complex)
      requires{is_a_ket_l x  (h_width h1)}
      requires{is_a_ket_l y  (h_width h2)}
      ensures{pps_apply (pps_par h1 h2) (kronecker x y) = kronecker (pps_apply h1 x)  (pps_apply h2 y)}
  =
  ()

let lemma pps_par_pred (h1 h2 h3:pps)
      requires{h_width h3 = h_width h1 + h_width h2}
      requires{h_range h3  = h_range h1 + h_range h2}
      requires{forall x y : int->int. forall i:int.
                                               (forall j . 0<= j <  (h_width h3) -> 0<= x j <2) ->
                                               (forall j . 0<= j <  (h_range h3) -> 0<= y j <2) ->
                                               0<=i< h_width h3 ->
                                               h_basis_ket h3 x y i =
                                                 if i < h_width h1 then h_basis_ket h1 x y i
                                                 else h_basis_ket h2 (fun k -> x (k+ h_width h1)) (fun k -> y (k+ h_range h1))  (i - h_width h1)}
      requires{forall x y: int-> int.        
                                 (forall j . 0<= j <  (h_width h3) -> 0<= x j <2) ->
                           (forall j . 0<= j <  (h_range h3) -> 0<= y j <2) ->
                           h_angle h3 x y  =  (h_angle h1 x y) +.+ (h_angle h2 (fun k -> x (k+ h_width h1)) (fun k -> y (k + h_range h1)))}
      ensures{forall x y. is_a_ket_l x (h_width h1) ->is_a_ket_l y (h_width h2) ->  pps_apply h3 (kronecker x y) = kronecker (pps_apply h1 x)  (pps_apply h2 y)}
  = set_pps_apply_equiv_sim h3 (pps_par h1 h2)      
      
let lemma pps_apply_basis_anc (h:pps)(x : bitvec) (y:matrix complex) (i:int)
      requires{1<=i}
      requires{i< h_width h}
      requires{length x = h_width h}
      requires{tpart x (h_width h -i) = int_to_bv 0 i}
      requires{pps_apply_basis h x = kronecker y (ket i 0)}
      requires{is_a_ket_l y (h_width h -i)}
      ensures{pps_apply_basis (pps_ancs h i) (hpart x (h_width h -i)) = y}
  =
  let width = h_width h 
  in let width' = width - i 
     in  let x' =  (hpart x width')
         in let h' = (pps_ancs h i)
            in
            begin
              pps_apply_basis_value_filter_gen h' x';
              pps_apply_basis_value_filter_gen h x;    
              assert{forall  k. 0 <= k < power 2 width' -> sum
                                                             (my_filter (n_bvs (h_range h'))
                                                                (fun (y1:bitvec) ->
                                                                  h_basis_ket_bv h' x' y1 = int_to_bv k (h_width h')))
                                                             (fun (y1:bitvec) -> ang_exp ((h_angle h' @ getbv x') @ getbv y1))
                                                           = sum (n_bvs i)(fun l -> sum  (my_filter (n_bvs (h_range h'))
                                                                                            (fun y -> h_basis_ket_bv h x y = concat (int_to_bv k (h_width h')) l))
                                                                                      (fun (y1:bitvec) -> ang_exp ((h_angle h' @ getbv x') @ getbv y1)))};
              assert{forall k. 0 <= k < power 2 width' -> get_ket (pps_apply_basis  h' x') k  = sum (n_bvs i) (fun j -> get_ket (pps_apply_basis h x) (bv_to_int(concat (int_to_bv k width') j)))};
              assert{forall k. 0 <= k < power 2 width'-> get_ket (pps_apply_basis  h' x') k =  get_ket (pps_apply_basis h x) (bv_to_int(concat (int_to_bv k width') (ket_to_bv (ket i 0))))};
              set_equal_ket_l  (pps_apply_basis  h x) (kronecker (pps_apply_basis  h' x') (ket i 0)); 
              kronecker_injec_eq_left (pps_apply_basis  h' x') y (ket i 0)
            end
            
let lemma pps_apply_basis_anc_ (h:pps)(x : bitvec) (y:matrix complex) (i:int)
      requires{1<=i}
      requires{i< h_width h}
      requires{length x = h_width h -i}
      requires{pps_apply_basis h  (concat x (int_to_bv 0 i)) = kronecker y (ket i 0)}
      requires{is_a_ket_l y (h_width h -i)}
      ensures{pps_apply_basis (pps_ancs h i) x = y}
  = pps_apply_basis_anc h (concat x (int_to_bv 0 i)) y i

let lemma pps_apply_anc (h :pps)(path_sem_target : matrix complex ->matrix complex)(x : matrix complex) (i:int)
      requires{1<=i}
      requires{i< h_width h}
      requires{is_a_ket_l x (h_width h -i)}
      requires{forall x:matrix complex. is_a_ket_l x (h_width h -i ) ->  pps_apply h (kronecker x (ket i 0)) =  (kronecker (path_sem_target x) (ket i 0))}
      requires{is_a_ket_l x (h_width h -i)}
      ensures{pps_apply (pps_ancs h i) x = (path_sem_target x)}
  =  ()
   
let lemma pps_apply_equiv_seq (h1 h1' h2 h2':pps)
      requires{pps_apply_equiv h1 h1'}
      requires{pps_apply_equiv h2 h2'}
      requires{h_width h1 = h_width h2}
      ensures{pps_apply_equiv (pps_seq h1 h2) (pps_seq h1' h2')}
  =()

let lemma pps_apply_equiv_par (h1 h1' h2 h2':pps)
      requires{pps_apply_equiv h1 h1'}
      requires{pps_apply_equiv h2 h2'}
      ensures{pps_apply_equiv (pps_par h1 h2) (pps_par h1' h2')}
  =()
  
let lemma pps_apply_equiv_anc (h h':pps) (i:int)
      requires{1<=i}
      requires{i< h_width h}
      requires{pps_apply_equiv h h'}
      requires{exists path_sem_target. forall y. is_a_ket_l y   (h_width h -i) -> pps_apply h  (kronecker  y (ket i 0)) = kronecker (path_sem_target y) (ket i 0)}
      ensures{pps_apply_equiv (pps_ancs h i) (pps_ancs h' i)}
  =()

let lemma   pps_place_image (h:pps) (k n:int) (x y z:bitvec)
      requires{0<= k}
      requires{k+ h_width h <= n}
      requires{length x = k}
      requires{length y = h_width h}
      requires{length z = n - h_width h - k}
      ensures{pps_apply_basis (pps_place h k n) (concat (concat x y) z) = (kronecker (kronecker (bv_to_ket x) (pps_apply_basis h y)) (bv_to_ket z))}
  =()
  
let lemma pps_place_image_bv (h:pps) (t n:int) (x:bitvec)
      requires{0<= t}
      requires{t+ h_width h <= n}
      requires{length x = n}
      ensures{pps_apply_basis (pps_place h t n) x = (kronecker (kronecker (bv_to_ket (hpart x t)) (pps_apply_basis h (htpart x t (h_width h)))) (bv_to_ket(tpart x (t+h_width h))))}
  = pps_place_image h t n  (hpart x t) (htpart x t (h_width h)) (tpart x  (t+h_width h))

let lemma pps_apply_equiv_place (h h':pps) (t n t' n':int)
      requires{0<= t}
      requires{t+ h_width h <= n}
      requires{t = t'}
      requires{n = n'}
      requires{pps_apply_equiv h h'}
      ensures{pps_apply_equiv (pps_place h  t n) (pps_place h'  t' n')}
  = set_pps_apply_equiv (pps_place h  t n) (pps_place h'  t' n')

let lemma pps_apply_equiv_cont (h h':pps)  (co t n co' t' n':int)
      requires{co = co'}
      requires{t = t'}
      requires{n = n'}
      requires{0<= t<= n - h_width h}
      requires{0<= co <n}
      requires{t<=co ->   t + h_width h  <= co}
      requires{pps_apply_equiv h h'}
      ensures{pps_apply_equiv (pps_cont h co t n) (pps_cont h' co' t' n')}
  =()
  
let lemma pps_anc_pred (h1 h2:pps)(path_sem_target: matrix complex-> matrix complex) (i:int)
      requires{1<=i}
      requires{i< h_width h1 }
      requires{forall y. is_a_ket_l y   (h_width h1 -i) -> pps_apply h1  (kronecker  y (ket i 0)) = kronecker (path_sem_target y) (ket i 0)}
      requires{h_width h2 = h_width h1 -i}
      requires{h_range h2  = h_range h1}
      requires{forall x y : int->int. forall ii:int.
                                                (forall j . 0<= j <  (h_width h2) -> 0<= x j <2) ->
                                                (forall j . 0<= j <  (h_range h2) -> 0<= y j <2) ->
                                                0<=ii< h_width h2 ->
                                                h_basis_ket h2 x y ii = h_basis_ket h1 (fun k -> if k < h_width h1 -i then x k else 0) y ii}
      requires{forall x y: int-> int.        
                                 (forall j . 0<= j <  (h_width h2) -> 0<= x j <2) ->
                           (forall j . 0<= j <  (h_range h2) -> 0<= y j <2) ->
                           h_angle h2 x y  = h_angle h1 (fun k -> if k < h_width h1 -i then x k else 0) y}
      ensures{forall x. length x = (h_width h2) ->  pps_apply_basis h2 x = path_sem_target (bv_to_ket x)}
  = set_pps_apply_equiv_sim h2 (pps_ancs h1 i)

let lemma pps_anc_pred_ (h1 h2:pps) (i:int)
      requires{1<=i}
      requires{i< h_width h1 }
      requires{exists path_sem_target. forall y. is_a_ket_l y   (h_width h1 -i) -> pps_apply h1  (kronecker  y (ket i 0)) = kronecker (path_sem_target y) (ket i 0)}
      requires{h_width h2 = h_width h1 -i}
      requires{h_range h2  = h_range h1}
      requires{forall x y : int->int. forall ii:int.
                                                (forall j . 0<= j <  (h_width h2) -> 0<= x j <2) ->
                                                (forall j . 0<= j <  (h_range h2) -> 0<= y j <2) ->
                                                0<=ii< h_width h2 ->
                                                h_basis_ket h2 x y ii = h_basis_ket h1 (fun k -> if k < h_width h1 -i then x k else 0) y ii}
      requires{forall x y: int-> int.        
                                 (forall j . 0<= j <  (h_width h2) -> 0<= x j <2) ->
                           (forall j . 0<= j <  (h_range h2) -> 0<= y j <2) ->
                           h_angle h2 x y  = h_angle h1 (fun k -> if k < h_width h1 -i then x k else 0) y}
      ensures{forall x. length x = (h_width h2) ->  pps_apply_basis h1 (concat x (int_to_bv 0 i)) = kronecker (pps_apply_basis h2 x ) (ket i 0)}
  = set_pps_apply_equiv_sim h2 (pps_ancs h1 i)

      use matrices.Matrix_sums
      use matrices.Matrix_product
   
let function pps_to_mat (h:pps)
               ensures{result = pow_inv_sqrt_2 (h_range h) *.. mat_sum_dim (n_bvs (h_width h)) (fun x -> mat_sum_dim (n_bvs (h_range h)) (fun y ->   
                                                                                                             (make_f (power 2 (h_width h)) (power 2 (h_width h)) (fun i j -> if i = bv_to_int (h_basis_ket_bv h x y) && j = bv_to_int x then ang_exp (h_angle_bv h x y) else c_zero ))) (power 2 (h_width h)) (power 2 (h_width h))) (power 2 (h_width h)) (power 2 (h_width h))}
               ensures{result = pow_inv_sqrt_2 (h_range h) *.. mat_sum (n_bvs (h_width h)) (fun x -> mat_sum (n_bvs (h_range h)) (fun y ->   
                                                                                                         (make_f (power 2 (h_width h)) (power 2 (h_width h)) (fun i j -> if i = bv_to_int (h_basis_ket_bv h x y) && j = bv_to_int x then ang_exp (h_angle_bv h x y) else c_zero ))))}
               ensures{rows result = power 2 (h_width h)}
               ensures{columns result = power 2 (h_width h)}
               ensures{forall x: bitvec. length x = (h_width h)  -> mat_mult result (bv_to_ket x) = pps_apply_basis h x}
               ensures{forall x: matrix complex. is_a_ket_l x  (h_width h)  -> mat_mult result x = pps_apply h x}
  = pow_inv_sqrt_2 (h_range h) *.. mat_sum_dim (n_bvs (h_width h)) (fun x -> mat_sum_dim (n_bvs (h_range h)) (fun y -> if length x = h_width h && length y = h_range h then  
                                                                                                                         (make_f (power 2 (h_width h)) (power 2 (h_width h)) (fun i j -> if i = bv_to_int (h_basis_ket_bv h x y) && j = bv_to_int x then ang_exp (h_angle_bv h x y) else c_zero )) else (make_f (power 2 (h_width h)) (power 2 (h_width h)) (fun _ _  -> c_zero))) (power 2 (h_width h)) (power 2 (h_width h)) ) (power 2 (h_width h)) (power 2 (h_width h)) 
  
end

module Mats_for_sem
         use  complex_expo.Complex_Exponentiation
         use  int_expo.Int_Exponentiation
         use complex_operations.Indic
         use  complex.Complex
         use  int.EuclideanDivision
         use  int.Int         
         use  binary.Bit_vector
         use   unit_circle.Angle
         use  matrices.Matrix
         use  matrices.Matrix_product
         use  qdata.Bv_to_ket
         use  qdata.Qreg
         use  qdata.Sqrt_two
         use  matrices.Matrix_scalar
         use  binary.Bit_vector_decomp
         use  Pps
         use  qdata.Kronecker_Qbit
         use binary.Int_to_bv
     
let function sem_id_mat()
               ensures{rows result = power 2 1}
               ensures{columns result = power 2 1}
               ensures{forall x. length x = 1 -> mat_mult result (bv_to_ket x) =  (bv_to_ket x)}
               ensures{forall x. length x = 1 -> mat_mult result (bv_to_ket x) =  pps_apply_basis (pps_id) x}
  = make_f 2 2 indic

let function sem_rz_mat (k:int) : matrix complex
                                    ensures{rows result = power 2 1}
                                    ensures{columns result = power 2 1}
                                    ensures{forall x. length x = 1 -> mat_mult result (bv_to_ket x) =  ang_exp (getbv x 0 /./ k) *..  bv_to_ket x}
                                    ensures{ forall x. length x = 1 -> mat_mult result (bv_to_ket x) =  pps_apply_basis (pps_rz k) x }
  =  make_f 2 2 (fun i j -> if i = j then  ang_exp (i /./ k) else c_zero)

let function sem_phase_mat (k:int) : matrix complex
                                       ensures{rows result = power 2 1}
                                       ensures{columns result = power 2 1}
                                       ensures{forall x. length x = 1 -> mat_mult result (bv_to_ket x) =   ang_exp ( 1 /./ k) *.. bv_to_ket x }
                                       ensures{ forall x. length x = 1 -> mat_mult result (bv_to_ket x) =  pps_apply_basis (pps_phase k) x }
  =  make_f 2 2 (fun i j -> if i = j  then ang_exp ( 1 /./ k) else c_zero)

let function sem_hadamard_mat() : matrix complex
                                    ensures{rows result = power 2 1}
                                    ensures{columns result = power 2 1}
                                    ensures{forall x. length x = 1 -> mat_mult result (bv_to_ket x) =  pow_inv_sqrt_2 1 *.. add_ket_l (ket 1 0) (ang_exp ((getbv x 0 )/./1 ) *..(ket 1 1)) 1}
                                    ensures{ forall x. length x = 1 -> mat_mult result (bv_to_ket x) =  pps_apply_basis pps_hadamard x }
  = make_f 2 2  (fun i j -> cpower (-. c_one) (i*j)  *. pow_inv_sqrt_2 1)
  
let function cnot_func(x:bitvec):bitvec
                                   requires{length x =2}
                                   ensures{length result = 2}
                                   ensures{bv_to_int x = 0 -> result = int_to_bv 0 2}
                                   ensures{bv_to_int x = 1 -> result = int_to_bv 1 2}
                                   ensures{bv_to_int x = 2 -> result = int_to_bv 3 2}
                                   ensures{bv_to_int x = 3 -> result = int_to_bv 2 2}
  =
  assert{getbv x 0 = div (bv_to_int x)2};
  assert{getbv x 1 = mod (bv_to_int x)2};
  if getbv x 0 = 0 then x else  make_bv (fun i -> if i = 0 then getbv x i else (1- getbv x i ))2

let lemma invol_cnot_func (x:bitvec)
      requires{length x =2}
      ensures{cnot_func (cnot_func x) = x}
  =()
  
let function cnot_func_int(i:int):int
                                    ensures{0<= result < 4}
                                    ensures{i = 0 -> result = 0}
                                    ensures{i = 1 -> result = 1}
                                    ensures{i = 2 -> result = 3}
                                    ensures{i = 3 -> result = 2}
                                    ensures{0<= i < 4 -> result = if div i 2 = 0  then i else 3 -mod i 2}
  =
  bv_to_int (cnot_func (int_to_bv i 2))

let lemma invol_cnot_func_int (i:int)
      requires{0<= i < 4}
      ensures{cnot_func_int (cnot_func_int i) = i}
  =()

let function sem_cnot_mat() : matrix complex
                                ensures{rows result = power 2 2}
                                ensures{columns result = power 2 2}
                                ensures{result = make_f 4 4  (fun i j -> if j =  (if div i 2 = 0  then i else 3 -mod i 2) then c_one else c_zero)}
                                ensures{forall x. length x = 2 -> mat_mult result (bv_to_ket x) = bv_to_ket (if getbv x 0 = 0  then x else  int_to_bv (if bv_to_int x = 2 then 3 else 2) 2)}
                                ensures{forall x. length x = 2 -> mat_mult result (bv_to_ket x) = bv_to_ket (if getbv x 0 = 0  then x else  make_bv (fun i ->
                                                                                                                                                if i = 0 then getbv x i else (1- getbv x i ))2)}
                                ensures{forall i. 0<= i < power 2 2 ->  mat_mult result (ket 2 i) =   ket 2 (if i = 0 then 0 else if i = 1 then 1 else if i=2 then 3 else 2 )}
                                ensures{ forall x. length x = 2 -> mat_mult result (bv_to_ket x) =  bv_to_ket  (cnot_func x) }
                                ensures{ forall x. length x = 2 -> mat_mult result (bv_to_ket x) =  pps_apply_basis (pps_cnot 0 1 2) x }
  = make_f 4 4  (fun i j -> if j = cnot_func_int i then c_one else c_zero)

let function swap_func(x:bitvec):bitvec
                                   requires{length x =2}
                                   ensures{length result = 2}
                                   ensures{bv_to_int x = 0 -> result = int_to_bv 0 2}
                                   ensures{bv_to_int x = 1 -> result = int_to_bv 2 2}
                                   ensures{bv_to_int x = 2 -> result = int_to_bv 1 2}
                                   ensures{bv_to_int x = 3 -> result = int_to_bv 3 2}
  =
  assert{getbv x 0 = div (bv_to_int x)2};
  assert{getbv x 1 = mod (bv_to_int x)2};
  make_bv (fun i ->  getbv x  (1-  i )) 2

let lemma invol_swap_func (x:bitvec)
      requires{length x =2}
      ensures{swap_func (swap_func x) = x}
  =()
  
let function swap_func_int(i:int):int
                                    ensures{0<= result < 4}
                                    ensures{i = 0 -> result = 0}
                                    ensures{i = 1 -> result = 2}
                                    ensures{i = 2 -> result = 1}
                                    ensures{i = 3 -> result = 3}
                                    ensures{0<= i < 4 -> result = if div i 2 = mod i 2  then i else 3 - i }
  =
  bv_to_int (swap_func (int_to_bv i 2))
  
let lemma invol_swap_func_int (i:int)
      requires{0<= i < 4}
      ensures{swap_func_int (swap_func_int i) = i}
  =()
  
let function sem_swap_mat() : matrix complex
                                ensures{rows result = power 2 2}
                                ensures{columns result = power 2 2}
                                ensures{result = make_f 4 4  (fun i j -> indic j (if i = 0  then i else if i = 1  then 2 else if i = 2  then 1 else 3))}
                                ensures{forall x. length x = 2 -> mat_mult result (bv_to_ket x) = bv_to_ket (  make_bv (fun i ->  getbv x (1-i) )2)}
                                ensures{ forall x. length x = 2 -> mat_mult result (bv_to_ket x) =  bv_to_ket  (swap_func x) }
                                ensures{forall i. 0<= i < power 2 2 ->  mat_mult result (ket 2 i) =   ket 2 (if i = 0 then 0 else if i = 1 then 2 else if i =2 then 1 else 3 )}
                                ensures{ forall x. length x = 2 -> mat_mult result (bv_to_ket x) =  pps_apply_basis (pps_swap 0 1 2 ) x }
  = make_f 4 4  (fun i j -> indic j (swap_func_int i ))
end 
     
