(* this is the prelude for Alt-Ergo, version >= 2.4.0 *)
(* this is a prelude for Alt-Ergo real arithmetic *)
(* this is a prelude for Alt-Ergo integer arithmetic *)
type string

logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool_True :
  (forall z:'a. forall z1:'a. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

logic infix_eqeq : 'a, 'a -> prop

axiom infix_eqeqqtspec :
  (forall a:'a1. forall b:'a1. (infix_eqeq(a, b) -> (a = b)))

axiom infix_eqeqqtspec1 :
  (forall a:'a1. forall b:'a1. ((a = b) -> infix_eqeq(a, b)))

axiom assert_equal : true

axiom goal_comm : (forall a:'a1. forall b:'a1. ((a = b) -> (b = a)))

type complex

axiom teqqtspec :
  (forall x:complex. forall y:complex. (infix_eqeq(x, y) -> (x = y)))

axiom teqqtspec1 :
  (forall x:complex. forall y:complex. ((x = y) -> infix_eqeq(x, y)))

logic c_zero : complex

logic c_one : complex

logic prefix_mndt : complex -> complex

logic ac infix_pldt : complex, complex -> complex

logic ac infix_asdt : complex, complex -> complex

logic inv : complex -> complex

axiom Assoc :
  (forall x:complex. forall y:complex. forall z:complex.
  (infix_pldt(infix_pldt(x, y), z) = infix_pldt(x, infix_pldt(y, z))))

axiom Unit_def_l : (forall x:complex. (infix_pldt(c_zero, x) = x))

axiom Unit_def_r : (forall x:complex. (infix_pldt(x, c_zero) = x))

axiom Inv_def_l :
  (forall x:complex. (infix_pldt(prefix_mndt(x), x) = c_zero))

axiom Inv_def_r :
  (forall x:complex. (infix_pldt(x, prefix_mndt(x)) = c_zero))

axiom Comm :
  (forall x:complex. forall y:complex. (infix_pldt(x, y) = infix_pldt(y, x)))

axiom Assoc1 :
  (forall x:complex. forall y:complex. forall z:complex.
  (infix_asdt(infix_asdt(x, y), z) = infix_asdt(x, infix_asdt(y, z))))

axiom Mul_distr_l :
  (forall x:complex. forall y:complex. forall z:complex. (infix_asdt(x,
  infix_pldt(y, z)) = infix_pldt(infix_asdt(x, y), infix_asdt(x, z))))

axiom Mul_distr_r :
  (forall x:complex. forall y:complex. forall z:complex.
  (infix_asdt(infix_pldt(y, z), x) = infix_pldt(infix_asdt(y, x),
  infix_asdt(z, x))))

axiom Comm1 :
  (forall x:complex. forall y:complex. (infix_asdt(x, y) = infix_asdt(y, x)))

axiom Unitary : (forall x:complex. (infix_asdt(c_one, x) = x))

axiom NonTrivialRing : (not (c_zero = c_one))

axiom Inverse :
  (forall x:complex. ((not (x = c_zero)) -> (infix_asdt(x, inv(x)) = c_one)))

function infix_mn(x: complex, y: complex) : complex = infix_pldt(x,
  prefix_mndt(y))

function infix_sl(x: complex, y: complex) : complex = infix_asdt(x, inv(y))

axiom add_div :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (z = c_zero)) -> (infix_sl(infix_pldt(x, y),
  z) = infix_pldt(infix_sl(x, z), infix_sl(y, z)))))

axiom sub_div :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (z = c_zero)) -> (infix_sl(infix_mn(x, y), z) = infix_mn(infix_sl(x,
  z), infix_sl(y, z)))))

axiom neg_div :
  (forall x:complex. forall y:complex. ((not (y = c_zero)) ->
  (infix_sl(prefix_mndt(x), y) = prefix_mndt(infix_sl(x, y)))))

axiom assoc_mul_div :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (z = c_zero)) -> (infix_sl(infix_asdt(x, y), z) = infix_asdt(x,
  infix_sl(y, z)))))

axiom assoc_div_mul :
  (forall x:complex. forall y:complex. forall z:complex.
  (((not (y = c_zero)) and (not (z = c_zero))) -> (infix_sl(infix_sl(x, y),
  z) = infix_sl(x, infix_asdt(y, z)))))

axiom assoc_div_div :
  (forall x:complex. forall y:complex. forall z:complex.
  (((not (y = c_zero)) and (not (z = c_zero))) -> (infix_sl(x, infix_sl(y,
  z)) = infix_sl(infix_asdt(x, z), y))))

function infix_mndt(x: complex, y: complex) : complex = infix_pldt(x,
  prefix_mndt(y))

logic infix_sldt : complex, complex -> complex

axiom infix_sldtqtdef :
  (forall x:complex. forall y:complex. ((not (y = c_zero)) -> (infix_sldt(x,
  y) = infix_asdt(x, inv(y)))))

axiom infix_sldtqtspec :
  (forall x:complex. forall y:complex. ((not (y = c_zero)) -> (infix_sldt(x,
  y) = infix_asdt(x, inv(y)))))

axiom add_div1 :
  (forall x:real. forall y:real. forall z:real. ((not (z = 0.0)) ->
  (((x + y) / z) = ((x / z) + (y / z)))))

axiom sub_div1 :
  (forall x:real. forall y:real. forall z:real. ((not (z = 0.0)) ->
  (((x - y) / z) = ((x / z) - (y / z)))))

axiom neg_div1 :
  (forall x:real. forall y:real. ((not (y = 0.0)) ->
  (((-x) / y) = (-(x / y)))))

axiom assoc_mul_div1 :
  (forall x:real. forall y:real. forall z:real. ((not (z = 0.0)) ->
  (((x * y) / z) = (x * (y / z)))))

axiom assoc_div_mul1 :
  (forall x:real. forall y:real. forall z:real. (((not (y = 0.0)) and
  (not (z = 0.0))) -> (((x / y) / z) = (x / (y * z)))))

axiom assoc_div_div1 :
  (forall x:real. forall y:real. forall z:real. (((not (y = 0.0)) and
  (not (z = 0.0))) -> ((x / (y / z)) = ((x * z) / y))))

axiom CompatOrderMult :
  (forall x:real. forall y:real. forall z:real. ((x <= y) -> ((0.0 <= z) ->
  ((x * z) <= (y * z)))))

logic infix_slas : real, real -> real

axiom infix_slasqtdef :
  (forall x:real. forall y:real. ((not (y = 0.0)) -> (infix_slas(x,
  y) = (x / y))))

axiom infix_eqasqtspec :
  (forall x:real. forall y:real. (infix_eqeq(x, y) -> (x = y)))

axiom infix_eqasqtspec1 :
  (forall x:real. forall y:real. ((x = y) -> infix_eqeq(x, y)))

predicate infix_lsgtas(x: real, y: real) = (not infix_eqeq(x, y))

axiom infix_lsgtasqtspec :
  (forall x:real. forall y:real. (infix_lsgtas(x, y) -> (not (x = y))))

axiom infix_lsgtasqtspec1 :
  (forall x:real. forall y:real. ((not (x = y)) -> infix_lsgtas(x, y)))

predicate infix_lsas(x: real, y: real) = ((x <= y) and infix_lsgtas(x, y))

axiom CompatOrderMult1 :
  (forall x:int. forall y:int. forall z:int. ((x <= y) -> ((0 <= z) ->
  ((x * z) <= (y * z)))))

logic from_int : int -> real

axiom Zero : (from_int(0) = 0.0)

axiom One : (from_int(1) = 1.0)

axiom Add :
  (forall x:int. forall y:int.
  (from_int((x + y)) = (from_int(x) + from_int(y))))

axiom Sub :
  (forall x:int. forall y:int.
  (from_int((x - y)) = (from_int(x) - from_int(y))))

axiom Mul :
  (forall x:int. forall y:int.
  (from_int((x * y)) = (from_int(x) * from_int(y))))

axiom Neg : (forall x:int. (from_int((-x)) = (-from_int(x))))

axiom Injective :
  (forall x:int. forall y:int. ((from_int(x) = from_int(y)) -> (x = y)))

axiom Monotonic :
  (forall x:int. forall y:int. ((x <= y) -> (from_int(x) <= from_int(y))))

logic from_int1 : int -> real

axiom from_intqtspec : (forall x:int. (from_int1(x) = from_int(x)))

axiom Zero1 : (from_int1(0) = 0.0)

axiom Add1 :
  (forall x:int. forall y:int.
  (from_int1((x + y)) = (from_int1(x) + from_int1(y))))

axiom One1 : (from_int1(1) = 1.0)

axiom Sub1 :
  (forall x:int. forall y:int.
  (from_int1((x - y)) = (from_int1(x) - from_int1(y))))

axiom mul_pos :
  (forall x:int. forall y:int. ((0 <= y) ->
  (from_int1((x * y)) = (from_int1(x) * from_int1(y)))))

axiom mul :
  (forall x:int. forall y:int. ((0 <= y) ->
  (from_int1((x * y)) = (from_int1(x) * from_int1(y)))))

axiom mul_rev :
  (forall x:int. forall y:int. ((0 <= y) ->
  ((from_int1(x) * from_int1(y)) = from_int1((x * y)))))

axiom neg : (forall x:int. (from_int1((-x)) = (-from_int1(x))))

axiom injective :
  (forall x:int. forall y:int. ((from_int1(x) = from_int1(y)) -> (x = y)))

axiom Monotonic1 :
  (forall x:int. forall y:int. ((x <= y) -> (from_int1(x) <= from_int1(y))))

axiom positive_inv :
  (forall x:real. (infix_lsas(0.0, x) -> infix_lsas(0.0, infix_slas(1.0,
  x))))

axiom r_zeroLessOne : (0.0 <= 1.0)

axiom r_compatOrderAdd :
  (forall x:real. forall y:real. forall z:real. ((x <= y) ->
  ((x + z) <= (y + z))))

axiom r_compatOrderMult :
  (forall x:real. forall y:real. forall z:real. ((x <= y) -> ((0.0 <= z) ->
  ((x * z) <= (y * z)))))

axiom inv_order :
  (forall a:real. forall b:real. (infix_lsas(0.0, a) -> (infix_lsas(0.0,
  b) -> ((a <= b) -> ((1.0 / b) <= (1.0 / a))))))

axiom inv_strict_order :
  (forall a:real. forall b:real. (infix_lsas(0.0, a) -> (infix_lsas(0.0,
  b) -> (infix_lsas(a, b) -> infix_lsas((1.0 / b), (1.0 / a))))))

axiom invol_neg : (forall a:complex. (prefix_mndt(prefix_mndt(a)) = a))

axiom injective_neg :
  (forall a:complex. forall b:complex. ((prefix_mndt(a) = prefix_mndt(b)) ->
  (a = b)))

axiom find_opposite :
  (forall a:complex. forall b:complex. ((infix_mndt(a, b) = c_zero) ->
  (a = b)))

axiom div_as_mult_inv :
  (forall a:complex. forall b:complex. ((not (a = c_zero)) -> (infix_sldt(b,
  a) = infix_asdt(b, infix_sldt(c_one, a)))))

axiom add_opposite :
  (forall a:complex. (infix_pldt(a, prefix_mndt(a)) = c_zero))

axiom opposite : (forall a:complex. (infix_mndt(a, a) = c_zero))

axiom mult_num :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (c = c_zero)) -> (infix_sldt(infix_asdt(a, b), c) = infix_asdt(a,
  infix_sldt(b, c)))))

axiom div_rev :
  (forall a:complex. forall b:complex. ((not (b = c_zero)) -> (infix_asdt(a,
  infix_sldt(c_one, b)) = infix_sldt(a, b))))

axiom mult_div_num :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (c = c_zero)) -> (infix_asdt(infix_sldt(a, c),
  b) = infix_sldt(infix_asdt(a, b), c))))

axiom mult_denom :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (c = c_zero)) -> ((not (b = c_zero)) -> (infix_sldt(a, infix_asdt(b,
  c)) = infix_asdt(infix_sldt(a, b), infix_sldt(c_one, c))))))

axiom mult_simpl :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (c = c_zero)) -> ((not (b = c_zero)) -> (infix_sldt(infix_asdt(a, b),
  infix_asdt(c, b)) = infix_sldt(a, c)))))

axiom dic_simpl :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (c = c_zero)) -> ((not (b = c_zero)) -> (infix_asdt(infix_sldt(a,
  infix_asdt(c, b)), b) = infix_sldt(a, c)))))

axiom simpl_with_c_one :
  (forall a:complex. forall b:complex. ((not (a = c_zero)) ->
  ((not (b = c_zero)) -> (infix_asdt(infix_sldt(a, b), infix_sldt(c_one,
  a)) = infix_sldt(c_one, b)))))

axiom add_op :
  (forall a1:complex. forall a2:complex. ((a1 = prefix_mndt(a2)) ->
  (infix_pldt(a1, a2) = c_zero)))

axiom mult_eq_t :
  (forall a1:complex. forall a2:complex. forall b1:complex.
  forall b2:complex. ((a1 = a2) -> ((b1 = b2) -> (infix_asdt(a1,
  b1) = infix_asdt(a2, b2)))))

axiom mult_eq_t_rev :
  (forall a1:complex. forall a2:complex. forall b1:complex.
  forall b2:complex. ((a1 = a2) -> ((b1 = b2) -> (infix_asdt(a1,
  b1) = infix_asdt(b2, a2)))))

axiom mult_comm :
  (forall a:complex. forall b:complex. (infix_asdt(a, b) = infix_asdt(b, a)))

axiom mult_assoc :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_asdt(infix_asdt(a, b), c) = infix_asdt(a, infix_asdt(b, c))))

axiom mult_abc_to_acb :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_asdt(infix_asdt(a, b), c) = infix_asdt(infix_asdt(a, c), b)))

axiom zero_mult_t :
  (forall a1:complex. forall a2:complex. ((a1 = c_zero) -> (infix_asdt(a1,
  a2) = c_zero)))

axiom mult_zero_t :
  (forall a1:complex. forall a2:complex. ((a1 = c_zero) -> (infix_asdt(a2,
  a1) = c_zero)))

axiom mult_one_t :
  (forall a1:complex. forall a2:complex. ((a2 = c_one) -> (infix_asdt(a1,
  a2) = a1)))

axiom add_eq_t :
  (forall a1:complex. forall a2:complex. forall b1:complex.
  forall b2:complex. ((a1 = a2) -> ((b1 = b2) -> (infix_pldt(a1,
  b1) = infix_pldt(a2, b2)))))

axiom add_eq_t_rev :
  (forall a1:complex. forall a2:complex. forall b1:complex.
  forall b2:complex. ((a1 = a2) -> ((b1 = b2) -> (infix_pldt(a1,
  b1) = infix_pldt(b2, a2)))))

axiom substr_eq_t :
  (forall a1:complex. forall a2:complex. forall b1:complex.
  forall b2:complex. ((a1 = a2) -> ((b1 = b2) -> (infix_mndt(a1,
  b1) = infix_mndt(a2, b2)))))

logic im : complex

axiom im_Def : (infix_asdt(im, im) = prefix_mndt(c_one))

logic r_to_c : real -> complex

axiom r_to_c_zero : (r_to_c(0.0) = c_zero)

axiom r_to_c_one : (r_to_c(1.0) = c_one)

axiom r_to_c_add :
  (forall i:real. forall j:real. (infix_pldt(r_to_c(i),
  r_to_c(j)) = r_to_c((i + j))))

axiom r_to_c_add_rev :
  (forall i:real. forall j:real. (r_to_c((i + j)) = infix_pldt(r_to_c(i),
  r_to_c(j))))

axiom r_to_c_opp : (forall i:real. (r_to_c((-i)) = prefix_mndt(r_to_c(i))))

axiom r_to_c_div :
  (forall i:real. forall j:real. ((not (j = 0.0)) -> (r_to_c(infix_slas(i,
  j)) = infix_sldt(r_to_c(i), r_to_c(j)))))

axiom r_to_c_mult :
  (forall i:real. forall j:real. (infix_asdt(r_to_c(i),
  r_to_c(j)) = r_to_c((i * j))))

axiom r_to_c_mult_rev :
  (forall i:real. forall j:real. (r_to_c((i * j)) = infix_asdt(r_to_c(i),
  r_to_c(j))))

axiom r_to_c_sub :
  (forall i:real. forall j:real. (infix_mndt(r_to_c(i),
  r_to_c(j)) = r_to_c((i - j))))

logic real_part : complex -> real

logic im_part : complex -> real

axiom Real_part_add :
  (forall i:complex. forall j:complex. (real_part(infix_pldt(i,
  j)) = (real_part(i) + real_part(j))))

axiom Im_part_add :
  (forall i:complex. forall j:complex. (im_part(infix_pldt(i,
  j)) = (im_part(i) + im_part(j))))

axiom Real_part_opposite :
  (forall i:complex. (real_part(prefix_mndt(i)) = (-real_part(i))))

axiom Im_part_opposite :
  (forall i:complex. (im_part(prefix_mndt(i)) = (-im_part(i))))

axiom Complex_decomp :
  (forall i:complex. (i = infix_pldt(r_to_c(real_part(i)), infix_asdt(im,
  r_to_c(im_part(i))))))

axiom Unic_decomp :
  (forall i:complex.
  (forall x:real. forall y:real. ((i = infix_pldt(r_to_c(x), infix_asdt(im,
  r_to_c(y)))) -> (x = real_part(i)))))

axiom Unic_decomp1 :
  (forall i:complex.
  (forall x:real. forall y:real. ((i = infix_pldt(r_to_c(x), infix_asdt(im,
  r_to_c(y)))) -> (y = im_part(i)))))

predicate real_(x: complex) = infix_eqeq(im_part(x), 0.0)

predicate pure_im_(x: complex) = infix_eqeq(real_part(x), 0.0)

axiom unic_decomp :
  (forall i:complex. forall x:real. forall y:real.
  ((i = infix_pldt(r_to_c(x), infix_asdt(im, r_to_c(y)))) ->
  (x = real_part(i))))

axiom unic_decomp1 :
  (forall i:complex. forall x:real. forall y:real.
  ((i = infix_pldt(r_to_c(x), infix_asdt(im, r_to_c(y)))) ->
  (y = im_part(i))))

axiom r_to_c_real :
  (forall x:complex. (real_(x) -> (x = r_to_c(real_part(x)))))

axiom real_r_to_c : (forall x:real. real_(r_to_c(x)))

axiom r_to_c_pure_im :
  (forall x:complex. (pure_im_(x) -> (x = infix_asdt(im,
  r_to_c(im_part(x))))))

axiom decomp_mult :
  (forall a:complex. forall b:complex. (infix_asdt(a,
  b) = infix_pldt(infix_mndt(infix_asdt(r_to_c(real_part(a)),
  r_to_c(real_part(b))), infix_asdt(r_to_c(im_part(a)), r_to_c(im_part(b)))),
  infix_asdt(im, infix_pldt(infix_asdt(r_to_c(real_part(a)),
  r_to_c(im_part(b))), infix_asdt(r_to_c(real_part(b)),
  r_to_c(im_part(a))))))))

function t_real_part(x: complex) : complex = r_to_c(real_part(x))

axiom t_real_partqtspec : (forall x:complex. real_(t_real_part(x)))

axiom t_real_part_inv :
  (forall x:complex.
  (t_real_part(prefix_mndt(x)) = prefix_mndt(t_real_part(x))))

function t_im_part(x: complex) : complex = r_to_c(im_part(x))

axiom t_im_partqtspec : (forall x:complex. real_(t_im_part(x)))

axiom t_im_part_inv :
  (forall x:complex. (t_im_part(prefix_mndt(x)) = prefix_mndt(t_im_part(x))))

axiom decomp_mult_as_reals :
  (forall a:complex. forall b:complex. (infix_asdt(a,
  b) = infix_pldt(infix_mndt(infix_asdt(t_real_part(a), t_real_part(b)),
  infix_asdt(t_im_part(a), t_im_part(b))), infix_asdt(im,
  infix_pldt(infix_asdt(t_real_part(a), t_im_part(b)),
  infix_asdt(t_real_part(b), t_im_part(a)))))))

axiom decomp_mult_real_part :
  (forall a:complex. forall b:complex. (real_part(infix_asdt(a,
  b)) = ((real_part(a) * real_part(b)) - (im_part(a) * im_part(b)))))

axiom decomp_mult_im_part :
  (forall a:complex. forall b:complex. (im_part(infix_asdt(a,
  b)) = ((real_part(a) * im_part(b)) + (real_part(b) * im_part(a)))))

axiom t_mult_real :
  (forall a:complex. forall b:complex. (t_real_part(infix_asdt(a,
  b)) = infix_mndt(infix_asdt(t_real_part(a), t_real_part(b)),
  infix_asdt(t_im_part(a), t_im_part(b)))))

axiom t_mult_im :
  (forall a:complex. forall b:complex. (t_im_part(infix_asdt(a,
  b)) = infix_pldt(infix_asdt(t_real_part(a), t_im_part(b)),
  infix_asdt(t_im_part(a), t_real_part(b)))))

axiom mult_real_real :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  (infix_asdt(a, b) = infix_asdt(r_to_c(real_part(a)),
  r_to_c(real_part(b)))))))

axiom mult_real_real1 :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  (infix_asdt(r_to_c(real_part(a)),
  r_to_c(real_part(b))) = r_to_c((real_part(a) * real_part(b)))))))

axiom mult_real_real2 :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  (real_part(infix_asdt(a, b)) = (real_part(a) * real_part(b))))))

axiom mult_real_real3 :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  (im_part(infix_asdt(a, b)) = 0.0))))

axiom complex_squared :
  (forall a:complex. (infix_asdt(a,
  a) = infix_pldt(infix_mndt(infix_asdt(t_real_part(a), t_real_part(a)),
  infix_asdt(t_im_part(a), t_im_part(a))),
  infix_asdt(infix_asdt(infix_asdt(im, infix_pldt(c_one, c_one)),
  t_real_part(a)), t_im_part(a)))))

axiom complex_squared1 :
  (forall a:complex. (t_real_part(infix_asdt(a,
  a)) = infix_mndt(infix_asdt(t_real_part(a), t_real_part(a)),
  infix_asdt(t_im_part(a), t_im_part(a)))))

axiom complex_squared2 :
  (forall a:complex. (t_im_part(infix_asdt(a,
  a)) = infix_asdt(infix_asdt(infix_pldt(c_one, c_one), t_real_part(a)),
  t_im_part(a))))

axiom complex_real_squared :
  (forall a:complex. (real_(a) -> (infix_asdt(a,
  a) = infix_asdt(t_real_part(a), t_real_part(a)))))

axiom decomp_div :
  (forall a:complex. forall b:complex. ((not (b = c_zero)) -> (infix_sldt(a,
  b) = infix_pldt(infix_sldt(t_real_part(infix_asdt(a, b)), infix_asdt(b,
  b)), infix_asdt(im, infix_sldt(t_im_part(infix_asdt(a, b)), infix_asdt(b,
  b)))))))

axiom decomp_div_real :
  (forall a:complex. forall b:complex. (real_(b) -> ((not (b = c_zero)) ->
  (infix_sldt(a, b) = infix_pldt(infix_sldt(infix_asdt(t_real_part(a), b),
  infix_asdt(b, b)), infix_asdt(im, infix_sldt(infix_asdt(t_im_part(a), b),
  infix_asdt(b, b))))))))

axiom complex_prod_fact :
  (forall a:complex. forall b:complex. (infix_asdt(a,
  b) = infix_pldt(infix_asdt(r_to_c(real_part(a)), b),
  infix_asdt(infix_asdt(im, r_to_c(im_part(a))), b))))

axiom non_zero_prod_pre :
  (forall a:complex. forall b:complex. ((not (a = c_zero)) -> ((infix_asdt(a,
  b) = c_zero) -> (im_part(b) = real_part(b)))))

axiom non_zero_prod_pre1 :
  (forall a:complex. forall b:complex. ((not (a = c_zero)) -> ((infix_asdt(a,
  b) = c_zero) -> (real_part(b) = 0.0))))

axiom non_zero_prod :
  (forall a:complex. forall b:complex. ((not (a = c_zero)) ->
  ((not (b = c_zero)) -> (not (infix_asdt(a, b) = c_zero)))))

axiom minus_c_one :
  (forall a:complex. (prefix_mndt(a) = infix_asdt(prefix_mndt(c_one), a)))

axiom mult_neg_l :
  (forall a:complex. forall b:complex. (infix_asdt(prefix_mndt(a),
  b) = prefix_mndt(infix_asdt(a, b))))

axiom mult_neg_r :
  (forall a:complex. forall b:complex. (infix_asdt(a,
  prefix_mndt(b)) = prefix_mndt(infix_asdt(a, b))))

axiom neg_neg_out : (forall a:complex. (prefix_mndt(prefix_mndt(a)) = a))

axiom div_neg_l :
  (forall a:complex. forall b:complex. ((not (b = c_zero)) ->
  (infix_sldt(prefix_mndt(a), b) = prefix_mndt(infix_sldt(a, b)))))

axiom eq_to_real :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) -> ((a = b) ->
  (real_part(a) = real_part(b))))))

axiom eq_by_real :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  ((real_part(a) = real_part(b)) -> (a = b)))))

axiom div_neg_r :
  (forall a:complex. forall b:complex. ((not (b = c_zero)) -> (infix_sldt(a,
  prefix_mndt(b)) = prefix_mndt(infix_sldt(a, b)))))

axiom invadd :
  (forall i:complex. (prefix_mndt(i) = infix_asdt(prefix_mndt(c_one), i)))

axiom noc_zeroAdd :
  (forall x:complex. forall y:complex. ((not (x = c_zero)) ->
  (not (infix_pldt(x, y) = y))))

axiom Absorbing_zero :
  (forall a:complex. forall b:complex. ((infix_asdt(a, b) = c_zero) ->
  ((not (a = c_zero)) -> (b = c_zero))))

axiom Absorbing_zero1 :
  (forall a:complex. forall b:complex. (((not (a = c_zero)) ->
  (b = c_zero)) -> (infix_asdt(a, b) = c_zero)))

axiom real_part_add :
  (forall i:complex. forall j:complex. (real_part(infix_pldt(i,
  j)) = (real_part(i) + real_part(j))))

axiom mult_im_rev :
  (forall a:complex. (infix_asdt(a, im) = infix_asdt(im, a)))

axiom im_im_elim :
  (forall a:complex. (infix_asdt(im, infix_asdt(im, a)) = prefix_mndt(a)))

axiom im_im_fact :
  (forall a:complex. forall b:complex. (infix_asdt(infix_asdt(im, a),
  infix_asdt(im, b)) = prefix_mndt(infix_asdt(a, b))))

axiom minus_minus_fact :
  (forall a:complex. forall b:complex. (infix_asdt(prefix_mndt(a),
  prefix_mndt(b)) = infix_asdt(a, b)))

axiom minus_minus_add :
  (forall a:complex. forall b:complex. (infix_pldt(prefix_mndt(a),
  prefix_mndt(b)) = prefix_mndt(infix_pldt(a, b))))

axiom minus_minus_add_rev :
  (forall a:complex. forall b:complex. (prefix_mndt(infix_pldt(a,
  b)) = infix_pldt(prefix_mndt(a), prefix_mndt(b))))

axiom minus_out_left :
  (forall a:complex. forall b:complex. (infix_asdt(prefix_mndt(a),
  b) = prefix_mndt(infix_asdt(a, b))))

axiom minus_out_right :
  (forall a:complex. forall b:complex. (infix_asdt(a,
  prefix_mndt(b)) = prefix_mndt(infix_asdt(a, b))))

axiom minus_in_left :
  (forall a:complex. forall b:complex. (prefix_mndt(infix_asdt(a,
  b)) = infix_asdt(prefix_mndt(a), b)))

axiom minus_in_right :
  (forall a:complex. forall b:complex. (prefix_mndt(infix_asdt(a,
  b)) = infix_asdt(a, prefix_mndt(b))))

axiom minus_add_out_left :
  (forall a:complex. forall b:complex. (infix_pldt(prefix_mndt(a),
  b) = prefix_mndt(infix_pldt(a, prefix_mndt(b)))))

axiom minus_as_add_opp :
  (forall a:complex. forall b:complex. (infix_mndt(a, b) = infix_pldt(a,
  prefix_mndt(b))))

axiom minus_add_out_right :
  (forall a:complex. forall b:complex. (infix_pldt(a,
  prefix_mndt(b)) = prefix_mndt(infix_pldt(prefix_mndt(a), b))))

axiom minus_add_in :
  (forall a:complex. forall b:complex. (prefix_mndt(infix_pldt(a,
  b)) = infix_pldt(prefix_mndt(a), prefix_mndt(b))))

axiom minus_add_out :
  (forall a:complex. forall b:complex. (infix_pldt(prefix_mndt(a),
  prefix_mndt(b)) = prefix_mndt(infix_pldt(a, b))))

axiom minus_eq :
  (forall a:complex. forall b:complex. ((a = b) ->
  (prefix_mndt(a) = prefix_mndt(b))))

axiom im_out_right :
  (forall a:complex. forall b:complex. (infix_asdt(infix_asdt(im, a),
  b) = infix_asdt(im, infix_asdt(a, b))))

axiom im_out_left :
  (forall a:complex. forall b:complex. (infix_asdt(a, infix_asdt(im,
  b)) = infix_asdt(im, infix_asdt(a, b))))

axiom im_part_add :
  (forall i:complex. forall j:complex. (im_part(infix_pldt(i,
  j)) = (im_part(i) + im_part(j))))

axiom injective_real_part :
  (forall i:complex. forall j:complex.
  ((not (real_part(i) = real_part(j))) -> (not (i = j))))

axiom injective_im_part :
  (forall i:complex. forall j:complex. ((not (im_part(i) = im_part(j))) ->
  (not (i = j))))

axiom minus_distr_four :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_asdt(a, b), infix_asdt(infix_asdt(prefix_mndt(b), c),
  d)) = infix_asdt(infix_mndt(a, infix_asdt(c, d)), b)))

axiom complex_decomp :
  (forall i:complex. (i = infix_pldt(r_to_c(real_part(i)), infix_asdt(im,
  r_to_c(im_part(i))))))

axiom simpl_frac :
  (forall x:complex. forall y:complex. ((not (y = c_zero)) ->
  (infix_sldt(infix_asdt(x, y), y) = x)))

axiom simpl_frac_ :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (y = c_zero)) -> ((not (z = c_zero)) -> (infix_sldt(infix_asdt(x, y),
  infix_asdt(z, y)) = infix_sldt(x, z)))))

axiom fact_frac :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (z = c_zero)) -> (infix_sldt(infix_asdt(x, y), z) = infix_asdt(x,
  infix_sldt(y, z)))))

axiom fact_frac_rev :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (z = c_zero)) -> (infix_asdt(x, infix_sldt(y,
  z)) = infix_sldt(infix_asdt(x, y), z))))

axiom mult_sym :
  (forall x:complex. forall y:complex. (infix_asdt(x, y) = infix_asdt(y, x)))

axiom inv_mult :
  (forall x:complex. forall y:complex. ((not (x = c_zero)) ->
  ((not (y = c_zero)) -> (infix_asdt(infix_sldt(c_one, x), infix_sldt(c_one,
  y)) = infix_sldt(c_one, infix_asdt(x, y))))))

axiom div_div :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (y = c_zero)) -> ((not (z = c_zero)) -> (infix_sldt(infix_sldt(x, y),
  z) = infix_sldt(x, infix_asdt(y, z))))))

axiom div_div_rev :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (y = c_zero)) -> ((not (z = c_zero)) -> (infix_sldt(x, infix_asdt(y,
  z)) = infix_sldt(infix_sldt(x, y), z)))))

axiom involutive_inv :
  (forall a:complex. ((not (a = c_zero)) -> (infix_sldt(c_one,
  infix_sldt(c_one, a)) = a)))

axiom twice :
  (forall i:complex. (infix_asdt(infix_pldt(c_one, c_one), i) = infix_pldt(i,
  i)))

axiom twice_half : (infix_asdt(infix_pldt(c_one, c_one), infix_sldt(c_one,
  infix_pldt(c_one, c_one))) = c_one)

axiom half_plus_half :
  (forall i:complex. (infix_pldt(infix_sldt(i, infix_pldt(c_one, c_one)),
  infix_sldt(i, infix_pldt(c_one, c_one))) = i))

axiom decomp_inv_real :
  (forall a:complex. (real_(a) -> ((not (a = c_zero)) -> (infix_sldt(c_one,
  a) = infix_sldt(c_one, t_real_part(a))))))

axiom decomp_inv_real1 :
  (forall a:complex. (real_(a) -> ((not (a = c_zero)) ->
  real_(infix_sldt(c_one, a)))))

axiom decomp_inv_real2 :
  (forall a:complex. (real_(a) -> ((not (a = c_zero)) ->
  (t_real_part(infix_sldt(c_one, a)) = infix_sldt(c_one, t_real_part(a))))))

axiom decomp_inv_real3 :
  (forall a:complex. (real_(a) -> ((not (a = c_zero)) ->
  (real_part(infix_sldt(c_one, a)) = infix_slas(1.0, real_part(a))))))

axiom mult_div_comm :
  (forall x:complex. forall y:complex. forall z:complex. forall t:complex.
  ((not (z = c_zero)) -> ((not (t = c_zero)) -> (infix_sldt(infix_asdt(x, y),
  infix_asdt(z, t)) = infix_asdt(infix_sldt(x, z), infix_sldt(y, t))))))

axiom mult_div_comm_rev :
  (forall x:complex. forall y:complex. forall z:complex. forall t:complex.
  ((not (z = c_zero)) -> ((not (t = c_zero)) -> (infix_asdt(infix_sldt(x, z),
  infix_sldt(y, t)) = infix_sldt(infix_asdt(x, y), infix_asdt(z, t))))))

predicate infix_lseqdt(x: complex, y: complex) = ((real_(x) and (real_(y) and
  (real_part(x) <= real_part(y)))) or infix_eqeq(x, y))

predicate infix_lsdt(x: complex, y: complex) = (infix_lseqdt(x, y) and
  (not infix_eqeq(x, y)))

predicate infix_gtdt(x: complex, y: complex) = (infix_lseqdt(y, x) and
  (not infix_eqeq(x, y)))

axiom leq_left_real :
  (forall a:complex. forall b:complex. (infix_lseqdt(a, b) -> (real_(a) ->
  real_(b))))

axiom leq_right_real :
  (forall a:complex. forall b:complex. (infix_lseqdt(a, b) -> (real_(b) ->
  real_(a))))

axiom inf_left_real :
  (forall a:complex. forall b:complex. (infix_lsdt(a, b) -> real_(a)))

axiom inf_right_real :
  (forall a:complex. forall b:complex. (infix_lsdt(a, b) -> real_(b)))

axiom inf_from_real :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  (infix_lsas(real_part(a), real_part(b)) -> infix_lsdt(a, b)))))

axiom inf_to_real :
  (forall a:complex. forall b:complex. (infix_lsdt(a, b) ->
  infix_lsas(real_part(a), real_part(b))))

axiom leq_left_not_real_a :
  (forall a:complex. forall b:complex. (infix_lseqdt(a, b) ->
  ((not real_(a)) -> (a = b))))

axiom leq_left_not_real_b :
  (forall a:complex. forall b:complex. (infix_lseqdt(a, b) ->
  ((not real_(b)) -> (a = b))))

axiom Refl : (forall x:complex. infix_lseqdt(x, x))

axiom Trans :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(x,
  y) -> (infix_lseqdt(y, z) -> infix_lseqdt(x, z))))

axiom Antisymm :
  (forall x:complex. forall y:complex. (infix_lseqdt(x, y) ->
  (infix_lseqdt(y, x) -> (x = y))))

axiom Refl1 : (forall x:complex. infix_lseqdt(x, x))

axiom Trans1 :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(y,
  x) -> (infix_lseqdt(z, y) -> infix_lseqdt(z, x))))

axiom Antisymm1 :
  (forall x:complex. forall y:complex. (infix_lseqdt(y, x) ->
  (infix_lseqdt(x, y) -> (x = y))))

axiom Trans2 :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lsdt(x, y) ->
  (infix_lsdt(y, z) -> infix_lsdt(x, z))))

axiom Asymm :
  (forall x:complex. forall y:complex. (infix_lsdt(x, y) ->
  (not infix_lsdt(y, x))))

axiom Trans3 :
  (forall x:complex. forall y:complex. forall z:complex. (infix_gtdt(x, y) ->
  (infix_gtdt(y, z) -> infix_gtdt(x, z))))

axiom Asymm1 :
  (forall x:complex. forall y:complex. (infix_gtdt(x, y) ->
  (not infix_gtdt(y, x))))

axiom r_to_c_inf :
  (forall i:real. forall j:real. (infix_lseqdt(r_to_c(i), r_to_c(j)) ->
  (i <= j)))

axiom r_to_c_inf1 :
  (forall i:real. forall j:real. ((i <= j) -> infix_lseqdt(r_to_c(i),
  r_to_c(j))))

axiom reali_is_its_real_part :
  (forall a:complex. (real_(a) -> (a = r_to_c(real_part(a)))))

axiom inf_from_r :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  ((real_part(a) <= real_part(b)) -> infix_lseqdt(a, b)))))

axiom strict_inf_from_r :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  (infix_lsas(real_part(a), real_part(b)) -> infix_lsdt(a, b)))))

axiom positive_inv_t :
  (forall x:complex. (infix_lsdt(c_zero, x) -> infix_lsdt(c_zero,
  infix_sldt(c_one, x))))

logic pi : complex

axiom piqtdef : infix_lsdt(r_to_c(3.0), pi)

axiom real_pi : real_(pi)

axiom pi_sup_one : infix_lsdt(c_one, pi)

axiom pi_sup_zero : infix_lsdt(c_zero, pi)

axiom compat_order_mult :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(x,
  y) -> (real_(x) -> (real_(y) -> (real_(z) -> (infix_lseqdt(c_zero, z) ->
  infix_lseqdt(infix_asdt(x, z), infix_asdt(y, z))))))))

axiom compat_order_add :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(x,
  y) -> (real_(x) -> (real_(y) -> (real_(z) -> infix_lseqdt(infix_pldt(x, z),
  infix_pldt(y, z)))))))

axiom compat_order_add_left :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(x,
  y) -> (real_(x) -> (real_(y) -> (real_(z) -> infix_lseqdt(infix_pldt(z, x),
  infix_pldt(z, y)))))))

axiom compat_order_add_both :
  (forall x:complex. forall y:complex. forall z:complex. forall t:complex.
  (infix_lseqdt(x, y) -> (infix_lseqdt(z, t) -> (real_(x) -> (real_(y) ->
  (real_(z) -> (real_(t) -> infix_lseqdt(infix_pldt(z, x), infix_pldt(t,
  y)))))))))

axiom compat_order_substr :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(x,
  y) -> (real_(x) -> (real_(y) -> (real_(z) -> infix_lseqdt(infix_mndt(x, z),
  infix_mndt(y, z)))))))

axiom compat_inf_mult :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lsdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_lsdt(infix_asdt(x, z), infix_asdt(y, z))))))))

axiom transitive_infeq :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lseqdt(a,
  b) -> (infix_lseqdt(b, c) -> infix_lseqdt(a, c))))

axiom transitive_infeq_inf :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lseqdt(a,
  b) -> (infix_lsdt(b, c) -> infix_lsdt(a, c))))

axiom transitive_inf_infeq :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(a, b) ->
  (infix_lseqdt(b, c) -> infix_lsdt(a, c))))

axiom transitive_inf :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(a, b) ->
  (infix_lsdt(b, c) -> infix_lsdt(a, c))))

axiom pi_sup_ttwo : infix_lsdt(infix_pldt(c_one, c_one), pi)

axiom transitive_leq_inv_r :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(b) -> (real_(c) -> (infix_lseqdt(a, b) -> (infix_lseqdt(b,
  infix_sldt(c_one, c)) -> (infix_lseqdt(c_one, c) -> infix_lseqdt(a,
  b))))))))

axiom transitive_leq_inv_r1 :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(b) -> (real_(c) -> (infix_lseqdt(a, b) -> (infix_lseqdt(b,
  infix_sldt(c_one, c)) -> (infix_lseqdt(c_one, c) -> infix_lseqdt(b,
  c_one))))))))

axiom compat_inf_mult_left :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lsdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_lsdt(infix_asdt(z, x), infix_asdt(z, y))))))))

axiom compat_inf_mult_both :
  (forall x:complex. forall y:complex. forall z:complex. forall t:complex.
  (infix_lsdt(x, y) -> (real_(x) -> (real_(y) -> (real_(z) ->
  ((infix_lsdt(c_zero, z) and infix_lsdt(z, t)) -> (infix_lsdt(c_zero, y) ->
  infix_lsdt(infix_asdt(z, x), infix_asdt(t, y)))))))))

axiom compat_inf_add :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lsdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> infix_lsdt(infix_pldt(x, z),
  infix_pldt(y, z)))))))

axiom compat_inf_add_left :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lsdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> infix_lsdt(infix_pldt(z, x),
  infix_pldt(z, y)))))))

axiom compat_inf_add_both :
  (forall x:complex. forall y:complex. forall z:complex. forall t:complex.
  (infix_lsdt(x, y) -> (infix_lsdt(z, t) -> infix_lsdt(infix_pldt(x, z),
  infix_pldt(y, t)))))

axiom compat_inf_substr :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lsdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> infix_lsdt(infix_mndt(x, z),
  infix_mndt(y, z)))))))

axiom real_inv :
  (forall x:complex. (real_(x) -> ((not (x = c_zero)) ->
  real_(infix_sldt(c_one, x)))))

axiom compat_order_mult_rev :
  (forall x:complex. forall y:complex. forall z:complex. (real_(x) ->
  (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  (infix_lseqdt(infix_asdt(x, z), infix_asdt(y, z)) -> infix_lseqdt(x,
  y)))))))

axiom compat_order_mult_left :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(x,
  y) -> (real_(x) -> (real_(y) -> (real_(z) -> (infix_lseqdt(c_zero, z) ->
  infix_lseqdt(infix_asdt(z, x), infix_asdt(z, y))))))))

axiom strict_compat_order_mult :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lsdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_lsdt(infix_asdt(x, z), infix_asdt(y, z))))))))

axiom strict_compat_order_mult_left :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lsdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_lsdt(infix_asdt(z, x), infix_asdt(z, y))))))))

axiom complete_order_real :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  ((not (x = y)) -> ((not infix_lsdt(x, y)) -> infix_lsdt(y, x))))))

axiom complete_order_real_ :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  ((not infix_lsdt(x, y)) -> ((not infix_lsdt(y, x)) -> (y = x))))))

axiom compat_order_mult_both :
  (forall x:complex. forall y:complex. forall z:complex. forall t:complex.
  ((infix_lseqdt(c_zero, x) and infix_lseqdt(x, y)) -> ((infix_lseqdt(c_zero,
  z) and infix_lseqdt(z, t)) -> infix_lseqdt(infix_asdt(z, x), infix_asdt(t,
  y)))))

axiom inf_to_non_sup_eq :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  (infix_lsdt(x, y) -> (not infix_lseqdt(y, x))))))

axiom sup_eq_to_non_inf :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  (infix_lseqdt(y, x) -> (not infix_lsdt(x, y))))))

axiom sup_to_inf :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  (infix_gtdt(x, y) -> infix_lsdt(y, x)))))

axiom inf_to_sup :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  (infix_lsdt(x, y) -> infix_gtdt(y, x)))))

axiom sup_to_non_inf_eq :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  (infix_gtdt(x, y) -> (not infix_lseqdt(x, y))))))

axiom inf_eq_to_non_sup :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  (infix_lseqdt(x, y) -> (not infix_gtdt(x, y))))))

axiom non_inf_eq_to_sup :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  ((not infix_lseqdt(x, y)) -> infix_gtdt(x, y)))))

axiom non_sup_toinf_eq :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  ((not infix_gtdt(x, y)) -> infix_lseqdt(x, y)))))

axiom real_mult :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  real_(infix_asdt(x, y)))))

axiom real_add :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  real_(infix_pldt(x, y)))))

axiom real_substr :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  real_(infix_mndt(x, y)))))

axiom inv_pos :
  (forall x:complex. (real_(x) -> (infix_lsdt(c_zero, x) ->
  infix_lsdt(c_zero, infix_sldt(c_one, x)))))

axiom lower_over_cons :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(c_zero,
  c) -> (infix_lseqdt(c_zero, a) -> (infix_lseqdt(a, b) ->
  infix_lseqdt(infix_sldt(a, c), infix_sldt(b, c))))))

axiom eq_to_leq_t :
  (forall a:complex. forall b:complex. (real_(a) -> ((a = b) ->
  infix_lseqdt(a, b))))

axiom real_minus : (forall a:complex. (real_(a) -> real_(prefix_mndt(a))))

axiom compat_r_to_c_infeq :
  (forall a:real. forall b:real. ((a <= b) -> infix_lseqdt(r_to_c(a),
  r_to_c(b))))

axiom compat_r_to_c_inf :
  (forall a:real. forall b:real. (infix_lsas(a, b) -> infix_lsdt(r_to_c(a),
  r_to_c(b))))

axiom compat_r_to_c_supeq :
  (forall a:real. forall b:real. ((b <= a) -> infix_lseqdt(r_to_c(b),
  r_to_c(a))))

axiom compat_r_to_c_sup :
  (forall a:real. forall b:real. (infix_lsas(b, a) -> infix_gtdt(r_to_c(a),
  r_to_c(b))))

axiom unic_inv :
  (forall i:complex. forall j:complex. ((not (i = c_zero)) -> ((infix_asdt(i,
  j) = c_one) -> (j = inv(i)))))

axiom inf_eq_def :
  (forall x:complex. forall y:complex. (infix_lseqdt(x, y) -> ((real_(x) and
  (real_(y) and (real_part(x) <= real_part(y)))) or (x = y))))

axiom inf_eq_def1 :
  (forall x:complex. forall y:complex. (((real_(x) and (real_(y) and
  (real_part(x) <= real_part(y)))) or (x = y)) -> infix_lseqdt(x, y)))

axiom inf_minus :
  (forall x:complex. forall y:complex. (infix_lsdt(x, y) ->
  infix_lsdt(prefix_mndt(y), prefix_mndt(x))))

axiom absorbing_zero :
  (forall a:complex. forall b:complex. ((infix_asdt(a, b) = c_zero) ->
  ((not (a = c_zero)) -> (b = c_zero))))

axiom absorbing_zero1 :
  (forall a:complex. forall b:complex. ((infix_asdt(a, b) = c_zero) ->
  ((not (b = c_zero)) -> (a = c_zero))))

axiom inf_zero_inv :
  (forall z:complex. (infix_lsdt(c_zero, z) -> infix_lsdt(c_zero,
  infix_sldt(c_one, z))))

axiom inf_zero_inv1 :
  (forall z:complex. (infix_lsdt(c_zero, z) -> infix_lseqdt(c_zero,
  infix_sldt(c_one, z))))

axiom mult_pos :
  (forall x:complex. forall y:complex. (infix_lseqdt(c_zero, x) ->
  (infix_lseqdt(c_zero, y) -> infix_lseqdt(c_zero, infix_asdt(x, y)))))

axiom simpl_leq_mult_div :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (infix_lsdt(c_zero, b) -> (infix_lseqdt(infix_asdt(a, b), c) ->
  infix_lseqdt(a, infix_asdt(infix_sldt(c_one, b), c))))))

axiom mult_leq_c_one_leq :
  (forall a:complex. forall b:complex. (infix_lseqdt(c_zero, a) ->
  ((infix_lseqdt(c_zero, b) and infix_lseqdt(b, c_one)) ->
  infix_lseqdt(infix_asdt(a, b), a))))

axiom mult_leq_c_one_leq_gen :
  (forall a:complex. forall aqt:complex. forall b:complex.
  (infix_lseqdt(c_zero, a) -> ((infix_lseqdt(c_zero, b) and infix_lseqdt(b,
  c_one)) -> ((a = aqt) -> infix_lseqdt(infix_asdt(a, b), aqt)))))

axiom mult_leq_c_one :
  (forall a:complex. forall b:complex. (infix_lseqdt(c_zero, a) ->
  ((exists c:complex. (infix_lseqdt(a, c) and (b = infix_sldt(c_one, c)))) ->
  (infix_lsdt(c_zero, b) -> infix_lseqdt(infix_asdt(a, b), c_one)))))

axiom mult_leq_c_one_expl :
  (forall a:complex. forall b:complex. forall d:complex.
  (infix_lseqdt(c_zero, a) -> (infix_lseqdt(a, d) -> (infix_lsdt(c_zero,
  d) -> (infix_lseqdt(b, infix_sldt(c_one, d)) -> infix_lseqdt(infix_asdt(a,
  b), c_one))))))

axiom mult_leq_c_one_rev :
  (forall a:complex. forall b:complex. (infix_lseqdt(c_zero, a) ->
  (infix_lsdt(c_zero, b) -> (infix_lseqdt(infix_asdt(a, b), c_one) ->
  infix_lseqdt(a, infix_sldt(c_one, b))))))

axiom simpl_leq_mult :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(c_zero,
  b) -> (infix_lseqdt(a, c) -> infix_lseqdt(infix_asdt(a, b), infix_asdt(c,
  b)))))

axiom simpl_leq_mult_inv :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(c_zero,
  a) -> (infix_lsdt(c_zero, b) -> (infix_lsdt(c_zero, c) -> (infix_lseqdt(a,
  infix_sldt(c_one, infix_asdt(b, c))) -> infix_lseqdt(infix_asdt(a, b),
  infix_sldt(c_one, c)))))))

axiom mult_to_div_leq :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (infix_lsdt(c_zero, b) -> (infix_lseqdt(infix_asdt(a, b), c) ->
  infix_lseqdt(a, infix_asdt(infix_sldt(c_one, b), c))))))

axiom mult_div :
  (forall x:complex. forall y:complex. (infix_lseqdt(c_zero, x) ->
  (infix_lsdt(c_zero, y) -> infix_lseqdt(c_zero, infix_sldt(x, y)))))

axiom strict_mult_pos :
  (forall x:complex. forall y:complex. (infix_lsdt(c_zero, x) ->
  (infix_lsdt(c_zero, y) -> infix_lsdt(c_zero, infix_asdt(x, y)))))

axiom rewrite_supeq : true

axiom rewrite_sup :
  (forall x:complex. forall y:complex. (infix_lsdt(x, y) -> infix_gtdt(y,
  x)))

axiom inv_order_complex :
  (forall a:complex. forall b:complex. (infix_lsdt(c_zero, a) ->
  (infix_lsdt(c_zero, b) -> (infix_lseqdt(a, b) ->
  infix_lseqdt(infix_sldt(c_one, b), infix_sldt(c_one, a))))))

axiom compat_inv_order :
  (forall a:complex. forall b:complex. forall c:complex. ((infix_lsdt(c_zero,
  a) and infix_lseqdt(a, b)) -> (infix_lseqdt(c, infix_sldt(c_one, b)) ->
  infix_lseqdt(c, infix_sldt(c_one, a)))))

axiom leq_by_div_simpl :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_lseqdt(c_zero, a) -> ((infix_lsdt(c_zero, b) and infix_lseqdt(b,
  c)) -> infix_lseqdt(infix_sldt(a, c), infix_sldt(a, b)))))

axiom leq_by_div :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_lseqdt(c_zero, a) -> ((infix_lsdt(c_zero, b) and infix_lseqdt(b,
  c)) -> infix_lseqdt(infix_sldt(a, c), infix_sldt(a, b)))))

axiom strict_pos_div :
  (forall x:complex. forall y:complex. (infix_lsdt(c_zero, x) ->
  (infix_lsdt(c_zero, y) -> infix_lsdt(c_zero, infix_sldt(x, y)))))

axiom inf_def :
  (forall x:complex. forall y:complex. (infix_lsdt(x, y) -> real_(x)))

axiom inf_def1 :
  (forall x:complex. forall y:complex. (infix_lsdt(x, y) -> real_(y)))

axiom inf_def2 :
  (forall x:complex. forall y:complex. (infix_lsdt(x, y) ->
  infix_lsas(real_part(x), real_part(y))))

axiom inf_def3 :
  (forall x:complex. forall y:complex. ((real_(x) and (real_(y) and
  infix_lsas(real_part(x), real_part(y)))) -> infix_lsdt(x, y)))

axiom sup_eq_def :
  (forall x:complex. forall y:complex. (infix_lseqdt(y, x) -> ((real_(x) and
  (real_(y) and (real_part(y) <= real_part(x)))) or (x = y))))

axiom sup_eq_def1 :
  (forall x:complex. forall y:complex. (((real_(x) and (real_(y) and
  (real_part(y) <= real_part(x)))) or (x = y)) -> infix_lseqdt(y, x)))

axiom sup_def :
  (forall x:complex. forall y:complex. (infix_gtdt(x, y) -> real_(x)))

axiom sup_def1 :
  (forall x:complex. forall y:complex. (infix_gtdt(x, y) -> real_(y)))

axiom sup_def2 :
  (forall x:complex. forall y:complex. (infix_gtdt(x, y) ->
  infix_lsas(real_part(y), real_part(x))))

axiom sup_def3 :
  (forall x:complex. forall y:complex. ((real_(x) and (real_(y) and
  infix_lsas(real_part(y), real_part(x)))) -> infix_gtdt(x, y)))

axiom assoc_mult_div :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (z = c_zero)) -> (infix_asdt(x, infix_sldt(y,
  z)) = infix_sldt(infix_asdt(x, y), z))))

axiom assoc_mult_div_rev :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (z = c_zero)) -> (infix_sldt(infix_asdt(x, y), z) = infix_asdt(x,
  infix_sldt(y, z)))))

axiom subst_zero : (forall a:complex. (infix_mndt(a, c_zero) = a))

axiom subst_zero_gen :
  (forall a:complex. forall b:complex. ((b = c_zero) -> (infix_mndt(a,
  b) = a)))

axiom transitive_inf_inv_r :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lseqdt(a,
  b) -> (infix_lseqdt(b, infix_sldt(c_one, c)) -> (infix_lsdt(c_one, c) ->
  infix_lseqdt(a, b)))))

axiom transitive_inf_inv_r1 :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lseqdt(a,
  b) -> (infix_lseqdt(b, infix_sldt(c_one, c)) -> (infix_lsdt(c_one, c) ->
  infix_lsdt(b, c_one)))))

axiom infeq_scal_r :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lseqdt(a,
  c) -> (infix_lseqdt(c_zero, b) -> infix_lseqdt(infix_asdt(a, b),
  infix_asdt(c, b)))))

axiom infeq_scal_l :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lseqdt(a,
  c) -> (infix_lseqdt(c_zero, b) -> infix_lseqdt(infix_asdt(b, a),
  infix_asdt(b, c)))))

axiom transitive_supeq :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lseqdt(b,
  a) -> (infix_lseqdt(c, b) -> infix_lseqdt(c, a))))

axiom transitive_inf_l :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(a, b) ->
  (infix_lseqdt(b, c) -> infix_lsdt(a, c))))

axiom transitive_sup_l :
  (forall a:complex. forall b:complex. forall c:complex. (infix_gtdt(a, b) ->
  (infix_lseqdt(c, b) -> infix_gtdt(a, c))))

axiom transitive_inf_r :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lseqdt(a,
  b) -> (infix_lsdt(b, c) -> infix_lsdt(a, c))))

axiom transitive_sup_r :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lseqdt(b,
  a) -> (infix_gtdt(b, c) -> infix_gtdt(a, c))))

axiom simpl_frac_r :
  (forall x:complex. forall y:complex. ((not (x = c_zero)) -> (infix_asdt(x,
  infix_sldt(y, x)) = y)))

axiom compat_mult_sup_eq_right :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_lseqdt(c_zero, a) -> (infix_lseqdt(c, b) ->
  infix_lseqdt(infix_asdt(a, c), infix_asdt(a, b)))))

axiom compat_mult_sup_right :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(c_zero,
  a) -> (infix_gtdt(b, c) -> infix_gtdt(infix_asdt(a, b), infix_asdt(a,
  c)))))

axiom compat_mult_inf_right :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(c_zero,
  a) -> (infix_lsdt(b, c) -> infix_lsdt(infix_asdt(a, b), infix_asdt(a,
  c)))))

axiom infeq_to_supeq : true

axiom infeq_inv :
  (forall a:complex. forall b:complex. (infix_lseqdt(a, b) ->
  infix_lseqdt(prefix_mndt(b), prefix_mndt(a))))

axiom infeq_inv_add_l :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_lseqdt(infix_pldt(a, c), b) -> (real_(a) -> (real_(c) ->
  infix_lseqdt(a, infix_mndt(b, c))))))

axiom infeq_inv_add_r :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(c) -> (infix_lseqdt(a, infix_pldt(b, c)) ->
  infix_lseqdt(infix_mndt(a, c), b)))))

axiom r_to_c_surj :
  (forall x:real. forall y:real. ((not (x = y)) ->
  (not (r_to_c(x) = r_to_c(y)))))

axiom r_to_c_inf_rev :
  (forall x:real. forall y:real. (infix_lsas(x, y) -> infix_lsdt(r_to_c(x),
  r_to_c(y))))

axiom div_simpl :
  (forall a:complex. forall b:complex. (infix_lsdt(c_zero, a) ->
  (infix_lsdt(c_zero, b) -> (infix_sldt(c_one, b) = infix_sldt(a,
  infix_asdt(a, b))))))

axiom infeq_inv_subs_l :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(b) -> (real_(c) -> (infix_lseqdt(infix_mndt(a, c), b) ->
  infix_lseqdt(a, infix_pldt(b, c)))))))

axiom infeq_inv_subs_r :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(b) -> (real_(c) -> (infix_lseqdt(a, infix_mndt(b, c)) ->
  infix_lseqdt(infix_pldt(a, c), b))))))

axiom infeq_pos_elim :
  (forall a:complex. forall b:complex. (real_(a) -> (infix_lseqdt(c_zero,
  b) -> infix_lseqdt(a, infix_pldt(a, b)))))

axiom infeq_pos_elim_add :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(b) -> (real_(c) -> (infix_lseqdt(c_zero, b) -> (infix_lseqdt(c,
  a) -> infix_lseqdt(c, infix_pldt(a, b))))))))

axiom supeq_elim_left :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  (infix_lseqdt(b, a) -> infix_lseqdt(infix_mndt(b, a), c_zero)))))

axiom sup_elim_left :
  (forall a:complex. forall b:complex. (infix_gtdt(a, b) ->
  infix_gtdt(c_zero, infix_mndt(b, a))))

axiom infeq_elim_left :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  (infix_lseqdt(a, b) -> infix_lseqdt(c_zero, infix_mndt(b, a))))))

axiom inf_elim_left :
  (forall a:complex. forall b:complex. (infix_lsdt(a, b) ->
  infix_lsdt(c_zero, infix_mndt(b, a))))

axiom t_im_real :
  (forall a:complex. forall b:complex. (t_im_part(infix_asdt(a,
  b)) = infix_pldt(infix_asdt(t_real_part(a), t_im_part(b)),
  infix_asdt(t_im_part(a), t_real_part(b)))))

axiom t_decomp_mult :
  (forall a:complex. forall b:complex. (infix_asdt(a,
  b) = infix_pldt(infix_mndt(infix_asdt(t_real_part(a), t_real_part(b)),
  infix_asdt(t_im_part(a), t_im_part(b))), infix_asdt(im,
  infix_pldt(infix_asdt(t_real_part(a), t_im_part(b)),
  infix_asdt(t_im_part(a), t_real_part(b)))))))

axiom t_complex_decomp :
  (forall i:complex. (i = infix_pldt(t_real_part(i), infix_asdt(im,
  t_im_part(i)))))

axiom t_unic_decomp :
  (forall i:complex. forall a:complex. forall b:complex. (real_(a) ->
  (real_(b) -> ((i = infix_pldt(a, infix_asdt(im, b))) ->
  (a = t_real_part(i))))))

axiom t_unic_decomp1 :
  (forall i:complex. forall a:complex. forall b:complex. (real_(a) ->
  (real_(b) -> ((i = infix_pldt(a, infix_asdt(im, b))) ->
  (b = t_im_part(i))))))

axiom t_decomp_minus :
  (forall i:complex. forall a:complex. forall b:complex. (real_(a) ->
  (real_(b) -> ((i = infix_mndt(a, infix_asdt(im, b))) ->
  (a = t_real_part(i))))))

axiom t_decomp_minus1 :
  (forall i:complex. forall a:complex. forall b:complex. (real_(a) ->
  (real_(b) -> ((i = infix_mndt(a, infix_asdt(im, b))) ->
  (prefix_mndt(b) = t_im_part(i))))))

axiom real_sum :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  real_(infix_pldt(x, y)))))

axiom real_diff :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  real_(infix_mndt(x, y)))))

axiom pure_im_sum :
  (forall x:complex. forall y:complex. (pure_im_(x) -> (pure_im_(y) ->
  pure_im_(infix_pldt(x, y)))))

axiom equal_decomp :
  (forall x:complex. forall y:complex. ((real_part(x) = real_part(y)) ->
  ((im_part(x) = im_part(y)) -> (x = y))))

axiom t_equal_decomp :
  (forall x:complex. forall y:complex. ((t_real_part(x) = t_real_part(y)) ->
  ((t_im_part(x) = t_im_part(y)) -> (x = y))))

axiom pure_im_diff :
  (forall x:complex. forall y:complex. (pure_im_(x) -> (pure_im_(y) ->
  pure_im_(infix_mndt(x, y)))))

axiom real_div :
  (forall x:complex. forall y:complex. (real_(x) -> ((not (y = c_zero)) ->
  (real_(y) -> real_(infix_sldt(x, y))))))

axiom mult_im_im :
  (forall a:complex. forall b:complex. (pure_im_(a) -> (pure_im_(b) ->
  (infix_asdt(a, b) = infix_asdt(infix_asdt(im, im),
  infix_asdt(r_to_c(im_part(a)), r_to_c(im_part(b))))))))

axiom mult_im_im1 :
  (forall a:complex. forall b:complex. (pure_im_(a) -> (pure_im_(b) ->
  (infix_asdt(a, b) = prefix_mndt(r_to_c((im_part(a) * im_part(b))))))))

axiom mult_im_im2 :
  (forall a:complex. forall b:complex. (pure_im_(a) -> (pure_im_(b) ->
  (real_part(infix_asdt(a, b)) = (-(im_part(a) * im_part(b)))))))

axiom mult_im_im3 :
  (forall a:complex. forall b:complex. (pure_im_(a) -> (pure_im_(b) ->
  (im_part(infix_asdt(a, b)) = 0.0))))

axiom mult_real_im :
  (forall a:complex. forall b:complex. (real_(a) -> (pure_im_(b) ->
  (infix_asdt(a, b) = infix_asdt(im, infix_asdt(r_to_c(real_part(a)),
  r_to_c(im_part(b))))))))

axiom mult_real_im1 :
  (forall a:complex. forall b:complex. (real_(a) -> (pure_im_(b) ->
  (infix_asdt(a, b) = infix_asdt(im, r_to_c((real_part(a) * im_part(b))))))))

axiom mult_real_im2 :
  (forall a:complex. forall b:complex. (real_(a) -> (pure_im_(b) ->
  (real_part(infix_asdt(a, b)) = 0.0))))

axiom mult_real_im3 :
  (forall a:complex. forall b:complex. (real_(a) -> (pure_im_(b) ->
  (im_part(infix_asdt(a, b)) = (real_part(a) * im_part(b))))))

axiom mult_im_real :
  (forall a:complex. forall b:complex. (pure_im_(a) -> (real_(b) ->
  (infix_asdt(a, b) = infix_asdt(im, infix_asdt(r_to_c(im_part(a)),
  r_to_c(real_part(b))))))))

axiom mult_im_real1 :
  (forall a:complex. forall b:complex. (pure_im_(a) -> (real_(b) ->
  (infix_asdt(a, b) = infix_asdt(im, r_to_c((im_part(a) * real_part(b))))))))

axiom mult_im_real2 :
  (forall a:complex. forall b:complex. (pure_im_(a) -> (real_(b) ->
  (real_part(infix_asdt(a, b)) = 0.0))))

axiom mult_im_real3 :
  (forall a:complex. forall b:complex. (pure_im_(a) -> (real_(b) ->
  (im_part(infix_asdt(a, b)) = (im_part(a) * real_part(b))))))

axiom decomp_mult_gen :
  (forall a:complex. forall b:complex. (real_part(infix_asdt(a,
  b)) = ((real_part(a) * real_part(b)) - (im_part(a) * im_part(b)))))

axiom decomp_mult_gen1 :
  (forall a:complex. forall b:complex. (im_part(infix_asdt(a,
  b)) = ((real_part(a) * im_part(b)) + (im_part(a) * real_part(b)))))

axiom inv_real :
  (forall a:complex. ((not (a = c_zero)) -> (real_(a) ->
  (real_part(infix_sldt(c_one, a)) = infix_slas(1.0, real_part(a))))))

axiom inv_real1 :
  (forall a:complex. ((not (a = c_zero)) -> (real_(a) ->
  real_(infix_sldt(c_one, a)))))

axiom div_real_real :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  ((not (b = c_zero)) -> (real_part(infix_sldt(a,
  b)) = infix_slas(real_part(a), real_part(b)))))))

axiom zeroLessOne : infix_lseqdt(c_zero, c_one)

axiom compatOrderAdd :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(x,
  y) -> (real_(x) -> (real_(y) -> (real_(z) -> infix_lseqdt(infix_pldt(x, z),
  infix_pldt(y, z)))))))

axiom positive_add :
  (forall x:complex. forall y:complex. (infix_lseqdt(c_zero, x) ->
  (infix_lseqdt(c_zero, y) -> infix_lseqdt(c_zero, infix_pldt(x, y)))))

axiom strict_positive_add_l :
  (forall x:complex. forall y:complex. (infix_lsdt(c_zero, x) ->
  (infix_lseqdt(c_zero, y) -> infix_lsdt(c_zero, infix_pldt(x, y)))))

axiom strict_compatOrderAdd :
  (forall x:complex. forall y:complex. forall z:complex. forall t:complex.
  (infix_lsdt(x, y) -> (infix_lsdt(z, t) -> (real_(x) -> (real_(y) ->
  (real_(z) -> (real_(t) -> infix_lsdt(infix_pldt(x, z), infix_pldt(y,
  t)))))))))

axiom compat_sup_add :
  (forall x:complex. forall y:complex. forall z:complex. forall t:complex.
  (infix_gtdt(x, y) -> (infix_gtdt(z, t) -> (real_(x) -> (real_(y) ->
  (real_(z) -> (real_(t) -> infix_gtdt(infix_pldt(x, z), infix_pldt(y,
  t)))))))))

axiom compat_supeq_mult :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(y,
  x) -> (real_(x) -> (real_(y) -> (real_(z) -> (infix_lseqdt(c_zero, z) ->
  infix_lseqdt(infix_asdt(y, z), infix_asdt(x, z))))))))

axiom compat_supeq_div :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(y,
  x) -> (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_lseqdt(infix_sldt(y, z), infix_sldt(x, z))))))))

axiom compat_infeq_div :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(x,
  y) -> (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_lseqdt(infix_sldt(x, z), infix_sldt(y, z))))))))

axiom compat_sup_div :
  (forall x:complex. forall y:complex. forall z:complex. (infix_gtdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_gtdt(infix_sldt(x, z), infix_sldt(y, z))))))))

axiom compat_inf_div :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lsdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_lsdt(infix_sldt(x, z), infix_sldt(y, z))))))))

axiom positive_prod_itself :
  (forall x:complex. (real_(x) -> infix_lseqdt(c_zero, infix_asdt(x, x))))

axiom strict_positive_prod_itself :
  (forall x:complex. (real_(x) -> ((not (x = c_zero)) -> infix_lsdt(c_zero,
  infix_asdt(x, x)))))

axiom compat_sup_mult :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(y,
  x) -> (real_(x) -> (real_(y) -> (real_(z) -> (infix_lseqdt(c_zero, z) ->
  infix_lseqdt(infix_asdt(y, z), infix_asdt(x, z))))))))

axiom strict_compat_sup_mult :
  (forall x:complex. forall y:complex. forall z:complex. (infix_gtdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_gtdt(infix_asdt(x, z), infix_asdt(y, z))))))))

axiom compat_sup_mult_left :
  (forall x:complex. forall y:complex. forall z:complex. (infix_lseqdt(y,
  x) -> (real_(x) -> (real_(y) -> (real_(z) -> (infix_lseqdt(c_zero, z) ->
  infix_lseqdt(infix_asdt(z, y), infix_asdt(z, x))))))))

axiom strict_compat_sup_mult_left :
  (forall x:complex. forall y:complex. forall z:complex. (infix_gtdt(x, y) ->
  (real_(x) -> (real_(y) -> (real_(z) -> (infix_lsdt(c_zero, z) ->
  infix_gtdt(infix_asdt(z, x), infix_asdt(z, y))))))))

axiom inv_inf_eq :
  (forall a:complex. forall b:complex. (infix_lsdt(c_zero, a) ->
  (infix_lsdt(c_zero, b) -> (infix_lseqdt(a, b) ->
  infix_lseqdt(infix_sldt(c_one, b), infix_sldt(c_one, a))))))

axiom inv_sup_eq :
  (forall a:complex. forall b:complex. (infix_lsdt(c_zero, a) ->
  (infix_lsdt(c_zero, b) -> (infix_lseqdt(b, a) ->
  infix_lseqdt(infix_sldt(c_one, a), infix_sldt(c_one, b))))))

axiom inv_sup :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  ((infix_lsdt(c_zero, x) and infix_lsdt(x, y)) ->
  infix_gtdt(infix_sldt(c_one, x), infix_sldt(c_one, y))))))

axiom inv_eqinf :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  ((infix_lsdt(c_zero, x) and infix_lseqdt(x, y)) ->
  infix_lseqdt(infix_sldt(c_one, y), infix_sldt(c_one, x))))))

axiom inv_eqsup :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  ((infix_lseqdt(y, x) and infix_gtdt(y, c_zero)) ->
  infix_lseqdt(infix_sldt(c_one, x), infix_sldt(c_one, y))))))

axiom inv_inf :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  ((infix_gtdt(x, y) and infix_gtdt(y, c_zero)) ->
  infix_lsdt(infix_sldt(c_one, x), infix_sldt(c_one, y))))))

axiom inv_neg :
  (forall x:complex. (real_(x) -> (infix_lsdt(x, c_zero) ->
  infix_lsdt(infix_sldt(c_one, x), c_zero))))

axiom lower_inv :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(c_zero,
  b) -> (infix_lseqdt(c_zero, a) -> (infix_lseqdt(b, c) ->
  infix_lseqdt(infix_sldt(a, c), infix_sldt(a, b))))))

axiom lower_inv_ :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(c_zero,
  b) -> (infix_lseqdt(c_zero, a) -> (infix_lseqdt(b, c) ->
  infix_lseqdt(infix_sldt(a, c), infix_sldt(a, b))))))

axiom zero_add_t :
  (forall a1:complex. forall a2:complex. ((a1 = c_zero) -> (infix_pldt(a1,
  a2) = a2)))

axiom add_zero_t :
  (forall a1:complex. forall a2:complex. ((a2 = c_zero) -> (infix_pldt(a1,
  a2) = a1)))

axiom one_mult_t :
  (forall a1:complex. forall a2:complex. ((a1 = c_one) -> (infix_asdt(a1,
  a2) = a2)))

axiom one_mult_t_const : (forall a:complex. (infix_asdt(c_one, a) = a))

axiom zero_mult_t_const :
  (forall a:complex. (infix_asdt(c_zero, a) = c_zero))

axiom mult_zero_t_const :
  (forall a:complex. (infix_asdt(a, c_zero) = c_zero))

axiom subs_eq :
  (forall a1:complex. forall a2:complex. forall b1:complex.
  forall b2:complex. ((a1 = a2) -> ((b1 = b2) -> (infix_mndt(a1,
  b1) = infix_mndt(a2, b2)))))

axiom subst_itself :
  (forall a1:complex. forall a2:complex. ((a1 = a2) -> (infix_mndt(a1,
  a2) = c_zero)))

axiom mult_assoc_four :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_asdt(infix_asdt(a, infix_asdt(b, c)), d) = infix_asdt(infix_asdt(a,
  b), infix_asdt(c, d))))

axiom mult_assoc_rev :
  (forall a:complex. forall b:complex. forall c:complex. (infix_asdt(a,
  infix_asdt(b, c)) = infix_asdt(infix_asdt(a, b), c)))

axiom add_assoc :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_pldt(infix_pldt(a, b), c) = infix_pldt(a, infix_pldt(b, c))))

axiom add_assoc_rev :
  (forall a:complex. forall b:complex. forall c:complex. (infix_pldt(a,
  infix_pldt(b, c)) = infix_pldt(infix_pldt(a, b), c)))

axiom div_mult :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (c = c_zero)) -> (infix_asdt(a, infix_sldt(b,
  c)) = infix_sldt(infix_asdt(a, b), c))))

axiom div_mult_rev :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (c = c_zero)) -> (infix_sldt(infix_asdt(a, b), c) = infix_asdt(a,
  infix_sldt(b, c)))))

axiom triang_p :
  (forall a:complex. forall b:complex. (infix_asdt(infix_pldt(a, b),
  infix_pldt(a, b)) = infix_pldt(infix_pldt(infix_asdt(a, a), infix_asdt(b,
  b)), infix_asdt(infix_asdt(infix_pldt(c_one, c_one), a), b))))

axiom triang_n :
  (forall a:complex. forall b:complex. (infix_asdt(infix_mndt(a, b),
  infix_mndt(a, b)) = infix_mndt(infix_pldt(infix_asdt(a, a), infix_asdt(b,
  b)), infix_asdt(infix_asdt(infix_pldt(c_one, c_one), a), b))))

axiom triang_s :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  forall e:complex. (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  infix_pldt(infix_mndt(d, b), e)) = infix_pldt(infix_pldt(a, c),
  infix_pldt(d, e))))

axiom triang_t :
  (forall a:complex. forall b:complex. (infix_asdt(infix_pldt(a, b),
  infix_mndt(a, b)) = infix_mndt(infix_asdt(a, a), infix_asdt(b, b))))

axiom triang_sr :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  forall e:complex. (infix_pldt(infix_pldt(infix_mndt(a, b), c),
  infix_pldt(infix_pldt(d, b), e)) = infix_pldt(infix_pldt(a, c),
  infix_pldt(d, e))))

axiom add_pos :
  (forall x:complex. forall y:complex. (infix_lseqdt(c_zero, x) ->
  (infix_lseqdt(c_zero, y) -> infix_lseqdt(c_zero, infix_pldt(x, y)))))

axiom add_pos_strit_l :
  (forall x:complex. forall y:complex. (infix_lsdt(c_zero, x) ->
  (infix_lseqdt(c_zero, y) -> infix_lsdt(c_zero, infix_pldt(x, y)))))

axiom add_pos_strit_r :
  (forall x:complex. forall y:complex. (infix_lseqdt(c_zero, x) ->
  (infix_lsdt(c_zero, y) -> infix_lsdt(c_zero, infix_pldt(x, y)))))

axiom modulus_pre_pre :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_asdt(a, b), infix_asdt(c, d)),
  infix_pldt(infix_asdt(a, d), infix_asdt(c, b))) = infix_pldt(infix_asdt(a,
  infix_pldt(b, d)), infix_asdt(c, infix_pldt(b, d)))))

axiom modulus_pre_pre1 :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_asdt(a, b), infix_asdt(c, d)),
  infix_pldt(infix_asdt(a, d), infix_asdt(c, b))) = infix_asdt(infix_pldt(a,
  c), infix_pldt(b, d))))

axiom modulus_pre :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_asdt(infix_asdt(a, b), infix_asdt(a, b)),
  infix_asdt(infix_asdt(c, d), infix_asdt(c, d))),
  infix_pldt(infix_asdt(infix_asdt(a, d), infix_asdt(a, d)),
  infix_asdt(infix_asdt(c, b), infix_asdt(c,
  b)))) = infix_asdt(infix_pldt(infix_asdt(a, a), infix_asdt(c, c)),
  infix_pldt(infix_asdt(b, b), infix_asdt(d, d)))))

function sqr(x: real) : real = (x * x)

logic sqrt : real -> real

axiom Sqrt_positive : (forall x:real. ((0.0 <= x) -> (0.0 <= sqrt(x))))

axiom Sqrt_square : (forall x:real. ((0.0 <= x) -> (sqr(sqrt(x)) = x)))

axiom Square_sqrt : (forall x:real. ((0.0 <= x) -> (sqrt((x * x)) = x)))

axiom Sqrt_mul :
  (forall x:real. forall y:real. (((0.0 <= x) and (0.0 <= y)) ->
  (sqrt((x * y)) = (sqrt(x) * sqrt(y)))))

axiom Sqrt_le :
  (forall x:real. forall y:real. (((0.0 <= x) and (x <= y)) ->
  (sqrt(x) <= sqrt(y))))

logic real_sqrt : real -> real

axiom real_sqrtqtspec :
  (forall x:real. ((0.0 <= x) -> ((real_sqrt(x) * real_sqrt(x)) = x)))

axiom real_sqrtqtspec1 :
  (forall x:real. ((0.0 <= x) -> (real_sqrt(x) = sqrt(x))))

logic square_rt : complex -> complex

axiom square_rtqtdef :
  (forall x:complex. (infix_lseqdt(c_zero, x) ->
  (square_rt(x) = r_to_c(real_sqrt(real_part(x))))))

axiom square_rtqtspec :
  (forall x:complex. (infix_lseqdt(c_zero, x) -> real_(square_rt(x))))

axiom square_rtqtspec1 :
  (forall x:complex. (infix_lseqdt(c_zero, x) -> (infix_asdt(square_rt(x),
  square_rt(x)) = x)))

axiom square_rtqtspec2 :
  (forall x:complex. (infix_lseqdt(c_zero, x) -> infix_lseqdt(c_zero,
  square_rt(x))))

axiom square_rt_eq :
  (forall a:complex. forall b:complex. (infix_lseqdt(c_zero, a) ->
  (infix_lseqdt(c_zero, b) -> ((a = b) -> (square_rt(a) = square_rt(b))))))

axiom real_square_rt :
  (forall x:complex. (real_(x) -> (infix_lseqdt(c_zero, x) ->
  real_(square_rt(x)))))

axiom pos_square_rt :
  (forall x:complex. (real_(x) -> (infix_lseqdt(c_zero, x) ->
  infix_lseqdt(c_zero, square_rt(x)))))

axiom square_rt_square :
  (forall x:complex. (infix_lseqdt(c_zero, x) -> (infix_asdt(square_rt(x),
  square_rt(x)) = x)))

axiom square_rt_infeq :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  ((infix_lseqdt(c_zero, x) and infix_lseqdt(x, y)) ->
  infix_lseqdt(square_rt(x), square_rt(y))))))

axiom square_rt_inf :
  (forall x:complex. forall y:complex. ((infix_lseqdt(c_zero, x) and
  infix_lsdt(x, y)) -> infix_lsdt(square_rt(x), square_rt(y))))

axiom injective_square_rt :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  (infix_lseqdt(c_zero, x) -> (infix_lseqdt(c_zero, y) ->
  ((square_rt(x) = square_rt(y)) -> (x = y)))))))

axiom injective_square :
  (forall x:complex. forall y:complex. (real_(x) -> (real_(y) ->
  (infix_lseqdt(c_zero, x) -> (infix_lseqdt(c_zero, y) -> ((infix_asdt(x,
  x) = infix_asdt(y, y)) -> (x = y)))))))

axiom square_rt_c_one : (square_rt(c_one) = c_one)

axiom square_rt_mult :
  (forall t:complex. forall tqt:complex. (real_(t) -> (infix_lseqdt(c_zero,
  t) -> (real_(tqt) -> (infix_lseqdt(c_zero, tqt) ->
  (infix_asdt(square_rt(t), square_rt(tqt)) = square_rt(infix_asdt(t,
  tqt))))))))

axiom square_rt_mult_rev :
  (forall t:complex. forall tqt:complex. (real_(t) -> (infix_lseqdt(c_zero,
  t) -> (real_(tqt) -> (infix_lseqdt(c_zero, tqt) -> (square_rt(infix_asdt(t,
  tqt)) = infix_asdt(square_rt(t), square_rt(tqt))))))))

function modulus(x: complex) : complex =
  square_rt(infix_pldt(infix_asdt(t_real_part(x), t_real_part(x)),
  infix_asdt(t_im_part(x), t_im_part(x))))

axiom modulusqtspec : (forall x:complex. infix_lseqdt(c_zero, modulus(x)))

predicate c_one_modulus(x: complex) = (modulus(x) = c_one)

axiom modulus_eq :
  (forall x:complex. forall y:complex. ((infix_asdt(t_real_part(x),
  t_real_part(x)) = infix_asdt(t_real_part(y), t_real_part(y))) ->
  ((infix_asdt(t_im_part(x), t_im_part(x)) = infix_asdt(t_im_part(y),
  t_im_part(y))) -> (modulus(x) = modulus(y)))))

axiom modulus_minus :
  (forall x:complex. (modulus(prefix_mndt(x)) = modulus(x)))

axiom square_rt_simpl :
  (forall x:complex. (infix_lsdt(c_zero, x) -> (infix_asdt(x,
  infix_sldt(c_one, square_rt(x))) = square_rt(x))))

axiom square_rt_simpl_fact :
  (forall x:complex. forall a:complex. (infix_lsdt(c_zero, x) ->
  (infix_asdt(infix_asdt(a, infix_sldt(c_one, square_rt(x))),
  x) = infix_asdt(a, square_rt(x)))))

axiom square_rt_simpl_mult :
  (forall x:complex. forall a:complex. (infix_lsdt(c_zero, x) ->
  (infix_asdt(infix_asdt(square_rt(x), a), infix_sldt(c_one,
  square_rt(x))) = a)))

axiom square_rt_simpl_fact_assoc :
  (forall x:complex. forall a:complex. (infix_lsdt(c_zero, x) ->
  (infix_asdt(x, infix_asdt(a, infix_sldt(c_one,
  square_rt(x)))) = infix_asdt(a, square_rt(x)))))

axiom modulus_itself :
  (forall x:complex. forall y:complex. ((x = y) ->
  (modulus(x) = modulus(y))))

axiom modulus_real_pos :
  (forall x:complex. (real_(x) -> (infix_lseqdt(c_zero, x) ->
  (modulus(x) = x))))

axiom modulus_real_pos_inv :
  (forall x:complex. (real_(x) -> (infix_lseqdt(c_zero, x) ->
  (modulus(prefix_mndt(x)) = x))))

axiom modulus_real_neg :
  (forall x:complex. (real_(x) -> (infix_lseqdt(x, c_zero) ->
  (modulus(x) = prefix_mndt(x)))))

axiom strict_positive_modulus :
  (forall x:complex. ((not (x = c_zero)) -> infix_lsdt(c_zero, modulus(x))))

axiom not_modulus_zero :
  (forall x:complex. ((not (x = c_zero)) -> (not (modulus(x) = c_zero))))

axiom modulus_real : (forall x:complex. real_(modulus(x)))

axiom t_mult_real_square :
  (forall a:complex. forall b:complex. (infix_asdt(t_real_part(infix_asdt(a,
  b)), t_real_part(infix_asdt(a,
  b))) = infix_mndt(infix_pldt(infix_asdt(infix_asdt(t_real_part(a),
  t_real_part(a)), infix_asdt(t_real_part(b), t_real_part(b))),
  infix_asdt(infix_asdt(t_im_part(a), t_im_part(a)), infix_asdt(t_im_part(b),
  t_im_part(b)))), infix_asdt(infix_pldt(c_one, c_one),
  infix_asdt(infix_asdt(infix_asdt(t_real_part(a), t_real_part(b)),
  t_im_part(a)), t_im_part(b))))))

axiom t_mult_im_square :
  (forall a:complex. forall b:complex. (infix_asdt(t_im_part(infix_asdt(a,
  b)), t_im_part(infix_asdt(a,
  b))) = infix_pldt(infix_pldt(infix_asdt(infix_asdt(t_real_part(a),
  t_real_part(a)), infix_asdt(t_im_part(b), t_im_part(b))),
  infix_asdt(infix_asdt(t_im_part(a), t_im_part(a)),
  infix_asdt(t_real_part(b), t_real_part(b)))), infix_asdt(infix_pldt(c_one,
  c_one), infix_asdt(infix_asdt(infix_asdt(t_real_part(a), t_real_part(b)),
  t_im_part(a)), t_im_part(b))))))

axiom mult_modulus_pre :
  (forall a:complex. forall b:complex.
  (infix_pldt(infix_asdt(t_real_part(infix_asdt(a, b)),
  t_real_part(infix_asdt(a, b))), infix_asdt(t_im_part(infix_asdt(a, b)),
  t_im_part(infix_asdt(a,
  b)))) = infix_asdt(infix_pldt(infix_asdt(t_real_part(a), t_real_part(a)),
  infix_asdt(t_im_part(a), t_im_part(a))),
  infix_pldt(infix_asdt(t_real_part(b), t_real_part(b)),
  infix_asdt(t_im_part(b), t_im_part(b))))))

axiom mult_modulus :
  (forall x:complex. forall y:complex. (modulus(infix_asdt(x,
  y)) = infix_asdt(modulus(x), modulus(y))))

axiom mult_modulus_rev :
  (forall x:complex. forall y:complex. (infix_asdt(modulus(x),
  modulus(y)) = modulus(infix_asdt(x, y))))

axiom modulus_real_minus_bound :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(b) -> (real_(c) -> (infix_lseqdt(c_zero, a) -> (infix_lseqdt(c_zero,
  b) -> (infix_lseqdt(c_zero, c) -> (infix_lseqdt(modulus(infix_mn(a, b)),
  c) -> infix_lseqdt(infix_mndt(a, c), b)))))))))

axiom modulus_real_minus_bound1 :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(b) -> (real_(c) -> (infix_lseqdt(c_zero, a) -> (infix_lseqdt(c_zero,
  b) -> (infix_lseqdt(c_zero, c) -> (infix_lseqdt(modulus(infix_mn(a, b)),
  c) -> infix_lseqdt(b, infix_pldt(a, c))))))))))

axiom mult_real_modulus :
  (forall x:complex. forall y:complex. (real_(x) -> (infix_lseqdt(c_zero,
  x) -> (modulus(infix_asdt(x, y)) = infix_asdt(x, modulus(y))))))

axiom mult_real_modulus_rev :
  (forall x:complex. forall y:complex. (real_(x) -> (infix_lseqdt(c_zero,
  x) -> (infix_asdt(x, modulus(y)) = modulus(infix_asdt(x, y))))))

axiom modulus_real_div :
  (forall x:complex. forall y:complex. (real_(x) -> (infix_lsdt(c_zero, x) ->
  (infix_sldt(modulus(y), x) = modulus(infix_sldt(y, x))))))

axiom mult_modulus_real :
  (forall x:complex. forall y:complex. (real_(y) -> (infix_lseqdt(c_zero,
  y) -> (modulus(infix_asdt(x, y)) = infix_asdt(modulus(x), y)))))

axiom mult_modulus_non_null :
  (forall x:complex. forall y:complex. ((not (x = c_zero)) ->
  ((not (y = c_zero)) -> (not (modulus(infix_asdt(x, y)) = c_zero)))))

axiom modulus_to_non_null :
  (forall x:complex. (infix_lsdt(c_zero, modulus(x)) -> (not (x = c_zero))))

axiom mult_c_one_modulus :
  (forall x:complex. forall y:complex. (c_one_modulus(x) ->
  (c_one_modulus(y) -> c_one_modulus(infix_asdt(x, y)))))

axiom modulus_pos :
  (forall x:complex. ((not (x = c_zero)) -> infix_lseqdt(c_zero,
  modulus(x))))

axiom modulus_infeq :
  (forall x:complex. forall b:complex. forall c:complex. (real_(x) ->
  (infix_lseqdt(b, c) -> (infix_lseqdt(modulus(x), b) -> infix_lseqdt(x,
  c)))))

axiom modulus_inf :
  (forall x:complex. forall b:complex. forall c:complex. (real_(x) ->
  (infix_lsdt(b, c) -> (infix_lseqdt(modulus(x), b) -> infix_lsdt(x, c)))))

axiom modulus_diff_rev :
  (forall a:complex. forall b:complex. (modulus(infix_mndt(a,
  b)) = modulus(infix_mndt(b, a))))

axiom modulus_simpl_leq :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(b) -> (real_(c) -> (infix_lsdt(c_zero, c) ->
  (infix_lseqdt(modulus(infix_asdt(a, c)), infix_asdt(b, c)) ->
  infix_lseqdt(modulus(a), b)))))))

axiom modulus_simpl_leq_rev :
  (forall a:complex. forall b:complex. forall c:complex. (real_(a) ->
  (real_(b) -> (real_(c) -> (infix_lseqdt(c_zero, c) ->
  (infix_lseqdt(modulus(a), b) -> infix_lseqdt(modulus(infix_asdt(a, c)),
  infix_asdt(b, c))))))))

axiom div_eq :
  (forall a1:complex. forall a2:complex. forall b1:complex.
  forall b2:complex. ((a1 = a2) -> ((b1 = b2) -> ((not (b1 = c_zero)) ->
  (infix_sldt(a1, b1) = infix_sldt(a2, b2))))))

axiom add_eq_inv_t :
  (forall a1:complex. forall a2:complex. forall b1:complex.
  forall b2:complex. ((a1 = a2) -> ((b1 = b2) -> (infix_pldt(a1,
  b1) = infix_pldt(b2, a2)))))

axiom mult_eq_inv_t :
  (forall a1:complex. forall a2:complex. forall b1:complex.
  forall b2:complex. ((a1 = a2) -> ((b1 = b2) -> (infix_asdt(a1,
  b1) = infix_asdt(b2, a2)))))

axiom sum_frac :
  (forall a1:complex. forall a2:complex. forall b:complex.
  ((not (b = c_zero)) -> (infix_pldt(infix_sldt(a1, b), infix_sldt(a2,
  b)) = infix_sldt(infix_pldt(a1, a2), b))))

axiom sum_frac_rev :
  (forall a1:complex. forall a2:complex. forall b:complex.
  ((not (b = c_zero)) -> (infix_sldt(infix_pldt(a1, a2),
  b) = infix_pldt(infix_sldt(a1, b), infix_sldt(a2, b)))))

axiom div_pos :
  (forall x:complex. forall y:complex. (infix_lseqdt(c_zero, x) ->
  (infix_lsdt(c_zero, y) -> infix_lseqdt(c_zero, infix_sldt(x, y)))))

logic fc : ('b,('a,'b) farray) farray

axiom fcqtdef :
  (forall y0:'b. forall y1:'a.
  ((((fc : ('b,('a,'b) farray) farray)[y0])[y1]) = y0))

predicate constant_f(f: ('a,'b) farray) =
  (exists a1:'b. (f = ((fc : ('b,('a,'b) farray) farray)[a1])))

logic op : 'im1, 'im1 -> 'im1

logic po : 'im1, 'im1 -> 'im1

logic inver : 'im1 -> 'im1

type 'a set

logic mem : 'a, 'a set -> prop

logic add : 'a, 'a set -> 'a set

logic empty : 'a set

logic cardinal : 'a set -> int

logic choose : 'a set -> 'a

logic remove : 'a, 'a set -> 'a set

logic filter_ : 'a set, ('a,bool) farray -> 'a set

logic union : 'a set, 'a set -> 'a set

predicate infix_eqeq1(s1: 'a set, s2: 'a set) =
  (forall x:'a. (mem(x, s1) <-> mem(x, s2)))

axiom extensionality :
  (forall s1:'a set. forall s2:'a set. (infix_eqeq1(s1, s2) -> (s1 = s2)))

predicate subset(s1: 'a set, s2: 'a set) =
  (forall x:'a. (mem(x, s1) -> mem(x, s2)))

axiom subset_refl : (forall s:'a set. subset(s, s))

axiom subset_trans :
  (forall s1:'a set. forall s2:'a set. forall s3:'a set. (subset(s1, s2) ->
  (subset(s2, s3) -> subset(s1, s3))))

predicate is_empty(s: 'a set) = (forall x:'a. (not mem(x, s)))

axiom is_empty_empty : is_empty((empty : 'a set))

axiom empty_is_empty :
  (forall s:'a set. (is_empty(s) -> (s = (empty : 'a set))))

axiom add_def :
  (forall x:'a. forall s:'a set. forall y:'a. (mem(y, add(x, s)) -> (mem(y,
  s) or (y = x))))

axiom add_def1 :
  (forall x:'a. forall s:'a set. forall y:'a. ((mem(y, s) or (y = x)) ->
  mem(y, add(x, s))))

axiom mem_singleton :
  (forall x:'a. forall y:'a. (mem(y, add(x, (empty : 'a set))) -> (y = x)))

axiom remove_def :
  (forall x:'a. forall s:'a set. forall y:'a. (mem(y, remove(x, s)) -> mem(y,
  s)))

axiom remove_def1 :
  (forall x:'a. forall s:'a set. forall y:'a. (mem(y, remove(x, s)) ->
  (not (y = x))))

axiom remove_def2 :
  (forall x:'a. forall s:'a set. forall y:'a. ((mem(y, s) and
  (not (y = x))) -> mem(y, remove(x, s))))

axiom add_remove :
  (forall x:'a. forall s:'a set. (mem(x, s) -> (add(x, remove(x, s)) = s)))

axiom remove_add :
  (forall x:'a. forall s:'a set. (remove(x, add(x, s)) = remove(x, s)))

axiom subset_remove : (forall x:'a. forall s:'a set. subset(remove(x, s), s))

axiom union_def :
  (forall s1:'a set. forall s2:'a set. forall x:'a. (mem(x, union(s1, s2)) ->
  (mem(x, s1) or mem(x, s2))))

axiom union_def1 :
  (forall s1:'a set. forall s2:'a set. forall x:'a. ((mem(x, s1) or mem(x,
  s2)) -> mem(x, union(s1, s2))))

axiom subset_union_1 :
  (forall s1:'a set. forall s2:'a set. subset(s1, union(s1, s2)))

axiom subset_union_2 :
  (forall s1:'a set. forall s2:'a set. subset(s2, union(s1, s2)))

logic inter : 'a set, 'a set -> 'a set

axiom inter_def :
  (forall s1:'a set. forall s2:'a set. forall x:'a. (mem(x, inter(s1, s2)) ->
  mem(x, s1)))

axiom inter_def1 :
  (forall s1:'a set. forall s2:'a set. forall x:'a. (mem(x, inter(s1, s2)) ->
  mem(x, s2)))

axiom inter_def2 :
  (forall s1:'a set. forall s2:'a set. forall x:'a. ((mem(x, s1) and mem(x,
  s2)) -> mem(x, inter(s1, s2))))

axiom subset_inter_1 :
  (forall s1:'a set. forall s2:'a set. subset(inter(s1, s2), s1))

axiom subset_inter_2 :
  (forall s1:'a set. forall s2:'a set. subset(inter(s1, s2), s2))

logic diff : 'a set, 'a set -> 'a set

axiom diff_def :
  (forall s1:'a set. forall s2:'a set. forall x:'a. (mem(x, diff(s1, s2)) ->
  mem(x, s1)))

axiom diff_def1 :
  (forall s1:'a set. forall s2:'a set. forall x:'a. (mem(x, diff(s1, s2)) ->
  (not mem(x, s2))))

axiom diff_def2 :
  (forall s1:'a set. forall s2:'a set. forall x:'a. ((mem(x, s1) and
  (not mem(x, s2))) -> mem(x, diff(s1, s2))))

axiom subset_diff :
  (forall s1:'a set. forall s2:'a set. subset(diff(s1, s2), s1))

axiom pick_def : (forall s:'a set. ((not is_empty(s)) -> mem(choose(s), s)))

predicate disjoint(s1: 'a set, s2: 'a set) =
  (forall x:'a. ((not mem(x, s1)) or (not mem(x, s2))))

axiom disjoint_inter_empty :
  (forall s1:'a set. forall s2:'a set. (disjoint(s1, s2) ->
  is_empty(inter(s1, s2))))

axiom disjoint_inter_empty1 :
  (forall s1:'a set. forall s2:'a set. (is_empty(inter(s1, s2)) ->
  disjoint(s1, s2)))

axiom disjoint_diff_eq :
  (forall s1:'a set. forall s2:'a set. (disjoint(s1, s2) -> (diff(s1,
  s2) = s1)))

axiom disjoint_diff_eq1 :
  (forall s1:'a set. forall s2:'a set. ((diff(s1, s2) = s1) -> disjoint(s1,
  s2)))

axiom disjoint_diff_s2 :
  (forall s1:'a set. forall s2:'a set. disjoint(diff(s1, s2), s2))

axiom filter_def :
  (forall s:'a set. forall p:('a,bool) farray. forall x:'a. (mem(x,
  filter_(s, p)) -> mem(x, s)))

axiom filter_def1 :
  (forall s:'a set. forall p:('a,bool) farray. forall x:'a. (mem(x,
  filter_(s, p)) -> ((p[x]) = true)))

axiom filter_def2 :
  (forall s:'a set. forall p:('a,bool) farray. forall x:'a. ((mem(x, s) and
  ((p[x]) = true)) -> mem(x, filter_(s, p))))

axiom subset_filter :
  (forall s:'a set. forall p:('a,bool) farray. subset(filter_(s, p), s))

logic map : ('a,'b) farray, 'a set -> 'b set

axiom map_def :
  (forall f:('a,'b) farray. forall u:'a set. forall y:'b. (mem(y, map(f,
  u)) -> (exists x:'a. (mem(x, u) and (y = (f[x]))))))

axiom map_def1 :
  (forall f:('a,'b) farray. forall u:'a set. forall y:'b.
  ((exists x:'a. (mem(x, u) and (y = (f[x])))) -> mem(y, map(f, u))))

axiom mem_map :
  (forall f:('a,'b) farray. forall u:'a set.
  (forall x:'a. (mem(x, u) -> mem((f[x]), map(f, u)))))

axiom cardinal_nonneg : (forall s:'a set. (0 <= cardinal(s)))

axiom cardinal_empty : (forall s:'a set. (is_empty(s) -> (cardinal(s) = 0)))

axiom cardinal_empty1 : (forall s:'a set. ((cardinal(s) = 0) -> is_empty(s)))

axiom cardinal_add :
  (forall x:'a.
  (forall s:'a set. (mem(x, s) -> (cardinal(add(x, s)) = cardinal(s)))))

axiom cardinal_add1 :
  (forall x:'a.
  (forall s:'a set. ((not mem(x, s)) -> (cardinal(add(x,
  s)) = (cardinal(s) + 1)))))

axiom cardinal_remove :
  (forall x:'a.
  (forall s:'a set. (mem(x, s) -> (cardinal(remove(x,
  s)) = (cardinal(s) - 1)))))

axiom cardinal_remove1 :
  (forall x:'a.
  (forall s:'a set. ((not mem(x, s)) -> (cardinal(remove(x,
  s)) = cardinal(s)))))

axiom cardinal_subset :
  (forall s1:'a set. forall s2:'a set. (subset(s1, s2) ->
  (cardinal(s1) <= cardinal(s2))))

axiom subset_eq :
  (forall s1:'a set. forall s2:'a set. (subset(s1, s2) ->
  ((cardinal(s1) = cardinal(s2)) -> (s1 = s2))))

axiom cardinal1 :
  (forall s:'a set. ((cardinal(s) = 1) ->
  (forall x:'a. (mem(x, s) -> (x = choose(s))))))

axiom cardinal_union :
  (forall s1:'a set. forall s2:'a set. (cardinal(union(s1,
  s2)) = ((cardinal(s1) + cardinal(s2)) - cardinal(inter(s1, s2)))))

axiom cardinal_inter_disjoint :
  (forall s1:'a set. forall s2:'a set. (disjoint(s1, s2) ->
  (cardinal(inter(s1, s2)) = 0)))

axiom cardinal_diff :
  (forall s1:'a set. forall s2:'a set. (cardinal(diff(s1,
  s2)) = (cardinal(s1) - cardinal(inter(s1, s2)))))

axiom cardinal_filter :
  (forall s:'a set. forall p:('a,bool) farray. (cardinal(filter_(s,
  p)) <= cardinal(s)))

axiom cardinal_map :
  (forall f:('a,'b) farray. forall s:'a set. (cardinal(map(f,
  s)) <= cardinal(s)))

type ('a, 'a1) tuple2 = { Tuple2_proj_1 : 'a; Tuple2_proj_2 : 'a1
}

function fir(o: ('a2, 'b) tuple2) : 'a2 = (o).Tuple2_proj_1

function sec(o: ('a, 'b) tuple2) : 'b = (o).Tuple2_proj_2

axiom get_fir :
  (forall a:'a1. forall b:'b1. (fir({ Tuple2_proj_1 = a; Tuple2_proj_2 = b
  }) = a))

axiom get_sec :
  (forall a:'a1. forall b:'b1. (sec({ Tuple2_proj_1 = a; Tuple2_proj_2 = b
  }) = b))

axiom set_pair :
  (forall o:('a, 'b) tuple2. (o = { Tuple2_proj_1 = fir(o); Tuple2_proj_2 =
  sec(o) }))

type 'a ref = { contents : 'a
}

axiom set_equal :
  (forall s:'a1 set. forall sqt:'a1 set.
  ((forall e:'a1. (mem(e, s) -> mem(e, sqt))) ->
  ((forall e:'a1. (mem(e, sqt) -> mem(e, s))) -> (s = sqt))))

axiom set_equal_eqq :
  (forall s:'a set. forall sqt:'a set.
  ((forall e:'a. (mem(e, s) -> mem(e, sqt))) ->
  ((forall e:'a. (mem(e, sqt) -> mem(e, s))) -> infix_eqeq(s, sqt))))

axiom union_exchange :
  (forall s:'a set. forall sqt:'a set. ((not is_empty(sqt)) ->
  (union(add(choose(sqt), s), remove(choose(sqt), sqt)) = union(s, sqt))))

axiom get_filter :
  (forall p:('a,bool) farray. forall s:'a set. forall x:'a. (mem(x,
  filter_(s, p)) -> ((p[x]) = true)))

axiom get_filter1 :
  (forall p:('a,bool) farray. forall s:'a set. forall x:'a. (mem(x,
  filter_(s, p)) -> mem(x, s)))

axiom set_filter :
  (forall p:('a,bool) farray. forall s:'a set. forall x:'a.
  (((p[x]) = true) -> (mem(x, s) -> mem(x, filter_(s, p)))))

axiom inter_empty :
  (forall s:'a set. forall sqt:'a set. (is_empty(s) -> is_empty(inter(s,
  sqt))))

axiom inter_empty_comm :
  (forall s:'a set. forall sqt:'a set. (is_empty(sqt) -> is_empty(inter(s,
  sqt))))

axiom inter_empty_elts :
  (forall s:'a set. forall sqt:'a set.
  ((forall e:'a. (mem(e, s) -> (not mem(e, sqt)))) -> is_empty(inter(s,
  sqt))))

axiom inter_sym :
  (forall s:'a set. forall sqt:'a set. (inter(s, sqt) = inter(sqt, s)))

axiom union_sym :
  (forall s:'a set. forall sqt:'a set. (union(s, sqt) = union(sqt, s)))

axiom union_empty :
  (forall s:'a set. forall sqt:'a set. (is_empty(s) -> (union(s,
  sqt) = sqt)))

axiom union_comm :
  (forall s:'a set. forall sqt:'a set. (is_empty(sqt) -> (union(s,
  sqt) = s)))

axiom union_members :
  (forall s:'a set. forall sqt:'a set.
  (forall a1:'a. (mem(a1, union(s, sqt)) -> ((not mem(a1, s)) -> mem(a1,
  sqt)))))

axiom union_members1 :
  (forall s:'a set. forall sqt:'a set.
  (forall a1:'a. (mem(a1, union(s, sqt)) -> ((not mem(a1, sqt)) -> mem(a1,
  s)))))

axiom union_alt :
  (forall s:'a set. forall sqt:'a set. forall e:'a. (mem(e, union(s, sqt)) ->
  ((not mem(e, s)) -> mem(e, sqt))))

axiom union_empty_comm :
  (forall s:'a set. forall sqt:'a set. (is_empty(sqt) -> (union(s,
  sqt) = s)))

axiom set_subset :
  (forall sqt:'a set. forall s:'a set.
  ((forall e:'a. (mem(e, sqt) -> mem(e, s))) -> subset(sqt, s)))

axiom set_empty :
  (forall s:'a set. ((forall e:'a. (not mem(e, s))) ->
  (s = (empty : 'a set))))

axiom set_empty1 :
  (forall s:'a set. ((forall e:'a. (not mem(e, s))) -> is_empty(s)))

axiom get_empty :
  (forall s:'a set. ((s = (empty : 'a set)) ->
  (forall e:'a. (not mem(e, s)))))

axiom get_empty1 : (forall s:'a set. ((s = (empty : 'a set)) -> is_empty(s)))

axiom get_non_empty :
  (forall s:'a set. ((not is_empty(s)) -> (exists e:'a. mem(e, s))))

axiom set_non_empty :
  (forall s:'a set. ((exists e:'a. mem(e, s)) -> (not is_empty(s))))

axiom set_non_empty1 :
  (forall s:'a set. ((exists e:'a. mem(e, s)) -> (0 <  cardinal(s))))

axiom set_pos_card_elt :
  (forall s:'a set. forall a1:'a. (mem(a1, s) -> (0 <  cardinal(s))))

axiom union_add :
  (forall s:'a set. forall sqt:'a set. forall x:'a. ((not mem(x, sqt)) ->
  (union(s, add(x, sqt)) = add(x, union(s, sqt)))))

axiom union_add_mem :
  (forall s:'a set. forall sqt:'a set. forall x:'a. forall y:'a. (mem(x,
  add(y, union(s, sqt))) -> ((not mem(x, sqt)) -> ((not mem(x, s)) ->
  (x = y)))))

axiom union_add_comm :
  (forall s:'a set. forall sqt:'a set. forall x:'a. ((not mem(x, sqt)) ->
  (add(x, union(s, sqt)) = union(s, add(x, sqt)))))

predicate p_injective(f: ('a,'b) farray, s: 'a set) =
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  ((not (e = eqt)) -> (not ((f[e]) = (f[eqt])))))))

axiom set_map_mem :
  (forall f:('a,'b) farray. forall s:'a set. forall b1:'b.
  ((exists a1:'a. (mem(a1, s) and (b1 = (f[a1])))) -> mem(b1, map(f, s))))

axiom map_add :
  (forall f:('a,'b) farray. forall s:'a set. forall x:'a. ((not mem(x, s)) ->
  (map(f, add(x, s)) = add((f[x]), map(f, s)))))

axiom map_eq :
  (forall f:('a,'b) farray. forall g:('a,'b) farray. forall s:'a set.
  ((forall e:'a. (mem(e, s) -> ((f[e]) = (g[e])))) -> (map(f, s) = map(g,
  s))))

axiom remove_mem :
  (forall s:'a set. forall e:'a. forall f:'a. (mem(e, remove(f, s)) -> mem(e,
  s)))

axiom injective_map_cardinal :
  (forall f:('a,'b) farray. forall s:'a set. (p_injective(f, s) ->
  (cardinal(map(f, s)) = cardinal(s))))

axiom set_map_mem_el :
  (forall f:('a,'b) farray. forall s:'a set. forall b1:'b. forall a1:'a.
  (mem(a1, s) -> ((b1 = (f[a1])) -> mem(b1, map(f, s)))))

axiom set_map_mem_el_gen :
  (forall f:('a,'b) farray. forall s:'a set. forall b1:'b.
  ((exists a1:'a. (mem(a1, s) and (b1 = (f[a1])))) -> mem(b1, map(f, s))))

axiom map_antec :
  (forall f:('a,'b) farray. forall s:'a set. forall b1:'b. (mem(b1, map(f,
  s)) -> (exists a1:'a. (mem(a1, s) and (b1 = (f[a1]))))))

axiom map_antec_gen :
  (forall f:('a,'b) farray. forall s:'a set.
  (forall b1:'b. (mem(b1, map(f, s)) ->
  (exists a1:'a. (mem(a1, s) and (b1 = (f[a1])))))))

axiom map_remove_choose :
  (forall s:'a set. forall f:('a,'b) farray. (p_injective(f, s) -> (map(f,
  remove(choose(s), s)) = remove((f[choose(s)]), map(f, s)))))

logic antec_set : 'a set, ('a,'b) farray, 'b -> 'a set

logic result : ('a,'b) farray, 'b -> ('a,bool) farray

axiom resultqtdef :
  (forall f:('a,'b) farray. forall b1:'b. forall e:'a. (((result(f,
  b1)[e]) = true) -> ((f[e]) = b1)))

axiom resultqtdef1 :
  (forall f:('a,'b) farray. forall b1:'b. forall e:'a. (((f[e]) = b1) ->
  ((result(f, b1)[e]) = true)))

axiom antec_setqtdef :
  (forall s:'a set. forall f:('a,'b) farray. forall b1:'b. (mem(b1, map(f,
  s)) -> (antec_set(s, f, b1) = filter_(s, result(f, b1)))))

logic remove_s : 'a set, 'a set -> 'a set

logic result1 : 'a set -> ('a,bool) farray

axiom resultqtdef2 :
  (forall sqt:'a set. forall e:'a. (((result1(sqt)[e]) = true) -> (not mem(e,
  sqt))))

axiom resultqtdef3 :
  (forall sqt:'a set. forall e:'a. ((not mem(e, sqt)) ->
  ((result1(sqt)[e]) = true)))

axiom remove_sqtdef :
  (forall s:'a set. forall sqt:'a set. (subset(sqt, s) -> (remove_s(s,
  sqt) = filter_(s, result1(sqt)))))

axiom remove_sqtspec :
  (forall s:'a set. forall sqt:'a set. (subset(sqt, s) ->
  (forall e:'a. (mem(e, remove_s(s, sqt)) -> mem(e, s)))))

axiom remove_sqtspec1 :
  (forall s:'a set. forall sqt:'a set. (subset(sqt, s) ->
  (forall e:'a. (mem(e, remove_s(s, sqt)) -> (not mem(e, sqt))))))

axiom remove_sqtspec2 :
  (forall s:'a set. forall sqt:'a set. (subset(sqt, s) ->
  (forall e:'a. ((mem(e, s) and (not mem(e, sqt))) -> mem(e, remove_s(s,
  sqt))))))

logic remove_antecs : 'a set, ('a,'b) farray, 'b -> 'a set

axiom remove_antecsqtdef :
  (forall s:'a set. forall f:('a,'b) farray. forall b1:'b. (mem(b1, map(f,
  s)) -> (remove_antecs(s, f, b1) = remove_s(s, antec_set(s, f, b1)))))

axiom remove_antecsqtspec :
  (forall s:'a set. forall f:('a,'b) farray. forall b1:'b. (mem(b1, map(f,
  s)) -> (forall e:'a. (mem(e, remove_antecs(s, f, b1)) -> mem(e, s)))))

axiom remove_antecsqtspec1 :
  (forall s:'a set. forall f:('a,'b) farray. forall b1:'b. (mem(b1, map(f,
  s)) ->
  (forall e:'a. (mem(e, remove_antecs(s, f, b1)) -> (not ((f[e]) = b1))))))

axiom remove_antecsqtspec2 :
  (forall s:'a set. forall f:('a,'b) farray. forall b1:'b. (mem(b1, map(f,
  s)) ->
  (forall e:'a. ((mem(e, s) and (not ((f[e]) = b1))) -> mem(e,
  remove_antecs(s, f, b1))))))

axiom remove_antecsqtspec3 :
  (forall s:'a set. forall f:('a,'b) farray. forall b1:'b. (mem(b1, map(f,
  s)) -> (cardinal(remove_antecs(s, f, b1)) <  cardinal(s))))

axiom map_remove_antec :
  (forall s:'a set. forall f:('a,'b) farray. forall b1:'b. (mem(b1, map(f,
  s)) -> (map(f, remove_antecs(s, f, b1)) = remove(b1, map(f, s)))))

axiom map_non_empty :
  (forall f:('a,'b) farray. forall s:'a set. ((0 <  cardinal(s)) ->
  (0 <  cardinal(map(f, s)))))

axiom non_empty_map :
  (forall f:('a,'b) farray. forall s:'a set. ((0 <  cardinal(map(f, s))) ->
  (0 <  cardinal(s))))

logic right_injections : 'a, 'b set -> ('a, 'b) tuple2 set

axiom right_injectionsqtdef :
  (forall a:'a1. forall s:'b set. (infix_eqeq(s, (empty : 'b set)) ->
  (right_injections(a, s) = (empty : ('a1, 'b) tuple2 set))))

axiom right_injectionsqtdef1 :
  (forall a:'a1. forall s:'b set. ((not infix_eqeq(s, (empty : 'b set))) ->
  (right_injections(a, s) = add({ Tuple2_proj_1 = a; Tuple2_proj_2 =
  choose(s) }, right_injections(a, remove(choose(s), s))))))

logic Tuple2_closure : ('a,('a1,('a, 'a1) tuple2) farray) farray

axiom Tuple2_closure_def :
  (forall y:'a. forall y1:'a1. ((((Tuple2_closure : ('a,('a1,('a,
  'a1) tuple2) farray) farray)[y])[y1]) = { Tuple2_proj_1 = y;
  Tuple2_proj_2 = y1 }))

axiom right_injectionsqtspec :
  (forall a:'a1. forall s:'b set. (cardinal(right_injections(a,
  s)) = cardinal(s)))

axiom right_injectionsqtspec1 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (mem({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = b1 },
  right_injections(a, s)) -> (aqt = a)))))

axiom right_injectionsqtspec2 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (mem({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = b1 },
  right_injections(a, s)) -> mem(b1, s)))))

axiom right_injectionsqtspec3 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (((aqt = a) and mem(b1, s)) -> mem({ Tuple2_proj_1 = aqt;
  Tuple2_proj_2 = b1 }, right_injections(a, s))))))

axiom right_injectionsqtspec4 :
  (forall a:'a1. forall s:'b set. (right_injections(a,
  s) = map(((Tuple2_closure : ('a1,('b,('a1, 'b) tuple2) farray) farray)[a]),
  s)))

logic left_injections : 'a set, 'b -> ('a, 'b) tuple2 set

axiom left_injectionsqtdef :
  (forall s:'a set. forall b:'b1. (infix_eqeq(s, (empty : 'a set)) ->
  (left_injections(s, b) = (empty : ('a, 'b1) tuple2 set))))

axiom left_injectionsqtdef1 :
  (forall s:'a set. forall b:'b1. ((not infix_eqeq(s, (empty : 'a set))) ->
  (left_injections(s, b) = add({ Tuple2_proj_1 = choose(s); Tuple2_proj_2 = b
  }, left_injections(remove(choose(s), s), b)))))

logic fc1 : 'b -> ('a,('a, 'b) tuple2) farray

axiom fcqtdef1 :
  (forall b:'b1. forall a:'a1. (((fc1(b) : ('a1,('a1,
  'b1) tuple2) farray)[a]) = { Tuple2_proj_1 = a; Tuple2_proj_2 = b }))

axiom left_injectionsqtspec :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = bqt },
  left_injections(s, b)) -> mem(a1, s)))))

axiom left_injectionsqtspec1 :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = bqt },
  left_injections(s, b)) -> (bqt = b)))))

axiom left_injectionsqtspec2 :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. ((mem(a1, s) and (bqt = b)) -> mem({ Tuple2_proj_1 = a1;
  Tuple2_proj_2 = bqt }, left_injections(s, b))))))

axiom left_injectionsqtspec3 :
  (forall s:'a set. forall b:'b1. (cardinal(left_injections(s,
  b)) = cardinal(s)))

axiom left_injectionsqtspec4 :
  (forall s:'a set. forall b:'b1. (left_injections(s,
  b) = map((fc1(b) : ('a,('a, 'b1) tuple2) farray), s)))

axiom set_map_eq :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  ((forall b1:'b. (mem(b1, sqt) ->
   (exists a1:'a. (mem(a1, s) and ((f[a1]) = b1))))) ->
  ((forall a1:'a. (mem(a1, s) -> mem((f[a1]), sqt))) -> (map(f, s) = sqt))))

axiom right_injections_l :
  (forall a:'a1. forall s:'b set. (cardinal(right_injections(a,
  s)) = cardinal(s)))

axiom right_injections_l1 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (mem({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = b1 },
  right_injections(a, s)) -> (aqt = a)))))

axiom right_injections_l2 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (mem({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = b1 },
  right_injections(a, s)) -> mem(b1, s)))))

axiom right_injections_l3 :
  (forall a:'a1. forall s:'b set.
  (forall aqt:'a1.
  (forall b1:'b. (((aqt = a) and mem(b1, s)) -> mem({ Tuple2_proj_1 = aqt;
  Tuple2_proj_2 = b1 }, right_injections(a, s))))))

axiom right_injections_l4 :
  (forall a:'a1. forall s:'b set. (right_injections(a,
  s) = map(((Tuple2_closure : ('a1,('b,('a1, 'b) tuple2) farray) farray)[a]),
  s)))

logic fc2 : 'b -> ('a,('a, 'b) tuple2) farray

axiom fcqtdef2 :
  (forall b:'b1. forall a:'a1. (((fc2(b) : ('a1,('a1,
  'b1) tuple2) farray)[a]) = { Tuple2_proj_1 = a; Tuple2_proj_2 = b }))

axiom left_injections_l :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = bqt },
  left_injections(s, b)) -> mem(a1, s)))))

axiom left_injections_l1 :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = bqt },
  left_injections(s, b)) -> (bqt = b)))))

axiom left_injections_l2 :
  (forall s:'a set. forall b:'b1.
  (forall a1:'a.
  (forall bqt:'b1. ((mem(a1, s) and (bqt = b)) -> mem({ Tuple2_proj_1 = a1;
  Tuple2_proj_2 = bqt }, left_injections(s, b))))))

axiom left_injections_l3 :
  (forall s:'a set. forall b:'b1. (cardinal(left_injections(s,
  b)) = cardinal(s)))

axiom left_injections_l4 :
  (forall s:'a set. forall b:'b1. (left_injections(s,
  b) = map((fc2(b) : ('a,('a, 'b1) tuple2) farray), s)))

axiom disjoint_injections :
  (forall s:'a set. forall b:'b1. forall c:'b1. ((not (b = c)) ->
  is_empty(inter(right_injections(b, s), right_injections(c, s)))))

axiom disjoint_injections1 :
  (forall s:'a set. forall b:'b1. forall c:'b1. ((not (b = c)) ->
  is_empty(inter(left_injections(s, b), left_injections(s, c)))))

axiom induction :
  (forall p:('a set,bool) farray. forall t:'a set.
  ((forall s:'a set. (is_empty(s) -> ((p[s]) = true))) ->
  ((forall s:'a set. (((p[s]) = true) ->
   (forall t1:'a. ((not mem(t1, s)) -> ((p[add(t1, s)]) = true))))) ->
  ((p[t]) = true))))

axiom cardinal_sum :
  (forall s:'a set. forall sqt:'a set. (cardinal(union(s,
  sqt)) = ((cardinal(s) + cardinal(sqt)) - cardinal(inter(s, sqt)))))

axiom cardinal_eq :
  (forall s:'a set. forall sqt:'a set.
  ((forall e:'a. (mem(e, s) -> mem(e, sqt))) ->
  ((forall e:'a. (mem(e, sqt) -> mem(e, s))) ->
  (cardinal(s) = cardinal(sqt)))))

axiom cardinal_sum_empty_inter :
  (forall s:'a set. forall sqt:'a set. ((inter(s, sqt) = (empty : 'a set)) ->
  (cardinal(union(s, sqt)) = (cardinal(s) + cardinal(sqt)))))

logic cartesian_product : 'a set, 'b set -> ('a, 'b) tuple2 set

axiom cartesian_productqtspec :
  (forall s1:'a set. forall s2:'b set. (cardinal(cartesian_product(s1,
  s2)) = (cardinal(s1) * cardinal(s2))))

axiom cartesian_productqtspec1 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a.
  (forall b1:'b. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = b1 },
  cartesian_product(s1, s2)) -> mem(a1, s1)))))

axiom cartesian_productqtspec2 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a.
  (forall b1:'b. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = b1 },
  cartesian_product(s1, s2)) -> mem(b1, s2)))))

axiom cartesian_productqtspec3 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a.
  (forall b1:'b. ((mem(a1, s1) and mem(b1, s2)) -> mem({ Tuple2_proj_1 = a1;
  Tuple2_proj_2 = b1 }, cartesian_product(s1, s2))))))

axiom cartesian_productqtspec4 :
  (forall s1:'a set. forall s2:'b set.
  (forall o:('a, 'b) tuple2. (mem(o, cartesian_product(s1, s2)) ->
  mem(fir(o), s1))))

axiom cartesian_productqtspec5 :
  (forall s1:'a set. forall s2:'b set.
  (forall o:('a, 'b) tuple2. (mem(o, cartesian_product(s1, s2)) ->
  mem(sec(o), s2))))

axiom cartesian_productqtspec6 :
  (forall s1:'a set. forall s2:'b set.
  (forall o:('a, 'b) tuple2. ((mem(fir(o), s1) and mem(sec(o), s2)) -> mem(o,
  cartesian_product(s1, s2)))))

function commute(o: ('a, 'b) tuple2) : ('b, 'a) tuple2 = { Tuple2_proj_1 =
  (o).Tuple2_proj_2; Tuple2_proj_2 = (o).Tuple2_proj_1 }

axiom commute_inj :
  (forall a:'a1. forall aqt:'a1. forall b:'b1. forall bqt:'b1. (((a = aqt) ->
  (not (b = bqt))) -> (not (commute({ Tuple2_proj_1 = a; Tuple2_proj_2 = b
  }) = commute({ Tuple2_proj_1 = aqt; Tuple2_proj_2 = bqt })))))

axiom mem_cartesian_product :
  (forall s1:'a set. forall s2:'b set. forall a1:'a. forall b1:'b. (mem(a1,
  s1) -> (mem(b1, s2) -> mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = b1 },
  cartesian_product(s1, s2)))))

logic commute_closure : (('a, 'b) tuple2,('b, 'a) tuple2) farray

axiom commute_closure_def :
  (forall y:('a, 'b) tuple2. (((commute_closure : (('a, 'b) tuple2,('b,
  'a) tuple2) farray)[y]) = commute(y)))

axiom commute_inj_gen :
  (forall s1:'a set. forall s2:'b set. p_injective((commute_closure : (('a,
  'b) tuple2,('b, 'a) tuple2) farray), cartesian_product(s1, s2)))

function commute_product(s1: 'a set, s2: 'b set) : ('b, 'a) tuple2 set =
  map((commute_closure : (('a, 'b) tuple2,('b, 'a) tuple2) farray),
  cartesian_product(s1, s2))

axiom commute_productqtspec :
  (forall s1:'a set. forall s2:'b set. (commute_product(s1,
  s2) = cartesian_product(s2, s1)))

function commute_product_el(s1: 'a set, s2: 'b set) : ('b, 'a) tuple2 set =
  map((commute_closure : (('a, 'b) tuple2,('b, 'a) tuple2) farray),
  cartesian_product(s1, s2))

axiom commute_product_elqtspec :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = b1
  }, cartesian_product(s1, s2)) -> mem(a1, s1))))

axiom commute_product_elqtspec1 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. (mem({ Tuple2_proj_1 = a1; Tuple2_proj_2 = b1
  }, cartesian_product(s1, s2)) -> mem(b1, s2))))

axiom commute_product_elqtspec2 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. ((mem(a1, s1) and mem(b1, s2)) -> mem({
  Tuple2_proj_1 = a1; Tuple2_proj_2 = b1 }, cartesian_product(s1, s2)))))

axiom commute_product_elqtspec3 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. ((mem(a1, s1) and mem(b1, s2)) -> mem({
  Tuple2_proj_1 = b1; Tuple2_proj_2 = a1 }, commute_product_el(s1, s2)))))

axiom commute_product_elqtspec4 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. (mem({ Tuple2_proj_1 = b1; Tuple2_proj_2 = a1
  }, commute_product_el(s1, s2)) -> mem(a1, s1))))

axiom commute_product_elqtspec5 :
  (forall s1:'a set. forall s2:'b set.
  (forall a1:'a. forall b1:'b. (mem({ Tuple2_proj_1 = b1; Tuple2_proj_2 = a1
  }, commute_product_el(s1, s2)) -> mem(b1, s2))))

axiom cartesian_product_union :
  (forall s1:'a set. forall s2:'b set. forall s3:'b set.
  (cartesian_product(s1, union(s2, s3)) = union(cartesian_product(s1, s2),
  cartesian_product(s1, s3))))

axiom cartesian_union_product :
  (forall s1:'a set. forall s2:'a set. forall s3:'b set.
  (cartesian_product(union(s1, s2), s3) = union(cartesian_product(s1, s3),
  cartesian_product(s2, s3))))

axiom cartesian_product_cardone_r :
  (forall s1:'a set. forall s2:'b set. ((cardinal(s1) = 1) ->
  infix_eqeq(cartesian_product(s1, s2), right_injections(choose(s1), s2))))

axiom cartesian_product_cardone_r1 :
  (forall s1:'a set. forall s2:'b set. ((cardinal(s1) = 1) ->
  infix_eqeq(cartesian_product(s1, s2), map(((Tuple2_closure : ('a,('b,('a,
  'b) tuple2) farray) farray)[choose(s1)]), s2))))

logic fc3 : 'b -> ('a,('a, 'b) tuple2) farray

axiom fcqtdef3 :
  (forall e:'b. forall e1:'a. (((fc3(e) : ('a,('a,
  'b) tuple2) farray)[e1]) = { Tuple2_proj_1 = e1; Tuple2_proj_2 = e }))

axiom cartesian_product_cardone_l :
  (forall s1:'a set. forall s2:'b set. ((cardinal(s2) = 1) ->
  infix_eqeq(cartesian_product(s1, s2), left_injections(s1, choose(s2)))))

axiom cartesian_product_cardone_l1 :
  (forall s1:'a set. forall s2:'b set. ((cardinal(s2) = 1) ->
  infix_eqeq(cartesian_product(s1, s2), map((fc3(choose(s2)) : ('a,('a,
  'b) tuple2) farray), s1))))

axiom disjoint_cartesian_product_l :
  (forall s1:'a set. forall s2:'a set. forall s3:'b set. ((inter(s1,
  s2) = (empty : 'a set)) -> (inter(cartesian_product(s1, s3),
  cartesian_product(s2, s3)) = (empty : ('a, 'b) tuple2 set))))

axiom disjoint_cartesian_product_r :
  (forall s1:'a set. forall s2:'b set. forall s3:'b set. ((inter(s2,
  s3) = (empty : 'b set)) -> (inter(cartesian_product(s1, s2),
  cartesian_product(s1, s3)) = (empty : ('a, 'b) tuple2 set))))

logic iter_union : 'a set set -> 'a set

axiom iter_unionqtdef :
  (forall s:'a set set. (infix_eqeq(s, (empty : 'a set set)) ->
  (iter_union(s) = (empty : 'a set))))

axiom iter_unionqtdef1 :
  (forall s:'a set set. ((not infix_eqeq(s, (empty : 'a set set))) ->
  (iter_union(s) = union(choose(s), iter_union(remove(choose(s), s))))))

axiom get_mem_union :
  (forall s:'a set. forall sqt:'a set. forall e:'a. (mem(e, union(s, sqt)) ->
  ((not mem(e, sqt)) -> mem(e, s))))

axiom get_mem_unionqt :
  (forall s:'a set. forall sqt:'a set. forall e:'a. (mem(e, union(s, sqt)) ->
  ((not mem(e, s)) -> mem(e, sqt))))

axiom set_mem_union :
  (forall s:'a set. forall sqt:'a set. forall e:'a. (mem(e, s) -> mem(e,
  union(s, sqt))))

axiom set_mem_unionqt :
  (forall s:'a set. forall sqt:'a set. forall e:'a. (mem(e, sqt) -> mem(e,
  union(s, sqt))))

predicate op_neutral_left(op1: ('im1,('im1,'im1) farray) farray,
  neutral: 'im1) = (forall e:'im1. (((op1[neutral])[e]) = e))

predicate op_neutral_right(op1: ('im1,('im1,'im1) farray) farray,
  neutral: 'im1) = (forall e:'im1. (((op1[e])[neutral]) = e))

predicate op_assoc(op1: ('im1,('im1,'im1) farray) farray) =
  (forall a:'im1. forall b:'im1. forall c:'im1.
  (((op1[((op1[a])[b])])[c]) = ((op1[a])[((op1[b])[c])])))

predicate op_neutral_left_comm(op1: ('im1,('im1,'im1) farray) farray,
  neutral: 'im1) =
  (forall a:'im1. ((forall b:'im1. (((op1[a])[b]) = b)) -> (a = neutral)))

predicate commut(op1: ('im1,('im1,'im1) farray) farray) =
  (forall a:'im1. forall b:'im1. (((op1[a])[b]) = ((op1[b])[a])))

predicate assoc(op1: ('im1,('im1,'im1) farray) farray) =
  (forall a:'im1. forall b:'im1. forall c:'im1.
  (((op1[((op1[a])[b])])[c]) = ((op1[a])[((op1[b])[c])])))

predicate opposite_n(op1: ('im1,('im1,'im1) farray) farray,
  po1: ('im1,('im1,'im1) farray) farray, neutral: 'im1) =
  (forall a:'im1. (((po1[a])[((op1[neutral])[a])]) = neutral))

predicate inverse(op1: ('im1,('im1,'im1) farray) farray,
  po1: ('im1,('im1,'im1) farray) farray, inver1: ('im1,'im1) farray) =
  (forall a:'im1. forall b:'im1. (((po1[a])[b]) = ((op1[a])[(inver1[b])])))

predicate opposite1(op1: ('im1,('im1,'im1) farray) farray,
  po1: ('im1,('im1,'im1) farray) farray) =
  (forall a:'im1. forall b:'im1. (((op1[((po1[a])[b])])[b]) = a))

predicate opposite_com(op1: ('im1,('im1,'im1) farray) farray,
  po1: ('im1,('im1,'im1) farray) farray) =
  (forall a:'im1. forall b:'im1. (((po1[((op1[a])[b])])[b]) = a))

axiom refl :
  (forall op1:('im1,('im1,'im1) farray) farray. forall a:'im1. forall b:'im1.
  (commut(op1) -> (((op1[a])[b]) = ((op1[b])[a]))))

predicate neutral(op1: ('im1,('im1,'im1) farray) farray, neut: 'im1) =
  (op_neutral_left(op1, neut) and (op_neutral_right(op1, neut) and
  op_assoc(op1)))

axiom set_neutral :
  (forall op1:('im1,('im1,'im1) farray) farray. forall neut:'im1.
  (op_neutral_left(op1, neut) -> (op_neutral_right(op1, neut) ->
  (op_assoc(op1) -> neutral(op1, neut)))))

predicate has_neutral(op1: ('im1,('im1,'im1) farray) farray) =
  (exists e:'im1. neutral(op1, e))

predicate iterates(op1: ('im1,('im1,'im1) farray) farray, neutral1: 'im1) =
  (op_neutral_left(op1, neutral1) and (op_neutral_right(op1, neutral1) and
  op_assoc(op1)))

predicate iterable(op1: ('im1,('im1,'im1) farray) farray) =
  (exists e:'im1. iterates(op1, e))

axiom iterates_ :
  (forall op1:('im1,('im1,'im1) farray) farray. forall neutral1:'im1.
  (op_neutral_left(op1, neutral1) -> (op_neutral_right(op1, neutral1) ->
  (op_assoc(op1) -> iterates(op1, neutral1)))))

axiom iterates_1 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall neutral1:'im1.
  (op_neutral_left(op1, neutral1) -> (op_neutral_right(op1, neutral1) ->
  (op_assoc(op1) -> iterable(op1)))))

logic neutral_elt : ('im1,('im1,'im1) farray) farray -> 'im1

axiom neutral_eltqtspec :
  (forall op1:('im1,('im1,'im1) farray) farray.
  (forall e:'im1. (neutral(op1, e) -> (neutral_elt(op1) = e))))

axiom neutral_eltqtspec1 :
  (forall op1:('im1,('im1,'im1) farray) farray.
  (forall e:'im1. ((neutral_elt(op1) = e) -> neutral(op1, e))))

predicate inverse_tuple(op1: ('im1,('im1,'im1) farray) farray,
  po1: ('im1,('im1,'im1) farray) farray, neutral1: 'im1) = (opposite_n(op1,
  po1, neutral1) and (opposite1(op1, po1) and opposite_com(op1, po1)))

logic iterate : ('im1,('im1,'im1) farray) farray, 'a set,
  ('a,'im1) farray -> 'im1

axiom iterateqtdef :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall f:('a,'im1) farray. (commut(op1) -> ((is_empty(s) ->
  iterable(op1)) -> ((cardinal(s) = 0) -> (iterate(op1, s,
  f) = neutral_elt(op1))))))

axiom iterateqtdef1 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall f:('a,'im1) farray. (commut(op1) -> ((is_empty(s) ->
  iterable(op1)) -> ((not (cardinal(s) = 0)) -> (iterate(op1, s,
  f) = ((op1[iterate(op1, remove(choose(s), s), f)])[(f[choose(s)])]))))))

axiom Iterate_def_empty :
  (forall op1:('im1,('im1,'im1) farray) farray.
  (forall s:'a set.
  (forall f:('a,'im1) farray. (commut(op1) -> (iterable(op1) ->
  (is_empty(s) -> (iterate(op1, (empty : 'a set), f) = neutral_elt(op1))))))))

axiom Iterate_one :
  (forall op1:('im1,('im1,'im1) farray) farray.
  (forall s:'a set.
  (forall f:('a,'im1) farray.
  (forall x:'a. (is_empty(s) -> (commut(op1) -> (iterate(op1, add(x, s),
  f) = (f[x]))))))))

axiom Iterate_add :
  (forall op1:('im1,('im1,'im1) farray) farray.
  (forall s:'a set.
  (forall f:('a,'im1) farray.
  (forall x:'a. ((0 <  cardinal(s)) -> (commut(op1) -> ((not mem(x, s)) ->
  (iterate(op1, add(x, s), f) = ((op1[(f[x])])[iterate(op1, s, f)])))))))))

axiom minus_zero :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall po1:('im1,('im1,'im1) farray) farray. forall a:'im1.
  (iterable(op1) -> (inverse_tuple(op1, po1, neutral_elt(op1)) ->
  (((po1[a])[neutral_elt(op1)]) = a))))

axiom unic :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall po1:('im1,('im1,'im1) farray) farray. forall a:'im1. forall b:'im1.
  forall c:'im1. (iterable(op1) -> (commut(op1) ->
  ((((op1[a])[b]) = ((op1[a])[c])) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) -> (b = c))))))

axiom substract_comm :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall po1:('im1,('im1,'im1) farray) farray. forall a:'im1. forall b:'im1.
  (iterable(op1) -> (commut(op1) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) -> (((po1[((op1[a])[b])])[a]) = b)))))

axiom substract_comm1 :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall po1:('im1,('im1,'im1) farray) farray. forall a:'im1. forall b:'im1.
  (iterable(op1) -> (commut(op1) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) -> (((po1[((op1[b])[a])])[a]) = b)))))

axiom substract_comm2 :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall po1:('im1,('im1,'im1) farray) farray. forall a:'im1. forall b:'im1.
  forall c:'im1. (iterable(op1) -> (commut(op1) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) ->
  (((po1[a])[((po1[b])[c])]) = ((op1[((po1[a])[b])])[c]))))))

axiom substract_comm3 :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall po1:('im1,('im1,'im1) farray) farray. forall a:'im1. forall b:'im1.
  forall c:'im1. (iterable(op1) -> (commut(op1) -> (inverse_tuple(op1, po1,
  neutral_elt(op1)) ->
  (((po1[((op1[a])[b])])[c]) = ((op1[a])[((po1[b])[c])]))))))

logic int_iterate : ('im1,('im1,'im1) farray) farray, (int,'im1) farray, int,
  int -> 'im1

axiom int_iterateqtdef :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. (((j <= i) -> iterable(op1)) -> ((j <= i) ->
  (int_iterate(op1, f, i, j) = neutral_elt(op1)))))

axiom int_iterateqtdef1 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. (((j <= i) -> iterable(op1)) ->
  ((not (j <= i)) -> ((j = (i + 1)) -> (int_iterate(op1, f, i,
  j) = (f[i]))))))

axiom int_iterateqtdef2 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. (((j <= i) -> iterable(op1)) ->
  ((not (j <= i)) -> ((not (j = (i + 1))) -> (int_iterate(op1, f, i,
  j) = ((op1[(f[i])])[int_iterate(op1, f, (i + 1), j)]))))))

axiom int_iterateqtspec :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. (((j <= i) -> iterable(op1)) -> ((j <= i) ->
  (int_iterate(op1, f, i, j) = neutral_elt(op1)))))

axiom int_iterateqtspec1 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. (((j <= i) -> iterable(op1)) ->
  ((j = (i + 1)) -> (int_iterate(op1, f, i,
  j) = ((op1[(f[i])])[neutral_elt(op1)])))))

logic int_int_iterate : ('im1,('im1,'im1) farray) farray,
  (int,(int,'im1) farray) farray, int, int, int, int -> 'im1

axiom int_int_iterateqtdef :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. (iterable(op1) -> ((j <= i) ->
  (int_int_iterate(op1, f, i, j, k, l) = neutral_elt(op1)))))

axiom int_int_iterateqtdef1 :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. (iterable(op1) -> ((not (j <= i)) ->
  (int_int_iterate(op1, f, i, j, k, l) = ((op1[int_iterate(op1, (f[i]), k,
  l)])[int_int_iterate(op1, f, (i + 1), j, k, l)])))))

axiom to_setqtspec :
  (forall e:'a. (forall b:'a. ((b = e) -> mem(b, add(e, (empty : 'a set))))))

axiom to_setqtspec1 : (forall e:'a. (cardinal(add(e, (empty : 'a set))) = 1))

axiom to_setqtspec2 :
  (forall e:'a. (forall b:'a. (mem(b, add(e, (empty : 'a set))) -> (b = e))))

logic to_fset : int, int -> int set

axiom to_fsetqtspec :
  (forall i:int. forall j:int. ((i <  j) -> (cardinal(to_fset(i,
  j)) = (j - i))))

axiom to_fsetqtspec1 :
  (forall i:int. forall j:int. ((j <= i) -> is_empty(to_fset(i, j))))

axiom to_fsetqtspec2 :
  (forall i:int. forall j:int.
  (forall k:int. (mem(k, to_fset(i, j)) -> (i <= k))))

axiom to_fsetqtspec3 :
  (forall i:int. forall j:int.
  (forall k:int. (mem(k, to_fset(i, j)) -> (k <  j))))

axiom to_fsetqtspec4 :
  (forall i:int. forall j:int.
  (forall k:int. (((i <= k) and (k <  j)) -> mem(k, to_fset(i, j)))))

axiom to_fset_bounds :
  (forall i:int. forall k:int. forall j:int. ((i <  j) -> (mem(k, to_fset(i,
  j)) -> (i <= k))))

axiom to_fset_bounds1 :
  (forall i:int. forall k:int. forall j:int. ((i <  j) -> (mem(k, to_fset(i,
  j)) -> (k <  j))))

axiom to_fset_unit_ext :
  (forall i:int. forall j:int. ((i <  j) -> (to_fset(i, j) = add(i,
  to_fset((i + 1), j)))))

axiom to_fset_ext :
  (forall i:int. forall iqt:int. forall j:int. (((i <= iqt) and
  (iqt <= j)) -> (to_fset(i, j) = union(to_fset(i, iqt), to_fset(iqt, j)))))

axiom card_fset : (forall n:int. ((0 <= n) -> (cardinal(to_fset(0, n)) = n)))

axiom card_fset_gen :
  (forall i:int. forall j:int. ((i <= j) -> (cardinal(to_fset(i,
  j)) = (j - i))))

axiom set_mem_to_fset :
  (forall i:int. forall k:int. forall j:int. (((i <= k) and (k <  j)) ->
  mem(k, to_fset(i, j))))

logic element : 'a set -> 'a

axiom elementqtdef :
  (forall s:'a set. ((cardinal(s) = 1) -> (element(s) = choose(s))))

axiom cardone :
  (forall s:'a set. forall a1:'a. ((forall b:'a. (mem(b, s) <-> (b = a1))) ->
  ((0 <  cardinal(s)) -> (cardinal(s) = 1))))

axiom cardone1 :
  (forall s:'a set. forall a1:'a. ((forall b:'a. (mem(b, s) <-> (b = a1))) ->
  ((0 <  cardinal(s)) -> (element(s) = a1))))

axiom set_cardone :
  (forall s:'a set. ((0 <  cardinal(s)) ->
  ((exists a1:'a. (forall b:'a. (mem(b, s) <-> (b = a1)))) ->
  (cardinal(s) = 1))))

axiom get_cardone :
  (forall s:'a set. ((cardinal(s) = 1) ->
  (exists a1:'a. (forall b:'a. (mem(b, s) <-> (b = a1))))))

axiom get_cardone_elt :
  (forall s:'a set. forall e:'a. ((cardinal(s) = 1) -> (mem(e, s) ->
  (e = element(s)))))

axiom set_cardone_elt :
  (forall s:'a set. forall a1:'a. ((forall b:'a. (mem(b, s) <-> (b = a1))) ->
  (cardinal(s) = 1)))

axiom set_cardone_elt1 :
  (forall s:'a set. forall a1:'a. ((forall b:'a. (mem(b, s) <-> (b = a1))) ->
  (element(s) = a1)))

axiom set_cardone_elt_ :
  (forall s:'a set. forall a1:'a. ((forall b:'a. (mem(b, s) <-> (b = a1))) ->
  (cardinal(s) = 1)))

axiom cardzero :
  (forall s:'a set. ((forall b:'a. (not mem(b, s))) -> (cardinal(s) = 0)))

axiom get_choose_cardone :
  (forall s:'a set. forall e:'a. ((cardinal(s) = 1) -> (mem(e, s) ->
  (choose(s) = e))))

axiom iterate_empty :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray. (is_empty(s) -> (commut(op1) ->
  (iterable(op1) -> (iterate(op1, s, t) = neutral_elt(op1))))))

axiom iterate_one :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray. ((cardinal(s) = 1) -> (commut(op1) ->
  (iterate(op1, s, t) = (t[choose(s)])))))

axiom iterate_add :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall f:('a,'im1) farray. forall x:'a. (commut(op1) -> (iterable(op1) ->
  ((not mem(x, s)) -> (iterate(op1, add(x, s),
  f) = ((op1[(f[x])])[iterate(op1, s, f)]))))))

axiom iterate_add_ :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall f:('a,'im1) farray. forall x:'a. (commut(op1) -> ((not mem(x, s)) ->
  ((not is_empty(s)) -> (iterate(op1, add(x, s),
  f) = ((op1[(f[x])])[iterate(op1, s, f)]))))))

logic po_closure : ('im1,('im1,'im1) farray) farray

axiom po_closure_def :
  (forall y:'im1. forall y1:'im1.
  ((((po_closure : ('im1,('im1,'im1) farray) farray)[y])[y1]) = po(y, y1)))

axiom iterate_remove :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall f:('a,'im1) farray. forall x:'a. (commut(op1) -> (iterable(op1) ->
  (inverse_tuple(op1, (po_closure : ('im1,('im1,'im1) farray) farray),
  neutral_elt(op1)) -> (mem(x, s) -> (iterate(op1, remove(x, s),
  f) = po(iterate(op1, s, f), (f[x]))))))))

axiom iterate_def_choose :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall f:('a,'im1) farray. (((cardinal(s) = 1) -> iterable(op1)) ->
  (commut(op1) -> ((not is_empty(s)) -> (iterate(op1, s,
  f) = ((op1[(f[choose(s)])])[iterate(op1, remove(choose(s), s), f)]))))))

axiom choose_any :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall f:('a,'im1) farray. forall t:'a. (iterable(op1) -> (commut(op1) ->
  (mem(t, s) -> (iterate(op1, s, f) = ((op1[(f[t])])[iterate(op1, remove(t,
  s), f)]))))))

logic fc4 : ('im1,('im1,'im1) farray) farray, ('a,'im1) farray,
  ('a,'im1) farray -> ('a,'im1) farray

axiom fcqtdef4 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:('a,'im1) farray.
  forall g:('a,'im1) farray. forall k:'a. ((fc4(op1, f,
  g)[k]) = ((op1[(f[k])])[(g[k])])))

axiom iterate_comp_iterate :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s1:'a set.
  forall f:('a,'im1) farray. forall g:('a,'im1) farray. (iterable(op1) ->
  (commut(op1) -> (assoc(op1) -> (iterate(op1, s1, fc4(op1, f,
  g)) = ((op1[iterate(op1, s1, f)])[iterate(op1, s1, g)]))))))

logic fc5 : ('im1,('im1,'im1) farray) farray, ('a,'im1) farray,
  ('a,'im1) farray -> ('a,'im1) farray

axiom fcqtdef5 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:('a,'im1) farray.
  forall g:('a,'im1) farray. forall k:'a. ((fc5(op1, f,
  g)[k]) = ((op1[(f[k])])[(g[k])])))

axiom iterate_comp_iterate_com :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s1:'a set.
  forall f:('a,'im1) farray. forall g:('a,'im1) farray. (iterable(op1) ->
  (commut(op1) -> (((op1[iterate(op1, s1, f)])[iterate(op1, s1,
  g)]) = iterate(op1, s1, fc5(op1, f, g))))))

axiom iterate_transitivity :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall po1:('im1,('im1,'im1) farray) farray. forall s1:'a set.
  forall s2:'a set. forall f:('a,'im1) farray. (iterable(op1) ->
  (commut(op1) -> (inverse_tuple(op1, po1, neutral_elt(op1)) -> (iterate(op1,
  union(s1, s2), f) = ((po1[((op1[iterate(op1, s1, f)])[iterate(op1, s2,
  f)])])[iterate(op1, inter(s1, s2), f)]))))))

axiom iterate_disjoint_transitivity :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s1:'a set.
  forall s2:'a set. forall t:('a,'im1) farray. (iterable(op1) ->
  (commut(op1) -> ((inter(s1, s2) = (empty : 'a set)) -> (iterate(op1,
  union(s1, s2), t) = ((op1[iterate(op1, s1, t)])[iterate(op1, s2, t)]))))))

axiom iterate_eq :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall f:('a,'im1) farray. forall g:('a,'im1) farray.
  ((forall x:'a. (mem(x, s) -> ((f[x]) = (g[x])))) -> (commut(op1) ->
  ((is_empty(s) -> iterable(op1)) -> (iterate(op1, s, f) = iterate(op1, s,
  g))))))

logic fc6 : ('b,'a) farray, ('a,'im1) farray -> ('b,'im1) farray

axiom fcqtdef6 :
  (forall f:('b,'a) farray. forall t:('a,'im1) farray. forall b1:'b. ((fc6(f,
  t)[b1]) = (t[(f[b1])])))

axiom iterate_map :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'b set.
  forall f:('b,'a) farray. forall t:('a,'im1) farray. ((is_empty(s) ->
  iterable(op1)) -> (commut(op1) -> (p_injective(f, s) -> (iterate(op1,
  map(f, s), t) = iterate(op1, s, fc6(f, t)))))))

axiom iterate_cardone :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray. (iterable(op1) -> (commut(op1) ->
  ((cardinal(s) = 1) -> (iterate(op1, s, t) = (t[element(s)]))))))

axiom iterate_cardzero :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray. (commut(op1) -> (iterable(op1) ->
  ((cardinal(s) = 0) -> (iterate(op1, s, t) = neutral_elt(op1))))))

logic fc7 : ('a,('b,'im1) farray) farray -> (('a, 'b) tuple2,'im1) farray

axiom fcqtdef7 :
  (forall f:('a,('b,'im1) farray) farray. forall o:('a, 'b) tuple2.
  ((fc7(f)[o]) = ((f[fir(o)])[sec(o)])))

axiom injec_iterate :
  (forall op1:('im1,('im1,'im1) farray) farray. forall a:'a1.
  forall s:'b set. forall f:('a1,('b,'im1) farray) farray. (iterable(op1) ->
  (commut(op1) -> (iterate(op1, s, (f[a])) = iterate(op1,
  cartesian_product(add(a, (empty : 'a1 set)), s), fc7(f))))))

logic fc8 : ('im1,('im1,'im1) farray) farray, 'b set,
  ('a,('b,'im1) farray) farray -> ('a,'im1) farray

logic fc9 : ('a,('b,'im1) farray) farray -> (('a, 'b) tuple2,'im1) farray

axiom fcqtdef8 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s2:'b set.
  forall f:('a,('b,'im1) farray) farray. forall a1:'a. ((fc8(op1, s2,
  f)[a1]) = iterate(op1, s2, (f[a1]))))

axiom fcqtdef9 :
  (forall f:('a,('b,'im1) farray) farray. forall o:('a, 'b) tuple2.
  ((fc9(f)[o]) = ((f[fir(o)])[sec(o)])))

axiom iterate_cartesian_product :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s1:'a set.
  forall s2:'b set. forall f:('a,('b,'im1) farray) farray. (iterable(op1) ->
  (commut(op1) -> (iterate(op1, s1, fc8(op1, s2, f)) = iterate(op1,
  cartesian_product(s1, s2), fc9(f))))))

axiom iterate_eq_func :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall f1:('a,'im1) farray. forall f2:('a,'im1) farray. (commut(op1) ->
  (iterable(op1) -> (p_injective(f1, s) -> (p_injective(f2, s) -> ((map(f1,
  s) = map(f2, s)) -> (iterate(op1, s, f1) = iterate(op1, s, f2))))))))

predicate p_injective_in(f: ('a,'b) farray, s: 'a set, sqt: 'b set) =
  (forall e:'a. (mem(e, s) -> (mem((f[e]), sqt) and
  (forall e1:'a. forall eqt:'a. (mem(e1, s) -> (mem(eqt, s) ->
  ((not (e1 = eqt)) -> (not ((f[e1]) = (f[eqt]))))))))))

predicate equal_func(f: ('a,'b) farray, g: ('a,'b) farray) =
  (forall e:'a. ((f[e]) = (g[e])))

axiom set_equal_func :
  (forall f:('a,'b) farray. forall g:('a,'b) farray.
  ((forall e:'a. ((f[e]) = (g[e]))) -> (f = g)))

axiom get_equal_func :
  (forall f:('a,'b) farray. forall g:('a,'b) farray. (equal_func(f, g) ->
  (forall e:'a. ((f[e]) = (g[e])))))

axiom set_injective :
  (forall f:('a,'b) farray. forall s:'a set.
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  p_injective(f, s)))

axiom imageqtspec :
  (forall f:('a,'b) farray. forall s:'a set.
  (forall a1:'b. (mem(a1, map(f, s)) ->
  (exists antec_a:'a. (mem(antec_a, s) and (a1 = (f[antec_a])))))))

axiom imageqtspec1 :
  (forall f:('a,'b) farray. forall s:'a set.
  (forall a1:'b.
  ((exists antec_a:'a. (mem(antec_a, s) and (a1 = (f[antec_a])))) -> mem(a1,
  map(f, s)))))

axiom card_image :
  (forall f:('a,'b) farray. forall s:'a set. (cardinal(map(f,
  s)) <= cardinal(s)))

axiom card_image_injective :
  (forall f:('a,'b) farray. forall s:'a set. (p_injective(f, s) ->
  (cardinal(map(f, s)) = cardinal(s))))

axiom get_injective :
  (forall f:('a,'b) farray. forall s:'a set. (p_injective(f, s) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  ((not (e = eqt)) -> (not ((f[e]) = (f[eqt])))))))))

axiom get_not_injective :
  (forall f:('a,'b) farray. forall s:'a set. ((not p_injective(f, s)) ->
  (exists e:'a. exists eqt:'a. (mem(e, s) and (mem(eqt, s) and
  ((not (e = eqt)) and ((f[e]) = (f[eqt]))))))))

axiom set_injective_in :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  p_injective(f, s))))

axiom get_injective_in :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_injective_in(f, s, sqt) ->
  (forall e:'a. (mem(e, s) -> mem((f[e]), sqt)))))

axiom get_injective_in1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_injective_in(f, s, sqt) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  ((not (e = eqt)) -> (not ((f[e]) = (f[eqt])))))))))

predicate p_surjective(f: ('a,'b) farray, s: 'a set, sqt: 'b set) =
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) and
  (forall eqt:'b. (mem(eqt, sqt) ->
  (exists e:'a. (mem(e, s) and ((f[e]) = eqt))))))

axiom set_surjective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) ->
  ((forall eqt:'b. (mem(eqt, sqt) ->
   (exists e:'a. (mem(e, s) and ((f[e]) = eqt))))) ->
  p_surjective(f, s, sqt))))

axiom get_surjective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_surjective(f, s, sqt) ->
  (forall e:'a. (mem(e, s) -> mem((f[e]), sqt)))))

axiom get_surjective1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_surjective(f, s, sqt) ->
  (forall eqt:'b. (mem(eqt, sqt) ->
  (exists e:'a. (mem(e, s) and ((f[e]) = eqt)))))))

axiom image_surjective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_surjective(f, s, sqt) -> (map(f, s) = sqt)))

predicate p_bijective(f: ('a,'b) farray, s: 'a set, sqt: 'b set) =
  (p_injective_in(f, s, sqt) and p_surjective(f, s, sqt))

axiom bijective_is_injective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> p_injective(f, s)))

axiom p_bijective_in :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set. forall a1:'a.
  (p_bijective(f, s, sqt) -> (mem(a1, s) -> mem((f[a1]), sqt))))

axiom bijective_is_surjective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> p_surjective(f, s, sqt)))

axiom auto_bijective_in :
  (forall f:('a,'a) farray. forall s:'a set. forall a1:'a. (p_bijective(f, s,
  s) -> (mem(a1, s) -> mem((f[a1]), s))))

axiom set_bijective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:'b. (mem(eqt, sqt) ->
   (exists e:'a. (mem(e, s) and ((f[e]) = eqt))))) ->
  p_bijective(f, s, sqt)))))

axiom set_bijective1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:'b. (mem(eqt, sqt) ->
   (exists e:'a. (mem(e, s) and ((f[e]) = eqt))))) ->
  (map(f, s) = sqt)))))

logic fc10 : ('a,'b) farray, ('b,'c) farray -> ('a,'c) farray

axiom fcqtdef10 :
  (forall f:('a,'b) farray. forall g:('b,'c) farray. forall k:'a. ((fc10(f,
  g)[k]) = (g[(f[k])])))

axiom bijectivity_is_transitive :
  (forall f:('a,'b) farray. forall g:('b,'c) farray. forall s:'a set.
  forall sqt:'b set. forall sqtqt:'c set. (p_bijective(f, s, sqt) ->
  (p_bijective(g, sqt, sqtqt) -> p_bijective(fc10(f, g), s, sqtqt))))

axiom bijective_image :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> (cardinal(s) = cardinal(sqt))))

axiom bijective_image1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> (sqt = map(f, s))))

axiom get_bijective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> (forall e:'a. (mem(e, s) -> mem((f[e]), sqt)))))

axiom get_bijective1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  ((not (e = eqt)) -> (not ((f[e]) = (f[eqt])))))))))

axiom get_bijective2 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) ->
  (forall eqt:'b. (mem(eqt, sqt) ->
  (exists e:'a. (mem(e, s) and ((f[e]) = eqt)))))))

axiom get_bijective3 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> (cardinal(s) = cardinal(sqt))))

axiom bijective_eq :
  (forall f:('a,'b) farray. forall g:('a,'b) farray. forall s:'a set.
  forall sqt:'b set. (p_bijective(f, s, sqt) ->
  ((forall e:'a. (mem(e, s) -> ((f[e]) = (g[e])))) -> p_bijective(g, s,
  sqt))))

axiom bijective_eq_gen :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) ->
  (forall g:('a,'b) farray.
  ((forall e:'a. (mem(e, s) -> ((f[e]) = (g[e])))) -> p_bijective(g, s,
  sqt)))))

axiom bij_equal_card :
  (forall f:('a,'b) farray. forall s:'a set. ((cardinal(s) = cardinal(map(f,
  s))) -> p_bijective(f, s, map(f, s))))

axiom set_bijective_auto :
  (forall f:('a,'a) farray. forall s:'a set.
  ((forall e:'a. (mem(e, s) -> mem((f[e]), s))) ->
  ((forall eqt:'a. (mem(eqt, s) ->
   (exists e:'a. (mem(e, s) and ((f[e]) = eqt))))) ->
  p_bijective(f, s, s))))

logic inverse_pre : ('a,'b) farray, 'a set, 'b set, 'b -> 'a

axiom inverse_preqtspec :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set. forall b1:'b.
  (p_bijective(f, sa, sb) -> (mem(b1, sb) -> mem(inverse_pre(f, sa, sb, b1),
  sa))))

axiom inverse_preqtspec1 :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set. forall b1:'b.
  (p_bijective(f, sa, sb) -> (mem(b1, sb) -> ((f[inverse_pre(f, sa, sb,
  b1)]) = b1))))

logic inverse1 : ('a,'b) farray, 'a set, 'b set -> ('b,'a) farray

axiom inverseqtdef :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set.
  (p_bijective(f, sa, sb) ->
  (forall x:'b. ((inverse1(f, sa, sb)[x]) = (if mem(x,
  sb) then inverse_pre(f, sa, sb, x) else choose(sa))))))

axiom inverseqtspec :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set.
  (p_bijective(f, sa, sb) ->
  (forall b1:'b. (mem(b1, sb) -> mem((inverse1(f, sa, sb)[b1]), sa)))))

axiom inverseqtspec1 :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set.
  (p_bijective(f, sa, sb) ->
  (forall b1:'b. (mem(b1, sb) -> ((f[(inverse1(f, sa, sb)[b1])]) = b1)))))

axiom inverseqtspec2 :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set.
  (p_bijective(f, sa, sb) -> p_bijective(inverse1(f, sa, sb), sb, sa)))

axiom unic_inverse :
  (forall f:('a,'b) farray. forall fqt:('b,'a) farray. forall sa:'a set.
  forall sb:'b set. (p_bijective(f, sa, sb) ->
  ((forall a1:'a. (mem(a1, sa) -> ((fqt[(f[a1])]) = a1))) ->
  (forall b1:'b. (mem(b1, sb) -> ((fqt[b1]) = (inverse1(f, sa, sb)[b1])))))))

axiom unic_inverse_apply :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set. forall b1:'b.
  forall a1:'a. (p_bijective(f, sa, sb) -> (mem(b1, sb) -> (mem(a1, sa) ->
  (((f[a1]) = b1) -> ((inverse1(f, sa, sb)[b1]) = a1))))))

axiom inverse_invol :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set. forall a1:'a.
  (p_bijective(f, sa, sb) -> (mem(a1, sa) -> ((inverse1(inverse1(f, sa, sb),
  sb, sa)[a1]) = (f[a1])))))

axiom compose_inverse :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set. forall b1:'b.
  (p_bijective(f, sa, sb) -> (mem(b1, sb) -> ((f[(inverse1(f, sa,
  sb)[b1])]) = b1))))

axiom inverse_compose :
  (forall f:('a,'b) farray. forall sa:'a set. forall sb:'b set. forall a1:'a.
  (p_bijective(f, sa, sb) -> (mem(a1, sa) -> ((inverse1(f, sa,
  sb)[(f[a1])]) = a1))))

axiom int_iterate_def_empty :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. ((j <= i) -> (iterable(op1) ->
  (int_iterate(op1, f, i, j) = neutral_elt(op1)))))

axiom int_iterate_def_plus_one :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. ((i <  j) -> ((((i + 1) = j) ->
  iterable(op1)) -> (int_iterate(op1, f, i,
  j) = ((op1[(f[i])])[int_iterate(op1, f, (i + 1), j)])))))

axiom int_iterate_cardone :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. ((j = (i + 1)) -> (int_iterate(op1, f, i,
  j) = (f[i]))))

axiom int_iterate_def_plus_one_com :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. ((i <  j) -> (((j = (i + 1)) ->
  iterable(op1)) -> (((op1[(f[i])])[int_iterate(op1, f, (i + 1),
  j)]) = int_iterate(op1, f, i, j)))))

axiom int_iterate_to_iterate :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. (((j <= i) -> iterable(op1)) -> (commut(op1) ->
  (int_iterate(op1, f, i, j) = iterate(op1, to_fset(i, j), f)))))

axiom int_iterate_right_extension :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. (iterable(op1) -> ((i <  j) ->
  (int_iterate(op1, f, i, j) = ((op1[int_iterate(op1, f, i,
  (j - 1))])[(f[(j - 1)])])))))

axiom int_iterate_right_extension_ :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. (assoc(op1) -> (((i + 1) <  j) ->
  (int_iterate(op1, f, i, j) = ((op1[int_iterate(op1, f, i,
  (j - 1))])[(f[(j - 1)])])))))

axiom int_iterate_transitivity :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall k:int. forall j:int. (iterable(op1) ->
  (iterable(op1) -> (op_neutral_left(op1, neutral_elt(op1)) -> (((i <= k) and
  (k <= j)) -> (int_iterate(op1, f, i, j) = ((op1[int_iterate(op1, f, i,
  k)])[int_iterate(op1, f, k, j)])))))))

axiom int_iterate_transitivity_ :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall k:int. forall j:int. (op_neutral_left(op1,
  neutral_elt(op1)) -> (((i <  k) and (k <  j)) -> (int_iterate(op1, f, i,
  j) = ((op1[int_iterate(op1, f, i, k)])[int_iterate(op1, f, k, j)])))))

logic fc11 : ('im1,('im1,'im1) farray) farray, (int,'im1) farray,
  (int,'im1) farray -> (int,'im1) farray

axiom fcqtdef11 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall g:(int,'im1) farray. forall k:int. ((fc11(op1, f,
  g)[k]) = ((op1[(f[k])])[(g[k])])))

axiom int_iterate_comp_iterate :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall g:(int,'im1) farray. forall i:int. forall j:int. (iterable(op1) ->
  (op_neutral_right(op1, neutral_elt(op1)) -> (commut(op1) ->
  (int_iterate(op1, fc11(op1, f, g), i, j) = ((op1[int_iterate(op1, f, i,
  j)])[int_iterate(op1, g, i, j)]))))))

axiom int_iterate_attr_no_f :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall op2:('im2,('im2,'im2) farray) farray. forall t1:(int,'im1) farray.
  forall t2:(int,'im2) farray. forall f:('im1,'im2) farray. forall i:int.
  forall j:int.
  ((forall x:int.
   (forall y:'im1. (((op2[(t2[x])])[(f[y])]) = (f[((op1[(t1[x])])[y])])))) ->
  (((f[neutral_elt(op1)]) = neutral_elt(op2)) -> (iterable(op1) ->
  (iterable(op2) -> ((forall i1:int. ((f[(t1[i1])]) = (t2[i1]))) ->
  (int_iterate(op2, t2, i, j) = (f[int_iterate(op1, t1, i, j)]))))))))

logic fc12 : (int,'im1) farray, ('im1,'im2) farray -> (int,'im2) farray

axiom fcqtdef12 :
  (forall t:(int,'im1) farray. forall f:('im1,'im2) farray. forall e:int.
  ((fc12(t, f)[e]) = (f[(t[e])])))

axiom int_iterate_attr :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall op2:('im2,('im2,'im2) farray) farray. forall t:(int,'im1) farray.
  forall f:('im1,'im2) farray. forall i:int. forall j:int.
  ((forall x:int.
   (forall y:'im1. (((op2[(f[(t[x])])])[(f[y])]) = (f[((op1[(t[x])])[y])])))) ->
  (((f[neutral_elt(op1)]) = neutral_elt(op2)) -> (iterable(op1) ->
  (iterable(op2) -> (int_iterate(op2, fc12(t, f), i, j) = (f[int_iterate(op1,
  t, i, j)])))))))

logic fc13 : (int,'im1) farray, ('im1,'im2) farray -> (int,'im2) farray

axiom fcqtdef13 :
  (forall t:(int,'im1) farray. forall f:('im1,'im2) farray. forall e:int.
  ((fc13(t, f)[e]) = (f[(t[e])])))

axiom int_iterate_attr_comm :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall op2:('im2,('im2,'im2) farray) farray. forall t:(int,'im1) farray.
  forall f:('im1,'im2) farray. forall i:int. forall j:int.
  ((forall x:int.
   (forall y:'im1. (((op2[(f[(t[x])])])[(f[y])]) = (f[((op1[(t[x])])[y])])))) ->
  (((f[neutral_elt(op1)]) = neutral_elt(op2)) -> (iterable(op1) ->
  (iterable(op2) -> ((f[int_iterate(op1, t, i, j)]) = int_iterate(op2,
  fc13(t, f), i, j)))))))

axiom int_iterate_eq :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall g:(int,'im1) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (((j <= i) -> iterable(op1)) -> (int_iterate(op1, f, i,
  j) = int_iterate(op1, g, i, j)))))

logic fc14 : (int,'im1) farray, int, int -> (int,'im1) farray

axiom fcqtdef14 :
  (forall f:(int,'im1) farray. forall l:int. forall h:int. forall a:int.
  ((fc14(f, l, h)[a]) = (f[((h - (a + 1)) + l)])))

axiom int_iterate_left_right :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall l:int. forall k:int. forall h:int. (iterable(op1) -> (commut(op1) ->
  (((l <= k) and (k <= h)) -> (int_iterate(op1, f, l, k) = int_iterate(op1,
  fc14(f, l, h), ((h - k) + l), h))))))

axiom int_iterate_eq_func :
  (forall op1:('im1,('im1,'im1) farray) farray. forall i:int. forall j:int.
  forall f:(int,'im1) farray. forall g:(int,'im1) farray. (iterable(op1) ->
  (commut(op1) -> (p_injective(f, to_fset(i, j)) -> (p_injective(g,
  to_fset(i, j)) -> ((map(f, to_fset(i, j)) = map(g, to_fset(i, j))) ->
  (int_iterate(op1, f, i, j) = int_iterate(op1, g, i, j))))))))

logic fc15 : (int,int) farray, (int,'im1) farray -> (int,'im1) farray

axiom fcqtdef15 :
  (forall f:(int,int) farray. forall t:(int,'im1) farray. forall b:int.
  ((fc15(f, t)[b]) = (t[(f[b])])))

axiom int_iterate_map :
  (forall op1:('im1,('im1,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. forall f:(int,int) farray.
  forall t:(int,'im1) farray. (((j <= i) -> iterable(op1)) -> (commut(op1) ->
  (p_bijective(f, to_fset(i, j), to_fset(k, l)) -> (int_iterate(op1, t, k,
  l) = int_iterate(op1, fc15(f, t), i, j))))))

logic fc16 : (int,'im1) farray, int -> (int,'im1) farray

axiom fcqtdef16 :
  (forall f:(int,'im1) farray. forall k:int. forall b:int. ((fc16(f,
  k)[b]) = (f[(b + k)])))

axiom int_iterate_transl :
  (forall op1:('im1,('im1,'im1) farray) farray. forall f:(int,'im1) farray.
  forall i:int. forall j:int. forall k:int. (iterable(op1) ->
  (int_iterate(op1, f, i, j) = int_iterate(op1, fc16(f, k), (i - k),
  (j - k)))))

logic fc17 : (int,int) farray, (int,'im1) farray -> (int,'im1) farray

axiom fcqtdef17 :
  (forall f:(int,int) farray. forall t:(int,'im1) farray. forall b:int.
  ((fc17(f, t)[b]) = (t[(f[b])])))

axiom int_iterate_map_auto :
  (forall op1:('im1,('im1,'im1) farray) farray. forall i:int. forall j:int.
  forall f:(int,int) farray. forall t:(int,'im1) farray. (((j <= i) ->
  iterable(op1)) -> (commut(op1) -> (p_bijective(f, to_fset(i, j), to_fset(i,
  j)) -> (int_iterate(op1, t, i, j) = int_iterate(op1, fc17(f, t), i, j))))))

axiom leq_trans :
  (forall a:int. forall b:int. forall c:int. ((a <= b) -> ((b <= c) ->
  (a <= c))))

axiom inf_trans :
  (forall a:int. forall b:int. forall c:int. ((a <  b) -> ((b <  c) ->
  (a <  c))))

axiom leq_trans_add :
  (forall a:int. forall b:int. forall c:int. forall d:int. ((a <= c) ->
  ((b <= d) -> ((a + b) <= (c + d)))))

axiom leq_trans_mult :
  (forall a:int. forall b:int. forall c:int. ((0 <= c) -> ((a <= b) ->
  ((a * c) <= (b * c)))))

axiom leq_trans_mult_right :
  (forall a:int. forall b:int. forall c:int. ((0 <= c) -> ((a <= b) ->
  ((c * a) <= (c * b)))))

axiom compat_int_order_mult :
  (forall a:int. forall b:int. forall c:int. forall d:int. (((0 <= c) and
  (c <= d)) -> (((0 <= a) and (a <= b)) -> ((c * a) <= (d * b)))))

axiom leq_trans_fact :
  (forall a:int. forall b:int. forall c:int. forall n:int. ((0 <= n) ->
  (((0 <= a) and (a <= c)) -> (((0 <= b) and (b <= (c * n))) ->
  ((a + b) <= (c * (n + 1)))))))

axiom leq_trans_facrev :
  (forall a:int. forall b:int. forall c:int. forall n:int. ((0 <= n) ->
  (((0 <= a) and (a <= c)) -> (((0 <= b) and (b <= (c * n))) ->
  ((b + a) <= (c * (n + 1)))))))

logic infix_pl_closure : (int,(int,int) farray) farray

logic infix_as_closure : (int,(int,int) farray) farray

axiom infix_pl_closure_def :
  (forall y:int. forall y1:int. (((infix_pl_closure[y])[y1]) = (y + y1)))

axiom infix_as_closure_def :
  (forall y:int. forall y1:int. (((infix_as_closure[y])[y1]) = (y * y1)))

axiom neutrals : (0 = neutral_elt(infix_pl_closure))

axiom neutrals1 : (1 = neutral_elt(infix_as_closure))

axiom neutrals2 : iterable(infix_pl_closure)

axiom neutrals3 : iterable(infix_as_closure)

function isum(s: 'a set, t: ('a,int) farray) : int =
  iterate(infix_pl_closure, s, t)

function iproduct(s: 'a set, t: ('a,int) farray) : int =
  iterate(infix_as_closure, s, t)

axiom isum_iter : iterates(infix_pl_closure, 0)

axiom isum_iter__ : iterable(infix_pl_closure)

axiom isum_eq :
  (forall s:'a set. forall t:('a,int) farray. forall tqt:('a,int) farray.
  ((forall e:'a. (mem(e, s) -> ((t[e]) = (tqt[e])))) -> (isum(s, t) = isum(s,
  tqt))))

axiom isum_eq_gen :
  (forall s:'a set. forall sqt:'a set. forall t:('a,int) farray.
  forall tqt:('a,int) farray. ((s = sqt) ->
  ((forall e:'a. (mem(e, s) -> ((t[e]) = (tqt[e])))) -> (isum(s, t) = isum(s,
  tqt)))))

axiom isum_add :
  (forall s:'b set. forall f:('b,int) farray. forall x:'b. ((not mem(x,
  s)) -> (isum(add(x, s), f) = ((f[x]) + isum(s, f)))))

axiom iproduct_eq :
  (forall s:'a set. forall t:('a,int) farray. forall tqt:('a,int) farray.
  ((forall e:'a. (mem(e, s) -> ((t[e]) = (tqt[e])))) -> (iproduct(s,
  t) = iproduct(s, tqt))))

axiom iproduct_eq_gen :
  (forall s:'a set. forall sqt:'a set. forall t:('a,int) farray.
  forall tqt:('a,int) farray. ((s = sqt) ->
  ((forall e:'a. (mem(e, s) -> ((t[e]) = (tqt[e])))) -> (iproduct(s,
  t) = iproduct(s, tqt)))))

axiom iproduct_add :
  (forall s:'b set. forall f:('b,int) farray. forall x:'b. ((not mem(x,
  s)) -> (iproduct(add(x, s), f) = ((f[x]) * iproduct(s, f)))))

axiom iproduct_from_choose :
  (forall s:'b set. forall f:('b,int) farray. ((0 <  cardinal(s)) ->
  (iproduct(s, f) = ((f[choose(s)]) * iproduct(remove(choose(s), s), f)))))

logic fc18 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef18 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc18(f, t)[b]) = (t[(f[b])])))

axiom iproduct_map :
  (forall s:int set. forall f:(int,int) farray. forall t:(int,int) farray.
  (p_injective(f, s) -> (iproduct(map(f, s), t) = iproduct(s, fc18(f, t)))))

logic fc19 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef19 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc19(f, t)[b]) = (t[(f[b])])))

axiom iproduct_map_auto :
  (forall s:int set. forall f:(int,int) farray. forall t:(int,int) farray.
  (p_bijective(f, s, s) -> (iproduct(s, t) = iproduct(s, fc19(f, t)))))

axiom iproduct_one :
  (forall s:'a set. forall f:('a,int) farray.
  ((forall e:'a. (mem(e, s) -> ((f[e]) = 1))) -> (iproduct(s, f) = 1)))

axiom iproduct_one_but_maybe_one_elt :
  (forall s:'a set. forall f:('a,int) farray. forall e:'a. (mem(e, s) ->
  ((forall eqt:'a. (mem(eqt, s) -> ((not (eqt = e)) -> ((f[eqt]) = 1)))) ->
  (iproduct(s, f) = (f[e])))))

axiom iproduct_one_but_maybe_one_elt1 :
  (forall s:'a set. forall f:('a,int) farray. forall e:'a. (mem(e, s) ->
  ((forall eqt:'a. (mem(eqt, s) -> ((not (eqt = e)) -> ((f[eqt]) = 1)))) ->
  (iproduct(s, f) = ((f[choose(s)]) * iproduct(remove(choose(s), s), f))))))

axiom mul_assoc :
  (forall a:int. forall b:int. forall c:int. (((a * b) * c) = (a * (b * c))))

axiom ad_assoc :
  (forall a:int. forall b:int. forall c:int. (((a + b) + c) = (a + (b + c))))

axiom ad_assoc_rev :
  (forall a:int. forall b:int. forall c:int. ((a + (b + c)) = ((a + b) + c)))

axiom ad_seq_switch :
  (forall a:int. forall b:int. forall c:int. forall aqt:int. forall bqt:int.
  forall cqt:int. ((a = aqt) -> ((b = bqt) -> ((c = cqt) ->
  ((aqt + (bqt + cqt)) = (b + (c + a)))))))

axiom mul_comm : (forall a:int. forall b:int. ((a * b) = (b * a)))

axiom add_eq_i :
  (forall a:int. forall aqt:int. forall b:int. forall bqt:int. ((a = aqt) ->
  ((b = bqt) -> ((a + b) = (aqt + bqt)))))

axiom mult_eq_i :
  (forall a:int. forall aqt:int. forall b:int. forall bqt:int. ((a = aqt) ->
  ((b = bqt) -> ((a * b) = (aqt * bqt)))))

axiom mul_assoc_rev :
  (forall a:int. forall b:int. forall c:int. ((a * (b * c)) = ((a * b) * c)))

axiom mult_add_distr :
  (forall a:int. forall b:int. forall c:int. forall d:int.
  (((a + b) * (c + d)) = ((((a * c) + (a * d)) + (b * c)) + (b * d))))

axiom mult_add_right :
  (forall a:int. forall b:int. forall c:int.
  (((a + b) * c) = ((a * c) + (b * c))))

axiom mult_add_right_rev :
  (forall a:int. forall b:int. forall c:int.
  (((a * c) + (b * c)) = ((a + b) * c)))

axiom mult_add_left :
  (forall a:int. forall b:int. forall c:int.
  ((a * (b + c)) = ((a * b) + (a * c))))

axiom mult_add_left_rev :
  (forall a:int. forall b:int. forall c:int.
  (((a * b) + (a * c)) = (a * (b + c))))

axiom mult_add_distr_rev :
  (forall a:int. forall b:int. forall c:int. forall d:int.
  (((((a * c) + (a * d)) + (b * c)) + (b * d)) = ((a + b) * (c + d))))

axiom mul_assoc_comm :
  (forall a:int. forall b:int. forall c:int. (((a * b) * c) = (b * (a * c))))

axiom mul_assoc_rev_comm :
  (forall a:int. forall b:int. forall c:int. ((a * (b * c)) = ((a * c) * b)))

axiom add_assoc1 :
  (forall a:int. forall b:int. forall c:int. (((a + b) + c) = (a + (b + c))))

axiom add_assoc_rev1 :
  (forall a:int. forall b:int. forall c:int. ((a + (b + c)) = ((a + b) + c)))

axiom isum_empty :
  (forall s:'a set. forall f:('a,int) farray. (is_empty(s) -> (isum(s,
  f) = 0)))

axiom iproduct_empty :
  (forall s:'a set. forall f:('a,int) farray. (is_empty(s) -> (iproduct(s,
  f) = 1)))

logic infix_mn_closure : (int,(int,int) farray) farray

axiom infix_mn_closure_def :
  (forall y:int. forall y1:int. (((infix_mn_closure[y])[y1]) = (y - y1)))

axiom isum_iter_ : opposite_n(infix_pl_closure, infix_mn_closure, 0)

axiom isum_iter_1 : opposite1(infix_pl_closure, infix_mn_closure)

axiom isum_iter_2 : opposite_com(infix_pl_closure, infix_mn_closure)

axiom isum_iter_3 : inverse_tuple(infix_pl_closure, infix_mn_closure, 0)

axiom pos_to_strict : (forall a:int. ((1 <= a) -> (0 <  a)))

axiom pos_by_strict : (forall a:int. ((0 <  a) -> (1 <= a)))

function ind_iproduct(f: (int,int) farray, i: int, j: int) : int =
  int_iterate(infix_as_closure, f, i, j)

axiom ind_iproduct_eq :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ind_iproduct(f, i, j) = ind_iproduct(g, i, j))))

axiom ind_iproduct_eq_gen :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i1:int.
  forall j1:int. forall i2:int. forall j2:int.
  ((forall k:int. (((i1 <= k) and (k <  j1)) -> ((f[k]) = (g[k])))) ->
  ((i1 = i2) -> ((j1 = j2) -> (ind_iproduct(f, i1, j1) = ind_iproduct(g, i2,
  j2))))))

axiom ind_iproduct_to_iproduct :
  (forall f:(int,int) farray. forall i:int. forall j:int. (ind_iproduct(f, i,
  j) = iproduct(to_fset(i, j), f)))

axiom ind_iproduct_one_but_maybe_one_elt :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall e:int.
  (((i <= e) and (e <  j)) ->
  ((forall eqt:int. (((i <= eqt) and (eqt <= j)) -> ((not (e = eqt)) ->
   ((f[eqt]) = 1)))) ->
  (ind_iproduct(f, i, j) = (f[e])))))

axiom mult_one_int : (forall a:int. forall b:int. ((b = 1) -> ((a * b) = a)))

axiom one_mult_int : (forall a:int. forall b:int. ((a = 1) -> ((a * b) = b)))

axiom mult_zero_int :
  (forall a:int. forall b:int. ((b = 0) -> ((a * b) = 0)))

axiom zero_mult_int :
  (forall a:int. forall b:int. ((a = 0) -> ((a * b) = 0)))

axiom iproduct_to_iterate :
  (forall f:(int,int) farray. forall i:int. forall j:int. (ind_iproduct(f, i,
  j) = int_iterate(infix_as_closure, f, i, j)))

axiom ind_iproduct_empty :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((j <= i) ->
  (ind_iproduct(f, i, j) = 1)))

axiom ind_iproduct_plus_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_iproduct(f, i, j) = ((f[i]) * ind_iproduct(f, (i + 1), j)))))

axiom ind_iproduct_right_extension :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_iproduct(f, i, j) = (ind_iproduct(f, i, (j - 1)) * (f[(j - 1)])))))

axiom ind_iproduct_right_extension_comm :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  ((ind_iproduct(f, i, (j - 1)) * (f[(j - 1)])) = ind_iproduct(f, i, j))))

axiom ind_iproduct_comp :
  (forall f:(int,int) farray. forall g:(int,int) farray.
  forall h:(int,int) farray. forall i:int. forall j:int. ((i <= j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> (((f[k]) * (g[k])) = (h[k])))) ->
  (ind_iproduct(h, i, j) = (ind_iproduct(f, i, j) * ind_iproduct(g, i,
  j))))))

axiom ind_iproduct_one :
  (forall f:(int,int) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = 1))) ->
  (ind_iproduct(f, i, j) = 1)))

axiom positive_iproduct :
  (forall f:(int,int) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> (0 <  (f[k])))) ->
  (0 <  ind_iproduct(f, i, j))))

axiom ind_iproduct_pos :
  (forall f:(int,int) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> (0 <= (f[k])))) ->
  (0 <= ind_iproduct(f, i, j))))

axiom ind_iproduct_strict_pos :
  (forall f:(int,int) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> (0 <  (f[k])))) ->
  (0 <  ind_iproduct(f, i, j))))

axiom iproduct_strict_pos :
  (forall s:'a set. forall f:('a,int) farray.
  ((forall k:'a. (mem(k, s) -> (0 <  (f[k])))) -> (0 <  iproduct(s, f))))

axiom ind_iproduct_strict_pos_one :
  (forall f:(int,int) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> (0 <  (f[k])))) ->
  (1 <= ind_iproduct(f, i, j))))

logic fc20 : (int,int) farray, int, int -> (int,int) farray

axiom fcqtdef20 :
  (forall f:(int,int) farray. forall l:int. forall h:int. forall a:int.
  ((fc20(f, l, h)[a]) = (f[((h - (a + 1)) + l)])))

axiom ind_iproduct_left_right :
  (forall f:(int,int) farray. forall l:int. forall k:int. forall h:int.
  (((l <= k) and (k <= h)) -> (ind_iproduct(f, l, k) = ind_iproduct(fc20(f,
  l, h), ((h - k) + l), h))))

axiom iterable_imult : iterable(infix_as_closure)

axiom int_minus_distr :
  (forall a:int. forall b:int. ((-(a + b)) = ((-a) + (-b))))

axiom int_minus_eq : (forall a:int. forall b:int. ((a = b) -> ((-a) = (-b))))

logic fc21 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef21 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc21(f, t)[b]) = (t[(f[b])])))

axiom ind_iproduct_map_auto :
  (forall i:int. forall j:int. forall f:(int,int) farray.
  forall t:(int,int) farray. (p_bijective(f, to_fset(i, j), to_fset(i, j)) ->
  (ind_iproduct(t, i, j) = ind_iproduct(fc21(f, t), i, j))))

logic fc22 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef22 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc22(f, t)[b]) = (t[(f[b])])))

axiom ind_iproduct_map :
  (forall i:int. forall j:int. forall k:int. forall l:int.
  forall f:(int,int) farray. forall t:(int,int) farray. (p_bijective(f,
  to_fset(i, j), to_fset(k, l)) -> (ind_iproduct(t, k,
  l) = ind_iproduct(fc22(f, t), i, j))))

axiom ind_iproduct_trans :
  (forall f:(int,int) farray. forall i:int. forall k:int. forall j:int.
  (((i <= k) and (k <= j)) -> (ind_iproduct(f, i, j) = (ind_iproduct(f, i,
  k) * ind_iproduct(f, k, j)))))

axiom ind_iproduct_inf :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((0 <= (f[k])) and
   ((f[k]) <= (g[k]))))) ->
  (ind_iproduct(f, i, j) <= ind_iproduct(g, i, j))))

logic choose_filter : 'a set, ('a,bool) farray -> 'a

axiom choose_filterqtdef :
  (forall s:'a set. forall p:('a,bool) farray.
  ((exists e:'a. (mem(e, s) and ((p[e]) = true))) ->
  (((p[choose(s)]) = true) -> (choose_filter(s, p) = choose(s)))))

axiom choose_filterqtdef1 :
  (forall s:'a set. forall p:('a,bool) farray.
  ((exists e:'a. (mem(e, s) and ((p[e]) = true))) ->
  ((not ((p[choose(s)]) = true)) -> (choose_filter(s,
  p) = choose_filter(remove(choose(s), s), p)))))

axiom choose_filterqtspec :
  (forall s:'a set. forall p:('a,bool) farray.
  ((exists e:'a. (mem(e, s) and ((p[e]) = true))) -> ((p[choose_filter(s,
  p)]) = true)))

axiom choose_filterqtspec1 :
  (forall s:'a set. forall p:('a,bool) farray.
  ((exists e:'a. (mem(e, s) and ((p[e]) = true))) -> mem(choose_filter(s, p),
  s)))

logic my_filter : 'a set, ('a,bool) farray -> 'a set

axiom my_filterqtdef :
  (forall s:'a set. forall p:('a,bool) farray. ((cardinal(s) = 0) ->
  (my_filter(s, p) = (empty : 'a set))))

axiom my_filterqtdef1 :
  (forall s:'a set. forall p:('a,bool) farray. ((not (cardinal(s) = 0)) ->
  (((p[choose(s)]) = true) -> (my_filter(s, p) = add(choose(s),
  my_filter(remove(choose(s), s), p))))))

axiom my_filterqtdef2 :
  (forall s:'a set. forall p:('a,bool) farray. ((not (cardinal(s) = 0)) ->
  ((not ((p[choose(s)]) = true)) -> (my_filter(s,
  p) = my_filter(remove(choose(s), s), p)))))

axiom my_filterqtspec :
  (forall s:'a set. forall p:('a,bool) farray.
  (forall e:'a. (mem(e, s) -> (((p[e]) = true) -> mem(e, my_filter(s, p))))))

axiom my_filterqtspec1 :
  (forall s:'a set. forall p:('a,bool) farray.
  (forall e:'a. (mem(e, s) -> (mem(e, my_filter(s, p)) -> ((p[e]) = true)))))

axiom my_filterqtspec2 :
  (forall s:'a set. forall p:('a,bool) farray.
  (forall e:'a. (mem(e, my_filter(s, p)) -> mem(e, s))))

axiom my_filterqtspec3 :
  (forall s:'a set. forall p:('a,bool) farray. (0 <= cardinal(my_filter(s,
  p))))

axiom my_filterqtspec4 :
  (forall s:'a set. forall p:('a,bool) farray. (cardinal(my_filter(s,
  p)) <= cardinal(s)))

logic my_filter_int : int, int, (int,bool) farray -> int set

axiom my_filter_intqtdef :
  (forall i:int. forall j:int. forall p:(int,bool) farray. ((j <= i) ->
  (my_filter_int(i, j, p) = (empty : int set))))

axiom my_filter_intqtdef1 :
  (forall i:int. forall j:int. forall p:(int,bool) farray. ((not (j <= i)) ->
  (((p[i]) = true) -> (my_filter_int(i, j, p) = add(i, my_filter_int((i + 1),
  j, p))))))

axiom my_filter_intqtdef2 :
  (forall i:int. forall j:int. forall p:(int,bool) farray. ((not (j <= i)) ->
  ((not ((p[i]) = true)) -> (my_filter_int(i, j, p) = my_filter_int((i + 1),
  j, p)))))

axiom my_filter_intqtspec :
  (forall i:int. forall j:int. forall p:(int,bool) farray. (my_filter_int(i,
  j, p) = my_filter(to_fset(i, j), p)))

axiom my_filter_intqtspec1 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  (forall e:int. (((i <= e) and (e <  j)) -> (((p[e]) = true) -> mem(e,
  my_filter_int(i, j, p))))))

axiom my_filter_intqtspec2 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  (forall e:int. (((i <= e) and (e <  j)) -> (mem(e, my_filter_int(i, j,
  p)) -> ((p[e]) = true)))))

axiom my_filter_intqtspec3 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  (forall e:int. (mem(e, my_filter_int(i, j, p)) -> (i <= e))))

axiom my_filter_intqtspec4 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  (forall e:int. (mem(e, my_filter_int(i, j, p)) -> (e <  j))))

axiom my_filter_intqtspec5 :
  (forall i:int. forall j:int. forall p:(int,bool) farray. ((i <= j) ->
  (0 <= cardinal(my_filter_int(i, j, p)))))

axiom my_filter_intqtspec6 :
  (forall i:int. forall j:int. forall p:(int,bool) farray. ((i <= j) ->
  (cardinal(my_filter_int(i, j, p)) <= (j - i))))

axiom in_my_filter :
  (forall s:'a set. forall p:('a,bool) farray. forall e:'a. (mem(e, s) ->
  (((p[e]) = true) -> mem(e, my_filter(s, p)))))

axiom not_in_my_filter_set :
  (forall s:'a set. forall p:('a,bool) farray. forall e:'a. ((not mem(e,
  s)) -> (not mem(e, my_filter(s, p)))))

axiom not_in_my_filter_filter :
  (forall s:'a set. forall p:('a,bool) farray. forall e:'a.
  ((not ((p[e]) = true)) -> (not mem(e, my_filter(s, p)))))

axiom in_my_filter_set :
  (forall s:'a set. forall p:('a,bool) farray. forall e:'a. (mem(e,
  my_filter(s, p)) -> mem(e, s)))

axiom in_my_filter_filter :
  (forall s:'a set. forall p:('a,bool) farray. forall e:'a. (mem(e,
  my_filter(s, p)) -> ((p[e]) = true)))

axiom my_filter_inter :
  (forall s:'a set. forall p1:('a,bool) farray. forall p2:('a,bool) farray.
  ((forall e:'a. (mem(e, s) -> (((p1[e]) = true) -> (not ((p2[e]) = true))))) ->
  (inter(my_filter(s, p1), my_filter(s, p2)) = (empty : 'a set))))

axiom my_filter_union :
  (forall s:'a set. forall p1:('a,bool) farray. forall p2:('a,bool) farray.
  ((forall e:'a. (mem(e, s) -> ((not ((p1[e]) = true)) -> ((p2[e]) = true)))) ->
  (union(my_filter(s, p1), my_filter(s, p2)) = s)))

axiom ind_iproduct_sup_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> (1 <= (f[k])))) ->
  ((exists k:int. (((i <= k) and (k <  j)) and (not ((f[k]) = 1)))) ->
  (1 <  ind_iproduct(f, i, j))))))

axiom comp_trans_equal_strict :
  (forall a:int. forall b:int. forall c:int. ((a <= b) -> ((b <  c) ->
  (a <  c))))

axiom transitive_inf_leq_int :
  (forall a:int. forall b:int. forall c:int. ((a <  b) -> ((b <= c) ->
  (a <  c))))

axiom transitive_inf_int :
  (forall a:int. forall b:int. forall c:int. ((a <  b) -> ((b <  c) ->
  (a <  c))))

axiom compeq_trans_sum :
  (forall a:int. forall b:int. forall c:int. ((b <= c) ->
  ((a + b) <= (a + c))))

axiom compeq_trans_sum_zero :
  (forall a:int. forall b:int. ((0 <= b) -> (a <= (a + b))))

axiom comp_trans_sum :
  (forall a:int. forall b:int. forall c:int. ((b <  c) ->
  ((a + b) <  (a + c))))

axiom comp_trans_mult :
  (forall a:int. forall b:int. forall c:int. (((0 <= a) and (a <  b)) ->
  ((0 <  c) -> ((a * c) <  (b * c)))))

axiom minus_out_int : (forall a:int. forall b:int. (((-a) * b) = (-(a * b))))

logic ind_isum : (int,int) farray, int, int -> int

axiom ind_isumqtdef :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((j <= i) ->
  (ind_isum(f, i, j) = 0)))

axiom ind_isumqtdef1 :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((not (j <= i)) ->
  ((j = (i + 1)) -> (ind_isum(f, i, j) = (f[i])))))

axiom ind_isumqtdef2 :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((not (j <= i)) ->
  ((not (j = (i + 1))) -> (ind_isum(f, i, j) = ((f[i]) + ind_isum(f, (i + 1),
  j))))))

axiom ind_isumqtspec :
  (forall f:(int,int) farray. forall i:int. forall j:int. (ind_isum(f, i,
  j) = int_iterate(infix_pl_closure, f, i, j)))

axiom ind_isum_empty :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((j <= i) ->
  (ind_isum(f, i, j) = 0)))

axiom ind_isum_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((j = (i + 1)) ->
  (ind_isum(f, i, j) = (f[i]))))

axiom ind_isum_plus_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_isum(f, i, j) = ((f[i]) + ind_isum(f, (i + 1), j)))))

axiom ind_isum_to_isum :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_isum(f, i, j) = isum(to_fset(i, j), f))))

logic fc23 : (int,(int,int) farray) farray

axiom fcqtdef23 : (forall y0:int. forall y1:int. (((fc23[y0])[y1]) = y0))

axiom ind_isum_const :
  (forall k:int. forall i:int. forall j:int. ((i <  j) ->
  (ind_isum((fc23[k]), i, j) = (k * (j - i)))))

axiom ind_isum_null :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = 0))) -> (ind_isum(f,
  i, j) = 0))))

axiom ind_isum_right_extension :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <= j) ->
  (ind_isum(f, i, (j + 1)) = (ind_isum(f, i, j) + (f[j])))))

axiom ind_isum_re :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_isum(f, i, j) = (ind_isum(f, i, (j - 1)) + (f[(j - 1)])))))

axiom ind_isum_re_null :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <  j) ->
  (((f[j]) = 0) -> (ind_isum(f, i, (j + 1)) = ind_isum(f, i, j)))))

axiom ind_isum_null_but_maybe_one_elt :
  (forall l:int. forall h:int. forall t:(int,int) farray. forall e:int.
  (((l <= e) and (e <  h)) ->
  ((forall a:int. (((l <= a) and (a <  h)) -> ((not (a = e)) ->
   ((t[a]) = 0)))) ->
  (ind_isum(t, l, h) = (t[e])))))

axiom ind_isum_eq :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ind_isum(f, i, j) = ind_isum(g, i, j))))

logic fc24 : (int,int) farray, (int,int) farray,
  (int,bool) farray -> (int,int) farray

axiom fcqtdef24 :
  (forall f:(int,int) farray. forall g:(int,int) farray.
  forall p:(int,bool) farray. forall k:int. ((fc24(f, g,
  p)[k]) = (if ((p[k]) = true) then (f[k]) else (g[k]))))

axiom ind_isum_to_guard :
  (forall f:(int,int) farray. forall g:(int,int) farray.
  forall p:(int,bool) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((p[k]) = true))) ->
  (ind_isum(fc24(f, g, p), i, j) = ind_isum(f, i, j))))

logic fc25 : (int,int) farray, (int,int) farray,
  (int,bool) farray -> (int,int) farray

axiom fcqtdef25 :
  (forall f:(int,int) farray. forall g:(int,int) farray.
  forall p:(int,bool) farray. forall k:int. ((fc25(f, g,
  p)[k]) = (if ((p[k]) = true) then (g[k]) else (f[k]))))

axiom ind_isum_no_guard :
  (forall f:(int,int) farray. forall g:(int,int) farray.
  forall p:(int,bool) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> (not ((p[k]) = true)))) ->
  (ind_isum(fc25(f, g, p), i, j) = ind_isum(f, i, j))))

axiom ind_isum_eq_gen :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall i1:int. forall j:int. forall j1:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  ((i = i1) -> ((j = j1) -> (ind_isum(f, i, j) = ind_isum(g, i1, j1))))))

axiom ind_isum_func_const :
  (forall k:int. forall f:(int,int) farray. forall i:int. forall j:int.
  ((i <= j) -> ((forall l:int. (((i <= l) and (l <  j)) -> ((f[l]) = k))) ->
  (ind_isum(f, i, j) = (k * (j - i))))))

axiom ind_isum_pos :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <= j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> (0 <= (f[k])))) ->
  (0 <= ind_isum(f, i, j)))))

logic fc26 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef26 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc26(f, t)[b]) = (t[(f[b])])))

axiom ind_isum_map_auto :
  (forall i:int. forall j:int. forall f:(int,int) farray.
  forall t:(int,int) farray. (p_bijective(f, to_fset(i, j), to_fset(i, j)) ->
  (ind_isum(t, i, j) = ind_isum(fc26(f, t), i, j))))

logic fc27 : int, int, (int,int) farray -> (int,int) farray

axiom fcqtdef27 :
  (forall i:int. forall j:int. forall f:(int,int) farray. forall k:int.
  ((fc27(i, j, f)[k]) = (f[(((j - k) - 1) + i)])))

axiom ind_isum_rev :
  (forall i:int. forall j:int. forall f:(int,int) farray. (ind_isum(f, i,
  j) = ind_isum(fc27(i, j, f), i, j)))

logic fc28 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef28 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc28(f, t)[b]) = (t[(f[b])])))

axiom ind_isum_map :
  (forall i:int. forall j:int. forall k:int. forall l:int.
  forall f:(int,int) farray. forall t:(int,int) farray. (p_bijective(f,
  to_fset(i, j), to_fset(k, l)) -> (ind_isum(t, k, l) = ind_isum(fc28(f, t),
  i, j))))

logic fc29 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef29 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc29(f, t)[b]) = (t[(f[b])])))

axiom ind_isum_map_auto_bij :
  (forall i:int. forall j:int. forall f:(int,int) farray.
  forall t:(int,int) farray.
  ((forall e:int. (((i <= e) and (e <  j)) -> ((i <= (f[e])) and
   ((f[e]) <  j)))) ->
  ((forall e:int. forall eqt:int. (((i <= e) and (e <  j)) ->
   (((i <= eqt) and (eqt <  j)) -> ((not (e = eqt)) ->
   (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:int. (((i <= eqt) and (eqt <  j)) ->
   (exists e:int. (((i <= e) and (e <  j)) and ((f[e]) = eqt))))) ->
  (ind_isum(t, i, j) = ind_isum(fc29(f, t), i, j))))))

logic fc30 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef30 :
  (forall f:(int,int) farray. forall t:(int,int) farray. forall b:int.
  ((fc30(f, t)[b]) = (t[(f[b])])))

axiom ind_isum_map_bij :
  (forall i:int. forall j:int. forall k:int. forall l:int.
  forall f:(int,int) farray. forall t:(int,int) farray.
  ((forall e:int. (((i <= e) and (e <  j)) -> ((k <= (f[e])) and
   ((f[e]) <  l)))) ->
  ((forall e:int. forall eqt:int. (((i <= e) and (e <  j)) ->
   (((i <= eqt) and (eqt <  j)) -> ((not (e = eqt)) ->
   (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:int. (((k <= eqt) and (eqt <  l)) ->
   (exists e:int. (((i <= e) and (e <  j)) and ((f[e]) = eqt))))) ->
  (ind_isum(t, k, l) = ind_isum(fc30(f, t), i, j))))))

logic fc31 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef31 :
  (forall f:(int,int) farray. forall k:int. forall b:int. ((fc31(f,
  k)[b]) = (f[(b + k)])))

axiom ind_isum_transl :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall k:int.
  (ind_isum(f, i, j) = ind_isum(fc31(f, k), (i - k), (j - k))))

logic fc32 : (int,int) farray -> (int,int) farray

axiom fcqtdef32 :
  (forall f:(int,int) farray. forall b:int. ((fc32(f)[b]) = (f[(b - 1)])))

axiom ind_isum_transl_plus_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. (ind_isum(f, i,
  j) = ind_isum(fc32(f), (i + 1), (j + 1))))

logic fc33 : (int,int) farray -> (int,int) farray

axiom fcqtdef33 :
  (forall f:(int,int) farray. forall b:int. ((fc33(f)[b]) = (f[(b + 1)])))

axiom ind_isum_transl_minus_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. (ind_isum(f, i,
  j) = ind_isum(fc33(f), (i - 1), (j - 1))))

logic fc34 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef34 :
  (forall f:(int,int) farray. forall a:int. forall i:int. ((fc34(f,
  a)[i]) = (a * (f[i]))))

axiom ind_isum_scal :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall a:int.
  ((i <= j) -> (ind_isum(fc34(f, a), i, j) = (a * ind_isum(f, i, j)))))

logic fc35 : (int,int) farray -> (int,int) farray

axiom fcqtdef35 :
  (forall f:(int,int) farray. forall i:int. ((fc35(f)[i]) = (-(f[i]))))

axiom minus_ind_isum :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <= j) ->
  ((-ind_isum(f, i, j)) = ind_isum(fc35(f), i, j))))

logic fc36 : (int,int) farray -> (int,int) farray

axiom fcqtdef36 :
  (forall f:(int,int) farray. forall i:int. ((fc36(f)[i]) = (-(f[i]))))

axiom minus_ind_isum_rev :
  (forall f:(int,int) farray. forall i:int. forall j:int. ((i <= j) ->
  (ind_isum(fc36(f), i, j) = (-ind_isum(f, i, j)))))

logic fc37 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef37 :
  (forall f:(int,int) farray. forall a:int. forall i:int. ((fc37(f,
  a)[i]) = (a * (f[i]))))

axiom ind_isum_scal_rev :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall a:int.
  ((i <= j) -> ((a * ind_isum(f, i, j)) = ind_isum(fc37(f, a), i, j))))

logic fc38 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef38 :
  (forall f:(int,int) farray. forall a:int. forall i:int. ((fc38(f,
  a)[i]) = ((f[i]) * a)))

axiom ind_isum_scal_rev_right :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall a:int.
  ((i <= j) -> ((ind_isum(f, i, j) * a) = ind_isum(fc38(f, a), i, j))))

logic fc39 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef39 :
  (forall f:(int,int) farray. forall a:int. forall i:int. ((fc39(f,
  a)[i]) = ((f[i]) * a)))

axiom ind_isum_scal_right :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall a:int.
  ((i <= j) -> (ind_isum(fc39(f, a), i, j) = (ind_isum(f, i, j) * a))))

axiom ind_isum_bound :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int. ((i <  j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) <  (g[k])))) ->
  (ind_isum(f, i, j) <  ind_isum(g, i, j)))))

axiom ind_isum_bound_eq :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int. ((i <= j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) <= (g[k])))) ->
  (ind_isum(f, i, j) <= ind_isum(g, i, j)))))

logic fc40 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef40 :
  (forall f:(int,int) farray. forall a:int. forall i:int. ((fc40(f,
  a)[i]) = (a * (f[i]))))

axiom ind_isum_scal_gen :
  (forall f:(int,int) farray. forall i:int. forall j:int.
  (forall a:int. (((i <= a) and (a <  j)) -> (ind_isum(fc40(f, a), i,
  j) = (a * ind_isum(f, i, j))))))

axiom ind_isum_trans :
  (forall f:(int,int) farray. forall i:int. forall k:int. forall j:int.
  (((i <= k) and (k <= j)) -> (ind_isum(f, i, j) = (ind_isum(f, i,
  k) + ind_isum(f, k, j)))))

logic power_pre : int, int -> int

axiom power_preqtdef :
  (forall e:int. forall i:int. ((0 <= i) -> ((i = 0) -> (power_pre(e,
  i) = 1))))

axiom power_preqtdef1 :
  (forall e:int. forall i:int. ((0 <= i) -> ((not (i = 0)) -> (power_pre(e,
  i) = (e * power_pre(e, (i - 1)))))))

function power(e: int, i: int) : int = (if (i <  0) then 0 else power_pre(e,
  i))

axiom Power_zero : (forall i:int. (power(i, 0) = 1))

axiom Power_one : (forall i:int. (power(i, 1) = i))

axiom power_plus_one :
  (forall i:int. forall x:int. ((0 <= x) -> (power(i, (x + 1)) = (power(i,
  x) * i))))

axiom power_sum :
  (forall i:int. forall x:int. forall y:int. ((0 <= x) -> ((0 <= y) ->
  (power(i, (x + y)) = (power(i, x) * power(i, y))))))

axiom power_mult :
  (forall i:int. forall x:int. forall y:int. ((0 <= x) -> ((0 <= y) ->
  (power(i, (x * y)) = power(power(i, x), y)))))

axiom Power_sum :
  (forall x:int. forall y:int. forall i:int. ((0 <= x) -> ((0 <= y) ->
  (power(i, (x + y)) = (power(i, x) * power(i, y))))))

axiom Power_mult :
  (forall x:int. forall y:int. forall i:int. ((0 <= x) -> ((0 <= y) ->
  (power(i, (x * y)) = power(power(i, x), y)))))

logic fc41 : (int,(int,int) farray) farray

axiom fcqtdef41 : (forall y0:int. forall y1:int. (((fc41[y0])[y1]) = y0))

axiom power_to_ind_iproduct :
  (forall e:int. forall i:int. ((0 <= i) -> (power(e,
  i) = ind_iproduct((fc41[e]), 0, i))))

logic fc42 : (int,(int,int) farray) farray

axiom fcqtdef42 : (forall y0:int. forall y1:int. (((fc42[y0])[y1]) = y0))

axiom power_transl :
  (forall e:int. forall k:int. forall i:int. ((0 <= i) -> (power(e,
  i) = ind_iproduct((fc42[e]), k, (k + i)))))

logic fc43 : (int,(int,int) farray) farray

axiom fcqtdef43 : (forall y0:int. forall y1:int. (((fc43[y0])[y1]) = y0))

axiom ind_iproduct_to_power :
  (forall e:int. forall i:int. forall j:int. (((0 <= i) and (i <= j)) ->
  (ind_iproduct((fc43[e]), i, j) = power(e, (j - i)))))

logic fc44 : (int,(int,int) farray) farray

axiom fcqtdef44 : (forall y0:int. forall y1:int. (((fc44[y0])[y1]) = y0))

axiom ind_iproduct_to_power_gen :
  (forall e:int.
  (forall i:int. forall j:int. (((0 <= i) and (i <= j)) ->
  (ind_iproduct((fc44[e]), i, j) = power(e, (j - i))))))

axiom power_sum_rev :
  (forall x:int. forall n:int. forall m:int. ((0 <= n) -> ((0 <= m) ->
  ((power(x, n) * power(x, m)) = power(x, (n + m))))))

axiom power_eq :
  (forall x:int. forall n:int. forall m:int. ((n = m) -> (power(x,
  n) = power(x, m))))

axiom power_eq_gen :
  (forall x:int. forall y:int. forall n:int. forall m:int. ((n = m) ->
  ((x = y) -> (power(x, n) = power(y, m)))))

logic fc45 : (int,int) farray

axiom fcqtdef45 : (forall k:int. ((fc45[k]) = power(2, (k + 1))))

axiom power_2_sum :
  (forall i:int. ((1 <= i) -> (ind_isum(fc45, 0, i) = (power(2,
  (i + 1)) - 2))))

logic fc46 : (int,int) farray

axiom fcqtdef46 : (forall k:int. ((fc46[k]) = power(2, (k + 1))))

axiom power_decomp :
  (forall i:int. ((1 <= i) -> (ind_isum(fc46, 0, i) <  power(2, (i + 1)))))

logic fc47 : int -> (int,int) farray

axiom fcqtdef47 :
  (forall i:int. forall k:int. ((fc47(i)[k]) = (if ((1 <= k) and
  (k <  (i + 1))) then power(2, (k - 1)) else 0)))

axiom power_decomp_minus_one :
  (forall i:int. ((1 <= i) -> (ind_isum(fc47(i), 1, i) <  power(2,
  (i - 1)))))

logic power_closure : (int,(int,int) farray) farray

axiom power_closure_def :
  (forall y:int. forall y1:int. (((power_closure[y])[y1]) = power(y, y1)))

axiom power_decomp_ :
  (forall i:int. ((1 <= i) -> (ind_isum((power_closure[2]), 0, i) <  power(2,
  i))))

logic fc48 : (int,int) farray

axiom fcqtdef48 : (forall k:int. ((fc48[k]) = power(2, (k + 1))))

axiom power_decomp_one :
  (forall i:int. ((1 <= i) -> (ind_isum(fc48, 1, i) <  power(2, (i + 1)))))

axiom power_decomp_one_ :
  (forall i:int. ((1 <= i) -> (ind_isum((power_closure[2]), 1, i) <  power(2,
  i))))

axiom growing_mult :
  (forall n:int. forall m:int. ((0 <= n) -> ((1 <= m) -> (n <= (n * m)))))

axiom strict_growing_mult :
  (forall n:int. forall m:int. ((1 <  n) -> ((1 <  m) -> (n <  (n * m)))))

axiom init_exp : (forall k:int. (power(k, 0) = 1))

axiom init_exp1 : (forall k:int. (power(k, 1) = k))

axiom init_exp2 : (forall k:int. (power(k, 2) = (k * k)))

axiom positive_int_exp :
  (forall k:int. forall n:int. ((1 <= k) -> ((0 <= n) -> (1 <= power(k,
  n)))))

axiom positive_int_exp1 :
  (forall k:int. forall n:int. ((1 <= k) -> ((0 <= n) -> (0 <  power(k,
  n)))))

axiom positive_int_exp2 :
  (forall k:int. forall n:int. ((1 <= k) -> ((0 <= n) -> (power(k,
  n) <= power(k, (n + 1))))))

axiom strict_positive_int_exp :
  (forall k:int. forall n:int. ((1 <  k) -> ((0 <  n) -> (1 <  power(k,
  n)))))

axiom strict_positive_int_exp1 :
  (forall k:int. forall n:int. ((1 <  k) -> ((0 <  n) -> (power(k,
  (n - 1)) <  power(k, n)))))

axiom strict_positive_int_exp2 :
  (forall k:int. forall n:int. ((1 <  k) -> ((0 <  n) -> (power(k,
  n) <  power(k, (n + 1))))))

function abs(x: int) : int = (if (0 <= x) then x else (-x))

axiom Abs_le : (forall x:int. forall y:int. ((abs(x) <= y) -> ((-y) <= x)))

axiom Abs_le1 : (forall x:int. forall y:int. ((abs(x) <= y) -> (x <= y)))

axiom Abs_le2 :
  (forall x:int. forall y:int. ((((-y) <= x) and (x <= y)) -> (abs(x) <= y)))

axiom Abs_pos : (forall x:int. (0 <= abs(x)))

axiom Div_mod :
  (forall x:int. forall y:int. ((not (y = 0)) ->
  (x = ((y * (x / y)) + (x % y)))))

axiom Mod_bound :
  (forall x:int. forall y:int. ((not (y = 0)) -> (0 <= (x % y))))

axiom Mod_bound1 :
  (forall x:int. forall y:int. ((not (y = 0)) -> ((x % y) <  abs(y))))

axiom Div_unique :
  (forall x:int. forall y:int. forall q:int. ((0 <  y) ->
  ((((q * y) <= x) and (x <  ((q * y) + y))) -> ((x / y) = q))))

axiom Div_bound :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) -> (0 <= (x / y))))

axiom Div_bound1 :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) -> ((x / y) <= x)))

axiom Mod_1 : (forall x:int. ((x % 1) = 0))

axiom Div_1 : (forall x:int. ((x / 1) = x))

axiom Div_inf :
  (forall x:int. forall y:int. (((0 <= x) and (x <  y)) -> ((x / y) = 0)))

axiom Div_inf_neg :
  (forall x:int. forall y:int. (((0 <  x) and (x <= y)) ->
  (((-x) / y) = (- 1))))

axiom Mod_0 : (forall y:int. ((not (y = 0)) -> ((0 % y) = 0)))

axiom Div_1_left : (forall y:int. ((1 <  y) -> ((1 / y) = 0)))

axiom Div_minus1_left : (forall y:int. ((1 <  y) -> (((- 1) / y) = (- 1))))

axiom Mod_1_left : (forall y:int. ((1 <  y) -> ((1 % y) = 1)))

axiom Mod_minus1_left : (forall y:int. ((1 <  y) -> (((- 1) % y) = (y - 1))))

axiom Div_mult :
  (forall x:int. forall y:int. forall z:int [(((x * y) + z) / x)].
  ((0 <  x) -> ((((x * y) + z) / x) = (y + (z / x)))))

axiom Mod_mult :
  (forall x:int. forall y:int. forall z:int [(((x * y) + z) % x)].
  ((0 <  x) -> ((((x * y) + z) % x) = (z % x))))

axiom power_minus_one :
  (forall i:int. ((0 <= i) -> (((i % 2) = 0) -> (power((- 1), i) = 1))))

axiom power_minus_one1 :
  (forall i:int. ((0 <= i) -> (((i % 2) = 1) -> (power((- 1), i) = (- 1)))))

axiom growing_exp :
  (forall k:int. forall m:int. forall n:int. ((1 <= k) -> (((0 <= m) and
  (m <= n)) -> (power(k, m) <= power(k, n)))))

axiom strict_growing_exp :
  (forall k:int. forall m:int. forall n:int. ((1 <  k) -> (((0 <= m) and
  (m <  n)) -> (power(k, m) <  power(k, n)))))

axiom unicity_exp :
  (forall k:int. forall m:int. forall n:int. ((1 <  k) -> ((0 <= m) ->
  ((0 <= n) -> ((power(k, m) = power(k, n)) -> (m = n))))))

axiom unicity_exp1 :
  (forall k:int. forall m:int. forall n:int. ((1 <  k) -> ((0 <= m) ->
  ((0 <= n) -> ((m = n) -> (power(k, m) = power(k, n)))))))

axiom bounded_sum_exp :
  (forall i:int. forall j:int. forall m:int. forall n:int. ((0 <= m) ->
  ((0 <= n) -> (((0 <= i) and (i <  power(2, m))) -> (((0 <= j) and
  (j <  power(2, n))) -> (((i * power(2, n)) + j) <  power(2, (m + n))))))))

axiom Power_pos : (forall i:int. ((0 <= i) -> (0 <  power(i, 0))))

axiom Power_pos_gen :
  (forall i:int. forall j:int. ((0 <  i) -> ((0 <= j) -> (0 <  power(i,
  j)))))

axiom power_two : (forall x:int. ((0 <= x) -> (power(x, 2) = (x * x))))

axiom power_plus_one_two :
  (forall x:int. ((0 <= x) -> (power(2, (x + 1)) = (power(2, x) + power(2,
  x)))))

axiom growing_right_power :
  (forall a:int. forall b:int. forall i:int. ((0 <= i) -> (((0 <= a) and
  (a <= b)) -> (power(a, i) <= power(b, i)))))

axiom power_of_one :
  (forall a:int. forall b:int. ((0 <= b) -> ((a = 1) -> (power(a, b) = 1))))

axiom bound_power :
  (forall i:int. forall a:int. forall k:int. forall n:int. ((0 <  a) ->
  (((0 <  k) and (k <= n)) -> (((0 <= i) and (i <  power(a, n))) ->
  ((i / power(a, (n - k))) <  power(a, k))))))

axiom power_inf :
  (forall a:int. forall n:int. forall nqt:int. ((1 <  a) -> (((0 <  n) and
  (n <  nqt)) -> (power(a, n) <  power(a, nqt)))))

axiom power_leq :
  (forall a:int. forall n:int. forall nqt:int. ((0 <= a) -> (((0 <  n) and
  (n <= nqt)) -> (power(a, n) <= power(a, nqt)))))

axiom power_rises :
  (forall a:int. forall n:int. ((1 <  a) -> ((1 <  n) -> (a <  power(a,
  n)))))

axiom int_expo_rises :
  (forall a:int. forall n:int. ((1 <  a) -> ((1 <= n) -> (n <  power(a,
  n)))))

axiom bound_power_2 :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  (n + 1)))) -> ((i / power(2, n)) <  2))))

logic polysquare : int, int, int, int -> int

axiom polysquareqtdef :
  (forall n:int. forall a2:int. forall a1:int. forall a0:int. ((0 <  n) ->
  ((0 <= a2) -> ((0 <= a1) -> ((0 <= a0) -> (polysquare(n, a2, a1,
  a0) = (((a2 * power(n, 2)) + (a1 * n)) + a0)))))))

axiom polysquareqtspec :
  (forall n:int. forall a2:int. forall a1:int. forall a0:int. ((0 <  n) ->
  ((0 <= a2) -> ((0 <= a1) -> ((0 <= a0) -> (0 <= polysquare(n, a2, a1,
  a0)))))))

axiom polysquare_leq_trans :
  (forall n:int. forall a2:int. forall a1:int. forall a0:int. forall b2:int.
  forall b1:int. forall b0:int. forall pa:int. forall pb:int. forall ps:int.
  ((0 <  n) -> ((0 <= a2) -> ((0 <= a1) -> ((0 <= a0) -> ((0 <= b2) ->
  ((0 <= b1) -> ((0 <= b0) -> ((pa <= polysquare(n, a2, a1, a0)) ->
  ((pb <= polysquare(n, b2, b1, b0)) -> ((ps <= (pa + pb)) ->
  (ps <= polysquare(n, (a2 + b2), (a1 + b1), (a0 + b0))))))))))))))

axiom polysquare_leq_trans_sc :
  (forall n:int. forall a2:int. forall a1:int. forall a0:int. forall b2:int.
  forall b1:int. forall b0:int. forall pa:int. forall sc:int. forall ps:int.
  ((0 <  n) -> ((0 <= a2) -> ((0 <= a1) -> ((0 <= a0) -> ((0 <= sc) ->
  (((sc * a2) <= b2) -> (((sc * a1) <= b1) -> (((sc * a0) <= b0) ->
  ((pa <= polysquare(n, a2, a1, a0)) -> ((ps <= (sc * pa)) ->
  (ps <= polysquare(n, b2, b1, b0)))))))))))))

axiom polysquare_update :
  (forall na:int. forall nb:int. forall a2:int. forall a1:int. forall a0:int.
  forall pa:int. (((0 <  na) and (na <= nb)) -> ((0 <= a2) -> ((0 <= a1) ->
  ((0 <= a0) -> ((pa <= polysquare(na, a2, a1, a0)) -> (pa <= polysquare(nb,
  a2, a1, a0))))))))

axiom add_im_re :
  (forall i:complex. forall j:complex. (infix_pldt(i,
  j) = infix_pldt(infix_pldt(t_real_part(i), t_real_part(j)), infix_asdt(im,
  infix_pldt(t_im_part(i), t_im_part(j))))))

axiom add_im_re1 :
  (forall i:complex. forall j:complex. (t_real_part(infix_pldt(i,
  j)) = infix_pldt(t_real_part(i), t_real_part(j))))

axiom add_im_re2 :
  (forall i:complex. forall j:complex. (t_im_part(infix_pldt(i,
  j)) = infix_pldt(t_im_part(i), t_im_part(j))))

axiom add_real_part :
  (forall i:complex. forall j:complex. (infix_pldt(t_real_part(i),
  t_real_part(j)) = t_real_part(infix_pldt(i, j))))

axiom add_im_part :
  (forall i:complex. forall j:complex. (infix_pldt(t_im_part(i),
  t_im_part(j)) = t_im_part(infix_pldt(i, j))))

axiom add_real_part_rev :
  (forall i:complex. forall j:complex. (t_real_part(infix_pldt(i,
  j)) = infix_pldt(t_real_part(i), t_real_part(j))))

axiom add_im_part_rev :
  (forall i:complex. forall j:complex. (t_im_part(infix_pldt(i,
  j)) = infix_pldt(t_im_part(i), t_im_part(j))))

axiom mult_distr_add_r :
  (forall a:complex. forall b:complex. forall c:complex. (infix_asdt(a,
  infix_pldt(b, c)) = infix_pldt(infix_asdt(a, b), infix_asdt(a, c))))

axiom add_add_minus :
  (forall a:complex. forall b:complex. forall c:complex. (infix_pldt(a,
  infix_mndt(b, c)) = infix_mndt(infix_pldt(a, b), c)))

axiom mult_distr_minus :
  (forall a:complex. forall b:complex. forall c:complex. (infix_asdt(a,
  infix_mndt(b, c)) = infix_mndt(infix_asdt(a, b), infix_asdt(a, c))))

axiom minus_out :
  (forall a:complex. forall b:complex. (infix_asdt(prefix_mndt(a),
  b) = prefix_mndt(infix_asdt(a, b))))

axiom mult_distr_add_r_rev :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_pldt(infix_asdt(a, b), infix_asdt(a, c)) = infix_asdt(a,
  infix_pldt(b, c))))

axiom mult_distr_minus_rev :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_mndt(infix_asdt(a, b), infix_asdt(a, c)) = infix_asdt(a,
  infix_mndt(b, c))))

axiom div_distr_add :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (a = c_zero)) -> (infix_sldt(infix_pldt(b, c),
  a) = infix_pldt(infix_sldt(b, a), infix_sldt(c, a)))))

axiom div_distr_minus :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (a = c_zero)) -> (infix_sldt(infix_mndt(b, c),
  a) = infix_mndt(infix_sldt(b, a), infix_sldt(c, a)))))

axiom div_distr_add_rev :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (a = c_zero)) -> (infix_pldt(infix_sldt(b, a), infix_sldt(c,
  a)) = infix_sldt(infix_pldt(b, c), a))))

axiom div_distr_minus_rev :
  (forall a:complex. forall b:complex. forall c:complex.
  ((not (a = c_zero)) -> (infix_mndt(infix_sldt(b, a), infix_sldt(c,
  a)) = infix_sldt(infix_mndt(b, c), a))))

axiom mult_distr_add_l :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_asdt(infix_pldt(b, c), a) = infix_pldt(infix_asdt(a, b),
  infix_asdt(a, c))))

axiom mult_distr_add_l_rev :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_pldt(infix_asdt(b, a), infix_asdt(c, a)) = infix_asdt(infix_pldt(b,
  c), a)))

axiom mult_distr_minus_r :
  (forall a:complex. forall b:complex. forall c:complex. (infix_asdt(a,
  infix_mndt(b, c)) = infix_mndt(infix_asdt(a, b), infix_asdt(a, c))))

axiom mult_distr_minus_ll :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_asdt(infix_pldt(prefix_mndt(b), c),
  a) = infix_pldt(infix_asdt(prefix_mndt(a), b), infix_asdt(a, c))))

axiom mult_distr_minus_ri :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_asdt(infix_mndt(b, c), a) = infix_mndt(infix_asdt(a, b),
  infix_asdt(a, c))))

axiom minus_distr_op :
  (forall a:complex. forall b:complex. forall c:complex. (infix_mndt(a,
  infix_pldt(b, c)) = infix_mndt(infix_mndt(a, b), c)))

axiom mult_distr_minus_l :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_asdt(infix_mndt(b, c), a) = infix_mndt(infix_asdt(a, b),
  infix_asdt(a, c))))

axiom assoc_right :
  (forall a:complex. forall b:complex. forall c:complex. (infix_pldt(a,
  infix_pldt(b, c)) = infix_pldt(infix_pldt(a, b), c)))

axiom assoc_right_mult :
  (forall a:complex. forall b:complex. forall c:complex. (infix_asdt(a,
  infix_asdt(b, c)) = infix_asdt(infix_asdt(a, b), c)))

axiom minus_elim :
  (forall a:complex. forall b:complex. (infix_mndt(a, b) = infix_pldt(a,
  prefix_mndt(b))))

axiom minus_eq_t :
  (forall a:complex. forall b:complex. forall aqt:complex.
  forall bqt:complex. ((a = aqt) -> ((b = bqt) -> (infix_mndt(a,
  b) = infix_mndt(aqt, bqt)))))

axiom minus_distr_elim :
  (forall a:complex. forall b:complex. forall c:complex. (infix_mndt(a,
  infix_pldt(b, c)) = infix_pldt(infix_pldt(a, prefix_mndt(b)),
  prefix_mndt(c))))

axiom plus_minus_distr_elim :
  (forall a:complex. forall b:complex. forall c:complex. (infix_pldt(a,
  prefix_mndt(infix_pldt(b, c))) = infix_pldt(infix_pldt(a, prefix_mndt(b)),
  prefix_mndt(c))))

axiom def_by_minus :
  (forall x:complex. forall y:complex. forall z:complex. ((x = infix_mndt(y,
  z)) -> (y = infix_pldt(x, z))))

axiom switch :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_pldt(infix_pldt(a, b), c) = infix_pldt(infix_pldt(a, c), b)))

axiom meet_a_c :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(a, c), b), d)))

axiom meet_a_d :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(a, d), b), c)))

axiom meet_b_c :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(b, c), a), d)))

axiom meet_b_d :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(b, d), a), c)))

axiom meet_c_d :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(c, d), a), b)))

axiom inv_add :
  (forall a:complex. forall b:complex. (infix_pldt(infix_pldt(a,
  prefix_mndt(a)), b) = b))

axiom switch_m :
  (forall a:complex. forall b:complex. forall c:complex.
  (infix_pldt(infix_pldt(a, b), c) = infix_pldt(infix_pldt(a, c), b)))

axiom meet_a_c_m :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(a, c), b), d)))

axiom meet_a_d_m :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(a, d), b), c)))

axiom meet_b_c_m :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(b, c), a), d)))

axiom meet_b_d_m :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(b, d), a), c)))

axiom meet_c_d_m :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  (infix_pldt(infix_pldt(infix_pldt(a, b), c),
  d) = infix_pldt(infix_pldt(infix_pldt(c, d), a), b)))

axiom t_real_part_add :
  (forall a:complex. forall b:complex. (t_real_part(infix_pldt(a,
  b)) = infix_pldt(t_real_part(a), t_real_part(b))))

axiom t_real_part_subs :
  (forall a:complex. forall b:complex. (t_real_part(infix_mndt(a,
  b)) = infix_mndt(t_real_part(a), t_real_part(b))))

axiom t_im_part_add :
  (forall a:complex. forall b:complex. (t_im_part(infix_pldt(a,
  b)) = infix_pldt(t_im_part(a), t_im_part(b))))

axiom t_im_part_subs :
  (forall a:complex. forall b:complex. (t_im_part(infix_mndt(a,
  b)) = infix_mndt(t_im_part(a), t_im_part(b))))

axiom t_real_part_real :
  (forall a:complex. (real_(a) -> (t_real_part(a) = a)))

axiom t_real_part_im :
  (forall a:complex. (pure_im_(a) -> (t_real_part(a) = c_zero)))

axiom im_t_im_part_im :
  (forall a:complex. (pure_im_(a) -> (infix_asdt(im, t_im_part(a)) = a)))

axiom t_im_part_im :
  (forall a:complex. (pure_im_(a) ->
  (t_im_part(a) = infix_asdt(prefix_mndt(im), a))))

axiom t_im_part_real :
  (forall a:complex. (real_(a) -> (t_im_part(a) = c_zero)))

axiom a_div_b_mult_a :
  (forall a:complex. forall b:complex. forall c:complex. forall d:complex.
  ((not (b = c_zero)) -> ((not (c = c_zero)) -> ((d = infix_sldt(c_one,
  b)) -> ((a = c) -> (infix_asdt(infix_sldt(a, b), infix_sldt(c_one,
  c)) = d))))))

function i_to_c(i: int) : complex = r_to_c(from_int1(i))

axiom i_to_cqtspec : (forall i:int. real_(i_to_c(i)))

axiom i_to_c_zero : (i_to_c(0) = c_zero)

axiom i_to_c_surj :
  (forall i:int. forall j:int. ((not (i = j)) ->
  (not (i_to_c(i) = i_to_c(j)))))

axiom i_to_c_eq :
  (forall i:int. forall j:int. ((i = j) -> (i_to_c(i) = i_to_c(j))))

axiom i_to_c_inf :
  (forall i:int. forall j:int. ((i <  j) -> infix_lsdt(i_to_c(i),
  i_to_c(j))))

axiom i_to_c_nzero :
  (forall i:int. ((not (i = 0)) -> (not (i_to_c(i) = c_zero))))

axiom i_to_c_one : (i_to_c(1) = c_one)

axiom i_to_c_add :
  (forall i:int. forall j:int. (infix_pldt(i_to_c(i),
  i_to_c(j)) = i_to_c((i + j))))

axiom i_to_c_add_rev :
  (forall i:int. forall j:int. (i_to_c((i + j)) = infix_pldt(i_to_c(i),
  i_to_c(j))))

axiom i_to_c_ttwo : (i_to_c(2) = infix_pldt(c_one, c_one))

axiom i_to_c_pos :
  (forall a:int. ((0 <= a) -> infix_lseqdt(c_zero, i_to_c(a))))

axiom i_to_c_minus : (forall a:int. (i_to_c((-a)) = prefix_mndt(i_to_c(a))))

axiom i_to_c_strict_pos :
  (forall a:int. ((0 <  a) -> infix_lsdt(c_zero, i_to_c(a))))

axiom i_to_c_mult_pos :
  (forall i:int. forall j:int. ((0 <= j) -> (infix_asdt(i_to_c(i),
  i_to_c(j)) = i_to_c((i * j)))))

axiom i_to_c_mult :
  (forall i:int. forall j:int. (infix_asdt(i_to_c(i),
  i_to_c(j)) = i_to_c((i * j))))

axiom i_to_c_mult_rev :
  (forall i:int. forall j:int. (i_to_c((i * j)) = infix_asdt(i_to_c(i),
  i_to_c(j))))

axiom i_to_c_mult_assoc :
  (forall x:complex. forall i:int. forall j:int. (infix_asdt(x,
  i_to_c((i * j))) = infix_asdt(infix_asdt(x, i_to_c(i)), i_to_c(j))))

axiom i_to_c_mult_assoc_rev :
  (forall x:complex. forall i:int. forall j:int. (infix_asdt(infix_asdt(x,
  i_to_c(i)), i_to_c(j)) = infix_asdt(x, i_to_c((i * j)))))

axiom i_to_c_sub :
  (forall i:int. forall j:int. (infix_mndt(i_to_c(i),
  i_to_c(j)) = i_to_c((i - j))))

axiom i_to_c_sub_rev :
  (forall i:int. forall j:int. (i_to_c((i - j)) = infix_mndt(i_to_c(i),
  i_to_c(j))))

axiom i_to_c_opp : (forall i:int. (i_to_c((-i)) = prefix_mndt(i_to_c(i))))

axiom i_to_c_div :
  (forall i:int. forall j:int. ((not (j = 0)) -> (infix_sldt(i_to_c((i * j)),
  i_to_c(j)) = i_to_c(i))))

axiom i_to_c_minus_mult :
  (forall i:int. forall j:int. (infix_asdt(i_to_c((-i)),
  i_to_c(j)) = infix_asdt(i_to_c(i), i_to_c((-j)))))

axiom i_to_c_div_leq_c_one :
  (forall a:int. forall b:int. (((0 <= a) and (a <  b)) ->
  infix_lseqdt(infix_sldt(i_to_c(a), i_to_c(b)), c_one)))

axiom compat_i_to_c_infeq :
  (forall a:int. forall b:int. ((a <= b) -> infix_lseqdt(i_to_c(a),
  i_to_c(b))))

axiom compat_i_to_c_inf :
  (forall a:int. forall b:int. ((a <  b) -> infix_lsdt(i_to_c(a),
  i_to_c(b))))

axiom compat_i_to_c_inf_rev :
  (forall a:int. forall b:int. (infix_lsdt(i_to_c(a), i_to_c(b)) ->
  (a <  b)))

axiom compat_i_to_c_sup :
  (forall a:int. forall b:int. ((b <  a) -> infix_gtdt(i_to_c(a),
  i_to_c(b))))

axiom positive_int_squrt :
  (forall i:int. ((0 <  i) -> infix_gtdt(square_rt(i_to_c(i)), c_zero)))

axiom non_null_int_squrt :
  (forall i:int. ((0 <  i) -> (not (square_rt(i_to_c(i)) = c_zero))))

logic result2 : ('im1,('im1,'im1) farray) farray,
  ('a,'im1) farray -> ('a,bool) farray

axiom resultqtdef4 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall t:('a,'im1) farray.
  forall e:'a. (((result2(op1, t)[e]) = true) -> (not neutral(op1, (t[e])))))

axiom resultqtdef5 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall t:('a,'im1) farray.
  forall e:'a. ((not neutral(op1, (t[e]))) -> ((result2(op1, t)[e]) = true)))

function nonn_part(op1: ('im1,('im1,'im1) farray) farray, s: 'a set,
  t: ('a,'im1) farray) : 'a set = filter_(s, result2(op1, t))

axiom nonn_partqtspec :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray.
  (forall e:'a. (mem(e, nonn_part(op1, s, t)) -> mem(e, s))))

axiom nonn_partqtspec1 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray.
  (forall e:'a. (mem(e, nonn_part(op1, s, t)) -> (not neutral(op1, (t[e]))))))

axiom nonn_partqtspec2 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray.
  (forall e:'a. ((mem(e, s) and (not neutral(op1, (t[e])))) -> mem(e,
  nonn_part(op1, s, t)))))

logic result3 : ('im1,('im1,'im1) farray) farray,
  ('a,'im1) farray -> ('a,bool) farray

axiom resultqtdef6 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall t:('a,'im1) farray.
  forall e:'a. (((result3(op1, t)[e]) = true) -> neutral(op1, (t[e]))))

axiom resultqtdef7 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall t:('a,'im1) farray.
  forall e:'a. (neutral(op1, (t[e])) -> ((result3(op1, t)[e]) = true)))

function n_part(op1: ('im1,('im1,'im1) farray) farray, s: 'a set,
  t: ('a,'im1) farray) : 'a set = filter_(s, result3(op1, t))

axiom n_partqtspec :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray.
  (forall e:'a. (mem(e, n_part(op1, s, t)) -> mem(e, s))))

axiom n_partqtspec1 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray.
  (forall e:'a. (mem(e, n_part(op1, s, t)) -> neutral(op1, (t[e])))))

axiom n_partqtspec2 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray.
  (forall e:'a. ((mem(e, s) and neutral(op1, (t[e]))) -> mem(e, n_part(op1,
  s, t)))))

axiom nullity_partition :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray. (commut(op1) -> (s = union(nonn_part(op1, s, t),
  n_part(op1, s, t)))))

axiom nullity_partition1 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray. (commut(op1) -> (inter(nonn_part(op1, s, t),
  n_part(op1, s, t)) = (empty : 'a set))))

axiom iterate_neutral :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray. (iterable(op1) -> (commut(op1) ->
  ((forall a1:'a. (mem(a1, s) -> ((t[a1]) = neutral_elt(op1)))) ->
  (iterate(op1, s, t) = neutral_elt(op1))))))

axiom iterate_nullity_partition :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s:'a set.
  forall t:('a,'im1) farray. (iterable(op1) -> (commut(op1) -> (iterate(op1,
  s, t) = iterate(op1, nonn_part(op1, s, t), t)))))

function couple(f: ('a,('b,'im1) farray) farray, o: ('a, 'b) tuple2) : 'im1 =
  ((f[(o).Tuple2_proj_1])[(o).Tuple2_proj_2])

axiom null_product :
  (forall a:complex. forall b:complex. ((infix_asdt(a, b) = c_zero) ->
  ((a = c_zero) or (b = c_zero))))

axiom couple_value :
  (forall f:('a,('b,'im1) farray) farray. forall o:('a, 'b) tuple2.
  (couple(f, o) = ((f[fir(o)])[sec(o)])))

axiom couple_value_dev :
  (forall f:('a,('b,'im1) farray) farray. forall o:('a, 'b) tuple2.
  forall a1:'a. forall b1:'b. ((o = { Tuple2_proj_1 = a1; Tuple2_proj_2 = b1
  }) -> (couple(f, o) = ((f[a1])[b1]))))

logic infix_pldt_closure : (complex,(complex,complex) farray) farray

axiom infix_pldt_closure_def :
  (forall y:complex. forall y1:complex.
  (((infix_pldt_closure[y])[y1]) = infix_pldt(y, y1)))

axiom neutral_c_zero : neutral(infix_pldt_closure, c_zero)

axiom neutral_c_zero1 : iterable(infix_pldt_closure)

function sum(s: 'a set, t: ('a,complex) farray) : complex =
  iterate(infix_pldt_closure, s, t)

axiom sum_empty :
  (forall s:'a set. forall t:('a,complex) farray. (is_empty(s) -> (sum(s,
  t) = c_zero)))

axiom sum_one :
  (forall s:'a set. forall t:('a,complex) farray. ((cardinal(s) = 1) ->
  (sum(s, t) = (t[choose(s)]))))

axiom sum_add :
  (forall s:'b set. forall f:('b,complex) farray. forall x:'b. ((not mem(x,
  s)) -> (sum(add(x, s), f) = infix_pldt((f[x]), sum(s, f)))))

axiom sum_plus_one :
  (forall s:'b set. forall f:('b,complex) farray. ((1 <  cardinal(s)) ->
  (sum(s, f) = infix_pldt((f[choose(s)]), sum(remove(choose(s), s), f)))))

axiom sum_partition :
  (forall s:'b set. forall sqt:'b set. forall f:('b,complex) farray.
  ((forall e:'b. (mem(e, s) -> (not mem(e, sqt)))) -> (sum(union(s, sqt),
  f) = infix_pldt(sum(s, f), sum(sqt, f)))))

axiom sum_real :
  (forall s:'a set. forall f:('a,complex) farray.
  ((forall a1:'a. (mem(a1, s) -> real_((f[a1])))) -> ((0 <  cardinal(s)) ->
  real_(sum(s, f)))))

logic fc49 : ('b,'a) farray, ('a,complex) farray -> ('b,complex) farray

axiom fcqtdef49 :
  (forall f:('b,'a) farray. forall t:('a,complex) farray. forall b1:'b.
  ((fc49(f, t)[b1]) = (t[(f[b1])])))

axiom map_sum_eq :
  (forall s:'b set. forall f:('b,'a) farray. forall t:('a,complex) farray.
  (p_injective(f, s) -> (sum(map(f, s), t) = sum(s, fc49(f, t)))))

logic fc50 : ('b,complex) farray, ('b,complex) farray -> ('b,complex) farray

axiom fcqtdef50 :
  (forall f:('b,complex) farray. forall g:('b,complex) farray. forall k:'b.
  ((fc50(f, g)[k]) = infix_pldt((f[k]), (g[k]))))

axiom sum_comp :
  (forall s:'b set. forall f:('b,complex) farray.
  forall g:('b,complex) farray. (sum(s, fc50(f, g)) = infix_pldt(sum(s, f),
  sum(s, g))))

logic fc51 : ('b,complex) farray, ('b,complex) farray -> ('b,complex) farray

axiom fcqtdef51 :
  (forall f:('b,complex) farray. forall g:('b,complex) farray. forall k:'b.
  ((fc51(f, g)[k]) = infix_pldt((f[k]), (g[k]))))

axiom sum_comp_rev :
  (forall s:'b set. forall f:('b,complex) farray.
  forall g:('b,complex) farray. (infix_pldt(sum(s, f), sum(s, g)) = sum(s,
  fc51(f, g))))

logic infix_mndt_closure : (complex,(complex,complex) farray) farray

axiom infix_mndt_closure_def :
  (forall y:complex. forall y1:complex.
  (((infix_mndt_closure[y])[y1]) = infix_mndt(y, y1)))

axiom sum_iter_ : opposite_n(infix_pldt_closure, infix_mndt_closure, c_zero)

axiom sum_iter_1 : opposite1(infix_pldt_closure, infix_mndt_closure)

axiom sum_iter_2 : opposite_com(infix_pldt_closure, infix_mndt_closure)

axiom sum_iter_3 : inverse_tuple(infix_pldt_closure, infix_mndt_closure,
  c_zero)

axiom neutral_zero : (neutral_elt(infix_pldt_closure) = c_zero)

axiom sum_eq :
  (forall s:'a set. forall f:('a,complex) farray.
  forall g:('a,complex) farray.
  ((forall x:'a. (mem(x, s) -> ((f[x]) = (g[x])))) -> (sum(s, f) = sum(s,
  g))))

axiom sum_eq_gen :
  (forall s:'a set. forall sqt:'a set. forall f:('a,complex) farray.
  forall g:('a,complex) farray. ((s = sqt) ->
  ((forall x:'a. (mem(x, s) -> ((f[x]) = (g[x])))) -> (sum(s, f) = sum(sqt,
  g)))))

axiom sum_disjoint_transitivity :
  (forall s1:'a set. forall s2:'a set. forall t:('a,complex) farray.
  ((inter(s1, s2) = (empty : 'a set)) -> (sum(union(s1, s2),
  t) = infix_pldt(sum(s1, t), sum(s2, t)))))

logic fc52 : 'b set, ('a,('b,complex) farray) farray -> ('a,complex) farray

logic fc53 : ('a,('b,complex) farray) farray -> (('a,
  'b) tuple2,complex) farray

axiom fcqtdef52 :
  (forall s2:'b set. forall f:('a,('b,complex) farray) farray. forall a1:'a.
  ((fc52(s2, f)[a1]) = sum(s2, (f[a1]))))

axiom fcqtdef53 :
  (forall f:('a,('b,complex) farray) farray. forall o:('a, 'b) tuple2.
  ((fc53(f)[o]) = ((f[fir(o)])[sec(o)])))

axiom sum_to_cartesian_product :
  (forall s1:'a set. forall s2:'b set.
  forall f:('a,('b,complex) farray) farray. (sum(s1, fc52(s2,
  f)) = sum(cartesian_product(s1, s2), fc53(f))))

logic fc54 : ('a,('b,complex) farray) farray -> (('a,
  'b) tuple2,complex) farray

logic fc55 : 'b set, ('a,('b,complex) farray) farray -> ('a,complex) farray

axiom fcqtdef54 :
  (forall f:('a,('b,complex) farray) farray. forall o:('a, 'b) tuple2.
  ((fc54(f)[o]) = ((f[fir(o)])[sec(o)])))

axiom fcqtdef55 :
  (forall s2:'b set. forall f:('a,('b,complex) farray) farray. forall a1:'a.
  ((fc55(s2, f)[a1]) = sum(s2, (f[a1]))))

axiom sum_from_cartesian_product :
  (forall s1:'a set. forall s2:'b set.
  forall f:('a,('b,complex) farray) farray. (sum(cartesian_product(s1, s2),
  fc54(f)) = sum(s1, fc55(s2, f))))

function ind_sum(f: (int,complex) farray, i: int, j: int) : complex =
  int_iterate(infix_pldt_closure, f, i, j)

axiom ind_sum_to_int_iterate :
  (forall f:(int,complex) farray. forall i:int. forall j:int. (ind_sum(f, i,
  j) = int_iterate(infix_pldt_closure, f, i, j)))

axiom ind_sum_cardone :
  (forall f:(int,complex) farray. forall i:int. forall j:int.
  ((j = (i + 1)) -> (ind_sum(f, i, j) = (f[i]))))

axiom ind_sum_right_extension :
  (forall f:(int,complex) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_sum(f, i, j) = infix_pldt(ind_sum(f, i, (j - 1)), (f[(j - 1)])))))

axiom ind_sum_trans :
  (forall f:(int,complex) farray. forall i:int. forall k:int. forall j:int.
  (((i <= k) and (k <= j)) -> (ind_sum(f, i, j) = infix_pldt(ind_sum(f, i,
  k), ind_sum(f, k, j)))))

axiom ind_sum_plus_one :
  (forall f:(int,complex) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_sum(f, i, j) = infix_pldt((f[i]), ind_sum(f, (i + 1), j)))))

axiom real_ind_sum :
  (forall f:(int,complex) farray. forall i:int. forall j:int. ((i <  j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> real_((f[k])))) ->
  real_(ind_sum(f, i, j)))))

axiom positive_ind_sum :
  (forall f:(int,complex) farray. forall i:int. forall j:int. ((i <  j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> infix_lseqdt(c_zero, (f[k])))) ->
  infix_lseqdt(c_zero, ind_sum(f, i, j)))))

axiom positive_sum :
  (forall s:'a set. forall f:('a,complex) farray.
  ((forall k:'a. (mem(k, s) -> infix_lseqdt(c_zero, (f[k])))) ->
  infix_lseqdt(c_zero, sum(s, f))))

axiom ind_sum_eq :
  (forall f:(int,complex) farray. forall g:(int,complex) farray.
  forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ind_sum(f, i, j) = ind_sum(g, i, j))))

logic fc56 : (int,complex) farray, complex, int, int -> (int,complex) farray

axiom fcqtdef56 :
  (forall f:(int,complex) farray. forall g:complex. forall i:int.
  forall j:int. forall k:int. ((fc56(f, g, i, j)[k]) = (if ((i <= k) and
  (k <  j)) then (f[k]) else g)))

axiom ind_sum_eq_del_bound :
  (forall f:(int,complex) farray. forall g:complex. forall i:int.
  forall j:int. (ind_sum(fc56(f, g, i, j), i, j) = ind_sum(f, i, j)))

logic fc57 : (int,complex) farray, complex, int, int -> (int,complex) farray

axiom fcqtdef57 :
  (forall f:(int,complex) farray. forall g:complex. forall i:int.
  forall j:int. forall k:int. ((fc57(f, g, i, j)[k]) = (if ((i <= k) and
  (k <  j)) then (f[k]) else g)))

axiom ind_sum_eq_del_bound_rev :
  (forall f:(int,complex) farray. forall g:complex. forall i:int.
  forall j:int. (ind_sum(f, i, j) = ind_sum(fc57(f, g, i, j), i, j)))

axiom ind_sum_eq_gen :
  (forall f:(int,complex) farray. forall g:(int,complex) farray.
  forall i1:int. forall j1:int. forall i2:int. forall j2:int. ((i1 = i2) ->
  ((j1 = j2) ->
  ((forall k:int. (((i1 <= k) and (k <  j1)) -> ((f[k]) = (g[k])))) ->
  (ind_sum(f, i1, j1) = ind_sum(g, i2, j2))))))

axiom ind_sum_eq_bound :
  (forall f:(int,complex) farray. forall g:(int,complex) farray.
  forall i:int. forall j:int. ((i = j) ->
  ((forall k:int. (((0 <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ind_sum(f, 0, i) = ind_sum(g, 0, j)))))

logic fc58 : (int,complex) farray,
  (int,complex) farray -> (int,complex) farray

axiom fcqtdef58 :
  (forall f:(int,complex) farray. forall g:(int,complex) farray.
  forall k:int. ((fc58(f, g)[k]) = infix_pldt((f[k]), (g[k]))))

axiom ind_sum_comp :
  (forall f:(int,complex) farray. forall g:(int,complex) farray.
  forall i:int. forall j:int. (ind_sum(fc58(f, g), i,
  j) = infix_pldt(ind_sum(f, i, j), ind_sum(g, i, j))))

logic fc59 : (int,complex) farray,
  (int,complex) farray -> (int,complex) farray

axiom fcqtdef59 :
  (forall f:(int,complex) farray. forall g:(int,complex) farray.
  forall k:int. ((fc59(f, g)[k]) = infix_pldt((f[k]), (g[k]))))

axiom ind_sum_comp_rev :
  (forall f:(int,complex) farray. forall g:(int,complex) farray.
  forall i:int. forall iqt:int. forall j:int. forall jqt:int. ((i = iqt) ->
  ((j = jqt) -> (infix_pldt(ind_sum(f, i, j), ind_sum(g, iqt,
  jqt)) = ind_sum(fc59(f, g), i, j)))))

axiom ind_sum_to_iterate :
  (forall f:(int,complex) farray. forall i:int. forall j:int. (ind_sum(f, i,
  j) = iterate(infix_pldt_closure, to_fset(i, j), f)))

axiom ind_sum_to_sum :
  (forall f:(int,complex) farray. forall i:int. forall j:int. (ind_sum(f, i,
  j) = sum(to_fset(i, j), f)))

logic fc60 : (int,int) farray, (int,complex) farray -> (int,complex) farray

axiom fcqtdef60 :
  (forall f:(int,int) farray. forall t:(int,complex) farray. forall b:int.
  ((fc60(f, t)[b]) = (t[(f[b])])))

axiom map_ind_sum_eq :
  (forall i:int. forall j:int. forall k:int. forall l:int.
  forall f:(int,int) farray. forall t:(int,complex) farray. (p_bijective(f,
  to_fset(i, j), to_fset(k, l)) -> (ind_sum(t, k, l) = ind_sum(fc60(f, t), i,
  j))))

logic fc61 : ('a,complex) farray, complex -> ('a,complex) farray

axiom fcqtdef61 :
  (forall f:('a,complex) farray. forall c:complex. forall x:'a. ((fc61(f,
  c)[x]) = infix_asdt(c, (f[x]))))

axiom sum_scal :
  (forall f:('a,complex) farray. forall s:'a set. forall c:complex. (sum(s,
  fc61(f, c)) = infix_asdt(c, sum(s, f))))

logic fc62 : ('a,complex) farray, complex -> ('a,complex) farray

axiom fcqtdef62 :
  (forall f:('a,complex) farray. forall c:complex. forall x:'a. ((fc62(f,
  c)[x]) = infix_asdt((f[x]), c)))

axiom sum_scal_right :
  (forall f:('a,complex) farray. forall s:'a set. forall c:complex. (sum(s,
  fc62(f, c)) = infix_asdt(sum(s, f), c)))

logic fc63 : ('a,complex) farray, complex -> ('a,complex) farray

axiom fcqtdef63 :
  (forall f:('a,complex) farray. forall c:complex. forall x:'a. ((fc63(f,
  c)[x]) = infix_asdt((f[x]), c)))

axiom sum_scal_rev_right :
  (forall f:('a,complex) farray. forall s:'a set. forall c:complex.
  (infix_asdt(sum(s, f), c) = sum(s, fc63(f, c))))

logic fc64 : ('a,complex) farray, complex -> ('a,complex) farray

axiom fcqtdef64 :
  (forall f:('a,complex) farray. forall c:complex. forall x:'a. ((fc64(f,
  c)[x]) = infix_asdt(c, (f[x]))))

axiom sum_scal_rev :
  (forall f:('a,complex) farray. forall s:'a set. forall c:complex.
  (infix_asdt(c, sum(s, f)) = sum(s, fc64(f, c))))

logic fc65 : (int,complex) farray, complex -> (int,complex) farray

axiom fcqtdef65 :
  (forall f:(int,complex) farray. forall a:complex. forall i:int. ((fc65(f,
  a)[i]) = infix_asdt(a, (f[i]))))

axiom ind_sum_scal :
  (forall f:(int,complex) farray. forall i:int. forall j:int.
  forall a:complex. (ind_sum(fc65(f, a), i, j) = infix_asdt(a, ind_sum(f, i,
  j))))

logic fc66 : (int,complex) farray, complex -> (int,complex) farray

axiom fcqtdef66 :
  (forall f:(int,complex) farray. forall a:complex. forall i:int. ((fc66(f,
  a)[i]) = infix_asdt(a, (f[i]))))

axiom ind_sum_scal_rev :
  (forall f:(int,complex) farray. forall i:int. forall j:int.
  forall a:complex. (infix_asdt(a, ind_sum(f, i, j)) = ind_sum(fc66(f, a), i,
  j)))

logic fc67 : (int,complex) farray, complex -> (int,complex) farray

axiom fcqtdef67 :
  (forall f:(int,complex) farray. forall a:complex. forall i:int. ((fc67(f,
  a)[i]) = infix_asdt((f[i]), a)))

axiom scal_ind_sum :
  (forall f:(int,complex) farray. forall i:int. forall j:int.
  forall a:complex. (ind_sum(fc67(f, a), i, j) = infix_asdt(ind_sum(f, i, j),
  a)))

logic fc68 : (int,complex) farray, complex -> (int,complex) farray

axiom fcqtdef68 :
  (forall f:(int,complex) farray. forall a:complex. forall i:int. ((fc68(f,
  a)[i]) = infix_asdt((f[i]), a)))

axiom scal_ind_sum_rev :
  (forall f:(int,complex) farray. forall i:int. forall j:int.
  forall a:complex. (infix_asdt(ind_sum(f, i, j), a) = ind_sum(fc68(f, a), i,
  j)))

logic fc69 : (int,complex) farray, complex -> (int,complex) farray

axiom fcqtdef69 :
  (forall f:(int,complex) farray. forall a:complex. forall i:int. ((fc69(f,
  a)[i]) = infix_asdt(a, (f[i]))))

axiom sum_scal_gen :
  (forall f:(int,complex) farray. forall s:int set.
  (forall a:complex. (sum(s, fc69(f, a)) = infix_asdt(a, sum(s, f)))))

logic fc70 : (int,complex) farray, complex -> (int,complex) farray

axiom fcqtdef70 :
  (forall f:(int,complex) farray. forall a:complex. forall i:int. ((fc70(f,
  a)[i]) = infix_asdt(a, (f[i]))))

axiom ind_sum_scal_gen :
  (forall f:(int,complex) farray. forall i:int. forall j:int.
  (forall a:complex. (ind_sum(fc70(f, a), i, j) = infix_asdt(a, ind_sum(f, i,
  j)))))

axiom int_int_iterate_def_empty :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. ((j <= i) -> (iterable(op1) ->
  (int_int_iterate(op1, f, i, j, k, l) = neutral_elt(op1)))))

axiom int_int_iterate_def_plus_one :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. ((i <  j) -> (iterable(op1) ->
  (int_int_iterate(op1, f, i, j, k, l) = ((op1[int_iterate(op1, (f[i]), k,
  l)])[int_int_iterate(op1, f, (i + 1), j, k, l)])))))

logic fc71 : ('im1,('im1,'im1) farray) farray,
  (int,(int,'im1) farray) farray, int, int -> (int,'im1) farray

axiom fcqtdef71 :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall k:int. forall l:int.
  forall a:int. ((fc71(op1, f, k, l)[a]) = int_iterate(op1, (f[a]), k, l)))

axiom int_int_iterate_to_int_iterate :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. ((i <= j) -> (iterable(op1) ->
  (int_int_iterate(op1, f, i, j, k, l) = int_iterate(op1, fc71(op1, f, k, l),
  i, j)))))

logic fc72 : ('im1,('im1,'im1) farray) farray,
  (int,(int,'im1) farray) farray, int, int -> (int,'im1) farray

axiom fcqtdef72 :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall k:int. forall l:int.
  forall a:int. ((fc72(op1, f, k, l)[a]) = int_iterate(op1, (f[a]), k, l)))

axiom int_iterate_to_int_int_iterate :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. ((i <= j) -> (iterable(op1) ->
  (int_iterate(op1, fc72(op1, f, k, l), i, j) = int_int_iterate(op1, f, i, j,
  k, l)))))

logic fc73 : (int,(int,'im1) farray) farray -> ((int,
  int) tuple2,'im1) farray

axiom fcqtdef73 :
  (forall f:(int,(int,'im1) farray) farray. forall o:(int, int) tuple2.
  ((fc73(f)[o]) = ((f[fir(o)])[sec(o)])))

axiom int_int_iterate_to_iterate :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. ((i <= j) -> (iterable(op1) -> (commut(op1) ->
  (int_int_iterate(op1, f, i, j, k, l) = iterate(op1,
  cartesian_product(to_fset(i, j), to_fset(k, l)), fc73(f)))))))

logic fc74 : ('a,('b,'im1) farray) farray -> (('a, 'b) tuple2,'im1) farray

logic fc75 : ('a,('b,'im1) farray) farray -> (('b, 'a) tuple2,'im1) farray

axiom fcqtdef74 :
  (forall f:('a,('b,'im1) farray) farray. forall o:('a, 'b) tuple2.
  ((fc74(f)[o]) = ((f[fir(o)])[sec(o)])))

axiom fcqtdef75 :
  (forall f:('a,('b,'im1) farray) farray. forall o:('b, 'a) tuple2.
  ((fc75(f)[o]) = ((f[sec(o)])[fir(o)])))

axiom iterate_commute :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s1:'a set.
  forall s2:'b set. forall f:('a,('b,'im1) farray) farray. (iterable(op1) ->
  (commut(op1) -> (iterate(op1, cartesian_product(s1, s2),
  fc74(f)) = iterate(op1, cartesian_product(s2, s1), fc75(f))))))

logic fc76 : ('im1,('im1,'im1) farray) farray, 'b set,
  ('a,('b,'im1) farray) farray -> ('a,'im1) farray

logic fc77 : ('a,('b,'im1) farray) farray, 'b -> ('a,'im1) farray

logic fc78 : ('im1,('im1,'im1) farray) farray, 'a set,
  ('a,('b,'im1) farray) farray -> ('b,'im1) farray

axiom fcqtdef76 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s2:'b set.
  forall f:('a,('b,'im1) farray) farray. forall a1:'a. ((fc76(op1, s2,
  f)[a1]) = iterate(op1, s2, (f[a1]))))

axiom fcqtdef77 :
  (forall f:('a,('b,'im1) farray) farray. forall a2:'b. forall a1:'a.
  ((fc77(f, a2)[a1]) = ((f[a1])[a2])))

axiom fcqtdef78 :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s1:'a set.
  forall f:('a,('b,'im1) farray) farray. forall a2:'b. ((fc78(op1, s1,
  f)[a2]) = iterate(op1, s1, fc77(f, a2))))

axiom iterate_commute_ :
  (forall op1:('im1,('im1,'im1) farray) farray. forall s1:'a set.
  forall s2:'b set. forall f:('a,('b,'im1) farray) farray. (iterable(op1) ->
  (commut(op1) -> (iterate(op1, s1, fc76(op1, s2, f)) = iterate(op1, s2,
  fc78(op1, s1, f))))))

logic fc79 : (int,(int,'im1) farray) farray -> (int,(int,'im1) farray) farray

axiom fcqtdef79 :
  (forall f:(int,(int,'im1) farray) farray. forall a:int. forall b:int.
  (((fc79(f)[a])[b]) = ((f[b])[a])))

axiom int_int_iterate_commute :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. (iterable(op1) -> (commut(op1) -> ((i <= j) ->
  ((k <= l) -> (int_int_iterate(op1, f, i, j, k, l) = int_int_iterate(op1,
  fc79(f), k, l, i, j)))))))

logic fc80 : ('im1,('im1,'im1) farray) farray,
  (int,(int,'im1) farray) farray, int, int -> (int,'im1) farray

logic fc81 : (int,(int,'im1) farray) farray, int -> (int,'im1) farray

logic fc82 : ('im1,('im1,'im1) farray) farray,
  (int,(int,'im1) farray) farray, int, int -> (int,'im1) farray

axiom fcqtdef80 :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall k:int. forall l:int.
  forall a:int. ((fc80(op1, f, k, l)[a]) = int_iterate(op1, (f[a]), k, l)))

axiom fcqtdef81 :
  (forall f:(int,(int,'im1) farray) farray. forall a:int. forall b:int.
  ((fc81(f, a)[b]) = ((f[b])[a])))

axiom fcqtdef82 :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall a:int. ((fc82(op1, f, i, j)[a]) = int_iterate(op1, fc81(f, a), i,
  j)))

axiom int_iterate_commute :
  (forall op1:('im1,('im1,'im1) farray) farray.
  forall f:(int,(int,'im1) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. (iterable(op1) -> (commut(op1) -> ((i <= j) ->
  ((k <= l) -> (int_iterate(op1, fc80(op1, f, k, l), i, j) = int_iterate(op1,
  fc82(op1, f, i, j), k, l)))))))

logic fc83 : (int,(int,complex) farray) farray, int,
  int -> (int,complex) farray

logic fc84 : (int,(int,complex) farray) farray, int -> (int,complex) farray

logic fc85 : (int,(int,complex) farray) farray, int,
  int -> (int,complex) farray

axiom fcqtdef83 :
  (forall f:(int,(int,complex) farray) farray. forall k:int. forall l:int.
  forall k1:int. ((fc83(f, k, l)[k1]) = ind_sum((f[k1]), k, l)))

axiom fcqtdef84 :
  (forall f:(int,(int,complex) farray) farray. forall k1:int. forall k2:int.
  ((fc84(f, k1)[k2]) = ((f[k2])[k1])))

axiom fcqtdef85 :
  (forall f:(int,(int,complex) farray) farray. forall i:int. forall j:int.
  forall k1:int. ((fc85(f, i, j)[k1]) = ind_sum(fc84(f, k1), i, j)))

axiom ind_sum_commute :
  (forall f:(int,(int,complex) farray) farray. forall i:int. forall j:int.
  forall k:int. forall l:int. ((i <= j) -> ((k <= l) -> (ind_sum(fc83(f, k,
  l), i, j) = ind_sum(fc85(f, i, j), k, l)))))

logic fc86 : ('a,('b,complex) farray) farray, 'b set -> ('a,complex) farray

logic fc87 : ('a,('b,complex) farray) farray, 'b -> ('a,complex) farray

logic fc88 : ('a,('b,complex) farray) farray, 'a set -> ('b,complex) farray

axiom fcqtdef86 :
  (forall f:('a,('b,complex) farray) farray. forall sb:'b set. forall a1:'a.
  ((fc86(f, sb)[a1]) = sum(sb, (f[a1]))))

axiom fcqtdef87 :
  (forall f:('a,('b,complex) farray) farray. forall b1:'b. forall a1:'a.
  ((fc87(f, b1)[a1]) = ((f[a1])[b1])))

axiom fcqtdef88 :
  (forall f:('a,('b,complex) farray) farray. forall sa:'a set. forall b1:'b.
  ((fc88(f, sa)[b1]) = sum(sa, fc87(f, b1))))

axiom sum_commute :
  (forall f:('a,('b,complex) farray) farray. forall sa:'a set.
  forall sb:'b set. (sum(sa, fc86(f, sb)) = sum(sb, fc88(f, sa))))

function non_c_zero(s: 'a set, t: ('a,complex) farray) : 'a set =
  nonn_part(infix_pldt_closure, s, t)

axiom non_c_zeroqtspec :
  (forall s:'a set. forall t:('a,complex) farray.
  (forall e:'a. (mem(e, non_c_zero(s, t)) -> mem(e, s))))

axiom non_c_zeroqtspec1 :
  (forall s:'a set. forall t:('a,complex) farray.
  (forall e:'a. (mem(e, non_c_zero(s, t)) -> (not ((t[e]) = c_zero)))))

axiom non_c_zeroqtspec2 :
  (forall s:'a set. forall t:('a,complex) farray.
  (forall e:'a. ((mem(e, s) and (not ((t[e]) = c_zero))) -> mem(e,
  non_c_zero(s, t)))))

axiom get_non_c_zero_member :
  (forall s:'a set. forall t:('a,complex) farray. forall e:'a. (mem(e,
  non_c_zero(s, t)) -> mem(e, s)))

axiom get_non_c_zero_member1 :
  (forall s:'a set. forall t:('a,complex) farray. forall e:'a. (mem(e,
  non_c_zero(s, t)) -> (not ((t[e]) = c_zero))))

axiom set_non_c_zero_member :
  (forall s:'a set. forall t:('a,complex) farray. forall e:'a. (mem(e, s) ->
  ((not ((t[e]) = c_zero)) -> mem(e, non_c_zero(s, t)))))

axiom set_non_c_zero_member_gen :
  (forall s:'a set. forall t:('a,complex) farray.
  (forall e:'a. ((mem(e, s) and (not ((t[e]) = c_zero))) -> mem(e,
  non_c_zero(s, t)))))

axiom set_non_c_zero_member_gen_ :
  (forall s:'a set. forall t:('a,complex) farray.
  (forall e:'a. ((mem(e, s) and (not ((t[e]) = c_zero))) -> mem(e,
  non_c_zero(s, t)))))

axiom sum_nullity_partition :
  (forall s:'a set. forall t:('a,complex) farray. (sum(s,
  t) = sum(non_c_zero(s, t), t)))

logic fc89 : ('a,'a) farray, ('a,complex) farray -> ('a,complex) farray

axiom fcqtdef89 :
  (forall f:('a,'a) farray. forall t:('a,complex) farray. forall b:'a.
  ((fc89(f, t)[b]) = (t[(f[b])])))

axiom non_null_map :
  (forall s:'a set. forall f:('a,'a) farray. forall t:('a,complex) farray.
  (non_c_zero(map(f, s), t) = map(f, non_c_zero(s, fc89(f, t)))))

logic fc90 : ('a,'a) farray, ('a,complex) farray -> ('a,complex) farray

logic fc91 : ('a,'a) farray, ('a,complex) farray -> ('a,complex) farray

logic fc92 : ('a,'a) farray, ('a,complex) farray -> ('a,complex) farray

axiom fcqtdef90 :
  (forall f:('a,'a) farray. forall t:('a,complex) farray. forall b:'a.
  ((fc90(f, t)[b]) = (t[(f[b])])))

axiom fcqtdef91 :
  (forall f:('a,'a) farray. forall t:('a,complex) farray. forall b:'a.
  ((fc91(f, t)[b]) = (t[(f[b])])))

axiom fcqtdef92 :
  (forall f:('a,'a) farray. forall t:('a,complex) farray. forall b:'a.
  ((fc92(f, t)[b]) = (t[(f[b])])))

axiom map_sum_eq_nonnull :
  (forall s:'a set. forall f:('a,'a) farray. forall t:('a,complex) farray.
  (p_bijective(f, non_c_zero(s, fc90(f, t)), non_c_zero(map(f, s), t)) ->
  (sum(non_c_zero(map(f, s), t), t) = sum(non_c_zero(s, fc91(f, t)), fc92(f,
  t)))))

axiom sum_null_but_one :
  (forall s:'a set. forall t:('a,complex) farray. ((cardinal(non_c_zero(s,
  t)) = 1) -> (sum(s, t) = (t[element(non_c_zero(s, t))]))))

axiom sum_null :
  (forall s:'a set. forall t:('a,complex) farray. ((cardinal(non_c_zero(s,
  t)) = 0) -> (sum(s, t) = c_zero)))

axiom sum_null_ :
  (forall s:'a set. forall t:('a,complex) farray.
  ((forall e:'a. (mem(e, s) -> ((t[e]) = c_zero))) -> (sum(s, t) = c_zero)))

axiom sum_null_forall :
  (forall s:'a set. forall t:('a,complex) farray.
  ((forall e:'a. (mem(e, s) -> ((t[e]) = c_zero))) -> (sum(s, t) = c_zero)))

axiom ind_sum_null :
  (forall t:(int,complex) farray. forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((t[k]) = c_zero))) ->
  (ind_sum(t, i, j) = c_zero)))

axiom sum_null_but_one_elt :
  (forall s:'a set. forall t:('a,complex) farray. forall elt:'a. ((mem(elt,
  s) and (not ((t[elt]) = c_zero))) ->
  ((forall a1:'a. (mem(a1, s) -> ((not (a1 = elt)) -> ((t[a1]) = c_zero)))) ->
  (sum(s, t) = (t[elt])))))

axiom sum_null_but_maybe_one_elt :
  (forall t:('a,complex) farray. forall s:'a set. forall elt:'a. (mem(elt,
  s) ->
  ((forall k:'a. (mem(k, s) -> ((not (k = elt)) -> ((t[k]) = c_zero)))) ->
  (sum(s, t) = (t[elt])))))

axiom sum_null_but_maybe_two_elt :
  (forall t:('a,complex) farray. forall s:'a set. forall elt:'a.
  forall eltqt:'a. (mem(elt, s) -> (mem(eltqt, s) -> ((not (elt = eltqt)) ->
  ((forall k:'a. (mem(k, s) -> ((not (k = elt)) -> ((not (k = eltqt)) ->
   ((t[k]) = c_zero))))) ->
  (sum(s, t) = infix_pldt((t[elt]), (t[eltqt]))))))))

axiom ind_sum_null_but_maybe_one_elt :
  (forall t:(int,complex) farray. forall i:int. forall j:int. forall ind:int.
  (((i <= ind) and (ind <  j)) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((not (k = ind)) ->
   ((t[k]) = c_zero)))) ->
  (ind_sum(t, i, j) = (t[ind])))))

axiom ind_sum_null_but_maybe_two_elt :
  (forall t:(int,complex) farray. forall i:int. forall j:int. forall ind:int.
  forall indqt:int. (((i <= ind) and (ind <  j)) -> (((i <= indqt) and
  (indqt <  j)) -> ((not (ind = indqt)) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((not (k = ind)) ->
   ((not (k = indqt)) -> ((t[k]) = c_zero))))) ->
  (ind_sum(t, i, j) = infix_pldt((t[ind]), (t[indqt]))))))))

logic fc93 : (int,int) farray, (int,complex) farray -> (int,complex) farray

axiom fcqtdef93 :
  (forall g:(int,int) farray. forall f:(int,complex) farray. forall k:int.
  ((fc93(g, f)[k]) = (f[(g[k])])))

axiom ind_sum_map_filter :
  (forall n:int. forall nqt:int. forall g:(int,int) farray.
  forall f:(int,complex) farray. forall p:(int,bool) farray. (((0 <= nqt) and
  (nqt <= n)) -> (p_injective(g, to_fset(0, nqt)) ->
  ((forall k:int. (((0 <= k) and (k <  n)) -> ((not ((p[k]) = true)) ->
   ((f[k]) = c_zero)))) ->
  ((forall k:int. (((0 <= k) and (k <  nqt)) -> ((0 <= (g[k])) and
   ((g[k]) <  n)))) ->
  ((forall k:int. (((0 <= k) and (k <  n)) -> (((p[k]) = true) <->
   (exists ant:int. (((0 <= ant) and (ant <  nqt)) and (k = (g[ant]))))))) ->
  (ind_sum(f, 0, n) = ind_sum(fc93(g, f), 0, nqt))))))))

logic infix_asdt_closure : (complex,(complex,complex) farray) farray

axiom infix_asdt_closure_def :
  (forall y:complex. forall y1:complex.
  (((infix_asdt_closure[y])[y1]) = infix_asdt(y, y1)))

axiom neutral_c_one : neutral(infix_asdt_closure, c_one)

axiom neutral_c_one1 : iterable(infix_asdt_closure)

axiom product_iter : op_neutral_left(infix_asdt_closure, c_one)

axiom product_iter1 : op_neutral_right(infix_asdt_closure, c_one)

axiom product_iter2 : op_assoc(infix_asdt_closure)

axiom product_iter3 : commut(infix_asdt_closure)

axiom product_iter4 : iterates(infix_asdt_closure, c_one)

function product(s: 'a set, t: ('a,complex) farray) : complex =
  iterate(infix_asdt_closure, s, t)

axiom product_eq :
  (forall s:'a set. forall t:('a,complex) farray.
  forall tqt:('a,complex) farray.
  ((forall e:'a. (mem(e, s) -> ((t[e]) = (tqt[e])))) -> (product(s,
  t) = product(s, tqt))))

axiom product_eq_gen :
  (forall s:'a set. forall sqt:'a set. forall t:('a,complex) farray.
  forall tqt:('a,complex) farray. ((s = sqt) ->
  ((forall e:'a. (mem(e, s) -> ((t[e]) = (tqt[e])))) -> (product(s,
  t) = product(sqt, tqt)))))

axiom product_empty :
  (forall s:'a set. forall f:('a,complex) farray. (is_empty(s) -> (product(s,
  f) = c_one)))

axiom product_iter_ : iterable(infix_asdt_closure)

axiom add_product :
  (forall s:'a set. forall f:('a,complex) farray. forall x:'a. ((not mem(x,
  s)) -> (product(add(x, s), f) = infix_asdt((f[x]), product(s, f)))))

axiom product_add :
  (forall s:'a set. forall f:('a,complex) farray. forall x:'a. ((not mem(x,
  s)) -> (product(add(x, s), f) = infix_asdt(product(s, f), (f[x])))))

axiom neutral_one : (neutral_elt(infix_asdt_closure) = c_one)

function ind_product(f: (int,complex) farray, i: int, j: int) : complex =
  int_iterate(infix_asdt_closure, f, i, j)

axiom ind_product_eq :
  (forall f:(int,complex) farray. forall g:(int,complex) farray.
  forall i:int. forall j:int.
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ind_product(f, i, j) = ind_product(g, i, j))))

axiom ind_product_cardone :
  (forall f:(int,complex) farray. forall i:int. forall j:int.
  ((j = (i + 1)) -> (ind_product(f, i, j) = (f[i]))))

axiom ind_product_eq_gen :
  (forall f:(int,complex) farray. forall g:(int,complex) farray.
  forall i1:int. forall j1:int. forall i2:int. forall j2:int.
  ((forall k:int. (((i1 <= k) and (k <  j1)) -> ((f[k]) = (g[k])))) ->
  ((i1 = i2) -> ((j1 = j2) -> (ind_product(f, i1, j1) = ind_product(g, i2,
  j2))))))

axiom ind_product_right_extension :
  (forall f:(int,complex) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_product(f, i, j) = infix_asdt(ind_product(f, i, (j - 1)),
  (f[(j - 1)])))))

axiom ind_product_left_extension :
  (forall f:(int,complex) farray. forall i:int. forall j:int. ((i <  j) ->
  (ind_product(f, i, j) = infix_asdt((f[i]), ind_product(f, (i + 1), j)))))

axiom ind_product_to_product :
  (forall f:(int,complex) farray. forall i:int. forall j:int. (ind_product(f,
  i, j) = product(to_fset(i, j), f)))

logic fc94 : ('b,'a) farray, ('a,complex) farray -> ('b,complex) farray

axiom fcqtdef94 :
  (forall f:('b,'a) farray. forall t:('a,complex) farray. forall b1:'b.
  ((fc94(f, t)[b1]) = (t[(f[b1])])))

axiom map_product_eq :
  (forall s:'b set. forall f:('b,'a) farray. forall t:('a,complex) farray.
  (p_injective(f, s) -> (product(map(f, s), t) = product(s, fc94(f, t)))))

logic fc95 : (int,int) farray, (int,complex) farray -> (int,complex) farray

axiom fcqtdef95 :
  (forall f:(int,int) farray. forall t:(int,complex) farray. forall b:int.
  ((fc95(f, t)[b]) = (t[(f[b])])))

axiom map_ind_product_eq :
  (forall i:int. forall j:int. forall k:int. forall l:int.
  forall f:(int,int) farray. forall t:(int,complex) farray. (p_bijective(f,
  to_fset(i, j), to_fset(k, l)) -> (ind_product(t, k,
  l) = ind_product(fc95(f, t), i, j))))

axiom ind_product_right_extension_comm :
  (forall f:(int,complex) farray. forall i:int. forall j:int. ((i <  j) ->
  (infix_asdt(ind_product(f, i, (j - 1)), (f[(j - 1)])) = ind_product(f, i,
  j))))

axiom ind_product_eq_func :
  (forall i:int. forall j:int. forall f1:(int,complex) farray.
  forall f2:(int,complex) farray. (p_injective(f1, to_fset(i, j)) ->
  (p_injective(f2, to_fset(i, j)) -> ((map(f1, to_fset(i, j)) = map(f2,
  to_fset(i, j))) -> (ind_product(f1, i, j) = ind_product(f2, i, j))))))

axiom ind_product_trans :
  (forall f:(int,complex) farray. forall i:int. forall k:int. forall j:int.
  (((i <= k) and (k <= j)) -> (ind_product(f, i,
  j) = infix_asdt(ind_product(f, i, k), ind_product(f, k, j)))))

axiom ind_product_zero_pre :
  (forall f:(int,complex) farray. forall i:int. forall t:int. forall j:int.
  (((i <= t) and (t <  j)) -> (((f[t]) = c_zero) -> (ind_product(f, i,
  j) = c_zero))))

axiom ind_product_zero :
  (forall f:(int,complex) farray. forall i:int. forall j:int. ((i <= j) ->
  ((exists t:int. (((i <= t) and (t <  j)) and ((f[t]) = c_zero))) ->
  (ind_product(f, i, j) = c_zero))))

axiom ind_product_zero_elt :
  (forall f:(int,complex) farray. forall i:int. forall j:int. forall t:int.
  ((i <= j) -> (((i <= t) and (t <  j)) -> (((f[t]) = c_zero) ->
  (ind_product(f, i, j) = c_zero)))))

axiom ind_product_const_c_one :
  (forall f:(int,complex) farray. forall i:int. forall j:int. ((i <= j) ->
  ((forall t:int. (((i <= t) and (t <  j)) -> ((f[t]) = c_one))) ->
  (ind_product(f, i, j) = c_one))))

logic fc96 : 'b set, ('a,('b,bool) farray) farray,
  ('b,complex) farray -> ('a,complex) farray

axiom fcqtdef96 :
  (forall s2:'b set. forall p:('a,('b,bool) farray) farray.
  forall f:('b,complex) farray. forall l:'a. ((fc96(s2, p,
  f)[l]) = sum(my_filter(s2, (p[l])), f)))

axiom sum_filter_decomp :
  (forall s:'a set. forall s2:'b set. forall p:('a,('b,bool) farray) farray.
  forall p1:('b,bool) farray. forall f:('b,complex) farray.
  ((forall e:'b. (mem(e, s2) -> (((p1[e]) = true) <->
   (exists eqt:'a. (mem(eqt, s) and (((p[eqt])[e]) = true)))))) ->
  ((forall e:'b.
   (forall eqt:'a. forall eqtqt:'a. (mem(e, s2) -> (((p1[e]) = true) ->
   (mem(eqt, s) -> (mem(eqtqt, s) -> ((((p[eqt])[e]) = true) ->
   ((((p[eqtqt])[e]) = true) -> (eqt = eqtqt))))))))) ->
  (sum(s, fc96(s2, p, f)) = sum(my_filter(s2, p1), f)))))

axiom ind_sum_constant :
  (forall f:(int,complex) farray. forall valu:complex. forall i:int.
  forall j:int. ((i <= j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = valu))) ->
  (ind_sum(f, i, j) = infix_asdt(valu, i_to_c((j - i)))))))

axiom ind_sum_constant_from_z :
  (forall f:(int,complex) farray. forall valu:complex. forall j:int.
  ((0 <= j) ->
  ((forall k:int. (((0 <= k) and (k <  j)) -> ((f[k]) = valu))) ->
  (ind_sum(f, 0, j) = infix_asdt(valu, i_to_c(j))))))

axiom sum_constant_lower_bound :
  (forall s:'a set. forall t:('a,complex) farray. forall x:complex.
  ((forall e:'a. (mem(e, s) -> real_((t[e])))) ->
  ((forall e:'a. (mem(e, s) -> infix_lseqdt((t[e]), x))) -> (real_(x) ->
  infix_lseqdt(sum(s, t), infix_asdt(i_to_c(cardinal(s)), x))))))

axiom sum_inf :
  (forall s:'a set. forall t:('a,complex) farray.
  forall tqt:('a,complex) farray.
  ((forall e:'a. (mem(e, s) -> real_((t[e])))) ->
  ((forall e:'a. (mem(e, s) -> real_((tqt[e])))) ->
  ((forall e:'a. (mem(e, s) -> infix_lseqdt((t[e]), (tqt[e])))) ->
  infix_lseqdt(sum(s, t), sum(s, tqt))))))

axiom sum_constant :
  (forall s:'a set. forall t:('a,complex) farray. forall x:complex.
  ((forall e:'a. (mem(e, s) -> ((t[e]) = x))) -> (sum(s,
  t) = infix_asdt(i_to_c(cardinal(s)), x))))

axiom ind_sum_constant_case :
  (forall n:int. forall t:(int,complex) farray. forall p:(int,bool) farray.
  forall x:complex. forall y:complex. forall k1:int. ((0 <= n) ->
  ((cardinal(my_filter(to_fset(0, n), p)) = k1) ->
  ((forall e:int. (((0 <= e) and (e <  n)) -> (((p[e]) = true) ->
   ((t[e]) = x)))) ->
  ((forall e:int. (((0 <= e) and (e <  n)) -> ((not ((p[e]) = true)) ->
   ((t[e]) = y)))) ->
  (ind_sum(t, 0, n) = infix_pldt(infix_asdt(i_to_c(k1), x),
  infix_asdt(i_to_c((n - k1)), y))))))))

axiom sum_const_one :
  (forall s:'a set. forall t:('a,complex) farray.
  ((forall e:'a. (mem(e, s) -> ((t[e]) = c_one))) -> (sum(s,
  t) = i_to_c(cardinal(s)))))

axiom abs_eqinf :
  (forall x:int. forall y:int. (((x <= y) and (y <= 0)) ->
  (abs(y) <= abs(x))))

axiom abs_inf :
  (forall x:int. forall y:int. (((0 <  x) and ((x <  y) and (y <= 0))) ->
  (abs(y) <  abs(x))))

axiom abs_eqsup :
  (forall x:int. forall y:int. (((x <= 0) and (y <= x)) ->
  (abs(x) <= abs(y))))

axiom abs_sup :
  (forall x:int. forall y:int. (((x <= 0) and (y <  x)) ->
  (abs(x) <  abs(y))))

axiom inv_negeq : (forall x:int. ((x <= 0) -> (0 <= abs(x))))

axiom inv_neg1 : (forall x:int. ((x <  0) -> (0 <  abs(x))))

logic cpower : complex, int -> complex

axiom Cpower_zero : (forall i:complex. (cpower(i, 0) = c_one))

axiom Cpower_one : (forall i:complex. (cpower(i, 1) = i))

axiom Cpower_sum :
  (forall i:complex.
  (forall n:int. forall m:int. (((i = c_zero) -> (not (n = (-m)))) ->
  (cpower(i, (n + m)) = infix_asdt(cpower(i, n), cpower(i, m))))))

axiom zero_poower :
  (forall e:int. ((not (e = 0)) -> (cpower(c_zero, e) = c_zero)))

axiom cpower_ttwo_two : (cpower(infix_pldt(c_one, c_one), 2) = i_to_c(4))

axiom real_squarert_two : real_(square_rt(infix_pldt(c_one, c_one)))

axiom squarertTwo : (cpower(square_rt(infix_pldt(c_one, c_one)),
  2) = infix_pldt(c_one, c_one))

axiom complete_rt_two :
  (forall a:complex. ((a = infix_sldt(square_rt(infix_pldt(c_one, c_one)),
  infix_pldt(c_one, c_one))) -> (infix_asdt(square_rt(infix_pldt(c_one,
  c_one)), a) = c_one)))

axiom cpower_sum :
  (forall x:complex. forall n:int. forall m:int. (((x = c_zero) ->
  (not (n = (-m)))) -> (cpower(x, (n + m)) = infix_asdt(cpower(x, n),
  cpower(x, m)))))

axiom cpower_one :
  (forall x:complex. forall n:int. ((n = 1) -> (cpower(x, n) = x)))

axiom cpower_two :
  (forall x:complex. forall n:int. ((n = 2) -> (cpower(x, n) = infix_asdt(x,
  x))))

axiom cpower_two_rev : (forall x:complex. (infix_asdt(x, x) = cpower(x, 2)))

axiom cpower_sum_rev :
  (forall x:complex. forall n:int. forall m:int. (((x = c_zero) ->
  (not (n = (-m)))) -> (infix_asdt(cpower(x, n), cpower(x, m)) = cpower(x,
  (n + m)))))

axiom cpower_plus_one :
  (forall e:complex. forall i:int. (((e = c_zero) -> (not (i = (- 1)))) ->
  (cpower(e, (i + 1)) = infix_asdt(cpower(e, i), e))))

axiom cpower_zero : (forall e:complex. (cpower(e, 0) = c_one))

axiom cpower_eq :
  (forall e:complex. forall eqt:complex. forall i:int. forall iqt:int.
  ((e = eqt) -> ((i = iqt) -> (cpower(e, i) = cpower(eqt, iqt)))))

axiom cpower_inv :
  (forall e:complex. forall i:int. ((not (e = c_zero)) ->
  (infix_asdt(cpower(e, i), cpower(e, (-i))) = c_one)))

axiom compat_cpower_leq :
  (forall a:complex. forall b:complex. forall i:int. ((infix_lseqdt(c_zero,
  a) and infix_lseqdt(a, b)) -> ((0 <= i) -> infix_lseqdt(c_zero, cpower(a,
  i)))))

axiom compat_cpower_leq1 :
  (forall a:complex. forall b:complex. forall i:int. ((infix_lseqdt(c_zero,
  a) and infix_lseqdt(a, b)) -> ((0 <= i) -> infix_lseqdt(cpower(a, i),
  cpower(b, i)))))

axiom cpower_inv_rew :
  (forall e:complex. forall i:int. ((not (e = c_zero)) -> (cpower(e,
  i) = infix_sldt(c_one, cpower(e, (-i))))))

axiom inv_cpower :
  (forall e:complex. forall i:int. ((not (cpower(e, i) = c_zero)) ->
  (infix_sldt(c_one, cpower(e, i)) = cpower(e, (-i)))))

axiom cpower_div :
  (forall x:complex. forall y:complex. forall n:int. ((0 <= n) ->
  ((not (y = c_zero)) -> (cpower(infix_sldt(x, y), n) = infix_sldt(cpower(x,
  n), cpower(y, n))))))

axiom cpower_div_rev :
  (forall x:complex. forall y:complex. forall n:int. ((0 <= n) ->
  ((not (y = c_zero)) -> (infix_sldt(cpower(x, n), cpower(y,
  n)) = cpower(infix_sldt(x, y), n)))))

axiom cpower_pi_bound_square_inv : infix_lseqdt(infix_sldt(i_to_c(4),
  cpower(pi, 2)), c_one)

axiom cpower_mult_split :
  (forall x:complex. forall y:complex. forall m:int. ((0 <= m) ->
  (cpower(infix_asdt(x, y), m) = infix_asdt(cpower(x, m), cpower(y, m)))))

axiom not_cpower_zero :
  (forall e:complex. forall i:int. ((not (e = c_zero)) -> (not (cpower(e,
  i) = c_zero))))

axiom cpower_inv_out :
  (forall x:complex. forall y:complex. (infix_lsdt(c_zero, y) ->
  (infix_asdt(cpower(infix_asdt(infix_sldt(c_one, square_rt(y)), x), 2),
  y) = cpower(x, 2))))

axiom squarert_inv :
  (forall x:complex. (infix_lsdt(c_zero, x) -> (infix_sldt(c_one,
  square_rt(x)) = square_rt(infix_sldt(c_one, x)))))

axiom squarert_inv_rev :
  (forall x:complex. (infix_lsdt(c_zero, x) -> (square_rt(infix_sldt(c_one,
  x)) = infix_sldt(c_one, square_rt(x)))))

axiom squarert_div :
  (forall x:complex. forall y:complex. (infix_lseqdt(c_zero, x) ->
  (infix_lsdt(c_zero, y) -> (infix_sldt(square_rt(x),
  square_rt(y)) = square_rt(infix_sldt(x, y))))))

axiom cpower_squarert_two :
  (forall i:int. ((0 <= i) -> (cpower(square_rt(infix_pldt(c_one, c_one)),
  i) = square_rt(i_to_c(power(2, i))))))

axiom cpower_square_rt_raise :
  (forall x:complex. forall y:complex. (infix_lsdt(c_zero, y) ->
  (cpower(infix_sldt(x, square_rt(y)), 2) = infix_sldt(infix_asdt(cpower(x,
  2), c_one), y))))

axiom cpower_subst :
  (forall x:complex. forall n:int. forall m:int. ((not (x = c_zero)) ->
  (infix_asdt(infix_sldt(c_one, cpower(x, n)), cpower(x, m)) = cpower(x,
  (m - n)))))

axiom cpower_c_one_pos :
  (forall m:int. ((0 <= m) -> (cpower(c_one, m) = c_one)))

axiom mult_cpower :
  (forall x:complex. forall xqt:complex. forall i:int. ((0 <= i) ->
  (infix_asdt(cpower(x, i), cpower(xqt, i)) = cpower(infix_asdt(x, xqt),
  i))))

axiom mult_cpower_rev :
  (forall x:complex. forall xqt:complex. forall i:int. ((0 <= i) ->
  (cpower(infix_asdt(x, xqt), i) = infix_asdt(cpower(x, i), cpower(xqt,
  i)))))

logic fc97 : (complex,(int,complex) farray) farray

axiom fcqtdef97 : (forall y0:complex. forall y1:int. (((fc97[y0])[y1]) = y0))

axiom cpower_iterate :
  (forall e:complex. forall i:int. ((0 <= i) -> (cpower(e,
  i) = int_iterate(infix_asdt_closure, (fc97[e]), 0, i))))

axiom cpower_modulus :
  (forall x:complex. forall n:int. ((0 <= n) -> (modulus(cpower(x,
  n)) = cpower(modulus(x), n))))

axiom cpower_modulus1 :
  (forall x:complex. forall n:int. ((0 <= n) -> ((0 <  n) ->
  (infix_lsdt(modulus(x), c_one) -> infix_lsdt(modulus(cpower(x, n)),
  c_one)))))

axiom cpower_modulus2 :
  (forall x:complex. forall n:int. ((0 <= n) -> ((0 <  n) ->
  ((modulus(x) = c_one) -> (modulus(cpower(x, n)) = c_one)))))

axiom cpower_modulus3 :
  (forall x:complex. forall n:int. ((0 <= n) -> ((0 <  n) ->
  (infix_gtdt(modulus(x), c_one) -> infix_gtdt(modulus(cpower(x, n)),
  c_one)))))

axiom cpower_modulus4 :
  (forall x:complex. forall n:int. ((0 <= n) -> ((0 <  n) ->
  (infix_lsdt(modulus(cpower(x, n)), c_one) -> infix_lsdt(modulus(x),
  c_one)))))

axiom cpower_modulus5 :
  (forall x:complex. forall n:int. ((0 <= n) -> ((0 <  n) ->
  ((modulus(cpower(x, n)) = c_one) -> (modulus(x) = c_one)))))

axiom cpower_modulus6 :
  (forall x:complex. forall n:int. ((0 <= n) -> ((0 <  n) ->
  (infix_gtdt(modulus(cpower(x, n)), c_one) -> infix_gtdt(modulus(x),
  c_one)))))

axiom cpower_mult_pre :
  (forall x:complex. forall n:int. forall m:int. ((0 <= m) -> (cpower(x,
  (n * m)) = cpower(cpower(x, n), m))))

axiom cpower_mult :
  (forall x:complex. forall n:int. forall m:int. (cpower(x,
  (n * m)) = cpower(cpower(x, n), m)))

axiom cpower_mult_rev :
  (forall x:complex. forall n:int. forall m:int. (cpower(cpower(x, n),
  m) = cpower(x, (n * m))))

axiom non_zero_cpower_pos :
  (forall i:complex. forall n:int. ((not (i = c_zero)) -> ((0 <= n) ->
  (not (cpower(i, n) = c_zero)))))

axiom inv_cpower_ :
  (forall e:complex. forall i:int. ((not (e = c_zero)) -> (infix_sldt(c_one,
  cpower(e, i)) = cpower(e, (-i)))))

axiom zero_cpower_pos :
  (forall n:int. ((0 <  n) -> (cpower(c_zero, n) = c_zero)))

axiom zero_cpower :
  (forall n:int. ((not (n = 0)) -> (cpower(c_zero, n) = c_zero)))

axiom non_zero_cpower :
  (forall i:complex. forall n:int. ((not (i = c_zero)) -> (not (cpower(i,
  n) = c_zero))))

axiom real_cpower_pos :
  (forall elt:complex. forall i:int. (real_(elt) -> ((0 <= i) ->
  real_(cpower(elt, i)))))

axiom real_cpower :
  (forall elt:complex. forall i:int. (real_(elt) -> real_(cpower(elt, i))))

axiom real_cpower_is_pos :
  (forall elt:complex. forall i:int. (real_(elt) -> (infix_lseqdt(c_zero,
  elt) -> ((0 <= i) -> infix_lseqdt(c_zero, cpower(elt, i))))))

axiom real_cpower_is_strict_pos :
  (forall elt:complex. forall i:int. (real_(elt) -> (infix_lsdt(c_zero,
  elt) -> ((0 <= i) -> infix_lsdt(c_zero, cpower(elt, i))))))

axiom real_modulus_square :
  (forall x:complex. (real_(x) -> (cpower(modulus(x), 2) = cpower(x, 2))))

axiom real_modulus_pos :
  (forall x:complex. (real_(x) -> (infix_lseqdt(c_zero, x) ->
  (modulus(x) = x))))

function conjugate(i: complex) : complex = infix_mndt(t_real_part(i),
  infix_asdt(im, t_im_part(i)))

axiom real_part_conjugate :
  (forall i:complex. (t_real_part(conjugate(i)) = t_real_part(i)))

axiom im_part_conjugate :
  (forall i:complex. (t_im_part(conjugate(i)) = prefix_mndt(t_im_part(i))))

axiom invol_conjugate : (forall i:complex. (conjugate(conjugate(i)) = i))

axiom add_conjugate :
  (forall i:complex. forall j:complex. (conjugate(infix_pldt(i,
  j)) = infix_pldt(conjugate(i), conjugate(j))))

axiom add_own_conjugate :
  (forall i:complex. (infix_pldt(i,
  conjugate(i)) = infix_asdt(infix_pldt(c_one, c_one), t_real_part(i))))

axiom itself_times_conjugate :
  (forall i:complex. real_(infix_asdt(i, conjugate(i))))

axiom itself_times_conjugate1 :
  (forall i:complex. (infix_asdt(i,
  conjugate(i)) = infix_pldt(infix_asdt(t_real_part(i), t_real_part(i)),
  infix_asdt(t_im_part(i), t_im_part(i)))))

axiom conjugate_to_modulus :
  (forall i:complex. (modulus(i) = square_rt(infix_asdt(i, conjugate(i)))))

axiom conjugate_times_itself_pos :
  (forall i:complex. infix_lseqdt(c_zero, infix_asdt(i, conjugate(i))))

logic fc98 : ('a,complex) farray -> ('a,complex) farray

axiom fcqtdef98 :
  (forall f:('a,complex) farray. forall x:'a.
  ((fc98(f)[x]) = conjugate((f[x]))))

axiom sum_conjugate :
  (forall s:'a set. forall f:('a,complex) farray. (conjugate(sum(s,
  f)) = sum(s, fc98(f))))

axiom conjugate_module_one :
  (forall i:complex. ((modulus(i) = c_one) -> (conjugate(i) = inv(i))))

axiom conjugate_module_one_rev :
  (forall i:complex. ((not (i = c_zero)) -> ((conjugate(i) = inv(i)) ->
  (modulus(i) = c_one))))

axiom conjugate_real : (forall i:complex. (real_(i) -> (conjugate(i) = i)))

axiom conjugate_real_gen :
  (forall i:complex. (real_(i) -> (conjugate(i) = i)))

axiom conjugate_one :
  (forall x:complex. ((x = c_one) -> (conjugate(x) = c_one)))

axiom conjugate_c_zero :
  (forall x:complex. ((x = c_zero) -> (conjugate(x) = c_zero)))

function indic(a: 'a1, aqt: 'a1) : complex = (if infix_eqeq(a,
  aqt) then c_one else c_zero)

axiom indicqtspec :
  (forall a:'a1. forall aqt:'a1. (indic(a,
  aqt) = (if (a = aqt) then c_one else c_zero)))

axiom get_indic :
  (forall a:'a1. forall aqt:'a1. (indic(a,
  aqt) = (if (a = aqt) then c_one else c_zero)))

function indic_bool(a: 'a1, aqt: 'a1) : bool = (if infix_eqeq(a,
  aqt) then true else false)

axiom indic_boolqtspec :
  (forall a:'a1. forall aqt:'a1. (indic_bool(a,
  aqt) = (if (a = aqt) then true else false)))

axiom indic_comm :
  (forall a:'a1. forall aqt:'a1. (indic(a, aqt) = indic(aqt, a)))

axiom indic_transl_r :
  (forall a:'a1. forall b:'a1. forall c:'a1. ((b = c) -> (indic(a,
  b) = indic(a, c))))

axiom indic_transl_l :
  (forall a:'a1. forall b:'a1. forall c:'a1. ((b = c) -> (indic(b,
  a) = indic(c, a))))

function indic_2(a: 'a1, aqt: 'a1, b: 'b1, bqt: 'b1) : complex =
  (if ((indic_bool(a, aqt) = true) and (indic_bool(b,
  bqt) = true)) then c_one else c_zero)

axiom indic_2qtspec :
  (forall a:'a1. forall aqt:'a1. forall b:'b1. forall bqt:'b1. (indic_2(a,
  aqt, b, bqt) = infix_asdt(indic(a, aqt), indic(b, bqt))))

axiom indic_2qtspec1 :
  (forall a:'a1. forall aqt:'a1. forall b:'b1. forall bqt:'b1. (indic_2(a,
  aqt, b, bqt) = indic({ Tuple2_proj_1 = a; Tuple2_proj_2 = b }, {
  Tuple2_proj_1 = aqt; Tuple2_proj_2 = bqt })))

axiom indic_2_if :
  (forall i:'a. forall k:'a. forall j:'b. forall l:'b. (indic_2(i, k, j,
  l) = (if ((i = k) and (j = l)) then c_one else c_zero)))

axiom indic_2_comm :
  (forall a:'a1. forall aqt:'a1. forall b:'b1. forall bqt:'b1. (indic_2(a,
  aqt, b, bqt) = indic_2(aqt, a, b, bqt)))

axiom indic_2_comm1 :
  (forall a:'a1. forall aqt:'a1. forall b:'b1. forall bqt:'b1. (indic_2(a,
  aqt, b, bqt) = indic_2(a, aqt, bqt, b)))

axiom indic_2_comm2 :
  (forall a:'a1. forall aqt:'a1. forall b:'b1. forall bqt:'b1. (indic_2(a,
  aqt, b, bqt) = indic_2(aqt, a, bqt, b)))

logic result4 : ('a,complex) farray, 'a -> ('a,complex) farray

axiom resultqtdef8 :
  (forall t:('a,complex) farray. forall i:'a. forall e:'a. ((result4(t,
  i)[e]) = infix_asdt((t[e]), indic(i, e))))

function sum_indic(s: 'a set, t: ('a,complex) farray, i: 'a) : complex =
  sum(s, result4(t, i))

function bool_to_c(a: bool) : complex =
  (if (a = true) then c_one else c_zero)

logic ind_sum_indic : (int,complex) farray, int, int, int -> complex

logic result5 : (int,complex) farray, int -> (int,complex) farray

axiom resultqtdef9 :
  (forall t:(int,complex) farray. forall i:int. forall e:int. ((result5(t,
  i)[e]) = infix_asdt((t[e]), indic(i, e))))

axiom ind_sum_indicqtdef :
  (forall t:(int,complex) farray. forall l:int. forall h:int. forall i:int.
  ((l <  h) -> (ind_sum_indic(t, l, h, i) = ind_sum(result5(t, i), l, h))))

axiom ind_sum_indicqtspec :
  (forall t:(int,complex) farray. forall l:int. forall h:int. forall i:int.
  ((l <  h) -> (ind_sum_indic(t, l, h, i) = sum_indic(to_fset(l, h), t, i))))

axiom sum_indic_t :
  (forall s:'a set. forall t:('a,complex) farray. forall i:'a. (mem(i, s) ->
  (sum_indic(s, t, i) = (t[i]))))

logic fc99 : ('a,complex) farray, 'a -> ('a,complex) farray

axiom fcqtdef99 :
  (forall t:('a,complex) farray. forall i:'a. forall e:'a. ((fc99(t,
  i)[e]) = infix_asdt((t[e]), indic(i, e))))

axiom sum_indic_ts :
  (forall s:'a set. forall t:('a,complex) farray. forall i:'a. (mem(i, s) ->
  (sum(s, fc99(t, i)) = (t[i]))))

logic fc100 : (int,complex) farray, int -> (int,complex) farray

axiom fcqtdef100 :
  (forall t:(int,complex) farray. forall i:int. forall e:int. ((fc100(t,
  i)[e]) = infix_asdt((t[e]), indic(i, e))))

axiom ind_sum_indic_t :
  (forall t:(int,complex) farray. forall l:int. forall h:int. forall i:int.
  (((l <= i) and (i <  h)) -> (ind_sum_indic(t, l, h, i) = (t[i]))))

axiom ind_sum_indic_t1 :
  (forall t:(int,complex) farray. forall l:int. forall h:int. forall i:int.
  (((l <= i) and (i <  h)) -> (ind_sum(fc100(t, i), l, h) = (t[i]))))

logic fc101 : (int,complex) farray, int -> (int,complex) farray

axiom fcqtdef101 :
  (forall t:(int,complex) farray. forall i:int. forall e:int. ((fc101(t,
  i)[e]) = infix_asdt((t[e]), indic(i, e))))

axiom ind_sum_indic_t_quant :
  (forall t:(int,complex) farray. forall l:int. forall h:int.
  (forall i:int. (((l <= i) and (i <  h)) -> (ind_sum(fc101(t, i), l,
  h) = (t[i])))))

axiom conjugate_indic :
  (forall i:'a. forall j:'a. (conjugate(indic(i, j)) = indic(i, j)))

axiom conjugate_indic_rev :
  (forall i:'a. forall j:'a. (indic(i, j) = conjugate(indic(i, j))))

axiom conjugate_indic_gen_int :
  (forall i:int. forall j:int. (conjugate(indic(i, j)) = indic(i, j)))

axiom conjugate_pure_im :
  (forall i:complex. (pure_im_(i) -> (conjugate(i) = prefix_mndt(i))))

axiom conjugate_im : (conjugate(im) = prefix_mndt(im))

axiom conjugate_value :
  (forall c:complex. forall a:complex. forall b:complex. (real_(a) ->
  (real_(b) -> ((c = infix_pldt(a, infix_asdt(im, b))) ->
  (conjugate(c) = infix_mndt(a, infix_asdt(im, b)))))))

axiom conjugate_minus_value :
  (forall c:complex. forall a:complex. forall b:complex. (real_(a) ->
  (real_(b) -> ((c = infix_mndt(a, infix_asdt(im, b))) ->
  (conjugate(c) = infix_pldt(a, infix_asdt(im, b)))))))

axiom prod_conjugate :
  (forall a:complex. forall b:complex. (infix_asdt(a,
  conjugate(b)) = infix_pldt(infix_pldt(infix_asdt(t_real_part(a),
  t_real_part(b)), infix_asdt(t_im_part(a), t_im_part(b))), infix_asdt(im,
  infix_mndt(infix_asdt(t_real_part(b), t_im_part(a)),
  infix_asdt(t_im_part(b), t_real_part(a)))))))

axiom mult_conjugate :
  (forall a:complex. forall b:complex. (conjugate(infix_asdt(a,
  b)) = infix_asdt(conjugate(a), conjugate(b))))

axiom conjugate_prod :
  (forall a:complex. forall b:complex. (infix_asdt(conjugate(a),
  b) = infix_pldt(infix_pldt(infix_asdt(t_real_part(a), t_real_part(b)),
  infix_asdt(t_im_part(a), t_im_part(b))), infix_asdt(im,
  infix_mndt(infix_asdt(t_real_part(a), t_im_part(b)),
  infix_asdt(t_real_part(b), t_im_part(a)))))))

axiom conj_conj_prod :
  (forall a:complex. forall b:complex. (conjugate(infix_asdt(conjugate(a),
  b)) = infix_asdt(a, conjugate(b))))

axiom conj_prod_conj :
  (forall a:complex. forall b:complex. (conjugate(infix_asdt(a,
  conjugate(b))) = infix_asdt(conjugate(a), b)))

axiom itself_prod_conjugate_modulus_one :
  (forall a:complex. ((modulus(a) = c_one) -> (infix_asdt(a,
  conjugate(a)) = c_one)))

axiom conjugate_prod_itself_modulus_one :
  (forall a:complex. ((modulus(a) = c_one) -> (infix_asdt(a,
  conjugate(a)) = c_one)))

axiom modulus_opposite :
  (forall a:complex. (real_(a) -> (infix_lseqdt(c_zero, a) ->
  (modulus(a) = modulus(prefix_mndt(a))))))

axiom modulus_conjugate :
  (forall a:complex. (modulus(a) = modulus(conjugate(a))))

axiom modulus_pos1 :
  (forall a:complex. (real_(a) -> (infix_lseqdt(c_zero, a) ->
  (modulus(a) = a))))

axiom modulus_neg :
  (forall a:complex. (real_(a) -> (infix_lseqdt(a, c_zero) ->
  (modulus(a) = prefix_mndt(a)))))

axiom inv_rewrite :
  (forall x:complex. ((not (x = c_zero)) -> (infix_sldt(c_one,
  x) = infix_sldt(conjugate(x), cpower(modulus(x), 2)))))

axiom inv_rewrite1 :
  (forall x:complex. ((not (x = c_zero)) -> (infix_sldt(c_one,
  x) = infix_asdt(conjugate(x), infix_sldt(c_one, cpower(modulus(x), 2))))))

axiom inv_modulus :
  (forall x:complex. ((not (x = c_zero)) -> (modulus(infix_sldt(c_one,
  x)) = infix_sldt(c_one, modulus(x)))))

axiom div_modulus :
  (forall x:complex. forall y:complex. ((not (x = c_zero)) ->
  (modulus(infix_sldt(y, x)) = infix_sldt(modulus(y), modulus(x)))))

axiom square_frac_modulus :
  (forall x:complex. forall y:complex. ((not (y = c_zero)) ->
  (cpower(modulus(infix_sldt(x, y)), 2) = infix_sldt(cpower(modulus(x), 2),
  cpower(modulus(y), 2)))))

axiom modulus_one_gen :
  (forall a:complex. forall b:complex. (infix_lseqdt(c_zero, a) ->
  (infix_lseqdt(c_zero, b) -> ((infix_pldt(cpower(a, 2), cpower(b,
  2)) = c_one) -> (modulus(infix_pldt(a, infix_asdt(im, b))) = c_one)))))

axiom modulus_one_decomp :
  (forall k:int. forall n:int. (((0 <= k) and (k <  power(2, n))) ->
  (modulus(infix_pldt(infix_sldt(square_rt(i_to_c((power(2, n) - k))),
  square_rt(i_to_c(power(2, n)))), infix_asdt(im,
  infix_sldt(square_rt(i_to_c(k)), square_rt(i_to_c(power(2,
  n))))))) = c_one)))

axiom extract_2_sq_modulus :
  (forall x:complex. forall y:complex. forall a:complex.
  ((not (a = c_zero)) -> ((not (y = c_zero)) ->
  (infix_sldt(cpower(modulus(x), 2), cpower(modulus(y),
  2)) = infix_sldt(infix_asdt(a, cpower(modulus(x), 2)), infix_asdt(a,
  cpower(modulus(y), 2)))))))

axiom cpower_2_modulus_simpl :
  (forall x:complex. forall y:complex. forall z:complex.
  ((not (x = c_zero)) -> ((not (y = c_zero)) -> ((not (z = c_zero)) ->
  (infix_sldt(cpower(modulus(infix_asdt(x, y)), 2),
  cpower(modulus(infix_asdt(z, y)), 2)) = infix_sldt(cpower(modulus(x), 2),
  cpower(modulus(z), 2)))))))

axiom cpower_div_leq_one :
  (forall a:complex. forall b:complex. forall i:int. ((infix_lseqdt(c_zero,
  a) and infix_lseqdt(a, b)) -> (infix_lsdt(c_zero, b) -> ((0 <= i) ->
  infix_lseqdt(c_zero, infix_sldt(cpower(a, i), cpower(b, i)))))))

axiom cpower_div_leq_one1 :
  (forall a:complex. forall b:complex. forall i:int. ((infix_lseqdt(c_zero,
  a) and infix_lseqdt(a, b)) -> (infix_lsdt(c_zero, b) -> ((0 <= i) ->
  infix_lseqdt(infix_sldt(cpower(a, i), cpower(b, i)), c_one)))))

axiom cpower_cpower :
  (forall x:complex. forall a:int. forall b:int. (cpower(cpower(x, a),
  b) = cpower(x, (a * b))))

axiom pre_cond_int_ :
  (forall a:complex. forall b:complex. forall c:complex. (infix_lsdt(a, b) ->
  (infix_lsdt(c_zero, c) -> infix_lsdt(infix_asdt(a, c), infix_asdt(b, c)))))

axiom growing_mult1 :
  (forall n:complex. forall m:complex. (infix_lseqdt(c_zero, n) ->
  (infix_lseqdt(c_one, m) -> infix_lseqdt(n, infix_asdt(n, m)))))

axiom strict_growing_mult_pos :
  (forall n:complex. forall m:complex. (infix_lsdt(c_one, n) ->
  (infix_lsdt(c_one, m) -> infix_lsdt(n, infix_asdt(n, m)))))

axiom init_exp3 : (forall k:complex. (cpower(k, 0) = c_one))

axiom init_exp4 : (forall k:complex. (cpower(k, 1) = k))

axiom init_exp5 : (forall k:complex. (cpower(k, 2) = infix_asdt(k, k)))

axiom int_exp_pos :
  (forall k:complex. forall n:int. (infix_lseqdt(c_one, k) -> ((0 <= n) ->
  infix_lseqdt(c_one, cpower(k, n)))))

axiom int_exp_pos1 :
  (forall k:complex. forall n:int. (infix_lseqdt(c_one, k) -> ((0 <= n) ->
  infix_gtdt(cpower(k, n), c_zero))))

axiom int_exp_pos2 :
  (forall k:complex. forall n:int. (infix_lseqdt(c_one, k) -> ((0 <= n) ->
  infix_lseqdt(cpower(k, n), cpower(k, (n + 1))))))

axiom strict_int_exp_pos :
  (forall k:complex. forall n:int. (infix_lsdt(c_one, k) -> ((0 <  n) ->
  infix_gtdt(cpower(k, n), c_one))))

axiom strict_int_exp_pos1 :
  (forall k:complex. forall n:int. (infix_lsdt(c_one, k) -> ((0 <  n) ->
  infix_lsdt(cpower(k, (n - 1)), cpower(k, n)))))

axiom strict_int_exp_pos2 :
  (forall k:complex. forall n:int. (infix_lsdt(c_one, k) -> ((0 <  n) ->
  infix_lsdt(cpower(k, n), cpower(k, (n + 1))))))

axiom strict_int_exp_neg :
  (forall k:complex. forall n:int. (infix_lsdt(c_one, k) -> ((n <  0) ->
  infix_lsdt(cpower(k, n), c_one))))

axiom strict_int_exp_neg1 :
  (forall k:complex. forall n:int. (infix_lsdt(c_one, k) -> ((n <  0) ->
  infix_lsdt(cpower(k, (n - 1)), cpower(k, n)))))

axiom strict_int_exp_neg2 :
  (forall k:complex. forall n:int. (infix_lsdt(c_one, k) -> ((n <  0) ->
  infix_lsdt(cpower(k, n), cpower(k, (n + 1))))))

axiom int_exp_neg :
  (forall k:complex. forall n:int. (infix_lseqdt(c_one, k) -> ((n <  0) ->
  infix_lseqdt(cpower(k, n), c_one))))

axiom int_exp_neg1 :
  (forall k:complex. forall n:int. (infix_lseqdt(c_one, k) -> ((n <  0) ->
  infix_gtdt(cpower(k, n), c_zero))))

axiom int_exp_neg2 :
  (forall k:complex. forall n:int. (infix_lseqdt(c_one, k) -> ((n <  0) ->
  infix_lseqdt(cpower(k, n), cpower(k, (n + 1))))))

axiom positive_exp :
  (forall k:complex. forall m:int. (infix_lseqdt(c_one, k) ->
  infix_lsdt(c_zero, cpower(k, m))))

axiom growing_exp_pos :
  (forall k:complex. forall m:int. forall n:int. (infix_lseqdt(c_one, k) ->
  (((0 <= m) and (m <= n)) -> infix_lseqdt(cpower(k, m), cpower(k, n)))))

axiom growing_exp1 :
  (forall k:complex. forall m:int. forall n:int. (infix_lseqdt(c_one, k) ->
  ((m <= n) -> infix_lseqdt(cpower(k, m), cpower(k, n)))))

axiom growing_exp_arg :
  (forall k:complex. forall kqt:complex. forall n:int. ((infix_lseqdt(c_zero,
  k) and infix_lseqdt(k, kqt)) -> ((0 <= n) -> infix_lseqdt(cpower(k, n),
  cpower(kqt, n)))))

axiom strict_growing_exp1 :
  (forall k:complex. forall m:int. forall n:int. (infix_lsdt(c_one, k) ->
  ((m <  n) -> infix_lsdt(cpower(k, m), cpower(k, n)))))

axiom cpower_comm_pos :
  (forall x:complex. forall y:complex. forall n:int. (infix_lseqdt(c_one,
  x) -> (infix_lseqdt(c_one, y) -> ((0 <= n) -> (cpower(infix_asdt(x, y),
  n) = infix_asdt(cpower(x, n), cpower(y, n)))))))

axiom cpower_comm :
  (forall x:complex. forall y:complex. forall n:int. (infix_lseqdt(c_one,
  x) -> (infix_lseqdt(c_one, y) -> (cpower(infix_asdt(x, y),
  n) = infix_asdt(cpower(x, n), cpower(y, n))))))

axiom unicity_exp2 :
  (forall k:complex. forall m:int. forall n:int. (infix_lsdt(c_one, k) ->
  ((cpower(k, m) = cpower(k, n)) -> (m = n))))

axiom unicity_exp3 :
  (forall k:complex. forall m:int. forall n:int. (infix_lsdt(c_one, k) ->
  ((m = n) -> (cpower(k, m) = cpower(k, n)))))

axiom cpower_i_to_c :
  (forall a:int. forall b:int. ((0 <= b) -> (i_to_c(power(a,
  b)) = cpower(i_to_c(a), b))))

axiom cpower_i_to_c_rev :
  (forall a:int. forall b:int. ((0 <= b) -> (cpower(i_to_c(a),
  b) = i_to_c(power(a, b)))))

logic fc102 : complex, complex -> (int,complex) farray

axiom fcqtdef102 :
  (forall a:complex. forall q:complex. forall i:int. ((fc102(a,
  q)[i]) = infix_asdt(a, cpower(q, i))))

axiom geometric_series :
  (forall a:complex. forall q:complex. forall n:int. ((1 <= n) ->
  ((not (c_one = q)) -> (sum(to_fset(0, n), fc102(a,
  q)) = infix_sldt(infix_asdt(a, infix_mndt(c_one, cpower(q, n))),
  infix_mndt(c_one, q))))))

logic fc103 : complex, complex -> (int,complex) farray

axiom fcqtdef103 :
  (forall a:complex. forall q:complex. forall i:int. ((fc103(a,
  q)[i]) = infix_asdt(a, cpower(q, i))))

axiom ind_geometric_series_r :
  (forall a:complex. forall q:complex. forall n:int. ((1 <= n) ->
  ((not (c_one = q)) -> (ind_sum(fc103(a, q), 0,
  n) = infix_sldt(infix_asdt(a, infix_mndt(c_one, cpower(q, n))),
  infix_mndt(c_one, q))))))

logic cpower_closure : (complex,(int,complex) farray) farray

axiom cpower_closure_def :
  (forall y:complex. forall y1:int. (((cpower_closure[y])[y1]) = cpower(y,
  y1)))

axiom ind_geometric_series :
  (forall q:complex. forall n:int. ((1 <= n) -> ((not (c_one = q)) ->
  (ind_sum((cpower_closure[q]), 0, n) = infix_sldt(infix_mndt(c_one,
  cpower(q, n)), infix_mndt(c_one, q))))))

axiom geometric_series_init_one :
  (forall q:complex. forall n:int. ((1 <= n) -> ((not (c_one = q)) ->
  (sum(to_fset(0, n), (cpower_closure[q])) = infix_sldt(infix_mndt(c_one,
  cpower(q, n)), infix_mndt(c_one, q))))))

logic fc104 : complex, complex -> (int,complex) farray

axiom fcqtdef104 :
  (forall a:complex. forall q:complex. forall i:int. ((fc104(a,
  q)[i]) = infix_asdt(a, cpower(q, i))))

axiom geometric_series_c_one :
  (forall a:complex. forall q:complex. forall n:int. ((1 <= n) ->
  ((q = c_one) -> (sum(to_fset(0, n), fc104(a, q)) = infix_asdt(a,
  i_to_c(n))))))

axiom geometric_series_c_one_init_one :
  (forall q:complex. forall n:int. ((1 <= n) -> ((q = c_one) ->
  (sum(to_fset(0, n), (cpower_closure[q])) = i_to_c(n)))))

axiom positive_cpower_2 :
  (forall x:complex. (real_(x) -> ((not (c_zero = x)) -> infix_lsdt(c_zero,
  cpower(x, 2)))))

axiom positive_cpower_2_mod :
  (forall x:complex. infix_lseqdt(c_zero, cpower(modulus(x), 2)))

axiom cpower_2_mod_non_null :
  (forall x:complex. ((not (x = c_zero)) -> infix_lsdt(c_zero,
  cpower(modulus(x), 2))))

axiom cpower_2_mod_mult_non_null :
  (forall x:complex. forall y:complex. ((not (x = c_zero)) ->
  ((not (y = c_zero)) -> infix_lsdt(c_zero, cpower(modulus(x), 2)))))

axiom growing_cpower_2 :
  (forall x:complex. forall y:complex. ((infix_lseqdt(c_zero, x) and
  infix_lseqdt(x, y)) -> infix_lseqdt(cpower(x, 2), cpower(y, 2))))

axiom cpower_incr_power_2 :
  (forall k:int. ((0 <= k) -> (cpower(i_to_c(power(2, k)),
  2) = i_to_c(power(2, (2 * k))))))

axiom cpower_modulus_incr_power_2 :
  (forall k:int. ((0 <= k) -> (cpower(modulus(i_to_c(power(2, k))),
  2) = i_to_c(power(2, (2 * k))))))

axiom cpower_modulus_supeq :
  (forall x:complex. forall y:complex. forall i:int. ((1 <= i) ->
  (infix_lseqdt(modulus(y), modulus(x)) -> infix_lseqdt(cpower(modulus(y),
  i), cpower(modulus(x), i)))))

axiom cpower_modulus_div_simpl :
  (forall x:complex. forall y:complex. forall z:complex. forall i:int.
  ((1 <= i) -> (infix_lseqdt(c_zero, x) -> (infix_lsdt(c_zero, y) ->
  (infix_lsdt(c_zero, z) -> (infix_sldt(cpower(x, i), cpower(y,
  i)) = infix_sldt(cpower(modulus(infix_asdt(x, z)), i),
  cpower(modulus(infix_asdt(y, z)), i))))))))

axiom cpower_two_modulus_div_simpl :
  (forall x:complex. forall y:complex. forall z:complex. (real_(x) ->
  (real_(y) -> (real_(z) -> ((not (c_zero = y)) -> ((not (c_zero = z)) ->
  (infix_sldt(cpower(x, 2), cpower(y,
  2)) = infix_sldt(cpower(modulus(infix_asdt(x, z)), 2),
  cpower(modulus(infix_asdt(y, z)), 2)))))))))

logic exp : complex -> complex

axiom e_mod : (forall x:complex. (modulus(exp(x)) = c_one))

axiom e_diff_c_zero : (forall x:complex. (not (exp(x) = c_zero)))

axiom Exp_one : real_(exp(c_one))

axiom Exp_zero : (exp(c_zero) = c_one)

axiom Exp_sum :
  (forall x:complex. forall y:complex. (exp(infix_pldt(x,
  y)) = infix_asdt(exp(x), exp(y))))

axiom exp_one : real_(exp(c_one))

axiom Exp_quarter_pi : (exp(infix_sldt(infix_asdt(im, pi),
  i_to_c(4))) = infix_pldt(infix_sldt(square_rt(infix_pldt(c_one, c_one)),
  infix_pldt(c_one, c_one)), infix_asdt(im,
  infix_sldt(square_rt(infix_pldt(c_one, c_one)), infix_pldt(c_one,
  c_one)))))

axiom exp_sum :
  (forall x:complex. forall y:complex. (exp(infix_pldt(x,
  y)) = infix_asdt(exp(x), exp(y))))

axiom exp_eq :
  (forall t1:complex. forall t2:complex. ((t1 = t2) -> (exp(t1) = exp(t2))))

axiom exp_sum_rev :
  (forall x:complex. forall y:complex. (infix_asdt(exp(x),
  exp(y)) = exp(infix_pldt(x, y))))

axiom exp_inv :
  (forall i:complex. ((not (exp(i) = c_zero)) ->
  (exp(prefix_mndt(i)) = infix_sldt(c_one, exp(i)))))

axiom exp_inv_rev :
  (forall i:complex. ((not (exp(i) = c_zero)) -> (infix_sldt(c_one,
  exp(i)) = exp(prefix_mndt(i)))))

axiom exp_mult_pre :
  (forall x:complex. forall y:int. ((0 <= y) -> (exp(infix_asdt(x,
  i_to_c(y))) = cpower(exp(x), y))))

axiom exp_mult :
  (forall x:complex. forall y:int. (exp(infix_asdt(x,
  i_to_c(y))) = cpower(exp(x), y)))

axiom cpower_to_exp :
  (forall x:complex. forall y:int. (cpower(exp(x), y) = exp(infix_asdt(x,
  i_to_c(y)))))

axiom exp_h_pi : (exp(infix_sldt(infix_asdt(im, pi), infix_pldt(c_one,
  c_one))) = im)

axiom exp_pi : (exp(infix_asdt(im, pi)) = prefix_mndt(c_one))

axiom exp_two_pi : (exp(infix_asdt(infix_asdt(im, pi), infix_pldt(c_one,
  c_one))) = c_one)

axiom exp_two_pi_mul :
  (forall k:int. (exp(infix_asdt(i_to_c(k), infix_asdt(infix_asdt(im, pi),
  infix_pldt(c_one, c_one)))) = c_one))

axiom exp_two_pi_mul_den :
  (forall k:int. forall l:int. ((not (k = 0)) ->
  (exp(infix_sldt(infix_asdt(i_to_c((k * l)), infix_asdt(infix_asdt(im, pi),
  infix_pldt(c_one, c_one))), i_to_c(k))) = c_one)))

axiom exp_two_pi_mul_den_add :
  (forall k:int. forall l:int. forall m:int.
  (exp(infix_asdt(i_to_c(((k * m) + l)), infix_asdt(infix_asdt(im, pi),
  infix_pldt(c_one, c_one)))) = exp(infix_asdt(i_to_c(l),
  infix_asdt(infix_asdt(im, pi), infix_pldt(c_one, c_one))))))

type angle

logic ang_inv : angle -> angle

logic ac ang_add : angle, angle -> angle

logic ang_meas : angle -> complex

axiom ang_measqtspec : (forall us:angle. infix_lseqdt(c_zero, ang_meas(us)))

axiom ang_measqtspec1 : (forall us:angle. infix_lsdt(ang_meas(us), c_one))

axiom real_ang_meas : (forall o:angle. real_(ang_meas(o)))

logic real_to_ang : complex -> angle

logic ang_zero : angle

axiom Assoc2 :
  (forall x:angle. forall y:angle. forall z:angle. (ang_add(ang_add(x, y),
  z) = ang_add(x, ang_add(y, z))))

axiom Unit_def_l1 : (forall x:angle. (ang_add(ang_zero, x) = x))

axiom Unit_def_r1 : (forall x:angle. (ang_add(x, ang_zero) = x))

axiom Inv_def_l1 : (forall x:angle. (ang_add(ang_inv(x), x) = ang_zero))

axiom Inv_def_r1 : (forall x:angle. (ang_add(x, ang_inv(x)) = ang_zero))

axiom Comm2 :
  (forall x:angle. forall y:angle. (ang_add(x, y) = ang_add(y, x)))

axiom Real_To_Ang_one :
  (forall phi:complex. (real_(phi) -> (real_to_ang(c_one) = ang_zero)))

axiom Real_To_Ang_inv :
  (forall phi:complex. (real_(phi) ->
  (ang_inv(real_to_ang(phi)) = real_to_ang(prefix_mndt(phi)))))

axiom Real_To_Ang_add :
  (forall phi:complex. forall phiqt:complex. (real_(phi) -> (real_(phiqt) ->
  (ang_add(real_to_ang(phi),
  real_to_ang(phiqt)) = real_to_ang(infix_pldt(phi, phiqt))))))

axiom meas_value :
  (forall phi:complex. (real_(phi) -> ((infix_lseqdt(c_zero, phi) and
  infix_lsdt(phi, c_one)) -> (ang_meas(real_to_ang(phi)) = phi))))

axiom Equal_angle :
  (forall o:angle. forall oqt:angle.
  ((exp(infix_asdt(infix_asdt(infix_asdt(im, pi), infix_pldt(c_one, c_one)),
  ang_meas(o))) = exp(infix_asdt(infix_asdt(infix_asdt(im, pi),
  infix_pldt(c_one, c_one)), ang_meas(oqt)))) -> (o = oqt)))

axiom Equal_angle1 :
  (forall o:angle. forall oqt:angle. ((o = oqt) ->
  (exp(infix_asdt(infix_asdt(infix_asdt(im, pi), infix_pldt(c_one, c_one)),
  ang_meas(o))) = exp(infix_asdt(infix_asdt(infix_asdt(im, pi),
  infix_pldt(c_one, c_one)), ang_meas(oqt))))))

axiom set_equal_angle_meas :
  (forall o:angle. forall oqt:angle. ((o = oqt) ->
  (ang_meas(o) = ang_meas(oqt))))

axiom get_equal_angle_meas :
  (forall o:angle. forall oqt:angle. ((ang_meas(o) = ang_meas(oqt)) ->
  (o = oqt)))

axiom meas_real_to_ang : (forall o:angle. (real_to_ang(ang_meas(o)) = o))

axiom meas_real_to_ang_rev : (forall o:angle. (o = real_to_ang(ang_meas(o))))

axiom ang_add_rev :
  (forall o:angle. forall oqt:angle. (ang_add(o, oqt) = ang_add(oqt, o)))

axiom real_to_ang_zero : (real_to_ang(c_zero) = ang_zero)

function ang_exp(o: angle) : complex =
  exp(infix_asdt(infix_asdt(infix_asdt(im, pi), infix_pldt(c_one, c_one)),
  ang_meas(o)))

axiom ang_expqtspec : (forall o:angle. (not (ang_exp(o) = c_zero)))

axiom set_equal_angle_exp :
  (forall o:angle. forall oqt:angle. ((o = oqt) ->
  (ang_exp(o) = ang_exp(oqt))))

axiom get_equal_angle_exp :
  (forall o:angle. forall oqt:angle. ((ang_exp(o) = ang_exp(oqt)) ->
  (o = oqt)))

axiom meas_value_plus_one :
  (forall phi:complex. (real_(phi) ->
  (exp(infix_asdt(infix_asdt(infix_asdt(im, pi), infix_pldt(c_one, c_one)),
  ang_meas(real_to_ang(phi)))) = exp(infix_asdt(infix_asdt(infix_asdt(im,
  pi), infix_pldt(c_one, c_one)), infix_pldt(ang_meas(real_to_ang(phi)),
  c_one))))))

axiom ang_exp_pi_over_four : (ang_exp(real_to_ang(infix_sldt(c_one,
  i_to_c(8)))) = infix_pldt(infix_sldt(square_rt(infix_pldt(c_one, c_one)),
  infix_pldt(c_one, c_one)), infix_asdt(im,
  infix_sldt(square_rt(infix_pldt(c_one, c_one)), infix_pldt(c_one,
  c_one)))))

axiom ang_exp_pi_over_two : (ang_exp(real_to_ang(infix_sldt(c_one,
  i_to_c(4)))) = im)

axiom ang_exp_pi : (ang_exp(real_to_ang(infix_sldt(c_one,
  i_to_c(2)))) = prefix_mndt(c_one))

axiom real_to_ang_c_one : (real_to_ang(c_one) = ang_zero)

axiom set_ang_meas_eq :
  (forall o:angle. forall oqt:angle. ((o = oqt) ->
  (ang_meas(o) = ang_meas(oqt))))

axiom get_ang_meas_eq :
  (forall o:angle. forall oqt:angle. ((ang_meas(o) = ang_meas(oqt)) ->
  (o = oqt)))

axiom ang_exp_zero : (ang_exp(ang_zero) = c_one)

axiom ang_exp_two_pi : (ang_exp(real_to_ang(i_to_c(1))) = c_one)

axiom ang_exp_c_one : (ang_exp(real_to_ang(c_one)) = c_one)

axiom ang_meas_add_inf_c_one :
  (forall o:angle. forall oqt:angle. (infix_lsdt(infix_pldt(ang_meas(o),
  ang_meas(oqt)), c_one) -> (ang_meas(ang_add(o,
  oqt)) = infix_pldt(ang_meas(o), ang_meas(oqt)))))

axiom set_ang_exp_eq :
  (forall o:angle. forall oqt:angle. ((o = oqt) ->
  (ang_exp(o) = ang_exp(oqt))))

axiom get_ang_exp_meas_eq :
  (forall o:angle. forall oqt:angle. ((ang_exp(o) = ang_exp(oqt)) ->
  (ang_meas(o) = ang_meas(oqt))))

axiom get_ang_exp_eq :
  (forall o:angle. forall oqt:angle. ((ang_exp(o) = ang_exp(oqt)) ->
  (o = oqt)))

axiom ang_meas_zero : (ang_meas(ang_zero) = c_zero)

axiom real_to_ang_add_one :
  (forall x:complex. (real_(x) -> (real_to_ang(infix_pldt(x,
  c_one)) = real_to_ang(x))))

logic truncate : real -> int

axiom Truncate_int : (forall i:int. (truncate(from_int(i)) = i))

axiom Truncate_down_pos :
  (forall x:real. ((0.0 <= x) -> (from_int(truncate(x)) <= x)))

axiom Truncate_down_pos1 :
  (forall x:real. ((0.0 <= x) -> (x <  from_int((truncate(x) + 1)))))

axiom Truncate_up_neg :
  (forall x:real. ((x <= 0.0) -> (from_int((truncate(x) - 1)) <  x)))

axiom Truncate_up_neg1 :
  (forall x:real. ((x <= 0.0) -> (x <= from_int(truncate(x)))))

axiom Real_of_truncate :
  (forall x:real. ((x - 1.0) <= from_int(truncate(x))))

axiom Real_of_truncate1 :
  (forall x:real. (from_int(truncate(x)) <= (x + 1.0)))

axiom Truncate_monotonic :
  (forall x:real. forall y:real. ((x <= y) -> (truncate(x) <= truncate(y))))

axiom Truncate_monotonic_int1 :
  (forall x:real. forall i:int. ((x <= from_int(i)) -> (truncate(x) <= i)))

axiom Truncate_monotonic_int2 :
  (forall x:real. forall i:int. ((from_int(i) <= x) -> (i <= truncate(x))))

logic floor : real -> int

logic ceil : real -> int

axiom Floor_int : (forall i:int. (floor(from_int(i)) = i))

axiom Ceil_int : (forall i:int. (ceil(from_int(i)) = i))

axiom Floor_down : (forall x:real. (from_int(floor(x)) <= x))

axiom Floor_down1 : (forall x:real. (x <  from_int((floor(x) + 1))))

axiom Ceil_up : (forall x:real. (from_int((ceil(x) - 1)) <  x))

axiom Ceil_up1 : (forall x:real. (x <= from_int(ceil(x))))

axiom Floor_monotonic :
  (forall x:real. forall y:real. ((x <= y) -> (floor(x) <= floor(y))))

axiom Ceil_monotonic :
  (forall x:real. forall y:real. ((x <= y) -> (ceil(x) <= ceil(y))))

logic int_part : complex -> complex

axiom int_partqtdef :
  (forall x:complex. (real_(x) ->
  (int_part(x) = i_to_c(floor(real_part(x))))))

axiom int_partqtspec : (forall x:complex. (real_(x) -> real_(int_part(x))))

axiom int_partqtspec1 :
  (forall x:complex. (real_(x) -> (exists i:int. (int_part(x) = i_to_c(i)))))

axiom int_partqtspec2 :
  (forall x:complex. (real_(x) -> infix_lseqdt(int_part(x), x)))

axiom int_partqtspec3 :
  (forall x:complex. (real_(x) -> infix_lsdt(x, infix_pldt(int_part(x),
  c_one))))

logic int_part_int : complex -> int

axiom int_part_intqtdef :
  (forall x:complex. (real_(x) -> (int_part_int(x) = floor(real_part(x)))))

axiom int_part_intqtspec :
  (forall x:complex. (real_(x) -> (i_to_c(int_part_int(x)) = int_part(x))))

axiom int_part_intqtspec1 :
  (forall x:complex. (real_(x) -> infix_lseqdt(i_to_c(int_part_int(x)), x)))

axiom int_part_intqtspec2 :
  (forall x:complex. (real_(x) -> infix_lsdt(x,
  infix_pldt(i_to_c(int_part_int(x)), c_one))))

logic dec_part : complex -> complex

axiom dec_partqtdef :
  (forall x:complex. (real_(x) -> (dec_part(x) = infix_mndt(x,
  int_part(x)))))

axiom dec_partqtspec : (forall x:complex. (real_(x) -> real_(dec_part(x))))

axiom dec_partqtspec1 :
  (forall x:complex. (real_(x) ->
  (exists i:int. (dec_part(x) = infix_mndt(x, i_to_c(i))))))

axiom dec_partqtspec2 :
  (forall x:complex. (real_(x) -> infix_lseqdt(c_zero, dec_part(x))))

axiom dec_partqtspec3 :
  (forall x:complex. (real_(x) -> infix_lsdt(dec_part(x), c_one)))

axiom dec_part_decomp :
  (forall x:complex. (real_(x) -> (x = infix_pldt(dec_part(x),
  int_part(x)))))

axiom dec_part_decomp_rev :
  (forall x:complex. (real_(x) -> (infix_pldt(dec_part(x),
  int_part(x)) = x)))

axiom dec_part_decomp_int :
  (forall x:complex. (real_(x) -> (x = infix_pldt(dec_part(x),
  i_to_c(int_part_int(x))))))

axiom dec_part_decomp_int_rev :
  (forall x:complex. (real_(x) -> (infix_pldt(dec_part(x),
  i_to_c(int_part_int(x))) = x)))

axiom ang_exp_add_b :
  (forall o:angle. forall oqt:angle. (infix_lsdt(infix_pldt(ang_meas(o),
  ang_meas(oqt)), c_one) -> (ang_exp(ang_add(o,
  oqt)) = infix_asdt(ang_exp(o), ang_exp(oqt)))))

axiom ang_exp_add_b_rev :
  (forall o:angle. forall oqt:angle. (infix_lsdt(infix_pldt(ang_meas(o),
  ang_meas(oqt)), c_one) -> (infix_asdt(ang_exp(o),
  ang_exp(oqt)) = ang_exp(ang_add(o, oqt)))))

axiom real_to_ang_add :
  (forall x:complex. forall xqt:complex. (real_(x) -> (real_(xqt) ->
  (real_to_ang(infix_pldt(x, xqt)) = ang_add(real_to_ang(x),
  real_to_ang(xqt))))))

axiom real_to_ang_add_rev :
  (forall x:complex. forall xqt:complex. (real_(x) -> (real_(xqt) ->
  (ang_add(real_to_ang(x), real_to_ang(xqt)) = real_to_ang(infix_pldt(x,
  xqt))))))

axiom ang_inv_add :
  (forall o:angle. forall oqt:angle. (ang_inv(ang_add(o,
  oqt)) = ang_add(ang_inv(o), ang_inv(oqt))))

axiom ang_inv_add_rev :
  (forall o:angle. forall oqt:angle. (ang_add(ang_inv(o),
  ang_inv(oqt)) = ang_inv(ang_add(o, oqt))))

axiom ang_exp_add_pre :
  (forall o:angle. forall oqt:angle. (infix_lseqdt(c_one,
  infix_pldt(ang_meas(o), ang_meas(oqt))) -> (infix_lseqdt(ang_meas(o),
  ang_meas(oqt)) -> (ang_exp(ang_add(o, oqt)) = infix_asdt(ang_exp(o),
  ang_exp(oqt))))))

axiom ang_exp_add :
  (forall o:angle. forall oqt:angle. (ang_exp(ang_add(o,
  oqt)) = infix_asdt(ang_exp(o), ang_exp(oqt))))

axiom ang_meas_add :
  (forall o:angle. forall oqt:angle. (real_to_ang(ang_meas(ang_add(o,
  oqt))) = ang_add(o, oqt)))

axiom ang_exp_add_rev :
  (forall o:angle. forall oqt:angle. (infix_asdt(ang_exp(o),
  ang_exp(oqt)) = ang_exp(ang_add(o, oqt))))

axiom real_to_ang_int_pre :
  (forall k:int. ((0 <= k) -> (ang_exp(real_to_ang(i_to_c(k))) = c_one)))

axiom real_to_ang_int :
  (forall k:int. (ang_exp(real_to_ang(i_to_c(k))) = c_one))

axiom real_to_ang_int_ : (forall k:int. (real_to_ang(i_to_c(k)) = ang_zero))

axiom real_to_ang_value_add :
  (forall phi:complex. forall k:int. ((infix_lseqdt(c_zero, phi) and
  infix_lsdt(phi, c_one)) -> (ang_exp(real_to_ang(infix_pldt(phi,
  i_to_c(k)))) = exp(infix_asdt(infix_asdt(infix_asdt(im, pi),
  infix_pldt(c_one, c_one)), phi)))))

axiom real_to_ang_value :
  (forall phi:complex. (real_(phi) ->
  (ang_exp(real_to_ang(phi)) = exp(infix_asdt(infix_asdt(infix_asdt(im, pi),
  infix_pldt(c_one, c_one)), phi)))))

axiom ang_exp_zero_ : (ang_exp(ang_zero) = c_one)

logic ang_mult_int_ : angle, int -> angle

axiom ang_mult_int_qtdef :
  (forall theta:angle. forall i:int. ((0 <= i) -> ((i = 0) ->
  (ang_mult_int_(theta, i) = ang_zero))))

axiom ang_mult_int_qtdef1 :
  (forall theta:angle. forall i:int. ((0 <= i) -> ((not (i = 0)) ->
  (ang_mult_int_(theta, i) = ang_add(ang_mult_int_(theta, (i - 1)),
  theta)))))

axiom ang_mult_int_qtspec :
  (forall theta:angle. forall i:int. ((0 <= i) -> (ang_mult_int_(theta,
  i) = real_to_ang(infix_asdt(ang_meas(theta), i_to_c(i))))))

function ang_mult_int(theta: angle, i: int) : angle =
  (if (0 <= i) then ang_mult_int_(theta, i) else ang_inv(ang_mult_int_(theta,
  (-i))))

axiom ang_mult_int_to_real_to_ang :
  (forall theta:angle. forall i:int. (ang_mult_int(theta,
  i) = real_to_ang(infix_asdt(ang_meas(theta), i_to_c(i)))))

axiom ang_mult_int_eq :
  (forall i:int. forall iqt:int. forall theta:angle. forall thetaqt:angle.
  ((i = iqt) -> ((theta = thetaqt) -> (ang_mult_int(theta,
  i) = ang_mult_int(thetaqt, iqt)))))

axiom ang_mult_int_plus_one_pos :
  (forall theta:angle. forall i:int. ((0 <  i) -> (ang_mult_int(theta,
  i) = ang_add(ang_mult_int(theta, (i - 1)), theta))))

axiom ang_mult_int_inv :
  (forall theta:angle. forall i:int. ((i <  0) -> (ang_mult_int(theta,
  i) = ang_inv(ang_mult_int(theta, (-i))))))

axiom real_to_ang_eq :
  (forall phi:complex. forall phiqt:complex. (real_(phi) -> ((phi = phiqt) ->
  (real_to_ang(phi) = real_to_ang(phiqt)))))

axiom set_equal_angle_by_exp :
  (forall o:angle. forall oqt:angle. ((ang_exp(o) = ang_exp(oqt)) ->
  (o = oqt)))

axiom real_to_ang_int_dec_part :
  (forall x:complex. (real_(x) ->
  (real_to_ang(x) = real_to_ang(dec_part(x)))))

axiom set_equal_exp_by_ang :
  (forall o:angle. forall oqt:angle. ((o = oqt) ->
  (ang_exp(o) = ang_exp(oqt))))

axiom div_plus_one :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <  j) ->
  (((i / j) * j) <= i))))

axiom div_plus_one1 :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <  j) ->
  (i <  (((i / j) + 1) * j)))))

axiom mod_is_inf : (forall i:int. forall j:int. ((0 <  j) -> ((i % j) <  j)))

axiom zero_add :
  (forall a1:int. forall a2:int. ((a1 = 0) -> ((a1 + a2) = a2)))

axiom add_zero :
  (forall a1:int. forall a2:int. ((a2 = 0) -> ((a1 + a2) = a1)))

axiom one_mult :
  (forall a1:int. forall a2:int. ((a1 = 1) -> ((a1 * a2) = a2)))

axiom mult_one :
  (forall a1:int. forall a2:int. ((a2 = 1) -> ((a1 * a2) = a1)))

axiom add_eq :
  (forall a1:int. forall a2:int. forall b1:int. forall b2:int. ((a1 = a2) ->
  ((b1 = b2) -> ((a1 + b1) = (a2 + b2)))))

axiom mult_eq :
  (forall a1:int. forall a2:int. forall b1:int. forall b2:int. ((a1 = a2) ->
  ((b1 = b2) -> ((a1 * b1) = (a2 * b2)))))

axiom add_eq_inv :
  (forall a1:int. forall a2:int. forall b1:int. forall b2:int. ((a1 = a2) ->
  ((b1 = b2) -> ((a1 + b1) = (b2 + a2)))))

axiom mult_eq_inv :
  (forall a1:int. forall a2:int. forall b1:int. forall b2:int. ((a1 = a2) ->
  ((b1 = b2) -> ((a1 * b1) = (b2 * a2)))))

axiom bound_eq :
  (forall i:int. forall j:int. (((0 <= i) and (i <  j)) -> (i = (i % j))))

axiom bound_eq_rev :
  (forall i:int. forall j:int. (((0 <= i) and (i <  j)) -> ((i % j) = i)))

axiom unicity_div_mod :
  (forall i:int. forall j:int. forall q:int. forall r:int. ((0 <  j) ->
  ((i = ((q * j) + r)) -> (((0 <= r) and (r <  j)) -> (q = (i / j))))))

axiom unicity_div_mod1 :
  (forall i:int. forall j:int. forall q:int. forall r:int. ((0 <  j) ->
  ((i = ((q * j) + r)) -> (((0 <= r) and (r <  j)) -> (r = (i % j))))))

axiom get_div :
  (forall j:int. forall q:int. forall r:int. ((0 <  j) -> (((0 <= r) and
  (r <  j)) -> ((((q * j) + r) / j) = q))))

axiom get_mod :
  (forall j:int. forall q:int. forall r:int. ((0 <  j) -> (((0 <= r) and
  (r <  j)) -> ((((q * j) + r) % j) = r))))

axiom positive_div :
  (forall i:int. forall j:int. (((0 <  j) and (j <  i)) -> (0 <  (i / j))))

axiom div_mod_sim_bound :
  (forall d:int. forall m:int. forall q:int. forall r:int. (((0 <= d) and
  (d <  r)) -> (((0 <= m) and (m <  q)) -> (0 <= ((d * q) + m)))))

axiom div_mod_sim_bound1 :
  (forall d:int. forall m:int. forall q:int. forall r:int. (((0 <= d) and
  (d <  r)) -> (((0 <= m) and (m <  q)) -> (((d * q) + m) <  (r * q)))))

axiom div_mod_sim_bound_gen_r :
  (forall d:int. forall q:int. forall r:int. (((0 <= d) and (d <  r)) ->
  (forall m:int. (((0 <= m) and (m <  q)) -> (0 <= ((d * q) + m))))))

axiom div_mod_sim_bound_gen_r1 :
  (forall d:int. forall q:int. forall r:int. (((0 <= d) and (d <  r)) ->
  (forall m:int. (((0 <= m) and (m <  q)) -> (((d * q) + m) <  (r * q))))))

axiom unicity_div_gen :
  (forall j:int. forall q:int. ((0 <= q) -> ((0 <  j) ->
  (forall i:int. ((0 <= i) -> (((0 <= (i - (q * j))) and
  ((i - (q * j)) <  j)) -> (q = (i / j))))))))

axiom unicity_div_gen1 :
  (forall j:int. forall q:int. ((0 <= q) -> ((0 <  j) ->
  (forall i:int. ((0 <= i) -> (((0 <= (i - (q * j))) and
  ((i - (q * j)) <  j)) -> ((i - (j * q)) = (i % j))))))))

axiom bound_mod : (forall i:int. forall j:int. ((0 <  j) -> (0 <= (i % j))))

axiom bound_mod1 : (forall i:int. forall j:int. ((0 <  j) -> ((i % j) <  j)))

axiom mod_eq :
  (forall a:int. forall b:int. forall d:int. ((a = b) ->
  ((a % d) = (b % d))))

axiom e_div_eq :
  (forall a:int. forall b:int. forall d:int. ((a = b) ->
  ((a / d) = (b / d))))

axiom decomp :
  (forall i:int. forall j:int. ((not (0 = j)) ->
  (i = ((j * (i / j)) + (i % j)))))

axiom div_mod_eq :
  (forall i:int. forall j:int. forall q:int. ((0 <= i) -> ((0 <= j) ->
  ((0 <  q) -> (((i / q) = (j / q)) -> (((i % q) = (j % q)) -> (i = j)))))))

axiom mod_zero :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <  j) -> (((i % j) = 0) ->
  (i = (j * (i / j)))))))

axiom div_plus_quotient :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <  j) ->
  (((i + j) / j) = ((i / j) + 1)))))

axiom div_plus_fact_gen_div :
  (forall i:int. forall j:int. forall k:int. ((0 <  j) ->
  (((i + (k * j)) / j) = ((i / j) + k))))

axiom mod_plus_fact_gen_mod :
  (forall i:int. forall j:int. forall k:int. ((0 <  j) ->
  ((((k * j) + i) % j) = (i % j))))

axiom mod_plus_fact_gen_mod_left :
  (forall i:int. forall j:int. forall k:int. ((0 <  j) ->
  ((((j * k) + i) % j) = (i % j))))

axiom bound_div :
  (forall i:int. forall q:int. forall f:int. ((0 <= i) -> ((0 <= q) ->
  ((0 <= f) -> ((i <  (f * q)) -> (0 <= (i / q)))))))

axiom bound_div1 :
  (forall i:int. forall q:int. forall f:int. ((0 <= i) -> ((0 <= q) ->
  ((0 <= f) -> ((i <  (f * q)) -> (0 <= ((i / q) * q)))))))

axiom bound_div2 :
  (forall i:int. forall q:int. forall f:int. ((0 <= i) -> ((0 <= q) ->
  ((0 <= f) -> ((i <  (f * q)) -> (((i / q) * q) <= i))))))

axiom bound_div3 :
  (forall i:int. forall q:int. forall f:int. ((0 <= i) -> ((0 <= q) ->
  ((0 <= f) -> ((i <  (f * q)) -> (i <  (q * ((i / q) + 1))))))))

axiom bound_div4 :
  (forall i:int. forall q:int. forall f:int. ((0 <= i) -> ((0 <= q) ->
  ((0 <= f) -> ((i <  (f * q)) -> ((i / q) <  f))))))

axiom mod_upper_bound :
  (forall i:int. forall q:int. ((0 <  i) -> ((i = q) -> ((i % q) = 0))))

axiom bound_div_gen :
  (forall q:int. forall f:int. ((0 <  q) -> ((0 <= f) ->
  (forall i:int. (((0 <= i) and (i <  (q * f))) -> ((i / q) <  f))))))

axiom mod_invariant :
  (forall i:int. forall q:int. forall f:int. ((0 <= i) -> ((0 <  q) ->
  ((0 <  f) ->
  ((((q * (f * (i / (q * f)))) + (i % (q * f))) % q) = ((i % (q * f)) % q))))))

axiom mod_inf :
  (forall i:int. forall q:int. (((0 <= i) and (i <  q)) -> ((i % q) = i)))

axiom add_mod :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  ((((a % c) + (b % c)) % c) = ((a + b) % c))))

axiom add_mod_eq :
  (forall a:int. forall b:int. forall c:int. forall d:int. forall n:int.
  ((0 <  n) -> (((a % n) = (c % n)) -> (((b % n) = (d % n)) ->
  (((a + b) % n) = ((c + d) % n))))))

axiom add_mod_left :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  ((((a % c) + b) % c) = ((a + b) % c))))

axiom simpl_add_mod_left :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) -> (((a % c) = 0) ->
  (((a + b) % c) = (b % c)))))

axiom add_mod_right :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  (((a + (b % c)) % c) = ((a + b) % c))))

axiom mod_mod_left :
  (forall i:int. forall j:int. forall f:int. ((0 <  j) -> ((0 <  f) ->
  (((i % (f * j)) % j) = (i % j)))))

axiom mult_mod :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  ((((a % c) * (b % c)) % c) = ((a * b) % c))))

axiom mod_mod_mult :
  (forall a:int. forall b:int. forall c:int. ((0 <  b) ->
  ((((a % b) * (c % b)) % b) = ((a * c) % b))))

axiom mod_mod_mult_rev :
  (forall a:int. forall b:int. forall c:int. ((0 <  b) ->
  (((a * c) % b) = (((a % b) * (c % b)) % b))))

axiom mod_mod_i :
  (forall i:int. forall j:int. ((0 <  j) -> (((i % j) % j) = (i % j))))

axiom binary_prod :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <  j) ->
  ((((i % 2) * (j % 2)) % 2) = ((i * j) % 2)))))

axiom mod_minus :
  (forall a:int. forall b:int. forall c:int. ((0 <  b) -> (((a % b) = c) ->
  (((-a) % b) = ((-c) % b)))))

axiom mult_mod_left :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  ((((a % c) * b) % c) = ((a * b) % c))))

axiom mult_mod_right :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  (((a * (b % c)) % c) = ((a * b) % c))))

axiom mod_mod_right :
  (forall i:int. forall j:int. forall f:int. ((0 <= i) -> ((0 <  j) ->
  ((0 <  f) -> (((i % (j * f)) % j) = (i % j))))))

axiom mod_mod_rev :
  (forall i:int. forall j:int. forall f:int. ((0 <= i) -> ((0 <  j) ->
  ((0 <  f) -> ((i % j) = ((i % (j * f)) % j))))))

axiom mod_mod_rev1 :
  (forall i:int. forall j:int. forall f:int. ((0 <= i) -> ((0 <  j) ->
  ((0 <  f) -> ((i % j) = ((i % (f * j)) % j))))))

axiom mod_mod_plus :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <  j) ->
  ((i % j) = ((i % (j + j)) % j)))))

axiom mod_mod_add_left :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  ((((a % c) + b) % c) = ((a + b) % c))))

axiom mod_mod_add_right :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  (((a + (b % c)) % c) = ((a + b) % c))))

axiom mod_mod_add_left_rev :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  (((a + b) % c) = (((a % c) + b) % c))))

axiom mod_mod_add_right_rev :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) ->
  (((a + b) % c) = ((a + (b % c)) % c))))

axiom mult_assoc1 :
  (forall i:int. forall q:int. forall f:int. ((0 <= i) -> ((0 <  q) ->
  ((0 <  f) -> ((q * (f * (i / (q * f)))) = ((q * f) * (i / (q * f))))))))

axiom div_div1 :
  (forall i:int. forall j:int. forall k:int. ((0 <= i) -> ((0 <  j) ->
  ((0 <  k) -> (((i / k) / j) = (i / (k * j)))))))

axiom div_div2 :
  (forall i:int. forall j:int. forall k:int. ((0 <= i) -> ((0 <  j) ->
  ((0 <  k) -> (((i / k) / j) = (i / (j * k)))))))

axiom compat_order_div :
  (forall i:int. forall iqt:int. forall j:int. (((0 <= i) and (i <= iqt)) ->
  ((0 <  j) -> ((i / j) <= (iqt / j)))))

axiom mod_div :
  (forall i:int. forall j:int. forall k:int. ((0 <= i) -> ((0 <  j) ->
  ((0 <  k) -> (((i % (j * k)) / j) = ((i / j) % k))))))

axiom inf_mul :
  (forall ia:int. forall ib:int. forall a:int. forall b:int. (((0 <= ia) and
  (ia <  a)) -> (((0 <= ib) and (ib <  b)) -> (((a * ib) + ia) <  (a * b)))))

axiom inf_mul1 :
  (forall ia:int. forall ib:int. forall a:int. forall b:int. (((0 <= ia) and
  (ia <  a)) -> (((0 <= ib) and (ib <  b)) -> (((ib * a) + ia) <  (b * a)))))

axiom inf_mul_gen :
  (forall n:int. forall v:int. forall p:int. (((0 <= p) and (p <  v)) ->
  (forall k:int. (((0 <= k) and (k <  n)) -> (((k * v) + p) <  (n * v))))))

axiom inf_mul_gen_b :
  (forall n:int. forall v:int. forall p:int. (((0 <= p) and (p <  n)) ->
  (forall k:int. (((0 <= k) and (k <  v)) -> (((p * v) + k) <  (n * v))))))

axiom inf_mul_comm :
  (forall i:int. forall bi:int. forall quot:int. forall rest:int.
  (((0 <= i) and (i <  bi)) -> ((0 <  rest) -> ((0 <  quot) ->
  ((bi = (quot * rest)) -> ((i % rest) <  rest))))))

axiom indic_div_mod :
  (forall i:int. forall j:int. forall q:int. ((0 <= i) -> ((0 <= j) ->
  ((0 <  q) -> (indic(i, j) = infix_asdt(indic((i % q), (j % q)),
  indic((i / q), (j / q))))))))

axiom indic_div_mod_gen :
  (forall q:int. ((0 <  q) ->
  (forall i:int. forall j:int. (((0 <= i) and (0 <= j)) -> (indic(i,
  j) = infix_asdt(indic((i % q), (j % q)), indic((i / q), (j / q))))))))

axiom set_inf : true

axiom set_infeq : true

axiom bounded_cycle :
  (forall a:int. forall b:int. forall c:int. forall d:int. ((0 <= a) ->
  ((0 <  b) -> (((0 <= d) and (d <  b)) -> ((0 <  c) ->
  ((((a * b) + d) / (b * c)) = (a / c)))))))

axiom div_mod_minus :
  (forall a:int. forall b:int. ((0 <  b) -> ((0 <  a) ->
  ((not ((a % b) = 0)) -> (((-a) % b) = (b - (a % b)))))))

logic fc105 : ('a,int) farray, int -> ('a,int) farray

axiom fcqtdef105 :
  (forall f:('a,int) farray. forall b:int. forall i:'a. ((fc105(f,
  b)[i]) = ((f[i]) % b)))

axiom mod_mod_iproduct :
  (forall s:'a set. forall f:('a,int) farray. forall b:int. ((0 <  b) ->
  ((iproduct(s, fc105(f, b)) % b) = (iproduct(s, f) % b))))

axiom ind_isum_mod_eq :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall j:int. forall n:int. ((0 <  n) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> (((f[k]) % n) = ((g[k]) % n)))) ->
  ((ind_isum(f, i, j) % n) = (ind_isum(g, i, j) % n)))))

logic int_to_ang : int, int -> angle

axiom int_to_angqtdef :
  (forall k:int. forall n:int. ((0 <= n) -> (int_to_ang(k,
  n) = real_to_ang(infix_sldt(i_to_c(k), i_to_c(power(2, n)))))))

axiom int_to_angqtspec :
  (forall k:int. forall n:int. ((0 <= n) -> (int_to_ang(k,
  n) = real_to_ang(infix_sldt(i_to_c((k % power(2, n))), i_to_c(power(2,
  n)))))))

axiom int_to_angqtspec1 :
  (forall k:int. forall n:int. ((0 <= n) -> (((0 <= k) and (k <  power(2,
  n))) -> (ang_meas(int_to_ang(k, n)) = infix_sldt(i_to_c(k), i_to_c(power(2,
  n)))))))

function infix_sldtsl(k: int, n: int) : angle =
  (if (0 <= n) then int_to_ang(k, n) else int_to_ang((-k), (-n)))

axiom infix_sldtslqtspec :
  (forall k:int. forall n:int. ((0 <= n) -> (infix_sldtsl(k,
  n) = real_to_ang(infix_sldt(i_to_c((k % power(2, n))), i_to_c(power(2,
  n)))))))

axiom infix_sldtslqtspec1 :
  (forall k:int. forall n:int. ((0 <= n) -> (((0 <= k) and (k <  power(2,
  n))) -> (ang_meas(infix_sldtsl(k, n)) = infix_sldt(i_to_c(k),
  i_to_c(power(2, n)))))))

axiom infix_sldtslqtspec2 :
  (forall k:int. forall n:int. ((n <  0) -> (infix_sldtsl(k,
  n) = real_to_ang(infix_sldt(i_to_c(((-k) % power(2, (-n)))),
  i_to_c(power(2, (-n))))))))

axiom infix_sldtslqtspec3 :
  (forall k:int. forall n:int. ((n <  0) -> (((0 <= k) and (k <  power(2,
  n))) -> (ang_meas(infix_sldtsl(k, n)) = infix_sldt(i_to_c((-k)),
  i_to_c(power(2, (-n))))))))

axiom int_to_ang_pos :
  (forall k:int. forall n:int. ((0 <= n) -> (infix_sldtsl(k,
  n) = real_to_ang(infix_sldt(i_to_c(k), i_to_c(power(2, n)))))))

axiom int_to_ang_real_mod :
  (forall k:int. forall n:int. ((0 <= n) -> (infix_sldtsl(k,
  n) = real_to_ang(infix_sldt(i_to_c((k % power(2, n))), i_to_c(power(2,
  n)))))))

axiom real_to_ang_inv :
  (forall x:complex. (real_(x) ->
  (real_to_ang(prefix_mndt(x)) = ang_inv(real_to_ang(x)))))

axiom real_to_ang_inv_rev :
  (forall x:complex. (real_(x) ->
  (ang_inv(real_to_ang(x)) = real_to_ang(prefix_mndt(x)))))

axiom involutive_ang_inv : (forall o:angle. (ang_inv(ang_inv(o)) = o))

axiom Real_To_Ang_inv_add :
  (forall phi:complex. (real_(phi) -> (ang_add(real_to_ang(phi),
  real_to_ang(prefix_mndt(phi))) = ang_zero)))

axiom Real_To_Ang_up :
  (forall phi:complex. (real_(phi) ->
  (real_to_ang(phi) = real_to_ang(infix_pldt(c_one, phi)))))

axiom real_To_Ang_cyclic_pos :
  (forall phi:complex. forall k:int. (real_(phi) -> ((0 <= k) ->
  (real_to_ang(phi) = real_to_ang(infix_pldt(i_to_c(k), phi))))))

axiom real_To_Ang_cyclic_neg :
  (forall phi:complex. forall k:int. (real_(phi) -> ((0 <= k) ->
  (real_to_ang(infix_mndt(i_to_c(k),
  phi)) = real_to_ang(prefix_mndt(phi))))))

axiom real_to_ang_equiv :
  (forall x:complex. forall xqt:complex. (real_(x) ->
  ((exists k:int. (xqt = infix_pldt(x, i_to_c(k)))) ->
  (real_to_ang(x) = real_to_ang(xqt)))))

axiom Real_zero_n : (real_to_ang(c_zero) = ang_zero)

axiom real_ang_mult_pos :
  (forall phi:complex. forall i:int. (real_(phi) -> ((0 <= i) ->
  (ang_mult_int(real_to_ang(phi), i) = real_to_ang(infix_asdt(phi,
  i_to_c(i)))))))

axiom real_ang_mult :
  (forall phi:complex. forall i:int. (real_(phi) ->
  (ang_mult_int(real_to_ang(phi), i) = real_to_ang(infix_asdt(phi,
  i_to_c(i))))))

axiom real_to_ang_down_cucles :
  (forall phi:complex. forall x:complex. (real_(phi) -> ((x = c_one) ->
  (real_to_ang(infix_mndt(phi, x)) = real_to_ang(phi)))))

function odd(n: int) : bool = (if ((n % 2) = 1) then true else false)

axiom oddqtspec :
  (forall n:int. ((odd(n) = true) -> (n = ((2 * (n / 2)) + 1))))

axiom oddqtspec1 : (forall n:int. ((odd(n) = false) -> (n = (2 * (n / 2)))))

function even(n: int) : bool = (if ((n % 2) = 0) then true else false)

axiom evenqtspec :
  (forall n:int. ((even(n) = true) -> (not (odd(n) = true))))

axiom evenqtspec1 :
  (forall n:int. ((not (odd(n) = true)) -> (even(n) = true)))

axiom even_to_mod : (forall n:int. ((even(n) = true) -> ((n % 2) = 0)))

axiom even_minus_one :
  (forall n:int. ((0 <  n) -> ((even(n) = true) -> (odd((n - 1)) = true))))

axiom odd_minus_one :
  (forall n:int. ((0 <  n) -> ((odd(n) = true) -> (even((n - 1)) = true))))

axiom even_opp : (forall n:int. ((even(n) = true) -> (even((-n)) = true)))

axiom odd_opp : (forall n:int. ((odd(n) = true) -> (odd((-n)) = true)))

axiom odd_to_mod : (forall n:int. ((odd(n) = true) -> ((n % 2) = 1)))

axiom even_or_odd : (forall n:int. ((even(n) = true) or (odd(n) = true)))

axiom cpower_minus_c_one :
  (forall n:int. ((0 <= n) -> ((even(n) = true) ->
  (cpower(prefix_mndt(c_one), n) = c_one))))

axiom cpower_minus_c_one1 :
  (forall n:int. ((0 <= n) -> ((odd(n) = true) -> (cpower(prefix_mndt(c_one),
  n) = prefix_mndt(c_one)))))

axiom cpower_minus_c_one_even :
  (forall n:int. ((0 <= n) -> ((even(n) = true) ->
  (cpower(prefix_mndt(c_one), n) = c_one))))

axiom cpower_minus_c_one_odd :
  (forall n:int. ((0 <= n) -> ((odd(n) = true) -> (cpower(prefix_mndt(c_one),
  n) = prefix_mndt(c_one)))))

logic fc106 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef106 :
  (forall f:(int,int) farray. forall a:int. forall i:int. ((fc106(f,
  a)[i]) = (a * (f[i]))))

axiom iproduct_extract_const :
  (forall s:int set. forall f:(int,int) farray. forall a:int. (iproduct(s,
  fc106(f, a)) = (power(a, cardinal(s)) * iproduct(s, f))))

axiom not_null_powers_squarert_two :
  (forall i:int. ((0 <= i) -> (not (cpower(square_rt(infix_pldt(c_one,
  c_one)), i) = c_zero))))

axiom real_pos_coeff : real_(infix_sldt(c_one, square_rt(infix_pldt(c_one,
  c_one))))

axiom coeffs : (infix_sldt(prefix_mndt(c_one), square_rt(infix_pldt(c_one,
  c_one))) = prefix_mndt(infix_sldt(c_one, square_rt(infix_pldt(c_one,
  c_one)))))

logic mop : int -> complex

axiom mopqtdef :
  (forall i:int. ((0 <= i) -> (mop(i) = cpower(prefix_mndt(c_one), i))))

axiom minus_one_power_values :
  (forall i:int. ((0 <= i) -> ((even(i) = true) -> (mop(i) = c_one))))

axiom minus_one_power_values1 :
  (forall i:int. ((0 <= i) -> ((odd(i) = true) ->
  (mop(i) = prefix_mndt(c_one)))))

axiom factors_mop :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <= j) ->
  (mop((i + j)) = infix_asdt(mop(i), mop(j))))))

axiom factors_mop_rev :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <= j) -> (infix_asdt(mop(i),
  mop(j)) = mop((i + j))))))

logic pow_inv_sqrt_2 : int -> complex

axiom pow_inv_sqrt_2qtdef :
  (forall i:int. ((0 <= i) -> (pow_inv_sqrt_2(i) = cpower(infix_sldt(c_one,
  square_rt(infix_pldt(c_one, c_one))), i))))

axiom pow_inv_sqrt_2qtspec :
  (forall i:int. ((0 <= i) -> real_(pow_inv_sqrt_2(i))))

axiom pow_inv_sqrt_2qtspec1 :
  (forall i:int. ((0 <= i) -> (pow_inv_sqrt_2(i) = infix_sldt(c_one,
  square_rt(i_to_c(power(2, i)))))))

axiom pow_inv_sqrt_2_add :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <= j) ->
  (pow_inv_sqrt_2((i + j)) = infix_asdt(pow_inv_sqrt_2(i),
  pow_inv_sqrt_2(j))))))

logic pow_inv_2 : int -> complex

axiom pow_inv_2qtdef :
  (forall i:int. ((0 <= i) -> (pow_inv_2(i) = infix_sldt(c_one,
  i_to_c(power(2, i))))))

axiom pow_inv_2qtspec : (forall i:int. ((0 <= i) -> real_(pow_inv_2(i))))

axiom pow_inv_2qtspec1 :
  (forall i:int. ((0 <= i) -> infix_gtdt(pow_inv_2(i), c_zero)))

axiom pow_inv_2qtspec2 :
  (forall i:int. ((0 <= i) -> (pow_inv_2(i) = pow_inv_sqrt_2((2 * i)))))

axiom pow_inv_2qtspec3 :
  (forall i:int. ((0 <= i) -> (pow_inv_2(i) = infix_asdt(pow_inv_sqrt_2(i),
  pow_inv_sqrt_2(i)))))

axiom pow_inv_2_leq_c_one :
  (forall i:int. ((0 <= i) -> infix_lseqdt(pow_inv_2(i), c_one)))

axiom pow_inv_2_inf_c_one :
  (forall i:int. ((1 <= i) -> infix_lsdt(pow_inv_2(i), c_one)))

axiom pow_inv_sqrt_2_leq_c_one :
  (forall i:int. ((0 <= i) -> infix_lseqdt(pow_inv_sqrt_2(i), c_one)))

axiom pow_inv_2_sqrt_inf_c_one :
  (forall i:int. ((1 <= i) -> infix_lsdt(pow_inv_sqrt_2(i), c_one)))

axiom cpower_pow_inv_2 :
  (forall i:int. forall k:int. ((1 <= i) -> ((1 <= k) ->
  (cpower(pow_inv_2(i), k) = pow_inv_2((i * k))))))

axiom cpower_pow_inv_sqrt_2 :
  (forall i:int. forall k:int. ((1 <= i) -> ((1 <= k) ->
  (cpower(pow_inv_sqrt_2(i), k) = pow_inv_sqrt_2((i * k))))))

axiom cpower_2_pow_inv_sqrt_2 :
  (forall i:int. ((1 <= i) -> (cpower(pow_inv_sqrt_2(i), 2) = pow_inv_2(i))))

axiom pow_inv_2_subst :
  (forall i:int. forall j:int. (((0 <= i) and (i <= j)) ->
  (infix_asdt(pow_inv_2(i), cpower(infix_pldt(c_one, c_one),
  j)) = cpower(infix_pldt(c_one, c_one), (j - i)))))

axiom pow_inv_2_ :
  (forall i:int. ((0 <= i) -> (pow_inv_2(i) = infix_sldt(c_one,
  i_to_c(power(2, i))))))

axiom pow_inv_sqrt_2_2_add : (infix_pldt(pow_inv_sqrt_2(1),
  pow_inv_sqrt_2(1)) = square_rt(infix_pldt(c_one, c_one)))

axiom pow_inv_2_cpower :
  (forall i:int. ((0 <= i) -> (pow_inv_2(i) = infix_sldt(c_one,
  cpower(infix_pldt(c_one, c_one), i)))))

type 'a matrix

logic elts : 'a matrix -> (int,(int,'a) farray) farray

logic rows : 'a matrix -> int

logic columns : 'a matrix -> int

axiom matrixqtinvariant :
  (forall self:'a matrix [columns(self)| rows(self)]. (0 <  rows(self)))

axiom matrixqtinvariant1 :
  (forall self:'a matrix [columns(self)| rows(self)]. (0 <  columns(self)))

predicate valid_index(a: 'a1 matrix, r: int, c: int) = (((0 <= r) and
  (r <  rows(a))) and ((0 <= c) and (c <  columns(a))))

predicate equal_size(a: 'a1 matrix, b: 'a1 matrix) = ((rows(a) = rows(b)) and
  (columns(a) = columns(b)))

function get(a: 'a1 matrix, r: int, c: int) : 'a1 = ((elts(a)[r])[c])

axiom getqtspec :
  (forall a:'a1 matrix. forall r:int. forall c:int. (get(a, r,
  c) = ((elts(a)[r])[c])))

axiom elts_eq :
  (forall a:'a1 matrix. forall b:'a1 matrix. ((a = b) ->
  (elts(a) = elts(b))))

axiom elts_inst_eq :
  (forall a:'a1 matrix. forall b:'a1 matrix. forall i:int. forall j:int.
  ((a = b) -> (((0 <= i) and (i <  rows(a))) -> (((0 <= j) and
  (j <  columns(a))) -> (((elts(a)[i])[j]) = ((elts(b)[i])[j]))))))

logic make : int, int, 'a -> 'a matrix

axiom makeqtspec :
  (forall r:int. forall c:int. forall v:'a. (((0 <  r) and (0 <  c)) ->
  (rows(make(r, c, v)) = r)))

axiom makeqtspec1 :
  (forall r:int. forall c:int. forall v:'a. (((0 <  r) and (0 <  c)) ->
  (columns(make(r, c, v)) = c)))

axiom makeqtspec2 :
  (forall r:int. forall c:int. forall v:'a. (((0 <  r) and (0 <  c)) ->
  (forall i:int. forall j:int. ((((0 <= i) and (i <  r)) and ((0 <= j) and
  (j <  c))) -> (get(make(r, c, v), i, j) = v)))))

axiom equality :
  (forall m:'a matrix. forall n:'a matrix. ((m = n) -> (rows(m) = rows(n))))

axiom equality1 :
  (forall m:'a matrix. forall n:'a matrix. ((m = n) ->
  (columns(m) = columns(n))))

axiom equality2 :
  (forall m:'a matrix. forall n:'a matrix. ((m = n) ->
  (forall i:int. forall j:int. (valid_index(m, i, j) -> (get(m, i,
  j) = get(n, i, j))))))

axiom equality3 :
  (forall m:'a matrix. forall n:'a matrix. ((((rows(m) = rows(n)) and
  (columns(m) = columns(n))) and
  (forall i:int. forall j:int. (valid_index(m, i, j) -> (get(m, i,
  j) = get(n, i, j))))) -> (m = n)))

axiom make_value :
  (forall r:int. forall c:int. forall i:int. forall j:int. forall v:'a.
  (((0 <  r) and (0 <  c)) -> (((0 <= i) and (i <  r)) -> (((0 <= j) and
  (j <  c)) -> (get(make(r, c, v), i, j) = v)))))

function mat_indices(m: 'a matrix) : (int, int) tuple2 set =
  cartesian_product(to_fset(0, rows(m)), to_fset(0, columns(m)))

axiom mat_indicesqtspec :
  (forall m:'a matrix.
  (forall o:(int, int) tuple2. (mem(o, mat_indices(m)) -> (0 <= fir(o)))))

axiom mat_indicesqtspec1 :
  (forall m:'a matrix.
  (forall o:(int, int) tuple2. (mem(o, mat_indices(m)) ->
  (fir(o) <  rows(m)))))

axiom mat_indicesqtspec2 :
  (forall m:'a matrix.
  (forall o:(int, int) tuple2. (mem(o, mat_indices(m)) -> (0 <= sec(o)))))

axiom mat_indicesqtspec3 :
  (forall m:'a matrix.
  (forall o:(int, int) tuple2. (mem(o, mat_indices(m)) ->
  (sec(o) <  columns(m)))))

axiom mat_indicesqtspec4 :
  (forall m:'a matrix.
  (forall o:(int, int) tuple2. (((0 <= fir(o)) and (fir(o) <  rows(m))) ->
  (((0 <= sec(o)) and (sec(o) <  columns(m))) -> mem(o, mat_indices(m))))))

axiom mat_indicesqtspec5 :
  (forall m:'a matrix.
  (forall i:int. forall j:int. (valid_index(m, i, j) -> mem({ Tuple2_proj_1 =
  i; Tuple2_proj_2 = j }, mat_indices(m)))))

axiom mat_indicesqtspec6 :
  (forall m:'a matrix.
  (forall i:int. forall j:int. (mem({ Tuple2_proj_1 = i; Tuple2_proj_2 = j },
  mat_indices(m)) -> valid_index(m, i, j))))

logic set1 : 'a matrix, int, int, 'a -> 'a matrix

axiom setqtspec :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall v:'a1.
  (valid_index(a, r, c) -> (rows(set1(a, r, c, v)) = rows(a))))

axiom setqtspec1 :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall v:'a1.
  (valid_index(a, r, c) -> (columns(set1(a, r, c, v)) = columns(a))))

axiom setqtspec2 :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall v:'a1.
  (valid_index(a, r, c) ->
  (forall i:int. forall j:int. (valid_index(a, i, j) -> (get(set1(a, r, c,
  v), i, j) = (if ((i = r) and (j = c)) then v else get(a, i, j)))))))

axiom setqtspec3 :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall v:'a1.
  (valid_index(a, r, c) -> (get(set1(a, r, c, v), r, c) = v)))

axiom setqtspec4 :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall v:'a1.
  (valid_index(a, r, c) ->
  (forall i:int. forall j:int. (valid_index(set1(a, r, c, v), i, j) ->
  ((not (i = r)) -> (get(set1(a, r, c, v), i, j) = get(a, i, j)))))))

axiom setqtspec5 :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall v:'a1.
  (valid_index(a, r, c) ->
  (forall i:int. forall j:int. (valid_index(set1(a, r, c, v), i, j) ->
  ((not (j = c)) -> (get(set1(a, r, c, v), i, j) = get(a, i, j)))))))

axiom set_valid_index :
  (forall a:'a1 matrix. forall i:int. forall j:int. (((0 <= i) and
  (i <  rows(a))) -> (((0 <= j) and (j <  columns(a))) -> valid_index(a, i,
  j))))

axiom get_valid_index :
  (forall a:'a1 matrix. forall r:int. forall c:int. ((rows(a) = r) ->
  ((columns(a) = c) ->
  (forall i:int. forall j:int. (valid_index(a, i, j) -> (0 <= i))))))

axiom get_valid_index1 :
  (forall a:'a1 matrix. forall r:int. forall c:int. ((rows(a) = r) ->
  ((columns(a) = c) ->
  (forall i:int. forall j:int. (valid_index(a, i, j) -> (i <  r))))))

axiom get_valid_index2 :
  (forall a:'a1 matrix. forall r:int. forall c:int. ((rows(a) = r) ->
  ((columns(a) = c) ->
  (forall i:int. forall j:int. (valid_index(a, i, j) -> (0 <= j))))))

axiom get_valid_index3 :
  (forall a:'a1 matrix. forall r:int. forall c:int. ((rows(a) = r) ->
  ((columns(a) = c) ->
  (forall i:int. forall j:int. (valid_index(a, i, j) -> (j <  c))))))

axiom get_valid_index_params :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall i:int.
  forall j:int. ((rows(a) = r) -> ((columns(a) = c) -> (valid_index(a, i,
  j) -> (0 <= i)))))

axiom get_valid_index_params1 :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall i:int.
  forall j:int. ((rows(a) = r) -> ((columns(a) = c) -> (valid_index(a, i,
  j) -> (i <  r)))))

axiom get_valid_index_params2 :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall i:int.
  forall j:int. ((rows(a) = r) -> ((columns(a) = c) -> (valid_index(a, i,
  j) -> (0 <= j)))))

axiom get_valid_index_params3 :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall i:int.
  forall j:int. ((rows(a) = r) -> ((columns(a) = c) -> (valid_index(a, i,
  j) -> (j <  c)))))

axiom set_values :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall v:'a1.
  (valid_index(a, r, c) ->
  (forall i:int. forall j:int. (valid_index(a, i, j) -> (get(set1(a, r, c,
  v), i, j) = (if ((i = r) and (j = c)) then v else get(a, i, j)))))))

axiom set_rows :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall v:'a1.
  (valid_index(a, r, c) -> (rows(set1(a, r, c, v)) = rows(a))))

axiom set_columns :
  (forall a:'a1 matrix. forall r:int. forall c:int. forall v:'a1.
  (valid_index(a, r, c) -> (columns(set1(a, r, c, v)) = columns(a))))

logic make_func : int, int, (int,(int,'a) farray) farray -> 'a matrix

axiom make_funcqtspec :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) -> (elts(make_func(r, c, f)) = f))))

axiom make_funcqtspec1 :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) -> (rows(make_func(r, c, f)) = r))))

axiom make_funcqtspec2 :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) -> (columns(make_func(r, c, f)) = c))))

axiom make_funcqtspec3 :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) ->
  (forall i:int. forall j:int. (get(make_func(r, c, f), i, j) = ((f[i])[j]))))))

logic make_f : int, int, (int,(int,'a) farray) farray -> 'a matrix

axiom make_fqtdef :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) -> (make_f(r, c, f) = make_func(r, c, f)))))

axiom make_fqtspec :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) -> (rows(make_f(r, c, f)) = r))))

axiom make_fqtspec1 :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) -> (columns(make_f(r, c, f)) = c))))

axiom make_fqtspec2 :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) ->
  (forall i:int. forall j:int. (get(make_f(r, c, f), i, j) = ((f[i])[j]))))))

axiom assert_make :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  forall i:int. forall j:int. (((0 <= i) and (i <  r)) -> (((0 <= j) and
  (j <  c)) -> (get(make_f(r, c, f), i, j) = ((f[i])[j])))))

axiom assert_make_r :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) -> (rows(make_f(r, c, f)) = r))))

axiom assert_make_c :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  ((0 <  r) -> ((0 <  c) -> (columns(make_f(r, c, f)) = c))))

function to_indexes(m: 'a matrix) : (int, int) tuple2 set =
  cartesian_product(to_fset(0, rows(m)), to_fset(0, columns(m)))

axiom to_indexesqtspec :
  (forall m:'a matrix. (cardinal(to_indexes(m)) = (rows(m) * columns(m))))

axiom set_to_indexes_mem :
  (forall m:'a matrix. forall i:int. forall j:int. (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(m))) -> mem({
  Tuple2_proj_1 = i; Tuple2_proj_2 = j }, to_indexes(m)))))

axiom get_to_indexes_mem :
  (forall m:'a matrix. forall o:(int, int) tuple2. (mem(o, to_indexes(m)) ->
  (0 <= fir(o))))

axiom get_to_indexes_mem1 :
  (forall m:'a matrix. forall o:(int, int) tuple2. (mem(o, to_indexes(m)) ->
  (fir(o) <  rows(m))))

axiom get_to_indexes_mem2 :
  (forall m:'a matrix. forall o:(int, int) tuple2. (mem(o, to_indexes(m)) ->
  (0 <= sec(o))))

axiom get_to_indexes_mem3 :
  (forall m:'a matrix. forall o:(int, int) tuple2. (mem(o, to_indexes(m)) ->
  (sec(o) <  columns(m))))

axiom mat_equality :
  (forall m:'a matrix. forall n:'a matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) ->
  ((forall i:int. forall j:int. (valid_index(m, i, j) -> (get(m, i,
   j) = get(n, i, j)))) ->
  infix_eqeq(m, n)))))

predicate square(m: 'a matrix) = (rows(m) = columns(m))

axiom equal_sym :
  (forall m:'a matrix. forall n:'a matrix. (infix_eqeq(m, n) -> infix_eqeq(n,
  m)))

axiom equal_sym1 :
  (forall m:'a matrix. forall n:'a matrix. (infix_eqeq(n, m) -> infix_eqeq(m,
  n)))

axiom equal_rex : (forall m:'a matrix. infix_eqeq(m, m))

axiom equal_trans :
  (forall m:'a matrix. forall n:'a matrix. forall o:'a matrix. (infix_eqeq(m,
  n) -> (infix_eqeq(n, o) -> infix_eqeq(m, o))))

axiom set_equal_mat :
  (forall m:'a matrix. forall n:'a matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) ->
  ((forall i:int. forall j:int. (valid_index(m, i, j) -> (get(m, i,
   j) = get(n, i, j)))) ->
  (m = n)))))

axiom set_equal_mat_make :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  forall g:(int,(int,'a) farray) farray. ((0 <  r) -> ((0 <  c) ->
  ((forall i:int. forall j:int. (((0 <= i) and (i <  r)) -> (((0 <= j) and
   (j <  c)) -> (((f[i])[j]) = ((g[i])[j]))))) ->
  (make_f(r, c, f) = make_f(r, c, g))))))

axiom set_equal_mat_make_t :
  (forall r:int. forall rqt:int. forall c:int. forall cqt:int.
  forall f:(int,(int,'a) farray) farray.
  forall g:(int,(int,'a) farray) farray. ((0 <  r) -> ((0 <  c) ->
  ((r = rqt) -> ((c = cqt) ->
  ((forall i:int. forall j:int. (((0 <= i) and (i <  r)) -> (((0 <= j) and
   (j <  c)) -> (((f[i])[j]) = ((g[i])[j]))))) ->
  (make_f(r, c, f) = make_f(rqt, cqt, g))))))))

axiom get_equal_mat :
  (forall m:'a matrix. forall n:'a matrix. ((m = n) -> (rows(m) = rows(n))))

axiom get_equal_mat1 :
  (forall m:'a matrix. forall n:'a matrix. ((m = n) ->
  (columns(m) = columns(n))))

axiom get_equal_mat2 :
  (forall m:'a matrix. forall n:'a matrix. ((m = n) ->
  (forall i:int. forall j:int. (valid_index(m, i, j) -> (get(m, i,
  j) = get(n, i, j))))))

axiom equal_functions :
  (forall r:int. forall c:int. forall f:(int,(int,'a) farray) farray.
  forall g:(int,(int,'a) farray) farray. ((0 <  r) -> ((0 <  c) ->
  ((forall i:int. forall j:int. ((((0 <= i) and (i <  r)) and ((0 <= j) and
   (j <  c))) -> (((f[i])[j]) = ((g[i])[j])))) ->
  (make_f(r, c, f) = make_f(r, c, g))))))

axiom equal_functions_mat :
  (forall f:(int,(int,'a) farray) farray. forall m:'a matrix.
  ((forall i:int. forall j:int. ((((0 <= i) and (i <  rows(m))) and
   ((0 <= j) and (j <  columns(m)))) -> (((f[i])[j]) = get(m, i, j)))) ->
  (m = make_f(rows(m), columns(m), f))))

predicate null_mat(a: complex matrix) =
  (forall i:int. forall j:int. (valid_index(a, i, j) -> (get(a, i,
  j) = c_zero)))

axiom set_null_mat :
  (forall a:complex matrix.
  ((forall i:int. forall j:int. (valid_index(a, i, j) -> (get(a, i,
   j) = c_zero))) ->
  null_mat(a)))

axiom get_null_mat :
  (forall a:complex matrix. (null_mat(a) ->
  (forall i:int. forall j:int. (valid_index(a, i, j) -> (get(a, i,
  j) = c_zero)))))

logic identity : int -> complex matrix

logic result6 : (int,(int,complex) farray) farray

axiom resultqtdef10 :
  (forall i:int. forall j:int.
  (((result6[i])[j]) = (if (i = j) then c_one else c_zero)))

axiom identityqtdef :
  (forall n:int. ((0 <= n) -> (identity(n) = make_f(power(2, n), power(2, n),
  result6))))

axiom identityqtspec :
  (forall n:int. ((0 <= n) -> (rows(identity(n)) = power(2, n))))

axiom identityqtspec1 :
  (forall n:int. ((0 <= n) -> (columns(identity(n)) = power(2, n))))

axiom identityqtspec2 :
  (forall n:int. ((0 <= n) ->
  (forall i:int. forall j:int. (valid_index(identity(n), i, j) ->
  (get(identity(n), i, j) = (if (i = j) then c_one else c_zero))))))

axiom identity_rows :
  (forall n:int. ((0 <= n) -> (rows(identity(n)) = power(2, n))))

axiom identity_columns :
  (forall n:int. ((0 <= n) -> (columns(identity(n)) = power(2, n))))

axiom identity_values :
  (forall i:int. forall j:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= j) and (j <  power(2, n))) ->
  (get(identity(n), i, j) = (if (i = j) then c_one else c_zero))))))

logic result7 : complex matrix,
  complex matrix -> (int,(int,complex) farray) farray

axiom resultqtdef11 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (((result7(m, n)[i])[j]) = infix_asdt(get(m, (i / rows(n)),
  (j / columns(n))), get(n, (i % rows(n)), (j % columns(n))))))

function kronecker(m: complex matrix, n: complex matrix) : complex matrix =
  make_f((rows(m) * rows(n)), (columns(m) * columns(n)), result7(m, n))

axiom kroneckerqtspec :
  (forall m:complex matrix. forall n:complex matrix. (rows(kronecker(m,
  n)) = (rows(m) * rows(n))))

axiom kroneckerqtspec1 :
  (forall m:complex matrix. forall n:complex matrix. (columns(kronecker(m,
  n)) = (columns(m) * columns(n))))

axiom kroneckerqtspec2 :
  (forall m:complex matrix. forall n:complex matrix.
  (forall i:int. forall j:int. (valid_index(kronecker(m, n), i, j) ->
  (get(kronecker(m, n), i, j) = infix_asdt(get(m, (i / rows(n)),
  (j / columns(n))), get(n, (i % rows(n)), (j % columns(n))))))))

axiom kronecker_eq :
  (forall m1:complex matrix. forall n1:complex matrix.
  forall m2:complex matrix. forall n2:complex matrix. ((m1 = m2) ->
  ((n1 = n2) -> (kronecker(m1, n1) = kronecker(m2, n2)))))

logic fc107 : complex matrix,
  complex matrix -> (int,(int,complex) farray) farray

axiom fcqtdef107 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (((fc107(m, n)[i])[j]) = infix_asdt(get(m, (i / rows(n)),
  (j / columns(n))), get(n, (i % rows(n)), (j % columns(n))))))

axiom get_kronecker :
  (forall m:complex matrix. forall n:complex matrix. (kronecker(m,
  n) = make_f((rows(m) * rows(n)), (columns(m) * columns(n)), fc107(m, n))))

axiom kronecker_values :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (valid_index(kronecker(m, n), i, j) -> (get(kronecker(m, n),
  i, j) = infix_asdt(get(m, (i / rows(n)), (j / columns(n))), get(n,
  (i % rows(n)), (j % columns(n)))))))

axiom kronecker_rows :
  (forall m:complex matrix. forall n:complex matrix. (rows(kronecker(m,
  n)) = (rows(m) * rows(n))))

axiom kronecker_columns :
  (forall m:complex matrix. forall n:complex matrix. (columns(kronecker(m,
  n)) = (columns(m) * columns(n))))

axiom kronecker_values_gen :
  (forall m:complex matrix. forall n:complex matrix.
  (forall i:int. forall j:int. (valid_index(kronecker(m, n), i, j) ->
  (get(kronecker(m, n), i, j) = infix_asdt(get(m, (i / rows(n)),
  (j / columns(n))), get(n, (i % rows(n)), (j % columns(n))))))))

axiom kronecker_mod_values :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (valid_index(kronecker(m, n), i, j) -> (get(kronecker(m, n),
  i, j) = infix_asdt(get(m, ((i % rows(kronecker(m, n))) / rows(n)),
  ((j % columns(kronecker(m, n))) / columns(n))), get(n,
  ((i % rows(kronecker(m, n))) % rows(n)), ((j % columns(kronecker(m,
  n))) % columns(n)))))))

axiom kronecker_indexes :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. forall k:int. forall l:int. (valid_index(m, i, j) ->
  (valid_index(n, k, l) -> valid_index(kronecker(m, n), ((i * rows(n)) + k),
  ((j * columns(n)) + l)))))

axiom kronecker_indexes_com :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (valid_index(kronecker(m, n), i, j) -> valid_index(m,
  (i / rows(n)), (j / columns(n)))))

axiom kronecker_indexes_com1 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (valid_index(kronecker(m, n), i, j) -> valid_index(n,
  (i % rows(n)), (j % columns(n)))))

axiom kronecker_assoc_pre :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  forall i:int. forall j:int. (((0 <= i) and
  (i <  ((rows(m) * rows(n)) * rows(o)))) -> (((0 <= j) and
  (j <  ((columns(m) * columns(n)) * columns(o)))) ->
  (get(kronecker(kronecker(m, n), o), i, j) = get(kronecker(m, kronecker(n,
  o)), i, j)))))

logic kronecker_closure : (complex matrix,(complex matrix,complex matrix) farray) farray

axiom kronecker_closure_def :
  (forall y:complex matrix. forall y1:complex matrix.
  (((kronecker_closure[y])[y1]) = kronecker(y, y1)))

axiom kronecker_assoc : op_assoc(kronecker_closure)

axiom kronecker_assoc_use :
  (forall a:complex matrix. forall b:complex matrix. forall c:complex matrix.
  (kronecker(a, kronecker(b, c)) = kronecker(kronecker(a, b), c)))

axiom kronecker_assoc_use_rev :
  (forall a:complex matrix. forall b:complex matrix. forall c:complex matrix.
  (kronecker(kronecker(a, b), c) = kronecker(a, kronecker(b, c))))

axiom neutral_ :
  (forall m:complex matrix. (kronecker(m, make(1, 1, c_one)) = m))

axiom neutral_1 :
  (forall m:complex matrix. (kronecker(make(1, 1, c_one), m) = m))

axiom neutral1 : (make(1, 1, c_one) = neutral_elt(kronecker_closure))

axiom neutral2 : has_neutral(kronecker_closure)

axiom neutral3 : iterable(kronecker_closure)

axiom kronecker_equal :
  (forall m:complex matrix. forall ml:complex matrix.
  forall n:complex matrix. forall nl:complex matrix. (infix_eqeq(m, ml) ->
  (infix_eqeq(n, nl) -> infix_eqeq(kronecker(m, n), kronecker(ml, nl)))))

axiom kron_id :
  (forall m:int. forall n:int. ((0 <= m) -> ((0 <= n) ->
  (kronecker(identity(m), identity(n)) = identity((m + n))))))

function frows(f: (int,complex matrix) farray, k: int) : int = rows((f[k]))

axiom frowsqtspec :
  (forall f:(int,complex matrix) farray. forall k:int. (0 <  frows(f, k)))

function fcolumns(f: (int,complex matrix) farray, k: int) : int =
  columns((f[k]))

axiom fcolumnsqtspec :
  (forall f:(int,complex matrix) farray. forall k:int. (0 <  fcolumns(f, k)))

logic fc108 : (complex matrix,(int,complex matrix) farray) farray

axiom fcqtdef108 :
  (forall y0:complex matrix. forall y1:int. (((fc108[y0])[y1]) = y0))

axiom const_fcol :
  (forall m:complex matrix. forall k:int. (fcolumns((fc108[m]),
  k) = columns(m)))

logic fc109 : (complex matrix,(int,complex matrix) farray) farray

axiom fcqtdef109 :
  (forall y0:complex matrix. forall y1:int. (((fc109[y0])[y1]) = y0))

axiom const_frows :
  (forall m:complex matrix. forall k:int. (frows((fc109[m]), k) = rows(m)))

logic result8 : complex matrix, complex matrix, int,
  int -> (int,complex) farray

logic result9 : complex matrix,
  complex matrix -> (int,(int,complex) farray) farray

logic result10 : (int,(int,complex) farray) farray

axiom resultqtdef12 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. forall k:int. ((result8(m, n, i, j)[k]) = infix_asdt(get(m,
  i, k), get(n, k, j))))

axiom resultqtdef13 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (((result9(m, n)[i])[j]) = ind_sum(result8(m, n, i, j), 0,
  columns(m))))

axiom resultqtdef14 :
  (forall us:int. forall us1:int. (((result10[us])[us1]) = c_zero))

function mat_mult_no_bound(m: complex matrix,
  n: complex matrix) : complex matrix =
  (if (columns(m) = rows(n)) then make_f(rows(m), columns(n), result9(m,
  n)) else make_f(1, 1, result10))

logic fc110 : complex matrix, complex matrix, int,
  int -> (int,complex) farray

axiom fcqtdef110 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. forall k:int. ((fc110(m, n, i, j)[k]) = infix_asdt(get(m, i,
  k), get(n, k, j))))

axiom mat_mult_no_boundqtspec :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) -> (rows(mat_mult_no_bound(m, n)) = rows(m))))

axiom mat_mult_no_boundqtspec1 :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) -> (columns(mat_mult_no_bound(m,
  n)) = columns(n))))

axiom mat_mult_no_boundqtspec2 :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) ->
  (forall i:int. forall j:int. (valid_index(mat_mult_no_bound(m, n), i, j) ->
  (get(mat_mult_no_bound(m, n), i, j) = ind_sum(fc110(m, n, i, j), 0,
  columns(m)))))))

logic mat_mult : complex matrix, complex matrix -> complex matrix

axiom mat_multqtdef :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) -> (mat_mult(m, n) = mat_mult_no_bound(m, n))))

logic fc111 : complex matrix, complex matrix, int,
  int -> (int,complex) farray

axiom fcqtdef111 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. forall k:int. ((fc111(m, n, i, j)[k]) = infix_asdt(get(m, i,
  k), get(n, k, j))))

axiom mat_multqtspec :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) -> (rows(mat_mult(m, n)) = rows(m))))

axiom mat_multqtspec1 :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) -> (columns(mat_mult(m, n)) = columns(n))))

axiom mat_multqtspec2 :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) ->
  (forall i:int. forall j:int. (valid_index(mat_mult(m, n), i, j) ->
  (get(mat_mult(m, n), i, j) = ind_sum(fc111(m, n, i, j), 0, columns(m)))))))

logic fc112 : complex matrix, complex matrix, int,
  int -> (int,complex) farray

logic fc113 : complex matrix,
  complex matrix -> (int,(int,complex) farray) farray

axiom fcqtdef112 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. forall k:int. ((fc112(m, n, i, j)[k]) = infix_asdt(get(m, i,
  k), get(n, k, j))))

axiom fcqtdef113 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (((fc113(m, n)[i])[j]) = ind_sum(fc112(m, n, i, j), 0,
  columns(m))))

axiom correct_mat_mult :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) -> (mat_mult(m, n) = make_f(rows(m), columns(n),
  fc113(m, n)))))

logic fc114 : complex matrix, complex matrix, int,
  int -> (int,complex) farray

axiom fcqtdef114 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. forall k:int. ((fc114(m, n, i, j)[k]) = infix_asdt(get(m, i,
  k), get(n, k, j))))

axiom mat_mult_values :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. ((columns(m) = rows(n)) -> (valid_index(mat_mult(m, n), i,
  j) -> (get(mat_mult(m, n), i, j) = ind_sum(fc114(m, n, i, j), 0,
  columns(m))))))

axiom mat_mult_columns :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) -> (columns(mat_mult(m, n)) = columns(n))))

axiom mat_mult_rows :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) -> (rows(mat_mult(m, n)) = rows(m))))

logic fc115 : complex matrix, complex matrix, int,
  int -> (int,complex) farray

axiom fcqtdef115 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. forall k:int. ((fc115(m, n, i, j)[k]) = infix_asdt(get(m, i,
  k), get(n, k, j))))

axiom mat_mult_values_quant :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) ->
  (forall i:int. forall j:int. (valid_index(mat_mult(m, n), i, j) ->
  (get(mat_mult(m, n), i, j) = ind_sum(fc115(m, n, i, j), 0, columns(m)))))))

logic int_mat_prod : (int,complex matrix) farray, int, int -> complex matrix

axiom int_mat_prodqtdef :
  (forall f:(int,complex matrix) farray. forall i:int. forall j:int.
  ((i <= j) ->
  ((forall k:int. forall kqt:int. ((((i <= k) and (k <= j)) and
   ((i <= kqt) and (kqt <= j))) -> ((rows((f[k])) = rows((f[kqt]))) and
   (rows((f[kqt])) = columns((f[kqt])))))) ->
  (((j - i) = 0) -> (int_mat_prod(f, i, j) = (f[i]))))))

axiom int_mat_prodqtdef1 :
  (forall f:(int,complex matrix) farray. forall i:int. forall j:int.
  ((i <= j) ->
  ((forall k:int. forall kqt:int. ((((i <= k) and (k <= j)) and
   ((i <= kqt) and (kqt <= j))) -> ((rows((f[k])) = rows((f[kqt]))) and
   (rows((f[kqt])) = columns((f[kqt])))))) ->
  ((not ((j - i) = 0)) -> (int_mat_prod(f, i,
  j) = mat_mult_no_bound(int_mat_prod(f, i, (j - 1)), (f[j])))))))

axiom int_mat_prodqtspec :
  (forall f:(int,complex matrix) farray. forall i:int. forall j:int.
  ((i <= j) ->
  ((forall k:int. forall kqt:int. ((((i <= k) and (k <= j)) and
   ((i <= kqt) and (kqt <= j))) -> ((rows((f[k])) = rows((f[kqt]))) and
   (rows((f[kqt])) = columns((f[kqt])))))) ->
  (rows(int_mat_prod(f, i, j)) = rows((f[i]))))))

axiom int_mat_prodqtspec1 :
  (forall f:(int,complex matrix) farray. forall i:int. forall j:int.
  ((i <= j) ->
  ((forall k:int. forall kqt:int. ((((i <= k) and (k <= j)) and
   ((i <= kqt) and (kqt <= j))) -> ((rows((f[k])) = rows((f[kqt]))) and
   (rows((f[kqt])) = columns((f[kqt])))))) ->
  (columns(int_mat_prod(f, i, j)) = columns((f[i]))))))

axiom int_mat_prodqtspec2 :
  (forall f:(int,complex matrix) farray. forall i:int. forall j:int.
  ((i <= j) ->
  ((forall k:int. forall kqt:int. ((((i <= k) and (k <= j)) and
   ((i <= kqt) and (kqt <= j))) -> ((rows((f[k])) = rows((f[kqt]))) and
   (rows((f[kqt])) = columns((f[kqt])))))) ->
  (columns(int_mat_prod(f, i, j)) = rows((f[i]))))))

axiom int_mat_prod_zero :
  (forall f:(int,complex matrix) farray. forall i:int. forall j:int.
  ((rows((f[i])) = columns((f[i]))) -> ((i = j) -> (int_mat_prod(f, i,
  j) = (f[i])))))

logic int_mat_prod_plus_one : (int,complex matrix) farray, int, int -> unit

axiom int_mat_prod_plus_oneqtdef :
  (forall f:(int,complex matrix) farray. forall i:int. forall j:int.
  ((i <  j) ->
  ((forall k:int. forall kqt:int. ((((i <= k) and (k <= j)) and
   ((i <= kqt) and (kqt <= j))) -> ((rows((f[k])) = rows((f[kqt]))) and
   (rows((f[kqt])) = columns((f[kqt])))))) ->
  (int_mat_prod_plus_one(f, i, j) = void))))

axiom int_mat_prod_plus_oneqtspec :
  (forall f:(int,complex matrix) farray. forall i:int. forall j:int.
  ((i <  j) ->
  ((forall k:int. forall kqt:int. ((((i <= k) and (k <= j)) and
   ((i <= kqt) and (kqt <= j))) -> ((rows((f[k])) = rows((f[kqt]))) and
   (rows((f[kqt])) = columns((f[kqt])))))) ->
  (int_mat_prod(f, i, j) = mat_mult(int_mat_prod(f, i, (j - 1)), (f[j]))))))

axiom int_mat_prod_eq :
  (forall f:(int,complex matrix) farray.
  forall g:(int,complex matrix) farray. forall i:int. forall j:int.
  ((i <= j) ->
  ((forall k:int. forall kqt:int. (((i <= k) and (k <= j)) ->
   (((i <= kqt) and (kqt <= j)) -> ((rows((f[k])) = rows((f[kqt]))) and
   (rows((f[kqt])) = columns((f[kqt]))))))) ->
  ((forall k:int. (((i <= k) and (k <= j)) -> ((f[k]) = (g[k])))) ->
  (int_mat_prod(f, i, j) = int_mat_prod(g, i, j))))))

axiom mat_mult_id :
  (forall n:int. forall m:complex matrix. ((0 <= n) ->
  ((columns(m) = power(2, n)) -> (mat_mult(m, identity(n)) = m))))

axiom id_mat_mult :
  (forall n:int. forall m:complex matrix. ((0 <= n) -> ((rows(m) = power(2,
  n)) -> (mat_mult(identity(n), m) = m))))

axiom mat_mult_eq :
  (forall m:complex matrix. forall n:complex matrix.
  forall mqt:complex matrix. forall nqt:complex matrix. ((m = mqt) ->
  ((n = nqt) -> ((columns(m) = rows(n)) -> (mat_mult(m, n) = mat_mult(mqt,
  nqt))))))

logic add_mat : complex matrix, complex matrix -> complex matrix

logic result11 : complex matrix,
  complex matrix -> (int,(int,complex) farray) farray

axiom resultqtdef15 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (((result11(m, n)[i])[j]) = infix_pldt(get(m, i, j), get(n,
  i, j))))

axiom add_matqtdef :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> (add_mat(m, n) = make_f(rows(m), columns(m),
  result11(m, n))))))

axiom add_matqtspec :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> (columns(add_mat(m, n)) = columns(m)))))

axiom add_matqtspec1 : true

axiom add_matqtspec2 :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> (rows(add_mat(m, n)) = rows(m)))))

axiom add_matqtspec3 :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> (rows(m) = rows(n)))))

axiom add_matqtspec4 :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) ->
  (forall i:int. forall j:int. (get(add_mat(m, n), i, j) = infix_pldt(get(m,
  i, j), get(n, i, j)))))))

axiom add_mat_equal :
  (forall m:complex matrix. forall n:complex matrix.
  forall mqt:complex matrix. forall nqt:complex matrix.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) -> ((m = mqt) ->
  ((n = nqt) -> (add_mat(m, n) = add_mat(mqt, nqt)))))))

axiom add_value :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = columns(n)) -> ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) ->
  (forall i:int. forall j:int. (((0 <= i) and (i <  rows(m))) ->
  (((0 <= j) and (j <  columns(m))) -> (get(add_mat(m, n), i,
  j) = infix_pldt(get(m, i, j), get(n, i, j))))))))))

axiom add_values :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. ((columns(m) = columns(n)) -> ((rows(m) = rows(n)) ->
  (get(add_mat(m, n), i, j) = infix_pldt(get(m, i, j), get(n, i, j))))))

axiom add_mat_null_left :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = columns(n)) -> ((rows(m) = rows(n)) -> (null_mat(m) ->
  (add_mat(m, n) = n)))))

axiom add_mat_null_right :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = columns(n)) -> ((rows(m) = rows(n)) -> (null_mat(n) ->
  (add_mat(m, n) = m)))))

axiom set_equal_columns_elt :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  (((columns(m) = columns(n)) and (columns(n) = i)) ->
  (columns(m) = columns(n))))

axiom set_equal_rows_elt :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  (((rows(m) = rows(n)) and (rows(n) = i)) -> (rows(m) = rows(n))))

axiom add_columns :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = columns(n)) -> ((rows(m) = rows(n)) -> (columns(add_mat(m,
  n)) = columns(m)))))

axiom add_rows :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = columns(n)) -> ((rows(m) = rows(n)) -> (rows(add_mat(m,
  n)) = rows(m)))))

axiom set_equal_dim_elt :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (((rows(m) = rows(n)) and (rows(n) = i)) ->
  (((columns(m) = columns(n)) and (columns(n) = j)) ->
  (columns(m) = columns(n)))))

axiom set_equal_dim_elt1 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (((rows(m) = rows(n)) and (rows(n) = i)) ->
  (((columns(m) = columns(n)) and (columns(n) = j)) -> (rows(m) = rows(n)))))

axiom set_dim_add :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (((rows(m) = rows(n)) and (rows(n) = i)) ->
  (((columns(m) = columns(n)) and (columns(n) = j)) -> (rows(add_mat(m,
  n)) = i))))

axiom set_dim_add1 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. (((rows(m) = rows(n)) and (rows(n) = i)) ->
  (((columns(m) = columns(n)) and (columns(n) = j)) -> (columns(add_mat(m,
  n)) = j))))

axiom add_mat_eq :
  (forall m:complex matrix. forall m1:complex matrix.
  forall n:complex matrix. forall n1:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> ((m = m1) -> ((n = n1) -> (add_mat(m,
  n) = add_mat(m1, n1)))))))

axiom add_mat_comm :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> (add_mat(m, n) = add_mat(n, m)))))

axiom add_mat_eq_rev :
  (forall m:complex matrix. forall m1:complex matrix.
  forall n:complex matrix. forall n1:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> ((m = m1) -> ((n = n1) -> (add_mat(n,
  m) = add_mat(m1, n1)))))))

logic add_neutral : unit -> complex matrix

axiom add_neutralqtspec :
  (forall us:unit.
  (forall i:int. forall j:int. (valid_index(add_neutral(us), i, j) ->
  (get(add_neutral(us), i, j) = c_zero))))

axiom add_neutralqtspec1 : (forall us:unit. (0 <  rows(add_neutral(us))))

axiom add_neutralqtspec2 : (forall us:unit. (0 <  columns(add_neutral(us))))

axiom distr_1_pre :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  forall i:int. forall j:int. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> ((columns(m) = rows(o)) -> (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(o))) ->
  (get(mat_mult(add_mat(m, n), o), i, j) = get(add_mat(mat_mult(m, o),
  mat_mult(n, o)), i, j))))))))

axiom distr_l :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) ->
  ((columns(m) = rows(o)) -> (mat_mult(add_mat(m, n),
  o) = add_mat(mat_mult(m, o), mat_mult(n, o)))))))

axiom distr_2_pre :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  forall i:int. forall j:int. ((rows(n) = rows(o)) ->
  ((columns(n) = columns(o)) -> ((columns(m) = rows(n)) -> (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(n))) ->
  valid_index(mat_mult(m, add_mat(n, o)), i, j)))))))

axiom distr_2_pre1 :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  forall i:int. forall j:int. ((rows(n) = rows(o)) ->
  ((columns(n) = columns(o)) -> ((columns(m) = rows(n)) -> (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(n))) -> (get(mat_mult(m,
  add_mat(n, o)), i, j) = get(add_mat(mat_mult(m, n), mat_mult(m, o)), i,
  j))))))))

axiom distr_r :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(n) = rows(o)) -> ((columns(n) = columns(o)) ->
  ((columns(m) = rows(n)) -> (mat_mult(m, add_mat(n,
  o)) = add_mat(mat_mult(m, n), mat_mult(m, o)))))))

logic result12 : complex, complex matrix -> (int,(int,complex) farray) farray

axiom resultqtdef16 :
  (forall s:complex. forall m:complex matrix. forall i:int. forall j:int.
  (((result12(s, m)[i])[j]) = infix_asdt(s, get(m, i, j))))

function infix_asdtdt(s: complex, m: complex matrix) : complex matrix =
  make_f(rows(m), columns(m), result12(s, m))

axiom infix_asdtdtqtspec :
  (forall s:complex. forall m:complex matrix. (columns(infix_asdtdt(s,
  m)) = columns(m)))

axiom infix_asdtdtqtspec1 :
  (forall s:complex. forall m:complex matrix. (rows(infix_asdtdt(s,
  m)) = rows(m)))

axiom infix_asdtdtqtspec2 :
  (forall s:complex. forall m:complex matrix.
  (forall i:int. forall j:int. (valid_index(infix_asdtdt(s, m), i, j) ->
  (get(infix_asdtdt(s, m), i, j) = infix_asdt(s, get(m, i, j))))))

axiom infix_asdtdtqtspec3 :
  (forall s:complex. forall m:complex matrix.
  (forall i:int. forall j:int. (valid_index(infix_asdtdt(s, m), i, j) ->
  valid_index(m, i, j))))

axiom infix_asdtdtqtspec4 :
  (forall s:complex. forall m:complex matrix.
  (forall i:int. forall j:int. (valid_index(m, i, j) ->
  valid_index(infix_asdtdt(s, m), i, j))))

axiom scalar_columns :
  (forall m:complex matrix. forall a:complex. (columns(infix_asdtdt(a,
  m)) = columns(m)))

axiom scalar_values :
  (forall m:complex matrix. forall a:complex. forall i:int. forall j:int.
  (get(infix_asdtdt(a, m), i, j) = infix_asdt(a, get(m, i, j))))

axiom scalar_rows :
  (forall m:complex matrix. forall a:complex. (rows(infix_asdtdt(a,
  m)) = rows(m)))

axiom scalar_null :
  (forall m:complex matrix. null_mat(infix_asdtdt(c_zero, m)))

axiom scalar_c_one : (forall m:complex matrix. (infix_asdtdt(c_one, m) = m))

axiom scalar_c_one_gen :
  (forall m:complex matrix. forall a:complex. ((a = c_one) ->
  (infix_asdtdt(a, m) = m)))

axiom scalar_null_gen :
  (forall m:complex matrix. forall a:complex. ((a = c_zero) ->
  null_mat(infix_asdtdt(a, m))))

axiom scalar_plus :
  (forall m:complex matrix. forall a:complex. forall b:complex.
  (infix_asdtdt(infix_pldt(a, b), m) = add_mat(infix_asdtdt(a, m),
  infix_asdtdt(b, m))))

axiom scalar_plus_rev :
  (forall m:complex matrix. forall a:complex. forall b:complex.
  (add_mat(infix_asdtdt(a, m), infix_asdtdt(b,
  m)) = infix_asdtdt(infix_pldt(a, b), m)))

axiom add_scal :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) -> (infix_asdtdt(a,
  add_mat(m, n)) = add_mat(infix_asdtdt(a, m), infix_asdtdt(a, n))))))

axiom add_scal_rev :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) ->
  (add_mat(infix_asdtdt(a, m), infix_asdtdt(a, n)) = infix_asdtdt(a,
  add_mat(m, n))))))

logic fc116 : complex matrix, complex matrix, complex, int,
  int -> (int,complex) farray

axiom fcqtdef116 :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  forall i:int. forall j:int. forall k:int. ((fc116(m, n, a, i,
  j)[k]) = infix_asdt(infix_asdt(a, get(m, i, k)), get(n, k, j))))

axiom mat_mult_scal_values_l :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  forall i:int. forall j:int. ((rows(n) = columns(m)) -> (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(n))) -> (infix_asdt(a,
  get(mat_mult(m, n), i, j)) = ind_sum(fc116(m, n, a, i, j), 0,
  columns(m)))))))

logic fc117 : complex matrix, complex matrix, complex, int,
  int -> (int,complex) farray

axiom fcqtdef117 :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  forall i:int. forall j:int. forall k:int. ((fc117(m, n, a, i,
  j)[k]) = infix_asdt(infix_asdt(a, get(m, i, k)), get(n, k, j))))

axiom mat_mult_scal_values_r :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  forall i:int. forall j:int. ((rows(n) = columns(m)) ->
  ((rows(m) = columns(n)) -> ((columns(m) = columns(n)) -> (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(n))) ->
  (infix_asdt(get(mat_mult(m, n), i, j), a) = ind_sum(fc117(m, n, a, i, j),
  0, columns(m)))))))))

axiom mat_mut_scal :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  ((rows(n) = columns(m)) -> (mat_mult(m, infix_asdtdt(a,
  n)) = infix_asdtdt(a, mat_mult(m, n)))))

axiom scal_mat_mut :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  ((rows(n) = columns(m)) -> (mat_mult(infix_asdtdt(a, m),
  n) = infix_asdtdt(a, mat_mult(m, n)))))

axiom mat_mut_scal_rev :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  ((rows(n) = columns(m)) -> (infix_asdtdt(a, mat_mult(m, n)) = mat_mult(m,
  infix_asdtdt(a, n)))))

axiom scal_mat_mut_rev :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  ((rows(n) = columns(m)) -> (infix_asdtdt(a, mat_mult(m,
  n)) = mat_mult(infix_asdtdt(a, m), n))))

logic fc118 : (int,(int,complex) farray) farray, (int,complex) farray, int,
  int -> (int,complex) farray

logic fc119 : (int,(int,complex) farray) farray, (int,complex) farray,
  int -> (int,complex) farray

logic fc120 : (int,(int,complex) farray) farray, (int,complex) farray, int,
  int -> (int,complex) farray

axiom fcqtdef118 :
  (forall f:(int,(int,complex) farray) farray. forall g:(int,complex) farray.
  forall k:int. forall l:int. forall k1:int. ((fc118(f, g, k,
  l)[k1]) = infix_asdt(ind_sum((f[k1]), k, l), (g[k1]))))

axiom fcqtdef119 :
  (forall f:(int,(int,complex) farray) farray. forall g:(int,complex) farray.
  forall k1:int. forall k2:int. ((fc119(f, g,
  k1)[k2]) = infix_asdt(((f[k2])[k1]), (g[k2]))))

axiom fcqtdef120 :
  (forall f:(int,(int,complex) farray) farray. forall g:(int,complex) farray.
  forall i:int. forall j:int. forall k1:int. ((fc120(f, g, i,
  j)[k1]) = ind_sum(fc119(f, g, k1), i, j)))

axiom ind_sum_commute_scal_r :
  (forall f:(int,(int,complex) farray) farray. forall g:(int,complex) farray.
  forall i:int. forall j:int. forall k:int. forall l:int. ((i <= j) ->
  ((k <= l) -> (ind_sum(fc118(f, g, k, l), i, j) = ind_sum(fc120(f, g, i, j),
  k, l)))))

axiom mat_mult_assoc_pre :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  forall i:int. forall j:int. ((columns(m) = rows(n)) ->
  ((columns(n) = rows(o)) -> (((0 <= i) and (i <  rows(m))) -> (((0 <= j) and
  (j <  columns(o))) -> (get(mat_mult(mat_mult(m, n), o), i,
  j) = get(mat_mult(m, mat_mult(n, o)), i, j)))))))

axiom mat_mult_assoc :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((columns(m) = rows(n)) -> ((columns(n) = rows(o)) -> (mat_mult(mat_mult(m,
  n), o) = mat_mult(m, mat_mult(n, o))))))

axiom mat_mult_assoc_quant :
  (forall m:complex matrix. forall n:complex matrix.
  ((columns(m) = rows(n)) ->
  (forall o:complex matrix. ((columns(n) = rows(o)) -> (mat_mult(mat_mult(m,
  n), o) = mat_mult(m, mat_mult(n, o)))))))

axiom mat_mult_assoc_comm :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((columns(m) = rows(n)) -> ((columns(n) = rows(o)) -> (mat_mult(m,
  mat_mult(n, o)) = mat_mult(mat_mult(m, n), o)))))

axiom scalar_eq :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  ((m = n) -> (infix_asdtdt(a, m) = infix_asdtdt(a, n))))

axiom scalar_eq_gen :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  forall b:complex. ((m = n) -> ((a = b) -> (infix_asdtdt(a,
  m) = infix_asdtdt(b, n)))))

axiom scalar_add :
  (forall m:complex matrix. forall a:complex. forall b:complex.
  (infix_asdtdt(infix_pldt(a, b), m) = add_mat(infix_asdtdt(a, m),
  infix_asdtdt(b, m))))

axiom scalar_assoc :
  (forall m:complex matrix. forall a:complex. forall b:complex.
  (infix_asdtdt(a, infix_asdtdt(b, m)) = infix_asdtdt(infix_asdt(a, b), m)))

axiom scalar_assoc_rev :
  (forall m:complex matrix. forall a:complex. forall b:complex.
  (infix_asdtdt(infix_asdt(a, b), m) = infix_asdtdt(a, infix_asdtdt(b, m))))

axiom scalars_inv :
  (forall m:complex matrix. forall a:complex. forall b:complex.
  forall aqt:complex. forall bqt:complex. ((a = aqt) -> ((b = bqt) ->
  (infix_asdtdt(aqt, infix_asdtdt(bqt, m)) = infix_asdtdt(b, infix_asdtdt(a,
  m))))))

axiom eq_scalar :
  (forall m:complex matrix. forall a:complex. forall b:complex.
  ((exists i:int. exists j:int. (valid_index(m, i, j) and (not (get(m, i,
   j) = c_zero)))) ->
  ((infix_asdtdt(a, m) = infix_asdtdt(b, m)) -> (a = b))))

logic mat_substr : complex matrix, complex matrix -> complex matrix

axiom mat_substrqtdef :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> (mat_substr(m, n) = add_mat(m,
  infix_asdtdt(prefix_mndt(c_one), n))))))

axiom mat_substrqtspec :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> (rows(mat_substr(m, n)) = rows(m)))))

axiom mat_substrqtspec1 :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> (columns(mat_substr(m, n)) = columns(m)))))

axiom mat_substrqtspec2 :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) ->
  (forall i:int. forall j:int. (((0 <= i) and (i <  rows(m))) ->
  (((0 <= j) and (j <  columns(m))) -> (get(mat_substr(m, n), i,
  j) = infix_mndt(get(m, i, j), get(n, i, j)))))))))

axiom substr_rows :
  (forall m:complex matrix. forall n:complex matrix. forall r:int.
  (((rows(m) = rows(n)) and (rows(n) = r)) -> ((columns(m) = columns(n)) ->
  (rows(mat_substr(m, n)) = r))))

axiom substr_columns :
  (forall m:complex matrix. forall n:complex matrix. forall c:int.
  ((rows(m) = rows(n)) -> (((columns(m) = columns(n)) and
  (columns(n) = c)) -> (columns(mat_substr(m, n)) = c))))

axiom substr_value :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) ->
  (((0 <= i) and (i <  rows(m))) -> (((0 <= j) and (j <  columns(m))) ->
  (get(mat_substr(m, n), i, j) = infix_mndt(get(m, i, j), get(n, i, j))))))))

axiom distr_l_substr :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) ->
  ((columns(m) = rows(o)) -> (mat_mult(mat_substr(m, n),
  o) = mat_substr(mat_mult(m, o), mat_mult(n, o)))))))

axiom distr_r_substr :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(n) = rows(o)) -> ((columns(n) = columns(o)) ->
  ((columns(m) = rows(o)) -> (mat_mult(m, mat_substr(n,
  o)) = mat_substr(mat_mult(m, n), mat_mult(m, o)))))))

axiom mat_substr_eq :
  (forall m:complex matrix. forall mqt:complex matrix.
  forall n:complex matrix. forall nqt:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> ((m = mqt) -> ((n = nqt) -> (mat_substr(m,
  n) = mat_substr(mqt, nqt)))))))

axiom substr_decomp :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> (m = add_mat(n, mat_substr(m, n))))))

axiom subtr_scal :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) -> (infix_asdtdt(a,
  mat_substr(m, n)) = mat_substr(infix_asdtdt(a, m), infix_asdtdt(a, n))))))

axiom subtr_scal_rev :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) ->
  (mat_substr(infix_asdtdt(a, m), infix_asdtdt(a, n)) = infix_asdtdt(a,
  mat_substr(m, n))))))

axiom get_equal_mat_to_substr :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> ((m = n) -> (mat_substr(m, n) = make(rows(m),
  columns(m), c_zero))))))

axiom set_inequal_mat_by_substr :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> ((not (m = n)) -> (not (mat_substr(m,
  n) = make(rows(m), columns(m), c_zero)))))))

axiom set_inequal_mat_by_substr1 :
  (forall m:complex matrix. forall n:complex matrix. ((rows(m) = rows(n)) ->
  ((columns(m) = columns(n)) -> ((not (mat_substr(m, n) = make(rows(m),
  columns(m), c_zero))) -> (not (m = n))))))

axiom pow_inv_2_scal :
  (forall i:int. forall x:complex matrix. ((0 <= i) ->
  (infix_asdtdt(pow_inv_2(i), x) = infix_asdtdt(pow_inv_sqrt_2(i),
  infix_asdtdt(pow_inv_sqrt_2(i), x)))))

axiom pow_inv_2_from_int :
  (forall n:int. ((0 <= n) -> (pow_inv_2(n) = infix_sldt(c_one,
  i_to_c(power(2, n))))))

axiom pow_inv_2_sq_rt :
  (forall n:int. ((0 <= n) -> (square_rt(pow_inv_2(n)) = pow_inv_sqrt_2(n))))

axiom pow_inv_sqrt_2_double :
  (forall n:int. ((0 <= n) -> (pow_inv_sqrt_2((2 * n)) = pow_inv_2(n))))

axiom pos_pow_inv_2 :
  (forall i:int. ((0 <= i) -> infix_lseqdt(c_zero, pow_inv_2(i))))

axiom pos_pow_inv_sqrt_2 :
  (forall i:int. ((0 <= i) -> infix_lseqdt(c_zero, pow_inv_sqrt_2(i))))

axiom strict_pos_pow_inv_2 :
  (forall i:int. ((0 <= i) -> infix_lsdt(c_zero, pow_inv_2(i))))

axiom pow_inv_2_add :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <= j) ->
  (pow_inv_2((i + j)) = infix_asdt(pow_inv_2(i), pow_inv_2(j))))))

axiom pow_inv_2_plus_one :
  (forall i:int. ((0 <= i) ->
  (pow_inv_2((i + 1)) = infix_asdt(infix_sldt(c_one, infix_pldt(c_one,
  c_one)), pow_inv_2(i)))))

axiom pow_inv_2_plus_one_rev :
  (forall i:int. ((0 <= i) -> (infix_asdt(infix_sldt(c_one, infix_pldt(c_one,
  c_one)), pow_inv_2(i)) = pow_inv_2((i + 1)))))

axiom pow_inv_2_with_ :
  (forall i:int. ((0 <= i) -> (pow_inv_2(i) = infix_sldt(c_one,
  i_to_c(power(2, i))))))

axiom pow_inv_2_to_one :
  (forall i:int. ((0 <= i) -> (infix_asdt(i_to_c(power(2, i)),
  pow_inv_2(i)) = c_one)))

axiom pow_inv_2_one :
  (forall i:int. ((i = 1) -> (i_to_c(power(2, i)) = infix_pldt(c_one,
  c_one))))

axiom pow_inv_2_to_one_gen :
  (forall i:int. forall x:complex. ((0 <= i) -> ((x = i_to_c(power(2, i))) ->
  (infix_asdt(pow_inv_2(i), x) = c_one))))

axiom pow_inv_to_pow_2 :
  (forall k:int. forall l:int. ((0 <= l) -> ((l <= k) ->
  (infix_asdt(pow_inv_2(k), i_to_c(power(2, l))) = pow_inv_2((k - l))))))

logic neg_pow_inv_sqrt_2 : int -> complex

axiom neg_pow_inv_sqrt_2qtdef :
  (forall i:int. ((0 <= i) ->
  (neg_pow_inv_sqrt_2(i) = cpower(infix_sldt(prefix_mndt(c_one),
  square_rt(infix_pldt(c_one, c_one))), i))))

axiom inv_pow_inv_sqrt_2 : (infix_asdt(pow_inv_sqrt_2(1),
  square_rt(infix_pldt(c_one, c_one))) = c_one)

axiom pow_inv_sqrt_2_values :
  (forall i:int. ((0 <= i) -> (pow_inv_sqrt_2(i) = infix_sldt(c_one,
  cpower(square_rt(infix_pldt(c_one, c_one)), i)))))

axiom neg_pow_inv_sqrt_2_values :
  (forall i:int. ((0 <= i) -> (neg_pow_inv_sqrt_2(i) = infix_asdt(mop(i),
  infix_sldt(c_one, cpower(square_rt(infix_pldt(c_one, c_one)), i))))))

axiom ppos_neg_coeff_values :
  (forall i:int. ((0 <= i) -> ((even(i) = true) ->
  (pow_inv_sqrt_2(i) = neg_pow_inv_sqrt_2(i)))))

axiom ppos_neg_coeff_values1 :
  (forall i:int. ((0 <= i) -> ((odd(i) = true) ->
  (pow_inv_sqrt_2(i) = prefix_mndt(neg_pow_inv_sqrt_2(i))))))

axiom ppos_neg_coeff_values2 :
  (forall i:int. ((0 <= i) -> (neg_pow_inv_sqrt_2(i) = infix_asdt(mop(i),
  pow_inv_sqrt_2(i)))))

logic pow_inv_sqrt_2_neg : int -> complex

axiom pow_inv_sqrt_2_negqtdef :
  (forall i:int. ((0 <= i) ->
  (pow_inv_sqrt_2_neg(i) = prefix_mndt(pow_inv_sqrt_2(i)))))

axiom int_to_ang_to_real_to_ang :
  (forall theta:angle. forall k:int. forall n:int. ((0 <= n) ->
  ((theta = infix_sldtsl(k, n)) -> (theta = real_to_ang(infix_asdt(i_to_c(k),
  pow_inv_2(n)))))))

axiom real_to_ang_to_int_to_ang :
  (forall k:int. forall n:int. ((0 <= n) ->
  (real_to_ang(infix_asdt(i_to_c(k), pow_inv_2(n))) = infix_sldtsl(k, n))))

axiom real_to_ang_to_int_to_ang_add :
  (forall k:int. forall kqt:int. forall n:int. ((0 <= n) ->
  (real_to_ang(infix_asdt(infix_pldt(i_to_c(k), i_to_c(kqt)),
  pow_inv_2(n))) = infix_sldtsl((k + kqt), n))))

axiom int_to_ang_to_real_to_ang_gen :
  (forall k:int. forall n:int. forall kx:complex. ((0 <= n) ->
  ((kx = i_to_c(k)) -> (infix_sldtsl(k, n) = real_to_ang(infix_asdt(kx,
  pow_inv_2(n)))))))

axiom Int_To_Ang_inv :
  (forall k:int. forall n:int. (ang_inv(infix_sldtsl(k,
  n)) = infix_sldtsl((-k), n)))

axiom Int_To_Ang_inv_add :
  (forall k:int. forall n:int. (ang_add(infix_sldtsl(k, n),
  infix_sldtsl((-k), n)) = ang_zero))

axiom Int_To_Ang_add :
  (forall k:int. forall kqt:int. forall n:int. (ang_add(infix_sldtsl(k, n),
  infix_sldtsl(kqt, n)) = infix_sldtsl((k + kqt), n)))

axiom Int_To_Ang_up :
  (forall k:int. forall n:int. ((0 <= n) -> (infix_sldtsl(k,
  n) = infix_sldtsl((2 * k), (n + 1)))))

axiom Int_To_Ang_cyclic :
  (forall k:int. forall n:int. ((0 <= n) -> (infix_sldtsl(k,
  n) = infix_sldtsl((k + power(2, n)), n))))

axiom Zero_n : (forall n:int. (infix_sldtsl(0, n) = ang_zero))

axiom set_ang_minus_one_by_int :
  (forall a:int. forall b:int. ((a = 1) -> ((b = 1) -> (infix_sldtsl(a,
  b) = infix_sldtsl(1, 1)))))

axiom ang_minus_one_from_real : (infix_sldtsl(1,
  1) = real_to_ang(infix_sldt(c_one, infix_pldt(c_one, c_one))))

axiom ang_exp_minus_one : (ang_exp(infix_sldtsl(1, 1)) = prefix_mndt(c_one))

axiom set_ang_zero_by_int :
  (forall a:int. forall b:int. ((a = 0) -> ((0 <= b) -> (infix_sldtsl(a,
  b) = ang_zero))))

axiom ang_minus_one_twice :
  (forall a1:angle. forall a2:angle. ((a1 = infix_sldtsl(1, 1)) ->
  ((a2 = infix_sldtsl(1, 1)) -> (ang_add(a1, a2) = ang_zero))))

function div_two(d: angle) : angle = real_to_ang(infix_sldt(ang_meas(d),
  infix_pldt(c_one, c_one)))

axiom div_twoqtspec :
  (forall d:angle. (ang_meas(div_two(d)) = infix_sldt(ang_meas(d),
  infix_pldt(c_one, c_one))))

axiom div_twoqtspec1 :
  (forall d:angle. (ang_add(div_two(d), div_two(d)) = d))

axiom Div_two : (forall d:angle. (ang_add(div_two(d), div_two(d)) = d))

axiom div_two_int_to_ang :
  (forall k:int. forall n:int. ((0 <= n) -> (((0 <= k) and (k <  power(2,
  n))) -> (div_two(infix_sldtsl(k, n)) = infix_sldtsl(k, (n + 1))))))

axiom ang_exp_mult :
  (forall x:angle. forall xqt:angle. (infix_asdt(ang_exp(x),
  ang_exp(xqt)) = ang_exp(ang_add(x, xqt))))

axiom ang_exp_modulus : (forall x:angle. (modulus(ang_exp(x)) = c_one))

axiom ang_exp_not_one :
  (forall i:complex. ((infix_lsdt(c_zero, i) and infix_lsdt(i, c_one)) ->
  (not (ang_exp(real_to_ang(i)) = c_one))))

axiom ang_exp_not_by_modulus :
  (forall i:complex. ((infix_lsdt(c_zero, i) and infix_lsdt(i, c_one)) ->
  (not (ang_exp(real_to_ang(modulus(i))) = c_one))))

logic k_int_to_ang : int -> angle

axiom k_int_to_angqtdef :
  (forall k:int. ((0 <= k) -> (k_int_to_ang(k) = infix_sldtsl(1, k))))

axiom K_int_to_angplus_one :
  (forall k:int. ((0 <  k) -> (ang_add(k_int_to_ang(k),
  k_int_to_ang(k)) = k_int_to_ang((k - 1)))))

logic phase_inv_pre : int, angle -> angle

axiom phase_inv_preqtdef :
  (forall i:int. forall d:angle. ((0 <= i) -> ((i = 0) -> (phase_inv_pre(i,
  d) = d))))

axiom phase_inv_preqtdef1 :
  (forall i:int. forall d:angle. ((0 <= i) -> ((not (i = 0)) ->
  (phase_inv_pre(i, d) = ang_inv(phase_inv_pre((i - 1), d))))))

axiom phase_inv_preqtspec :
  (forall i:int. forall d:angle. ((0 <= i) -> (((i % 2) = 0) ->
  (phase_inv_pre(i, d) = d))))

axiom phase_inv_preqtspec1 :
  (forall i:int. forall d:angle. ((0 <= i) -> (((i % 2) = 1) ->
  (phase_inv_pre(i, d) = ang_inv(d)))))

function phase_inv_(i: int, d: angle) : angle =
  (if (0 <= i) then phase_inv_pre(i, d) else phase_inv_pre((-i), d))

axiom phase_inv_qtspec :
  (forall i:int. forall d:angle. (((i % 2) = 0) -> (phase_inv_(i, d) = d)))

axiom phase_inv_qtspec1 :
  (forall i:int. forall d:angle. (((i % 2) = 1) -> (phase_inv_(i,
  d) = ang_inv(d))))

axiom infix_mncfqtspec :
  (forall d:angle. forall i:int. (((i % 2) = 0) -> (phase_inv_(i, d) = d)))

axiom infix_mncfqtspec1 :
  (forall d:angle. forall i:int. (((i % 2) = 1) -> (phase_inv_(i,
  d) = ang_inv(d))))

axiom Even_phase_inv :
  (forall d:angle. (forall i:int. (((i % 2) = 0) -> (phase_inv_(i, d) = d))))

axiom Odd_phase_inv :
  (forall d:angle.
  (forall i:int. (((i % 2) = 1) -> (phase_inv_(i, d) = ang_inv(d)))))

axiom Gen_phase_inv :
  (forall k:int. forall n:int. forall i:int. ((0 <= n) -> ((0 <= i) ->
  (phase_inv_(i, infix_sldtsl(k, n)) = infix_sldtsl((power((- 1), i) * k),
  n)))))

axiom Gen_phase_inv_neg :
  (forall k:int. forall n:int. forall i:int. ((0 <= n) -> ((i <  0) ->
  (phase_inv_(i, infix_sldtsl(k, n)) = infix_sldtsl((power((- 1), (-i)) * k),
  n)))))

axiom Ang_exp_inv :
  (forall o:angle. (ang_exp(ang_inv(o)) = infix_sldt(c_one, ang_exp(o))))

axiom ang_inv_to_conjugate :
  (forall o:angle. (ang_exp(ang_inv(o)) = conjugate(ang_exp(o))))

axiom exp_minus :
  (forall x:complex. (real_(x) -> (exp(infix_asdt(im,
  prefix_mndt(x))) = conjugate(exp(infix_asdt(im, x))))))

axiom conjugate_to_ang_inv :
  (forall o:angle. (conjugate(ang_exp(o)) = ang_exp(ang_inv(o))))

axiom conjugate_inv_elim :
  (forall o:angle. (conjugate(ang_exp(ang_inv(o))) = ang_exp(o)))

axiom ang_exp_neg_conjugate :
  (forall x:complex. (real_(x) ->
  (ang_exp(real_to_ang(prefix_mndt(x))) = conjugate(ang_exp(real_to_ang(x))))))

axiom ang_exp_neg_conjugate_rev :
  (forall x:complex. (real_(x) ->
  (conjugate(ang_exp(real_to_ang(x))) = ang_exp(real_to_ang(prefix_mndt(x))))))

axiom ang_mult_int_in :
  (forall i:int. forall k:int. forall n:int. (ang_mult_int(infix_sldtsl(k,
  n), i) = infix_sldtsl((i * k), n)))

axiom ang_mult_int_out :
  (forall i:int. forall k:int. forall n:int. ((0 <= n) ->
  (infix_sldtsl((i * k), n) = ang_mult_int(infix_sldtsl(k, n), i))))

axiom int_to_ang_cycles :
  (forall k:int. forall n:int. forall i:int. ((0 <= n) -> ((0 <= i) ->
  (infix_sldtsl((k + (i * power(2, n))), n) = infix_sldtsl(k, n)))))

axiom int_to_ang_eq :
  (forall k1:int. forall k2:int. forall n1:int. forall n2:int. ((k1 = k2) ->
  ((n1 = n2) -> (infix_sldtsl(k1, n1) = infix_sldtsl(k2, n2)))))

axiom int_to_ang_cycles_neg :
  (forall k:int. forall n:int. forall i:int. ((0 <= n) -> ((i <= 0) ->
  (infix_sldtsl((k + (i * power(2, n))), n) = infix_sldtsl(k, n)))))

axiom int_to_ang_cycles_gen :
  (forall k:int. forall n:int. forall i:int. ((0 <= n) ->
  (infix_sldtsl((k + (i * power(2, n))), n) = infix_sldtsl(k, n))))

axiom int_to_ang_cycles_zero :
  (forall nqt:int. forall n:int. (((0 <= n) and (n <= nqt)) ->
  (infix_sldtsl(power(2, nqt), n) = ang_zero)))

axiom int_to_ang_cycles_zero_mult :
  (forall k:int. forall nqt:int. forall n:int. (((0 <= n) and (n <= nqt)) ->
  (infix_sldtsl((k * power(2, nqt)), n) = ang_zero)))

axiom int_to_ang_cycles_zero_mult_ :
  (forall k:int. forall nqt:int. forall n:int. (((0 <= n) and (n <= nqt)) ->
  (infix_sldtsl((k * power(2, nqt)), n) = ang_zero)))

axiom int_to_ang_up :
  (forall k:int. forall n:int. forall nqt:int. ((0 <= n) -> ((0 <= nqt) ->
  (infix_sldtsl((k * power(2, nqt)), (n + nqt)) = infix_sldtsl(k, n)))))

axiom int_to_ang_mod :
  (forall k:int. forall n:int. ((0 <= n) -> (infix_sldtsl(k,
  n) = infix_sldtsl((k % power(2, n)), n))))

axiom int_to_ang_equiv :
  (forall k1:int. forall k2:int. forall n1:int. forall n2:int. ((0 <= n1) ->
  (((k1 % power(2, n1)) = (k2 % power(2, n1))) -> ((n1 = n2) ->
  (infix_sldtsl(k1, n1) = infix_sldtsl(k2, n2))))))

axiom int_to_ang_red :
  (forall k:int. forall n:int. ((1 <= n) -> ((not (0 = k)) ->
  (((k % 2) = 0) -> (infix_sldtsl(k, n) = infix_sldtsl((k / 2), (n - 1)))))))

axiom int_to_ang_bin_rev :
  (forall n:int. forall i:int. forall j:int. ((0 <= n) -> ((0 <= i) ->
  ((j = (n - 1)) -> (infix_sldtsl((-(i * power(2, j))),
  n) = infix_sldtsl((i * power(2, (n - 1))), n))))))

axiom int_to_ang_bin_rev_ :
  (forall n:int. forall i:int. forall j:int. ((0 <= n) -> ((0 <= i) ->
  ((j = (n - 1)) -> (infix_sldtsl((-(i * power(2, j))),
  n) = infix_sldtsl((i * power(2, (n - 1))), n))))))

axiom int_to_ang_add_rev :
  (forall i:int. forall j:int. forall n:int. ((0 <= n) ->
  (infix_sldtsl((i + j), n) = ang_add(infix_sldtsl(i, n), infix_sldtsl(j,
  n)))))

axiom int_to_ang_ind_isum_plus_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall n:int.
  ((i <  j) -> ((0 <= n) -> (infix_sldtsl(ind_isum(f, i, j),
  n) = ang_add(infix_sldtsl((f[i]), n), infix_sldtsl(ind_isum(f, (i + 1), j),
  n))))))

axiom int_to_ang_ind_isum_plus_one_rev :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall n:int.
  ((i <  j) -> ((0 <= n) -> (infix_sldtsl(ind_isum(f, i, j),
  n) = ang_add(infix_sldtsl(ind_isum(f, (i + 1), j), n), infix_sldtsl((f[i]),
  n))))))

axiom int_to_ang_ind_isum_right_extension :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall n:int.
  ((i <  j) -> ((0 <= n) -> (infix_sldtsl(ind_isum(f, i, j),
  n) = ang_add(infix_sldtsl(ind_isum(f, i, (j - 1)), n),
  infix_sldtsl((f[(j - 1)]), n))))))

axiom int_to_ang_ind_isum_right_extension_rev :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall n:int.
  ((i <  j) -> ((0 <= n) -> (infix_sldtsl(ind_isum(f, i, j),
  n) = ang_add(infix_sldtsl((f[(j - 1)]), n), infix_sldtsl(ind_isum(f, i,
  (j - 1)), n))))))

axiom minus_int_to_ang_ind_isum_plus_one :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall n:int.
  ((i <  j) -> ((0 <= n) -> (infix_sldtsl((-ind_isum(f, i, j)),
  n) = ang_add(infix_sldtsl((-(f[i])), n), infix_sldtsl((-ind_isum(f,
  (i + 1), j)), n))))))

axiom minus_int_to_ang_ind_isum_plus_one_rev :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall n:int.
  ((i <  j) -> ((0 <= n) -> (infix_sldtsl((-ind_isum(f, i, j)),
  n) = ang_add(infix_sldtsl((-ind_isum(f, (i + 1), j)), n),
  infix_sldtsl((-(f[i])), n))))))

axiom minus_int_to_ang_ind_isum_right_extension :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall n:int.
  ((i <  j) -> ((0 <= n) -> (infix_sldtsl((-ind_isum(f, i, j)),
  n) = ang_add(infix_sldtsl((-ind_isum(f, i, (j - 1))), n),
  infix_sldtsl((-(f[(j - 1)])), n))))))

axiom minus_int_to_ang_ind_isum_right_extension_rev :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall n:int.
  ((i <  j) -> ((0 <= n) -> (infix_sldtsl((-ind_isum(f, i, j)),
  n) = ang_add(infix_sldtsl((-(f[(j - 1)])), n), infix_sldtsl((-ind_isum(f,
  i, (j - 1))), n))))))

axiom int_to_ang_simpl :
  (forall k:int. forall n1:int. forall n2:int. ((0 <= n1) -> ((0 <= n2) ->
  (infix_sldtsl((k * power(2, n1)), (n2 + n1)) = infix_sldtsl(k, n2)))))

axiom ang_add_eq :
  (forall d1:angle. forall d2:angle. forall e1:angle. forall e2:angle.
  ((d1 = e1) -> ((d2 = e2) -> (ang_add(d1, d2) = ang_add(e1, e2)))))

axiom ang_add_comm :
  (forall d1:angle. forall d2:angle. (ang_add(d1, d2) = ang_add(d2, d1)))

axiom ang_add_eq_comm :
  (forall d1:angle. forall d2:angle. forall d3:angle. forall d4:angle.
  ((d1 = d3) -> ((d2 = d4) -> (ang_add(d1, d2) = ang_add(d4, d3)))))

axiom ang_add_switch :
  (forall a:angle. forall b:angle. forall c:angle. forall d:angle.
  (ang_add(ang_add(a, b), ang_add(c, d)) = ang_add(ang_add(a, c), ang_add(b,
  d))))

axiom ang_mult_int_zero :
  (forall theta:angle. (ang_mult_int(theta, 0) = ang_zero))

axiom ang_div :
  (forall k:int. forall n:int. forall i:int. ((0 <= n) -> ((0 <= i) ->
  (infix_sldtsl(k, n) = ang_mult_int(infix_sldtsl(k, (n + i)), power(2,
  i))))))

axiom ang_zero_add :
  (forall dqt:angle. forall d:angle. ((dqt = ang_zero) -> (ang_add(dqt,
  d) = d)))

axiom int_to_ang_rev :
  (forall k:int. forall l:int. forall n:int. forall m:int. ((0 <  n) ->
  ((0 <= k) -> ((n = (m + 1)) -> (infix_sldtsl((((-k) * l) * power(2, m)),
  n) = infix_sldtsl(((k * l) * power(2, m)), n))))))

axiom int_to_ang_rev_ :
  (forall k:int. forall l:int. forall n:int. forall m:int. ((0 <  n) ->
  ((0 <= k) -> ((0 <= l) -> ((n = (m + 1)) ->
  (infix_sldtsl((((-k) * l) * power(2, m)),
  n) = infix_sldtsl(((k * l) * power(2, m)), n)))))))

axiom ang_add_zero_d :
  (forall dqt:angle. forall d:angle. ((dqt = ang_zero) -> (ang_add(d,
  dqt) = d)))

axiom real_to_ang_distr_minus :
  (forall x:complex. forall z:complex. forall t:complex.
  (forall y:int. (real_(x) -> (real_(z) -> (real_(t) ->
  (ang_add(real_to_ang(infix_asdt(x, i_to_c(y))),
  real_to_ang(infix_asdt(infix_asdt(i_to_c(y), prefix_mndt(z)),
  t))) = ang_mult_int(real_to_ang(infix_mndt(x, infix_asdt(z, t))), y)))))))

axiom ang_mult_int_exp_pos :
  (forall o:angle. forall i:int. ((0 <= i) -> (ang_exp(ang_mult_int(o,
  i)) = cpower(ang_exp(o), i))))

axiom ang_mult_int_exp :
  (forall o:angle. forall i:int. (ang_exp(ang_mult_int(o,
  i)) = cpower(ang_exp(o), i)))

axiom ang_mult_int_exp_rev :
  (forall o:angle. forall i:int. (cpower(ang_exp(o),
  i) = ang_exp(ang_mult_int(o, i))))

axiom cpower_ang_exp_real :
  (forall x:complex. forall i:int. (real_(x) ->
  (cpower(ang_exp(real_to_ang(x)), i) = ang_exp(real_to_ang(infix_asdt(x,
  i_to_c(i)))))))

axiom ang_mult_int_add :
  (forall o:angle. forall i:int. forall iqt:int. (ang_mult_int(o,
  (i + iqt)) = ang_add(ang_mult_int(o, i), ang_mult_int(o, iqt))))

axiom ang_mult_int_plus_one :
  (forall o:angle. forall i:int. (ang_add(o, ang_mult_int(o,
  i)) = ang_mult_int(o, (i + 1))))

axiom ang_mult_int_plus_one_rev :
  (forall o:angle. forall i:int. (ang_mult_int(o, (1 + i)) = ang_add(o,
  ang_mult_int(o, i))))

axiom ang_mult_int_double :
  (forall o:angle. forall i:int. (ang_mult_int(o,
  (2 * i)) = ang_add(ang_mult_int(o, i), ang_mult_int(o, i))))

axiom ang_mult_int_inv_one :
  (forall o:angle. (ang_mult_int(o, (- 1)) = ang_inv(o)))

axiom ang_mult_int_one :
  (forall o:angle. forall n:int. ((n = 1) -> (ang_mult_int(o, n) = o)))

axiom ang_mult_int_inv_rev :
  (forall o:angle. (ang_inv(o) = ang_mult_int(o, (- 1))))

axiom ang_mult_int_comp :
  (forall o:angle. forall i:int. forall j:int. (ang_mult_int(ang_mult_int(o,
  i), j) = ang_mult_int(o, (i * j))))

axiom ang_mult_int_comp_rev :
  (forall o:angle. forall i:int. forall j:int. (ang_mult_int(o,
  (i * j)) = ang_mult_int(ang_mult_int(o, i), j)))

axiom add_ang_mult_int_pos :
  (forall o:angle. forall oqt:angle. forall i:int. ((0 <= i) ->
  (ang_add(ang_mult_int(o, i), ang_mult_int(oqt,
  i)) = ang_mult_int(ang_add(o, oqt), i))))

axiom add_ang_mult_int :
  (forall o:angle. forall oqt:angle. forall i:int. (ang_add(ang_mult_int(o,
  i), ang_mult_int(oqt, i)) = ang_mult_int(ang_add(o, oqt), i)))

function ang_substr(o: angle, oqt: angle) : angle = ang_add(o, ang_inv(oqt))

axiom ang_substr_inv :
  (forall o:angle. forall oqt:angle. (ang_substr(o, ang_mult_int(oqt,
  (- 1))) = ang_add(o, oqt)))

axiom ang_mult_int_distr :
  (forall o:angle. forall oqt:angle. forall n:int. (ang_mult_int(ang_add(o,
  oqt), n) = ang_add(ang_mult_int(o, n), ang_mult_int(oqt, n))))

axiom ang_mult_int_distr_rev :
  (forall o:angle. forall n1:int. forall n2:int. (ang_add(ang_mult_int(o,
  n1), ang_mult_int(o, n2)) = ang_mult_int(o, (n1 + n2))))

axiom ang_add_assoc :
  (forall o:angle. forall oqt:angle. forall oqtqt:angle. (ang_add(o,
  ang_add(oqt, oqtqt)) = ang_add(ang_add(o, oqt), oqtqt)))

axiom ang_add_assoc_rev :
  (forall o:angle. forall oqt:angle. forall oqtqt:angle. (ang_add(ang_add(o,
  oqt), oqtqt) = ang_add(o, ang_add(oqt, oqtqt))))

axiom ang_add_own_inv :
  (forall o:angle. (ang_add(ang_mult_int(o, (- 1)), o) = ang_zero))

axiom ang_exp_inv :
  (forall o:angle. (ang_exp(ang_inv(o)) = conjugate(ang_exp(o))))

axiom ang_exp_one_one : (ang_exp(infix_sldtsl(1, 1)) = prefix_mndt(c_one))

axiom int_to_ang_one_even :
  (forall k:int. ((even(k) = true) -> (infix_sldtsl(k, 1) = ang_zero)))

axiom int_to_ang_one_odd :
  (forall k:int. ((odd(k) = true) -> (infix_sldtsl(k, 1) = infix_sldtsl(1,
  1))))

axiom ang_exp_one_one_expo :
  (forall i:int. ((0 <= i) -> (ang_exp(ang_mult_int(infix_sldtsl(1, 1),
  i)) = (if (even(i) = true) then c_one else prefix_mndt(c_one)))))

axiom int_to_ang_zero_den :
  (forall k:int. forall n:int. ((n = 0) -> (infix_sldtsl(k, n) = ang_zero)))

axiom int_to_ang_minus_up :
  (forall k:int. forall n:int. (infix_sldtsl(k, (-n)) = infix_sldtsl((-k),
  n)))

axiom int_to_ang_minus_down :
  (forall k:int. forall n:int. (infix_sldtsl((-k), (-n)) = infix_sldtsl(k,
  n)))

axiom int_to_ang_inv :
  (forall k:int. forall n:int. (ang_inv(infix_sldtsl(k, n)) = infix_sldtsl(k,
  (-n))))

axiom int_to_ang_inv_rev :
  (forall k:int. forall n:int. (infix_sldtsl(k,
  (-n)) = ang_inv(infix_sldtsl(k, n))))

axiom int_to_ang_inv_add :
  (forall k:int. forall n:int. (ang_add(infix_sldtsl(k, n), infix_sldtsl(k,
  (-n))) = ang_zero))

axiom ang_mult_int_neutral :
  (forall theta:angle. forall n:int. ((theta = ang_zero) ->
  (ang_mult_int(theta, n) = ang_zero)))

axiom phase_inv_neutral :
  (forall theta:angle. forall n:int. ((theta = ang_zero) -> (phase_inv_(n,
  theta) = ang_zero)))

predicate binary(t: (int,int) farray) =
  (forall k:int. ((0 <= (t[k])) and ((t[k]) <  2)))

predicate binary_l(t: (int,int) farray, l: int) =
  (forall k:int. (((0 <= k) and (k <  l)) -> ((0 <= (t[k])) and
  ((t[k]) <  2))))

axiom set_binary_l :
  (forall t:(int,int) farray. forall l:int.
  ((forall k:int. (((0 <= k) and (k <  l)) -> ((0 <= (t[k])) and
   ((t[k]) <  2)))) ->
  binary_l(t, l)))

axiom get_binary_l :
  (forall t:(int,int) farray. forall l:int. (binary_l(t, l) ->
  (forall k:int. (((0 <= k) and (k <  l)) -> (0 <= (t[k]))))))

axiom get_binary_l1 :
  (forall t:(int,int) farray. forall l:int. (binary_l(t, l) ->
  (forall k:int. (((0 <= k) and (k <  l)) -> ((t[k]) <  2)))))

axiom get_binary_one :
  (forall t:(int,int) farray. forall k:int. forall l:int. (binary_l(t, l) ->
  (((0 <= k) and (k <  l)) -> ((not ((t[k]) = 0)) -> ((t[k]) = 1)))))

axiom get_binary_zero :
  (forall t:(int,int) farray. forall k:int. forall l:int. (binary_l(t, l) ->
  (((0 <= k) and (k <  l)) -> ((not ((t[k]) = 1)) -> ((t[k]) = 0)))))

axiom binary_is_binary_l :
  (forall t:(int,int) farray. forall l:int. (binary(t) -> binary_l(t, l)))

axiom binary_leq :
  (forall t:(int,int) farray. forall k:int. forall l:int. ((l <= k) ->
  (binary_l(t, k) -> binary_l(t, l))))

axiom set_binary :
  (forall t:(int,int) farray.
  ((forall k:int. ((0 <= (t[k])) and ((t[k]) <  2))) -> binary(t)))

axiom get_binary :
  (forall t:(int,int) farray. (binary(t) -> (forall k:int. (0 <= (t[k])))))

axiom get_binary1 :
  (forall t:(int,int) farray. (binary(t) -> (forall k:int. ((t[k]) <  2))))

function shift(f: (int,'a) farray, i: int, k: int) : 'a = (f[(k + i)])

axiom shift_value :
  (forall f:(int,'a) farray. forall i:int. forall k:int. (shift(f, i,
  k) = (f[(k + i)])))

axiom shiftz :
  (forall f:(int,'a) farray. forall k:int. (shift(f, 0, k) = (f[k])))

axiom shiftz_gen :
  (forall f:(int,'a) farray. forall i:int. forall k:int. ((i = 0) ->
  (shift(f, i, k) = (f[k]))))

logic shift_closure : ((int,'a) farray,(int,(int,'a) farray) farray) farray

axiom shift_closure_def :
  (forall y:(int,'a) farray. forall y1:int. forall y2:int.
  (((((shift_closure : ((int,'a) farray,(int,(int,'a) farray) farray) farray)[y])[y1])[y2]) = shift(y,
  y1, y2)))

axiom shiftz_quant :
  (forall f:(int,'a) farray.
  ((((shift_closure : ((int,'a) farray,(int,(int,'a) farray) farray) farray)[f])[0]) = f))

axiom shiftz_quant_rev :
  (forall f:(int,'a) farray.
  (f = (((shift_closure : ((int,'a) farray,(int,(int,'a) farray) farray) farray)[f])[0])))

function concat_fun(f: (int,'a) farray, g: (int,'a) farray, i: int,
  k: int) : 'a = (if (k <  i) then (f[k]) else (g[(k - i)]))

axiom shift_add :
  (forall f:(int,'a) farray. forall i:int. forall j:int. forall k:int.
  (shift((((shift_closure : ((int,'a) farray,(int,(int,'a) farray) farray) farray)[f])[j]),
  i, k) = shift(f, (i + j), k)))

axiom concat_fun_value :
  (forall f:(int,'a) farray. forall g:(int,'a) farray. forall i:int.
  forall k:int. (concat_fun(f, g, i,
  k) = (if (k <  i) then (f[k]) else (g[(k - i)]))))

axiom concat_eq :
  (forall f1:(int,'a) farray. forall g1:(int,'a) farray.
  forall f2:(int,'a) farray. forall g2:(int,'a) farray. forall i1:int.
  forall i2:int. forall k:int.
  ((forall l:int. ((l <  i1) -> ((f1[l]) = (f2[l])))) ->
  ((forall l:int. ((0 <= l) -> ((g1[l]) = (g2[l])))) -> ((i1 = i2) ->
  (concat_fun(f1, g1, i1, k) = concat_fun(f2, g2, i2, k))))))

logic mod_func : (int,'a) farray, int, int -> 'a

axiom mod_funcqtdef :
  (forall f:(int,'a) farray. forall k:int. forall i:int. ((0 <  k) ->
  (mod_func(f, k, i) = (f[(i % k)]))))

axiom mod_func_inf :
  (forall f:(int,'a) farray. forall k:int. forall i:int. ((0 <  k) ->
  (((0 <= i) and (i <  k)) -> (mod_func(f, k, i) = (f[i])))))

logic mod_func_closure : ((int,'a) farray,(int,(int,'a) farray) farray) farray

axiom mod_func_closure_def :
  (forall y:(int,'a) farray. forall y1:int. forall y2:int.
  (((((mod_func_closure : ((int,'a) farray,(int,(int,'a) farray) farray) farray)[y])[y1])[y2]) = mod_func(y,
  y1, y2)))

axiom shift_mod :
  (forall f:(int,'a) farray. forall k:int. forall i:int. ((0 <  k) ->
  (mod_func(f, k,
  i) = shift((((mod_func_closure : ((int,'a) farray,(int,(int,'a) farray) farray) farray)[f])[k]),
  k, i))))

axiom shift_mod_rev :
  (forall f:(int,'a) farray. forall k:int. forall i:int. ((0 <  k) ->
  (shift((((mod_func_closure : ((int,'a) farray,(int,(int,'a) farray) farray) farray)[f])[k]),
  k, i) = mod_func(f, k, i))))

logic head_bit : int, int -> int

axiom head_bitqtdef :
  (forall i:int. forall k:int. ((0 <  k) -> (((0 <= i) and (i <  power(2,
  k))) -> (head_bit(i, k) = (i / power(2, (k - 1)))))))

axiom head_bitqtspec :
  (forall i:int. forall k:int. ((0 <  k) -> (((0 <= i) and (i <  power(2,
  k))) -> (0 <= head_bit(i, k)))))

axiom head_bitqtspec1 :
  (forall i:int. forall k:int. ((0 <  k) -> (((0 <= i) and (i <  power(2,
  k))) -> (head_bit(i, k) <= 1))))

logic tail_bits : int, int -> int

axiom tail_bitsqtdef :
  (forall i:int. forall k:int. ((0 <  k) -> (((0 <= i) and (i <  power(2,
  k))) -> (tail_bits(i, k) = (i % power(2, (k - 1)))))))

axiom tail_bitsqtspec :
  (forall i:int. forall k:int. ((0 <  k) -> (((0 <= i) and (i <  power(2,
  k))) -> (0 <= tail_bits(i, k)))))

axiom tail_bitsqtspec1 :
  (forall i:int. forall k:int. ((0 <  k) -> (((0 <= i) and (i <  power(2,
  k))) -> (tail_bits(i, k) <= power(2, (k - 1))))))

logic ht_to_int : int, int, int -> int

axiom ht_to_intqtdef :
  (forall hi:int. forall ti:int. forall k:int. ((0 <  k) -> (((0 <= hi) and
  (hi <  2)) -> (((0 <= ti) and (ti <  power(2, (k - 1)))) -> (ht_to_int(hi,
  ti, k) = ((hi * power(2, (k - 1))) + ti))))))

axiom head_tail_inv :
  (forall i:int. forall k:int. ((0 <  k) -> (((0 <= i) and (i <  power(2,
  k))) -> (ht_to_int(head_bit(i, k), tail_bits(i, k), k) = i))))

axiom ht_to_int_head :
  (forall i:int. forall ti:int. forall k:int. ((0 <  k) -> (((0 <= i) and
  (i <  power(2, k))) -> (((0 <= ti) and (ti <  power(2, (k - 1)))) ->
  (head_bit(ht_to_int(head_bit(i, k), ti, k), k) = head_bit(i, k))))))

axiom ht_to_int_tail :
  (forall hi:int. forall i:int. forall k:int. ((0 <  k) -> (((0 <= i) and
  (i <  power(2, k))) -> (((0 <= hi) and (hi <  2)) ->
  (tail_bits(ht_to_int(hi, tail_bits(i, k), k), k) = tail_bits(i, k))))))

axiom concat_fun_bin_i :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall k:int. (binary(f) -> (binary(g) -> (0 <= concat_fun(f, g, i, k)))))

axiom concat_fun_bin_i1 :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  forall k:int. (binary(f) -> (binary(g) -> (concat_fun(f, g, i, k) <  2))))

axiom shift_bin_i :
  (forall f:(int,int) farray. forall i:int. forall k:int. (binary(f) ->
  (0 <= shift(f, i, k))))

axiom shift_bin_i1 :
  (forall f:(int,int) farray. forall i:int. forall k:int. (binary(f) ->
  (shift(f, i, k) <  2)))

logic concat_fun_closure : ((int,'a) farray,((int,'a) farray,(int,(int,'a) farray) farray) farray) farray

axiom concat_fun_closure_def :
  (forall y:(int,'a) farray. forall y1:(int,'a) farray. forall y2:int.
  forall y3:int.
  ((((((concat_fun_closure : ((int,'a) farray,((int,'a) farray,(int,(int,'a) farray) farray) farray) farray)[y])[y1])[y2])[y3]) = concat_fun(y,
  y1, y2, y3)))

axiom concat_fun_bin :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall i:int.
  (binary(f) -> (binary(g) ->
  binary(((((concat_fun_closure : ((int,int) farray,((int,int) farray,(int,(int,int) farray) farray) farray) farray)[f])[g])[i])))))

axiom mod_func_bin :
  (forall f:(int,int) farray. forall k:int. ((0 <  k) -> (binary(f) ->
  binary((((mod_func_closure : ((int,int) farray,(int,(int,int) farray) farray) farray)[f])[k])))))

axiom shift_bin :
  (forall f:(int,int) farray. forall i:int. (binary(f) ->
  binary((((shift_closure : ((int,int) farray,(int,(int,int) farray) farray) farray)[f])[i]))))

logic fc121 : (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef121 :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall x:int.
  ((fc121(f, g)[x]) = (f[(g[x])])))

axiom binary_comp :
  (forall f:(int,int) farray. forall g:(int,int) farray. (binary(f) ->
  binary(fc121(f, g))))

axiom set_is_all_binary :
  (forall t:(int,int) farray.
  ((forall k:int. ((0 <= (t[k])) and ((t[k]) <  2))) -> binary(t)))

logic nary_length : int, int -> int

axiom nary_lengthqtspec :
  (forall i:int. forall n:int. ((1 <  n) -> ((0 <= i) -> ((0 <  i) ->
  (power(n, (nary_length(i, n) - 1)) <= i)))))

axiom nary_lengthqtspec1 :
  (forall i:int. forall n:int. ((1 <  n) -> ((0 <= i) -> ((0 <  i) ->
  (i <  power(n, nary_length(i, n)))))))

axiom nary_lengthqtspec2 :
  (forall i:int. forall n:int. ((1 <  n) -> ((0 <= i) -> ((i <  n) ->
  (nary_length(i, n) = 1)))))

axiom nary_lengthqtspec3 :
  (forall i:int. forall n:int. ((1 <  n) -> ((0 <= i) -> (1 <= nary_length(i,
  n)))))

axiom nary_lengthqtspec4 :
  (forall i:int. forall n:int. ((1 <  n) -> ((0 <= i) -> (i = (i % power(n,
  nary_length(i, n)))))))

logic binary_length : int -> int

axiom binary_lengthqtdef :
  (forall i:int. ((0 <= i) -> (binary_length(i) = nary_length(i, 2))))

axiom binary_lengthqtspec :
  (forall i:int. ((0 <= i) -> ((0 <  i) -> (power(2,
  (binary_length(i) - 1)) <= i))))

axiom binary_lengthqtspec1 :
  (forall i:int. ((0 <= i) -> ((0 <  i) -> (i <  power(2,
  binary_length(i))))))

axiom binary_lengthqtspec2 :
  (forall i:int. ((0 <= i) -> ((i <  2) -> (binary_length(i) = 1))))

axiom binary_lengthqtspec3 :
  (forall i:int. ((0 <= i) -> (1 <= binary_length(i))))

axiom binary_lengthqtspec4 :
  (forall i:int. ((0 <= i) -> (i = (i % power(2, binary_length(i))))))

axiom set_binary_length :
  (forall i:int. forall k:int. ((0 <= i) -> ((0 <= k) -> (((0 <  i) ->
  ((power(2, (k - 1)) <= i) and (i <  power(2, k)))) -> (((i <  2) ->
  (k = 1)) -> (k = binary_length(i)))))))

axiom set_binary_length_b :
  (forall i:int. forall k:int. ((0 <= i) -> ((0 <  k) -> ((i <  power(2,
  k)) -> (binary_length(i) <= k)))))

type bitvec

logic value : bitvec -> (int,int) farray

logic length : bitvec -> int

axiom bitvecqtinvariant :
  (forall self:bitvec [length(self)| value(self)]. (0 <= length(self)))

axiom bitvecqtinvariant1 :
  (forall self:bitvec [length(self)| value(self)].
  (forall i:int. (((0 <= i) and (i <  length(self))) ->
  (0 <= (value(self)[i])))))

axiom bitvecqtinvariant2 :
  (forall self:bitvec [length(self)| value(self)].
  (forall i:int. (((0 <= i) and (i <  length(self))) ->
  ((value(self)[i]) <  2))))

axiom bitvecqtinvariant3 :
  (forall self:bitvec [length(self)| value(self)].
  (forall i:int. ((not ((0 <= i) and (i <  length(self)))) ->
  ((value(self)[i]) = 0))))

predicate bvlength(f: (int,int) farray, i: int) =
  (forall k:int. (((0 <= k) and (k <  i)) -> ((0 <= (f[k])) and
  ((f[k]) <  2))))

axiom binary_mult :
  (forall a:int. forall b:int. (((a * b) % 2) = ((a % 2) * (b % 2))))

axiom getbvqtspec : (forall a:bitvec. binary(value(a)))

axiom getbvqtspec1 : true

logic to_bool : int -> bool

axiom to_boolqtdef :
  (forall i:int. (((0 <= i) and (i <  2)) -> ((not (i = 0)) ->
  (to_bool(i) = true))))

axiom to_boolqtdef1 :
  (forall i:int. (((0 <= i) and (i <  2)) -> ((i = 0) ->
  (to_bool(i) = false))))

axiom getbv_bound : (forall bv:bitvec. forall i:int. (0 <= (value(bv)[i])))

axiom getbv_bound1 : (forall bv:bitvec. forall i:int. ((value(bv)[i]) <  2))

axiom getbv_eq :
  (forall bvx:bitvec. forall bvy:bitvec. forall i:int. ((bvx = bvy) ->
  ((value(bvx)[i]) = (value(bvy)[i]))))

axiom getbv_eq_gen :
  (forall bvx:bitvec. forall bvy:bitvec. forall i:int. forall j:int.
  ((bvx = bvy) -> ((i = j) -> ((value(bvx)[i]) = (value(bvy)[j])))))

logic setbv : (int,int) farray, int, int -> (int,int) farray

axiom setbvqtdef :
  (forall bv:(int,int) farray. forall i:int. forall j:int. forall k:int.
  ((setbv(bv, i, j)[k]) = (if (k = i) then j else (bv[k]))))

axiom setbvqtspec :
  (forall bv:(int,int) farray. forall i:int. forall j:int.
  (forall k:int. ((not (k = i)) -> ((setbv(bv, i, j)[k]) = (bv[k])))))

axiom setbvqtspec1 :
  (forall bv:(int,int) farray. forall i:int. forall j:int. ((setbv(bv, i,
  j)[i]) = j))

logic setbv_int : (int,int) farray, (int,int) farray, int,
  int -> (int,int) farray

axiom setbv_intqtdef :
  (forall bv1:(int,int) farray. forall bv2:(int,int) farray. forall i:int.
  forall j:int. forall k:int. ((setbv_int(bv1, bv2, i,
  j)[k]) = (if ((i <  k) and (k <= j)) then (bv2[(k - i)]) else (bv1[k]))))

axiom setbv_intqtspec :
  (forall bv1:(int,int) farray. forall bv2:(int,int) farray. forall i:int.
  forall j:int.
  (forall k:int. (((i <  k) and (k <= j)) -> ((setbv_int(bv1, bv2, i,
  j)[k]) = (bv2[(k - i)])))))

axiom setbv_intqtspec1 :
  (forall bv1:(int,int) farray. forall bv2:(int,int) farray. forall i:int.
  forall j:int.
  (forall k:int. ((k <= i) -> ((setbv_int(bv1, bv2, i, j)[k]) = (bv1[k])))))

axiom setbv_intqtspec2 :
  (forall bv1:(int,int) farray. forall bv2:(int,int) farray. forall i:int.
  forall j:int.
  (forall k:int. ((j <  k) -> ((setbv_int(bv1, bv2, i, j)[k]) = (bv1[k])))))

axiom set_bvlength :
  (forall bv:bitvec. forall i:int.
  ((forall k:int. (((1 <= k) and (k <  i)) -> ((0 <= (value(bv)[k])) and
   ((value(bv)[k]) <  2)))) ->
  bvlength(value(bv), i)))

axiom null_product_bitvec :
  (forall x:bitvec. forall n:int. ((n = length(x)) ->
  ((forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 1))) ->
  (ind_iproduct(value(x), 0, n) = 1))))

axiom non_null_product_bitvec :
  (forall x:bitvec. forall n:int. ((n = length(x)) ->
  ((not (forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 1)))) ->
  (ind_iproduct(value(x), 0, n) = 0))))

logic fc122 : bitvec -> (int,int) farray

axiom fcqtdef122 :
  (forall x:bitvec. forall i:int. ((fc122(x)[i]) = (1 - (value(x)[i]))))

axiom null_product_bitvec_inv :
  (forall x:bitvec. forall n:int. ((n = length(x)) ->
  ((forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 0))) ->
  (ind_iproduct(fc122(x), 0, n) = 1))))

logic fc123 : bitvec -> (int,int) farray

axiom fcqtdef123 :
  (forall x:bitvec. forall i:int. ((fc123(x)[i]) = (1 - (value(x)[i]))))

axiom non_null_product_bitvec_inv :
  (forall x:bitvec. forall n:int. ((n = length(x)) ->
  ((not (forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 0)))) ->
  (ind_iproduct(fc123(x), 0, n) = 0))))

axiom null_product_bitvec_rev :
  (forall x:bitvec. forall n:int. ((n = length(x)) ->
  ((ind_iproduct(value(x), 0, n) = 1) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 1))))))

axiom non_null_product_bitvec_rev :
  (forall x:bitvec. forall n:int. ((n = length(x)) ->
  ((ind_iproduct(value(x), 0, n) = 0) ->
  (not (forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 1)))))))

logic fc124 : bitvec -> (int,int) farray

axiom fcqtdef124 :
  (forall x:bitvec. forall i:int. ((fc124(x)[i]) = (1 - (value(x)[i]))))

axiom null_product_bitvec_inv_rev :
  (forall x:bitvec. forall n:int. ((n = length(x)) ->
  ((ind_iproduct(fc124(x), 0, n) = 1) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 0))))))

logic fc125 : bitvec -> (int,int) farray

logic fc126 : bitvec -> (int,int) farray

axiom fcqtdef125 :
  (forall x:bitvec. forall i:int. ((fc125(x)[i]) = (1 - (value(x)[i]))))

axiom fcqtdef126 :
  (forall x:bitvec. forall i:int. ((fc126(x)[i]) = (1 - (value(x)[i]))))

axiom inter1 :
  (forall x:bitvec. forall n:int. forall k:int. ((n = length(x)) ->
  ((ind_iproduct(fc125(x), 0, n) = 0) -> (((0 <= k) and (k <= n)) ->
  ((forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 0))) ->
  (ind_iproduct(fc126(x), 0, k) = 1))))))

logic fc127 : bitvec -> (int,int) farray

axiom fcqtdef127 :
  (forall x:bitvec. forall i:int. ((fc127(x)[i]) = (1 - (value(x)[i]))))

axiom non_null_product_bitvec_inv_rev :
  (forall x:bitvec. forall n:int. ((n = length(x)) ->
  ((ind_iproduct(fc127(x), 0, n) = 0) ->
  (not (forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 0)))))))

axiom set_flength :
  (forall f:(int,int) farray. forall i:int.
  ((forall k:int. (((0 <= k) and (k <  i)) -> ((0 <= (f[k])) and
   ((f[k]) <  2)))) ->
  bvlength(f, i)))

axiom get_bvlength :
  (forall f:(int,int) farray. forall i:int. (bvlength(f, i) ->
  (forall k:int. (((0 <= k) and (k <  i)) -> (0 <= (f[k]))))))

axiom get_bvlength1 :
  (forall f:(int,int) farray. forall i:int. (bvlength(f, i) ->
  (forall k:int. (((0 <= k) and (k <  i)) -> ((f[k]) <  2)))))

axiom set_bv_to :
  (forall f:(int,int) farray. forall i:int. ((0 <  i) ->
  ((forall j:int. (((0 <= j) and (j <  i)) -> ((0 <= (f[j])) and
   ((f[j]) <= 1)))) ->
  bvlength(f, i))))

axiom set_in_range_val :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <  length(bv))) ->
  (0 <= (value(bv)[i]))))

axiom set_in_range_val1 :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <  length(bv))) ->
  ((value(bv)[i]) <  2)))

axiom bvlengthm :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <  length(bv))) ->
  bvlength(value(bv), i)))

predicate in_range(bv: bitvec, r: int) = ((0 <= r) and (r <  length(bv)))

axiom binary_bv :
  (forall bv:bitvec. forall i:int. (in_range(bv, i) ->
  (0 <= (value(bv)[i]))))

axiom binary_bv1 :
  (forall bv:bitvec. forall i:int. (in_range(bv, i) ->
  ((value(bv)[i]) <= 1)))

axiom equal_bv :
  (forall m:bitvec. forall n:bitvec. ((m = n) -> (length(m) = length(n))))

axiom equal_bv1 :
  (forall m:bitvec. forall n:bitvec. ((m = n) ->
  (forall i:int. (in_range(m, i) -> ((value(m)[i]) = (value(n)[i]))))))

axiom equal_bv2 :
  (forall m:bitvec. forall n:bitvec. (((length(m) = length(n)) and
  (forall i:int. (in_range(m, i) -> ((value(m)[i]) = (value(n)[i]))))) ->
  (m = n)))

axiom set_equal_bv :
  (forall bv:bitvec. forall bvqt:bitvec. ((length(bv) = length(bvqt)) ->
  ((forall i:int. (((0 <= i) and (i <  length(bv))) ->
   ((value(bv)[i]) = (value(bvqt)[i])))) ->
  (bv = bvqt))))

axiom get_equal_bv :
  (forall bv:bitvec. forall bvqt:bitvec. ((bv = bvqt) ->
  (length(bv) = length(bvqt))))

axiom get_equal_bv1 :
  (forall bv:bitvec. forall bvqt:bitvec. ((bv = bvqt) ->
  (forall i:int. (((0 <= i) and (i <  length(bv))) ->
  ((value(bv)[i]) = (value(bvqt)[i]))))))

logic make_bv : (int,int) farray, int -> bitvec

axiom make_bvqtspec :
  (forall f:(int,int) farray. forall s:int.
  ((forall i:int. (((0 <= i) and (i <  s)) -> ((0 <= (f[i])) and
   ((f[i]) <  2)))) ->
  ((0 <= s) -> (length(make_bv(f, s)) = s))))

axiom make_bvqtspec1 :
  (forall f:(int,int) farray. forall s:int.
  ((forall i:int. (((0 <= i) and (i <  s)) -> ((0 <= (f[i])) and
   ((f[i]) <  2)))) ->
  ((0 <= s) ->
  (forall i:int. (((0 <= i) and (i <  s)) -> ((value(make_bv(f,
  s))[i]) = (f[i])))))))

axiom make_bvqtspec2 :
  (forall f:(int,int) farray. forall s:int.
  ((forall i:int. (((0 <= i) and (i <  s)) -> ((0 <= (f[i])) and
   ((f[i]) <  2)))) ->
  ((0 <= s) ->
  (forall i:int. ((not ((0 <= i) and (i <  s))) -> ((value(make_bv(f,
  s))[i]) = 0))))))

logic make_bv_m : (int,int) farray, int -> bitvec

logic result13 : (int,int) farray -> (int,int) farray

axiom resultqtdef17 :
  (forall f:(int,int) farray. forall k:int.
  ((result13(f)[k]) = ((f[k]) % 2)))

axiom make_bv_mqtdef :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) -> (make_bv_m(f,
  s) = make_bv(result13(f), s))))

axiom make_bv_mqtspec :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) -> (length(make_bv_m(f,
  s)) = s)))

axiom make_bv_mqtspec1 :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) ->
  (forall i:int. bvlength(value(make_bv_m(f, s)), i))))

axiom make_bv_mqtspec2 :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) ->
  (forall k:int. (((0 <= k) and (k <  s)) -> ((value(make_bv_m(f,
  s))[k]) = ((f[k]) % 2))))))

axiom make_bv_mqtspec3 :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) ->
  (forall k:int. ((not ((0 <= k) and (k <  s))) -> ((value(make_bv_m(f,
  s))[k]) = 0)))))

logic result14 : (int,int) farray

axiom resultqtdef18 : (forall us:int. ((result14[us]) = 0))

function bitvec_null() : bitvec = make_bv(result14, 0)

axiom assert_make_bv_no_bound :
  (forall f:(int,int) farray. forall s:int. forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  s)) -> ((0 <= (f[i1])) and
   ((f[i1]) <  2)))) ->
  (((1 <= i) and (i <= s)) -> ((value(make_bv(f, 0))[i]) = 0))))

axiom make_bv_length :
  (forall f:(int,int) farray. forall s:int.
  ((forall i:int. (((0 <= i) and (i <  s)) -> ((0 <= (f[i])) and
   ((f[i]) <  2)))) ->
  ((0 <= s) -> (length(make_bv(f, s)) = s))))

axiom assert_make_bv :
  (forall f:(int,int) farray. forall s:int. forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  s)) -> ((0 <= (f[i1])) and
   ((f[i1]) <  2)))) ->
  ((0 <= s) -> ((value(make_bv(f, s))[i]) = (if ((0 <= i) and
  (i <  s)) then (f[i]) else 0)))))

axiom assert_make_m :
  (forall f:(int,int) farray. forall s:int. forall i:int. ((0 <= s) ->
  ((value(make_bv_m(f, s))[i]) = (if ((0 <= i) and
  (i <  s)) then ((f[i]) % 2) else 0))))

axiom make_bv_eq :
  (forall f:(int,int) farray. forall fqt:(int,int) farray. forall n:int.
  forall nqt:int. ((0 <= n) -> ((n = nqt) ->
  ((forall i:int. (((0 <= i) and (i <  n)) -> ((f[i]) = (fqt[i])))) ->
  ((forall i:int. (((0 <= i) and (i <  n)) -> ((0 <= (f[i])) and
   ((f[i]) <  2)))) ->
  (make_bv(f, n) = make_bv(fqt, nqt)))))))

axiom assert_make_bv_b :
  (forall f:(int,int) farray. forall s:int. forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  s)) -> ((0 <= (f[i1])) and
   ((f[i1]) <  2)))) ->
  (((0 <= i) and (i <  s)) -> ((value(make_bv(f, s))[i]) = (f[i])))))

axiom assert_make_m_b :
  (forall f:(int,int) farray. forall s:int. forall i:int. (((0 <= i) and
  (i <  s)) -> ((0 <= s) -> ((value(make_bv_m(f, s))[i]) = ((f[i]) % 2)))))

axiom make_m_bv_length :
  (forall f:(int,int) farray. forall s:int. forall i:int. ((0 <= s) ->
  bvlength(value(make_bv_m(f, s)), i)))

axiom make_m_length :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) -> (length(make_bv_m(f,
  s)) = s)))

axiom set_equal_bv_make :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall s:int.
  ((forall i:int. ((0 <= (f[i])) and ((f[i]) <  2))) -> ((0 <= s) ->
  ((forall i:int. ((f[i]) = (g[i]))) -> (make_bv(f, s) = make_bv(g, s))))))

axiom set_equal_bv_make_ :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall s:int.
  ((0 <= s) ->
  ((forall i:int. (((0 <= i) and (i <  s)) -> ((0 <= (f[i])) and
   ((f[i]) <  2)))) ->
  ((forall i:int. (((0 <= i) and (i <  s)) -> ((f[i]) = (g[i])))) ->
  (make_bv(f, s) = make_bv(g, s))))))

axiom set_equal_bv_m_make :
  (forall f:(int,int) farray. forall g:(int,int) farray. forall s:int.
  ((0 <= s) -> ((forall i:int. (((f[i]) % 2) = ((g[i]) % 2))) ->
  (make_bv_m(f, s) = make_bv_m(g, s)))))

axiom make_bv_itself :
  (forall x:bitvec. forall n:int. ((length(x) = n) -> (make_bv(value(x),
  n) = x)))

logic head : bitvec -> int

axiom headqtdef :
  (forall bv:bitvec. ((1 <= length(bv)) -> (head(bv) = (value(bv)[0]))))

axiom headqtspec : (forall bv:bitvec. ((1 <= length(bv)) -> (0 <= head(bv))))

axiom headqtspec1 :
  (forall bv:bitvec. ((1 <= length(bv)) -> (head(bv) <= 1)))

logic makes_bv : (int,int) farray, int -> bitvec

logic result15 : (int,int) farray -> (int,int) farray

axiom resultqtdef19 :
  (forall f:(int,int) farray. forall i:int.
  ((result15(f)[i]) = (if (let q1_ = (f[i]) : int in ((0 <= q1_) and
  (q1_ <  2))) then (f[i]) else 0)))

axiom makes_bvqtdef :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) -> (makes_bv(f,
  s) = make_bv(result15(f), s))))

axiom makes_bvqtspec :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) -> (length(makes_bv(f,
  s)) = s)))

axiom makes_bvqtspec1 :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) ->
  (forall i:int. (((0 <= i) and (i <  s)) -> (((0 <= (f[i])) and
  ((f[i]) <  2)) -> ((value(makes_bv(f, s))[i]) = (f[i])))))))

axiom makes_bvqtspec2 :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) ->
  ((forall i:int. (((0 <= i) and (i <  s)) -> ((0 <= (f[i])) and
   ((f[i]) <  2)))) ->
  (makes_bv(f, s) = make_bv(f, s)))))

axiom makes_bvqtspec3 :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) ->
  (forall i:int. ((not ((0 <= i) and (i <  s))) -> ((value(makes_bv(f,
  s))[i]) = 0)))))

axiom assert_makes_bv_c :
  (forall f:(int,int) farray. forall s:int. forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  s)) -> ((0 <= (f[i1])) and
   ((f[i1]) <  2)))) ->
  ((0 <= s) -> ((value(makes_bv(f, s))[i]) = (if ((0 <= i) and
  (i <  s)) then (f[i]) else 0)))))

axiom assert_makes_bv_b :
  (forall f:(int,int) farray. forall s:int. forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  s)) -> ((0 <= (f[i1])) and
   ((f[i1]) <  2)))) ->
  ((0 <= s) -> (((0 <= i) and (i <  s)) -> ((value(makes_bv(f,
  s))[i]) = (f[i]))))))

axiom assert_makes_bv :
  (forall f:(int,int) farray. forall s:int. forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  s)) -> ((0 <= (f[i1])) and
   ((f[i1]) <  2)))) ->
  ((0 <= s) -> ((value(makes_bv(f, s))[i]) = (if (((0 <= i) and (i <  s)) and
  (0 <= (f[i]))) then (f[i]) else 0)))))

axiom makes_bv_length :
  (forall f:(int,int) farray. forall s:int. ((0 <= s) -> (length(makes_bv(f,
  s)) = s)))

logic tail : bitvec -> bitvec

logic result16 : bitvec -> (int,int) farray

axiom resultqtdef20 :
  (forall bv:bitvec. forall i:int.
  ((result16(bv)[i]) = (value(bv)[(i + 1)])))

axiom tailqtdef :
  (forall bv:bitvec. ((1 <= length(bv)) -> (tail(bv) = make_bv(result16(bv),
  (length(bv) - 1)))))

axiom tailqtspec :
  (forall bv:bitvec. ((1 <= length(bv)) ->
  (length(tail(bv)) = (length(bv) - 1))))

axiom tailqtspec1 :
  (forall bv:bitvec. ((1 <= length(bv)) ->
  (forall i:int. (in_range(tail(bv), i) ->
  ((value(tail(bv))[i]) = (value(bv)[(i + 1)]))))))

logic concat_l : bitvec, int -> bitvec

logic result17 : bitvec, int -> (int,int) farray

axiom resultqtdef21 :
  (forall bv:bitvec. forall i:int. forall k:int. ((result17(bv,
  i)[k]) = (if (k = 0) then i else (value(bv)[(k - 1)]))))

axiom concat_lqtdef :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <= 1)) -> (concat_l(bv,
  i) = make_bv(result17(bv, i), (length(bv) + 1)))))

axiom concat_lqtspec :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <= 1)) ->
  (length(concat_l(bv, i)) = (length(bv) + 1))))

axiom concat_lqtspec1 :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <= 1)) ->
  ((value(concat_l(bv, i))[0]) = i)))

axiom concat_lqtspec2 :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <= 1)) ->
  (forall j:int. (in_range(bv, j) -> ((value(concat_l(bv,
  i))[(j + 1)]) = (value(bv)[j]))))))

axiom concat_l_value :
  (forall bv:bitvec. forall i:int. forall k:int. (((0 <= i) and (i <  2)) ->
  ((value(concat_l(bv, i))[k]) = (if (k = 0) then i else (if ((0 <  k) and
  (k <= (length(bv) + 1))) then (value(bv)[(k - 1)]) else 0)))))

axiom concat_l_value_b :
  (forall bv:bitvec. forall i:int. forall k:int. (((0 <= k) and
  (k <  (length(bv) + 1))) -> (((0 <= i) and (i <  2)) ->
  ((value(concat_l(bv,
  i))[k]) = (if (k = 0) then i else (value(bv)[(k - 1)]))))))

axiom concat_ht :
  (forall bv:bitvec. ((1 <= length(bv)) -> (bv = concat_l(tail(bv),
  head(bv)))))

axiom concat_ht_union :
  (forall bv:bitvec. ((2 <= length(bv)) -> ((not (bv = concat_l(tail(bv),
  0))) -> (bv = concat_l(tail(bv), 1)))))

logic result18 : bitvec -> (int,int) farray

axiom resultqtdef22 :
  (forall bv:bitvec. forall k:int. ((result18(bv)[k]) = (if in_range(bv,
  k) then ((value(bv)[k]) * power(2, ((length(bv) - 1) - k))) else 1)))

function bv_to_int(bv: bitvec) : int = ind_isum(result18(bv), 0, length(bv))

logic fc128 : bitvec -> (int,int) farray

axiom fcqtdef128 :
  (forall bv:bitvec. forall k:int.
  ((fc128(bv)[k]) = ((value(bv)[k]) * power(2, ((length(bv) - 1) - k)))))

axiom bv_to_intqtspec :
  (forall bv:bitvec. (bv_to_int(bv) = ind_isum(fc128(bv), 0, length(bv))))

axiom bv_to_intqtspec1 : (forall bv:bitvec. (0 <= bv_to_int(bv)))

axiom bv_to_int_eq :
  (forall bv1:bitvec. forall bv2:bitvec. ((bv1 = bv2) ->
  (bv_to_int(bv1) = bv_to_int(bv2))))

logic fc129 : bitvec -> (int,int) farray

axiom fcqtdef129 :
  (forall bv:bitvec. forall k:int.
  ((fc129(bv)[k]) = ((value(bv)[k]) * power(2, ((length(bv) - 1) - k)))))

axiom bv_to_int_sum :
  (forall bv:bitvec. (bv_to_int(bv) = ind_isum(fc129(bv), 0, length(bv))))

logic fc130 : bitvec -> (int,int) farray

axiom fcqtdef130 :
  (forall bv:bitvec. forall k:int.
  ((fc130(bv)[k]) = ((value(bv)[((length(bv) - 1) - k)]) * power(2, k))))

axiom bv_to_int_sum_inv :
  (forall bv:bitvec. (bv_to_int(bv) = ind_isum(fc130(bv), 0, length(bv))))

logic fc131 : bitvec -> (int,int) farray

axiom fcqtdef131 :
  (forall bv:bitvec. forall k:int.
  ((fc131(bv)[k]) = ((-(value(bv)[k])) * power(2, ((length(bv) - 1) - k)))))

axiom bv_to_int_sum_opp :
  (forall bv:bitvec. ((-bv_to_int(bv)) = ind_isum(fc131(bv), 0, length(bv))))

axiom bv_to_int_onebit :
  (forall bv:bitvec. ((length(bv) = 1) -> (bv_to_int(bv) = (value(bv)[0]))))

logic fc132 : bitvec -> (int,int) farray

logic fc133 : bitvec -> (int,int) farray

axiom fcqtdef132 :
  (forall bv:bitvec. forall l:int.
  ((fc132(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom fcqtdef133 :
  (forall bv:bitvec. forall l:int.
  ((fc133(bv)[l]) = ((value(bv)[((length(bv) - 1) - l)]) * power(2, l))))

axiom ind_isum_bv_rev :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <= length(bv))) ->
  (ind_isum(fc132(bv), i, length(bv)) = ind_isum(fc133(bv), 0,
  (length(bv) - i)))))

logic fc134 : (int,int) farray, int -> (int,int) farray

logic fc135 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef134 :
  (forall f:(int,int) farray. forall n:int. forall l:int. ((fc134(f,
  n)[l]) = ((f[l]) * power(2, ((n - 1) - l)))))

axiom fcqtdef135 :
  (forall f:(int,int) farray. forall n:int. forall l:int. ((fc135(f,
  n)[l]) = ((f[((n - 1) - l)]) * power(2, l))))

axiom ind_isum_bin_rev :
  (forall f:(int,int) farray. forall n:int. forall i:int. (((0 <= i) and
  (i <  n)) -> (binary(f) -> (ind_isum(fc134(f, n), i, n) = ind_isum(fc135(f,
  n), 0, (n - i))))))

logic fc136 : (int,int) farray, int -> (int,int) farray

logic fc137 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef136 :
  (forall f:(int,int) farray. forall n:int. forall l:int. ((fc136(f,
  n)[l]) = ((f[l]) * power(2, ((n - 1) - l)))))

axiom fcqtdef137 :
  (forall f:(int,int) farray. forall n:int. forall l:int. ((fc137(f,
  n)[l]) = ((f[((n - 1) - l)]) * power(2, l))))

axiom ind_isum_bin_rev_z :
  (forall f:(int,int) farray. forall n:int. ((0 <= n) -> (binary(f) ->
  (ind_isum(fc136(f, n), 0, n) = ind_isum(fc137(f, n), 0, n)))))

logic fc138 : bitvec -> (int,int) farray

axiom fcqtdef138 :
  (forall bv:bitvec. forall k:int.
  ((fc138(bv)[k]) = ((value(bv)[((length(bv) - 1) - k)]) * power(2, k))))

axiom bv_to_int_sum_rev :
  (forall bv:bitvec. (ind_isum(fc138(bv), 0, length(bv)) = bv_to_int(bv)))

logic fc139 : bitvec -> (int,int) farray

axiom fcqtdef139 :
  (forall bv:bitvec. forall l:int.
  ((fc139(bv)[l]) = ((value(bv)[l]) * power(2, l))))

axiom ind_isum_bv_bound_growing :
  (forall bv:bitvec. forall i:int. (((0 <  i) and (i <  length(bv))) ->
  (ind_isum(fc139(bv), 0, i) <  power(2, i))))

logic fc140 : bitvec -> (int,int) farray

axiom fcqtdef140 :
  (forall bv:bitvec. forall l:int.
  ((fc140(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom ind_isum_bv_bound :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <  length(bv))) ->
  (ind_isum(fc140(bv), i, length(bv)) <  power(2, (length(bv) - i)))))

logic fc141 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef141 :
  (forall f:(int,int) farray. forall n:int. forall l:int. ((fc141(f,
  n)[l]) = ((f[l]) * power(2, ((n - 1) - l)))))

axiom ind_isum_bin_bound :
  (forall f:(int,int) farray. forall n:int. forall i:int. (((0 <= i) and
  (i <  n)) -> (binary(f) -> (ind_isum(fc141(f, n), i, n) <  power(2,
  (n - i))))))

axiom bv_to_int_bound :
  (forall bv:bitvec. ((1 <= length(bv)) -> (bv_to_int(bv) <  power(2,
  length(bv)))))

axiom bv_to_int_bound_gen :
  (forall bv:bitvec. forall l:int. ((0 <= l) -> ((length(bv) = l) ->
  (bv_to_int(bv) <  power(2, l)))))

logic int_to_bv : int, int -> bitvec

logic result19 : int, int -> (int,int) farray

axiom resultqtdef23 :
  (forall i:int. forall n:int. forall k:int. ((result19(i,
  n)[k]) = (if ((0 <= k) and (k <  n)) then ((i % power(2,
  (n - k))) / power(2, ((n - k) - 1))) else 0)))

axiom int_to_bvqtdef :
  (forall i:int. forall n:int. ((0 <= n) -> (int_to_bv(i,
  n) = make_bv(result19(i, n), n))))

logic fc142 : int, int -> (int,int) farray

axiom fcqtdef142 :
  (forall i:int. forall n:int. forall k:int. ((fc142(i,
  n)[k]) = ((i % power(2, (n - k))) / power(2, ((n - k) - 1)))))

axiom int_to_bvqtspec :
  (forall i:int. forall n:int. ((0 <= n) -> (length(int_to_bv(i, n)) = n)))

axiom int_to_bvqtspec1 :
  (forall i:int. forall n:int. ((0 <= n) -> (int_to_bv(i,
  n) = make_bv(fc142(i, n), n))))

predicate constant_size(s: 'a set, f: ('a,complex matrix) farray) =
  (forall e:'a. (mem(e, s) -> ((rows((f[e])) = rows((f[choose(s)]))) and
  (columns((f[e])) = columns((f[choose(s)]))))))

axiom set_constant_size :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   (rows((f[e])) = rows((f[eqt])))))) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   (columns((f[e])) = columns((f[eqt])))))) ->
  constant_size(s, f))))

axiom set_constant_size_exists :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((exists r:int. (forall e:'a. (mem(e, s) -> (rows((f[e])) = r)))) ->
  ((exists c:int. (forall e:'a. (mem(e, s) -> (columns((f[e])) = c)))) ->
  constant_size(s, f))))

axiom set_constant_size_t :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) -> constant_size(s,
  f))))

logic fc143 : ('a,complex matrix) farray, ('a,bool) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef143 :
  (forall f:('a,complex matrix) farray. forall p:('a,bool) farray.
  forall m:complex matrix. forall j:'a. ((fc143(f, p,
  m)[j]) = (if ((p[j]) = true) then (f[j]) else m)))

axiom guarded_set_constant_size :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall p:('a,bool) farray. forall m:complex matrix. (constant_size(s, f) ->
  ((forall e:'a. (mem(e, s) -> ((p[e]) = true))) -> constant_size(s, fc143(f,
  p, m)))))

logic fc144 : ('a,complex) farray, complex matrix, int,
  int -> ('a,complex matrix) farray

axiom fcqtdef144 :
  (forall f:('a,complex) farray. forall m:complex matrix. forall i:int.
  forall j:int. forall e:'a. ((fc144(f, m, i, j)[e]) = set1(m, i, j,
  (f[e]))))

axiom set_constant_size_set :
  (forall s:'a set. forall f:('a,complex) farray. forall m:complex matrix.
  forall i:int. forall j:int. (valid_index(m, i, j) -> constant_size(s,
  fc144(f, m, i, j))))

axiom get_constant_size :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  (rows((f[e])) = rows((f[eqt]))))))))

axiom get_constant_size1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  (columns((f[e])) = columns((f[eqt]))))))))

logic s_rows : 'a set, ('a,complex matrix) farray -> int

axiom s_rowsqtdef :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> (s_rows(s, f) = rows((f[choose(s)])))))

axiom s_rowsqtspec :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> (0 <  s_rows(s, f))))

axiom s_rowsqtspec1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> (forall e:'a. (mem(e, s) -> (rows((f[e])) = s_rows(s, f))))))

axiom s_rowsqtspec2 :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  (rows((f[e])) = rows((f[eqt]))))))))

logic s_columns : 'a set, ('a,complex matrix) farray -> int

axiom s_columnsqtdef :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> (s_columns(s, f) = columns((f[choose(s)])))))

axiom s_columnsqtspec :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> (0 <  s_columns(s, f))))

axiom s_columnsqtspec1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> (forall e:'a. (mem(e, s) -> (columns((f[e])) = s_columns(s, f))))))

axiom s_columnsqtspec2 :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) ->
  (forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
  (columns((f[e])) = columns((f[eqt]))))))))

axiom set_s_rows :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  (constant_size(s, f) -> ((rows((f[choose(s)])) = r) -> (s_rows(s,
  f) = r))))

axiom set_s_rows_elt :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall elt:'a.
  (constant_size(s, f) -> (mem(elt, s) -> (s_rows(s, f) = rows((f[elt]))))))

axiom set_s_columns :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  (constant_size(s, f) -> ((columns((f[choose(s)])) = r) -> (s_columns(s,
  f) = r))))

axiom set_s_columns_elt :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall elt:'a.
  (constant_size(s, f) -> (mem(elt, s) -> (s_columns(s,
  f) = columns((f[elt]))))))

axiom s_rows_eq :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. (constant_size(s, f) ->
  ((0 <  cardinal(s)) -> ((forall e:'a. (mem(e, s) -> ((f[e]) = (g[e])))) ->
  (s_rows(s, f) = s_rows(s, g))))))

axiom set_constant_size_give :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  cardinal(s)) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) -> constant_size(s,
  f)))))

axiom set_constant_size_give1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  cardinal(s)) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  (forall e:'a. (mem(e, s) -> (rows((f[e])) = r)))))))

axiom set_constant_size_give2 : true

axiom set_constant_size_give3 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  cardinal(s)) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) -> (s_rows(s,
  f) = r)))))

axiom set_constant_size_give4 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  cardinal(s)) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) -> (s_columns(s,
  f) = c)))))

axiom s_columns_eq :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. (constant_size(s, f) ->
  ((0 <  cardinal(s)) -> ((forall e:'a. (mem(e, s) -> ((f[e]) = (g[e])))) ->
  (s_columns(s, f) = s_columns(s, g))))))

axiom subset_constant_size :
  (forall s:'a set. forall sqt:'a set. forall f:('a,complex matrix) farray.
  (constant_size(s, f) -> ((not is_empty(sqt)) -> (subset(sqt, s) ->
  constant_size(sqt, f)))))

axiom subset_constant_size1 :
  (forall s:'a set. forall sqt:'a set. forall f:('a,complex matrix) farray.
  (constant_size(s, f) -> ((not is_empty(sqt)) -> (subset(sqt, s) ->
  (s_rows(sqt, f) = s_rows(s, f))))))

axiom subset_constant_size2 :
  (forall s:'a set. forall sqt:'a set. forall f:('a,complex matrix) farray.
  (constant_size(s, f) -> ((not is_empty(sqt)) -> (subset(sqt, s) ->
  (s_columns(sqt, f) = s_columns(s, f))))))

axiom set_s_rows_rem :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((1 <  cardinal(s)) -> (constant_size(s, f) ->
  constant_size(remove(choose(s), s), f))))

axiom set_s_rows_rem1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((1 <  cardinal(s)) -> (constant_size(s, f) -> (s_rows(remove(choose(s),
  s), f) = rows((f[choose(s)]))))))

axiom set_s_columns_rem :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((1 <  cardinal(s)) -> (constant_size(s, f) ->
  constant_size(remove(choose(s), s), f))))

axiom set_s_columns_rem1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((1 <  cardinal(s)) -> (constant_size(s, f) -> (s_columns(remove(choose(s),
  s), f) = columns((f[choose(s)]))))))

axiom set_s_rows_add :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall x:'a.
  ((0 <  cardinal(s)) -> (constant_size(s, f) ->
  ((columns((f[x])) = s_columns(s, f)) -> ((rows((f[x])) = s_rows(s, f)) ->
  (s_rows(add(x, s), f) = s_rows(s, f)))))))

axiom set_s_columns_add :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall x:'a.
  ((0 <  cardinal(s)) -> (constant_size(s, f) ->
  ((columns((f[x])) = s_columns(s, f)) -> ((rows((f[x])) = s_rows(s, f)) ->
  (s_columns(add(x, s), f) = s_columns(s, f)))))))

axiom set_s_rows_columns_add :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall x:'a.
  ((0 <  cardinal(s)) -> (constant_size(s, f) ->
  ((columns((f[x])) = s_columns(s, f)) -> ((rows((f[x])) = s_rows(s, f)) ->
  (s_columns(add(x, s), f) = s_columns(s, f)))))))

axiom set_s_rows_columns_add1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall x:'a.
  ((0 <  cardinal(s)) -> (constant_size(s, f) ->
  ((columns((f[x])) = s_columns(s, f)) -> ((rows((f[x])) = s_rows(s, f)) ->
  (s_rows(add(x, s), f) = s_rows(s, f)))))))

logic mat_sum : 'a set, ('a,complex matrix) farray -> complex matrix

axiom mat_sumqtdef :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> ((0 <  cardinal(s)) -> ((cardinal(s) = 1) -> (mat_sum(s,
  f) = (f[element(s)]))))))

axiom mat_sumqtdef1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> ((0 <  cardinal(s)) -> ((not (cardinal(s) = 1)) -> (mat_sum(s,
  f) = add_mat((f[choose(s)]), mat_sum(remove(choose(s), s), f)))))))

axiom mat_sumqtspec :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> ((0 <  cardinal(s)) -> (rows(mat_sum(s, f)) = s_rows(s, f)))))

axiom mat_sumqtspec1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> ((0 <  cardinal(s)) -> (columns(mat_sum(s, f)) = s_columns(s, f)))))

axiom mat_sumqtspec2 :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> ((0 <  cardinal(s)) ->
  (forall e:'a. (mem(e, s) -> (rows((f[e])) = s_rows(s, f)))))))

axiom mat_sumqtspec3 :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> ((0 <  cardinal(s)) ->
  (forall e:'a. (mem(e, s) -> (columns((f[e])) = s_columns(s, f)))))))

axiom columns_mat_sum :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall n:int.
  ((not (cardinal(s) = 0)) -> (constant_size(s, f) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = n))) -> (columns(mat_sum(s,
  f)) = n)))))

axiom rows_mat_sum :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall n:int.
  ((not (cardinal(s) = 0)) -> (constant_size(s, f) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = n))) -> (rows(mat_sum(s,
  f)) = n)))))

axiom mat_sum_cardone :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((cardinal(s) = 1) -> (mat_sum(s, f) = (f[element(s)]))))

logic fc145 : ('a,complex matrix) farray, int, int -> ('a,complex) farray

axiom fcqtdef145 :
  (forall f:('a,complex matrix) farray. forall i:int. forall j:int.
  forall e:'a. ((fc145(f, i, j)[e]) = get((f[e]), i, j)))

axiom mat_sum_to_sum_pre :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall i:int.
  forall j:int. (constant_size(s, f) -> ((0 <  cardinal(s)) -> (((0 <= i) and
  (i <  s_rows(s, f))) -> (((0 <= j) and (j <  s_columns(s, f))) ->
  (get(mat_sum(s, f), i, j) = sum(s, fc145(f, i, j))))))))

logic fc146 : ('a,complex matrix) farray, int, int -> ('a,complex) farray

logic fc147 : 'a set,
  ('a,complex matrix) farray -> (int,(int,complex) farray) farray

axiom fcqtdef146 :
  (forall f:('a,complex matrix) farray. forall i:int. forall j:int.
  forall e:'a. ((fc146(f, i, j)[e]) = get((f[e]), i, j)))

axiom fcqtdef147 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall i:int.
  forall j:int. (((fc147(s, f)[i])[j]) = sum(s, fc146(f, i, j))))

axiom mat_sum_to_sum :
  (forall s:'a set. forall f:('a,complex matrix) farray. (constant_size(s,
  f) -> ((0 <  cardinal(s)) -> (mat_sum(s, f) = make_f(s_rows(s, f),
  s_columns(s, f), fc147(s, f))))))

logic fc148 : ('a,complex matrix) farray, int, int -> ('a,complex) farray

axiom fcqtdef148 :
  (forall f:('a,complex matrix) farray. forall i:int. forall j:int.
  forall e:'a. ((fc148(f, i, j)[e]) = get((f[e]), i, j)))

axiom mat_sum_value :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall i:int.
  forall j:int. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (valid_index(mat_sum(s, f), i, j) -> (get(mat_sum(s, f), i, j) = sum(s,
  fc148(f, i, j)))))))

axiom mat_sum_add :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall x:'a.
  ((0 <  cardinal(s)) -> (constant_size(s, f) -> ((rows((f[x])) = s_rows(s,
  f)) -> ((columns((f[x])) = s_columns(s, f)) -> ((not mem(x, s)) ->
  (mat_sum(add(x, s), f) = add_mat((f[x]), mat_sum(s, f)))))))))

axiom mat_sum_plus_one :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((1 <  cardinal(s)) -> (constant_size(s, f) -> (mat_sum(s,
  f) = add_mat((f[choose(s)]), mat_sum(remove(choose(s), s), f))))))

logic fc149 : ('b,complex matrix) farray,
  ('b,complex matrix) farray -> ('b,complex matrix) farray

axiom fcqtdef149 :
  (forall f:('b,complex matrix) farray. forall g:('b,complex matrix) farray.
  forall k:'b. ((fc149(f, g)[k]) = add_mat((f[k]), (g[k]))))

axiom mat_sum_comp_pre :
  (forall s:'b set. forall f:('b,complex matrix) farray.
  forall g:('b,complex matrix) farray. forall i:int. forall j:int.
  (constant_size(s, f) -> (constant_size(s, g) -> (((0 <= i) and
  (i <  s_rows(s, f))) -> (((0 <= j) and (j <  s_columns(s, f))) ->
  ((s_rows(s, f) = s_rows(s, g)) -> ((s_columns(s, f) = s_columns(s, g)) ->
  ((0 <  cardinal(s)) -> (get(mat_sum(s, fc149(f, g)), i,
  j) = get(add_mat(mat_sum(s, f), mat_sum(s, g)), i, j))))))))))

logic fc150 : ('b,complex matrix) farray,
  ('b,complex matrix) farray -> ('b,complex matrix) farray

axiom fcqtdef150 :
  (forall f:('b,complex matrix) farray. forall g:('b,complex matrix) farray.
  forall k:'b. ((fc150(f, g)[k]) = add_mat((f[k]), (g[k]))))

axiom mat_sum_comp :
  (forall s:'b set. forall f:('b,complex matrix) farray.
  forall g:('b,complex matrix) farray. (constant_size(s, f) ->
  (constant_size(s, g) -> ((s_rows(s, f) = s_rows(s, g)) -> ((s_columns(s,
  f) = s_columns(s, g)) -> ((0 <  cardinal(s)) -> (mat_sum(s, fc150(f,
  g)) = add_mat(mat_sum(s, f), mat_sum(s, g)))))))))

logic fc151 : ('b,complex matrix) farray,
  ('b,complex matrix) farray -> ('b,complex matrix) farray

axiom fcqtdef151 :
  (forall f:('b,complex matrix) farray. forall g:('b,complex matrix) farray.
  forall k:'b. ((fc151(f, g)[k]) = add_mat((f[k]), (g[k]))))

axiom mat_sum_comp_rec :
  (forall s:'b set. forall f:('b,complex matrix) farray.
  forall g:('b,complex matrix) farray. (constant_size(s, f) ->
  (constant_size(s, g) -> ((s_rows(s, f) = s_rows(s, g)) -> ((s_columns(s,
  f) = s_columns(s, g)) -> ((0 <  cardinal(s)) -> (add_mat(mat_sum(s, f),
  mat_sum(s, g)) = mat_sum(s, fc151(f, g)))))))))

logic fc152 : 'b set, ('a,('b,complex matrix) farray) farray, int,
  int -> ('a,complex) farray

logic fc153 : ('a,('b,complex matrix) farray) farray, int, int,
  'a -> ('b,complex) farray

logic fc154 : 'b set, ('a,('b,complex matrix) farray) farray, int,
  int -> ('a,complex) farray

axiom fcqtdef152 :
  (forall sqt:'b set. forall f:('a,('b,complex matrix) farray) farray.
  forall i:int. forall j:int. forall e:'a. ((fc152(sqt, f, i,
  j)[e]) = get(mat_sum(sqt, (f[e])), i, j)))

axiom fcqtdef153 :
  (forall f:('a,('b,complex matrix) farray) farray. forall i:int.
  forall j:int. forall e:'a. forall e1:'b. ((fc153(f, i, j,
  e)[e1]) = get(((f[e])[e1]), i, j)))

axiom fcqtdef154 :
  (forall sqt:'b set. forall f:('a,('b,complex matrix) farray) farray.
  forall i:int. forall j:int. forall e:'a. ((fc154(sqt, f, i,
  j)[e]) = sum(sqt, fc153(f, i, j, e))))

axiom mat_sum_to_sum_fun :
  (forall s:'a set. forall sqt:'b set.
  forall f:('a,('b,complex matrix) farray) farray. forall r:int.
  forall c:int. forall i:int. forall j:int. ((0 <  cardinal(s)) ->
  ((0 <  cardinal(sqt)) ->
  ((forall e:'a.
   (forall e1:'b. (mem(e, s) -> (mem(e1, sqt) -> (rows(((f[e])[e1])) = r))))) ->
  ((forall e:'a.
   (forall e1:'b. (mem(e, s) -> (mem(e1, sqt) ->
   (columns(((f[e])[e1])) = c))))) ->
  (((0 <= i) and (i <  r)) -> (((0 <= j) and (j <  c)) -> (sum(s, fc152(sqt,
  f, i, j)) = sum(s, fc154(sqt, f, i, j))))))))))

logic fc155 : 'b set,
  ('a,('b,complex matrix) farray) farray -> ('a,complex matrix) farray

logic fc156 : ('a,('b,complex matrix) farray) farray, int, int,
  'a -> ('b,complex) farray

logic fc157 : 'b set, ('a,('b,complex matrix) farray) farray, int,
  int -> ('a,complex) farray

axiom fcqtdef155 :
  (forall sqt:'b set. forall f:('a,('b,complex matrix) farray) farray.
  forall e:'a. ((fc155(sqt, f)[e]) = mat_sum(sqt, (f[e]))))

axiom fcqtdef156 :
  (forall f:('a,('b,complex matrix) farray) farray. forall i:int.
  forall j:int. forall e:'a. forall eqt:'b. ((fc156(f, i, j,
  e)[eqt]) = get(((f[e])[eqt]), i, j)))

axiom fcqtdef157 :
  (forall sqt:'b set. forall f:('a,('b,complex matrix) farray) farray.
  forall i:int. forall j:int. forall e:'a. ((fc157(sqt, f, i,
  j)[e]) = sum(sqt, fc156(f, i, j, e))))

axiom mat_sum_to_sum_double_pre :
  (forall s:'a set. forall sqt:'b set.
  forall f:('a,('b,complex matrix) farray) farray. forall r:int.
  forall c:int. forall i:int. forall j:int.
  ((forall e:'a. forall eqt:'b. (mem(e, s) -> (mem(eqt, sqt) ->
   (rows(((f[e])[eqt])) = r)))) ->
  ((forall e:'a. forall eqt:'b. (mem(e, s) -> (mem(eqt, sqt) ->
   (columns(((f[e])[eqt])) = c)))) ->
  (((0 <= i) and (i <  r)) -> (((0 <= j) and (j <  c)) ->
  ((0 <  cardinal(s)) -> ((0 <  cardinal(sqt)) -> (get(mat_sum(s, fc155(sqt,
  f)), i, j) = sum(s, fc157(sqt, f, i, j))))))))))

logic fc158 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef158 :
  (forall f:('a,complex matrix) farray. forall n:complex matrix. forall e:'a.
  ((fc158(f, n)[e]) = mat_mult((f[e]), n)))

axiom mat_mult_sum_out_l :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall n:complex matrix. ((0 <  cardinal(s)) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = rows(n)))) ->
  ((exists r:int. (forall e:'a. (mem(e, s) -> (rows((f[e])) = r)))) ->
  (mat_mult(mat_sum(s, f), n) = mat_sum(s, fc158(f, n)))))))

logic mat_sum_dim : 'a set, ('a,complex matrix) farray, int,
  int -> complex matrix

axiom mat_sum_dimqtdef :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  ((cardinal(s) = 0) -> (mat_sum_dim(s, f, r, c) = make(r, c, c_zero))))))))

axiom mat_sum_dimqtdef1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  ((not (cardinal(s) = 0)) -> (mat_sum_dim(s, f, r, c) = mat_sum(s, f))))))))

axiom mat_sum_dimqtspec :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  ((0 <  cardinal(s)) -> (mat_sum_dim(s, f, r, c) = mat_sum(s, f))))))))

axiom mat_sum_dimqtspec1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  ((cardinal(s) = 0) -> (mat_sum_dim(s, f, r, c) = make(r, c, c_zero))))))))

axiom mat_sum_dimqtspec2 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  (rows(mat_sum_dim(s, f, r, c)) = r))))))

axiom mat_sum_dimqtspec3 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  (columns(mat_sum_dim(s, f, r, c)) = c))))))

axiom mat_sum_dim_to_mat_sum :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((0 <  cardinal(s)) -> ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) -> (mat_sum_dim(s, f,
  r, c) = mat_sum(s, f))))))))

axiom mat_sum_dim_to_make_zero :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall r:int.
  forall c:int. ((cardinal(s) = 0) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) -> ((0 <  r) ->
  ((0 <  c) -> (mat_sum_dim(s, f, r, c) = make(r, c, c_zero))))))))

axiom mat_sum_dim_add :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall x:'a.
  forall r:int. forall c:int. ((0 <= cardinal(s)) -> ((not mem(x, s)) ->
  ((forall e:'a. (mem(e, add(x, s)) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, add(x, s)) -> (columns((f[e])) = c))) ->
  ((0 <  r) -> ((0 <  c) -> (mat_sum_dim(add(x, s), f, r,
  c) = add_mat((f[x]), mat_sum_dim(s, f, r, c))))))))))

logic fc159 : ('a,complex matrix) farray,
  complex -> ('a,complex matrix) farray

axiom fcqtdef159 :
  (forall f:('a,complex matrix) farray. forall a1:complex. forall k:'a.
  ((fc159(f, a1)[k]) = infix_asdtdt(a1, (f[k]))))

axiom mat_sum_scalar :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall a1:complex.
  (constant_size(s, f) -> ((0 <  cardinal(s)) -> (mat_sum(s, fc159(f,
  a1)) = infix_asdtdt(a1, mat_sum(s, f))))))

logic fc160 : ('a,complex matrix) farray,
  complex -> ('a,complex matrix) farray

axiom fcqtdef160 :
  (forall f:('a,complex matrix) farray. forall a1:complex. forall k:'a.
  ((fc160(f, a1)[k]) = infix_asdtdt(a1, (f[k]))))

axiom mat_sum_scalar_rev :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall a1:complex.
  (constant_size(s, f) -> ((0 <  cardinal(s)) -> (infix_asdtdt(a1, mat_sum(s,
  f)) = mat_sum(s, fc160(f, a1))))))

logic fc161 : complex matrix -> ('a,complex matrix) farray

axiom fcqtdef161 :
  (forall x:complex matrix. forall us:'a.
  (((fc161(x) : ('a,complex matrix) farray)[us]) = x))

axiom mat_sum_const :
  (forall s:'a set. forall x:complex matrix. ((0 <  cardinal(s)) ->
  (mat_sum(s,
  (fc161(x) : ('a,complex matrix) farray)) = infix_asdtdt(i_to_c(cardinal(s)),
  x))))

logic fc162 : complex matrix -> ('a,complex matrix) farray

axiom fcqtdef162 :
  (forall x:complex matrix. forall us:'a.
  (((fc162(x) : ('a,complex matrix) farray)[us]) = x))

axiom mat_sum_quot :
  (forall s:'a set. forall x:complex matrix. ((0 <  cardinal(s)) ->
  (x = infix_asdtdt(infix_sldt(c_one, i_to_c(cardinal(s))), mat_sum(s,
  (fc162(x) : ('a,complex matrix) farray))))))

logic fc163 : ('a,complex matrix) farray, complex matrix, int,
  int -> ('a,complex matrix) farray

axiom fcqtdef163 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix.
  forall i:int. forall j:int. forall k:'a. ((fc163(f, m, i,
  j)[k]) = infix_asdtdt(get((f[k]), i, j), m)))

axiom mat_sum_scalar_right :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall i:int. forall j:int. (constant_size(s,
  f) -> ((0 <  cardinal(s)) -> (((0 <= i) and (i <  s_rows(s, f))) ->
  (((0 <= j) and (j <  s_columns(s, f))) -> (infix_asdtdt(get(mat_sum(s, f),
  i, j), m) = mat_sum(s, fc163(f, m, i, j))))))))

axiom mat_sum_eq :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. ((0 <  cardinal(s)) ->
  (constant_size(s, f) ->
  ((forall a1:'a. (mem(a1, s) -> ((f[a1]) = (g[a1])))) -> (mat_sum(s,
  f) = mat_sum(s, g))))))

axiom mat_sum_eq_gen :
  (forall s:'a set. forall sqt:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. ((0 <  cardinal(s)) -> ((s = sqt) ->
  (constant_size(s, f) ->
  ((forall a1:'a. (mem(a1, s) -> ((f[a1]) = (g[a1])))) -> (mat_sum(s,
  f) = mat_sum(sqt, g)))))))

axiom mat_sum_eq_gen_int :
  (forall i1:int. forall i2:int. forall o1:int. forall o2:int.
  forall f:(int,complex matrix) farray. forall g:(int,complex matrix) farray.
  ((i1 <  o1) -> ((i1 = o1) -> ((i2 = o2) -> (constant_size(to_fset(i1, o1),
  f) -> ((forall a:int. (mem(a, to_fset(i1, o1)) -> ((f[a]) = (g[a])))) ->
  (mat_sum(to_fset(i1, o1), f) = mat_sum(to_fset(i2, o2), g))))))))

axiom mat_sum_comp_eq :
  (forall s:'b set. forall f:('b,complex matrix) farray.
  forall g:('b,complex matrix) farray. forall h:('b,complex matrix) farray.
  (constant_size(s, f) -> (constant_size(s, g) -> (constant_size(s, h) ->
  (((s_rows(s, f) = s_rows(s, g)) and (s_rows(s, g) = s_rows(s, h))) ->
  (((s_columns(s, f) = s_columns(s, g)) and (s_columns(s, g) = s_columns(s,
  h))) -> ((0 <  cardinal(s)) ->
  ((forall e:'b.
   (forall i:int. forall j:int. (mem(e, s) -> (((0 <= i) and (i <  s_rows(s,
   f))) -> (((0 <= j) and (j <  s_columns(s, f))) -> (infix_pldt(get((f[e]),
   i, j), get((g[e]), i, j)) = get((h[e]), i, j))))))) ->
  (add_mat(mat_sum(s, f), mat_sum(s, g)) = mat_sum(s, h))))))))))

axiom mat_sum_dim_eq :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall r:int. forall c:int.
  ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  ((forall e:'a. (mem(e, s) -> ((f[e]) = (g[e])))) -> (mat_sum_dim(s, f, r,
  c) = mat_sum_dim(s, g, r, c))))))))

logic fc164 : ('b,complex matrix) farray,
  ('a,'b) farray -> ('a,complex matrix) farray

axiom fcqtdef164 :
  (forall f:('b,complex matrix) farray. forall t:('a,'b) farray.
  forall a1:'a. ((fc164(f, t)[a1]) = (f[(t[a1])])))

axiom constant_size_map :
  (forall f:('b,complex matrix) farray. forall s:'a set.
  forall t:('a,'b) farray. (constant_size(s, fc164(f, t)) ->
  constant_size(map(t, s), f)))

logic fc165 : ('b,complex matrix) farray,
  ('a,'b) farray -> ('a,complex matrix) farray

logic fc166 : ('b,complex matrix) farray,
  ('a,'b) farray -> ('a,complex matrix) farray

axiom fcqtdef165 :
  (forall f:('b,complex matrix) farray. forall t:('a,'b) farray.
  forall a1:'a. ((fc165(f, t)[a1]) = (f[(t[a1])])))

axiom fcqtdef166 :
  (forall f:('b,complex matrix) farray. forall t:('a,'b) farray.
  forall a1:'a. ((fc166(f, t)[a1]) = (f[(t[a1])])))

axiom map_mat_sum :
  (forall f:('b,complex matrix) farray. forall s:'a set.
  forall t:('a,'b) farray. ((0 <  cardinal(s)) -> (constant_size(s, fc165(f,
  t)) -> (p_injective(t, s) -> (mat_sum(map(t, s), f) = mat_sum(s, fc166(f,
  t)))))))

logic fc167 : ('b,complex matrix) farray,
  ('a,'b) farray -> ('a,complex matrix) farray

logic fc168 : ('b,complex matrix) farray,
  ('a,'b) farray -> ('a,complex matrix) farray

axiom fcqtdef167 :
  (forall f:('b,complex matrix) farray. forall t:('a,'b) farray.
  forall a1:'a. ((fc167(f, t)[a1]) = (f[(t[a1])])))

axiom fcqtdef168 :
  (forall f:('b,complex matrix) farray. forall t:('a,'b) farray.
  forall a1:'a. ((fc168(f, t)[a1]) = (f[(t[a1])])))

axiom map_mat_sum_rec :
  (forall f:('b,complex matrix) farray. forall s:'a set.
  forall t:('a,'b) farray. ((0 <  cardinal(s)) -> (constant_size(s, fc167(f,
  t)) -> (p_injective(t, s) -> (mat_sum(s, fc168(f, t)) = mat_sum(map(t, s),
  f))))))

logic identity1 : (complex matrix,complex matrix) farray

axiom identity_def : (forall y:complex matrix. ((identity1[y]) = y))

axiom mat_sum_id :
  (forall f:('a,complex matrix) farray. forall s:'a set.
  ((0 <  cardinal(s)) -> (constant_size(s, f) -> (constant_size(map(f, s),
  identity1) -> (p_injective(f, s) -> (mat_sum(map(f, s),
  identity1) = mat_sum(s, f)))))))

logic nonn_mat_subset : ('a,complex matrix) farray, 'a set -> 'a set

logic result20 : ('a,complex matrix) farray, 'a set -> ('a,bool) farray

axiom resultqtdef24 :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall e:'a.
  (((result20(f, s)[e]) = true) -> (not infix_eqeq((f[e]), make(s_rows(s, f),
  s_columns(s, f), c_zero)))))

axiom resultqtdef25 :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall e:'a.
  ((not infix_eqeq((f[e]), make(s_rows(s, f), s_columns(s, f), c_zero))) ->
  ((result20(f, s)[e]) = true)))

axiom nonn_mat_subsetqtdef :
  (forall f:('a,complex matrix) farray. forall s:'a set. (constant_size(s,
  f) -> (nonn_mat_subset(f, s) = filter_(s, result20(f, s)))))

axiom nonn_mat_subsetqtspec :
  (forall f:('a,complex matrix) farray. forall s:'a set. (constant_size(s,
  f) -> subset(nonn_mat_subset(f, s), s)))

axiom nonn_mat_subsetqtspec1 :
  (forall f:('a,complex matrix) farray. forall s:'a set. (constant_size(s,
  f) -> (forall e:'a. (mem(e, nonn_mat_subset(f, s)) -> mem(e, s)))))

axiom nonn_mat_subsetqtspec2 :
  (forall f:('a,complex matrix) farray. forall s:'a set. (constant_size(s,
  f) -> constant_size(nonn_mat_subset(f, s), f)))

axiom nonn_mat_subsetqtspec3 :
  (forall f:('a,complex matrix) farray. forall s:'a set. (constant_size(s,
  f) -> ((not (nonn_mat_subset(f, s) = (empty : 'a set))) ->
  (s_rows(nonn_mat_subset(f, s), f) = s_rows(s, f)))))

axiom nonn_mat_subsetqtspec4 :
  (forall f:('a,complex matrix) farray. forall s:'a set. (constant_size(s,
  f) -> ((not (nonn_mat_subset(f, s) = (empty : 'a set))) ->
  (s_columns(nonn_mat_subset(f, s), f) = s_columns(s, f)))))

axiom mat_subset_elt :
  (forall f:('a,complex matrix) farray. forall s:'a set. (constant_size(s,
  f) -> (forall e:'a. (mem(e, nonn_mat_subset(f, s)) -> mem(e, s)))))

axiom mat_subset_nonn_elt :
  (forall f:('a,complex matrix) farray. forall s:'a set. (constant_size(s,
  f) ->
  (forall e:'a. (mem(e, nonn_mat_subset(f, s)) ->
  (not ((f[e]) = make(s_rows(s, f), s_columns(s, f), c_zero)))))))

axiom nonn_mat_sum_cardzero :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall r:int.
  forall c:int. ((cardinal(s) = 0) -> ((0 <  r) -> ((0 <  c) ->
  (mat_sum_dim(s, f, r, c) = mat_sum_dim(nonn_mat_subset(f, s), f, r, c))))))

axiom nonn_mat_sum_cardone :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall r:int.
  forall c:int. ((cardinal(s) = 1) -> ((0 <  r) -> ((0 <  c) ->
  ((rows((f[choose(s)])) = r) -> ((columns((f[choose(s)])) = c) ->
  (mat_sum_dim(s, f, r, c) = mat_sum_dim(nonn_mat_subset(f, s), f, r,
  c))))))))

axiom mat_sum_null_but_maybe_one_elt :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall e:'a.
  ((1 <  cardinal(s)) -> (constant_size(s, f) -> (mem(e, s) ->
  ((forall eqt:'a. (mem(eqt, s) -> ((not (e = eqt)) -> null_mat((f[eqt]))))) ->
  (mat_sum(s, f) = (f[e])))))))

axiom nonn_mat_sum_plus_one :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall r:int.
  forall c:int. ((1 <  cardinal(s)) -> ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  ((mat_sum_dim(remove(choose(s), s), f, r,
  c) = mat_sum_dim(nonn_mat_subset(f, remove(choose(s), s)), f, r, c)) ->
  (mat_sum_dim(s, f, r, c) = mat_sum_dim(nonn_mat_subset(f, s), f, r,
  c)))))))))

axiom nonn_mat_sum :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall r:int.
  forall c:int. ((0 <  r) -> ((0 <  c) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) -> (mat_sum_dim(s, f,
  r, c) = mat_sum_dim(nonn_mat_subset(f, s), f, r, c)))))))

logic fc169 : ('a,'c) farray,
  ('c,complex matrix) farray -> ('a,complex matrix) farray

logic fc170 : ('b,'c) farray,
  ('c,complex matrix) farray -> ('b,complex matrix) farray

axiom fcqtdef169 :
  (forall t1:('a,'c) farray. forall f:('c,complex matrix) farray.
  forall a1:'a. ((fc169(t1, f)[a1]) = (f[(t1[a1])])))

axiom fcqtdef170 :
  (forall t2:('b,'c) farray. forall f:('c,complex matrix) farray.
  forall a:'b. ((fc170(t2, f)[a]) = (f[(t2[a])])))

axiom mat_sum_map_map :
  (forall s1:'a set. forall s2:'b set. forall t1:('a,'c) farray.
  forall t2:('b,'c) farray. forall f:('c,complex matrix) farray.
  ((0 <  cardinal(s1)) -> (p_injective(t1, s1) -> (constant_size(s1,
  fc169(t1, f)) -> ((0 <  cardinal(s2)) -> (p_injective(t2, s2) ->
  (constant_size(s2, fc170(t2, f)) -> ((map(t1, s1) = map(t2, s2)) ->
  (mat_sum(map(t1, s1), f) = mat_sum(map(t2, s2), f))))))))))

axiom mat_sum_disjoint_transitivity :
  (forall s:'a set. forall s1:'a set. forall s2:'a set.
  forall f:('a,complex matrix) farray. (constant_size(s, f) -> ((inter(s1,
  s2) = (empty : 'a set)) -> ((union(s1, s2) = s) -> ((0 <  cardinal(s1)) ->
  ((0 <  cardinal(s2)) -> (add_mat(mat_sum(s1, f), mat_sum(s2,
  f)) = mat_sum(s, f))))))))

axiom mat_sum_null :
  (forall f:('a,complex matrix) farray. forall s:'a set.
  ((1 <  cardinal(s)) -> (constant_size(s, f) ->
  ((forall e:'a. (mem(e, s) ->
   (forall i:int. forall j:int. (valid_index((f[e]), i, j) -> (get((f[e]), i,
   j) = c_zero))))) ->
  (forall i:int. forall j:int. (valid_index(mat_sum(s, f), i, j) ->
  (get(mat_sum(s, f), i, j) = c_zero)))))))

axiom mat_sum_null_b :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall r:int.
  forall c:int. ((1 <  cardinal(s)) ->
  ((forall e:'a. (mem(e, s) -> (rows((f[e])) = r))) ->
  ((forall e:'a. (mem(e, s) -> (columns((f[e])) = c))) ->
  ((forall e:'a. (mem(e, s) ->
   (forall i:int. forall j:int. (valid_index((f[e]), i, j) -> (get((f[e]), i,
   j) = c_zero))))) ->
  (forall i:int. forall j:int. (((0 <= i) and (i <  r)) -> (((0 <= j) and
  (j <  c)) -> (get(mat_sum(s, f), i, j) = c_zero)))))))))

logic fc171 : ('b,complex matrix) farray, ('a,'b) farray,
  ('a,'b) farray -> ('a,complex matrix) farray

axiom fcqtdef171 :
  (forall f:('b,complex matrix) farray. forall injz:('a,'b) farray.
  forall injo:('a,'b) farray. forall e:'a. ((fc171(f, injz,
  injo)[e]) = add_mat((f[(injz[e])]), (f[(injo[e])]))))

axiom map_add_mat_sum_t :
  (forall s:'a set. forall sqt:'b set. forall f:('b,complex matrix) farray.
  forall injz:('a,'b) farray. forall injo:('a,'b) farray. (constant_size(sqt,
  f) -> ((0 <  cardinal(s)) -> ((inter(map(injz, s), map(injo,
  s)) = (empty : 'b set)) -> ((union(map(injz, s), map(injo, s)) = sqt) ->
  (p_injective(injo, s) -> (p_injective(injz, s) -> (mat_sum(s, fc171(f,
  injz, injo)) = mat_sum(sqt, f)))))))))

logic fc172 : ('a,complex matrix) farray,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef172 :
  (forall f:('a,complex matrix) farray. forall g:('a,complex matrix) farray.
  forall e:'a. ((fc172(f, g)[e]) = add_mat((f[e]), (g[e]))))

axiom map_add_mat_sum :
  (forall s:'a set. forall s1:'a set. forall s2:'a set. forall sqt:'a set.
  forall f:('a,complex matrix) farray. forall g:('a,complex matrix) farray.
  forall h:('a,complex matrix) farray. (constant_size(sqt, h) ->
  (constant_size(s, f) -> (constant_size(s, g) -> (((s_rows(sqt,
  h) = s_rows(s, f)) and (s_rows(s, f) = s_rows(s, g))) -> (((s_columns(sqt,
  h) = s_columns(s, f)) and (s_columns(s, f) = s_columns(s, g))) ->
  ((0 <  cardinal(s)) -> (p_injective(f, s) -> (p_injective(g, s) ->
  (p_injective(h, sqt) -> ((map(f, s) = map(h, s1)) -> ((map(g, s) = map(h,
  s2)) -> ((inter(s1, s2) = (empty : 'a set)) -> ((union(s1, s2) = sqt) ->
  (mat_sum(s, fc172(f, g)) = mat_sum(sqt, h))))))))))))))))

logic fc173 : bitvec -> (int,int) farray

logic fc174 : bitvec -> (int,int) farray

logic fc175 : bitvec -> (int,int) farray

logic fc176 : bitvec, int -> (int,int) farray

axiom fcqtdef173 :
  (forall bv:bitvec. forall k:int.
  ((fc173(bv)[k]) = ((value(bv)[k]) * power(2, ((length(bv) - 1) - k)))))

axiom fcqtdef174 :
  (forall bv:bitvec. forall k:int.
  ((fc174(bv)[k]) = ((value(bv)[k]) * power(2, ((length(bv) - 1) - k)))))

axiom fcqtdef175 :
  (forall bv:bitvec. forall k:int.
  ((fc175(bv)[k]) = ((value(bv)[k]) * power(2, ((length(bv) - 1) - k)))))

axiom fcqtdef176 :
  (forall bv:bitvec. forall i:int. forall k:int. ((fc176(bv,
  i)[k]) = ((value(bv)[k]) * power(2, ((i - 1) - k)))))

axiom ind_isum_mod_div :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <  length(bv))) ->
  ((ind_isum(fc173(bv), 0, length(bv)) % power(2,
  (length(bv) - i))) = ind_isum(fc174(bv), i, length(bv)))))

axiom ind_isum_mod_div1 :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <  length(bv))) ->
  ((ind_isum(fc175(bv), 0, length(bv)) / power(2,
  (length(bv) - i))) = ind_isum(fc176(bv, i), 0, i))))

logic fc177 : (int,int) farray, int -> (int,int) farray

logic fc178 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef177 :
  (forall f:(int,int) farray. forall l:int. forall k:int. ((fc177(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))))

axiom fcqtdef178 :
  (forall f:(int,int) farray. forall l:int. forall k:int. ((fc178(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))))

axiom mod_ind_isum :
  (forall f:(int,int) farray. forall i:int. forall l:int. (((0 <= i) and
  (i <= l)) -> (binary(f) -> ((ind_isum(fc177(f, l), 0, l) % power(2,
  i)) = ind_isum(fc178(f, l), (l - i), l)))))

logic fc179 : (int,int) farray, int -> (int,int) farray

logic fc180 : (int,int) farray, int, int -> (int,int) farray

axiom fcqtdef179 :
  (forall f:(int,int) farray. forall l:int. forall k:int. ((fc179(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))))

axiom fcqtdef180 :
  (forall f:(int,int) farray. forall i:int. forall l:int. forall k:int.
  ((fc180(f, i, l)[k]) = ((f[((k + l) - i)]) * power(2, ((i - 1) - k)))))

axiom mod_ind_isum_z :
  (forall f:(int,int) farray. forall i:int. forall l:int. (((0 <= i) and
  (i <= l)) -> (binary(f) -> ((ind_isum(fc179(f, l), 0, l) % power(2,
  i)) = ind_isum(fc180(f, i, l), 0, i)))))

logic fc181 : (int,int) farray, int -> (int,int) farray

logic fc182 : (int,int) farray, int, int -> (int,int) farray

axiom fcqtdef181 :
  (forall f:(int,int) farray. forall l:int. forall k:int. ((fc181(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))))

axiom fcqtdef182 :
  (forall f:(int,int) farray. forall i:int. forall l:int. forall k:int.
  ((fc182(f, i, l)[k]) = ((f[k]) * power(2, (((l - 1) - k) - i)))))

axiom div_ind_isum :
  (forall f:(int,int) farray. forall i:int. forall l:int. (((0 <= i) and
  (i <= l)) -> (binary(f) -> ((ind_isum(fc181(f, l), 0, l) / power(2,
  i)) = ind_isum(fc182(f, i, l), 0, (l - i))))))

logic fc183 : bitvec, int -> (int,int) farray

axiom fcqtdef183 :
  (forall bv:bitvec. forall i:int. forall l:int. ((fc183(bv,
  i)[l]) = ((value(bv)[l]) * power(2, (i - l)))))

axiom ind_isum_mod :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <  length(bv))) ->
  ((ind_isum(fc183(bv, i), 0, (i + 1)) % 2) = (value(bv)[i]))))

logic fc184 : (int,int) farray, int -> (int,int) farray

logic fc185 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef184 :
  (forall f:(int,int) farray. forall l:int. forall k:int. ((fc184(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))))

axiom fcqtdef185 :
  (forall f:(int,int) farray. forall l:int. forall k:int. ((fc185(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))))

axiom mod_ind_isum_ :
  (forall f:(int,int) farray. forall i:int. forall l:int. (((0 <= i) and
  (i <= l)) -> (binary(f) -> ((ind_isum(fc184(f, l), 0, l) % power(2,
  i)) = ind_isum(fc185(f, l), (l - i), l)))))

logic fc186 : (int,int) farray, int -> (int,int) farray

logic fc187 : (int,int) farray, int, int -> (int,int) farray

axiom fcqtdef186 :
  (forall f:(int,int) farray. forall l:int. forall k:int. ((fc186(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))))

axiom fcqtdef187 :
  (forall f:(int,int) farray. forall i:int. forall l:int. forall k:int.
  ((fc187(f, i, l)[k]) = ((f[((k + l) - i)]) * power(2, ((i - 1) - k)))))

axiom mod_ind_isum_z_ :
  (forall f:(int,int) farray. forall i:int. forall l:int. (((0 <= i) and
  (i <= l)) -> (binary(f) -> ((ind_isum(fc186(f, l), 0, l) % power(2,
  i)) = ind_isum(fc187(f, i, l), 0, i)))))

logic fc188 : (int,int) farray, int -> (int,int) farray

logic fc189 : (int,int) farray, int, int -> (int,int) farray

axiom fcqtdef188 :
  (forall f:(int,int) farray. forall l:int. forall k:int. ((fc188(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))))

axiom fcqtdef189 :
  (forall f:(int,int) farray. forall i:int. forall l:int. forall k:int.
  ((fc189(f, i, l)[k]) = ((f[k]) * power(2, (((l - 1) - k) - i)))))

axiom div_ind_isum_ :
  (forall f:(int,int) farray. forall i:int. forall l:int. (((0 <= i) and
  (i <= l)) -> (binary(f) -> ((ind_isum(fc188(f, l), 0, l) / power(2,
  i)) = ind_isum(fc189(f, i, l), 0, (l - i))))))

logic fc190 : bitvec, int -> (int,int) farray

axiom fcqtdef190 :
  (forall bv:bitvec. forall i:int. forall l:int. ((fc190(bv,
  i)[l]) = ((value(bv)[l]) * power(2, (i - l)))))

axiom ind_isum_mod_ :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <  length(bv))) ->
  ((ind_isum(fc190(bv, i), 0, (i + 1)) % 2) = (value(bv)[i]))))

logic fc191 : bitvec -> (int,int) farray

logic fc192 : bitvec -> (int,int) farray

axiom fcqtdef191 :
  (forall bv:bitvec. forall l:int.
  ((fc191(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom fcqtdef192 :
  (forall bv:bitvec. forall l:int.
  ((fc192(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom bv_to_int_kth_pre :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  (length(bv) - 1))) ->
  ((value(bv)[k]) = ((ind_isum(fc191(bv), 0, length(bv)) / power(2,
  ((length(bv) - k) - 1))) % 2))))

axiom bv_to_int_kth_pre1 :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  (length(bv) - 1))) ->
  ((value(bv)[k]) = ((ind_isum(fc192(bv), 0, length(bv)) % power(2,
  (length(bv) - k))) / power(2, ((length(bv) - k) - 1))))))

logic fc193 : int, int -> (int,int) farray

axiom fcqtdef193 :
  (forall i:int. forall n:int. forall l:int. ((fc193(i,
  n)[l]) = ((value(int_to_bv(i, n))[l]) * power(2, ((n - l) - 1)))))

axiom int_to_bv_sum_pre :
  (forall i:int. forall n:int. forall k:int. (((k <= n) and (0 <= k)) ->
  (((0 <= i) and (i <  power(2, n))) -> ((i % power(2,
  k)) = ind_isum(fc193(i, n), (n - k), n)))))

logic fc194 : int, int -> (int,int) farray

axiom fcqtdef194 :
  (forall i:int. forall n:int. forall k:int. ((fc194(i,
  n)[k]) = ((value(int_to_bv(i, n))[k]) * power(2, ((n - 1) - k)))))

axiom int_to_bv_sum :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (i = ind_isum(fc194(i, n), 0, n)))))

logic fc195 : int, int -> (int,int) farray

axiom fcqtdef195 :
  (forall i:int. forall n:int. forall k:int. ((fc195(i,
  n)[k]) = ((value(int_to_bv(i, n))[k]) * power(2, ((n - k) - 1)))))

axiom int_to_bv_sum_rev :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (ind_isum(fc195(i, n), 0, n) = i))))

logic fc196 : int, int -> (int,int) farray

axiom fcqtdef196 :
  (forall i:int. forall n:int. forall k:int. ((fc196(i,
  n)[k]) = ((i / power(2, ((n - k) - 1))) % 2)))

axiom int_to_bv_mod_div :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_to_bv(i, n) = make_bv(fc196(i, n), n)))))

logic fc197 : int, int -> (int,int) farray

axiom fcqtdef197 :
  (forall i:int. forall n:int. forall l:int. ((fc197(i,
  n)[l]) = ((value(int_to_bv(i, n))[l]) * power(2, ((n - 1) - l)))))

axiom mod_isum :
  (forall i:int. forall k:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> ((i % power(2,
  k)) = ind_isum(fc197(i, n), (n - k), n))))))

logic fc198 : int, int, int -> (int,int) farray

axiom fcqtdef198 :
  (forall i:int. forall k:int. forall n:int. forall l:int. ((fc198(i, k,
  n)[l]) = ((value(int_to_bv(i, n))[(l + (n - k))]) * power(2,
  ((k - l) - 1)))))

axiom mod_isum_z :
  (forall i:int. forall k:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> ((i % power(2,
  k)) = ind_isum(fc198(i, k, n), 0, k))))))

logic fc199 : int, int, int -> (int,int) farray

axiom fcqtdef199 :
  (forall i:int. forall k:int. forall n:int. forall l:int. ((fc199(i, k,
  n)[l]) = ((value(int_to_bv(i, n))[l]) * power(2, (((n - 1) - k) - l)))))

axiom div_isum :
  (forall i:int. forall k:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> ((i / power(2,
  k)) = ind_isum(fc199(i, k, n), 0, (n - k)))))))

logic fc200 : int, int -> (int,int) farray

axiom fcqtdef200 :
  (forall i:int. forall n:int. forall k:int. ((fc200(i,
  n)[k]) = ((i % power(2, (n - k))) / power(2, ((n - k) - 1)))))

axiom int_to_bv_div_mod :
  (forall i:int. forall k:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> (int_to_bv(i,
  n) = make_bv(fc200(i, n), n))))))

axiom int_to_bv_value :
  (forall i:int. forall n:int. forall k:int. ((0 <  n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> ((value(int_to_bv(i,
  n))[k]) = ((i / power(2, ((n - k) - 1))) % 2))))))

axiom int_to_bv_value_zero :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> ((value(int_to_bv(i, n))[0]) = (if (i <  power(2,
  (n - 1))) then 0 else 1)))))

logic fc201 : int, int -> (int,int) farray

axiom fcqtdef201 :
  (forall i:int. forall n:int. forall k:int. ((fc201(i,
  n)[k]) = ((i / power(2, ((n - k) - 1))) % 2)))

axiom int_to_bv_mod_div_ :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_to_bv(i, n) = make_bv(fc201(i, n), n)))))

logic fc202 : int, int -> (int,int) farray

axiom fcqtdef202 :
  (forall i:int. forall n:int. forall l:int. ((fc202(i,
  n)[l]) = ((value(int_to_bv(i, n))[l]) * power(2, ((n - 1) - l)))))

axiom mod_isum_ :
  (forall i:int. forall k:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> ((i % power(2,
  k)) = ind_isum(fc202(i, n), (n - k), n))))))

logic fc203 : int, int, int -> (int,int) farray

axiom fcqtdef203 :
  (forall i:int. forall k:int. forall n:int. forall l:int. ((fc203(i, k,
  n)[l]) = ((value(int_to_bv(i, n))[(l + (n - k))]) * power(2,
  ((k - l) - 1)))))

axiom mod_isum_z_ :
  (forall i:int. forall k:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> ((i % power(2,
  k)) = ind_isum(fc203(i, k, n), 0, k))))))

logic fc204 : int, int, int -> (int,int) farray

axiom fcqtdef204 :
  (forall i:int. forall k:int. forall n:int. forall l:int. ((fc204(i, k,
  n)[l]) = ((value(int_to_bv(i, n))[l]) * power(2, (((n - 1) - k) - l)))))

axiom div_isum_ :
  (forall i:int. forall k:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> ((i / power(2,
  k)) = ind_isum(fc204(i, k, n), 0, (n - k)))))))

logic fc205 : int, int -> (int,int) farray

axiom fcqtdef205 :
  (forall i:int. forall n:int. forall k:int. ((fc205(i,
  n)[k]) = ((i % power(2, (n - k))) / power(2, ((n - k) - 1)))))

axiom int_to_bv_div_mod_ :
  (forall i:int. forall k:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> (int_to_bv(i,
  n) = make_bv(fc205(i, n), n))))))

axiom int_to_bv_value_ :
  (forall i:int. forall n:int. forall k:int. ((0 <  n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  n)) -> ((value(int_to_bv(i,
  n))[k]) = ((i / power(2, ((n - k) - 1))) % 2))))))

axiom int_to_bv_value_zero_ :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> ((value(int_to_bv(i, n))[0]) = (if (i <  power(2,
  (n - 1))) then 0 else 1)))))

axiom int_to_bv_zero :
  (forall n:int.
  (forall k:int. (((0 <= k) and (k <  n)) -> ((value(int_to_bv(0,
  n))[k]) = 0))))

logic fc206 : int, int -> (int,int) farray

axiom fcqtdef206 :
  (forall i:int. forall n:int. forall k:int. ((fc206(i,
  n)[k]) = ((value(int_to_bv(i, n))[k]) * power(2, ((n - k) - 1)))))

axiom int_to_sum :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (i = ind_isum(fc206(i, n), 0, n)))))

axiom int_to_bv_transl :
  (forall i:int. forall k:int. forall n:int. forall t:int. (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= k) and (k <  (n - t))) -> (((0 <  t) and
  (t <= n)) -> ((value(int_to_bv((i % power(2, (n - t))),
  (n - t)))[k]) = (value(int_to_bv(i, n))[(k + t)]))))))

axiom int_to_bv_transl_div :
  (forall i:int. forall k:int. forall n:int. forall nqt:int. forall t:int.
  (((0 <= i) and (i <  power(2, n))) -> (((0 <= k) and (k <  t)) ->
  ((nqt = t) -> (((0 <  t) and (t <= n)) -> ((value(int_to_bv((i / power(2,
  (n - t))), nqt))[k]) = (value(int_to_bv(i, n))[k])))))))

logic fc207 : int, int -> (int,int) farray

axiom fcqtdef207 :
  (forall n:int. forall i:int. forall j:int. ((fc207(n,
  i)[j]) = (1 - (value(int_to_bv(i, n))[j]))))

axiom product_int_to_bv_inv :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (ind_iproduct(fc207(n, i), 0, n) = (if (i = 0) then 1 else 0)))))

logic bin_to_int : (int,int) farray, int -> int

axiom bin_to_intqtdef :
  (forall f:(int,int) farray. forall n:int. ((0 <= n) -> (binary_l(f, n) ->
  (bin_to_int(f, n) = bv_to_int(make_bv(f, n))))))

logic fc208 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef208 :
  (forall f:(int,int) farray. forall n:int. forall k:int. ((fc208(f,
  n)[k]) = ((f[k]) * power(2, ((n - 1) - k)))))

axiom bin_to_intqtspec :
  (forall f:(int,int) farray. forall n:int. ((0 <= n) -> (binary_l(f, n) ->
  (bin_to_int(f, n) = ind_isum(fc208(f, n), 0, n)))))

axiom bin_to_intqtspec1 :
  (forall f:(int,int) farray. forall n:int. ((0 <= n) -> (binary_l(f, n) ->
  (0 <= bin_to_int(f, n)))))

logic int_to_bin : int, int -> (int,int) farray

axiom int_to_binqtdef :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_to_bin(i, n) = value(int_to_bv(i, n))))))

logic fc209 : int, int -> (int,int) farray

axiom fcqtdef209 :
  (forall i:int. forall n:int. forall k:int. ((fc209(i,
  n)[k]) = ((int_to_bin(i, n)[k]) * power(2, ((n - 1) - k)))))

axiom int_to_binqtspec :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (i = ind_isum(fc209(i, n), 0, n)))))

axiom int_to_binqtspec1 :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> binary(int_to_bin(i, n)))))

axiom int_to_binqtspec2 :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) ->
  (forall k:int. (((0 <= k) and (k <  n)) -> ((int_to_bin(i,
  n)[k]) = ((i / power(2, ((n - k) - 1))) % 2)))))))

axiom int_to_bv_tail :
  (forall i:int. forall n:int. ((1 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_to_bv(tail_bits(i, n), (n - 1)) = tail(int_to_bv(i, n))))))

logic fc210 : bitvec -> (int,int) farray

axiom fcqtdef210 :
  (forall bv:bitvec. forall l:int.
  ((fc210(bv)[l]) = ((value(bv)[l]) * power(2, (length(bv) - l)))))

axiom bound_sum_dec :
  (forall bv:bitvec. forall i:int. (((1 <= i) and (i <= length(bv))) ->
  (ind_isum(fc210(bv), i, (length(bv) + 1)) <  power(2,
  ((length(bv) - i) + 1)))))

axiom bv_to_int_to_bv :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (bv_to_int(int_to_bv(i, n)) = i))))

axiom bv_to_int_to_bv_ :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (bv_to_int(int_to_bv(i, n)) = i))))

logic fc211 : int, int -> (int,int) farray

axiom fcqtdef211 :
  (forall i:int. forall n:int. forall l:int. ((fc211(i,
  n)[l]) = ((value(int_to_bv(i, n))[l]) * power(2, ((n - 1) - l)))))

axiom tail_bits_sum :
  (forall i:int. forall n:int. ((1 <  n) -> ((0 <= i) -> (((0 <= i) and
  (i <  power(2, n))) -> (tail_bits(i, n) = ind_isum(fc211(i, n), 1, n))))))

axiom int_to_bv_to_int :
  (forall bv:bitvec. ((1 <= length(bv)) -> (int_to_bv(bv_to_int(bv),
  length(bv)) = bv)))

axiom int_to_bv_to_int_ :
  (forall bv:bitvec. forall l:int. ((0 <= l) -> ((length(bv) = l) ->
  (int_to_bv(bv_to_int(bv), l) = bv))))

axiom int_to_bv_to_int_rev :
  (forall bv:bitvec. forall l:int. ((0 <= l) -> ((length(bv) = l) ->
  (bv = int_to_bv(bv_to_int(bv), l)))))

axiom concat_to_int :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <= 1)) ->
  (bv_to_int(concat_l(bv, i)) = (bv_to_int(bv) + (i * power(2,
  length(bv)))))))

axiom bounded_to_int :
  (forall bv:bitvec. (bv_to_int(bv) <  power(2, length(bv))))

axiom int_to_bv_to_int_value :
  (forall bv:bitvec. forall i:int. ((1 <= length(bv)) ->
  ((value(int_to_bv(bv_to_int(bv), length(bv)))[i]) = (if ((0 <= i) and
  (i <  length(bv))) then (value(bv)[i]) else 0))))

axiom int_to_bv_to_int_gen :
  (forall bv:bitvec. forall n:int. ((1 <= length(bv)) -> ((n = length(bv)) ->
  (int_to_bv(bv_to_int(bv), n) = bv))))

logic fc212 : bitvec -> (int,int) farray

axiom fcqtdef212 :
  (forall bv:bitvec. forall l:int.
  ((fc212(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom bv_to_int_mod :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  length(bv))) ->
  ((bv_to_int(bv) % power(2, (length(bv) - k))) = ind_isum(fc212(bv), k,
  length(bv)))))

logic fc213 : bitvec -> (int,int) farray

axiom fcqtdef213 :
  (forall bv:bitvec. forall l:int.
  ((fc213(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom bv_to_int_mod_rev :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  length(bv))) ->
  (ind_isum(fc213(bv), k, length(bv)) = (bv_to_int(bv) % power(2,
  (length(bv) - k))))))

logic fc214 : bitvec -> (int,int) farray

axiom fcqtdef214 :
  (forall bv:bitvec. forall l:int.
  ((fc214(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom bv_to_int_mod_gen :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall bv:bitvec. ((length(bv) = n) -> ((bv_to_int(bv) % power(2,
  (length(bv) - k))) = ind_isum(fc214(bv), k, length(bv)))))))

axiom to_int_head_tail :
  (forall bv:bitvec. ((1 <= length(bv)) ->
  (bv_to_int(bv) = (bv_to_int(tail(bv)) + (head(bv) * power(2,
  (length(bv) - 1)))))))

axiom to_int_head_tail1 :
  (forall bv:bitvec. ((1 <= length(bv)) ->
  (bv_to_int(tail(bv)) = (bv_to_int(bv) % power(2, (length(bv) - 1))))))

logic my_map : ('a,'b) farray, 'a set -> 'b set

axiom my_mapqtdef :
  (forall f:('a,'b) farray. forall u:'a set. ((cardinal(u) = 0) -> (my_map(f,
  u) = (empty : 'b set))))

axiom my_mapqtdef1 :
  (forall f:('a,'b) farray. forall u:'a set. ((not (cardinal(u) = 0)) ->
  (my_map(f, u) = add((f[choose(u)]), my_map(f, remove(choose(u), u))))))

axiom my_mapqtspec :
  (forall f:('a,'b) farray. forall u:'a set. (my_map(f, u) = map(f, u)))

axiom my_map_to_map :
  (forall f:('a,'b) farray. forall u:'a set. (my_map(f, u) = map(f, u)))

axiom map_to_my_map :
  (forall f:('a,'b) farray. forall u:'a set. (map(f, u) = my_map(f, u)))

logic mapz_pre : int, bitvec set -> bitvec set

logic result21 : (bitvec,bitvec) farray

axiom resultqtdef26 : (forall bv:bitvec. ((result21[bv]) = concat_l(bv, 0)))

axiom mapz_preqtdef :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) -> (mapz_pre(n,
  s) = my_map(result21, s)))))

logic fc215 : (int,int) farray

axiom fcqtdef215 : (forall us:int. ((fc215[us]) = 0))

axiom mapz_preqtspec :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  mem(make_bv(fc215, n), mapz_pre(n, s)))))

axiom mapz_preqtspec1 :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  (forall e:bitvec. (mem(e, mapz_pre(n, s)) -> ((value(e)[0]) = 0))))))

axiom mapz_preqtspec2 :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  (forall e:bitvec. (mem(e, mapz_pre(n, s)) ->
  (exists bv:bitvec. (mem(bv, s) and (e = concat_l(bv, 0)))))))))

axiom mapz_preqtspec3 :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  (forall e:bitvec. (mem(e, mapz_pre(n, s)) -> (length(e) = n))))))

axiom mapz_preqtspec4 :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  (forall e:bitvec. ((length(e) = n) -> (((value(e)[0]) = 0) -> mem(e,
  mapz_pre(n, s))))))))

logic mapo_pre : int, bitvec set -> bitvec set

logic result22 : (bitvec,bitvec) farray

axiom resultqtdef27 : (forall bv:bitvec. ((result22[bv]) = concat_l(bv, 1)))

axiom mapo_preqtdef :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) -> (mapo_pre(n,
  s) = my_map(result22, s)))))

logic fc216 : (int,int) farray

axiom fcqtdef216 : (forall us:int. ((fc216[us]) = 1))

axiom mapo_preqtspec :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  mem(make_bv(fc216, n), mapo_pre(n, s)))))

axiom mapo_preqtspec1 :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  (forall e:bitvec. (mem(e, mapo_pre(n, s)) -> ((value(e)[0]) = 1))))))

axiom mapo_preqtspec2 :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  (forall e:bitvec. (mem(e, mapo_pre(n, s)) ->
  (exists bv:bitvec. (mem(bv, s) and (e = concat_l(bv, 1)))))))))

axiom mapo_preqtspec3 :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  (forall e:bitvec. (mem(e, mapo_pre(n, s)) -> (length(e) = n))))))

axiom mapo_preqtspec4 :
  (forall n:int. forall s:bitvec set. ((1 <= n) ->
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  (forall e:bitvec. ((length(e) = n) -> (((value(e)[0]) = 1) -> mem(e,
  mapo_pre(n, s))))))))

logic n_bvs : int -> bitvec set

axiom n_bvsqtspec :
  (forall n:int. ((0 <= n) -> ((1 <= n) ->
  (forall s:bitvec set.
  ((forall f:bitvec. (mem(f, s) <-> (length(f) = (n - 1)))) ->
  (n_bvs(n) = union(mapz_pre(n, s), mapo_pre(n, s))))))))

axiom n_bvsqtspec1 :
  (forall n:int. ((0 <= n) ->
  (forall f:bitvec. (mem(f, n_bvs(n)) -> (length(f) = n)))))

axiom n_bvsqtspec2 :
  (forall n:int. ((0 <= n) ->
  (forall f:bitvec. (mem(f, n_bvs(n)) -> (length(f) = n)))))

axiom n_bvsqtspec3 :
  (forall n:int. ((0 <= n) ->
  (forall f:bitvec. ((length(f) = n) -> mem(f, n_bvs(n))))))

axiom n_bvsqtspec4 : (forall n:int. ((0 <= n) -> (0 <  cardinal(n_bvs(n)))))

axiom in_n_bvs :
  (forall x:bitvec. forall n:int. ((0 <= n) -> ((length(x) = n) -> mem(x,
  n_bvs(n)))))

axiom get_in_n_bvs :
  (forall x:bitvec. forall n:int. ((0 <= n) -> (mem(x, n_bvs(n)) ->
  (length(x) = n))))

logic mapz : int -> bitvec set

axiom mapzqtdef :
  (forall n:int. ((1 <= n) -> (mapz(n) = mapz_pre(n, n_bvs((n - 1))))))

logic fc217 : (bitvec,bitvec) farray

axiom fcqtdef217 : (forall bv:bitvec. ((fc217[bv]) = concat_l(bv, 0)))

axiom mapzqtspec :
  (forall n:int. ((1 <= n) -> (mapz(n) = my_map(fc217, n_bvs((n - 1))))))

axiom mapzqtspec1 : (forall n:int. ((1 <= n) -> (0 <  cardinal(mapz(n)))))

axiom mapzqtspec2 :
  (forall n:int. ((1 <= n) ->
  (forall e:bitvec. (mem(e, mapz(n)) -> ((value(e)[0]) = 0)))))

axiom mapzqtspec3 :
  (forall n:int. ((1 <= n) ->
  (forall e:bitvec. (mem(e, mapz(n)) ->
  (exists bv:bitvec. (mem(bv, n_bvs((n - 1))) and (e = concat_l(bv, 0))))))))

axiom mapzqtspec4 :
  (forall n:int. ((1 <= n) ->
  (forall e:bitvec. (mem(e, mapz(n)) -> (length(e) = n)))))

axiom mapzqtspec5 :
  (forall n:int. ((1 <= n) ->
  (forall e:bitvec. ((length(e) = n) -> (((value(e)[0]) = 0) -> mem(e,
  mapz(n)))))))

logic mapo : int -> bitvec set

axiom mapoqtdef :
  (forall n:int. ((1 <= n) -> (mapo(n) = mapo_pre(n, n_bvs((n - 1))))))

logic fc218 : (bitvec,bitvec) farray

axiom fcqtdef218 : (forall bv:bitvec. ((fc218[bv]) = concat_l(bv, 1)))

axiom mapoqtspec :
  (forall n:int. ((1 <= n) -> (mapo(n) = my_map(fc218, n_bvs((n - 1))))))

axiom mapoqtspec1 : (forall n:int. ((1 <= n) -> (0 <  cardinal(mapo(n)))))

axiom mapoqtspec2 :
  (forall n:int. ((1 <= n) ->
  (forall e:bitvec. (mem(e, mapo(n)) -> ((value(e)[0]) = 1)))))

axiom mapoqtspec3 :
  (forall n:int. ((1 <= n) ->
  (forall e:bitvec. (mem(e, mapo(n)) ->
  (exists bv:bitvec. (mem(bv, n_bvs((n - 1))) and (e = concat_l(bv, 1))))))))

axiom mapoqtspec4 :
  (forall n:int. ((1 <= n) ->
  (forall e:bitvec. (mem(e, mapo(n)) -> (length(e) = n)))))

axiom mapoqtspec5 :
  (forall n:int. ((1 <= n) ->
  (forall e:bitvec. ((length(e) = n) -> (((value(e)[0]) = 1) -> mem(e,
  mapo(n)))))))

axiom n_bvs_node :
  (forall n:int. ((0 <  n) -> (inter(mapz(n),
  mapo(n)) = (empty : bitvec set))))

axiom n_bvs_node1 :
  (forall n:int. ((0 <  n) -> (union(mapz(n), mapo(n)) = n_bvs(n))))

logic fc219 : (int,int) farray

logic fc220 : (int,int) farray

logic fc221 : (int,int) farray

logic fc222 : (int,int) farray

axiom fcqtdef219 : (forall us:int. ((fc219[us]) = 0))

axiom fcqtdef220 : (forall us:int. ((fc220[us]) = 0))

axiom fcqtdef221 : (forall us:int. ((fc221[us]) = 0))

axiom fcqtdef222 : (forall us:int. ((fc222[us]) = 0))

axiom n_bvszqtspec : (forall x:bitvec. ((length(x) = 0) -> mem(x, n_bvs(0))))

axiom n_bvszqtspec1 :
  (forall x:bitvec. (mem(x, n_bvs(0)) -> (x = make_bv(fc219, 0))))

axiom n_bvszqtspec2 : (n_bvs(0) = add(make_bv(fc220, 0),
  (empty : bitvec set)))

axiom n_bvszqtspec3 : (choose(n_bvs(0)) = make_bv(fc221, 0))

axiom n_bvszqtspec4 :
  (forall f:(bitvec,complex matrix) farray. (mat_sum(n_bvs(0),
  f) = (f[make_bv(fc222, 0)])))

logic fc223 : (int,int) farray

logic fc224 : (int,int) farray

logic fc225 : (int,int) farray

logic fc226 : (int,int) farray

axiom fcqtdef223 : (forall us:int. ((fc223[us]) = 0))

axiom fcqtdef224 : (forall us:int. ((fc224[us]) = 1))

axiom fcqtdef225 : (forall us:int. ((fc225[us]) = 0))

axiom fcqtdef226 : (forall us:int. ((fc226[us]) = 1))

axiom n_bvsoqtspec : (forall x:bitvec. ((length(x) = 1) -> mem(x, n_bvs(1))))

axiom n_bvsoqtspec1 :
  (forall x:bitvec. (mem(x, n_bvs(1)) -> (length(x) = 1)))

axiom n_bvsoqtspec2 : (n_bvs(1) = add(make_bv(fc223, 1), add(make_bv(fc224,
  1), (empty : bitvec set))))

axiom n_bvsoqtspec3 :
  (forall f:(bitvec,complex matrix) farray. (constant_size(n_bvs(1), f) ->
  (mat_sum(n_bvs(1), f) = add_mat((f[make_bv(fc225, 1)]), (f[make_bv(fc226,
  1)])))))

logic fc227 : (bitvec,bitvec) farray

logic fc228 : (bitvec,bitvec) farray

axiom fcqtdef227 : (forall bv:bitvec. ((fc227[bv]) = concat_l(bv, 0)))

axiom fcqtdef228 : (forall bv:bitvec. ((fc228[bv]) = concat_l(bv, 1)))

axiom injective_node :
  (forall n:int. ((0 <= n) -> p_injective(fc227, n_bvs(n))))

axiom injective_node1 :
  (forall n:int. ((0 <= n) -> p_injective(fc228, n_bvs(n))))

logic fc229 : (bitvec,complex matrix) farray -> (bitvec,complex matrix) farray

logic fc230 : (bitvec,complex matrix) farray -> (bitvec,complex matrix) farray

axiom fcqtdef229 :
  (forall f:(bitvec,complex matrix) farray. forall bv:bitvec.
  ((fc229(f)[bv]) = (f[concat_l(bv, 0)])))

axiom fcqtdef230 :
  (forall f:(bitvec,complex matrix) farray. forall bv:bitvec.
  ((fc230(f)[bv]) = (f[concat_l(bv, 1)])))

axiom mat_sum_n_bvs_pos :
  (forall n:int. forall f:(bitvec,complex matrix) farray. ((0 <  n) ->
  (constant_size(n_bvs(n), f) -> (mat_sum(n_bvs(n),
  f) = add_mat(mat_sum(n_bvs((n - 1)), fc229(f)), mat_sum(n_bvs((n - 1)),
  fc230(f)))))))

logic fc231 : (int,(int,int) farray) farray

axiom fcqtdef231 : (forall y0:int. forall y1:int. (((fc231[y0])[y1]) = y0))

axiom mat_sum_n_bvs_null :
  (forall f:(bitvec,complex matrix) farray. (mat_sum(n_bvs(0),
  f) = (f[make_bv((fc231[0]), 0)])))

logic fc232 : (int,(int,int) farray) farray

axiom fcqtdef232 : (forall y0:int. forall y1:int. (((fc232[y0])[y1]) = y0))

axiom mat_sum_n_bvs_null_eq :
  (forall f:(bitvec,complex matrix) farray. forall x:complex matrix.
  ((x = (f[make_bv((fc232[0]), 0)])) -> (mat_sum(n_bvs(0), f) = x)))

axiom get_n_bvs : (forall bv:bitvec. mem(bv, n_bvs(length(bv))))

axiom get_n_bvs_gen :
  (forall bv:bitvec. forall l:int. ((l = length(bv)) -> mem(bv, n_bvs(l))))

axiom set_n_bvs :
  (forall bv:bitvec. (mem(bv, n_bvs(length(bv))) ->
  (forall i:int. ((not ((0 <= i) and (i <  length(bv)))) ->
  ((value(bv)[i]) = 0)))))

axiom int_to_bv_n_bvs :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> mem(int_to_bv(i, n), n_bvs(n)))))

logic fc233 : (bitvec,bitvec) farray

logic fc234 : (bitvec,bitvec) farray

axiom fcqtdef233 : (forall bv:bitvec. ((fc233[bv]) = concat_l(bv, 0)))

axiom fcqtdef234 : (forall bv:bitvec. ((fc234[bv]) = concat_l(bv, 1)))

axiom n_bvs_def_pos :
  (forall n:int. ((0 <  n) -> (n_bvs(n) = union(map(fc233, n_bvs((n - 1))),
  map(fc234, n_bvs((n - 1)))))))

logic bv_to_int_closure : (bitvec,int) farray

axiom bv_to_int_closure_def :
  (forall y:bitvec. ((bv_to_int_closure[y]) = bv_to_int(y)))

axiom map_n_bvs :
  (forall n:int. ((0 <  n) -> (to_fset(0, power(2,
  n)) = map(bv_to_int_closure, n_bvs(n)))))

logic fc235 : (int,complex) farray -> (bitvec,complex) farray

axiom fcqtdef235 :
  (forall f:(int,complex) farray. forall k:bitvec.
  ((fc235(f)[k]) = (f[bv_to_int(k)])))

axiom ind_sum_bv :
  (forall f:(int,complex) farray. forall n:int. ((1 <= n) -> (ind_sum(f, 0,
  power(2, n)) = sum(n_bvs(n), fc235(f)))))

logic first_div : bitvec, bitvec -> int

axiom first_divqtspec :
  (forall bv1:bitvec. forall bv2:bitvec. ((length(bv1) = length(bv2)) ->
  ((not (bv1 = bv2)) ->
  (forall j:int. (((0 <= j) and (j <  first_div(bv1, bv2))) ->
  ((value(bv1)[j]) = (value(bv2)[j])))))))

axiom first_divqtspec1 :
  (forall bv1:bitvec. forall bv2:bitvec. ((length(bv1) = length(bv2)) ->
  ((not (bv1 = bv2)) -> ((first_div(bv1, bv2) <  length(bv1)) ->
  (not ((value(bv1)[first_div(bv1, bv2)]) = (value(bv2)[first_div(bv1,
  bv2)])))))))

axiom first_divqtspec2 :
  (forall bv1:bitvec. forall bv2:bitvec. ((length(bv1) = length(bv2)) ->
  ((not (bv1 = bv2)) -> (0 <= first_div(bv1, bv2)))))

axiom first_divqtspec3 :
  (forall bv1:bitvec. forall bv2:bitvec. ((length(bv1) = length(bv2)) ->
  ((not (bv1 = bv2)) -> (first_div(bv1, bv2) <  length(bv1)))))

logic fc236 : int -> (bitvec,bitvec) farray

axiom fcqtdef236 :
  (forall i:int. forall bv:bitvec. ((fc236(i)[bv]) = concat_l(bv, i)))

axiom injective_concat :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <= 1)) ->
  p_injective(fc236(i), n_bvs(n)))))

axiom inf_first_div :
  (forall bv1:bitvec. forall bv2:bitvec. ((length(bv1) = length(bv2)) ->
  ((not (bv1 = bv2)) ->
  (forall j:int. ((1 <= j) -> ((not ((value(bv1)[j]) = (value(bv2)[j]))) ->
  (first_div(bv1, bv2) <= j)))))))

axiom first_div_diff :
  (forall bv1:bitvec. forall bv2:bitvec. ((length(bv1) = length(bv2)) ->
  ((not (bv1 = bv2)) -> (not ((value(bv1)[first_div(bv1,
  bv2)]) = (value(bv2)[first_div(bv1, bv2)]))))))

axiom exists_first_div :
  (forall bv1:bitvec. forall bv2:bitvec. ((length(bv1) = length(bv2)) ->
  ((not (bv1 = bv2)) ->
  (exists i:int. (((0 <= i) and (i <  length(bv1))) and (i = first_div(bv1,
  bv2)))))))

axiom set_diff_length :
  (forall bv1:bitvec. forall bv2:bitvec.
  ((not (length(bv1) = length(bv2))) -> (not (bv1 = bv2))))

axiom set_diff_val :
  (forall bv1:bitvec. forall bv2:bitvec. forall i:int.
  ((length(bv1) = length(bv2)) -> (((0 <= i) and (i <  length(bv1))) ->
  ((not ((value(bv1)[i]) = (value(bv2)[i]))) -> (not (bv1 = bv2))))))

logic fc237 : bitvec -> (int,int) farray

logic fc238 : bitvec -> (int,int) farray

logic fc239 : bitvec -> (int,int) farray

logic fc240 : bitvec -> (int,int) farray

axiom fcqtdef237 :
  (forall bv:bitvec. forall l:int.
  ((fc237(bv)[l]) = (if (l <  length(bv)) then ((value(bv)[l]) * power(2,
  ((length(bv) - 1) - l))) else 0)))

axiom fcqtdef238 :
  (forall bv:bitvec. forall l:int.
  ((fc238(bv)[l]) = (if (l <  length(bv)) then ((value(bv)[l]) * power(2,
  ((length(bv) - 1) - l))) else 0)))

axiom fcqtdef239 :
  (forall bv:bitvec. forall l:int.
  ((fc239(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom fcqtdef240 :
  (forall bv:bitvec. forall l:int.
  ((fc240(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom kth_decomp :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  length(bv))) ->
  (bv_to_int(bv) = ((ind_isum(fc237(bv), 0, k) + ((value(bv)[k]) * power(2,
  ((length(bv) - 1) - k)))) + ind_isum(fc238(bv), (k + 1), length(bv))))))

axiom kth_decomp1 :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  length(bv))) ->
  (bv_to_int(bv) = ((ind_isum(fc239(bv), 0, k) + ((value(bv)[k]) * power(2,
  ((length(bv) - 1) - k)))) + ind_isum(fc240(bv), (k + 1), length(bv))))))

logic fc241 : int, int, int -> (int,complex) farray

axiom fcqtdef241 :
  (forall i:int. forall j:int. forall n:int. forall k:int. ((fc241(i, j,
  n)[k]) = indic((value(int_to_bv(i, n))[k]), (value(int_to_bv(j, n))[k]))))

axiom int_to_bv_prod :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= j) and (j <  power(2, n))) ->
  (ind_product(fc241(i, j, n), 0, n) = indic(i, j))))))

logic fc242 : int, int, int -> (int,complex) farray

axiom fcqtdef242 :
  (forall i:int. forall n:int. forall j:int. forall k:int. ((fc242(i, n,
  j)[k]) = indic((value(int_to_bv(i, n))[k]), (value(int_to_bv(j, n))[k]))))

axiom int_to_bv_prod_gen :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) ->
  (forall j:int. (((0 <= j) and (j <  power(2, n))) -> (ind_product(fc242(i,
  n, j), 0, n) = indic(i, j)))))))

logic fc243 : bitvec -> (int,int) farray

logic fc244 : bitvec -> (int,int) farray

axiom fcqtdef243 :
  (forall bv:bitvec. forall l:int.
  ((fc243(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom fcqtdef244 :
  (forall bv:bitvec. forall l:int.
  ((fc244(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom kth_decomp_bound_zero :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  length(bv))) ->
  (((value(bv)[k]) = 0) -> (ind_isum(fc243(bv), 0, k) <= bv_to_int(bv)))))

axiom kth_decomp_bound_zero1 :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  length(bv))) ->
  (((value(bv)[k]) = 0) -> (bv_to_int(bv) <  (ind_isum(fc244(bv), 0,
  k) + power(2, ((length(bv) - k) - 1)))))))

logic fc245 : bitvec -> (int,int) farray

logic fc246 : bitvec -> (int,int) farray

axiom fcqtdef245 :
  (forall bv:bitvec. forall l:int.
  ((fc245(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - 1) - l)))))

axiom fcqtdef246 :
  (forall bv:bitvec. forall l:int.
  ((fc246(bv)[l]) = ((value(bv)[l]) * power(2, ((length(bv) - l) - 1)))))

axiom kth_decomp_bound_one :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  length(bv))) ->
  (((value(bv)[k]) = 1) -> ((ind_isum(fc245(bv), 0, k) + power(2,
  ((length(bv) - k) - 1))) <= bv_to_int(bv)))))

axiom kth_decomp_bound_one1 :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  length(bv))) ->
  (((value(bv)[k]) = 1) -> (bv_to_int(bv) <  (ind_isum(fc246(bv), 0,
  k) + power(2, (length(bv) - k)))))))

axiom bv_to_int_length_2 :
  (forall x:bitvec. ((length(x) = 2) ->
  ((value(x)[0]) = (bv_to_int(x) / 2))))

axiom bv_to_int_length_21 :
  (forall x:bitvec. ((length(x) = 2) ->
  ((value(x)[1]) = (bv_to_int(x) % 2))))

axiom bv_to_int_length_2_gen :
  (forall x:bitvec. ((length(x) = 2) ->
  ((value(x)[0]) = (bv_to_int(x) / 2))))

axiom bv_to_int_length_2_gen1 :
  (forall x:bitvec. ((length(x) = 2) ->
  ((value(x)[1]) = (bv_to_int(x) % 2))))

logic result23 : bitvec -> (int,int) farray

axiom resultqtdef28 :
  (forall bv:bitvec. forall k:int.
  ((result23(bv)[k]) = (value(bv)[((length(bv) - k) - 1)])))

function bv_inversion(bv: bitvec) : bitvec = make_bv(result23(bv),
  length(bv))

axiom bv_inversionqtspec :
  (forall bv:bitvec. (length(bv_inversion(bv)) = length(bv)))

axiom bv_inversionqtspec1 :
  (forall bv:bitvec.
  (forall k:int. (in_range(bv_inversion(bv), k) ->
  ((value(bv_inversion(bv))[k]) = (value(bv)[((length(bv) - k) - 1)])))))

axiom bv_inversion_value :
  (forall bv:bitvec. forall i:int.
  ((value(bv_inversion(bv))[i]) = (value(bv)[((length(bv) - i) - 1)])))

axiom bv_inversion_invol :
  (forall bv:bitvec. (bv_inversion(bv_inversion(bv)) = bv))

logic int_bit_inversion : int, int -> int

axiom int_bit_inversionqtdef :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_bit_inversion(i, n) = bv_to_int(bv_inversion(int_to_bv(i,
  n)))))))

axiom int_bit_inversionqtspec :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (0 <= int_bit_inversion(i, n)))))

axiom int_bit_inversionqtspec1 :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_bit_inversion(i, n) <  power(2, n)))))

logic int_bit_inversion_ext : int, int -> int

axiom int_bit_inversion_extqtdef :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <= power(2,
  n))) -> ((i = power(2, n)) -> (int_bit_inversion_ext(i, n) = i)))))

axiom int_bit_inversion_extqtdef1 :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <= power(2,
  n))) -> ((not (i = power(2, n))) -> (int_bit_inversion_ext(i,
  n) = bv_to_int(bv_inversion(int_to_bv(i, n))))))))

axiom int_bit_inversion_extqtspec :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <= power(2,
  n))) -> (0 <= int_bit_inversion_ext(i, n)))))

axiom int_bit_inversion_extqtspec1 :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <= power(2,
  n))) -> (int_bit_inversion_ext(i, n) <= power(2, n)))))

axiom int_bit_inversion_extqtspec2 :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <= power(2,
  n))) -> ((i = power(2, n)) -> (int_bit_inversion_ext(i, n) = power(2,
  n))))))

axiom int_bit_inversion_invol :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_bit_inversion(int_bit_inversion(i, n), n) = i))))

axiom int_bit_inversion_inj :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= j) and (j <  power(2, n))) ->
  ((not (i = j)) -> (not (int_bit_inversion(i, n) = int_bit_inversion(j,
  n))))))))

axiom int_bit_inversion_ext_invol :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <= power(2,
  n))) -> (int_bit_inversion_ext(int_bit_inversion_ext(i, n), n) = i))))

axiom int_bit_inversion_onebit :
  (forall i:int. (((0 <= i) and (i <  2)) -> (int_bit_inversion(i, 1) = i)))

axiom int_bit_inversion_zero :
  (forall i:int. forall n:int. ((0 <  n) -> ((0 = i) -> (int_bit_inversion(i,
  n) = 0))))

logic fc247 : bitvec -> (int,int) farray

axiom fcqtdef247 :
  (forall bv:bitvec. forall k:int.
  ((fc247(bv)[k]) = ((value(bv)[((length(bv) - k) - 1)]) * power(2,
  ((length(bv) - 1) - k)))))

axiom bv_to_int_sum_inversion :
  (forall bv:bitvec. ((0 <  length(bv)) -> (int_bit_inversion(bv_to_int(bv),
  length(bv)) = ind_isum(fc247(bv), 0, length(bv)))))

logic fc248 : bitvec -> (int,int) farray

axiom fcqtdef248 :
  (forall bv:bitvec. forall k:int.
  ((fc248(bv)[k]) = ((value(bv)[k]) * power(2, k))))

axiom bv_to_int_sum_inversion_inc :
  (forall bv:bitvec. ((0 <  length(bv)) -> (int_bit_inversion(bv_to_int(bv),
  length(bv)) = ind_isum(fc248(bv), 0, length(bv)))))

axiom inversion_to_int_comm :
  (forall bv:bitvec. ((0 <  length(bv)) ->
  (int_to_bv(int_bit_inversion(bv_to_int(bv), length(bv)),
  length(bv)) = bv_inversion(bv))))

logic fc249 : int, int -> (int,int) farray

axiom fcqtdef249 :
  (forall i:int. forall n:int. forall k:int. ((fc249(i,
  n)[k]) = ((value(int_to_bv(i, n))[((n - k) - 1)]) * power(2,
  ((n - 1) - k)))))

axiom bv_inversion_sum :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_bit_inversion(i, n) = ind_isum(fc249(i, n), 0, n)))))

logic fc250 : bitvec -> (int,int) farray

axiom fcqtdef250 :
  (forall bv:bitvec. forall k:int.
  ((fc250(bv)[k]) = ((value(bv)[((length(bv) - k) - 1)]) * power(2,
  ((length(bv) - 1) - k)))))

axiom bv_to_int_inversion_sum :
  (forall bv:bitvec. (bv_to_int(bv_inversion(bv)) = ind_isum(fc250(bv), 0,
  length(bv))))

axiom bv_to_int_bit_inversion :
  (forall bv:bitvec. ((0 <  length(bv)) ->
  (bv_to_int(bv_inversion(bv)) = int_bit_inversion(bv_to_int(bv),
  length(bv)))))

logic fc251 : bitvec -> (int,int) farray

axiom fcqtdef251 :
  (forall bv:bitvec. forall k:int.
  ((fc251(bv)[k]) = ((value(bv)[k]) * power(2, k))))

axiom bv_to_int_inversion_sum_inc :
  (forall bv:bitvec. ((0 <  length(bv)) ->
  (bv_to_int(bv_inversion(bv)) = ind_isum(fc251(bv), 0, length(bv)))))

axiom bv_m_to_int_bit_inversion :
  (forall f:(int,int) farray. forall n:int. ((0 <  n) ->
  (bv_to_int(bv_inversion(make_bv_m(f,
  n))) = int_bit_inversion(bv_to_int(make_bv_m(f, n)), n))))

logic fc252 : int, int -> (int,int) farray

axiom fcqtdef252 :
  (forall i:int. forall n:int. forall k:int. ((fc252(i,
  n)[k]) = ((value(int_to_bv(i, n))[(n - k)]) * power(2, ((n - k) - 1)))))

axiom int_bit_inversion_tail_bits :
  (forall i:int. forall n:int. ((1 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_bit_inversion(tail_bits(i, n), (n - 1)) = ind_isum(fc252(i,
  n), 1, n)))))

logic fc253 : (int,int) farray, int -> (int,int) farray

axiom fcqtdef253 :
  (forall bv:(int,int) farray. forall n:int. forall k:int. ((fc253(bv,
  n)[k]) = (((bv[((n - 1) - k)]) % 2) * power(2, ((n - k) - 1)))))

axiom tail_bits_int_bit_inversion :
  (forall bv:(int,int) farray. forall n:int. ((1 <  n) ->
  (tail_bits(int_bit_inversion(bv_to_int(make_bv_m(bv, n)), n),
  n) = ind_isum(fc253(bv, n), 1, n))))

axiom int_bit_inversion_ht :
  (forall i:int. forall n:int. ((1 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (int_bit_inversion(i, n) = ((2 * int_bit_inversion(tail_bits(i, n),
  (n - 1))) + head_bit(i, n))))))

axiom bv_inversion_ht :
  (forall f:(int,int) farray. forall n:int. ((1 <  n) ->
  (bv_to_int(bv_inversion(make_bv_m(f, n))) = (head(make_bv_m(f,
  n)) + (2 * bv_to_int(bv_inversion(tail(make_bv_m(f, n)))))))))

axiom bv_inversion_ht_bv :
  (forall bv:bitvec. ((1 <  length(bv)) ->
  (bv_to_int(bv_inversion(bv)) = (head(bv) + (2 * bv_to_int(bv_inversion(tail(bv))))))))

axiom bv_to_int_ht :
  (forall f:(int,int) farray. forall n:int. ((1 <  n) ->
  (bv_to_int(make_bv_m(f, n)) = ((power(2, (n - 1)) * head(make_bv_m(f,
  n))) + bv_to_int(tail(make_bv_m(f, n)))))))

axiom bv_inversion_mult_ht :
  (forall fx:(int,int) farray. forall fy:(int,int) farray. forall n:int.
  ((1 <  n) -> ((bv_to_int(make_bv_m(fx,
  n)) * bv_to_int(bv_inversion(make_bv_m(fy, n)))) = (((head(make_bv_m(fy,
  n)) * bv_to_int(make_bv_m(fx, n))) + (bv_to_int(tail(make_bv_m(fx,
  n))) * (2 * bv_to_int(bv_inversion(tail(make_bv_m(fy, n))))))) + (power(2,
  n) * (head(make_bv_m(fx, n)) * bv_to_int(bv_inversion(tail(make_bv_m(fy,
  n))))))))))

axiom bv_inversion_mult_ht_bv :
  (forall bvx:bitvec. forall bvy:bitvec. ((1 <  length(bvx)) ->
  ((length(bvx) = length(bvy)) ->
  ((bv_to_int(bvx) * bv_to_int(bv_inversion(bvy))) = (((head(bvy) * bv_to_int(bvx)) + (bv_to_int(tail(bvx)) * (2 * bv_to_int(bv_inversion(tail(bvy)))))) + (power(2,
  length(bvx)) * (head(bvx) * bv_to_int(bv_inversion(tail(bvy))))))))))

logic ang_add_closure : (angle,(angle,angle) farray) farray

axiom ang_add_closure_def :
  (forall y:angle. forall y1:angle. (((ang_add_closure[y])[y1]) = ang_add(y,
  y1)))

function ang_sum(f: (int,angle) farray, i: int, j: int) : angle =
  (if (j <= i) then ang_zero else int_iterate(ang_add_closure, f, i, j))

axiom ang_sumto_int_iterate :
  (forall f:(int,angle) farray. forall i:int. forall j:int. ((i <  j) ->
  (ang_sum(f, i, j) = int_iterate(ang_add_closure, f, i, j))))

axiom ang_sum_plus_one :
  (forall f:(int,angle) farray. forall i:int. forall j:int.
  (((i + 1) <  j) -> (ang_sum(f, i, j) = ang_add((f[i]), ang_sum(f, (i + 1),
  j)))))

axiom ang_sum_cardone :
  (forall f:(int,angle) farray. forall i:int. forall j:int. ((j = (i + 1)) ->
  (ang_sum(f, i, j) = (f[i]))))

axiom ang_sum_cardone_p :
  (forall f:(int,angle) farray. forall i:int. forall j:int. forall r:angle.
  ((j = (i + 1)) -> (((f[i]) = r) -> (r = ang_sum(f, i, j)))))

axiom ang_sum_neutral :
  (forall f:(int,angle) farray. forall i:int. forall j:int. ((i <= j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = ang_zero))) ->
  (ang_sum(f, i, j) = ang_zero))))

axiom ang_sum_def_plus_one_com :
  (forall f:(int,angle) farray. forall i:int. forall j:int.
  (((i + 1) <  j) -> (ang_add((f[i]), ang_sum(f, (i + 1), j)) = ang_sum(f, i,
  j))))

axiom ang_sum_right_extension :
  (forall f:(int,angle) farray. forall i:int. forall j:int.
  (((i + 1) <  j) -> (ang_sum(f, i, j) = ang_add(ang_sum(f, i, (j - 1)),
  (f[(j - 1)])))))

axiom ang_sum_re :
  (forall f:(int,angle) farray. forall i:int. forall j:int.
  (((i + 1) <= j) -> (ang_sum(f, i, j) = ang_add(ang_sum(f, i, (j - 1)),
  (f[(j - 1)])))))

axiom ang_sum_transitivity :
  (forall f:(int,angle) farray. forall i:int. forall k:int. forall j:int.
  (((i <  k) and (k <  j)) -> (ang_sum(f, i, j) = ang_add(ang_sum(f, i, k),
  ang_sum(f, k, j)))))

axiom ang_sum_eq :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. ((i <= j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ang_sum(f, i, j) = ang_sum(g, i, j)))))

axiom ang_sum_int_to_ang :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. ((i <  j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  ((exists n:int.
   (forall k:int.
   (exists j1:int. exists jqt:int. (((f[k]) = infix_sldtsl(j1, n)) and
   (((g[k]) = infix_sldtsl(jqt, n)) and (j1 = jqt)))))) ->
  (ang_sum(f, i, j) = ang_sum(g, i, j))))))

axiom vang_sum_eq :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. ((i <  j) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ang_exp(ang_sum(f, i, j)) = ang_exp(ang_sum(g, i, j))))))

axiom vang_sum_scal_eq :
  (forall f:(int,angle) farray. forall g:(int,angle) farray.
  forall m:complex matrix. forall n:complex matrix. forall i:int.
  forall j:int. ((i <  j) -> ((m = n) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (infix_asdtdt(ang_exp(ang_sum(f, i, j)),
  m) = infix_asdtdt(ang_exp(ang_sum(g, i, j)), n))))))

logic fc254 : (int,angle) farray -> (int,angle) farray

axiom fcqtdef254 :
  (forall f:(int,angle) farray. forall k:int.
  ((fc254(f)[k]) = ang_inv((f[k]))))

axiom ang_sum_inv :
  (forall f:(int,angle) farray. forall i:int. forall j:int.
  (ang_inv(ang_sum(f, i, j)) = ang_sum(fc254(f), i, j)))

axiom ang_sum_plus_one_p :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. forall l:int. forall m:int. forall r:angle.
  (((i + 1) <  j) -> ((l = (i + 1)) -> ((m = j) -> (((g[i]) = r) ->
  ((forall k:int. ((((i + 1) <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ang_add(r, ang_sum(f, l, m)) = ang_sum(g, i, j))))))))

axiom vang_sum_plus_one_p :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. forall l:int. forall m:int. forall r:angle.
  (((i + 1) <  j) -> ((l = (i + 1)) -> ((m = j) -> (((g[i]) = r) ->
  ((forall k:int. ((((i + 1) <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (infix_asdt(ang_exp(r), ang_exp(ang_sum(f, l, m))) = ang_exp(ang_sum(g, i,
  j)))))))))

axiom vang_sum_plus_one_rev :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. forall l:int. forall m:int. forall r:angle.
  (((i + 1) <  j) -> ((l = (i + 1)) -> ((m = j) -> (((g[i]) = r) ->
  ((forall k:int. ((((i + 1) <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ang_exp(ang_sum(g, i, j)) = infix_asdt(ang_exp(r), ang_exp(ang_sum(f, l,
  m))))))))))

axiom ang_sum_right_extension_p :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. forall l:int. forall m:int. forall r:angle.
  (((i + 1) <  j) -> ((m = (j - 1)) -> ((l = i) -> (((g[(j - 1)]) = r) ->
  ((forall k:int. (((i <= k) and (k <  (j - 1))) -> ((f[k]) = (g[k])))) ->
  (ang_add(ang_sum(f, l, m), r) = ang_sum(g, i, j))))))))

axiom vang_sum_right_extension_p :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. forall l:int. forall m:int. forall r:angle.
  (((i + 1) <  j) -> ((m = (j - 1)) -> ((l = i) -> (((g[(j - 1)]) = r) ->
  ((forall k:int. (((i <= k) and (k <  (j - 1))) -> ((f[k]) = (g[k])))) ->
  (infix_asdt(ang_exp(ang_sum(f, l, m)), ang_exp(r)) = ang_exp(ang_sum(g, i,
  j)))))))))

axiom vang_sum_right_extension_rev :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. forall l:int. forall m:int. forall r:angle.
  (((i + 1) <  j) -> ((m = (j - 1)) -> ((l = i) -> (((g[(j - 1)]) = r) ->
  ((forall k:int. (((i <= k) and (k <  (j - 1))) -> ((f[k]) = (g[k])))) ->
  (ang_exp(ang_sum(g, i, j)) = infix_asdt(ang_exp(ang_sum(f, l, m)),
  ang_exp(r)))))))))

axiom ang_sum_cardzero :
  (forall f:(int,angle) farray. forall i:int. forall j:int. ((j <= i) ->
  (ang_sum(f, i, j) = ang_zero)))

axiom ang_sum_eq_gen :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. forall iqt:int. forall jqt:int. ((i <  j) -> ((i = iqt) ->
  ((j = jqt) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ang_sum(f, i, j) = ang_sum(g, iqt, jqt)))))))

logic fc255 : (int,(int,angle) farray) farray, int -> (int,angle) farray

logic fc256 : (int,(int,angle) farray) farray, int -> (int,angle) farray

axiom fcqtdef255 :
  (forall f:(int,(int,angle) farray) farray. forall l:int. forall x:int.
  ((fc255(f, l)[x]) = ang_sum((f[x]), x, l)))

axiom fcqtdef256 :
  (forall g:(int,(int,angle) farray) farray. forall lqt:int. forall x:int.
  ((fc256(g, lqt)[x]) = ang_sum((g[x]), x, lqt)))

axiom ang_sum_sum_eq_vl :
  (forall f:(int,(int,angle) farray) farray.
  forall g:(int,(int,angle) farray) farray. forall i:int. forall j:int.
  forall iqt:int. forall jqt:int. forall l:int. forall lqt:int. ((i <  j) ->
  ((j <= l) -> ((i = iqt) -> ((j = jqt) -> ((l = lqt) ->
  ((forall x:int. forall xqt:int. (((i <= x) and (x <  j)) ->
   (((x <= xqt) and (xqt <  l)) -> (((f[x])[xqt]) = ((g[x])[xqt]))))) ->
  (ang_sum(fc255(f, l), i, j) = ang_sum(fc256(g, lqt), iqt, jqt)))))))))

logic fc257 : (int,int) farray, int -> (int,angle) farray

axiom fcqtdef257 :
  (forall f:(int,int) farray. forall n:int. forall k:int. ((fc257(f,
  n)[k]) = infix_sldtsl((-(f[k])), n)))

axiom ang_sum_minus :
  (forall f:(int,int) farray. forall i:int. forall j:int. forall n:int.
  ((0 <= n) -> ((i <  j) -> (ang_sum(fc257(f, n), i,
  j) = infix_sldtsl((-ind_isum(f, i, j)), n)))))

axiom multiple_control_as_ang_sum :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) ->
  ((if (forall j:int. (((0 <= j) and (j <  n)) -> ((value(x)[j]) = 1))) then infix_sldtsl(1,
  1) else ang_zero) = ang_mult_int(infix_sldtsl(1, 1), ind_iproduct(value(x),
  0, n)))))))

axiom multiple_control_as_ang_sum_rev :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) -> (ang_mult_int(infix_sldtsl(1, 1),
  ind_iproduct(value(x), 0,
  n)) = (if (forall j:int. (((0 <= j) and (j <  n)) -> ((value(x)[j]) = 1))) then infix_sldtsl(1,
  1) else ang_zero))))))

logic fc258 : (int,int) farray, (int,angle) farray -> (int,angle) farray

axiom fcqtdef258 :
  (forall f:(int,int) farray. forall t:(int,angle) farray. forall b:int.
  ((fc258(f, t)[b]) = (t[(f[b])])))

axiom ang_sum_map :
  (forall i:int. forall j:int. forall k:int. forall l:int.
  forall f:(int,int) farray. forall t:(int,angle) farray. ((i <  j) ->
  (p_bijective(f, to_fset(i, j), to_fset(k, l)) -> (ang_sum(t, k,
  l) = ang_sum(fc258(f, t), i, j)))))

axiom ang_sum_break :
  (forall f:(int,angle) farray. forall i:int. forall j:int. forall y:int.
  (((i <= y) and (y <= j)) -> (ang_sum(f, i, j) = ang_add(ang_sum(f, i, y),
  ang_sum(f, y, j)))))

axiom ang_sum_break_zero_l :
  (forall f:(int,angle) farray. forall i:int. forall j:int. forall y:int.
  (((i <= y) and (y <= j)) ->
  ((forall k:int. (((i <= k) and (k <  y)) -> ((f[k]) = ang_zero))) ->
  (ang_sum(f, y, j) = ang_sum(f, i, j)))))

axiom ang_sum_break_zero_lg :
  (forall f:(int,angle) farray. forall g:(int,angle) farray. forall i:int.
  forall j:int. forall y:int. (((i <= y) and (y <= j)) ->
  ((forall k:int. (((i <= k) and (k <  y)) -> ((f[k]) = ang_zero))) ->
  ((forall k:int. (((i <= k) and (k <  j)) -> ((f[k]) = (g[k])))) ->
  (ang_sum(f, y, j) = ang_sum(g, i, j))))))

axiom ang_sum_break_zero_lg_params :
  (forall f:(bitvec,(bitvec,(int,(int,angle) farray) farray) farray) farray.
  forall g:(bitvec,(bitvec,(int,(int,angle) farray) farray) farray) farray.
  forall i:int. forall j:int. forall s:int. forall r:int. ((0 <= s) ->
  ((0 <= r) ->
  ((forall x:bitvec. forall z:bitvec.
   (forall a:int. forall k:int. ((length(x) = s) -> ((length(z) = r) ->
   (((i <= a) and (a <  j)) -> (((i <= k) and (k <  a)) ->
   (((((g[x])[z])[a])[k]) = ang_zero))))))) ->
  ((forall x:bitvec. forall z:bitvec.
   (forall a:int. forall k:int. ((length(x) = s) -> ((length(z) = r) ->
   (((i <= a) and (a <  j)) -> (((a <= k) and (k <  j)) ->
   (((((f[x])[z])[a])[k]) = ((((g[x])[z])[a])[k])))))))) ->
  (forall x:bitvec. forall z:bitvec.
  (forall a:int. ((length(x) = s) -> ((length(z) = r) -> (((i <= a) and
  (a <  j)) -> (ang_sum((((f[x])[z])[a]), a, j) = ang_sum((((g[x])[z])[a]),
  i, j))))))))))))

axiom ang_sum_break_zero_l_params :
  (forall f:('a,('a,(int,angle) farray) farray) farray.
  forall g:('a,('a,(int,angle) farray) farray) farray. forall i:int.
  forall j:int. forall l:int. (((i <= l) and (l <= j)) ->
  (forall x:'a. forall y:'a.
  ((forall k:int. (((i <= k) and (k <  l)) -> ((((f[x])[y])[k]) = ang_zero))) ->
  ((forall k:int. (((i <= k) and (k <  j)) ->
   ((((f[x])[y])[k]) = (((g[x])[y])[k])))) ->
  (ang_sum(((g[x])[y]), i, j) = ang_sum(((f[x])[y]), l, j)))))))

axiom ang_sum_break_param :
  (forall f:(int,(int,angle) farray) farray. forall i:int. forall j:int.
  ((i <  j) ->
  (forall y:int. (((i <= y) and (y <  j)) -> (ang_sum((f[y]), i,
  j) = ang_add(ang_sum((f[y]), i, y), ang_sum((f[y]), y, j)))))))

axiom ang_sum_neutral_param_r :
  (forall f:(int,(int,angle) farray) farray. forall i:int. forall j:int.
  ((i <  j) ->
  (forall y:int. (((i <= y) and (y <  j)) ->
  ((forall k:int. (((y <= k) and (k <  j)) -> (((f[y])[k]) = ang_zero))) ->
  (ang_sum((f[y]), y, j) = ang_zero))))))

axiom ang_sum_neutral_param_l :
  (forall f:(int,(int,angle) farray) farray. forall i:int. forall j:int.
  ((i <  j) ->
  (forall y:int. (((i <= y) and (y <  j)) ->
  ((forall k:int. (((i <= k) and (k <  y)) -> (((f[y])[k]) = ang_zero))) ->
  (ang_sum((f[y]), i, y) = ang_zero))))))

logic fc259 : (int,angle) farray, int -> (int,angle) farray

axiom fcqtdef259 :
  (forall f:(int,angle) farray. forall k:int. forall b:int. ((fc259(f,
  k)[b]) = (f[(b + k)])))

axiom ang_sum_transl :
  (forall f:(int,angle) farray. forall i:int. forall j:int. forall k:int.
  ((i <  j) -> (ang_sum(f, i, j) = ang_sum(fc259(f, k), (i - k), (j - k)))))

logic fc260 : (int,angle) farray -> (int,angle) farray

axiom fcqtdef260 :
  (forall f:(int,angle) farray. forall b:int. ((fc260(f)[b]) = (f[(b - 1)])))

axiom ang_sum_transl_one :
  (forall f:(int,angle) farray. forall i:int. forall j:int. ((i <  j) ->
  (ang_sum(f, i, j) = ang_sum(fc260(f), (i + 1), (j + 1)))))

logic fc261 : (int,int) farray, int -> (int,angle) farray

axiom fcqtdef261 :
  (forall f:(int,int) farray. forall n:int. forall k:int. ((fc261(f,
  n)[k]) = infix_sldtsl((f[k]), n)))

axiom ang_sum_to_ind_isum :
  (forall f:(int,int) farray. forall n:int. forall i:int. forall j:int.
  ((0 <= n) -> ((i <  j) -> (ang_sum(fc261(f, n), i,
  j) = infix_sldtsl(ind_isum(f, i, j), n)))))

logic fc262 : (int,int) farray, int -> (int,angle) farray

axiom fcqtdef262 :
  (forall f:(int,int) farray. forall n:int. forall k:int. ((fc262(f,
  n)[k]) = infix_sldtsl((f[k]), n)))

axiom ind_isum_to_d_sum :
  (forall f:(int,int) farray. forall n:int. forall i:int. forall j:int.
  ((0 <= n) -> ((i <  j) -> (infix_sldtsl(ind_isum(f, i, j),
  n) = ang_sum(fc262(f, n), i, j)))))

logic fc263 : (int,int) farray, int, int -> (int,angle) farray

axiom fcqtdef263 :
  (forall bvx:(int,int) farray. forall k:int. forall n:int. forall x:int.
  ((fc263(bvx, k, n)[x]) = infix_sldtsl((((bvx[x]) * power(2,
  ((n - x) - 1))) * k), n)))

axiom ang_sum_int_decomp :
  (forall bvx:(int,int) farray. forall k:int. forall n:int. ((0 <  n) ->
  (binary(bvx) -> (ang_sum(fc263(bvx, k, n), 0,
  n) = infix_sldtsl((bin_to_int(bvx, n) * k), n)))))

logic fc264 : (int,int) farray, int, int -> (int,angle) farray

axiom fcqtdef264 :
  (forall bvx:(int,int) farray. forall n:int. forall k:int. forall x:int.
  ((fc264(bvx, n, k)[x]) = infix_sldtsl((((bvx[x]) * power(2,
  ((n - x) - 1))) * k), n)))

axiom ang_sum_int_decomp_gen :
  (forall bvx:(int,int) farray. forall n:int. ((0 <  n) -> (binary(bvx) ->
  (forall k:int. (ang_sum(fc264(bvx, n, k), 0,
  n) = infix_sldtsl((bin_to_int(bvx, n) * k), n))))))

logic fc265 : int, bitvec, int -> (int,angle) farray

axiom fcqtdef265 :
  (forall n:int. forall x:bitvec. forall k:int. forall i:int. ((fc265(n, x,
  k)[i]) = infix_sldtsl((((value(x)[i]) * power(2, ((n - i) - 1))) * k), n)))

axiom ang_sum_bv_to_int :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec.
  (forall k:int. ((length(x) = n) -> (ang_sum(fc265(n, x, k), 0,
  n) = infix_sldtsl((bv_to_int(x) * k), n)))))))

logic fc266 : int, bitvec, int -> (int,angle) farray

axiom fcqtdef266 :
  (forall n:int. forall x:bitvec. forall k:int. forall i:int. ((fc266(n, x,
  k)[i]) = infix_sldtsl((((value(x)[i]) * power(2, ((n - i) - 1))) * k), n)))

axiom ang_sum_bv_to_int_ :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec.
  (forall k:int. ((length(x) = n) -> (ang_sum(fc266(n, x, k), 0,
  n) = infix_sldtsl((bv_to_int(x) * k), n)))))))

logic fc267 : int, bitvec, bitvec, int -> (int,angle) farray

logic fc268 : int, bitvec, bitvec -> (int,angle) farray

axiom fcqtdef267 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall target:int.
  forall k:int. ((fc267(n, x, y,
  target)[k]) = infix_sldtsl((((value(y)[k]) * (value(x)[target])) * power(2,
  (((n - k) - 1) + ((n - target) - 1)))), n)))

axiom fcqtdef268 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall target:int.
  ((fc268(n, x, y)[target]) = ang_sum(fc267(n, x, y, target),
  ((n - target) - 1), n)))

axiom ang_sum_sum_bv_to_int_mult :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((0 <  n) ->
  ((length(x) = n) -> ((length(y) = n) -> (ang_sum(fc268(n, x, y), 0,
  n) = infix_sldtsl((bv_to_int(x) * bv_to_int(y)), n))))))

logic fc269 : int, bitvec, bitvec, int -> (int,angle) farray

logic fc270 : int, bitvec, bitvec -> (int,angle) farray

axiom fcqtdef269 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall target:int.
  forall k:int. ((fc269(n, x, y,
  target)[k]) = infix_sldtsl((((value(y)[k]) * (value(x)[target])) * power(2,
  (((n - k) - 1) + ((n - target) - 1)))), n)))

axiom fcqtdef270 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall target:int.
  ((fc270(n, x, y)[target]) = ang_sum(fc269(n, x, y, target),
  ((n - target) - 1), n)))

axiom ang_sum_sum_bv_to_int_mult_gen :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. forall y:bitvec. ((length(x) = n) -> ((length(y) = n) ->
  (ang_sum(fc270(n, x, y), 0,
  n) = infix_sldtsl((bv_to_int(x) * bv_to_int(y)), n)))))))

logic fc271 : (int,int) farray, int, int -> (int,angle) farray

axiom fcqtdef271 :
  (forall bvx:(int,int) farray. forall n:int. forall k:int. forall x:int.
  ((fc271(bvx, n, k)[x]) = infix_sldtsl((((bvx[x]) * power(2,
  ((n - x) - 1))) * k), n)))

axiom ang_sum_int_decomp_gen_rev :
  (forall bvx:(int,int) farray. forall n:int. ((0 <  n) -> (binary(bvx) ->
  (forall k:int. (infix_sldtsl((bin_to_int(bvx, n) * k),
  n) = ang_sum(fc271(bvx, n, k), 0, n))))))

logic fc272 : angle, (int,int) farray -> (int,angle) farray

axiom fcqtdef272 :
  (forall o:angle. forall f:(int,int) farray. forall i:int. ((fc272(o,
  f)[i]) = ang_mult_int(o, (f[i]))))

axiom sum_ang_mult_int_e :
  (forall o:angle. forall f:(int,int) farray. forall l:int. forall h:int.
  ((l <  h) -> (ang_sum(fc272(o, f), l, h) = ang_mult_int(o, ind_isum(f, l,
  h)))))

logic fc273 : (int,complex) farray -> (int,angle) farray

axiom fcqtdef273 :
  (forall phi:(int,complex) farray. forall i:int.
  ((fc273(phi)[i]) = real_to_ang((phi[i]))))

axiom real_to_ang_sum :
  (forall phi:(int,complex) farray. forall l:int. forall h:int. ((l <  h) ->
  ((forall i:int. (((l <= i) and (i <  h)) -> real_((phi[i])))) ->
  (ang_sum(fc273(phi), l, h) = real_to_ang(ind_sum(phi, l, h))))))

logic fc274 : (int,int) farray, complex -> (int,angle) farray

axiom fcqtdef274 :
  (forall f:(int,int) farray. forall x:complex. forall i:int. ((fc274(f,
  x)[i]) = real_to_ang(infix_asdt(x, i_to_c((f[i]))))))

axiom real_to_ang_sum_int :
  (forall f:(int,int) farray. forall l:int. forall h:int. forall x:complex.
  ((l <  h) -> (real_(x) -> (ang_sum(fc274(f, x), l,
  h) = real_to_ang(infix_asdt(x, i_to_c(ind_isum(f, l, h))))))))

logic fc275 : (int,int) farray, complex -> (int,angle) farray

axiom fcqtdef275 :
  (forall f:(int,int) farray. forall x:complex. forall i:int. ((fc275(f,
  x)[i]) = real_to_ang(infix_asdt(x, i_to_c((f[i]))))))

axiom real_to_ang_sum_int_gen :
  (forall f:(int,int) farray. forall l:int. forall h:int. ((l <  h) ->
  (forall x:complex. (real_(x) -> (ang_sum(fc275(f, x), l,
  h) = real_to_ang(infix_asdt(x, i_to_c(ind_isum(f, l, h)))))))))

logic fc276 : complex, bitvec -> (int,angle) farray

axiom fcqtdef276 :
  (forall x:complex. forall y:bitvec. forall i:int. ((fc276(x,
  y)[i]) = real_to_ang(infix_asdt(infix_asdt(x, i_to_c(power(2, i))),
  i_to_c((value(y)[i]))))))

axiom real_to_ang_bv_inversion :
  (forall ft:int. forall x:complex. forall y:bitvec. ((0 <  ft) ->
  (real_(x) -> ((length(y) = ft) -> (ang_sum(fc276(x, y), 0,
  ft) = real_to_ang(infix_asdt(x, i_to_c(bv_to_int(bv_inversion(y))))))))))

logic fc277 : (int,angle) farray, int -> (int,angle) farray

axiom fcqtdef277 :
  (forall f:(int,angle) farray. forall i:int. forall x:int. ((fc277(f,
  i)[x]) = ang_mult_int((f[x]), i)))

axiom sum_ang_mult_int :
  (forall f:(int,angle) farray. forall i:int. forall l:int. forall h:int.
  ((l <  h) -> (ang_sum(fc277(f, i), l, h) = ang_mult_int(ang_sum(f, l, h),
  i))))

logic fc278 : bitvec, complex -> (int,angle) farray

axiom fcqtdef278 :
  (forall x:bitvec. forall theta:complex. forall i:int. ((fc278(x,
  theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta, i_to_c(power(2, i))),
  i_to_c((value(x)[i]))))))

axiom ang_sum_bv_to_int_inversion_pre :
  (forall n:int. forall x:bitvec. ((0 <  n) -> ((length(x) = n) ->
  (forall theta:complex. (real_(theta) -> (real_to_ang(infix_asdt(theta,
  i_to_c(bv_to_int(bv_inversion(x))))) = ang_sum(fc278(x, theta), 0, n)))))))

logic fc279 : bitvec, complex -> (int,angle) farray

axiom fcqtdef279 :
  (forall x:bitvec. forall theta:complex. forall i:int. ((fc279(x,
  theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta, i_to_c(power(2, i))),
  i_to_c((value(x)[i]))))))

axiom ang_sum_bv_to_int_inversion :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec.
  (forall theta:complex. ((length(x) = n) -> (real_(theta) ->
  (real_to_ang(infix_asdt(theta,
  i_to_c(bv_to_int(bv_inversion(x))))) = ang_sum(fc279(x, theta), 0, n))))))))

logic fc280 : int, bitvec, complex -> (int,angle) farray

axiom fcqtdef280 :
  (forall n:int. forall x:bitvec. forall theta:complex. forall i:int.
  ((fc280(n, x, theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta,
  i_to_c(power(2, ((n - i) - 1)))), i_to_c((-(value(x)[i])))))))

axiom ang_sum_bv_to_int_opp_pre :
  (forall n:int. forall x:bitvec. ((0 <  n) -> ((length(x) = n) ->
  (forall theta:complex. (real_(theta) -> (real_to_ang(infix_asdt(theta,
  i_to_c((-bv_to_int(x))))) = ang_sum(fc280(n, x, theta), 0, n)))))))

logic fc281 : int, bitvec, complex -> (int,angle) farray

axiom fcqtdef281 :
  (forall n:int. forall x:bitvec. forall theta:complex. forall i:int.
  ((fc281(n, x, theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta,
  i_to_c(power(2, ((n - i) - 1)))), i_to_c((-(value(x)[i])))))))

axiom ang_sum_bv_to_int_opp :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec.
  (forall theta:complex. ((length(x) = n) -> (real_(theta) ->
  (real_to_ang(infix_asdt(theta, i_to_c((-bv_to_int(x))))) = ang_sum(fc281(n,
  x, theta), 0, n))))))))

logic fc282 : int, bitvec, complex -> (int,angle) farray

axiom fcqtdef282 :
  (forall n:int. forall x:bitvec. forall theta:complex. forall i:int.
  ((fc282(n, x, theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta,
  i_to_c(power(2, ((n - i) - 1)))), i_to_c((value(x)[i]))))))

axiom ang_sum_bv_to_int_mult_pre :
  (forall n:int. forall x:bitvec. ((0 <  n) -> ((length(x) = n) ->
  (forall theta:complex. (real_(theta) -> (real_to_ang(infix_asdt(theta,
  i_to_c(bv_to_int(x)))) = ang_sum(fc282(n, x, theta), 0, n)))))))

logic fc283 : int, bitvec, complex -> (int,angle) farray

axiom fcqtdef283 :
  (forall n:int. forall x:bitvec. forall theta:complex. forall i:int.
  ((fc283(n, x, theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta,
  i_to_c(power(2, ((n - i) - 1)))), i_to_c((value(x)[i]))))))

axiom ang_sum_bv_to_int_mult :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec.
  (forall theta:complex. ((length(x) = n) -> (real_(theta) ->
  (real_to_ang(infix_asdt(theta, i_to_c(bv_to_int(x)))) = ang_sum(fc283(n, x,
  theta), 0, n))))))))

logic fc284 : int, bitvec, bitvec, int -> (int,angle) farray

logic fc285 : int, bitvec, bitvec -> (int,angle) farray

axiom fcqtdef284 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int.
  forall i:int. ((fc284(n, x, y,
  j)[i]) = infix_sldtsl((((-(value(x)[i])) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j))), n)))

axiom fcqtdef285 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int. ((fc285(n,
  x, y)[j]) = ang_sum(fc284(n, x, y, j), j, n)))

axiom rewrite_ang_sum_sum_to_bv_and_inversion :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((0 <  n) ->
  ((length(x) = n) -> ((length(y) = n) -> (ang_sum(fc285(n, x, y), 0,
  n) = real_to_ang(infix_sldt(infix_asdt(i_to_c((-bv_to_int(x))),
  i_to_c(bv_to_int(bv_inversion(y)))), i_to_c(power(2, n)))))))))

logic fc286 : int, bitvec, bitvec, int -> (int,angle) farray

logic fc287 : int, bitvec, bitvec -> (int,angle) farray

axiom fcqtdef286 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int.
  forall i:int. ((fc286(n, x, y,
  j)[i]) = infix_sldtsl((((-(value(x)[i])) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j))), n)))

axiom fcqtdef287 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int. ((fc287(n,
  x, y)[j]) = ang_sum(fc286(n, x, y, j), j, n)))

axiom rewrite_ang_sum_sum_to_bv_and_inversion_gen :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. forall y:bitvec. ((length(x) = n) -> ((length(y) = n) ->
  (ang_sum(fc287(n, x, y), 0,
  n) = real_to_ang(infix_asdt(infix_asdt(i_to_c((-bv_to_int(x))),
  i_to_c(bv_to_int(bv_inversion(y)))), pow_inv_2(n)))))))))

logic fc288 : int, bitvec, bitvec, int -> (int,int) farray

logic fc289 : int, bitvec, bitvec -> (int,int) farray

axiom fcqtdef288 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int.
  forall i:int. ((fc288(n, x, y,
  j)[i]) = (((value(x)[i]) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j)))))

axiom fcqtdef289 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int. ((fc289(n,
  x, y)[j]) = ind_isum(fc288(n, x, y, j), j, n)))

axiom int_to_ang_by_sum_mult_break :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((0 <  n) ->
  ((length(x) = n) -> ((length(y) = n) -> (infix_sldtsl(ind_isum(fc289(n, x,
  y), 0, n), n) = infix_sldtsl((bv_to_int(x) * bv_to_int(bv_inversion(y))),
  n))))))

logic fc290 : int, bitvec, bitvec, int -> (int,int) farray

logic fc291 : int, bitvec, bitvec -> (int,int) farray

axiom fcqtdef290 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int.
  forall i:int. ((fc290(n, x, y,
  j)[i]) = (((value(x)[i]) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j)))))

axiom fcqtdef291 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int. ((fc291(n,
  x, y)[j]) = ind_isum(fc290(n, x, y, j), j, n)))

axiom int_to_ang_by_sum_mult_break_gen :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. forall y:bitvec. ((length(x) = n) -> ((length(y) = n) ->
  (infix_sldtsl(ind_isum(fc291(n, x, y), 0, n),
  n) = infix_sldtsl((bv_to_int(x) * bv_to_int(bv_inversion(y))), n)))))))

logic fc292 : int, bitvec, bitvec, int -> (int,int) farray

logic fc293 : int, bitvec, bitvec -> (int,int) farray

axiom fcqtdef292 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int.
  forall i:int. ((fc292(n, x, y,
  j)[i]) = (((value(x)[i]) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j)))))

axiom fcqtdef293 :
  (forall n:int. forall x:bitvec. forall y:bitvec. forall j:int. ((fc293(n,
  x, y)[j]) = (-ind_isum(fc292(n, x, y, j), j, n))))

axiom int_to_ang_by_sum_mult_break_neg :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. forall y:bitvec. ((length(x) = n) -> ((length(y) = n) ->
  (infix_sldtsl(ind_isum(fc293(n, x, y), 0, n),
  n) = infix_sldtsl(((-bv_to_int(x)) * bv_to_int(bv_inversion(y))), n)))))))

logic is_a_ket : complex matrix -> prop

axiom Is_a_ket : (forall m:complex matrix. (is_a_ket(m) -> (columns(m) = 1)))

axiom Is_a_ket1 :
  (forall m:complex matrix. (is_a_ket(m) ->
  (exists s:int. ((0 <= s) and (rows(m) = power(2, s))))))

axiom Is_a_ket2 :
  (forall m:complex matrix. (((columns(m) = 1) and
  (exists s:int. ((0 <= s) and (rows(m) = power(2, s))))) -> is_a_ket(m)))

logic xor_i : int, int -> int

axiom xor_iqtdef :
  (forall i:int. forall iqt:int. (((0 <= i) and (i <  2)) -> (((0 <= iqt) and
  (iqt <  2)) -> ((i = 0) -> (xor_i(i, iqt) = iqt)))))

axiom xor_iqtdef1 :
  (forall i:int. forall iqt:int. (((0 <= i) and (i <  2)) -> (((0 <= iqt) and
  (iqt <  2)) -> ((not (i = 0)) -> (xor_i(i, iqt) = (1 - iqt))))))

axiom xor_iqtspec :
  (forall i:int. forall iqt:int. (((0 <= i) and (i <  2)) -> (((0 <= iqt) and
  (iqt <  2)) -> ((i = 0) -> ((iqt = 0) -> (xor_i(i, iqt) = 0))))))

axiom xor_iqtspec1 :
  (forall i:int. forall iqt:int. (((0 <= i) and (i <  2)) -> (((0 <= iqt) and
  (iqt <  2)) -> ((i = 0) -> ((iqt = 1) -> (xor_i(i, iqt) = 1))))))

axiom xor_iqtspec2 :
  (forall i:int. forall iqt:int. (((0 <= i) and (i <  2)) -> (((0 <= iqt) and
  (iqt <  2)) -> ((i = 1) -> ((iqt = 0) -> (xor_i(i, iqt) = 1))))))

axiom xor_iqtspec3 :
  (forall i:int. forall iqt:int. (((0 <= i) and (i <  2)) -> (((0 <= iqt) and
  (iqt <  2)) -> ((i = 1) -> ((iqt = 1) -> (xor_i(i, iqt) = 0))))))

predicate is_a_ket_l(m: complex matrix, l: int) = ((0 <= l) and
  ((columns(m) = 1) and (rows(m) = power(2, l))))

axiom ket_l_rows :
  (forall m:complex matrix. forall l:int. (is_a_ket_l(m, l) ->
  (rows(m) = power(2, l))))

axiom ket_l_columns :
  (forall m:complex matrix. ((exists l:int. is_a_ket_l(m, l)) ->
  (columns(m) = 1)))

logic ket_length : complex matrix -> int

axiom ket_lengthqtdef :
  (forall m:complex matrix. (is_a_ket(m) ->
  (ket_length(m) = (binary_length(rows(m)) - 1))))

axiom ket_lengthqtspec :
  (forall m:complex matrix. (is_a_ket(m) -> (0 <= ket_length(m))))

axiom ket_lengthqtspec1 :
  (forall m:complex matrix. (is_a_ket(m) -> (rows(m) = power(2,
  ket_length(m)))))

axiom get_ket_rev : true

logic get_ket_bv : complex matrix, bitvec -> complex

axiom get_ket_bvqtdef :
  (forall x:complex matrix. forall bv:bitvec. (is_a_ket_l(x, length(bv)) ->
  (get_ket_bv(x, bv) = get(x, bv_to_int(bv), 0))))

axiom get_ket_add :
  (forall x:complex matrix. forall y:complex matrix. forall i:int.
  (is_a_ket(x) -> (is_a_ket(y) -> ((ket_length(x) = ket_length(y)) ->
  (((0 <= i) and (i <  power(2, ket_length(y)))) -> (get(add_mat(x, y), i,
  0) = infix_pldt(get(x, i, 0), get(y, i, 0))))))))

axiom get_ket_substr :
  (forall x:complex matrix. forall y:complex matrix. forall i:int.
  (is_a_ket(x) -> (is_a_ket(y) -> ((ket_length(x) = ket_length(y)) ->
  (((0 <= i) and (i <  power(2, ket_length(y)))) -> (get(mat_substr(x, y), i,
  0) = infix_mndt(get(x, i, 0), get(y, i, 0))))))))

axiom mat_mult_ket_l :
  (forall m:complex matrix. forall k:complex matrix. forall n:int.
  (is_a_ket_l(k, n) -> ((rows(m) = power(2, n)) -> ((columns(m) = power(2,
  n)) -> is_a_ket_l(mat_mult(m, k), n)))))

axiom ket_kronecker_values :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  (is_a_ket(m) -> (is_a_ket(n) -> (((0 <= i) and
  (i <  (rows(m) * rows(n)))) -> (get(kronecker(m, n), i,
  0) = infix_asdt(get(m, (i / rows(n)), 0), get(n, (i % rows(n)), 0)))))))

axiom ket_l_to_ket :
  (forall m:complex matrix. forall l:int. (is_a_ket_l(m, l) -> is_a_ket(m)))

axiom ket_l_to_ket1 :
  (forall m:complex matrix. forall l:int. (is_a_ket_l(m, l) ->
  (ket_length(m) = l)))

axiom ket_l_to_ket_gen :
  (forall m:complex matrix. ((exists l:int. is_a_ket_l(m, l)) ->
  is_a_ket(m)))

axiom ket_to_ket_l :
  (forall m:complex matrix. (is_a_ket(m) -> is_a_ket_l(m, ket_length(m))))

axiom set_ket_valid_index :
  (forall m:complex matrix. forall i:int. (is_a_ket(m) -> (((0 <= i) and
  (i <  power(2, ket_length(m)))) -> valid_index(m, i, 0))))

axiom ket_to_ket_l_l :
  (forall m:complex matrix. forall i:int. (is_a_ket(m) ->
  ((ket_length(m) = i) -> is_a_ket_l(m, i))))

axiom set_constant_size_ket :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((forall e:'a. (mem(e, s) -> is_a_ket((f[e])))) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   (ket_length((f[e])) = ket_length((f[eqt])))))) ->
  constant_size(s, f))))

logic ket_norm_l : complex matrix, int -> complex

logic result24 : complex matrix -> (int,complex) farray

axiom resultqtdef29 :
  (forall x:complex matrix. forall k:int.
  ((result24(x)[k]) = infix_asdt(modulus(get(x, k, 0)), modulus(get(x, k,
  0)))))

axiom ket_norm_lqtdef :
  (forall x:complex matrix. forall n:int. (is_a_ket_l(x, n) -> (ket_norm_l(x,
  n) = square_rt(sum(to_fset(0, power(2, n)), result24(x))))))

logic fc294 : complex matrix -> (int,complex) farray

axiom fcqtdef294 :
  (forall x:complex matrix. forall k:int.
  ((fc294(x)[k]) = infix_asdt(modulus(get(x, k, 0)), modulus(get(x, k, 0)))))

axiom ind_sum_ket_norm_l :
  (forall x:complex matrix. forall n:int. (is_a_ket_l(x, n) -> (ket_norm_l(x,
  n) = square_rt(ind_sum(fc294(x), 0, power(2, n))))))

axiom ket_norm_one :
  (forall x:complex matrix. forall n:int. ((n = 1) -> (is_a_ket_l(x, n) ->
  (ket_norm_l(x, n) = square_rt(infix_pldt(infix_asdt(modulus(get(x, 0, 0)),
  modulus(get(x, 0, 0))), infix_asdt(modulus(get(x, 1, 0)), modulus(get(x, 1,
  0)))))))))

axiom ket_norm_one_c_one :
  (forall x:complex matrix. forall n:int. ((n = 1) -> (is_a_ket_l(x, n) ->
  ((infix_pldt(infix_asdt(modulus(get(x, 0, 0)), modulus(get(x, 0, 0))),
  infix_asdt(modulus(get(x, 1, 0)), modulus(get(x, 1, 0)))) = c_one) ->
  (ket_norm_l(x, n) = c_one)))))

axiom scalar_ket_norm_l :
  (forall x:complex matrix. forall a:complex. forall n:int.
  (infix_lseqdt(c_zero, a) -> (is_a_ket_l(x, n) ->
  (ket_norm_l(infix_asdtdt(a, x), n) = infix_asdt(a, ket_norm_l(x, n))))))

axiom zero_ket_norm_l :
  (forall x:complex matrix. forall n:int. (is_a_ket_l(x, n) ->
  ((ket_norm_l(x, n) = c_zero) ->
  (forall i:int. forall j:int. (((0 <= i) and (i <  power(2, n))) ->
  ((j = 0) -> (get(x, i, j) = c_zero)))))))

logic normalized_l : complex matrix, int -> complex matrix

axiom normalized_lqtdef :
  (forall x:complex matrix. forall n:int. (is_a_ket_l(x, n) ->
  ((exists i:int. (((0 <= i) and (i <  power(2, n))) and (not (get(x, i,
   0) = c_zero)))) ->
  (normalized_l(x, n) = infix_asdtdt(infix_sldt(c_one, ket_norm_l(x, n)),
  x)))))

axiom normalized_lqtspec :
  (forall x:complex matrix. forall n:int. (is_a_ket_l(x, n) ->
  ((exists i:int. (((0 <= i) and (i <  power(2, n))) and (not (get(x, i,
   0) = c_zero)))) ->
  is_a_ket_l(normalized_l(x, n), n))))

logic make_ket : int, (int,complex) farray -> complex matrix

logic result25 : (int,complex) farray -> (int,(int,complex) farray) farray

axiom resultqtdef30 :
  (forall f:(int,complex) farray. forall x:int. forall us:int.
  (((result25(f)[x])[us]) = (f[x])))

axiom make_ketqtdef :
  (forall n:int. forall f:(int,complex) farray. ((0 <= n) -> (make_ket(n,
  f) = make_f(power(2, n), 1, result25(f)))))

axiom make_ketqtspec :
  (forall n:int. forall f:(int,complex) farray. ((0 <= n) ->
  is_a_ket_l(make_ket(n, f), n)))

axiom make_ketqtspec1 :
  (forall n:int. forall f:(int,complex) farray. ((0 <= n) ->
  (forall i:int. (((0 <= i) and (i <  power(2, n))) -> (get(make_ket(n, f),
  i, 0) = (f[i]))))))

axiom make_ketqtspec2 :
  (forall n:int. forall f:(int,complex) farray. ((0 <= n) ->
  (forall i:int. forall j:int. (valid_index(make_ket(n, f), i, j) ->
  (get(make_ket(n, f), i, j) = (f[i]))))))

axiom assert_make_ket :
  (forall r:int. forall c:int. forall f:(int,complex) farray. forall i:int.
  ((c = 1) -> (((0 <= i) and (i <  power(2, r))) -> (get(make_ket(r, f), i,
  0) = (f[i])))))

axiom assert_make_ket_l :
  (forall l:int. forall f:(int,complex) farray. forall i:int. ((0 <= l) ->
  (get(make_ket(l, f), i, 0) = (f[i]))))

axiom make_ket_length :
  (forall l:int. forall f:(int,complex) farray. ((0 <= l) ->
  (ket_length(make_ket(l, f)) = l)))

axiom make_ket_rows :
  (forall l:int. forall f:(int,complex) farray. ((0 <= l) ->
  (rows(make_ket(l, f)) = power(2, l))))

axiom make_ket_columns :
  (forall l:int. forall f:(int,complex) farray. ((0 <= l) ->
  (columns(make_ket(l, f)) = 1)))

logic make_ket_constant : int, complex -> complex matrix

logic result26 : complex -> (int,complex) farray

axiom resultqtdef31 :
  (forall c:complex. forall us:int. ((result26(c)[us]) = c))

axiom make_ket_constantqtdef :
  (forall n:int. forall c:complex. ((0 <= n) -> (make_ket_constant(n,
  c) = make_ket(n, result26(c)))))

axiom make_ket_constantqtspec :
  (forall n:int. forall c:complex. ((0 <= n) ->
  is_a_ket_l(make_ket_constant(n, c), n)))

axiom make_ket_constantqtspec1 :
  (forall n:int. forall c:complex. ((0 <= n) ->
  (forall i:int. (((0 <= i) and (i <  power(2, n))) ->
  (get(make_ket_constant(n, c), i, 0) = c)))))

axiom make_ket_constantqtspec2 :
  (forall n:int. forall c:complex. ((0 <= n) ->
  (forall i:int. forall j:int. (valid_index(make_ket_constant(n, c), i, j) ->
  (get(make_ket_constant(n, c), i, j) = c)))))

axiom set_equal_ket :
  (forall m:complex matrix. forall n:complex matrix. (is_a_ket(m) ->
  (is_a_ket(n) -> ((ket_length(m) = ket_length(n)) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, ket_length(m)))) -> (get(m,
   i, 0) = get(n, i, 0)))) ->
  (m = n))))))

axiom set_equal_ket_ :
  (forall m:complex matrix. forall n:complex matrix.
  ((exists l:int. (is_a_ket_l(m, l) and (is_a_ket_l(n, l) and
   (forall i:int. (((0 <= i) and (i <  power(2, l))) -> (get(m, i,
   0) = get(n, i, 0))))))) ->
  (m = n)))

logic add_ket : complex matrix, complex matrix -> complex matrix

axiom add_ketqtdef :
  (forall m:complex matrix. forall n:complex matrix. (is_a_ket(m) ->
  (is_a_ket(n) -> ((ket_length(m) = ket_length(n)) -> (add_ket(m,
  n) = add_mat(m, n))))))

axiom add_ketqtspec :
  (forall m:complex matrix. forall n:complex matrix. (is_a_ket(m) ->
  (is_a_ket(n) -> ((ket_length(m) = ket_length(n)) -> is_a_ket(add_ket(m,
  n))))))

axiom add_ketqtspec1 :
  (forall m:complex matrix. forall n:complex matrix. (is_a_ket(m) ->
  (is_a_ket(n) -> ((ket_length(m) = ket_length(n)) -> (ket_length(add_ket(m,
  n)) = ket_length(m))))))

axiom add_ketqtspec2 :
  (forall m:complex matrix. forall n:complex matrix. (is_a_ket(m) ->
  (is_a_ket(n) -> ((ket_length(m) = ket_length(n)) ->
  (forall i:int. (valid_index(add_ket(m, n), i, 0) -> (get(add_ket(m, n), i,
  0) = infix_pldt(get(m, i, 0), get(n, i, 0)))))))))

logic add_ket_l : complex matrix, complex matrix, int -> complex matrix

logic result27 : complex matrix, complex matrix -> (int,complex) farray

axiom resultqtdef32 :
  (forall m:complex matrix. forall n:complex matrix. forall i:int.
  ((result27(m, n)[i]) = infix_pldt(get(m, i, 0), get(n, i, 0))))

axiom add_ket_lqtdef :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) -> (add_ket_l(m, n, l) = make_ket(l, result27(m, n)))))

axiom add_ket_lqtspec :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) -> is_a_ket_l(add_ket_l(m, n, l), l)))

axiom add_ket_lqtspec1 :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) -> (ket_length(add_ket_l(m, n, l)) = l)))

axiom add_ket_lqtspec2 :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) ->
  (forall i:int. (get(add_ket_l(m, n, l), i, 0) = infix_pldt(get(m, i, 0),
  get(n, i, 0))))))

axiom add_ket_lqtspec3 :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) -> (is_a_ket_l(m, l) -> (is_a_ket_l(n, l) -> (add_ket_l(m, n,
  l) = add_mat(m, n))))))

axiom add_ket_l_to_add_mat :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) -> (is_a_ket_l(m, l) -> (is_a_ket_l(n, l) -> (add_ket_l(m, n,
  l) = add_mat(m, n))))))

axiom null_add_ket_l :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  (is_a_ket_l(m, l) -> (is_a_ket_l(n, l) -> (null_mat(m) -> (add_ket_l(m, n,
  l) = n)))))

axiom add_ket_l_null :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  (is_a_ket_l(m, l) -> (is_a_ket_l(n, l) -> (null_mat(n) -> (add_ket_l(m, n,
  l) = m)))))

logic add_ket_l_eq : complex matrix, complex matrix, complex matrix,
  complex matrix, int -> unit

axiom add_ket_l_eqqtdef :
  (forall m:complex matrix. forall mqt:complex matrix.
  forall n:complex matrix. forall nqt:complex matrix. forall l:int.
  (is_a_ket_l(m, l) -> (is_a_ket_l(n, l) -> ((m = mqt) -> ((n = nqt) ->
  (add_ket_l_eq(m, mqt, n, nqt, l) = void))))))

logic add_ket_l_closure : (complex matrix,(complex matrix,(int,complex matrix) farray) farray) farray

axiom add_ket_l_closure_def :
  (forall y:complex matrix. forall y1:complex matrix. forall y2:int.
  ((((add_ket_l_closure[y])[y1])[y2]) = add_ket_l(y, y1, y2)))

axiom add_ket_l_eqqtspec :
  (forall m:complex matrix. forall mqt:complex matrix.
  forall n:complex matrix. forall nqt:complex matrix. forall l:int.
  (is_a_ket_l(m, l) -> (is_a_ket_l(n, l) -> ((m = mqt) -> ((n = nqt) ->
  (((add_ket_l_closure[m])[n]) = ((add_ket_l_closure[mqt])[nqt])))))))

axiom add_ket_l_value :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  forall i:int. (((0 <= i) and (i <  power(2, l))) -> ((0 <= l) ->
  (get(add_ket_l(m, n, l), i, 0) = infix_pldt(get(m, i, 0), get(n, i, 0))))))

axiom add_ket_l_length :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) -> (ket_length(add_ket_l(m, n, l)) = l)))

axiom add_ket_l_rows :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) -> (rows(add_ket_l(m, n, l)) = power(2, l))))

axiom add_ket_l_columns :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) -> (columns(add_ket_l(m, n, l)) = 1)))

axiom add_ket_l_values :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) ->
  (forall i:int. (((0 <= i) and (i <  power(2, l))) -> (get(add_ket_l(m, n,
  l), i, 0) = infix_pldt(get(m, i, 0), get(n, i, 0)))))))

axiom add_ket_l_comm :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((0 <= l) -> (add_ket_l(m, n, l) = add_ket_l(n, m, l))))

axiom set_equal_ket_l :
  (forall m:complex matrix. forall n:complex matrix.
  ((exists l:int. (is_a_ket_l(m, l) and is_a_ket_l(n, l))) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, ket_length(m)))) -> (get(m,
   i, 0) = get(n, i, 0)))) ->
  (m = n))))

axiom set_equal_ket_l_ :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  (is_a_ket_l(m, l) -> (is_a_ket_l(n, l) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, l))) -> (get(m, i,
   0) = get(n, i, 0)))) ->
  (m = n)))))

axiom get_ket_length :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> ((columns(m) = 1) ->
  ((rows(m) = power(2, n)) -> (ket_length(m) = n)))))

axiom set_ket_length :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (is_a_ket(m) ->
  ((ket_length(m) = n) -> (rows(m) = power(2, n))))))

axiom scalar_ket :
  (forall x:complex matrix. forall a:complex. (is_a_ket(x) ->
  is_a_ket(infix_asdtdt(a, x))))

axiom scalar_ket_length :
  (forall m:complex matrix. forall a:complex. (is_a_ket(m) ->
  (ket_length(infix_asdtdt(a, m)) = ket_length(m))))

axiom scalar_ket_valid_index :
  (forall m:complex matrix. forall a:complex. forall i:int. (valid_index(m,
  i, 0) -> (is_a_ket(m) -> valid_index(infix_asdtdt(a, m), i, 0))))

axiom scalar_ket_l :
  (forall x:complex matrix. forall l:int. forall a:complex. (is_a_ket_l(x,
  l) -> is_a_ket_l(infix_asdtdt(a, x), l)))

axiom scalar_ket_l_values :
  (forall a:complex. forall x:complex matrix. forall l:int. (is_a_ket_l(x,
  l) ->
  (forall i:int. (((0 <= i) and (i <  power(2, l))) -> (get(infix_asdtdt(a,
  x), i, 0) = infix_asdt(a, get(x, i, 0)))))))

axiom scalar_ket_l_value :
  (forall a:complex. forall x:complex matrix. forall i:int. forall l:int.
  (((0 <= i) and (i <  power(2, l))) -> (is_a_ket_l(x, l) ->
  (get(infix_asdtdt(a, x), i, 0) = infix_asdt(a, get(x, i, 0))))))

axiom scalar_ket_value :
  (forall x:complex matrix. forall i:int. forall a:complex.
  (get(infix_asdtdt(a, x), i, 0) = infix_asdt(a, get(x, i, 0))))

axiom scalar_ket_value_rev :
  (forall x:complex matrix. forall i:int. forall a:complex. (infix_asdt(a,
  get(x, i, 0)) = get(infix_asdtdt(a, x), i, 0)))

axiom add_ket_is_a_ket :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket(x) ->
  (is_a_ket(y) -> ((ket_length(x) = ket_length(y)) -> is_a_ket(add_mat(x,
  y))))))

axiom set_ket_length_gen :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (is_a_ket(m) ->
  ((power(2, ket_length(m)) = n) -> (rows(m) = n)))))

axiom set_is_a_ket :
  (forall m:complex matrix. ((columns(m) = 1) ->
  ((exists s:int. ((0 <= s) and (rows(m) = power(2, s)))) -> is_a_ket(m))))

axiom set_is_a_ket_l :
  (forall m:complex matrix. forall l:int. ((0 <= l) -> ((columns(m) = 1) ->
  ((rows(m) = power(2, l)) -> is_a_ket_l(m, l)))))

axiom set_is_a_ket_p :
  (forall m:complex matrix. forall l:int. ((0 <= l) -> ((columns(m) = 1) ->
  ((rows(m) = power(2, l)) -> is_a_ket(m)))))

axiom get_is_a_ket :
  (forall m:complex matrix. (is_a_ket(m) -> (columns(m) = 1)))

axiom get_is_a_ket1 :
  (forall m:complex matrix. (is_a_ket(m) -> (rows(m) = power(2,
  ket_length(m)))))

axiom get_ket_columns :
  (forall m:complex matrix. (is_a_ket(m) -> (columns(m) = 1)))

axiom get_ket_rows :
  (forall m:complex matrix. (is_a_ket(m) -> (rows(m) = power(2,
  ket_length(m)))))

axiom get_ket_rows_gen :
  (forall m:complex matrix. forall i:int. (is_a_ket(m) -> ((i = power(2,
  ket_length(m))) -> (rows(m) = i))))

axiom get_ket_rows_length :
  (forall m:complex matrix. forall l:int. (is_a_ket(m) ->
  ((ket_length(m) = l) -> (rows(m) = power(2, l)))))

axiom ket_kronecker :
  (forall m:complex matrix. forall n:complex matrix. (is_a_ket(m) ->
  (is_a_ket(n) -> is_a_ket(kronecker(m, n)))))

axiom ket_kronecker1 :
  (forall m:complex matrix. forall n:complex matrix. (is_a_ket(m) ->
  (is_a_ket(n) -> (ket_length(kronecker(m,
  n)) = (ket_length(m) + ket_length(n))))))

axiom ket_kronecker_l :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  forall lqt:int. (is_a_ket_l(m, l) -> (is_a_ket_l(n, lqt) ->
  is_a_ket_l(kronecker(m, n), (l + lqt)))))

axiom set_ket_kron_l :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  forall lqt:int. forall lqtqt:int. (is_a_ket_l(m, l) -> (is_a_ket_l(n,
  lqt) -> ((lqtqt = (l + lqt)) -> is_a_ket_l(kronecker(m, n), lqtqt)))))

logic ket : int, int -> complex matrix

axiom ketqtdef :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (ket(n, i) = set1(make(power(2, n), 1, c_zero), i, 0, c_one)))))

axiom ketqtdef1 :
  (forall n:int. forall i:int. ((0 <= n) -> ((not ((0 <= i) and
  (i <  power(2, n)))) -> (ket(n, i) = make(power(2, n), 1, c_zero)))))

axiom ketqtspec :
  (forall n:int. forall i:int. ((0 <= n) -> is_a_ket(ket(n, i))))

axiom ketqtspec1 :
  (forall n:int. forall i:int. ((0 <= n) -> (ket_length(ket(n, i)) = n)))

axiom ketqtspec2 :
  (forall n:int. forall i:int. ((0 <= n) -> (columns(ket(n, i)) = 1)))

axiom ketqtspec3 :
  (forall n:int. forall i:int. ((0 <= n) -> (rows(ket(n, i)) = power(2, n))))

axiom ketqtspec4 :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) ->
  (forall j:int. (valid_index(ket(n, i), j, 0) -> (get(ket(n, i), j,
  0) = indic(j, i)))))))

axiom ketqtspec5 :
  (forall n:int. forall i:int. ((0 <= n) ->
  (forall j:int. (valid_index(ket(n, i), j, 0) -> ((not (i = j)) ->
  (get(ket(n, i), j, 0) = c_zero))))))

axiom ketqtspec6 :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (get(ket(n, i), i, 0) = c_one))))

axiom ket_l :
  (forall n:int. forall m:int. forall i:int. ((0 <= n) -> ((n = m) ->
  is_a_ket_l(ket(n, i), m))))

axiom ket_ket_length :
  (forall n:int. forall m:int. forall i:int. ((0 <= n) -> ((n = m) ->
  (ket_length(ket(n, i)) = m))))

axiom ket_length_explicit :
  (forall n:int. forall i:int. ((0 <= n) -> (ket_length(ket(n, i)) = n)))

axiom ket_eq :
  (forall n1:int. forall n2:int. forall i1:int. forall i2:int. ((0 <= n1) ->
  ((n1 = n2) -> ((i1 = i2) -> (ket(n1, i1) = ket(n2, i2))))))

axiom ket_rows :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (rows(ket(n, i)) = power(2, n)))))

axiom ket_columns :
  (forall n:int. forall i:int. ((0 <= n) -> (columns(ket(n, i)) = 1)))

axiom ket_value :
  (forall n:int. forall i:int. forall j:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= j) and (j <  power(2, n))) -> (get(ket(n,
  i), j, 0) = (if (i = j) then c_one else c_zero))))))

axiom g_ket_value :
  (forall n:int. forall i:int. forall j:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= j) and (j <  power(2, n))) -> (get(ket(n,
  i), j, 0) = (if (i = j) then c_one else c_zero))))))

axiom norm_ket_basis :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (ket_norm_l(ket(n, i), n) = c_one))))

axiom get_ket_ :
  (forall m:complex matrix. forall i:int. forall n:int. ((m = ket(n, i)) ->
  ((0 <= n) -> (((0 <= i) and (i <  power(2, n))) -> is_a_ket(m)))))

axiom get_ket_1 :
  (forall m:complex matrix. forall i:int. forall n:int. ((m = ket(n, i)) ->
  ((0 <= n) -> (((0 <= i) and (i <  power(2, n))) -> (ket_length(m) = n)))))

axiom get_ket_2 :
  (forall m:complex matrix. forall i:int. forall n:int. ((m = ket(n, i)) ->
  ((0 <= n) -> (((0 <= i) and (i <  power(2, n))) -> (columns(m) = 1)))))

axiom get_ket_3 :
  (forall m:complex matrix. forall i:int. forall n:int. ((m = ket(n, i)) ->
  ((0 <= n) -> (((0 <= i) and (i <  power(2, n))) -> (rows(m) = power(2,
  n))))))

axiom get_ket_4 :
  (forall m:complex matrix. forall i:int. forall n:int. ((m = ket(n, i)) ->
  ((0 <= n) -> (((0 <= i) and (i <  power(2, n))) ->
  (forall j:int. (valid_index(m, j, 0) -> (get(m, j, 0) = indic(j, i))))))))

axiom get_ket_5 :
  (forall m:complex matrix. forall i:int. forall n:int. ((m = ket(n, i)) ->
  ((0 <= n) -> (((0 <= i) and (i <  power(2, n))) ->
  (forall j:int. (valid_index(m, j, 0) -> ((not (i = j)) -> (get(m, j,
  0) = c_zero))))))))

axiom get_ket_6 :
  (forall m:complex matrix. forall i:int. forall n:int. ((m = ket(n, i)) ->
  ((0 <= n) -> (((0 <= i) and (i <  power(2, n))) -> (get(m, i,
  0) = c_one)))))

axiom get_ket_value :
  (forall i:int. forall n:int. forall j:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= j) and (j <  power(2, n))) -> (get(ket(n,
  i), j, 0) = indic(j, i))))))

axiom get_ket_values :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) ->
  (forall j:int. (((0 <= j) and (j <  power(2, n))) -> (get(ket(n, i), j,
  0) = indic(j, i)))))))

axiom get_ket_value_z :
  (forall i:int. forall n:int. forall j:int. forall z:int. ((z = 0) ->
  ((0 <= n) -> (((0 <= i) and (i <  power(2, n))) -> (((0 <= j) and
  (j <  power(2, n))) -> (get(ket(n, i), j, z) = indic(j, i)))))))

axiom get__ket_value :
  (forall i:int. forall j:int. forall n:int. ((0 <= n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= j) and (j <  power(2, n))) -> (get(ket(n,
  i), j, 0) = indic(j, i))))))

axiom set_ket :
  (forall m:complex matrix. forall i:int. forall n:int. ((0 <= n) ->
  (((0 <= i) and (i <  power(2, n))) -> ((columns(m) = 1) ->
  ((rows(m) = power(2, n)) ->
  ((forall j:int. (valid_index(m, j, 0) -> (get(m, j, 0) = indic(j, i)))) ->
  (m = ket(n, i))))))))

axiom kronecker_kets :
  (forall i1:int. forall i2:int. forall n1:int. forall n2:int. ((0 <= n1) ->
  ((0 <= n2) -> (((0 <= i1) and (i1 <  power(2, n1))) -> (((0 <= i2) and
  (i2 <  power(2, n2))) -> (kronecker(ket(n1, i1), ket(n2,
  i2)) = ket((n1 + n2), ((i1 * power(2, n2)) + i2))))))))

axiom kronecker_kets_ :
  (forall i1:int. forall i2:int. forall n1:int. forall n2:int. ((0 <= n1) ->
  ((0 <= n2) -> (((0 <= i1) and (i1 <  power(2, n1))) -> (((0 <= i2) and
  (i2 <  power(2, n2))) -> (kronecker(ket(n1, i1), ket(n2,
  i2)) = ket((n1 + n2), ((i1 * power(2, n2)) + i2))))))))

axiom kronecker_ket_l :
  (forall x:complex matrix. forall y:complex matrix. forall n1:int.
  forall n2:int. ((0 <= n1) -> ((0 <= n2) -> (is_a_ket_l(x, n1) ->
  (is_a_ket_l(y, n2) -> is_a_ket_l(kronecker(x, y), (n1 + n2)))))))

axiom kronecker_ket_l_sum :
  (forall x:complex matrix. forall y:complex matrix. forall n1:int.
  forall n2:int. forall n3:int. ((0 <= n1) -> ((0 <= n2) -> (is_a_ket_l(x,
  n1) -> (is_a_ket_l(y, n2) -> ((n3 = (n1 + n2)) -> is_a_ket_l(kronecker(x,
  y), n3)))))))

axiom kronecker_kets_bin_to_int :
  (forall f1:(int,int) farray. forall f2:(int,int) farray. forall n1:int.
  forall n2:int. (binary(f1) -> (binary(f2) -> ((0 <= n1) -> ((0 <= n2) ->
  (kronecker(ket(n1, bin_to_int(f1, n1)), ket(n2, bin_to_int(f2,
  n2))) = ket((n1 + n2), ((bin_to_int(f1, n1) * power(2,
  n2)) + bin_to_int(f2, n2)))))))))

logic result28 : bitvec, bitvec -> (int,int) farray

axiom resultqtdef33 :
  (forall bv1:bitvec. forall bv2:bitvec. forall i:int. ((result28(bv1,
  bv2)[i]) = (if ((length(bv1) <= i) and
  (i <  (length(bv1) + length(bv2)))) then (value(bv2)[(i - length(bv1))]) else (value(bv1)[i]))))

function concat(bv1: bitvec, bv2: bitvec) : bitvec = make_bv(result28(bv1,
  bv2), (length(bv1) + length(bv2)))

axiom concatqtspec :
  (forall bv1:bitvec. forall bv2:bitvec. (length(concat(bv1,
  bv2)) = (length(bv1) + length(bv2))))

axiom concatqtspec1 :
  (forall bv1:bitvec. forall bv2:bitvec.
  (forall i:int. (((0 <= i) and (i <  length(bv1))) -> ((value(concat(bv1,
  bv2))[i]) = (value(bv1)[i])))))

axiom concatqtspec2 :
  (forall bv1:bitvec. forall bv2:bitvec.
  (forall i:int. ((length(concat(bv1, bv2)) <= i) -> ((value(concat(bv1,
  bv2))[i]) = (value(bv1)[i])))))

axiom concatqtspec3 :
  (forall bv1:bitvec. forall bv2:bitvec.
  (forall i:int. (((length(bv1) <= i) and (i <  length(concat(bv1, bv2)))) ->
  ((value(concat(bv1, bv2))[i]) = (value(bv2)[(i - length(bv1))])))))

axiom concat_length :
  (forall bv1:bitvec. forall bv2:bitvec. (length(concat(bv1,
  bv2)) = (length(bv1) + length(bv2))))

logic hpart : bitvec, int -> bitvec

axiom hpartqtdef :
  (forall bv:bitvec. forall m:int. ((0 <= m) -> (hpart(bv,
  m) = make_bv(value(bv), m))))

axiom hpartqtspec :
  (forall bv:bitvec. forall m:int. ((0 <= m) -> (length(hpart(bv, m)) = m)))

axiom hpartqtspec1 :
  (forall bv:bitvec. forall m:int. ((0 <= m) -> ((length(bv) = m) ->
  (hpart(bv, m) = bv))))

axiom hpartqtspec2 :
  (forall bv:bitvec. forall m:int. ((0 <= m) ->
  (forall k:int. (((0 <= k) and (k <  m)) -> ((value(hpart(bv,
  m))[k]) = (value(bv)[k]))))))

axiom hpartqtspec3 :
  (forall bv:bitvec. forall m:int. ((0 <= m) ->
  (forall k:int. ((not ((0 <= k) and (k <  m))) -> ((value(hpart(bv,
  m))[k]) = 0)))))

axiom hpart_value :
  (forall bv:bitvec. forall m:int. forall i:int. ((0 <= m) ->
  ((value(hpart(bv, m))[i]) = (if ((0 <= i) and
  (i <  m)) then (value(bv)[i]) else 0))))

axiom hpart_length :
  (forall bv:bitvec. forall m:int. ((0 <= m) -> (length(hpart(bv, m)) = m)))

axiom hpart_value_b :
  (forall bv:bitvec. forall m:int. forall i:int. (((0 <= i) and (i <  m)) ->
  ((value(hpart(bv, m))[i]) = (value(bv)[i]))))

logic tpart : bitvec, int -> bitvec

logic result29 : bitvec, int -> (int,int) farray

logic result30 : bitvec, int -> (int,int) farray

axiom resultqtdef34 :
  (forall bv:bitvec. forall m:int. forall k:int. ((result29(bv,
  m)[k]) = (value(bv)[(k + m)])))

axiom resultqtdef35 :
  (forall bv:bitvec. forall m:int. forall k:int. ((result30(bv,
  m)[k]) = (value(bv)[(k + m)])))

axiom tpartqtdef :
  (forall bv:bitvec. forall m:int. ((0 <= m) -> ((m <= length(bv)) ->
  (tpart(bv, m) = make_bv(result29(bv, m), (length(bv) - m))))))

axiom tpartqtdef1 :
  (forall bv:bitvec. forall m:int. ((0 <= m) -> ((not (m <= length(bv))) ->
  (tpart(bv, m) = make_bv(result30(bv, m), 0)))))

axiom tpartqtspec :
  (forall bv:bitvec. forall m:int. ((0 <= m) -> ((m <= length(bv)) ->
  (length(tpart(bv, m)) = (length(bv) - m)))))

axiom tpartqtspec1 :
  (forall bv:bitvec. forall m:int. ((0 <= m) -> ((length(bv) <  m) ->
  (length(tpart(bv, m)) = 0))))

axiom tpartqtspec2 :
  (forall bv:bitvec. forall m:int. ((0 <= m) ->
  (forall k:int. (((0 <= k) and (k <  length(tpart(bv, m)))) ->
  ((value(tpart(bv, m))[k]) = (value(bv)[(k + m)]))))))

logic bv_tail : bitvec, int -> bitvec

axiom bv_tailqtdef :
  (forall bv:bitvec. forall m:int. (((0 <= m) and (m <= (length(bv) - m))) ->
  (bv_tail(bv, m) = tpart(bv, (length(bv) - m)))))

axiom bv_tailqtspec :
  (forall bv:bitvec. forall m:int. (((0 <= m) and (m <= (length(bv) - m))) ->
  (length(bv_tail(bv, m)) = m)))

axiom bv_tailqtspec1 :
  (forall bv:bitvec. forall m:int. (((0 <= m) and (m <= (length(bv) - m))) ->
  (forall k:int. (((0 <= k) and (k <  length(bv_tail(bv, m)))) ->
  ((value(bv_tail(bv, m))[k]) = (value(bv)[(k + (length(bv) - m))]))))))

logic last : bitvec -> int

axiom lastqtdef :
  (forall bv:bitvec. ((1 <= length(bv)) ->
  (last(bv) = (value(bv)[(length(bv) - 1)]))))

logic bv_head : bitvec, int -> bitvec

axiom bv_headqtdef :
  (forall bv:bitvec. forall m:int. (((0 <= m) and (m <= length(bv))) ->
  (bv_head(bv, m) = hpart(bv, (length(bv) - m)))))

axiom bv_headqtspec :
  (forall bv:bitvec. forall m:int. (((0 <= m) and (m <= length(bv))) ->
  (length(bv_head(bv, m)) = (length(bv) - m))))

axiom bv_headqtspec1 :
  (forall bv:bitvec. forall m:int. (((0 <= m) and (m <= length(bv))) ->
  (forall k:int. (((0 <= k) and (k <  length(bv_head(bv, m)))) ->
  ((value(bv_head(bv, m))[k]) = (value(bv)[k]))))))

logic htpart : bitvec, int, int -> bitvec

logic result31 : bitvec, int -> (int,int) farray

axiom resultqtdef36 :
  (forall bv:bitvec. forall k:int. forall i:int. ((result31(bv,
  k)[i]) = (value(bv)[(k + i)])))

axiom htpartqtdef :
  (forall bv:bitvec. forall k:int. forall n:int. ((0 <= k) -> ((0 <= n) ->
  (htpart(bv, k, n) = make_bv(result31(bv, k), n)))))

axiom htpartqtspec :
  (forall bv:bitvec. forall k:int. forall n:int. ((0 <= k) -> ((0 <= n) ->
  (length(htpart(bv, k, n)) = n))))

axiom htpartqtspec1 :
  (forall bv:bitvec. forall k:int. forall n:int. ((0 <= k) -> ((0 <= n) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((value(htpart(bv, k,
  n))[i]) = (value(bv)[(k + i)])))))))

axiom tpart_value :
  (forall bv:bitvec. forall m:int. forall i:int. ((0 <= m) ->
  ((value(tpart(bv, m))[i]) = (if ((0 <= i) and
  (i <  (length(bv) - m))) then (value(bv)[(i + m)]) else 0))))

axiom tpart_value_b :
  (forall bv:bitvec. forall m:int. forall i:int. ((0 <= m) -> (((0 <= i) and
  (i <  (length(bv) - m))) -> ((value(tpart(bv,
  m))[i]) = (value(bv)[(i + m)])))))

axiom tpart_length :
  (forall bv:bitvec. forall m:int. (((0 <= m) and (m <= length(bv))) ->
  (length(tpart(bv, m)) = (length(bv) - m))))

axiom htpart_value :
  (forall bv:bitvec. forall k:int. forall n:int. forall i:int. ((0 <= k) ->
  ((0 <= n) -> ((value(htpart(bv, k, n))[i]) = (if ((0 <= i) and
  (i <  n)) then (value(bv)[(k + i)]) else 0)))))

axiom htpart_value_b :
  (forall bv:bitvec. forall k:int. forall n:int. forall i:int. ((0 <= k) ->
  ((0 <= n) -> (((0 <= i) and (i <  n)) -> ((value(htpart(bv, k,
  n))[i]) = (value(bv)[(k + i)]))))))

axiom htpart_product_ :
  (forall x:bitvec. forall k:int. forall n:int. forall nqt:int.
  (((0 <= k) and (k <  n)) -> ((nqt = (n - k)) ->
  (ind_iproduct(value(htpart(x, k, nqt)), 0,
  (n - k)) = ind_iproduct(value(x), k, n)))))

axiom htpart_product_one :
  (forall x:bitvec. forall k:int. forall n:int. forall nqt:int.
  (((0 <= k) and (k <  n)) -> ((length(x) = n) -> ((nqt = (n - k)) ->
  ((ind_iproduct(value(x), 0, n) = 1) -> (ind_iproduct(value(htpart(x, k,
  nqt)), 0, (n - k)) = 1))))))

axiom htpart_product_zero :
  (forall x:bitvec. forall k:int. forall n:int. forall nqt:int.
  (((0 <= k) and (k <  n)) -> ((length(x) = n) -> ((nqt = (n - k)) ->
  ((exists j:int. (((k <= j) and (j <  n)) and (not ((value(x)[j]) = 1)))) ->
  (ind_iproduct(value(htpart(x, k, nqt)), 0, (n - k)) = 0))))))

axiom htpart_product :
  (forall x:bitvec. forall k:int. forall n:int. forall nqt:int.
  (((0 <= k) and (k <  n)) -> ((length(x) = n) -> ((nqt = (n - k)) ->
  (ind_iproduct(value(htpart(x, k, nqt)), 0,
  (n - k)) = (if (forall j:int. (((k <= j) and (j <  n)) ->
                 ((value(x)[j]) = 1))) then 1 else 0))))))

axiom htpart_length :
  (forall bv:bitvec. forall k:int. forall n:int. ((0 <= k) -> ((0 <= n) ->
  (length(htpart(bv, k, n)) = n))))

axiom tpart_length_gen :
  (forall bv:bitvec. forall m:int. forall l:int. (((0 <= m) and
  (m <= length(bv))) -> ((l = (length(bv) - m)) -> (length(tpart(bv,
  m)) = l))))

axiom concat_value_left :
  (forall bv1:bitvec. forall bv2:bitvec. forall i:int. (((0 <= i) and
  (i <  length(bv1))) -> ((value(concat(bv1, bv2))[i]) = (value(bv1)[i]))))

axiom concat_value :
  (forall bv1:bitvec. forall bv2:bitvec. forall i:int. ((value(concat(bv1,
  bv2))[i]) = (if ((length(bv1) <= i) and
  (i <  (length(bv1) + length(bv2)))) then (value(bv2)[(i - length(bv1))]) else (if ((0 <= i) and
  (i <  length(bv1))) then (value(bv1)[i]) else 0))))

axiom concat_value_b :
  (forall bv1:bitvec. forall bv2:bitvec. forall i:int. (((0 <= i) and
  (i <  (length(bv1) + length(bv2)))) -> ((value(concat(bv1,
  bv2))[i]) = (if (i <  length(bv1)) then (value(bv1)[i]) else (value(bv2)[(i - length(bv1))])))))

axiom concat_value_right :
  (forall bv1:bitvec. forall bv2:bitvec. forall i:int.
  (((length(bv1) <= i) and (i <  (length(bv1) + length(bv2)))) ->
  ((value(concat(bv1, bv2))[i]) = (value(bv2)[(i - length(bv1))]))))

axiom concat_value_out :
  (forall bv1:bitvec. forall bv2:bitvec. forall i:int.
  (((length(bv1) + length(bv2)) <  i) -> ((value(concat(bv1,
  bv2))[i]) = (value(bv1)[i]))))

axiom concat_value_tpart :
  (forall bv1:bitvec. forall bv2:bitvec. forall i:int.
  (((length(bv1) <= i) and (i <  length(bv2))) -> ((value(concat(bv1,
  tpart(bv2, length(bv1))))[i]) = (value(bv2)[i]))))

axiom concat_value_ht :
  (forall bv1:bitvec. forall bv2:bitvec. forall bv3:bitvec.
  forall bv4:bitvec. forall i:int. (((0 <= i) and (i <  length(bv3))) ->
  ((((0 <= i) and (i <  length(bv1))) ->
  ((value(bv1)[i]) = (value(bv4)[i]))) -> (((length(bv1) <= i) ->
  ((value(bv3)[i]) = (value(bv4)[i]))) -> ((bv2 = tpart(bv3, length(bv1))) ->
  ((value(concat(bv1, bv2))[i]) = (value(bv4)[i])))))))

axiom concat_ht1 :
  (forall bv1:bitvec. forall bv2:bitvec. forall bv3:bitvec.
  forall bv4:bitvec.
  ((forall i:int. (((0 <= i) and (i <  length(bv1))) ->
   ((value(bv1)[i]) = (value(bv4)[i])))) ->
  ((forall i:int. ((length(bv1) <= i) ->
   ((value(bv3)[i]) = (value(bv4)[i])))) ->
  ((length(bv4) = (length(bv1) + length(bv2))) ->
  (((length(bv1) + length(bv2)) <= length(bv3)) -> ((bv2 = tpart(bv3,
  length(bv1))) -> (concat(bv1, bv2) = bv4)))))))

axiom set_concat :
  (forall bv1:bitvec. forall bv2:bitvec. forall bv4:bitvec.
  ((forall i:int. (((0 <= i) and (i <  length(bv1))) ->
   ((value(bv1)[i]) = (value(bv4)[i])))) ->
  ((forall i:int. ((length(bv1) <= i) ->
   ((value(bv2)[(i - length(bv1))]) = (value(bv4)[i])))) ->
  ((length(bv4) = (length(bv1) + length(bv2))) -> (concat(bv1,
  bv2) = bv4)))))

axiom concat_m :
  (forall bv1:bitvec. forall bv2:bitvec. forall i1:int. forall i2:int.
  ((0 <  i1) -> ((0 <  i2) -> ((length(bv1) = i1) -> ((length(bv2) = i2) ->
  (concat(make_bv_m(value(bv1), i1), make_bv_m(value(bv2),
  i2)) = make_bv_m(value(concat(bv1, bv2)), (i1 + i2))))))))

axiom concat_comm :
  (forall bv1:bitvec. forall bv2:bitvec. (hpart(concat(bv1, bv2),
  length(bv1)) = bv1))

axiom concat_comm1 :
  (forall bv1:bitvec. forall bv2:bitvec. (tpart(concat(bv1, bv2),
  length(bv1)) = bv2))

axiom concat_and_rec :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <= length(bv))) ->
  (concat(hpart(bv, i), tpart(bv, i)) = bv)))

axiom bv_decomp_ht :
  (forall bv:bitvec. forall i:int. (((0 <= i) and (i <= length(bv))) ->
  (bv = concat(hpart(bv, i), tpart(bv, i)))))

axiom bv_decomp_hhtt :
  (forall bv:bitvec. forall i:int. forall j:int. forall k:int. ((0 <= i) ->
  ((0 <= j) -> (((0 <= k) and (k <= length(bv))) -> ((k = (i + j)) ->
  (bv = concat(concat(hpart(bv, i), htpart(bv, i, j)), tpart(bv, k))))))))

axiom bv_decomp_hhtt_rev :
  (forall bv:bitvec. forall i:int. forall j:int. forall k:int. ((0 <= i) ->
  ((0 <= j) -> (((0 <= k) and (k <= length(bv))) -> ((k = (i + j)) ->
  (concat(concat(hpart(bv, i), htpart(bv, i, j)), tpart(bv, k)) = bv))))))

logic concat_int_bv : bitvec, int, int -> bitvec

axiom concat_int_bvqtdef :
  (forall bv:bitvec. forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and
  (i <  power(2, n))) -> (concat_int_bv(bv, i, n) = concat(bv, int_to_bv(i,
  n))))))

axiom concat_int_to_bv_value :
  (forall bv:bitvec. forall i:int. forall n:int. forall j:int. ((0 <  n) ->
  (((0 <= i) and (i <  power(2, n))) -> (((0 <= j) and
  (j <  length(concat_int_bv(bv, i, n)))) -> ((j <  length(bv)) ->
  ((value(concat_int_bv(bv, i, n))[j]) = (value(bv)[j])))))))

axiom bv_to_int_concat :
  (forall bvx:bitvec. forall bvy:bitvec. (bv_to_int(concat(bvx,
  bvy)) = ((power(2, length(bvy)) * bv_to_int(bvx)) + bv_to_int(bvy))))

axiom concat_fin :
  (forall f1:(int,int) farray. forall f2:(int,int) farray. forall l1:int.
  forall l2:int. ((0 <= l1) -> ((0 <= l2) -> (binary(f1) -> (binary(f2) ->
  (make_bv(((((concat_fun_closure : ((int,int) farray,((int,int) farray,(int,(int,int) farray) farray) farray) farray)[f1])[f2])[l1]),
  (l1 + l2)) = concat(make_bv(f1, l1), make_bv(f2, l2))))))))

axiom bin_to_int_concat :
  (forall f1:(int,int) farray. forall f2:(int,int) farray. forall l1:int.
  forall l2:int. ((0 <= l1) -> ((0 <= l2) -> (binary(f1) -> (binary(f2) ->
  (bin_to_int(((((concat_fun_closure : ((int,int) farray,((int,int) farray,(int,(int,int) farray) farray) farray) farray)[f1])[f2])[l1]),
  (l1 + l2)) = ((power(2, l2) * bin_to_int(f1, l1)) + bin_to_int(f2,
  l2))))))))

logic inv_func : ('a,'b) farray, 'a set, 'b set, 'b -> 'a

logic result32 : ('a,'b) farray, 'b -> ('a,bool) farray

axiom resultqtdef37 :
  (forall f:('a,'b) farray. forall eqt:'b. forall e:'a. ((result32(f,
  eqt)[e]) = indic_bool((f[e]), eqt)))

axiom inv_funcqtdef :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  forall eqt:'b. (p_bijective(f, s, sqt) -> (mem(eqt, sqt) -> (inv_func(f, s,
  sqt, eqt) = element(my_filter(s, result32(f, eqt)))))))

axiom inv_funcqtspec :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  forall eqt:'b. (p_bijective(f, s, sqt) -> (mem(eqt, sqt) -> mem(inv_func(f,
  s, sqt, eqt), s))))

axiom inv_funcqtspec1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  forall eqt:'b. (p_bijective(f, s, sqt) -> (mem(eqt, sqt) -> ((f[inv_func(f,
  s, sqt, eqt)]) = eqt))))

logic inv_func_closure : (('a,'b) farray,('a set,('b set,('b,'a) farray) farray) farray) farray

axiom inv_func_closure_def :
  (forall y:('a,'b) farray. forall y1:'a set. forall y2:'b set. forall y3:'b.
  ((((((inv_func_closure : (('a,'b) farray,('a set,('b set,('b,'a) farray) farray) farray) farray)[y])[y1])[y2])[y3]) = inv_func(y,
  y1, y2, y3)))

axiom bijective_inv_func :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) ->
  p_bijective(((((inv_func_closure : (('a,'b) farray,('a set,('b set,('b,'a) farray) farray) farray) farray)[f])[s])[sqt]),
  sqt, s)))

axiom inv_rec :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set. forall e:'a.
  (p_bijective(f, s, sqt) -> (mem(e, s) -> (inv_func(f, s, sqt,
  (f[e])) = e))))

logic inv_ : ('a,'b) farray, 'a set, 'b set, 'b -> 'a

axiom inv_qtdef :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set. forall e:'b.
  (p_bijective(f, s, sqt) -> (mem(e, sqt) -> (inv_(f, s, sqt,
  e) = inv_func(f, s, sqt, e)))))

axiom inv_qtspec :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set. forall e:'b.
  (p_bijective(f, s, sqt) -> (mem(e, sqt) -> mem(inv_(f, s, sqt, e), s))))

axiom inv_qtspec1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set. forall e:'b.
  (p_bijective(f, s, sqt) -> (mem(e, sqt) -> ((f[inv_(f, s, sqt, e)]) = e))))

logic inv__closure : (('a,'b) farray,('a set,('b set,('b,'a) farray) farray) farray) farray

axiom inv__closure_def :
  (forall y:('a,'b) farray. forall y1:'a set. forall y2:'b set. forall y3:'b.
  ((((((inv__closure : (('a,'b) farray,('a set,('b set,('b,'a) farray) farray) farray) farray)[y])[y1])[y2])[y3]) = inv_(y,
  y1, y2, y3)))

axiom inv_bijective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) ->
  p_bijective(((((inv__closure : (('a,'b) farray,('a set,('b set,('b,'a) farray) farray) farray) farray)[f])[s])[sqt]),
  sqt, s)))

axiom set_bijective_inv :
  (forall f:('a,'b) farray. forall g:('b,'a) farray. forall s:'a set.
  forall b1:'b. (mem(b1, map(f, s)) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:'b. (mem(eqt, map(f, s)) -> (mem((g[eqt]), s) and
   ((f[(g[eqt])]) = eqt)))) ->
  p_bijective(f, s, map(f, s))))))

axiom set_bijective_inv1 :
  (forall f:('a,'b) farray. forall g:('b,'a) farray. forall s:'a set.
  forall b1:'b. (mem(b1, map(f, s)) ->
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:'b. (mem(eqt, map(f, s)) -> (mem((g[eqt]), s) and
   ((f[(g[eqt])]) = eqt)))) ->
  (inv_func(f, s, map(f, s), b1) = (g[b1]))))))

axiom set_bij_inv :
  (forall f:('a,'b) farray. forall g:('b,'a) farray. forall s:'a set.
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:'b. (mem(eqt, map(f, s)) -> (mem((g[eqt]), s) and
   ((f[(g[eqt])]) = eqt)))) ->
  p_bijective(f, s, map(f, s)))))

axiom set_bij_inv1 :
  (forall f:('a,'b) farray. forall g:('b,'a) farray. forall s:'a set.
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:'b. (mem(eqt, map(f, s)) -> (mem((g[eqt]), s) and
   ((f[(g[eqt])]) = eqt)))) ->
  p_bijective(g, map(f, s), s))))

axiom set_bij_inv2 :
  (forall f:('a,'b) farray. forall g:('b,'a) farray. forall s:'a set.
  ((forall e:'a. forall eqt:'a. (mem(e, s) -> (mem(eqt, s) ->
   ((not (e = eqt)) -> (not ((f[e]) = (f[eqt]))))))) ->
  ((forall eqt:'b. (mem(eqt, map(f, s)) -> (mem((g[eqt]), s) and
   ((f[(g[eqt])]) = eqt)))) ->
  (forall b1:'b. (mem(b1, map(f, s)) -> (inv_func(f, s, map(f, s),
  b1) = (g[b1])))))))

logic inv_f : ('a,'b) farray, 'a set, 'b set -> ('b,'a) farray

axiom inv_fqtspec :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) ->
  (forall e:'b. (mem(e, sqt) -> mem((inv_f(f, s, sqt)[e]), s)))))

axiom inv_fqtspec1 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) ->
  (forall e:'b. (mem(e, sqt) -> ((f[(inv_f(f, s, sqt)[e])]) = e)))))

axiom inv_fqtspec2 :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_bijective(f, s, sqt) -> p_bijective(inv_f(f, s, sqt), sqt, s)))

axiom inv_f_back :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set. forall e:'b.
  (mem(e, sqt) -> (p_bijective(f, s, sqt) -> ((f[(inv_f(f, s,
  sqt)[e])]) = e))))

axiom inv_f_back_rev :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set. forall e:'a.
  (mem(e, s) -> (p_bijective(f, s, sqt) -> ((inv_f(f, s,
  sqt)[(f[e])]) = e))))

axiom injective_is_bijective :
  (forall f:('a,'b) farray. forall s:'a set. forall sqt:'b set.
  (p_injective(f, s) -> ((forall e:'a. (mem(e, s) -> mem((f[e]), sqt))) ->
  ((cardinal(s) = cardinal(sqt)) -> p_bijective(f, s, sqt)))))

axiom injective_is_bijective_auto :
  (forall f:('a,'a) farray. forall s:'a set. (p_injective(f, s) ->
  ((forall e:'a. (mem(e, s) -> mem((f[e]), s))) -> p_bijective(f, s, s))))

axiom injective_is_bijective_auto1 :
  (forall f:('a,'a) farray. forall s:'a set. (p_injective(f, s) ->
  ((forall e:'a. (mem(e, s) -> mem((f[e]), s))) -> (map(f, s) = s))))

logic inv_auto : ('a,'a) farray, 'a set -> ('a,'a) farray

axiom inv_autoqtdef :
  (forall f:('a,'a) farray. forall s:'a set. (p_injective(f, s) ->
  ((forall e:'a. (mem(e, s) -> mem((f[e]), s))) -> (inv_auto(f, s) = inv_f(f,
  s, s)))))

axiom inv_autoqtspec :
  (forall f:('a,'a) farray. forall s:'a set. (p_injective(f, s) ->
  ((forall e:'a. (mem(e, s) -> mem((f[e]), s))) ->
  (forall e:'a. (mem(e, s) -> mem((inv_auto(f, s)[e]), s))))))

axiom inv_autoqtspec1 :
  (forall f:('a,'a) farray. forall s:'a set. (p_injective(f, s) ->
  ((forall e:'a. (mem(e, s) -> mem((f[e]), s))) ->
  (forall e:'a. (mem(e, s) -> ((f[(inv_auto(f, s)[e])]) = e))))))

axiom inv_autoqtspec2 :
  (forall f:('a,'a) farray. forall s:'a set. (p_injective(f, s) ->
  ((forall e:'a. (mem(e, s) -> mem((f[e]), s))) -> p_bijective(inv_auto(f,
  s), s, s))))

logic fc295 : ((bitvec, bitvec) tuple2,bitvec) farray

logic fc296 : int -> (bitvec,(bitvec, bitvec) tuple2) farray

axiom fcqtdef295 :
  (forall o:(bitvec, bitvec) tuple2. ((fc295[o]) = concat(fir(o), sec(o))))

axiom fcqtdef296 :
  (forall i:int. forall x:bitvec. ((fc296(i)[x]) = { Tuple2_proj_1 = hpart(x,
  i); Tuple2_proj_2 = tpart(x, i) }))

axiom bijective_concat :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <= j) -> p_bijective(fc295,
  cartesian_product(n_bvs(i), n_bvs(j)), n_bvs((i + j))))))

axiom bijective_concat1 :
  (forall i:int. forall j:int. ((0 <= i) -> ((0 <= j) ->
  p_bijective(fc296(i), n_bvs((i + j)), cartesian_product(n_bvs(i),
  n_bvs(j))))))

axiom bv_to_int_hpart :
  (forall bv:bitvec. forall l:int. (((0 <= l) and (l <= length(bv))) ->
  (bv_to_int(hpart(bv, l)) = (bv_to_int(bv) / power(2, (length(bv) - l))))))

axiom bv_to_int_tpart :
  (forall bv:bitvec. forall l:int. (((0 <= l) and (l <= length(bv))) ->
  (bv_to_int(tpart(bv, l)) = (bv_to_int(bv) % power(2, (length(bv) - l))))))

axiom bv_to_int_hpart_rev :
  (forall bv:bitvec. forall l:int. forall q:int. ((q = (length(bv) - l)) ->
  (((0 <= l) and (l <= length(bv))) -> ((bv_to_int(bv) / power(2,
  q)) = bv_to_int(hpart(bv, l))))))

axiom bv_to_int_tpart_rev :
  (forall bv:bitvec. forall l:int. forall q:int. ((q = (length(bv) - l)) ->
  (((0 <= l) and (l <= length(bv))) -> ((bv_to_int(bv) % power(2,
  q)) = bv_to_int(tpart(bv, l))))))

logic ind_basis_mat : int, int, int, int -> complex matrix

logic result33 : int, int -> (int,(int,complex) farray) farray

axiom resultqtdef38 :
  (forall i:int. forall j:int. forall k:int. forall l:int. (((result33(i,
  j)[k])[l]) = indic_2(k, i, l, j)))

axiom ind_basis_matqtdef :
  (forall i:int. forall j:int. forall r:int. forall c:int. (((0 <= i) and
  (i <  r)) -> (((0 <= j) and (j <  c)) -> (ind_basis_mat(i, j, r,
  c) = make_f(r, c, result33(i, j))))))

axiom ind_basis_matqtspec :
  (forall i:int. forall j:int. forall r:int. forall c:int. (((0 <= i) and
  (i <  r)) -> (((0 <= j) and (j <  c)) -> (rows(ind_basis_mat(i, j, r,
  c)) = r))))

axiom ind_basis_matqtspec1 :
  (forall i:int. forall j:int. forall r:int. forall c:int. (((0 <= i) and
  (i <  r)) -> (((0 <= j) and (j <  c)) -> (columns(ind_basis_mat(i, j, r,
  c)) = c))))

axiom ind_basis_matqtspec2 :
  (forall i:int. forall j:int. forall r:int. forall c:int. (((0 <= i) and
  (i <  r)) -> (((0 <= j) and (j <  c)) ->
  (forall k:int. forall l:int. (valid_index(ind_basis_mat(i, j, r, c), k,
  l) -> (get(ind_basis_mat(i, j, r, c), k, l) = indic_2(k, i, l, j)))))))

axiom ind_basis_matqtspec3 :
  (forall i:int. forall j:int. forall r:int. forall c:int. (((0 <= i) and
  (i <  r)) -> (((0 <= j) and (j <  c)) ->
  (forall o:(int, int) tuple2. (mem(o, mat_indices(ind_basis_mat(i, j, r,
  c))) -> ((get(ind_basis_mat(i, j, r, c), fir(o), sec(o)) = c_one) ->
  (fir(o) = i)))))))

axiom ind_basis_matqtspec4 :
  (forall i:int. forall j:int. forall r:int. forall c:int. (((0 <= i) and
  (i <  r)) -> (((0 <= j) and (j <  c)) ->
  (forall o:(int, int) tuple2. (mem(o, mat_indices(ind_basis_mat(i, j, r,
  c))) -> ((get(ind_basis_mat(i, j, r, c), fir(o), sec(o)) = c_one) ->
  (sec(o) = j)))))))

axiom ind_basis_matqtspec5 :
  (forall i:int. forall j:int. forall r:int. forall c:int. (((0 <= i) and
  (i <  r)) -> (((0 <= j) and (j <  c)) ->
  (forall o:(int, int) tuple2. (mem(o, mat_indices(ind_basis_mat(i, j, r,
  c))) -> (((fir(o) = i) and (sec(o) = j)) -> (get(ind_basis_mat(i, j, r, c),
  fir(o), sec(o)) = c_one)))))))

axiom ind_basis_mat_values :
  (forall i:int. forall j:int. forall r:int. forall c:int. (((0 <= i) and
  (i <  r)) -> (((0 <= j) and (j <  c)) ->
  (forall i1:int. forall j1:int. (((0 <= i1) and (i1 <  r)) ->
  (((0 <= j1) and (j1 <  c)) -> (get(ind_basis_mat(i, j, r, c), i1,
  j1) = indic_2(i, i1, j, j1))))))))

axiom unic_ind_basis_mat :
  (forall i1:int. forall j1:int. forall i2:int. forall j2:int. forall r:int.
  forall c:int. (((0 <= i1) and (i1 <  r)) -> (((0 <= j1) and (j1 <  c)) ->
  (((0 <= i2) and (i2 <  r)) -> (((0 <= j2) and (j2 <  c)) ->
  ((ind_basis_mat(i1, j1, r, c) = ind_basis_mat(i2, j2, r, c)) -> ({
  Tuple2_proj_1 = i1; Tuple2_proj_2 = j1 } = { Tuple2_proj_1 = i2;
  Tuple2_proj_2 = j2 })))))))

logic basis_mat : int, int -> complex matrix set

logic result34 : int, int -> ((int, int) tuple2,complex matrix) farray

axiom resultqtdef39 :
  (forall r:int. forall c:int. forall o:(int, int) tuple2. ((result34(r,
  c)[o]) = (let j = (o).Tuple2_proj_2 : int in (let i = (o).Tuple2_proj_1
  : int in (if (((0 <= i) and (i <  r)) and ((0 <= j) and
  (j <  c))) then ind_basis_mat(i, j, r, c) else make(r, c, c_zero))))))

axiom basis_matqtdef :
  (forall r:int. forall c:int. ((0 <  r) -> ((0 <  c) -> (basis_mat(r,
  c) = map(result34(r, c), cartesian_product(to_fset(0, r), to_fset(0,
  c)))))))

logic fc297 : int, int -> ((int, int) tuple2,complex matrix) farray

logic fc298 : complex matrix -> ((int, int) tuple2,bool) farray

axiom fcqtdef297 :
  (forall r:int. forall c:int. forall o:(int, int) tuple2. ((fc297(r,
  c)[o]) = ind_basis_mat(fir(o), sec(o), r, c)))

axiom fcqtdef298 :
  (forall m:complex matrix. forall x:(int, int) tuple2.
  (((fc298(m)[x]) = true) -> (get(m, fir(x), sec(x)) = c_one)))

axiom fcqtdef299 :
  (forall m:complex matrix. forall x:(int, int) tuple2. ((get(m, fir(x),
  sec(x)) = c_one) -> ((fc298(m)[x]) = true)))

axiom basis_matqtspec :
  (forall r:int. forall c:int. ((0 <  r) -> ((0 <  c) ->
  (forall m:complex matrix. (mem(m, basis_mat(r, c)) ->
  (exists i:int. exists j:int. (((0 <= i) and (i <  r)) and (((0 <= j) and
  (j <  c)) and (m = ind_basis_mat(i, j, r, c))))))))))

axiom basis_matqtspec1 :
  (forall r:int. forall c:int. ((0 <  r) -> ((0 <  c) ->
  (forall m:complex matrix.
  ((exists i:int. exists j:int. (((0 <= i) and (i <  r)) and (((0 <= j) and
   (j <  c)) and (m = ind_basis_mat(i, j, r, c))))) ->
  mem(m, basis_mat(r, c)))))))

axiom basis_matqtspec2 :
  (forall r:int. forall c:int. ((0 <  r) -> ((0 <  c) -> (basis_mat(r,
  c) = map(fc297(r, c), cartesian_product(to_fset(0, r), to_fset(0, c)))))))

axiom basis_matqtspec3 :
  (forall r:int. forall c:int. ((0 <  r) -> ((0 <  c) ->
  constant_size(basis_mat(r, c), identity1))))

axiom basis_matqtspec4 :
  (forall r:int. forall c:int. ((0 <  r) -> ((0 <  c) ->
  (s_columns(basis_mat(r, c), identity1) = c))))

axiom basis_matqtspec5 :
  (forall r:int. forall c:int. ((0 <  r) -> ((0 <  c) -> (s_rows(basis_mat(r,
  c), identity1) = r))))

axiom basis_matqtspec6 :
  (forall r:int. forall c:int. ((0 <  r) -> ((0 <  c) ->
  (forall m:complex matrix. (mem(m, basis_mat(r, c)) ->
  (cardinal(my_filter(mat_indices(m), fc298(m))) = 1))))))

logic basis_mat_indexes : complex matrix -> (int, int) tuple2

logic result35 : complex matrix -> ((int, int) tuple2,bool) farray

axiom resultqtdef40 :
  (forall m:complex matrix. forall x:(int, int) tuple2.
  (((result35(m)[x]) = true) -> mem(x, mat_indices(m))))

axiom resultqtdef41 :
  (forall m:complex matrix. forall x:(int, int) tuple2.
  (((result35(m)[x]) = true) -> infix_eqeq(m, ind_basis_mat(fir(x), sec(x),
  rows(m), columns(m)))))

axiom resultqtdef42 :
  (forall m:complex matrix. forall x:(int, int) tuple2. ((mem(x,
  mat_indices(m)) and infix_eqeq(m, ind_basis_mat(fir(x), sec(x), rows(m),
  columns(m)))) -> ((result35(m)[x]) = true)))

axiom basis_mat_indexesqtdef :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  (basis_mat_indexes(m) = element(my_filter(mat_indices(m), result35(m))))))

logic fc299 : complex matrix -> (int,(int,complex) farray) farray

axiom fcqtdef300 :
  (forall m:complex matrix. forall i:int. forall j:int.
  (((fc299(m)[i])[j]) = indic_2(fir(basis_mat_indexes(m)), i,
  sec(basis_mat_indexes(m)), j)))

axiom basis_mat_indexesqtspec :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  (m = ind_basis_mat(fir(basis_mat_indexes(m)), sec(basis_mat_indexes(m)),
  rows(m), columns(m)))))

axiom basis_mat_indexesqtspec1 :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  (m = make_f(rows(m), columns(m), fc299(m)))))

axiom basis_mat_indexesqtspec2 :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  (get(m, fir(basis_mat_indexes(m)), sec(basis_mat_indexes(m))) = c_one)))

axiom basis_mat_indexesqtspec3 :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  (forall i:int. forall j:int. (valid_index(m, i, j) ->
  ((i = fir(basis_mat_indexes(m))) ->
  ((not (j = sec(basis_mat_indexes(m)))) -> (get(m, i, j) = c_zero)))))))

axiom basis_mat_indexesqtspec4 :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  valid_index(m, fir(basis_mat_indexes(m)), sec(basis_mat_indexes(m)))))

logic fc300 : complex matrix -> (int,(int,complex) farray) farray

axiom fcqtdef301 :
  (forall m:complex matrix. forall i:int. forall j:int.
  (((fc300(m)[i])[j]) = indic_2(fir(basis_mat_indexes(m)), i,
  sec(basis_mat_indexes(m)), j)))

axiom get_basis_mat_indexes :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  (m = ind_basis_mat(fir(basis_mat_indexes(m)), sec(basis_mat_indexes(m)),
  rows(m), columns(m)))))

axiom get_basis_mat_indexes1 :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  (m = make_f(rows(m), columns(m), fc300(m)))))

axiom get_basis_mat_indexes2 :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  (get(m, fir(basis_mat_indexes(m)), sec(basis_mat_indexes(m))) = c_one)))

axiom get_basis_mat_indexes3 :
  (forall m:complex matrix. (mem(m, basis_mat(rows(m), columns(m))) ->
  (forall i:int. forall j:int. (valid_index(m, i, j) ->
  ((not (basis_mat_indexes(m) = { Tuple2_proj_1 = i; Tuple2_proj_2 = j })) ->
  (get(m, i, j) = c_zero))))))

logic fc301 : int, int -> (int,(int,complex) farray) farray

axiom fcqtdef302 :
  (forall i:int. forall j:int. forall i1:int. forall j1:int. (((fc301(i,
  j)[i1])[j1]) = indic_2(i, i1, j, j1)))

axiom set_basis_mat_indexes :
  (forall m:complex matrix. forall i:int. forall j:int. (valid_index(m, i,
  j) -> (mem(m, basis_mat(rows(m), columns(m))) -> ((get(m, i, j) = c_one) ->
  (basis_mat_indexes(m) = { Tuple2_proj_1 = i; Tuple2_proj_2 = j })))))

axiom set_basis_mat_indexes1 :
  (forall m:complex matrix. forall i:int. forall j:int. (valid_index(m, i,
  j) -> (mem(m, basis_mat(rows(m), columns(m))) -> ((get(m, i, j) = c_one) ->
  (m = ind_basis_mat(i, j, rows(m), columns(m)))))))

axiom set_basis_mat_indexes2 :
  (forall m:complex matrix. forall i:int. forall j:int. (valid_index(m, i,
  j) -> (mem(m, basis_mat(rows(m), columns(m))) -> ((get(m, i, j) = c_one) ->
  (m = make_f(rows(m), columns(m), fc301(i, j)))))))

axiom set_basis_mat_indexes3 :
  (forall m:complex matrix. forall i:int. forall j:int. (valid_index(m, i,
  j) -> (mem(m, basis_mat(rows(m), columns(m))) -> ((get(m, i, j) = c_one) ->
  (forall i1:int. forall j1:int. (valid_index(m, i1, j1) -> ((i1 = i) ->
  ((not (j1 = j)) -> (get(m, i1, j1) = c_zero)))))))))

logic basis_projection : complex matrix, int, int -> complex matrix

axiom basis_projectionqtdef :
  (forall m:complex matrix. forall i:int. forall j:int. (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(m))) ->
  (basis_projection(m, i, j) = infix_asdtdt(get(m, i, j), ind_basis_mat(i, j,
  rows(m), columns(m)))))))

logic fc302 : complex matrix, int, int -> (int,(int,complex) farray) farray

axiom fcqtdef303 :
  (forall m:complex matrix. forall i:int. forall j:int. forall k:int.
  forall l:int. (((fc302(m, i, j)[k])[l]) = infix_asdt(get(m, i, j),
  indic_2(k, i, l, j))))

axiom basis_projectionqtspec :
  (forall m:complex matrix. forall i:int. forall j:int. (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(m))) ->
  (rows(basis_projection(m, i, j)) = rows(m)))))

axiom basis_projectionqtspec1 :
  (forall m:complex matrix. forall i:int. forall j:int. (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(m))) ->
  (columns(basis_projection(m, i, j)) = columns(m)))))

axiom basis_projectionqtspec2 :
  (forall m:complex matrix. forall i:int. forall j:int. (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(m))) ->
  (basis_projection(m, i, j) = make_f(rows(m), columns(m), fc302(m, i,
  j))))))

axiom basis_projectionqtspec3 :
  (forall m:complex matrix. forall i:int. forall j:int. (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(m))) ->
  (get(basis_projection(m, i, j), i, j) = get(m, i, j)))))

axiom basis_projectionqtspec4 :
  (forall m:complex matrix. forall i:int. forall j:int. (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(m))) ->
  (forall iqt:int. forall jqt:int. (valid_index(basis_projection(m, i, j),
  iqt, jqt) -> ((not (iqt = i)) -> (get(basis_projection(m, i, j), iqt,
  jqt) = c_zero)))))))

axiom basis_projectionqtspec5 :
  (forall m:complex matrix. forall i:int. forall j:int. (((0 <= i) and
  (i <  rows(m))) -> (((0 <= j) and (j <  columns(m))) ->
  (forall iqt:int. forall jqt:int. (valid_index(basis_projection(m, i, j),
  iqt, jqt) -> ((not (jqt = j)) -> (get(basis_projection(m, i, j), iqt,
  jqt) = c_zero)))))))

axiom basis_projection_null :
  (forall m:complex matrix. forall i:int. forall j:int. forall k:int.
  forall l:int. (valid_index(m, i, j) -> (valid_index(m, k, l) ->
  (((i = k) -> (not (j = l))) -> (get(basis_projection(m, i, j), k,
  l) = c_zero)))))

logic result36 : complex matrix -> ((int, int) tuple2,complex matrix) farray

axiom resultqtdef43 :
  (forall m:complex matrix. forall o:(int, int) tuple2.
  ((result36(m)[o]) = (if valid_index(m, fir(o),
  sec(o)) then basis_projection(m, fir(o), sec(o)) else m)))

function basis_projections(m: complex matrix) : complex matrix set =
  map(result36(m), to_indexes(m))

logic couple_closure : (('a,('b,'im1) farray) farray,(('a,
  'b) tuple2,'im1) farray) farray

logic basis_projection_closure : (complex matrix,(int,(int,complex matrix) farray) farray) farray

axiom couple_closure_def :
  (forall y:('a,('b,'im1) farray) farray. forall y1:('a, 'b) tuple2.
  ((((couple_closure : (('a,('b,'im1) farray) farray,(('a,
  'b) tuple2,'im1) farray) farray)[y])[y1]) = couple(y, y1)))

axiom basis_projection_closure_def :
  (forall y:complex matrix. forall y1:int. forall y2:int.
  ((((basis_projection_closure[y])[y1])[y2]) = basis_projection(y, y1, y2)))

axiom basis_projectionsqtspec :
  (forall m:complex matrix.
  (basis_projections(m) = map(((couple_closure : ((int,(int,complex matrix) farray) farray,((int,
  int) tuple2,complex matrix) farray) farray)[(basis_projection_closure[m])]),
  to_indexes(m))))

axiom basis_projectionsqtspec1 :
  (forall m:complex matrix.
  (forall e:complex matrix. (mem(e, basis_projections(m)) ->
  (rows(e) = rows(m)))))

axiom basis_projectionsqtspec2 :
  (forall m:complex matrix.
  (forall e:complex matrix. (mem(e, basis_projections(m)) ->
  (columns(e) = columns(m)))))

axiom basis_projectionsqtspec3 :
  (forall m:complex matrix. constant_size(basis_projections(m), identity1))

logic fc303 : complex matrix -> ((int, int) tuple2,complex matrix) farray

axiom fcqtdef304 :
  (forall m:complex matrix. forall o:(int, int) tuple2.
  ((fc303(m)[o]) = (if valid_index(m, fir(o),
  sec(o)) then basis_projection(m, fir(o), sec(o)) else m)))

axiom rewrite_basis_projections :
  (forall m:complex matrix. (basis_projections(m) = map(fc303(m),
  to_indexes(m))))

logic result37 : complex matrix -> ((int, int) tuple2,complex matrix) farray

axiom resultqtdef44 :
  (forall m:complex matrix. forall o:(int, int) tuple2.
  ((result37(m)[o]) = (if mem(o, to_indexes(m)) then basis_projection(m,
  fir(o), sec(o)) else m)))

function indexes_decomp(m: complex matrix) : complex matrix =
  mat_sum(to_indexes(m), result37(m))

axiom indexes_decompqtspec :
  (forall m:complex matrix. (rows(indexes_decomp(m)) = rows(m)))

axiom indexes_decompqtspec1 :
  (forall m:complex matrix. (columns(indexes_decomp(m)) = columns(m)))

logic fc304 : complex matrix -> ((int, int) tuple2,complex matrix) farray

axiom fcqtdef305 :
  (forall m:complex matrix. forall o:(int, int) tuple2.
  ((fc304(m)[o]) = basis_projection(m, fir(o), sec(o))))

axiom rewrite_indexes_decomp :
  (forall m:complex matrix. (indexes_decomp(m) = mat_sum(to_indexes(m),
  fc304(m))))

logic fc305 : complex matrix, int, int -> ((int, int) tuple2,complex) farray

axiom fcqtdef306 :
  (forall m:complex matrix. forall i:int. forall j:int. forall o:(int,
  int) tuple2. ((fc305(m, i, j)[o]) = get(basis_projection(m, fir(o),
  sec(o)), i, j)))

axiom indexes_decomp_pre :
  (forall m:complex matrix. forall i:int. forall j:int. (valid_index(m, i,
  j) -> (get(m, i, j) = sum(to_indexes(m), fc305(m, i, j)))))

logic fc306 : complex matrix, int, int -> ((int, int) tuple2,complex) farray

axiom fcqtdef307 :
  (forall m:complex matrix. forall i:int. forall j:int. forall o:(int,
  int) tuple2. ((fc306(m, i, j)[o]) = get(basis_projection(m, fir(o),
  sec(o)), i, j)))

axiom indexes_decomp_pre_gen :
  (forall m:complex matrix.
  (forall i:int. forall j:int. (valid_index(m, i, j) -> (get(m, i,
  j) = sum(to_indexes(m), fc306(m, i, j))))))

axiom mat_to_indexes_decomp :
  (forall m:complex matrix. (m = indexes_decomp(m)))

function basis_decomp(m: complex matrix) : complex matrix =
  mat_sum(basis_projections(m), identity1)

axiom basis_decompqtspec :
  (forall m:complex matrix. (rows(basis_decomp(m)) = rows(m)))

axiom basis_decompqtspec1 :
  (forall m:complex matrix. (columns(basis_decomp(m)) = columns(m)))

axiom indexes_basis_decomp_equal_pre :
  (forall m:complex matrix. forall i:int. forall j:int. (valid_index(m, i,
  j) -> (get(indexes_decomp(m), i, j) = get(basis_decomp(m), i, j))))

axiom indexes_basis_decomp_equal :
  (forall m:complex matrix. (indexes_decomp(m) = basis_decomp(m)))

axiom mat_to_basis_decomp :
  (forall m:complex matrix. (m = indexes_decomp(m)))

logic fc307 : complex matrix, 'a set,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

logic fc308 : complex matrix,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef308 :
  (forall m:complex matrix. forall s:'a set.
  forall f:('a,complex matrix) farray. forall a1:'a. ((fc307(m, s,
  f)[a1]) = (if mem(a1, s) then mat_mult(m, (f[a1])) else m)))

axiom fcqtdef309 :
  (forall m:complex matrix. forall f:('a,complex matrix) farray.
  forall a1:'a. ((fc308(m, f)[a1]) = mat_mult(m, (f[a1]))))

axiom product_mat_sum_r_pre :
  (forall m:complex matrix. forall sqt:'a set. forall s:'a set.
  forall f:('a,complex matrix) farray. (constant_size(s, f) ->
  ((columns(m) = s_rows(s, f)) -> (subset(sqt, s) -> ((0 <  cardinal(sqt)) ->
  (mat_mult(m, mat_sum(sqt, f)) = mat_sum(sqt, fc307(m, s, f))))))))

axiom product_mat_sum_r_pre1 :
  (forall m:complex matrix. forall sqt:'a set. forall s:'a set.
  forall f:('a,complex matrix) farray. (constant_size(s, f) ->
  ((columns(m) = s_rows(s, f)) -> (subset(sqt, s) -> ((0 <  cardinal(sqt)) ->
  (mat_mult(m, mat_sum(sqt, f)) = mat_sum(sqt, fc308(m, f))))))))

axiom product_mat_sum_r_pre2 :
  (forall m:complex matrix. forall sqt:'a set. forall s:'a set.
  forall f:('a,complex matrix) farray. (constant_size(s, f) ->
  ((columns(m) = s_rows(s, f)) -> (subset(sqt, s) -> ((0 <  cardinal(sqt)) ->
  (rows(mat_sum(sqt, f)) = s_rows(s, f)))))))

axiom product_mat_sum_r_pre3 :
  (forall m:complex matrix. forall sqt:'a set. forall s:'a set.
  forall f:('a,complex matrix) farray. (constant_size(s, f) ->
  ((columns(m) = s_rows(s, f)) -> (subset(sqt, s) -> ((0 <  cardinal(sqt)) ->
  (columns(mat_sum(sqt, f)) = s_columns(s, f)))))))

axiom product_mat_sum_r_pre4 :
  (forall m:complex matrix. forall sqt:'a set. forall s:'a set.
  forall f:('a,complex matrix) farray. (constant_size(s, f) ->
  ((columns(m) = s_rows(s, f)) -> (subset(sqt, s) -> ((0 <  cardinal(sqt)) ->
  (rows(mat_mult(m, mat_sum(sqt, f))) = rows(m)))))))

axiom product_mat_sum_r_pre5 :
  (forall m:complex matrix. forall sqt:'a set. forall s:'a set.
  forall f:('a,complex matrix) farray. (constant_size(s, f) ->
  ((columns(m) = s_rows(s, f)) -> (subset(sqt, s) -> ((0 <  cardinal(sqt)) ->
  (columns(mat_mult(m, mat_sum(sqt, f))) = s_columns(s, f)))))))

logic fc309 : complex matrix,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef310 :
  (forall m:complex matrix. forall f:('a,complex matrix) farray.
  forall a1:'a. ((fc309(m, f)[a1]) = mat_mult(m, (f[a1]))))

axiom product_mat_sum_r :
  (forall m:complex matrix. forall s:'a set.
  forall f:('a,complex matrix) farray. (constant_size(s, f) ->
  ((columns(m) = s_rows(s, f)) -> ((0 <  cardinal(s)) -> (mat_mult(m,
  mat_sum(s, f)) = mat_sum(s, fc309(m, f)))))))

logic fc310 : complex matrix,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef311 :
  (forall m:complex matrix. forall f:('a,complex matrix) farray.
  forall a1:'a. ((fc310(m, f)[a1]) = mat_mult(m, (f[a1]))))

axiom product_mat_sum_r_rev :
  (forall m:complex matrix. forall s:'a set.
  forall f:('a,complex matrix) farray. (constant_size(s, f) ->
  ((columns(m) = s_rows(s, f)) -> ((0 <  cardinal(s)) -> (mat_sum(s, fc310(m,
  f)) = mat_mult(m, mat_sum(s, f)))))))

axiom p_injective_proj :
  (forall m:complex matrix.
  p_injective(((couple_closure : ((int,(int,complex matrix) farray) farray,((int,
  int) tuple2,complex matrix) farray) farray)[(basis_projection_closure[m])]),
  nonn_mat_subset(((couple_closure : ((int,(int,complex matrix) farray) farray,((int,
  int) tuple2,complex matrix) farray) farray)[(basis_projection_closure[m])]),
  to_indexes(m))))

axiom mat_decomp_equal_indexes :
  (forall m:complex matrix. (m = indexes_decomp(m)))

logic ket_basis : int -> complex matrix set

axiom ket_basisqtdef :
  (forall n:int. ((0 <= n) -> (ket_basis(n) = basis_mat(power(2, n), 1))))

logic fc311 : int -> ((int, int) tuple2,complex matrix) farray

axiom fcqtdef312 :
  (forall n:int. forall o:(int, int) tuple2.
  ((fc311(n)[o]) = ind_basis_mat(fir(o), sec(o), power(2, n), 1)))

axiom ket_basisqtspec :
  (forall n:int. ((0 <= n) -> (ket_basis(n) = map(fc311(n),
  cartesian_product(to_fset(0, power(2, n)), to_fset(0, 1))))))

axiom ket_basisqtspec1 :
  (forall n:int. ((0 <= n) -> (ket_basis(n) = basis_mat(power(2, n), 1))))

axiom ket_basisqtspec2 :
  (forall n:int. ((0 <= n) ->
  (forall mat:complex matrix. (mem(mat, ket_basis(n)) ->
  (rows(mat) = power(2, n))))))

axiom ket_basisqtspec3 :
  (forall n:int. ((0 <= n) ->
  (forall mat:complex matrix. (mem(mat, ket_basis(n)) -> (columns(mat) = 1)))))

axiom ket_basisqtspec4 :
  (forall n:int. ((0 <= n) ->
  (forall mat:complex matrix. (mem(mat, ket_basis(n)) ->
  (rows(mat) = power(2, n))))))

axiom ket_basisqtspec5 :
  (forall n:int. ((0 <= n) ->
  (forall mat:complex matrix. (mem(mat, ket_basis(n)) -> (columns(mat) = 1)))))

axiom ket_basisqtspec6 :
  (forall n:int. ((0 <= n) ->
  (forall mat:complex matrix. (mem(mat, ket_basis(n)) ->
  (exists i:int. (valid_index(mat, i, 0) and (basis_mat_indexes(mat) = {
  Tuple2_proj_1 = i; Tuple2_proj_2 = 0 })))))))

logic fc312 : int -> (int,complex matrix) farray

axiom fcqtdef313 :
  (forall n:int. forall i:int. ((fc312(n)[i]) = ind_basis_mat(i, 0, power(2,
  n), 1)))

axiom unary_ket_basis :
  (forall n:int. ((0 <= n) -> (ket_basis(n) = map(fc312(n), to_fset(0,
  power(2, n))))))

axiom to_ket_basis :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> mem(ind_basis_mat(i, 0, power(2, n), 1), ket_basis(n)))))

logic ket_basis_index : complex matrix, int -> int

axiom ket_basis_indexqtdef :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (mem(m,
  ket_basis(n)) -> (ket_basis_index(m, n) = fir(basis_mat_indexes(m))))))

logic fc313 : complex matrix, int -> (int,(int,complex) farray) farray

axiom fcqtdef314 :
  (forall m:complex matrix. forall n:int. forall i:int. forall us:int.
  (((fc313(m, n)[i])[us]) = indic(ket_basis_index(m, n), i)))

axiom ket_basis_indexqtspec :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (mem(m,
  ket_basis(n)) -> mem(ind_basis_mat(ket_basis_index(m, n), 0, power(2, n),
  1), ket_basis(n)))))

axiom ket_basis_indexqtspec1 :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (mem(m,
  ket_basis(n)) -> (m = make_f(rows(m), 1, fc313(m, n))))))

axiom ket_basis_indexqtspec2 :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (mem(m,
  ket_basis(n)) ->
  (forall i:int. (valid_index(m, i, 0) -> ((not (i = ket_basis_index(m,
  n))) -> (get(m, i, 0) = c_zero)))))))

axiom ket_basis_indexqtspec3 :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (mem(m,
  ket_basis(n)) -> valid_index(m, ket_basis_index(m, n), 0))))

logic fc314 : int -> (int,(int,complex) farray) farray

axiom fcqtdef315 :
  (forall i:int. forall i1:int. forall us:int.
  (((fc314(i)[i1])[us]) = indic(i, i1)))

axiom set_ket_basis :
  (forall m:complex matrix. forall n:int. forall i:int. ((0 <= n) ->
  (((0 <= i) and (i <  power(2, n))) -> (mem(m, ket_basis(n)) -> ((get(m, i,
  0) = c_one) -> (ket_basis_index(m, n) = i))))))

axiom set_ket_basis1 :
  (forall m:complex matrix. forall n:int. forall i:int. ((0 <= n) ->
  (((0 <= i) and (i <  power(2, n))) -> (mem(m, ket_basis(n)) -> ((get(m, i,
  0) = c_one) ->
  (forall i1:int. (valid_index(m, i1, 0) -> ((not (i1 = i)) -> (get(m, i1,
  0) = c_zero)))))))))

axiom set_ket_basis2 :
  (forall m:complex matrix. forall n:int. forall i:int. ((0 <= n) ->
  (((0 <= i) and (i <  power(2, n))) -> (mem(m, ket_basis(n)) -> ((get(m, i,
  0) = c_one) -> mem(m, ket_basis(n)))))))

axiom set_ket_basis3 :
  (forall m:complex matrix. forall n:int. forall i:int. ((0 <= n) ->
  (((0 <= i) and (i <  power(2, n))) -> (mem(m, ket_basis(n)) -> ((get(m, i,
  0) = c_one) -> (m = make_f(rows(m), columns(m), fc314(i))))))))

axiom from_ket_basis :
  (forall n:int. forall m:complex matrix. ((0 <= n) -> (mem(m,
  ket_basis(n)) ->
  (exists i:int. (((0 <= i) and (i <  power(2, n))) and (m = ind_basis_mat(i,
  0, power(2, n), 1)))))))

axiom int_to_ket_basis :
  (forall n:int. forall i:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> mem(ket(n, i), ket_basis(n)))))

predicate is_a_ket_basis_elt(m: complex matrix) = (is_a_ket(m) and mem(m,
  ket_basis(ket_length(m))))

axiom ket_basis_elt_are_kets :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) -> is_a_ket(m)))

axiom get_is_a_ket_basis_elt :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) -> is_a_ket(m)))

axiom get_is_a_ket_basis_elt1 :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) -> mem(m,
  ket_basis(ket_length(m)))))

axiom get_is_a_ket_basis_elt2 :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) ->
  (exists i:int. (((0 <= i) and (i <  power(2, ket_length(m)))) and
  (m = ket(ket_length(m), i))))))

axiom get_is_a_ket_basis_elt3 :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) ->
  (exists i:int. (((0 <= i) and (i <  power(2, ket_length(m)))) and ((get(m,
  i, 0) = c_one) and
  (forall j:int. ((((0 <= j) and (j <  power(2, ket_length(m)))) and
  (not (get(m, j, 0) = c_zero))) -> (i = j))))))))

axiom get_is_a_ket_basis_elt4 :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) ->
  (forall i:int. ((((0 <= i) and (i <  power(2, ket_length(m)))) and (get(m,
  i, 0) = c_one)) ->
  (forall j:int. ((((0 <= j) and (j <  power(2, ket_length(m)))) and
  (not (get(m, j, 0) = c_zero))) -> (i = j)))))))

axiom get_is_a_ket_basis_elt_indic :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) ->
  (exists i:int. (((0 <= i) and (i <  power(2, ket_length(m)))) and
  (forall j:int. (((0 <= j) and (j <  power(2, ket_length(m)))) -> (get(m, j,
  0) = indic(i, j))))))))

axiom set_is_a_ket_basis_elt :
  (forall m:complex matrix. (is_a_ket(m) ->
  ((exists i:int. (((0 <= i) and (i <  power(2, ket_length(m)))) and
   (m = ket(ket_length(m), i)))) ->
  is_a_ket_basis_elt(m))))

logic fc315 : int -> (int,(int,complex) farray) farray

axiom fcqtdef316 :
  (forall j:int. forall i:int. forall us:int. (((fc315(j)[i])[us]) = indic(i,
  j)))

axiom set_is_a_ket_basis_elt_exists :
  (forall m:complex matrix. (is_a_ket(m) ->
  ((exists j:int. (((0 <= j) and (j <  power(2, ket_length(m)))) and
   (m = make_f(power(2, ket_length(m)), 1, fc315(j))))) ->
  is_a_ket_basis_elt(m))))

axiom ket_func_sets_ket_basis_elts :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> is_a_ket_basis_elt(ket(n, i)))))

axiom ket_func_sets_ket_basis_elts1 :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (ket_length(ket(n, i)) = n))))

axiom kronecker_is_a_ket_basis_elt :
  (forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  is_a_ket_basis_elt(kronecker(x, y)))))

axiom ket_is_a_ket_basis_elt :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> is_a_ket_basis_elt(ket(n, i)))))

axiom ket_basis_non_null_val :
  (forall m:complex matrix. forall n:int. forall i:int. ((0 <= n) ->
  (((0 <= i) and (i <  power(2, n))) -> (is_a_ket_basis_elt(m) ->
  ((ket_length(m) = n) -> ((not (get(m, i, 0) = c_zero)) -> (m = ket(n,
  i))))))))

logic ket_to_int : complex matrix -> int

axiom ket_to_intqtspec :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) -> (0 <= ket_to_int(m))))

axiom ket_to_intqtspec1 :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) ->
  (ket_to_int(m) <  power(2, ket_length(m)))))

axiom ket_to_intqtspec2 :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) -> (get(m, ket_to_int(m),
  0) = c_one)))

axiom ket_to_intqtspec3 :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) -> (m = ket(ket_length(m),
  ket_to_int(m)))))

axiom ket_to_intqtspec4 :
  (forall m:complex matrix. (is_a_ket_basis_elt(m) ->
  (forall i:int. (((0 <= i) and (i <  power(2, ket_length(m)))) ->
  ((m = ket(ket_length(m), i)) -> (i = ket_to_int(m)))))))

axiom ket_to_int_ket :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (ket_to_int(ket(n, i)) = i))))

axiom equal_ket_by_int :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  (is_a_ket_l(m, l) -> (is_a_ket_l(n, l) -> (is_a_ket_basis_elt(n) ->
  (is_a_ket_basis_elt(m) -> ((ket_to_int(m) = ket_to_int(n)) -> (m = n)))))))

logic bin_to_ket : int, (int,int) farray -> complex matrix

axiom bin_to_ketqtdef :
  (forall n:int. forall bvx:(int,int) farray. ((0 <= n) -> (binary(bvx) ->
  (bin_to_ket(n, bvx) = ket(n, bin_to_int(bvx, n))))))

axiom bin_to_ketqtspec :
  (forall n:int. forall bvx:(int,int) farray. ((0 <= n) -> (binary(bvx) ->
  is_a_ket_basis_elt(bin_to_ket(n, bvx)))))

axiom bin_to_ketqtspec1 :
  (forall n:int. forall bvx:(int,int) farray. ((0 <= n) -> (binary(bvx) ->
  (ket_length(bin_to_ket(n, bvx)) = n))))

axiom bin_to_ketqtspec2 :
  (forall n:int. forall bvx:(int,int) farray. ((0 <= n) -> (binary(bvx) ->
  (ket_to_int(bin_to_ket(n, bvx)) = bin_to_int(bvx, n)))))

axiom bin_to_ketqtspec3 :
  (forall n:int. forall bvx:(int,int) farray. ((0 <= n) -> (binary(bvx) ->
  (rows(bin_to_ket(n, bvx)) = power(2, n)))))

axiom bin_to_ketqtspec4 :
  (forall n:int. forall bvx:(int,int) farray. ((0 <= n) -> (binary(bvx) ->
  (columns(bin_to_ket(n, bvx)) = 1))))

axiom bin_to_ketqtspec5 :
  (forall n:int. forall bvx:(int,int) farray. ((0 <= n) -> (binary(bvx) ->
  is_a_ket(bin_to_ket(n, bvx)))))

axiom bin_to_ketqtspec6 :
  (forall n:int. forall bvx:(int,int) farray. ((0 <= n) -> (binary(bvx) ->
  is_a_ket_l(bin_to_ket(n, bvx), n))))

axiom bin_to_ket_l :
  (forall n:int. forall nqt:int. forall bvx:(int,int) farray. ((0 <= n) ->
  ((n = nqt) -> (binary(bvx) -> is_a_ket_l(bin_to_ket(n, bvx), nqt)))))

axiom bin_to_ket_eq :
  (forall n1:int. forall n2:int. forall bvx1:(int,int) farray.
  forall bvx2:(int,int) farray. ((0 <= n1) -> (binary(bvx1) ->
  (binary(bvx2) -> ((n2 = n1) ->
  ((forall i:int. (((0 <= i) and (i <  n1)) -> ((bvx1[i]) = (bvx2[i])))) ->
  (bin_to_ket(n1, bvx1) = bin_to_ket(n2, bvx2))))))))

axiom kronecker_kets_bin_to_ket :
  (forall f1:(int,int) farray. forall f2:(int,int) farray. forall n1:int.
  forall n2:int. (binary(f1) -> (binary(f2) -> ((0 <= n1) -> ((0 <= n2) ->
  (kronecker(bin_to_ket(n1, f1), bin_to_ket(n2, f2)) = bin_to_ket((n1 + n2),
  ((((concat_fun_closure : ((int,int) farray,((int,int) farray,(int,(int,int) farray) farray) farray) farray)[f1])[f2])[n1]))))))))

axiom kronecker_ket_to_int :
  (forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  is_a_ket_basis_elt(kronecker(x, y)))))

axiom kronecker_ket_to_int1 :
  (forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (ket_length(kronecker(x, y)) = (ket_length(x) + ket_length(y))))))

axiom kronecker_ket_to_int2 :
  (forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) -> (kronecker(x,
  y) = ket((ket_length(x) + ket_length(y)), ((ket_to_int(x) * power(2,
  ket_length(y))) + ket_to_int(y)))))))

axiom kronecker_ket_to_int3 :
  (forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (ket_to_int(kronecker(x, y)) = ((ket_to_int(x) * power(2,
  ket_length(y))) + ket_to_int(y))))))

axiom ket_ket_to_int :
  (forall x:complex matrix. (is_a_ket_basis_elt(x) -> (ket(ket_length(x),
  ket_to_int(x)) = x)))

axiom ket_ket_to_int_values :
  (forall x:complex matrix. (is_a_ket_basis_elt(x) ->
  (forall i:int. forall j:int. (valid_index(x, i, j) -> (get(x, i,
  j) = indic(i, ket_to_int(x)))))))

logic ket_basis_projection : complex matrix, int -> complex matrix

axiom ket_basis_projectionqtdef :
  (forall m:complex matrix. forall j:int. (is_a_ket(m) -> (((0 <= j) and
  (j <  power(2, ket_length(m)))) -> (ket_basis_projection(m,
  j) = infix_asdtdt(get(m, j, 0), ket(ket_length(m), j))))))

axiom ket_basis_projectionqtspec :
  (forall m:complex matrix. forall j:int. (is_a_ket(m) -> (((0 <= j) and
  (j <  power(2, ket_length(m)))) -> (ket_basis_projection(m,
  j) = basis_projection(m, j, 0)))))

axiom ket_basis_projection_columns :
  (forall m:complex matrix. forall j:int. (is_a_ket(m) -> (((0 <= j) and
  (j <  power(2, ket_length(m)))) -> (columns(ket_basis_projection(m,
  j)) = 1))))

axiom ket_basis_projection_rows :
  (forall m:complex matrix. forall j:int. (is_a_ket(m) -> (((0 <= j) and
  (j <  power(2, ket_length(m)))) -> (rows(ket_basis_projection(m,
  j)) = rows(m)))))

logic ket_basis_projections : complex matrix -> complex matrix set

logic result38 : complex matrix -> (int,complex matrix) farray

axiom resultqtdef45 :
  (forall m:complex matrix. forall j:int. ((result38(m)[j]) = (if mem(j,
  to_fset(0, power(2, ket_length(m)))) then ket_basis_projection(m,
  j) else m)))

axiom ket_basis_projectionsqtdef :
  (forall m:complex matrix. (is_a_ket(m) ->
  (ket_basis_projections(m) = map(result38(m), to_fset(0, power(2,
  ket_length(m)))))))

axiom ket_basis_projectionsqtspec :
  (forall m:complex matrix. (is_a_ket(m) ->
  (ket_basis_projections(m) = basis_projections(m))))

logic ket_basis_projections_antec : complex matrix -> unit

axiom ket_basis_projections_antecqtdef :
  (forall m:complex matrix. (is_a_ket(m) ->
  (ket_basis_projections_antec(m) = void)))

axiom ket_basis_projections_antecqtspec :
  (forall m:complex matrix. (is_a_ket(m) ->
  (forall e:complex matrix. (mem(e, ket_basis_projections(m)) ->
  (exists j:int. (((0 <= j) and (j <  power(2, ket_length(m)))) and
  (e = ket_basis_projection(m, j))))))))

axiom ket_basis_projections_antecqtspec1 :
  (forall m:complex matrix. (is_a_ket(m) ->
  (forall e:complex matrix.
  ((exists j:int. (((0 <= j) and (j <  power(2, ket_length(m)))) and
   (e = ket_basis_projection(m, j)))) ->
  mem(e, ket_basis_projections(m))))))

axiom ket_basis_projections_antecqtspec2 :
  (forall m:complex matrix. (is_a_ket(m) ->
  (forall e:complex matrix. (mem(e, ket_basis_projections(m)) ->
  (exists j:int. exists i:int. (valid_index(m, j, i) and
  (e = basis_projection(m, j, i))))))))

axiom ket_basis_projections_antecqtspec3 :
  (forall m:complex matrix. (is_a_ket(m) ->
  (forall e:complex matrix.
  ((exists j:int. exists i:int. (valid_index(m, j, i) and
   (e = basis_projection(m, j, i)))) ->
  mem(e, ket_basis_projections(m))))))

logic ket_sum : 'a set, ('a,complex matrix) farray -> complex matrix

axiom ket_sumqtdef :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((0 <  cardinal(s)) -> ((forall e:'a. (mem(e, s) -> is_a_ket((f[e])))) ->
  ((exists l:int. (forall e:'a. (mem(e, s) -> (ket_length((f[e])) = l)))) ->
  (ket_sum(s, f) = mat_sum(s, f))))))

logic fc316 : ('a,complex matrix) farray, int -> ('a,complex) farray

axiom fcqtdef317 :
  (forall f:('a,complex matrix) farray. forall i:int. forall e:'a. ((fc316(f,
  i)[e]) = get((f[e]), i, 0)))

axiom ket_sumqtspec :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((0 <  cardinal(s)) -> ((forall e:'a. (mem(e, s) -> is_a_ket((f[e])))) ->
  ((exists l:int. (forall e:'a. (mem(e, s) -> (ket_length((f[e])) = l)))) ->
  (forall i:int. (valid_index(ket_sum(s, f), i, 0) -> (get(ket_sum(s, f), i,
  0) = sum(s, fc316(f, i)))))))))

axiom ket_sumqtspec1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((0 <  cardinal(s)) -> ((forall e:'a. (mem(e, s) -> is_a_ket((f[e])))) ->
  ((exists l:int. (forall e:'a. (mem(e, s) -> (ket_length((f[e])) = l)))) ->
  is_a_ket(ket_sum(s, f))))))

axiom ket_sumqtspec2 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  ((0 <  cardinal(s)) -> ((forall e:'a. (mem(e, s) -> is_a_ket((f[e])))) ->
  ((exists l:int. (forall e:'a. (mem(e, s) -> (ket_length((f[e])) = l)))) ->
  (forall e:'a. (mem(e, s) -> (ket_length(ket_sum(s,
  f)) = ket_length((f[e])))))))))

logic ket_sum_l : 'a set, ('a,complex matrix) farray, int -> complex matrix

logic result39 : (int,complex) farray

logic fc317 : (complex matrix,(int,complex) farray) farray

logic fc318 : (complex matrix,(int,complex) farray) farray

axiom resultqtdef46 : (forall us:int. ((result39[us]) = c_zero))

axiom fcqtdef318 :
  (forall y0:complex matrix. forall y1:int. (((fc317[y0])[y1]) = get(y0, y1,
  0)))

axiom fcqtdef319 :
  (forall y0:complex matrix. forall y1:int. (((fc318[y0])[y1]) = get(y0, y1,
  0)))

axiom ket_sum_lqtdef :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((cardinal(s) = 0) -> (ket_sum_l(s, f, l) = make_ket(l,
  result39)))))

axiom ket_sum_lqtdef1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((not (cardinal(s) = 0)) -> ((cardinal(s) = 1) ->
  (ket_sum_l(s, f, l) = make_ket(l, (fc317[(f[choose(s)])])))))))

axiom ket_sum_lqtdef2 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((not (cardinal(s) = 0)) -> ((not (cardinal(s) = 1)) ->
  (ket_sum_l(s, f, l) = add_ket(ket_sum_l(remove(choose(s), s), f, l),
  make_ket(l, (fc318[(f[choose(s)])]))))))))

logic fc319 : ('a,complex matrix) farray, 'a -> (int,complex) farray

logic fc320 : ('a,complex matrix) farray, int -> ('a,complex matrix) farray

logic fc321 : ('a,complex matrix) farray, int -> ('a,complex) farray

axiom fcqtdef320 :
  (forall f:('a,complex matrix) farray. forall i:'a. forall j:int. ((fc319(f,
  i)[j]) = get((f[i]), j, 0)))

axiom fcqtdef321 :
  (forall f:('a,complex matrix) farray. forall l:int. forall i:'a. ((fc320(f,
  l)[i]) = make_ket(l, fc319(f, i))))

axiom fcqtdef322 :
  (forall f:('a,complex matrix) farray. forall i:int. forall e:'a. ((fc321(f,
  i)[e]) = get((f[e]), i, 0)))

axiom ket_sum_lqtspec :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((0 <  cardinal(s)) -> (ket_sum_l(s, f, l) = mat_sum(s,
  fc320(f, l))))))

axiom ket_sum_lqtspec1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> is_a_ket(ket_sum_l(s, f, l))))

axiom ket_sum_lqtspec2 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) ->
  (forall i:int. (valid_index(ket_sum_l(s, f, l), i, 0) -> (get(ket_sum_l(s,
  f, l), i, 0) = sum(s, fc321(f, i)))))))

axiom ket_sum_lqtspec3 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> is_a_ket_l(ket_sum_l(s, f, l), l)))

axiom ket_sum_lqtspec4 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((0 <  cardinal(s)) ->
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l))) -> (ket_sum_l(s, f,
  l) = mat_sum(s, f))))))

axiom ket_sum_lqtspec5 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> (ket_length(ket_sum_l(s, f, l)) = l)))

logic fc322 : ('a,complex matrix) farray, 'a -> (int,complex) farray

logic fc323 : ('a,complex matrix) farray, int -> ('a,complex matrix) farray

axiom fcqtdef323 :
  (forall f:('a,complex matrix) farray. forall i:'a. forall j:int. ((fc322(f,
  i)[j]) = get((f[i]), j, 0)))

axiom fcqtdef324 :
  (forall f:('a,complex matrix) farray. forall l:int. forall i:'a. ((fc323(f,
  l)[i]) = make_ket(l, fc322(f, i))))

axiom ket_sum_l_to_mat_sum :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((0 <  cardinal(s)) -> (ket_sum_l(s, f, l) = mat_sum(s,
  fc323(f, l))))))

axiom ket_sum_l_rows :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((0 <  cardinal(s)) -> (rows(ket_sum_l(s, f, l)) = power(2,
  l)))))

logic fc324 : ('a,complex matrix) farray, int -> ('a,complex) farray

axiom fcqtdef325 :
  (forall f:('a,complex matrix) farray. forall i:int. forall e:'a. ((fc324(f,
  i)[e]) = get((f[e]), i, 0)))

axiom ket_sum_l_value :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  forall i:int. forall j:int. ((0 <= l) -> (((0 <= i) and (i <  power(2,
  l))) -> ((j = 0) -> (get(ket_sum_l(s, f, l), i, j) = sum(s, fc324(f,
  i)))))))

logic fc325 : ('a,complex matrix) farray, int -> ('a,complex) farray

axiom fcqtdef326 :
  (forall f:('a,complex matrix) farray. forall i:int. forall e:'a. ((fc325(f,
  i)[e]) = get((f[e]), i, 0)))

axiom get_ket_sum_l_value :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  forall i:int. ((0 <= l) -> (((0 <= i) and (i <  power(2, l))) ->
  (get(ket_sum_l(s, f, l), i, 0) = sum(s, fc325(f, i))))))

axiom ket_sum_l_columns :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> (columns(ket_sum_l(s, f, l)) = 1)))

axiom ket_sum_null_but_maybe_one_elt :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall e:'a.
  ((1 <  cardinal(s)) ->
  ((forall e1:'a. (mem(e1, s) -> is_a_ket((f[e1])))) -> (constant_size(s,
  f) -> (mem(e, s) ->
  ((forall eqt:'a. (mem(eqt, s) -> ((not (e = eqt)) -> null_mat((f[eqt]))))) ->
  (ket_sum(s, f) = (f[e]))))))))

axiom ket_sum_null :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((1 <  cardinal(s)) -> ((0 <= l) ->
  ((forall e:'a. (mem(e, s) ->
   (forall i:int. (((0 <= i) and (i <  power(2, l))) -> (get((f[e]), i,
   0) = c_zero))))) ->
  (forall j:int. (((0 <= j) and (j <  power(2, l))) -> (get(ket_sum_l(s, f,
  l), j, 0) = c_zero)))))))

logic fc326 : (complex matrix,(int,complex) farray) farray

axiom fcqtdef327 :
  (forall y0:complex matrix. forall y1:int. (((fc326[y0])[y1]) = get(y0, y1,
  0)))

axiom ket_sum_l_null_but_maybe_one_elt :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall e:'a.
  forall l:int. ((0 <= l) -> ((1 <  cardinal(s)) -> (mem(e, s) ->
  ((forall eqt:'a. (mem(eqt, s) -> ((not (eqt = e)) ->
   (forall i:int. (((0 <= i) and (i <  power(2, l))) -> (get((f[eqt]), i,
   0) = c_zero)))))) ->
  (ket_sum_l(s, f, l) = make_ket(l, (fc326[(f[e])]))))))))

axiom ket_sum_l_null_but_maybe_one_elt_ :
  (forall f:('a,complex matrix) farray. forall s:'a set. forall e:'a.
  forall l:int. ((0 <= l) -> ((1 <  cardinal(s)) -> (mem(e, s) ->
  ((forall eqt:'a. (mem(eqt, s) -> is_a_ket_l((f[eqt]), l))) ->
  ((forall eqt:'a. (mem(eqt, s) -> ((not (eqt = e)) ->
   (forall i:int. (((0 <= i) and (i <  power(2, l))) -> (get((f[eqt]), i,
   0) = c_zero)))))) ->
  (ket_sum_l(s, f, l) = (f[e]))))))))

axiom ket_sum_ket_l :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> is_a_ket_l(ket_sum_l(s, f, l), l)))

axiom ket_sum_ket_l_ :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  forall lqt:int. ((0 <= l) -> ((l = lqt) -> is_a_ket_l(ket_sum_l(s, f, l),
  lqt))))

axiom add_ket_l_eq1 :
  (forall m:complex matrix. forall o:complex matrix.
  forall mqt:complex matrix. forall oqt:complex matrix. forall l:int.
  ((0 <= l) -> ((m = mqt) -> ((o = oqt) -> (add_ket_l(m, o,
  l) = add_ket_l(mqt, oqt, l))))))

axiom add_ket_l_eq_scal :
  (forall m:complex matrix. forall o:complex matrix.
  forall mqt:complex matrix. forall oqt:complex matrix. forall a:complex.
  forall b:complex. forall aqt:complex. forall bqt:complex. forall l:int.
  ((0 <= l) -> ((m = mqt) -> ((o = oqt) -> ((a = aqt) -> ((b = bqt) ->
  (add_ket_l(infix_asdtdt(a, m), infix_asdtdt(b, o),
  l) = add_ket_l(infix_asdtdt(aqt, mqt), infix_asdtdt(bqt, oqt), l))))))))

axiom add_ket_l_scal :
  (forall x:complex matrix. forall y:complex matrix. forall a:complex.
  forall l:int. (is_a_ket_l(x, l) -> (is_a_ket_l(y, l) ->
  (add_ket_l(infix_asdtdt(a, x), infix_asdtdt(a, y), l) = infix_asdtdt(a,
  add_ket_l(x, y, l))))))

axiom add_ket_l_scal_rev :
  (forall x:complex matrix. forall y:complex matrix. forall a:complex.
  forall l:int. (is_a_ket_l(x, l) -> (is_a_ket_l(y, l) -> (infix_asdtdt(a,
  add_ket_l(x, y, l)) = add_ket_l(infix_asdtdt(a, x), infix_asdtdt(a, y),
  l)))))

axiom get_ket_scalar :
  (forall x:complex matrix. forall a:complex. forall i:int.
  (get(infix_asdtdt(a, x), i, 0) = infix_asdt(a, get(x, i, 0))))

axiom scal_add_scal_ket_l :
  (forall g:complex. forall a:complex. forall x:complex matrix.
  forall aqt:complex. forall xqt:complex matrix. forall n:int. ((0 <= n) ->
  (infix_asdtdt(g, add_ket_l(infix_asdtdt(a, x), infix_asdtdt(aqt, xqt),
  n)) = add_ket_l(infix_asdtdt(infix_asdt(g, a), x),
  infix_asdtdt(infix_asdt(g, aqt), xqt), n))))

axiom add_ket_l_switch :
  (forall a:complex matrix. forall b:complex matrix. forall c:complex matrix.
  forall d:complex matrix. forall n:int. ((0 <= n) -> (add_ket_l(add_ket_l(a,
  b, n), add_ket_l(c, d, n), n) = add_ket_l(add_ket_l(a, c, n), add_ket_l(b,
  d, n), n))))

axiom add_ket_scal_fact :
  (forall a:complex matrix. forall n:int. forall s:complex.
  forall sqt:complex. (is_a_ket_l(a, n) -> ((0 <= n) ->
  (add_ket_l(infix_asdtdt(s, a), infix_asdtdt(sqt, a),
  n) = infix_asdtdt(infix_pldt(s, sqt), a)))))

logic fc327 : ('b,complex matrix) farray, ('b,complex matrix) farray,
  int -> ('b,complex matrix) farray

axiom fcqtdef328 :
  (forall f:('b,complex matrix) farray. forall g:('b,complex matrix) farray.
  forall l:int. forall k:'b. ((fc327(f, g, l)[k]) = add_ket_l((f[k]), (g[k]),
  l)))

axiom ket_sum_comp_l :
  (forall s:'b set. forall f:('b,complex matrix) farray.
  forall g:('b,complex matrix) farray. forall l:int. ((0 <= l) ->
  (ket_sum_l(s, fc327(f, g, l), l) = add_ket_l(ket_sum_l(s, f, l),
  ket_sum_l(s, g, l), l))))

logic fc328 : ('b,complex matrix) farray, ('b,complex matrix) farray,
  int -> ('b,complex matrix) farray

axiom fcqtdef329 :
  (forall f:('b,complex matrix) farray. forall g:('b,complex matrix) farray.
  forall l:int. forall k:'b. ((fc328(f, g, l)[k]) = add_ket_l((f[k]), (g[k]),
  l)))

axiom ket_sum_comp_l_rev :
  (forall s:'b set. forall f:('b,complex matrix) farray.
  forall g:('b,complex matrix) farray. forall l:int. ((0 <= l) ->
  (add_ket_l(ket_sum_l(s, f, l), ket_sum_l(s, g, l), l) = ket_sum_l(s,
  fc328(f, g, l), l))))

logic fc329 : ('a,complex matrix) farray,
  complex -> ('a,complex matrix) farray

axiom fcqtdef330 :
  (forall f:('a,complex matrix) farray. forall a1:complex. forall k:'a.
  ((fc329(f, a1)[k]) = infix_asdtdt(a1, (f[k]))))

axiom ket_sum_scalar_l :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall a1:complex.
  forall l:int. ((0 <= l) -> (ket_sum_l(s, fc329(f, a1),
  l) = infix_asdtdt(a1, ket_sum_l(s, f, l)))))

axiom ket_l_ket_sum_scalar :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall a1:complex.
  forall l:int. forall n:int. ((0 <= l) -> ((l = n) ->
  is_a_ket_l(infix_asdtdt(a1, ket_sum_l(s, f, l)), n))))

axiom scal_ket_sum_scalar_l :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall b:complex.
  forall l:int. forall lqt:int. ((0 <= l) -> ((l = lqt) ->
  is_a_ket_l(infix_asdtdt(b, ket_sum_l(s, f, l)), lqt))))

logic fc330 : ('a,complex matrix) farray,
  complex -> ('a,complex matrix) farray

axiom fcqtdef331 :
  (forall f:('a,complex matrix) farray. forall a1:complex. forall k:'a.
  ((fc330(f, a1)[k]) = infix_asdtdt(a1, (f[k]))))

axiom ket_sum_scalar_rev_l :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall a1:complex.
  forall l:int. ((0 <= l) -> (infix_asdtdt(a1, ket_sum_l(s, f,
  l)) = ket_sum_l(s, fc330(f, a1), l))))

axiom ket_sum_eq :
  (forall s:'a set. forall sqt:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall l:int. ((0 <= l) ->
  ((s = sqt) -> ((forall a1:'a. (mem(a1, s) -> ((f[a1]) = (g[a1])))) ->
  (ket_sum_l(s, f, l) = ket_sum_l(sqt, g, l))))))

axiom ket_sum_eq_gen :
  (forall s:'a set. forall sqt:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall l1:int. forall l2:int.
  ((0 <= l1) -> ((s = sqt) -> ((l1 = l2) ->
  ((forall a1:'a. (mem(a1, s) -> ((f[a1]) = (g[a1])))) -> (ket_sum_l(s, f,
  l1) = ket_sum_l(sqt, g, l2)))))))

logic fc331 : ('a,complex matrix) farray, int -> ('a,complex) farray

logic fc332 : ('a,complex matrix) farray, int -> ('a,complex) farray

axiom fcqtdef332 :
  (forall f:('a,complex matrix) farray. forall i:int. forall e:'a. ((fc331(f,
  i)[e]) = get((f[e]), i, 0)))

axiom fcqtdef333 :
  (forall g:('a,complex matrix) farray. forall i:int. forall e:'a. ((fc332(g,
  i)[e]) = get((g[e]), i, 0)))

axiom ket_sum_eq_by_sum :
  (forall s:'a set. forall sqt:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall l1:int. forall l2:int.
  ((0 <= l1) -> ((s = sqt) -> ((l1 = l2) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, l1))) -> (sum(s, fc331(f,
   i)) = sum(s, fc332(g, i))))) ->
  (ket_sum_l(s, f, l1) = ket_sum_l(sqt, g, l2)))))))

axiom ket_sum_bvs_eq :
  (forall n1:int. forall n2:int. forall f:(bitvec,complex matrix) farray.
  forall g:(bitvec,complex matrix) farray. forall l1:int. forall l2:int.
  ((0 <= l1) -> ((l1 = l2) -> ((n1 = n2) -> ((0 <= n1) ->
  ((forall e:bitvec. (mem(e, n_bvs(n1)) -> ((f[e]) = (g[e])))) ->
  (ket_sum_l(n_bvs(n1), f, l1) = ket_sum_l(n_bvs(n2), g, l2))))))))

axiom ket_sum_scal_bvs_eq :
  (forall n1:int. forall n2:int. forall f:(bitvec,complex matrix) farray.
  forall g:(bitvec,complex matrix) farray. forall l1:int. forall l2:int.
  forall s1:complex. forall s2:complex. ((0 <= l1) -> ((l1 = l2) ->
  ((n1 = n2) -> ((s1 = s2) -> ((0 <= n1) ->
  ((forall e:bitvec. (mem(e, n_bvs(n1)) -> ((f[e]) = (g[e])))) ->
  (infix_asdtdt(s1, ket_sum_l(n_bvs(n1), f, l1)) = infix_asdtdt(s2,
  ket_sum_l(n_bvs(n2), g, l2))))))))))

logic fc333 : int, (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

logic fc334 : int, (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef334 :
  (forall n2:int. forall f:(bitvec,(bitvec,complex matrix) farray) farray.
  forall l1:int. forall k:bitvec. ((fc333(n2, f,
  l1)[k]) = ket_sum_l(n_bvs(n2), (f[k]), l1)))

axiom fcqtdef335 :
  (forall n2qt:int. forall g:(bitvec,(bitvec,complex matrix) farray) farray.
  forall l1qt:int. forall k:bitvec. ((fc334(n2qt, g,
  l1qt)[k]) = ket_sum_l(n_bvs(n2qt), (g[k]), l1qt)))

axiom ket_sum_sum_bvs_eq :
  (forall n1:int. forall n2:int. forall n1qt:int. forall n2qt:int.
  forall f:(bitvec,(bitvec,complex matrix) farray) farray.
  forall g:(bitvec,(bitvec,complex matrix) farray) farray. forall l1:int.
  forall l2:int. forall l1qt:int. forall l2qt:int. ((0 <= l1) ->
  (((l1 = l2) and ((l2 = l1qt) and (l1qt = l2qt))) -> ((n1 = n1qt) ->
  ((0 <= n1) -> ((n2 = n2qt) -> ((0 <= n2) ->
  ((forall e:bitvec. forall eqt:bitvec. (mem(e, n_bvs(n1)) -> (mem(eqt,
   n_bvs(n2)) -> (((f[e])[eqt]) = ((g[e])[eqt]))))) ->
  (ket_sum_l(n_bvs(n1), fc333(n2, f, l1), l2) = ket_sum_l(n_bvs(n1qt),
  fc334(n2qt, g, l1qt), l2qt))))))))))

logic fc335 : int, (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

logic fc336 : int, (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef336 :
  (forall n2:int. forall f:(bitvec,(bitvec,complex matrix) farray) farray.
  forall l1:int. forall k:bitvec. ((fc335(n2, f,
  l1)[k]) = ket_sum_l(n_bvs(n2), (f[k]), l1)))

axiom fcqtdef337 :
  (forall n2qt:int. forall g:(bitvec,(bitvec,complex matrix) farray) farray.
  forall l1qt:int. forall k:bitvec. ((fc336(n2qt, g,
  l1qt)[k]) = ket_sum_l(n_bvs(n2qt), (g[k]), l1qt)))

axiom ket_sum_sum_scal_bvs_eq :
  (forall n1:int. forall n2:int. forall n1qt:int. forall n2qt:int.
  forall f:(bitvec,(bitvec,complex matrix) farray) farray.
  forall g:(bitvec,(bitvec,complex matrix) farray) farray. forall l1:int.
  forall l2:int. forall l1qt:int. forall l2qt:int. forall s1:complex.
  forall s2:complex. ((0 <= l1) -> (((l1 = l2) and ((l2 = l1qt) and
  (l1qt = l2qt))) -> ((n1 = n1qt) -> ((0 <= n1) -> ((n2 = n2qt) ->
  ((s1 = s2) -> ((0 <= n2) ->
  ((forall e:bitvec. forall eqt:bitvec. (mem(e, n_bvs(n1)) -> (mem(eqt,
   n_bvs(n2)) -> (((f[e])[eqt]) = ((g[e])[eqt]))))) ->
  (infix_asdtdt(s1, ket_sum_l(n_bvs(n1), fc335(n2, f, l1),
  l2)) = infix_asdtdt(s1, ket_sum_l(n_bvs(n1qt), fc336(n2qt, g, l1qt),
  l2qt))))))))))))

logic fc337 : int, (bitvec,(bitvec,complex matrix) farray) farray, int,
  complex -> (bitvec,complex matrix) farray

logic fc338 : int, (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef338 :
  (forall n2qt:int. forall f:(bitvec,(bitvec,complex matrix) farray) farray.
  forall l1qt:int. forall s2:complex. forall k:bitvec. ((fc337(n2qt, f, l1qt,
  s2)[k]) = infix_asdtdt(s2, ket_sum_l(n_bvs(n2qt), (f[k]), l1qt))))

axiom fcqtdef339 :
  (forall n2:int. forall g:(bitvec,(bitvec,complex matrix) farray) farray.
  forall l1:int. forall k:bitvec. ((fc338(n2, g,
  l1)[k]) = ket_sum_l(n_bvs(n2), (g[k]), l1)))

axiom ket_sum_sum_scal_mult_bvs_eq :
  (forall n1:int. forall n2:int. forall n1qt:int. forall n2qt:int.
  forall f:(bitvec,(bitvec,complex matrix) farray) farray.
  forall g:(bitvec,(bitvec,complex matrix) farray) farray. forall l1:int.
  forall l2:int. forall l1qt:int. forall l2qt:int. forall s1:complex.
  forall s2:complex. forall s3:complex. ((0 <= l1) -> (((l1 = l2) and
  ((l2 = l1qt) and (l1qt = l2qt))) -> ((n1 = n1qt) -> ((0 <= n1) ->
  ((s3 = infix_asdt(s1, s2)) -> ((n2 = n2qt) -> ((0 <= n2) ->
  ((forall e:bitvec. forall eqt:bitvec. (mem(e, n_bvs(n1)) -> (mem(eqt,
   n_bvs(n2)) -> (((f[e])[eqt]) = ((g[e])[eqt]))))) ->
  (infix_asdtdt(s1, ket_sum_l(n_bvs(n1qt), fc337(n2qt, f, l1qt, s2),
  l2qt)) = infix_asdtdt(s3, ket_sum_l(n_bvs(n1), fc338(n2, g, l1),
  l2))))))))))))

axiom ket_sum_l_cardone :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((cardinal(s) = 1) -> (is_a_ket_l((f[choose(s)]), l) ->
  (ket_sum_l(s, f, l) = (f[choose(s)]))))))

logic fc339 : (int,complex) farray

axiom fcqtdef340 : (forall us:int. ((fc339[us]) = c_zero))

axiom ket_sum_l_empty :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((cardinal(s) = 0) -> (ket_sum_l(s, f, l) = make_ket(l,
  fc339)))))

logic fc340 : (complex matrix,(int,complex) farray) farray

axiom fcqtdef341 :
  (forall y0:complex matrix. forall y1:int. (((fc340[y0])[y1]) = get(y0, y1,
  0)))

axiom ket_sum_l_cardone_ :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((cardinal(s) = 1) -> (ket_sum_l(s, f, l) = make_ket(l,
  (fc340[(f[choose(s)])]))))))

axiom ket_sum_l_plus_one :
  (forall s:'a set. forall e:'a. forall f:('a,complex matrix) farray.
  forall l:int. ((0 <= l) -> ((0 <  cardinal(s)) -> ((not mem(e, s)) ->
  (ket_sum_l(add(e, s), f, l) = add_ket_l(ket_sum_l(s, f, l), (f[e]), l))))))

logic fc341 : (bitvec,complex matrix) farray -> (bitvec,complex matrix) farray

logic fc342 : (bitvec,complex matrix) farray -> (bitvec,complex matrix) farray

axiom fcqtdef342 :
  (forall f:(bitvec,complex matrix) farray. forall bv:bitvec.
  ((fc341(f)[bv]) = (f[concat_l(bv, 0)])))

axiom fcqtdef343 :
  (forall f:(bitvec,complex matrix) farray. forall bv:bitvec.
  ((fc342(f)[bv]) = (f[concat_l(bv, 1)])))

axiom ket_sum_n_bvs_pos :
  (forall n:int. forall f:(bitvec,complex matrix) farray. forall l:int.
  ((0 <= l) -> ((0 <  n) -> (ket_sum_l(n_bvs(n), f,
  l) = add_ket_l(ket_sum_l(n_bvs((n - 1)), fc341(f), l),
  ket_sum_l(n_bvs((n - 1)), fc342(f), l), l)))))

axiom ket_sum_bitvec_one :
  (forall f:(bitvec,complex matrix) farray. forall l:int. ((0 <= l) ->
  (ket_sum_l(n_bvs(1), f, l) = add_ket_l((f[int_to_bv(0, 1)]),
  (f[int_to_bv(1, 1)]), l))))

axiom ket_sum_bitvec_zero :
  (forall f:(bitvec,complex matrix) farray. forall l:int. forall m:int.
  ((0 <= l) -> ((m = 0) -> (is_a_ket_l((f[int_to_bv(0, 0)]), l) ->
  (ket_sum_l(n_bvs(m), f, l) = (f[int_to_bv(0, 0)]))))))

axiom ket_sum_l_valid_index :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall l:int.
  forall i:int. ((0 <= l) -> ((0 <  cardinal(s)) -> (((0 <= i) and
  (i <  power(1, l))) -> valid_index(ket_sum_l(s, f, l), i, 0)))))

logic fc343 : complex matrix -> ('a,complex matrix) farray

axiom fcqtdef344 :
  (forall x:complex matrix. forall us:'a.
  (((fc343(x) : ('a,complex matrix) farray)[us]) = x))

axiom ket_sum_const :
  (forall s:'a set. forall x:complex matrix. forall l:int. ((0 <= l) ->
  (is_a_ket_l(x, l) -> (ket_sum_l(s, (fc343(x) : ('a,complex matrix) farray),
  l) = infix_asdtdt(i_to_c(cardinal(s)), x)))))

logic fc344 : complex matrix -> ('a,complex matrix) farray

axiom fcqtdef345 :
  (forall x:complex matrix. forall us:'a.
  (((fc344(x) : ('a,complex matrix) farray)[us]) = x))

axiom ket_sum_const_w :
  (forall s:'a set. forall x:complex matrix. forall l:int. ((0 <= l) ->
  ((0 <  cardinal(s)) -> (is_a_ket_l(x, l) -> (infix_asdtdt(infix_sldt(c_one,
  i_to_c(cardinal(s))), ket_sum_l(s, (fc344(x) : ('a,complex matrix) farray),
  l)) = x)))))

logic fc345 : ('b,complex matrix) farray,
  ('a,'b) farray -> ('a,complex matrix) farray

axiom fcqtdef346 :
  (forall f:('b,complex matrix) farray. forall t:('a,'b) farray.
  forall a1:'a. ((fc345(f, t)[a1]) = (f[(t[a1])])))

axiom map_ket_sum_l :
  (forall f:('b,complex matrix) farray. forall s:'a set.
  forall t:('a,'b) farray. forall n:int. ((0 <= n) -> (p_injective(t, s) ->
  (ket_sum_l(map(t, s), f, n) = ket_sum_l(s, fc345(f, t), n)))))

axiom pre_injective_bv_to_int :
  (forall bv1:bitvec. forall bv2:bitvec. ((length(bv1) = length(bv2)) ->
  ((not (bv1 = bv2)) -> (not (bv_to_int(bv1) = bv_to_int(bv2))))))

axiom injective_bv_to_int :
  (forall n:int. ((0 <= n) -> p_injective(bv_to_int_closure, n_bvs(n))))

axiom bijective_to_int :
  (forall n:int. ((0 <  n) -> p_bijective(bv_to_int_closure, n_bvs(n),
  to_fset(0, power(2, n)))))

logic fc346 : int -> (int,bitvec) farray

axiom fcqtdef347 :
  (forall n:int. forall i:int. ((fc346(n)[i]) = int_to_bv(i, n)))

axiom injective_int_to_bv :
  (forall n:int. ((0 <= n) -> p_injective(fc346(n), to_fset(0, power(2,
  n)))))

axiom n_bvs_card :
  (forall n:int. ((0 <= n) -> (cardinal(n_bvs(n)) = power(2, n))))

logic fc347 : (bitvec,bitvec) farray

axiom fcqtdef348 : (forall bv:bitvec. ((fc347[bv]) = concat_l(bv, 0)))

axiom concat_first_term_zero :
  (forall e:bitvec. forall i:int. ((0 <= i) -> (mem(e, map(fc347,
  n_bvs(i))) -> ((value(e)[0]) = 0))))

logic fc348 : (bitvec,bitvec) farray

axiom fcqtdef349 : (forall bv:bitvec. ((fc348[bv]) = concat_l(bv, 1)))

axiom concat_first_term_one :
  (forall e:bitvec. forall i:int. ((0 <= i) -> (mem(e, map(fc348,
  n_bvs(i))) -> ((value(e)[0]) = 1))))

axiom bv_sum_to_int_sum :
  (forall n:int. forall f:(int,complex) farray.
  forall g:(bitvec,complex) farray. ((0 <= n) ->
  ((forall x:bitvec. ((length(x) = n) -> ((g[x]) = (f[bv_to_int(x)])))) ->
  (sum(n_bvs(n), g) = sum(to_fset(0, power(2, n)), f)))))

logic fc349 : (bitvec,complex matrix) farray -> (bitvec,complex matrix) farray

axiom fcqtdef350 :
  (forall f:(bitvec,complex matrix) farray. forall bv:bitvec.
  ((fc349(f)[bv]) = add_mat((f[concat_l(bv, 0)]), (f[concat_l(bv, 1)]))))

axiom sum_concat :
  (forall f:(bitvec,complex matrix) farray. forall i:int. forall r:int.
  forall c:int. ((0 <  i) -> ((forall bv:bitvec. (rows((f[bv])) = r)) ->
  ((forall bv:bitvec. (columns((f[bv])) = c)) -> (mat_sum(n_bvs(i),
  fc349(f)) = mat_sum(n_bvs((i + 1)), f))))))

logic fc350 : complex, complex -> (bitvec,complex) farray

axiom fcqtdef351 :
  (forall a:complex. forall q:complex. forall i:bitvec. ((fc350(a,
  q)[i]) = infix_asdt(a, cpower(q, bv_to_int(i)))))

axiom geometric_series_bv :
  (forall a:complex. forall q:complex. forall n:int. ((1 <= n) ->
  ((not (q = c_one)) -> (sum(n_bvs(n), fc350(a,
  q)) = infix_sldt(infix_asdt(a, infix_mndt(c_one, cpower(q, power(2, n)))),
  infix_mndt(c_one, q))))))

logic fc351 : complex -> (bitvec,complex) farray

axiom fcqtdef352 :
  (forall q:complex. forall i:bitvec. ((fc351(q)[i]) = cpower(q,
  bv_to_int(i))))

axiom geometric_series_bv_init_one :
  (forall q:complex. forall n:int. ((1 <= n) -> ((not (q = c_one)) ->
  (sum(n_bvs(n), fc351(q)) = infix_sldt(infix_mndt(c_one, cpower(q, power(2,
  n))), infix_mndt(c_one, q))))))

logic fc352 : (int,complex matrix) farray -> (bitvec,complex matrix) farray

axiom fcqtdef353 :
  (forall f:(int,complex matrix) farray. forall a:bitvec.
  ((fc352(f)[a]) = (f[bv_to_int(a)])))

axiom ket_sum_l_to_n_bvs :
  (forall f:(int,complex matrix) farray. forall l:int. forall n:int.
  ((0 <= n) -> ((0 <= l) -> (ket_sum_l(to_fset(0, power(2, l)), f,
  n) = ket_sum_l(n_bvs(l), fc352(f), n)))))

logic fc353 : (bitvec,complex matrix) farray,
  int -> (int,complex matrix) farray

axiom fcqtdef354 :
  (forall f:(bitvec,complex matrix) farray. forall l:int. forall i:int.
  ((fc353(f, l)[i]) = (f[int_to_bv(i, l)])))

axiom ket_sum_l_to_fset :
  (forall f:(bitvec,complex matrix) farray. forall l:int. forall n:int.
  ((0 <= n) -> ((0 <= l) -> (ket_sum_l(n_bvs(l), f, n) = ket_sum_l(to_fset(0,
  power(2, l)), fc353(f, l), n)))))

axiom ket_sum_partition :
  (forall s:'a set. forall s1:'a set. forall s2:'a set.
  forall f:('a,complex matrix) farray. forall n:int. ((0 <= n) ->
  ((s = union(s1, s2)) -> ((inter(s1, s2) = (empty : 'a set)) ->
  (ket_sum_l(s, f, n) = add_ket_l(ket_sum_l(s1, f, n), ket_sum_l(s2, f, n),
  n))))))

logic fc354 : complex matrix, int -> (int,complex matrix) farray

axiom fcqtdef355 :
  (forall m:complex matrix. forall n:int. forall j:int. ((fc354(m,
  n)[j]) = infix_asdtdt(get(m, j, 0), ket(n, j))))

axiom ket_decomp :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (is_a_ket(m) ->
  ((ket_length(m) = n) -> (m = mat_sum(to_fset(0, power(2, n)), fc354(m,
  n)))))))

logic fc355 : complex matrix, int -> (bitvec,complex matrix) farray

axiom fcqtdef356 :
  (forall m:complex matrix. forall n:int. forall bvx:bitvec. ((fc355(m,
  n)[bvx]) = infix_asdtdt(get(m, bv_to_int(bvx), 0), ket(n,
  bv_to_int(bvx)))))

axiom ket_decomp_bv :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (is_a_ket(m) ->
  ((ket_length(m) = n) -> (m = ket_sum_l(n_bvs(n), fc355(m, n), n))))))

logic fc356 : (int,complex) farray, int -> (int,complex matrix) farray

logic fc357 : (int,complex) farray -> (int,(int,complex) farray) farray

axiom fcqtdef357 :
  (forall f:(int,complex) farray. forall n:int. forall j:int. ((fc356(f,
  n)[j]) = infix_asdtdt((f[j]), ket(n, j))))

axiom fcqtdef358 :
  (forall f:(int,complex) farray. forall x:int. forall us:int.
  (((fc357(f)[x])[us]) = (f[x])))

axiom ket_recomp :
  (forall f:(int,complex) farray. forall n:int. ((0 <= n) ->
  (mat_sum(to_fset(0, power(2, n)), fc356(f, n)) = make_f(power(2, n), 1,
  fc357(f)))))

logic fc358 : complex matrix -> (int,complex matrix) farray

axiom fcqtdef359 :
  (forall m:complex matrix. forall j:int.
  ((fc358(m)[j]) = infix_asdtdt(get(m, j, 0), ket(ket_length(m), j))))

axiom ket_decomp_quant :
  (forall m:complex matrix. (is_a_ket(m) -> (m = mat_sum(to_fset(0, power(2,
  ket_length(m))), fc358(m)))))

logic fc359 : complex matrix, complex matrix -> (int,complex matrix) farray

axiom fcqtdef360 :
  (forall m:complex matrix. forall x:complex matrix. forall k:int. ((fc359(m,
  x)[k]) = infix_asdtdt(get(m, k, ket_to_int(x)), ket(ket_length(x), k))))

axiom mat_mult_ket_basis :
  (forall m:complex matrix. forall x:complex matrix.
  (is_a_ket_basis_elt(x) -> (((columns(m) = rows(m)) and
  (rows(m) = rows(x))) -> (mat_mult(m, x) = mat_sum(to_fset(0, rows(x)),
  fc359(m, x))))))

axiom ket_mult_diag :
  (forall m:complex matrix. forall x:complex matrix. ((1 <= ket_length(x)) ->
  (is_a_ket_basis_elt(x) -> ((rows(m) = power(2, ket_length(x))) ->
  ((columns(m) = power(2, ket_length(x))) ->
  ((forall i:int. forall j:int. (((0 <= i) and (i <  power(2,
   ket_length(x)))) -> (((0 <= j) and (j <  power(2, ket_length(x)))) ->
   ((not (i = j)) -> (get(m, i, j) = c_zero))))) ->
  (mat_mult(m, x) = infix_asdtdt(get(m, ket_to_int(x), ket_to_int(x)),
  ket(ket_length(x), ket_to_int(x))))))))))

logic fc360 : complex matrix, complex matrix,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef361 :
  (forall m:complex matrix. forall x:complex matrix. forall n:int.
  forall bvx:bitvec. ((fc360(m, x, n)[bvx]) = infix_asdtdt(get(m,
  bv_to_int(bvx), ket_to_int(x)), ket(n, bv_to_int(bvx)))))

axiom mat_mult_ket_basis_bv :
  (forall m:complex matrix. forall x:complex matrix. forall n:int.
  ((ket_length(x) = n) -> (is_a_ket_basis_elt(x) ->
  (((columns(m) = rows(m)) and (rows(m) = rows(x))) -> (mat_mult(m,
  x) = ket_sum_l(n_bvs(n), fc360(m, x, n), n))))))

logic fc361 : complex matrix,
  complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef362 :
  (forall m:complex matrix. forall x:complex matrix. forall bvx:bitvec.
  ((fc361(m, x)[bvx]) = infix_asdtdt(get(m, bv_to_int(bvx), ket_to_int(x)),
  ket(ket_length(x), bv_to_int(bvx)))))

axiom mat_mult_ket_basis_bv_gen :
  (forall m:complex matrix. forall x:complex matrix.
  (is_a_ket_basis_elt(x) -> (((columns(m) = rows(m)) and
  (rows(m) = rows(x))) -> (mat_mult(m, x) = ket_sum_l(n_bvs(ket_length(x)),
  fc361(m, x), ket_length(x))))))

logic fc362 : complex matrix, complex matrix,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef363 :
  (forall m:complex matrix. forall x:complex matrix. forall n:int.
  forall bvx:bitvec. ((fc362(m, x, n)[bvx]) = infix_asdtdt(get(x,
  bv_to_int(bvx), 0), mat_mult(m, ket(n, bv_to_int(bvx))))))

axiom mat_mult_ket_bv :
  (forall m:complex matrix. forall x:complex matrix. forall n:int.
  (is_a_ket_l(x, n) -> (((columns(m) = rows(m)) and ((rows(m) = rows(x)) and
  (rows(x) = power(2, n)))) -> (mat_mult(m, x) = ket_sum_l(n_bvs(n), fc362(m,
  x, n), n)))))

logic fc363 : complex matrix,
  complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef364 :
  (forall m:complex matrix. forall x:complex matrix. forall bvx:bitvec.
  ((fc363(m, x)[bvx]) = infix_asdtdt(get(x, bv_to_int(bvx), 0), mat_mult(m,
  ket(ket_length(x), bv_to_int(bvx))))))

axiom mat_mult_ket_bv_gen :
  (forall m:complex matrix. forall x:complex matrix. (is_a_ket(x) ->
  (((columns(m) = rows(m)) and (rows(m) = rows(x))) -> (mat_mult(m,
  x) = ket_sum_l(n_bvs(ket_length(x)), fc363(m, x), ket_length(x))))))

logic fc364 : complex matrix,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef365 :
  (forall m:complex matrix. forall f:('a,complex matrix) farray. forall x:'a.
  ((fc364(m, f)[x]) = mat_mult(m, (f[x]))))

axiom mat_mult_ket_sum_l :
  (forall m:complex matrix. forall s:'a set.
  forall f:('a,complex matrix) farray. forall l:int. ((0 <  cardinal(s)) ->
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l))) ->
  (((columns(m) = rows(m)) and (rows(m) = power(2, l))) -> (mat_mult(m,
  ket_sum_l(s, f, l)) = ket_sum_l(s, fc364(m, f), l))))))

logic fc365 : (int,int) farray, (int,complex) farray,
  int -> (int,complex matrix) farray

logic fc366 : (int,int) farray, int set, int set, (int,complex) farray,
  int -> (int,complex matrix) farray

axiom fcqtdef366 :
  (forall f:(int,int) farray. forall a:(int,complex) farray. forall n:int.
  forall j:int. ((fc365(f, a, n)[j]) = infix_asdtdt((a[j]), set1(make(n, 1,
  c_zero), (f[j]), 0, c_one))))

axiom fcqtdef367 :
  (forall f:(int,int) farray. forall s:int set. forall sqt:int set.
  forall a:(int,complex) farray. forall n:int. forall j:int. ((fc366(f, s,
  sqt, a, n)[j]) = infix_asdtdt((a[inv_func(f, s, sqt, j)]), set1(make(n, 1,
  c_zero), j, 0, c_one))))

axiom fun_inversion_pre :
  (forall f:(int,int) farray. forall s:int set. forall sqt:int set.
  forall a:(int,complex) farray. forall n:int. ((0 <= n) ->
  ((0 <  cardinal(s)) -> (p_bijective(f, s, sqt) -> (subset(s, to_fset(0,
  n)) -> (subset(sqt, to_fset(0, n)) -> (mat_sum(s, fc365(f, a,
  n)) = mat_sum(sqt, fc366(f, s, sqt, a, n)))))))))

logic fc367 : (int,int) farray, (int,complex) farray,
  complex matrix -> (int,complex matrix) farray

logic fc368 : (int,int) farray, (int,complex) farray, complex matrix,
  int -> (int,complex matrix) farray

axiom fcqtdef368 :
  (forall f:(int,int) farray. forall a:(int,complex) farray.
  forall m:complex matrix. forall j:int. ((fc367(f, a,
  m)[j]) = infix_asdtdt((a[j]), ket(ket_length(m), (f[j])))))

axiom fcqtdef369 :
  (forall f:(int,int) farray. forall a:(int,complex) farray.
  forall m:complex matrix. forall pow_2_n:int. forall j:int. ((fc368(f, a, m,
  pow_2_n)[j]) = infix_asdtdt((a[inv_(f, to_fset(0, pow_2_n), to_fset(0,
  pow_2_n), j)]), ket(ket_length(m), j))))

axiom ket_fun_inversion :
  (forall f:(int,int) farray. forall a:(int,complex) farray.
  forall m:complex matrix. forall pow_2_n:int. ((pow_2_n = power(2,
  ket_length(m))) -> (is_a_ket(m) -> ((0 <  pow_2_n) -> (p_bijective(f,
  to_fset(0, pow_2_n), to_fset(0, pow_2_n)) -> ((m = mat_sum(to_fset(0,
  pow_2_n), fc367(f, a, m))) -> (m = mat_sum(to_fset(0, pow_2_n), fc368(f, a,
  m, pow_2_n)))))))))

axiom ket_sum_partition_filter :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall p1:('a,bool) farray. forall p2:('a,bool) farray. forall n:int.
  ((0 <= n) ->
  ((forall e:'a. (mem(e, s) -> (((p1[e]) = true) <->
   (not ((p2[e]) = true))))) ->
  (ket_sum_l(s, f, n) = add_ket_l(ket_sum_l(my_filter(s, p1), f, n),
  ket_sum_l(my_filter(s, p2), f, n), n)))))

axiom kronecker_neutral_ket_l : is_a_ket_l(make(1, 1, c_one), 0)

axiom kronecker_neutral_ket_basis : is_a_ket_basis_elt(make(1, 1, c_one))

axiom equals_kronecker_neutral :
  (forall n:complex matrix. (is_a_ket_l(n, 0) -> (is_a_ket_basis_elt(n) ->
  (n = make(1, 1, c_one)))))

axiom get_kronecker_neutral :
  (forall a:complex matrix. forall n:complex matrix. (is_a_ket_l(n, 0) ->
  (is_a_ket_basis_elt(n) -> (kronecker(a, n) = a))))

axiom get_neutral_kronecker :
  (forall a:complex matrix. forall n:complex matrix. (is_a_ket_l(n, 0) ->
  (is_a_ket_basis_elt(n) -> (kronecker(n, a) = a))))

axiom set_kronecker_neutral :
  (forall a:complex matrix. (a = kronecker(a, make(1, 1, c_one))))

axiom set_neutral_kronecker :
  (forall a:complex matrix. (a = kronecker(make(1, 1, c_one), a)))

logic hpart_ket : complex matrix, int -> complex matrix

axiom hpart_ketqtdef :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> (hpart_ket(m, i) = ket(i,
  (ket_to_int(m) / power(2, (ket_length(m) - i))))))))

axiom hpart_ketqtspec :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> is_a_ket_basis_elt(hpart_ket(m,
  i)))))

axiom hpart_ketqtspec1 :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> (ket_length(hpart_ket(m,
  i)) = i))))

axiom hpart_ketqtspec2 :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> (ket_to_int(hpart_ket(m,
  i)) = (ket_to_int(m) / power(2, (ket_length(m) - i)))))))

axiom hpart_ket_rows :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> (rows(hpart_ket(m, i)) = power(2,
  i)))))

axiom hpart_ket_l :
  (forall m:complex matrix. forall i:int. forall j:int.
  (is_a_ket_basis_elt(m) -> (((0 <= i) and (i <= ket_length(m))) ->
  ((i = j) -> is_a_ket_l(hpart_ket(m, i), j)))))

logic tpart_ket : complex matrix, int -> complex matrix

axiom tpart_ketqtdef :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> (tpart_ket(m,
  i) = ket((ket_length(m) - i), (ket_to_int(m) % power(2,
  (ket_length(m) - i))))))))

axiom tpart_ketqtspec :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> is_a_ket_basis_elt(tpart_ket(m,
  i)))))

axiom tpart_ketqtspec1 :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> (ket_length(tpart_ket(m,
  i)) = (ket_length(m) - i)))))

axiom tpart_ketqtspec2 :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> (ket_to_int(tpart_ket(m,
  i)) = (ket_to_int(m) % power(2, (ket_length(m) - i)))))))

axiom tpart_ket_l :
  (forall m:complex matrix. forall i:int. forall j:int.
  (is_a_ket_basis_elt(m) -> (((0 <= i) and (i <= ket_length(m))) ->
  ((j = (ket_length(m) - i)) -> is_a_ket_l(tpart_ket(m, i), j)))))

axiom tpart_ket_rows :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> (rows(tpart_ket(m, i)) = power(2,
  (ket_length(m) - i))))))

axiom concat_ket :
  (forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  is_a_ket_basis_elt(kronecker(x, y)))))

axiom concat_ket1 :
  (forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (ket_length(kronecker(x, y)) = (ket_length(x) + ket_length(y))))))

axiom concat_ket2 :
  (forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (ket_to_int(kronecker(x, y)) = ((ket_to_int(x) * power(2,
  ket_length(y))) + ket_to_int(y))))))

axiom concat_ht_part_ket :
  (forall m:complex matrix. forall i:int. (is_a_ket_basis_elt(m) ->
  (((0 <= i) and (i <= ket_length(m))) -> (kronecker(hpart_ket(m, i),
  tpart_ket(m, i)) = m))))

axiom ket_ht_decomp :
  (forall n:int. forall i:int. forall j:int. (((0 <= i) and (i <= n)) ->
  (((0 <= j) and (j <  power(2, n))) -> (ket(n,
  j) = kronecker(hpart_ket(ket(n, j), i), tpart_ket(ket(n, j), i))))))

axiom ket_ht_decomp_quant :
  (forall n:int. forall i:int. (((0 <= i) and (i <= n)) ->
  (forall j:int. (((0 <= j) and (j <  power(2, n))) -> (ket(n,
  j) = kronecker(hpart_ket(ket(n, j), i), tpart_ket(ket(n, j), i)))))))

logic fc369 : complex matrix, int -> (int,complex matrix) farray

axiom fcqtdef370 :
  (forall m:complex matrix. forall i:int. forall j:int. ((fc369(m,
  i)[j]) = infix_asdtdt(get(m, j, 0), kronecker(hpart_ket(ket(ket_length(m),
  j), i), tpart_ket(ket(ket_length(m), j), i)))))

axiom ht_decomp :
  (forall m:complex matrix. forall i:int. (is_a_ket(m) -> (((0 <= i) and
  (i <= ket_length(m))) -> (m = mat_sum(to_fset(0, power(2, ket_length(m))),
  fc369(m, i))))))

axiom not_null_ket_basis :
  (forall x:complex matrix. (is_a_ket_basis_elt(x) -> (not null_mat(x))))

logic ket_to_bv : complex matrix -> bitvec

axiom ket_to_bvqtdef :
  (forall x:complex matrix. (is_a_ket_basis_elt(x) ->
  (ket_to_bv(x) = int_to_bv(ket_to_int(x), ket_length(x)))))

axiom ket_to_bvqtspec :
  (forall x:complex matrix. (is_a_ket_basis_elt(x) ->
  (bv_to_int(ket_to_bv(x)) = ket_to_int(x))))

axiom ket_to_bvqtspec1 :
  (forall x:complex matrix. (is_a_ket_basis_elt(x) ->
  (length(ket_to_bv(x)) = ket_length(x))))

axiom ket_to_bvqtspec2 :
  (forall x:complex matrix. (is_a_ket_basis_elt(x) -> mem(ket_to_bv(x),
  n_bvs(ket_length(x)))))

axiom ket_to_bv_length :
  (forall x:complex matrix. forall n:int. (is_a_ket_basis_elt(x) ->
  ((ket_length(x) = n) -> (length(ket_to_bv(x)) = n))))

function bv_to_ket(bv: bitvec) : complex matrix = ket(length(bv),
  bv_to_int(bv))

axiom bv_to_ketqtspec : (forall bv:bitvec. is_a_ket_basis_elt(bv_to_ket(bv)))

axiom bv_to_ketqtspec1 :
  (forall bv:bitvec. (ket_to_int(bv_to_ket(bv)) = bv_to_int(bv)))

axiom bv_to_ketqtspec2 :
  (forall bv:bitvec. is_a_ket_l(bv_to_ket(bv), length(bv)))

axiom bv_to_ketqtspec3 :
  (forall bv:bitvec. (rows(bv_to_ket(bv)) = power(2, length(bv))))

axiom bv_to_ketqtspec4 : (forall bv:bitvec. (columns(bv_to_ket(bv)) = 1))

axiom bv_to_ketqtspec5 :
  (forall bv:bitvec. (bv_to_ket(bv) = bin_to_ket(length(bv), value(bv))))

axiom ket_to_bv_ket_length :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (length(ket_to_bv(ket(n, i))) = n))))

axiom is_a_ket_l_bv_to_ket :
  (forall bv:bitvec. forall l:int. ((length(bv) = l) ->
  is_a_ket_l(bv_to_ket(bv), l)))

axiom is_a_ket_l_bv_to_ket_ :
  (forall bv:bitvec. forall l:int. (mem(bv, n_bvs(l)) -> ((0 <= l) ->
  is_a_ket_l(bv_to_ket(bv), l))))

axiom bin_to_ket_to_bv_to_ket :
  (forall f:(int,int) farray. forall n:int. ((0 <= n) -> (binary(f) ->
  (bin_to_ket(n, f) = bv_to_ket(make_bv(f, n))))))

axiom bin_to_ket_to_bv_to_ket_abs :
  (forall f:(int,int) farray. forall n:int. forall a:bitvec. ((0 <= n) ->
  ((a = make_bv(f, n)) -> (binary(f) -> (bin_to_ket(n, f) = bv_to_ket(a))))))

axiom ket_to_int_to_bv_to_ket :
  (forall n:int. forall e:bitvec. ((0 <= n) -> (mem(e, n_bvs(n)) -> (ket(n,
  bv_to_int(e)) = bv_to_ket(e)))))

axiom ket_to_bv_ket :
  (forall n:int. forall i:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (ket_to_bv(ket(n, i)) = int_to_bv(i, n)))))

axiom bv_to_ket_length :
  (forall bv:bitvec. (ket_length(bv_to_ket(bv)) = length(bv)))

axiom get_ket_bv_to_ket_length :
  (forall bv:bitvec. forall k:int. (((0 <= k) and (k <  power(2,
  length(bv)))) -> (get(bv_to_ket(bv), k,
  0) = (if (k = bv_to_int(bv)) then c_one else c_zero))))

axiom is_a_ket_l_bvs :
  (forall e:bitvec. forall n:int. ((0 <= n) -> (mem(e, n_bvs(n)) ->
  is_a_ket_l(bv_to_ket(e), n))))

axiom is_a_ket_l_scal_bvs :
  (forall e:bitvec. forall n:int. forall a:complex. ((0 <= n) -> (mem(e,
  n_bvs(n)) -> is_a_ket_l(infix_asdtdt(a, bv_to_ket(e)), n))))

axiom ket_to_bv_concat :
  (forall x:bitvec. forall y:bitvec. (bv_to_ket(concat(x,
  y)) = kronecker(bv_to_ket(x), bv_to_ket(y))))

axiom bv_to_ket_concat_rev :
  (forall x:bitvec. forall y:bitvec. (kronecker(bv_to_ket(x),
  bv_to_ket(y)) = bv_to_ket(concat(x, y))))

axiom bv_to_ket_kronecker :
  (forall x:bitvec. forall i:int. (((0 <= i) and (i <= length(x))) ->
  (bv_to_ket(x) = kronecker(hpart_ket(bv_to_ket(x), i),
  tpart_ket(bv_to_ket(x), i)))))

axiom bv_to_ket_kronecker_ :
  (forall x:bitvec. forall i:int. (((0 <= i) and (i <= length(x))) ->
  (bv_to_ket(x) = kronecker(bv_to_ket(hpart(x, i)), bv_to_ket(tpart(x,
  i))))))

axiom bv_to_ket_to_bv : (forall bv:bitvec. (ket_to_bv(bv_to_ket(bv)) = bv))

axiom ket_to_bv_to_ket :
  (forall x:complex matrix. (is_a_ket_basis_elt(x) ->
  (bv_to_ket(ket_to_bv(x)) = x)))

axiom bv_to_ket_eq :
  (forall bv1:bitvec. forall bv2:bitvec. ((length(bv1) = length(bv2)) ->
  ((forall i:int. (((0 <= i) and (i <  length(bv1))) ->
   ((value(bv1)[i]) = (value(bv2)[i])))) ->
  (bv_to_ket(bv1) = bv_to_ket(bv2)))))

logic fc370 : complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef371 :
  (forall m:complex matrix. forall bvx:bitvec.
  ((fc370(m)[bvx]) = infix_asdtdt(get(m, bv_to_int(bvx), 0),
  bv_to_ket(bvx))))

axiom ket_decomp_ :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (is_a_ket(m) ->
  ((ket_length(m) = n) -> (m = ket_sum_l(n_bvs(n), fc370(m), n))))))

axiom ket_bv_to_int_to_bv_to_ket :
  (forall x:bitvec. forall n:int. ((n = length(x)) -> (ket(n,
  bv_to_int(x)) = bv_to_ket(x))))

axiom ket_to_bv_kronecker :
  (forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) -> (ket_to_bv(kronecker(x,
  y)) = concat(ket_to_bv(x), ket_to_bv(y))))))

logic fc371 : complex matrix, int -> (bitvec,complex matrix) farray

axiom fcqtdef372 :
  (forall m:complex matrix. forall n:int. forall bvx:bitvec. ((fc371(m,
  n)[bvx]) = infix_asdtdt(get(m, bv_to_int(bvx), 0), ket(n,
  bv_to_int(bvx)))))

axiom ket_decomp_bv_ket :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (is_a_ket(m) ->
  ((ket_length(m) = n) -> (m = ket_sum_l(n_bvs(n), fc371(m, n), n))))))

logic fc372 : (int,int) farray

axiom fcqtdef373 : (forall us:int. ((fc372[us]) = 0))

axiom ket_zero : (forall n:int. ((0 <= n) -> is_a_ket_l(ket(n, 0), n)))

axiom ket_zero1 : (forall n:int. ((0 <= n) -> is_a_ket_basis_elt(ket(n, 0))))

axiom ket_zero2 :
  (forall n:int. ((0 <= n) -> (ket_to_bv(ket(n, 0)) = make_bv(fc372, n))))

axiom ket_zero3 :
  (forall n:int. ((0 <= n) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((value(ket_to_bv(ket(n,
  0)))[i]) = 0)))))

logic fc373 : (bitvec,complex) farray -> (bitvec,complex matrix) farray

axiom fcqtdef374 :
  (forall f:(bitvec,complex) farray. forall x:bitvec.
  ((fc373(f)[x]) = infix_asdtdt((f[x]), bv_to_ket(x))))

axiom uniform_ket_norm_l :
  (forall x:complex matrix. forall f:(bitvec,complex) farray. forall n:int.
  (is_a_ket_l(x, n) ->
  ((forall e:bitvec. (mem(e, n_bvs(n)) -> (modulus((f[e])) = c_one))) ->
  ((x = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc373(f), n))) ->
  (ket_norm_l(x, n) = c_one)))))

logic ket_sum_l_diag : (bitvec,complex) farray, int -> complex matrix

logic result40 : (bitvec,complex) farray -> (bitvec,complex matrix) farray

axiom resultqtdef47 :
  (forall f:(bitvec,complex) farray. forall x:bitvec.
  ((result40(f)[x]) = infix_asdtdt((f[x]), bv_to_ket(x))))

axiom ket_sum_l_diagqtdef :
  (forall f:(bitvec,complex) farray. forall l:int. ((0 <= l) ->
  (ket_sum_l_diag(f, l) = ket_sum_l(n_bvs(l), result40(f), l))))

axiom ket_sum_l_diagqtspec :
  (forall f:(bitvec,complex) farray. forall l:int. ((0 <= l) ->
  is_a_ket_l(ket_sum_l_diag(f, l), l)))

axiom ket_sum_l_diagqtspec1 :
  (forall f:(bitvec,complex) farray. forall l:int. ((0 <= l) ->
  (forall i:int. (((0 <= i) and (i <  power(2, l))) -> (get(ket_sum_l_diag(f,
  l), i, 0) = (f[int_to_bv(i, l)]))))))

logic fc374 : (bitvec,complex) farray -> (bitvec,complex matrix) farray

logic fc375 : (bitvec,complex) farray -> (bitvec,complex matrix) farray

axiom fcqtdef375 :
  (forall f:(bitvec,complex) farray. forall x:bitvec.
  ((fc374(f)[x]) = infix_asdtdt((f[x]), bv_to_ket(x))))

axiom fcqtdef376 :
  (forall f:(bitvec,complex) farray. forall x:bitvec.
  ((fc375(f)[x]) = infix_asdtdt((f[x]), bv_to_ket(x))))

axiom ket_sum_of_scalars :
  (forall f:(bitvec,complex) farray. forall n:int. ((0 <= n) ->
  is_a_ket_l(ket_sum_l(n_bvs(n), fc374(f), n), n)))

axiom ket_sum_of_scalars1 :
  (forall f:(bitvec,complex) farray. forall n:int. ((0 <= n) ->
  (forall i:int. (((0 <= i) and (i <  power(2, n))) ->
  (get(ket_sum_l(n_bvs(n), fc375(f), n), i, 0) = (f[int_to_bv(i, n)]))))))

logic fc376 : 'b set,
  ('a,('b,complex matrix) farray) farray -> ('a,complex matrix) farray

logic fc377 : ('a,('b,complex matrix) farray) farray -> (('a,
  'b) tuple2,complex matrix) farray

axiom fcqtdef377 :
  (forall s2:'b set. forall f:('a,('b,complex matrix) farray) farray.
  forall a1:'a. ((fc376(s2, f)[a1]) = mat_sum(s2, (f[a1]))))

axiom fcqtdef378 :
  (forall f:('a,('b,complex matrix) farray) farray. forall o:('a, 'b) tuple2.
  ((fc377(f)[o]) = ((f[fir(o)])[sec(o)])))

axiom mat_sum_sum_cartesian_product_pre :
  (forall s1:'a set. forall s2:'b set.
  forall f:('a,('b,complex matrix) farray) farray. forall r:int.
  forall c:int. ((0 <  r) -> ((0 <  c) ->
  ((forall a1:'a. forall b1:'b. (mem(a1, s1) -> (mem(b1, s2) ->
   (rows(((f[a1])[b1])) = r)))) ->
  ((forall a1:'a. forall b1:'b. (mem(a1, s1) -> (mem(b1, s2) ->
   (columns(((f[a1])[b1])) = c)))) ->
  ((0 <  cardinal(s1)) -> ((0 <  cardinal(s2)) -> (mat_sum(s1, fc376(s2,
  f)) = mat_sum(cartesian_product(s1, s2), fc377(f))))))))))

logic fc378 : (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

logic fc379 : (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef379 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall x:int.
  forall bvy:bitvec. ((fc378(f, x)[bvy]) = mat_sum(n_bvs(x), (f[bvy]))))

axiom fcqtdef380 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall y:int.
  forall bv:bitvec. ((fc379(f, y)[bv]) = ((f[hpart(bv, y)])[tpart(bv, y)])))

axiom mat_sum_comp1 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall x:int. forall y:int. ((0 <= x) -> ((0 <= y) -> ((0 <= l) ->
  ((forall bvx:bitvec. forall bvy:bitvec. (mem(bvx, n_bvs(x)) -> (mem(bvy,
   n_bvs(y)) -> is_a_ket(((f[bvy])[bvx]))))) ->
  ((forall bvx:bitvec. forall bvy:bitvec. (mem(bvx, n_bvs(x)) -> (mem(bvy,
   n_bvs(y)) -> (ket_length(((f[bvy])[bvx])) = l)))) ->
  (mat_sum(n_bvs(y), fc378(f, x)) = mat_sum(n_bvs((x + y)), fc379(f,
  y)))))))))

logic fc380 : (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

logic fc381 : (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef381 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall y:int.
  forall bv:bitvec. ((fc380(f, y)[bv]) = ((f[hpart(bv, y)])[tpart(bv, y)])))

axiom fcqtdef382 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall x:int.
  forall bvy:bitvec. ((fc381(f, x)[bvy]) = mat_sum(n_bvs(x), (f[bvy]))))

axiom mat_sum_comp_rev :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall x:int. forall y:int. ((0 <= x) -> ((0 <= y) -> ((0 <= l) ->
  ((forall bvx:bitvec. forall bvy:bitvec. (mem(bvx, n_bvs(x)) -> (mem(bvy,
   n_bvs(y)) -> is_a_ket(((f[bvy])[bvx]))))) ->
  ((forall bvx:bitvec. forall bvy:bitvec. (mem(bvx, n_bvs(x)) -> (mem(bvy,
   n_bvs(y)) -> (ket_length(((f[bvy])[bvx])) = l)))) ->
  (mat_sum(n_bvs((x + y)), fc380(f, y)) = mat_sum(n_bvs(y), fc381(f,
  x)))))))))

logic fc382 : (bitvec,(bitvec,complex matrix) farray) farray,
  (bitvec,complex) farray, int, int -> (bitvec,complex matrix) farray

logic fc383 : (bitvec,(bitvec,complex matrix) farray) farray,
  (bitvec,complex) farray, int -> (bitvec,complex matrix) farray

axiom fcqtdef383 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray.
  forall scal:(bitvec,complex) farray. forall l:int. forall x:int.
  forall bvy:bitvec. ((fc382(f, scal, l, x)[bvy]) = infix_asdtdt((scal[bvy]),
  ket_sum_l(n_bvs(x), (f[bvy]), l))))

axiom fcqtdef384 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray.
  forall scal:(bitvec,complex) farray. forall y:int. forall bv:bitvec.
  ((fc383(f, scal, y)[bv]) = infix_asdtdt((scal[hpart(bv, y)]), ((f[hpart(bv,
  y)])[tpart(bv, y)]))))

axiom ket_sum_bin_comp_l :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray.
  forall scal:(bitvec,complex) farray. forall l:int. forall x:int.
  forall y:int. ((0 <= x) -> ((0 <= y) -> ((0 <= l) -> (ket_sum_l(n_bvs(y),
  fc382(f, scal, l, x), l) = ket_sum_l(n_bvs((x + y)), fc383(f, scal, y),
  l))))))

logic fc384 : (bitvec,(bitvec,complex matrix) farray) farray, int,
  int -> (bitvec,complex matrix) farray

logic fc385 : (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef385 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall x:int. forall bvy:bitvec. ((fc384(f, l,
  x)[bvy]) = ket_sum_l(n_bvs(x), (f[bvy]), l)))

axiom fcqtdef386 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall y:int.
  forall bv:bitvec. ((fc385(f, y)[bv]) = ((f[hpart(bv, y)])[tpart(bv, y)])))

axiom ket_sum_bin_comp :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall x:int. forall y:int. ((0 <= x) -> ((0 <= y) -> ((0 <= l) ->
  (ket_sum_l(n_bvs(y), fc384(f, l, x), l) = ket_sum_l(n_bvs((x + y)),
  fc385(f, y), l))))))

logic fc386 : (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

logic fc387 : (bitvec,(bitvec,complex matrix) farray) farray, int,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef387 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall y:int.
  forall bv:bitvec. ((fc386(f, y)[bv]) = ((f[hpart(bv, y)])[tpart(bv, y)])))

axiom fcqtdef388 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall x:int. forall bvy:bitvec. ((fc387(f, l,
  x)[bvy]) = ket_sum_l(n_bvs(x), (f[bvy]), l)))

axiom ket_sum_bin_comp_rev :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall x:int. forall y:int. ((0 <= x) -> ((0 <= y) -> ((0 <= l) ->
  (ket_sum_l(n_bvs((x + y)), fc386(f, y), l) = ket_sum_l(n_bvs(y), fc387(f,
  l, x), l))))))

logic fc388 : (bitvec,(bitvec,complex matrix) farray) farray,
  int -> (bitvec,complex matrix) farray

logic fc389 : (bitvec,(bitvec,complex matrix) farray) farray, int,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef389 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall x:int.
  forall bv:bitvec. ((fc388(f, x)[bv]) = ((f[hpart(bv, x)])[tpart(bv, x)])))

axiom fcqtdef390 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall y:int. forall bvx:bitvec. ((fc389(f, l,
  y)[bvx]) = ket_sum_l(n_bvs(y), (f[bvx]), l)))

axiom ket_sum_bin_comp_rev_ :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall x:int. forall y:int. ((0 <= x) -> ((0 <= y) -> ((0 <= l) ->
  (ket_sum_l(n_bvs((x + y)), fc388(f, x), l) = ket_sum_l(n_bvs(x), fc389(f,
  l, y), l))))))

axiom ket_sum_bv_to_ints :
  (forall n:int. forall f:(bitvec,complex matrix) farray.
  forall g:(int,complex matrix) farray. ((0 <= n) ->
  ((forall x:bitvec. ((length(x) = n) -> ((f[x]) = (g[bv_to_int(x)])))) ->
  (ket_sum_l(n_bvs(n), f, n) = ket_sum_l(to_fset(0, power(2, n)), g, n)))))

logic fc390 : (bitvec,(bitvec,complex matrix) farray) farray, int,
  int -> (bitvec,complex matrix) farray

logic fc391 : (bitvec,(bitvec,complex matrix) farray) farray, int,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef391 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall l2:int. forall x:bitvec. ((fc390(f, l,
  l2)[x]) = ket_sum_l(n_bvs(l2), (f[x]), l)))

axiom fcqtdef392 :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall l1:int. forall y:bitvec. ((fc391(f, l,
  l1)[y]) = ket_sum_l(n_bvs(l1), (f[y]), l)))

axiom ket_sum_sum_rev :
  (forall f:(bitvec,(bitvec,complex matrix) farray) farray. forall l:int.
  forall l1:int. forall l2:int. ((0 <= l) -> (((0 <= l1) and (l1 = l2)) ->
  (ket_sum_l(n_bvs(l1), fc390(f, l, l2), l) = ket_sum_l(n_bvs(l2), fc391(f,
  l, l1), l)))))

logic fc392 : (bitvec,complex) farray -> (bitvec,complex matrix) farray

axiom fcqtdef393 :
  (forall f:(bitvec,complex) farray. forall y:bitvec.
  ((fc392(f)[y]) = infix_asdtdt((f[y]), bv_to_ket(y))))

axiom get_ket_sum :
  (forall f:(bitvec,complex) farray. forall n:int. forall i:int.
  (((0 <= i) and (i <  power(2, n))) -> ((0 <= n) -> (get(ket_sum_l(n_bvs(n),
  fc392(f), n), i, 0) = (f[int_to_bv(i, n)])))))

axiom get_ket_scalar_zero :
  (forall x:complex matrix. forall a:complex. (get(infix_asdtdt(a, x), 0,
  0) = infix_asdt(a, get(x, 0, 0))))

logic fc393 : (bitvec,(bitvec,complex) farray) farray,
  bitvec -> (bitvec,complex matrix) farray

logic fc394 : (bitvec,(bitvec,complex) farray) farray, bitvec set,
  int -> (bitvec,complex matrix) farray

logic fc395 : (bitvec,(bitvec,complex) farray) farray,
  bitvec -> (bitvec,complex) farray

logic fc396 : (bitvec,(bitvec,complex) farray) farray,
  bitvec set -> (bitvec,complex matrix) farray

axiom fcqtdef394 :
  (forall f:(bitvec,(bitvec,complex) farray) farray. forall x:bitvec.
  forall y:bitvec. ((fc393(f, x)[y]) = infix_asdtdt(((f[x])[y]),
  bv_to_ket(y))))

axiom fcqtdef395 :
  (forall f:(bitvec,(bitvec,complex) farray) farray. forall sy:bitvec set.
  forall l:int. forall x:bitvec. ((fc394(f, sy, l)[x]) = ket_sum_l(sy,
  fc393(f, x), l)))

axiom fcqtdef396 :
  (forall f:(bitvec,(bitvec,complex) farray) farray. forall y:bitvec.
  forall x:bitvec. ((fc395(f, y)[x]) = ((f[x])[y])))

axiom fcqtdef397 :
  (forall f:(bitvec,(bitvec,complex) farray) farray. forall sx:bitvec set.
  forall y:bitvec. ((fc396(f, sx)[y]) = infix_asdtdt(sum(sx, fc395(f, y)),
  bv_to_ket(y))))

axiom ket_sum_sum_complex :
  (forall f:(bitvec,(bitvec,complex) farray) farray. forall sx:bitvec set.
  forall sy:bitvec set. forall l:int. ((0 <= l) ->
  ((forall x:bitvec. (mem(x, sx) -> (length(x) = l))) ->
  ((forall y:bitvec. (mem(y, sy) -> (length(y) = l))) -> (ket_sum_l(sx,
  fc394(f, sy, l), l) = ket_sum_l(sy, fc396(f, sx), l))))))

axiom mat_mult_ket_basis_bv_value :
  (forall m:complex matrix. forall x:bitvec. forall i:int. forall l:int.
  ((length(x) = l) -> (((0 <= i) and (i <  power(2, l))) ->
  (((columns(m) = rows(m)) and (rows(m) = power(2, l))) -> (get(mat_mult(m,
  bv_to_ket(x)), i, 0) = get(m, i, bv_to_int(x)))))))

axiom mat_mult_ket_basis_bv_value_gen :
  (forall m:complex matrix. forall l:int. (((columns(m) = rows(m)) and
  (rows(m) = power(2, l))) ->
  (forall x:bitvec.
  (forall i:int. ((length(x) = l) -> (((0 <= i) and (i <  power(2, l))) ->
  (get(mat_mult(m, bv_to_ket(x)), i, 0) = get(m, i, bv_to_int(x)))))))))

axiom mat_mult_ket_injec_eq_left :
  (forall m:complex matrix. forall n:complex matrix. forall l:int.
  ((rows(m) = power(2, l)) -> ((columns(m) = power(2, l)) ->
  ((rows(n) = power(2, l)) -> ((columns(n) = power(2, l)) ->
  ((forall x:bitvec. ((length(x) = l) -> (mat_mult(m,
   bv_to_ket(x)) = mat_mult(n, bv_to_ket(x))))) ->
  (m = n)))))))

axiom int_to_bv_to_ket :
  (forall k:int. forall n:int. (((0 <= k) and (k <  power(2, n))) ->
  (bv_to_ket(int_to_bv(k, n)) = ket(n, k))))

type pps

logic h_width : pps -> int

logic h_range : pps -> int

logic h_basis_ket : pps -> ((int,int) farray,((int,int) farray,(int,int) farray) farray) farray

logic h_angle : pps -> ((int,int) farray,((int,int) farray,angle) farray) farray

axiom ppsqtinvariant :
  (forall self:pps [h_angle(self)| h_basis_ket(self)| h_range(self)|
  h_width(self)]. (0 <= h_width(self)))

axiom ppsqtinvariant1 :
  (forall self:pps [h_angle(self)| h_basis_ket(self)| h_range(self)|
  h_width(self)]. (0 <= h_range(self)))

axiom ppsqtinvariant2 :
  (forall self:pps [h_angle(self)| h_basis_ket(self)| h_range(self)|
  h_width(self)].
  (forall x:(int,int) farray. forall y:(int,int) farray.
  ((forall i:int. (((0 <= i) and (i <  h_width(self))) -> ((0 <= (x[i])) and
   ((x[i]) <  2)))) ->
  ((forall i:int. (((0 <= i) and (i <  h_range(self))) -> ((0 <= (y[i])) and
   ((y[i]) <  2)))) ->
  (forall i:int. (((0 <= i) and (i <  h_width(self))) ->
  (0 <= (((h_basis_ket(self)[x])[y])[i]))))))))

axiom ppsqtinvariant3 :
  (forall self:pps [h_angle(self)| h_basis_ket(self)| h_range(self)|
  h_width(self)].
  (forall x:(int,int) farray. forall y:(int,int) farray.
  ((forall i:int. (((0 <= i) and (i <  h_width(self))) -> ((0 <= (x[i])) and
   ((x[i]) <  2)))) ->
  ((forall i:int. (((0 <= i) and (i <  h_range(self))) -> ((0 <= (y[i])) and
   ((y[i]) <  2)))) ->
  (forall i:int. (((0 <= i) and (i <  h_width(self))) ->
  ((((h_basis_ket(self)[x])[y])[i]) <  2)))))))

axiom ppsqtinvariant4 :
  (forall self:pps [h_angle(self)| h_basis_ket(self)| h_range(self)|
  h_width(self)].
  (forall x:(int,int) farray. forall xqt:(int,int) farray.
  forall y:(int,int) farray. forall yqt:(int,int) farray.
  ((forall i:int. (((0 <= i) and (i <  h_width(self))) ->
   ((x[i]) = (xqt[i])))) ->
  ((forall i:int. (((0 <= i) and (i <  h_range(self))) ->
   ((y[i]) = (yqt[i])))) ->
  (forall i:int. (((0 <= i) and (i <  h_width(self))) ->
  ((((h_basis_ket(self)[x])[y])[i]) = (((h_basis_ket(self)[xqt])[yqt])[i]))))))))

axiom ppsqtinvariant5 :
  (forall self:pps [h_angle(self)| h_basis_ket(self)| h_range(self)|
  h_width(self)].
  (forall x:(int,int) farray. forall xqt:(int,int) farray.
  forall y:(int,int) farray. forall yqt:(int,int) farray.
  ((forall i:int. (((0 <= i) and (i <  h_width(self))) ->
   ((x[i]) = (xqt[i])))) ->
  ((forall i:int. (((0 <= i) and (i <  h_range(self))) ->
   ((y[i]) = (yqt[i])))) ->
  (((h_angle(self)[x])[y]) = ((h_angle(self)[xqt])[yqt]))))))

logic inv_func_int : (int,int) farray, int -> (int,int) farray

axiom inv_func_intqtdef :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) -> (inv_func_int(f, n) = inverse1(f, to_fset(0, n),
  to_fset(0, n)))))

axiom inv_func_intqtspec :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) -> p_bijective(inv_func_int(f, n), to_fset(0, n), to_fset(0,
  n))))

axiom inv_func_intqtspec1 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. (((0 <= a) and (a <  n)) -> (0 <= (inv_func_int(f, n)[a]))))))

axiom inv_func_intqtspec2 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. (((0 <= a) and (a <  n)) -> ((inv_func_int(f, n)[a]) <  n)))))

axiom inv_func_intqtspec3 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. (((0 <= a) and (a <  n)) -> ((f[(inv_func_int(f,
  n)[a])]) = a)))))

axiom inv_func_intqtspec4 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. (((0 <= a) and (a <  n)) -> ((inv_func_int(f,
  n)[(f[a])]) = a)))))

axiom inv_func_intqtspec5 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. forall b:int. (((0 <= a) and (a <  n)) -> (((0 <= b) and
  (b <  n)) -> (((f[a]) = b) -> ((inv_func_int(f, n)[b]) = a)))))))

axiom binary_h_basis_ket :
  (forall p:pps. forall w:int. forall x:(int,int) farray.
  forall y:(int,int) farray. ((w = h_width(p)) -> (binary_l(x, w) ->
  (binary_l(y, h_range(p)) -> binary_l(((h_basis_ket(p)[x])[y]), w)))))

logic swap_int : int, int, int -> (int,int) farray

axiom swap_intqtdef :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall i:int. ((swap_int(t1, t2,
  n)[i]) = (if (i = t1) then t2 else (if (i = t2) then t1 else i)))))))

axiom swap_intqtspec :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall a:int. ((a = t1) -> ((swap_int(t1, t2, n)[a]) = t2))))))

axiom swap_intqtspec1 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall a:int. ((a = t2) -> ((swap_int(t1, t2, n)[a]) = t1))))))

axiom swap_intqtspec2 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall a:int. ((not (a = t1)) -> ((not (a = t2)) -> ((swap_int(t1, t2,
  n)[a]) = a)))))))

axiom swap_intqtspec3 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> p_bijective(swap_int(t1, t2, n), to_fset(0,
  n), to_fset(0, n)))))

axiom swap_intqtspec4 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((inv_func_int(swap_int(t1, t2,
  n), n)[i]) = (swap_int(t1, t2, n)[i])))))))

logic build_pps : int, int,
  ((int,int) farray,((int,int) farray,(int,int) farray) farray) farray,
  ((int,int) farray,((int,int) farray,angle) farray) farray -> pps

axiom build_ppsqtspec :
  (forall w:int. forall r:int.
  forall k:((int,int) farray,((int,int) farray,(int,int) farray) farray) farray.
  forall a:((int,int) farray,((int,int) farray,angle) farray) farray.
  ((0 <= w) -> ((0 <= r) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((0 <= (x[i])) and
    ((x[i]) <  2)))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((0 <= (y[i])) and
    ((y[i]) <  2)))) ->
   (forall i:int. (((0 <= i) and (i <  w)) -> ((0 <= (((k[x])[y])[i])) and
   ((((k[x])[y])[i]) <  2))))))) ->
  ((forall x:(int,int) farray. forall xqt:(int,int) farray.
   forall y:(int,int) farray. forall yqt:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((x[i]) = (xqt[i])))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((y[i]) = (yqt[i])))) ->
   (forall i:int. (((0 <= i) and (i <  w)) ->
   ((((k[x])[y])[i]) = (((k[xqt])[yqt])[i]))))))) ->
  ((forall x:(int,int) farray. forall xqt:(int,int) farray.
   forall y:(int,int) farray. forall yqt:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((x[i]) = (xqt[i])))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((y[i]) = (yqt[i])))) ->
   (((a[x])[y]) = ((a[xqt])[yqt]))))) ->
  (h_width(build_pps(w, r, k, a)) = w)))))))

axiom build_ppsqtspec1 :
  (forall w:int. forall r:int.
  forall k:((int,int) farray,((int,int) farray,(int,int) farray) farray) farray.
  forall a:((int,int) farray,((int,int) farray,angle) farray) farray.
  ((0 <= w) -> ((0 <= r) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((0 <= (x[i])) and
    ((x[i]) <  2)))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((0 <= (y[i])) and
    ((y[i]) <  2)))) ->
   (forall i:int. (((0 <= i) and (i <  w)) -> ((0 <= (((k[x])[y])[i])) and
   ((((k[x])[y])[i]) <  2))))))) ->
  ((forall x:(int,int) farray. forall xqt:(int,int) farray.
   forall y:(int,int) farray. forall yqt:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((x[i]) = (xqt[i])))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((y[i]) = (yqt[i])))) ->
   (forall i:int. (((0 <= i) and (i <  w)) ->
   ((((k[x])[y])[i]) = (((k[xqt])[yqt])[i]))))))) ->
  ((forall x:(int,int) farray. forall xqt:(int,int) farray.
   forall y:(int,int) farray. forall yqt:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((x[i]) = (xqt[i])))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((y[i]) = (yqt[i])))) ->
   (((a[x])[y]) = ((a[xqt])[yqt]))))) ->
  (h_range(build_pps(w, r, k, a)) = r)))))))

axiom build_ppsqtspec2 :
  (forall w:int. forall r:int.
  forall k:((int,int) farray,((int,int) farray,(int,int) farray) farray) farray.
  forall a:((int,int) farray,((int,int) farray,angle) farray) farray.
  ((0 <= w) -> ((0 <= r) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((0 <= (x[i])) and
    ((x[i]) <  2)))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((0 <= (y[i])) and
    ((y[i]) <  2)))) ->
   (forall i:int. (((0 <= i) and (i <  w)) -> ((0 <= (((k[x])[y])[i])) and
   ((((k[x])[y])[i]) <  2))))))) ->
  ((forall x:(int,int) farray. forall xqt:(int,int) farray.
   forall y:(int,int) farray. forall yqt:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((x[i]) = (xqt[i])))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((y[i]) = (yqt[i])))) ->
   (forall i:int. (((0 <= i) and (i <  w)) ->
   ((((k[x])[y])[i]) = (((k[xqt])[yqt])[i]))))))) ->
  ((forall x:(int,int) farray. forall xqt:(int,int) farray.
   forall y:(int,int) farray. forall yqt:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((x[i]) = (xqt[i])))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((y[i]) = (yqt[i])))) ->
   (((a[x])[y]) = ((a[xqt])[yqt]))))) ->
  (forall x:bitvec. forall y:bitvec.
  (forall i:int. ((length(x) = w) -> ((length(y) = r) -> (((0 <= i) and
  (i <  w)) -> ((((h_basis_ket(build_pps(w, r, k,
  a))[value(x)])[value(y)])[i]) = ((((k[value(x)])[value(y)])[i]) % 2)))))))))))))

axiom build_ppsqtspec3 :
  (forall w:int. forall r:int.
  forall k:((int,int) farray,((int,int) farray,(int,int) farray) farray) farray.
  forall a:((int,int) farray,((int,int) farray,angle) farray) farray.
  ((0 <= w) -> ((0 <= r) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((0 <= (x[i])) and
    ((x[i]) <  2)))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((0 <= (y[i])) and
    ((y[i]) <  2)))) ->
   (forall i:int. (((0 <= i) and (i <  w)) -> ((0 <= (((k[x])[y])[i])) and
   ((((k[x])[y])[i]) <  2))))))) ->
  ((forall x:(int,int) farray. forall xqt:(int,int) farray.
   forall y:(int,int) farray. forall yqt:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((x[i]) = (xqt[i])))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((y[i]) = (yqt[i])))) ->
   (forall i:int. (((0 <= i) and (i <  w)) ->
   ((((k[x])[y])[i]) = (((k[xqt])[yqt])[i]))))))) ->
  ((forall x:(int,int) farray. forall xqt:(int,int) farray.
   forall y:(int,int) farray. forall yqt:(int,int) farray.
   ((forall i:int. (((0 <= i) and (i <  w)) -> ((x[i]) = (xqt[i])))) ->
   ((forall i:int. (((0 <= i) and (i <  r)) -> ((y[i]) = (yqt[i])))) ->
   (((a[x])[y]) = ((a[xqt])[yqt]))))) ->
  (forall x:bitvec. forall y:bitvec. ((length(x) = w) -> ((length(y) = r) ->
  (((h_angle(build_pps(w, r, k,
  a))[value(x)])[value(y)]) = ((a[value(x)])[value(y)])))))))))))

logic build_pps_bv : int, int, (bitvec,(bitvec,bitvec) farray) farray,
  (bitvec,(bitvec,angle) farray) farray -> pps

logic result41 : (int,int) farray -> (int,int) farray

logic result42 : (int,int) farray -> (int,int) farray

logic result43 : int, int,
  (bitvec,(bitvec,bitvec) farray) farray -> ((int,int) farray,((int,int) farray,(int,int) farray) farray) farray

logic result44 : (int,int) farray -> (int,int) farray

logic result45 : (int,int) farray -> (int,int) farray

logic result46 : int, int,
  (bitvec,(bitvec,angle) farray) farray -> ((int,int) farray,((int,int) farray,angle) farray) farray

axiom resultqtdef48 :
  (forall x:(int,int) farray. forall i:int.
  ((result41(x)[i]) = ((x[i]) % 2)))

axiom resultqtdef49 :
  (forall y:(int,int) farray. forall i:int.
  ((result42(y)[i]) = ((y[i]) % 2)))

axiom resultqtdef50 :
  (forall w:int. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray. forall x:(int,int) farray.
  forall y:(int,int) farray. (((result43(w, r,
  k)[x])[y]) = value(((k[make_bv(result41(x), w)])[make_bv(result42(y),
  r)]))))

axiom resultqtdef51 :
  (forall x:(int,int) farray. forall i:int.
  ((result44(x)[i]) = ((x[i]) % 2)))

axiom resultqtdef52 :
  (forall y:(int,int) farray. forall i:int.
  ((result45(y)[i]) = ((y[i]) % 2)))

axiom resultqtdef53 :
  (forall w:int. forall r:int.
  forall a:(bitvec,(bitvec,angle) farray) farray. forall x:(int,int) farray.
  forall y:(int,int) farray. (((result46(w, r,
  a)[x])[y]) = ((a[make_bv(result44(x), w)])[make_bv(result45(y), r)])))

axiom build_pps_bvqtdef :
  (forall w:int. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= w) -> ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = w) -> ((length(y) = r) ->
   (length(((k[x])[y])) = w)))) ->
  (build_pps_bv(w, r, k, a) = build_pps(w, r, result43(w, r, k), result46(w,
  r, a)))))))

axiom build_pps_bvqtspec :
  (forall w:int. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= w) -> ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = w) -> ((length(y) = r) ->
   (length(((k[x])[y])) = w)))) ->
  (h_width(build_pps_bv(w, r, k, a)) = w)))))

axiom build_pps_bvqtspec1 :
  (forall w:int. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= w) -> ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = w) -> ((length(y) = r) ->
   (length(((k[x])[y])) = w)))) ->
  (h_range(build_pps_bv(w, r, k, a)) = r)))))

axiom build_pps_bvqtspec2 :
  (forall w:int. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= w) -> ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = w) -> ((length(y) = r) ->
   (length(((k[x])[y])) = w)))) ->
  (forall x:bitvec. forall y:bitvec.
  (forall i:int. ((length(x) = w) -> ((length(y) = r) -> (((0 <= i) and
  (i <  w)) -> ((((h_basis_ket(build_pps_bv(w, r, k,
  a))[value(x)])[value(y)])[i]) = (value(((k[x])[y]))[i])))))))))))

axiom build_pps_bvqtspec3 :
  (forall w:int. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= w) -> ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = w) -> ((length(y) = r) ->
   (length(((k[x])[y])) = w)))) ->
  (forall x:bitvec. forall y:bitvec. ((length(x) = w) -> ((length(y) = r) ->
  (((h_angle(build_pps_bv(w, r, k,
  a))[value(x)])[value(y)]) = ((a[x])[y])))))))))

logic h_basis_ket_bv : pps, bitvec, bitvec -> bitvec

axiom h_basis_ket_bvqtdef :
  (forall h:pps. forall x:bitvec. forall y:bitvec.
  ((length(x) = h_width(h)) -> ((length(y) = h_range(h)) ->
  (h_basis_ket_bv(h, x, y) = make_bv(((h_basis_ket(h)[value(x)])[value(y)]),
  h_width(h))))))

axiom h_basis_ket_bvqtspec :
  (forall h:pps. forall x:bitvec. forall y:bitvec.
  ((length(x) = h_width(h)) -> ((length(y) = h_range(h)) ->
  (length(h_basis_ket_bv(h, x, y)) = h_width(h)))))

axiom h_basis_ket_bvqtspec1 :
  (forall h:pps. forall x:bitvec. forall y:bitvec.
  ((length(x) = h_width(h)) -> ((length(y) = h_range(h)) ->
  (forall i:int. (((0 <= i) and (i <  h_width(h))) ->
  ((value(h_basis_ket_bv(h, x,
  y))[i]) = (((h_basis_ket(h)[value(x)])[value(y)])[i])))))))

logic h_angle_bv : pps, bitvec, bitvec -> angle

axiom h_angle_bvqtdef :
  (forall h:pps. forall x:bitvec. forall y:bitvec.
  ((length(x) = h_width(h)) -> ((length(y) = h_range(h)) -> (h_angle_bv(h, x,
  y) = ((h_angle(h)[value(x)])[value(y)])))))

axiom pps_ket_bound :
  (forall h:pps. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. (((0 <= i) and (i <  h_width(h))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  h_width(h))) -> ((0 <= (x[i1])) and
   ((x[i1]) <  2)))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  h_range(h))) -> ((0 <= (y[i1])) and
   ((y[i1]) <  2)))) ->
  (0 <= (((h_basis_ket(h)[x])[y])[i]))))))

axiom pps_ket_bound1 :
  (forall h:pps. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. (((0 <= i) and (i <  h_width(h))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  h_width(h))) -> ((0 <= (x[i1])) and
   ((x[i1]) <  2)))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  h_range(h))) -> ((0 <= (y[i1])) and
   ((y[i1]) <  2)))) ->
  ((((h_basis_ket(h)[x])[y])[i]) <  2)))))

axiom low_pps_ket_bound :
  (forall h:pps. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. (((0 <= i) and (i <  h_width(h))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  h_width(h))) -> ((0 <= (x[i1])) and
   ((x[i1]) <  2)))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  h_range(h))) -> ((0 <= (y[i1])) and
   ((y[i1]) <  2)))) ->
  (0 <= (((h_basis_ket(h)[x])[y])[i]))))))

axiom high_pps_ket_bound :
  (forall h:pps. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. (((0 <= i) and (i <  h_width(h))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  h_width(h))) -> ((0 <= (x[i1])) and
   ((x[i1]) <  2)))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  h_range(h))) -> ((0 <= (y[i1])) and
   ((y[i1]) <  2)))) ->
  ((((h_basis_ket(h)[x])[y])[i]) <  2)))))

logic pps_apply_basis : pps, bitvec -> complex matrix

logic result47 : pps, bitvec -> (bitvec,complex matrix) farray

axiom resultqtdef54 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. ((result47(h,
  x)[y]) = infix_asdtdt(ang_exp(((h_angle(h)[value(x)])[value(y)])),
  bv_to_ket(make_bv(((h_basis_ket(h)[value(x)])[value(y)]), h_width(h))))))

axiom pps_apply_basisqtdef :
  (forall h:pps. forall x:bitvec. ((length(x) = h_width(h)) ->
  (pps_apply_basis(h, x) = infix_asdtdt(pow_inv_sqrt_2(h_range(h)),
  ket_sum_l(n_bvs(h_range(h)), result47(h, x), h_width(h))))))

logic fc397 : pps, bitvec, int -> (bitvec,complex) farray

axiom fcqtdef398 :
  (forall h:pps. forall x:bitvec. forall i:int. forall y:bitvec. ((fc397(h,
  x, i)[y]) = infix_asdt(ang_exp(((h_angle(h)[value(x)])[value(y)])),
  indic(bv_to_int(make_bv(((h_basis_ket(h)[value(x)])[value(y)]),
  h_width(h))), i))))

axiom pps_apply_basisqtspec :
  (forall h:pps. forall x:bitvec. ((length(x) = h_width(h)) ->
  is_a_ket_l(pps_apply_basis(h, x), h_width(h))))

axiom pps_apply_basisqtspec1 :
  (forall h:pps. forall x:bitvec. ((length(x) = h_width(h)) ->
  (forall i:int. (((0 <= i) and (i <  power(2, h_width(h)))) ->
  (get(pps_apply_basis(h, x), i, 0) = infix_asdt(pow_inv_sqrt_2(h_range(h)),
  sum(n_bvs(h_range(h)), fc397(h, x, i))))))))

logic fc398 : pps, bitvec, bitvec -> (bitvec,complex) farray

logic fc399 : pps, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef399 :
  (forall h:pps. forall x:bitvec. forall z:bitvec. forall y:bitvec.
  ((fc398(h, x,
  z)[y]) = infix_asdt(ang_exp(((h_angle(h)[value(x)])[value(y)])),
  indic(h_basis_ket_bv(h, x, y), z))))

axiom fcqtdef400 :
  (forall h:pps. forall x:bitvec. forall z:bitvec. ((fc399(h,
  x)[z]) = infix_asdtdt(infix_asdt(pow_inv_sqrt_2(h_range(h)),
  sum(n_bvs(h_range(h)), fc398(h, x, z))), ket(h_width(h), bv_to_int(z)))))

axiom pps_apply_basis_decomp :
  (forall h:pps. forall x:bitvec. ((length(x) = h_width(h)) ->
  (pps_apply_basis(h, x) = ket_sum_l(n_bvs(h_width(h)), fc399(h, x),
  h_width(h)))))

axiom pps_apply_basis_ket_l :
  (forall h:pps. forall x:bitvec. forall l:int. ((length(x) = l) ->
  ((l = h_width(h)) -> is_a_ket_l(pps_apply_basis(h, x), l))))

axiom pps_apply_basis_ket_length :
  (forall h:pps. forall x:bitvec. forall l:int. ((length(x) = l) ->
  ((l = h_width(h)) -> (ket_length(pps_apply_basis(h, x)) = l))))

logic fc400 : pps, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef401 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. ((fc400(h,
  x)[y]) = infix_asdtdt(ang_exp(h_angle_bv(h, x, y)),
  bv_to_ket(h_basis_ket_bv(h, x, y)))))

axiom pps_apply_basis_bv :
  (forall h:pps. forall x:bitvec. ((length(x) = h_width(h)) ->
  (pps_apply_basis(h, x) = infix_asdtdt(pow_inv_sqrt_2(h_range(h)),
  ket_sum_l(n_bvs(h_range(h)), fc400(h, x), h_width(h))))))

logic fc401 : pps, bitvec, int -> (bitvec,complex) farray

axiom fcqtdef402 :
  (forall h:pps. forall x:bitvec. forall i:int. forall y:bitvec. ((fc401(h,
  x, i)[y]) = infix_asdt(ang_exp(h_angle_bv(h, x, y)),
  indic(h_basis_ket_bv(h, x, y), int_to_bv(i, h_width(h))))))

axiom pps_apply_basis_value :
  (forall h:pps. forall x:bitvec. ((length(x) = h_width(h)) ->
  (forall i:int. (((0 <= i) and (i <  power(2, h_width(h)))) ->
  (get(pps_apply_basis(h, x), i, 0) = infix_asdt(pow_inv_sqrt_2(h_range(h)),
  sum(n_bvs(h_range(h)), fc401(h, x, i))))))))

logic fc402 : pps, bitvec, int -> (bitvec,bool) farray

logic fc403 : pps, bitvec -> (bitvec,complex) farray

axiom fcqtdef403 :
  (forall h:pps. forall x:bitvec. forall k:int. forall y:bitvec. (((fc402(h,
  x, k)[y]) = true) -> (h_basis_ket_bv(h, x, y) = int_to_bv(k, h_width(h)))))

axiom fcqtdef404 :
  (forall h:pps. forall x:bitvec. forall k:int. forall y:bitvec.
  ((h_basis_ket_bv(h, x, y) = int_to_bv(k, h_width(h))) -> ((fc402(h, x,
  k)[y]) = true)))

axiom fcqtdef405 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. ((fc403(h,
  x)[y]) = ang_exp(((h_angle(h)[value(x)])[value(y)]))))

axiom pps_apply_basis_value_filter :
  (forall h:pps. forall x:bitvec. forall k:int. ((length(x) = h_width(h)) ->
  (((0 <= k) and (k <  power(2, h_width(h)))) -> (get(pps_apply_basis(h, x),
  k, 0) = infix_asdt(pow_inv_sqrt_2(h_range(h)),
  sum(my_filter(n_bvs(h_range(h)), fc402(h, x, k)), fc403(h, x)))))))

logic fc404 : pps, bitvec, int -> (bitvec,bool) farray

logic fc405 : pps, bitvec -> (bitvec,complex) farray

axiom fcqtdef406 :
  (forall h:pps. forall x:bitvec. forall k:int. forall y:bitvec. (((fc404(h,
  x, k)[y]) = true) -> (h_basis_ket_bv(h, x, y) = int_to_bv(k, h_width(h)))))

axiom fcqtdef407 :
  (forall h:pps. forall x:bitvec. forall k:int. forall y:bitvec.
  ((h_basis_ket_bv(h, x, y) = int_to_bv(k, h_width(h))) -> ((fc404(h, x,
  k)[y]) = true)))

axiom fcqtdef408 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. ((fc405(h,
  x)[y]) = ang_exp(((h_angle(h)[value(x)])[value(y)]))))

axiom pps_apply_basis_value_filter_gen :
  (forall h:pps. forall x:bitvec. ((length(x) = h_width(h)) ->
  (forall k:int. (((0 <= k) and (k <  power(2, h_width(h)))) ->
  (get(pps_apply_basis(h, x), k, 0) = infix_asdt(pow_inv_sqrt_2(h_range(h)),
  sum(my_filter(n_bvs(h_range(h)), fc404(h, x, k)), fc405(h, x))))))))

logic fc406 : pps, bitvec, bitvec -> (bitvec,complex matrix) farray

logic fc407 : pps, bitvec, int -> (bitvec,complex matrix) farray

axiom fcqtdef409 :
  (forall h:pps. forall x:bitvec. forall z:bitvec. forall t:bitvec.
  ((fc406(h, x, z)[t]) = infix_asdtdt(get(pps_apply_basis(h, x),
  bv_to_int(concat(z, t)), 0), bv_to_ket(concat(z, t)))))

axiom fcqtdef410 :
  (forall h:pps. forall x:bitvec. forall s:int. forall z:bitvec. ((fc407(h,
  x, s)[z]) = ket_sum_l(n_bvs((h_width(h) - s)), fc406(h, x, z),
  h_width(h))))

axiom pps_apply_basis_ht :
  (forall h:pps. forall x:bitvec. forall s:int. ((length(x) = h_width(h)) ->
  (((1 <= s) and (s <= h_width(h))) -> (pps_apply_basis(h,
  x) = ket_sum_l(n_bvs(s), fc407(h, x, s), h_width(h))))))

logic pps_apply : pps, complex matrix -> complex matrix

logic result48 : pps, complex matrix -> (bitvec,complex matrix) farray

axiom resultqtdef55 :
  (forall h:pps. forall x:complex matrix. forall y:bitvec. ((result48(h,
  x)[y]) = (if (length(y) = h_width(h)) then infix_asdtdt(get(x,
  bv_to_int(y), 0), pps_apply_basis(h, y)) else x)))

axiom pps_applyqtdef :
  (forall h:pps. forall x:complex matrix. (is_a_ket_l(x, h_width(h)) ->
  (pps_apply(h, x) = ket_sum_l(n_bvs(h_width(h)), result48(h, x),
  h_width(h)))))

axiom pps_applyqtspec :
  (forall h:pps. forall x:complex matrix. (is_a_ket_l(x, h_width(h)) ->
  is_a_ket_l(pps_apply(h, x), h_width(h))))

logic fc408 : pps, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef411 :
  (forall h:pps. forall x:complex matrix. forall y:bitvec. ((fc408(h,
  x)[y]) = infix_asdtdt(get(x, bv_to_int(y), 0), pps_apply_basis(h, y))))

axiom get_pps_apply :
  (forall h:pps. forall x:complex matrix. (is_a_ket_l(x, h_width(h)) ->
  (pps_apply(h, x) = ket_sum_l(n_bvs(h_width(h)), fc408(h, x), h_width(h)))))

axiom rewrite_pps_apply_basis :
  (forall h:pps. forall x:complex matrix. (is_a_ket_l(x, h_width(h)) ->
  (is_a_ket_basis_elt(x) -> (pps_apply(h, x) = pps_apply_basis(h,
  ket_to_bv(x))))))

logic fc409 : pps, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef412 :
  (forall h:pps. forall x:complex matrix. forall y:bitvec. ((fc409(h,
  x)[y]) = infix_asdtdt(ang_exp(((h_angle(h)[value(ket_to_bv(x))])[value(y)])),
  bv_to_ket(make_bv(((h_basis_ket(h)[value(ket_to_bv(x))])[value(y)]),
  h_width(h))))))

axiom rewrite_pps_apply_basis_ :
  (forall h:pps. forall x:complex matrix. (is_a_ket_l(x, h_width(h)) ->
  (is_a_ket_basis_elt(x) -> (pps_apply(h,
  x) = infix_asdtdt(pow_inv_sqrt_2(h_range(h)), ket_sum_l(n_bvs(h_range(h)),
  fc409(h, x), h_width(h)))))))

axiom rewrite_pps_apply_basis_rev :
  (forall h:pps. forall x:bitvec. ((length(x) = h_width(h)) ->
  (pps_apply_basis(h, x) = pps_apply(h, bv_to_ket(x)))))

logic fc410 : pps, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef413 :
  (forall h:pps. forall x:complex matrix. forall z:bitvec. ((fc410(h,
  x)[z]) = infix_asdtdt(get(x, bv_to_int(z), 0), pps_apply(h,
  bv_to_ket(z)))))

axiom pps_apply_decomp :
  (forall h:pps. forall x:complex matrix. (is_a_ket_l(x, h_width(h)) ->
  (pps_apply(h, x) = ket_sum_l(n_bvs(h_width(h)), fc410(h, x), h_width(h)))))

axiom pps_apply_scal :
  (forall h:pps. forall x:complex matrix. forall a:complex. (is_a_ket_l(x,
  h_width(h)) -> (pps_apply(h, infix_asdtdt(a, x)) = infix_asdtdt(a,
  pps_apply(h, x)))))

axiom pps_apply_add :
  (forall h:pps. forall x:complex matrix. forall y:complex matrix.
  forall l:int. (is_a_ket_l(x, h_width(h)) -> (is_a_ket_l(y, h_width(h)) ->
  ((l = h_width(h)) -> (pps_apply(h, add_ket_l(x, y,
  l)) = add_ket_l(pps_apply(h, x), pps_apply(h, y), l))))))

logic fc411 : pps, ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef414 :
  (forall h:pps. forall f:('a,complex matrix) farray. forall e:'a. ((fc411(h,
  f)[e]) = pps_apply(h, (f[e]))))

axiom pps_apply_sum :
  (forall h:pps. forall s:'a set. forall f:('a,complex matrix) farray.
  forall l:int. ((1 <= cardinal(s)) ->
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), h_width(h)))) ->
  ((l = h_width(h)) -> (pps_apply(h, ket_sum_l(s, f, l)) = ket_sum_l(s,
  fc411(h, f), l))))))

logic pps_id : pps

axiom pps_idqtdef : (h_width(pps_id) = 1)

axiom pps_idqtdef1 : (h_range(pps_id) = 0)

axiom pps_idqtdef2 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_id)[x])[y])[i]) = (x[i]))))

axiom pps_idqtdef3 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_id)[x])[y]) = ang_zero))

logic pps_swap : int, int, int -> pps

axiom pps_swapqtdef :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (h_width(pps_swap(t1, t2,
  n)) = n)))))

axiom pps_swapqtdef1 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (h_range(pps_swap(t1, t2,
  n)) = 0)))))

axiom pps_swapqtdef2 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_swap(t1, t2,
  n))[x])[y])[i]) = (x[(swap_int(t1, t2, n)[i])]))))))))

axiom pps_swapqtdef3 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_swap(t1, t2, n))[x])[y]) = ang_zero))))))

logic pps_phase : int -> pps

axiom pps_phaseqtspec : (forall k:int. (h_width(pps_phase(k)) = 1))

axiom pps_phaseqtspec1 : (forall k:int. (h_range(pps_phase(k)) = 0))

axiom pps_phaseqtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_phase(k))[x])[y])[i]) = (x[i])))))

axiom pps_phaseqtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_phase(k))[x])[y]) = infix_sldtsl(1, k))))

logic pps_rz : int -> pps

axiom pps_rzqtspec : (forall k:int. (h_width(pps_rz(k)) = 1))

axiom pps_rzqtspec1 : (forall k:int. (h_range(pps_rz(k)) = 0))

axiom pps_rzqtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_rz(k))[x])[y])[i]) = (x[i])))))

axiom pps_rzqtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_rz(k))[x])[y]) = infix_sldtsl((x[0]), k))))

function incr_abs(k: int) : int = (if (0 <= k) then (k + 1) else (k - 1))

axiom incr_absqtspec : (forall k:int. ((0 <= k) -> (incr_abs(k) = (k + 1))))

axiom incr_absqtspec1 : (forall k:int. ((k <  0) -> (incr_abs(k) = (k - 1))))

function decr_abs(k: int) : int = (if (k <= 0) then (k + 1) else (k - 1))

axiom decr_absqtspec : (forall k:int. ((0 <  k) -> (decr_abs(k) = (k - 1))))

axiom decr_absqtspec1 : (forall k:int. ((k <= 0) -> (decr_abs(k) = (k + 1))))

axiom decr_absqtspec2 :
  (forall k:int. ((not (k = 0)) -> ((not (k = (- 1))) ->
  (incr_abs(decr_abs(k)) = k))))

axiom decr_inc : (forall k:int. (decr_abs(incr_abs(k)) = k))

logic pps_rx : int -> pps

axiom pps_rxqtspec : (forall k:int. (h_width(pps_rx(k)) = 1))

axiom pps_rxqtspec1 : (forall k:int. (h_range(pps_rx(k)) = 2))

axiom pps_rxqtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_rx(k))[x])[y])[i]) = (y[1])))))

axiom pps_rxqtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_rx(k))[x])[y]) = ang_add(ang_add(infix_sldtsl(((x[0]) * (y[0])),
  1), infix_sldtsl(((y[0]) * (y[1])), 1)), phase_inv_(((y[0]) - 1),
  infix_sldtsl(1, incr_abs(k)))))))

logic pps_xx : pps

axiom pps_xxqtdef : (h_width(pps_xx) = 1)

axiom pps_xxqtdef1 : (h_range(pps_xx) = 0)

axiom pps_xxqtdef2 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_xx)[x])[y])[i]) = (1 - (x[i])))))

axiom pps_xxqtdef3 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_xx)[x])[y]) = infix_sldtsl(1, 0)))

logic pps_yy : pps

axiom pps_yyqtdef : (h_width(pps_yy) = 1)

axiom pps_yyqtdef1 : (h_range(pps_yy) = 0)

axiom pps_yyqtdef2 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_yy)[x])[y])[i]) = (1 - (x[i])))))

axiom pps_yyqtdef3 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_yy)[x])[y]) = phase_inv_((x[0]), infix_sldtsl(1, 2))))

logic pps_zz : pps

axiom pps_zzqtdef : (h_width(pps_zz) = 1)

axiom pps_zzqtdef1 : (h_range(pps_zz) = 0)

axiom pps_zzqtdef2 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_zz)[x])[y])[i]) = (x[i]))))

axiom pps_zzqtdef3 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_zz)[x])[y]) = infix_sldtsl((x[0]), 1)))

logic pps_ry : int -> pps

axiom pps_ryqtspec : (forall k:int. (h_width(pps_ry(k)) = 1))

axiom pps_ryqtspec1 : (forall k:int. (h_range(pps_ry(k)) = 2))

axiom pps_ryqtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_ry(k))[x])[y])[i]) = (y[1])))))

axiom pps_ryqtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_ry(k))[x])[y]) = ang_add(ang_add(ang_add(infix_sldtsl(((x[0]) * (y[0])),
  1), infix_sldtsl(((y[0]) * (y[1])), 1)), phase_inv_(((y[0]) - 1),
  infix_sldtsl(1, incr_abs(k)))), infix_sldtsl(((y[1]) - (x[0])), 2)))))

logic pps_rz_b : int -> pps

axiom pps_rz_bqtspec : (forall k:int. (h_width(pps_rz_b(k)) = 1))

axiom pps_rz_bqtspec1 : (forall k:int. (h_range(pps_rz_b(k)) = 0))

axiom pps_rz_bqtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_rz_b(k))[x])[y])[i]) = (x[i])))))

axiom pps_rz_bqtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_rz_b(k))[x])[y]) = phase_inv_(((x[0]) - 1), infix_sldtsl(1,
  incr_abs(k))))))

logic pps_hadamard : pps

axiom pps_hadamardqtdef : (h_width(pps_hadamard) = 1)

axiom pps_hadamardqtdef1 : (h_range(pps_hadamard) = 1)

axiom pps_hadamardqtdef2 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_hadamard)[x])[y])[i]) = (y[i]))))

axiom pps_hadamardqtdef3 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_hadamard)[x])[y]) = infix_sldtsl(((x[0]) * (y[0])), 1)))

logic pps_cnot : int, int, int -> pps

axiom pps_cnotqtdef :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (t = c)) -> (h_width(pps_cnot(c, t,
  n)) = n)))))

axiom pps_cnotqtdef1 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (t = c)) -> (h_range(pps_cnot(c, t,
  n)) = 0)))))

axiom pps_cnotqtdef2 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (t = c)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = t)) -> ((((h_basis_ket(pps_cnot(c, t,
  n))[x])[y])[i]) = (x[i])))))))))

axiom pps_cnotqtdef3 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (t = c)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t) -> ((((h_basis_ket(pps_cnot(c, t,
  n))[x])[y])[i]) = (((x[c]) * (1 - (x[t]))) + ((1 - (x[c])) * (x[t])))))))))))

axiom pps_cnotqtdef4 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (t = c)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_cnot(c, t, n))[x])[y]) = infix_sldtsl(1, 0)))))))

logic pps_toffoli : int, int, int, int -> pps

axiom pps_toffoliqtdef :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (t = c1)) -> ((not (t = c2)) -> ((not (c2 = c1)) ->
  (h_width(pps_toffoli(c1, c2, t, n)) = n))))))))

axiom pps_toffoliqtdef1 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (t = c1)) -> ((not (t = c2)) -> ((not (c2 = c1)) ->
  (h_range(pps_toffoli(c1, c2, t, n)) = 0))))))))

axiom pps_toffoliqtdef2 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (t = c1)) -> ((not (t = c2)) -> ((not (c2 = c1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = t)) -> ((((h_basis_ket(pps_toffoli(c1, c2, t,
  n))[x])[y])[i]) = (x[i]))))))))))))

axiom pps_toffoliqtdef3 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (t = c1)) -> ((not (t = c2)) -> ((not (c2 = c1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t) -> ((((h_basis_ket(pps_toffoli(c1, c2, t,
  n))[x])[y])[i]) = ((((x[c1]) * (x[c2])) * (1 - (x[i]))) + ((x[t]) * (1 - ((x[c1]) * (x[c2]))))))))))))))))

axiom pps_toffoliqtdef4 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (t = c1)) -> ((not (t = c2)) -> ((not (c2 = c1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_toffoli(c1, c2, t, n))[x])[y]) = infix_sldtsl(1, 0))))))))))

logic pps_fredkin : int, int, int, int -> pps

axiom pps_fredkinqtdef :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (h_width(pps_fredkin(c, t1, t2, n)) = n))))))))

axiom pps_fredkinqtdef1 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (h_range(pps_fredkin(c, t1, t2, n)) = 0))))))))

axiom pps_fredkinqtdef2 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t1) -> ((((h_basis_ket(pps_fredkin(c, t1, t2,
  n))[x])[y])[i]) = (((x[c]) * (x[t2])) + ((1 - (x[c])) * (x[t1]))))))))))))))

axiom pps_fredkinqtdef3 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t2) -> ((((h_basis_ket(pps_fredkin(c, t1, t2,
  n))[x])[y])[i]) = (((x[c]) * (x[t1])) + ((1 - (x[c])) * (x[t2]))))))))))))))

axiom pps_fredkinqtdef4 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = t1)) -> ((not (i = t2)) ->
  ((((h_basis_ket(pps_fredkin(c, t1, t2, n))[x])[y])[i]) = (x[i])))))))))))))

axiom pps_fredkinqtdef5 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_fredkin(c, t1, t2, n))[x])[y]) = infix_sldtsl(1, 0))))))))))

axiom pps_id_apply_basis :
  (forall x:bitvec. ((length(x) = 1) -> (pps_apply_basis(pps_id,
  x) = bv_to_ket(x))))

axiom pps_swap_apply_basis :
  (forall x:bitvec. ((length(x) = 2) -> (pps_apply_basis(pps_swap(0, 1, 2),
  x) = ket(2,
  (if (bv_to_int(x) = 0) then 0 else (if (bv_to_int(x) = 1) then 2 else (if (bv_to_int(x) = 2) then 1 else 3)))))))

axiom pps_cnot_apply_basis :
  (forall x:bitvec. ((length(x) = 2) -> (pps_apply_basis(pps_cnot(0, 1, 2),
  x) = ket(2,
  (if (bv_to_int(x) = 0) then 0 else (if (bv_to_int(x) = 1) then 1 else (if (bv_to_int(x) = 2) then 3 else 2)))))))

axiom pps_phase_apply_basis :
  (forall k:int. forall x:bitvec. ((length(x) = 1) ->
  (pps_apply_basis(pps_phase(k), x) = infix_asdtdt(ang_exp(infix_sldtsl(1,
  k)), bv_to_ket(x)))))

axiom pps_rz_apply_basis :
  (forall k:int. forall x:bitvec. ((length(x) = 1) ->
  (pps_apply_basis(pps_rz(k),
  x) = infix_asdtdt(ang_exp(infix_sldtsl((value(x)[0]), k)), bv_to_ket(x)))))

axiom pps_hadamard_apply_basis :
  (forall x:bitvec. ((length(x) = 1) -> (pps_apply_basis(pps_hadamard,
  x) = infix_asdtdt(pow_inv_sqrt_2(1), add_ket_l(ket(1, 0),
  infix_asdtdt(ang_exp(infix_sldtsl((value(x)[0]), 1)), ket(1, 1)), 1)))))

logic pps_seq : pps, pps -> pps

logic fc412 : pps, (int,int) farray -> (int,int) farray

logic fc413 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef415 :
  (forall h1:pps. forall y:(int,int) farray. forall k:int. ((fc412(h1,
  y)[k]) = (y[(k + h_range(h1))])))

axiom fcqtdef416 :
  (forall h1:pps. forall y:(int,int) farray. forall k:int. ((fc413(h1,
  y)[k]) = (y[(k + h_range(h1))])))

axiom pps_seqqtspec :
  (forall h1:pps. forall h2:pps. ((h_width(h1) = h_width(h2)) ->
  (h_width(pps_seq(h1, h2)) = h_width(h1))))

axiom pps_seqqtspec1 :
  (forall h1:pps. forall h2:pps. ((h_width(h1) = h_width(h2)) ->
  (h_range(pps_seq(h1, h2)) = (h_range(h1) + h_range(h2)))))

axiom pps_seqqtspec2 :
  (forall h1:pps. forall h2:pps. ((h_width(h1) = h_width(h2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_seq(h1,
  h2))[x])[y])[i]) = (((h_basis_ket(h2)[((h_basis_ket(h1)[x])[y])])[fc412(h1,
  y)])[i]))))))

axiom pps_seqqtspec3 :
  (forall h1:pps. forall h2:pps. ((h_width(h1) = h_width(h2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_seq(h1, h2))[x])[y]) = ang_add(((h_angle(h1)[x])[y]),
  ((h_angle(h2)[((h_basis_ket(h1)[x])[y])])[fc413(h1, y)]))))))

logic pps_place : pps, int, int -> pps

logic fc414 : int, (int,int) farray -> (int,int) farray

logic fc415 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef417 :
  (forall t:int. forall x:(int,int) farray. forall j:int. ((fc414(t,
  x)[j]) = (x[(j + t)])))

axiom fcqtdef418 :
  (forall t:int. forall x:(int,int) farray. forall j:int. ((fc415(t,
  x)[j]) = (x[(j + t)])))

axiom pps_placeqtspec :
  (forall h:pps. forall t:int. forall n:int. ((0 <= t) ->
  (((t + h_width(h)) <= n) -> (h_width(pps_place(h, t, n)) = n))))

axiom pps_placeqtspec1 :
  (forall h:pps. forall t:int. forall n:int. ((0 <= t) ->
  (((t + h_width(h)) <= n) -> (h_range(pps_place(h, t, n)) = h_range(h)))))

axiom pps_placeqtspec2 :
  (forall h:pps. forall t:int. forall n:int. ((0 <= t) ->
  (((t + h_width(h)) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_place(h, t,
  n))[x])[y])[i]) = (if ((t <= i) and
  (i <  (t + h_width(h)))) then (((h_basis_ket(h)[fc414(t,
  x)])[y])[(i - t)]) else (x[i]))))))))

axiom pps_placeqtspec3 :
  (forall h:pps. forall t:int. forall n:int. ((0 <= t) ->
  (((t + h_width(h)) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_place(h, t, n))[x])[y]) = ((h_angle(h)[fc415(t, x)])[y]))))))

logic result49 : complex -> (int,(int,complex) farray) farray

axiom resultqtdef56 :
  (forall x:complex. forall i:int. forall us:int.
  (((result49(x)[i])[us]) = (if (i = 0) then t_real_part(x) else t_im_part(x))))

function complex_as_a_vector(x: complex) : complex matrix = make_f(2, 1,
  result49(x))

axiom complex_as_a_vectorqtspec :
  (forall x:complex. is_a_ket_l(complex_as_a_vector(x), 1))

axiom complex_as_a_vectorqtspec1 :
  (forall x:complex. (ket_norm_l(complex_as_a_vector(x), 1) = modulus(x)))

logic sin : complex -> complex

axiom sinqtdef :
  (forall x:complex. (real_(x) -> (sin(x) = t_im_part(exp(infix_asdt(im,
  x))))))

axiom sinqtspec : (forall x:complex. (real_(x) -> real_(sin(x))))

logic cos : complex -> complex

axiom cosqtdef :
  (forall x:complex. (real_(x) -> (cos(x) = t_real_part(exp(infix_asdt(im,
  x))))))

axiom cosqtspec : (forall x:complex. (real_(x) -> real_(cos(x))))

axiom euler_real_r :
  (forall x:complex. (real_(x) ->
  (cos(x) = r_to_c(real_part(exp(infix_asdt(im, x)))))))

axiom euler_im_r :
  (forall x:complex. (real_(x) -> (sin(x) = r_to_c(im_part(exp(infix_asdt(im,
  x)))))))

axiom cos_zero : (cos(c_zero) = c_one)

axiom cos_half_pi : (cos(infix_sldt(pi, infix_pldt(c_one, c_one))) = c_zero)

axiom cos_quarter_pi : (cos(infix_sldt(pi,
  i_to_c(4))) = infix_sldt(square_rt(infix_pldt(c_one, c_one)),
  infix_pldt(c_one, c_one)))

axiom cos_pi : (cos(pi) = prefix_mndt(c_one))

axiom sin_zero : (sin(c_zero) = c_zero)

axiom sin_half_pi : (sin(infix_sldt(pi, infix_pldt(c_one, c_one))) = c_one)

axiom sin_ang_exp :
  (forall x:complex. (real_(x) ->
  (sin(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  x)) = t_im_part(ang_exp(real_to_ang(x))))))

axiom cos_ang_exp :
  (forall x:complex. (real_(x) ->
  (cos(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  x)) = t_real_part(ang_exp(real_to_ang(x))))))

axiom sin_ang_exp_ :
  (forall x:complex. (real_(x) ->
  (sin(x) = t_im_part(ang_exp(real_to_ang(infix_sldt(x,
  infix_asdt(infix_pldt(c_one, c_one), pi))))))))

axiom cos_ang_exp_ :
  (forall x:complex. (real_(x) ->
  (cos(x) = t_real_part(ang_exp(real_to_ang(infix_sldt(x,
  infix_asdt(infix_pldt(c_one, c_one), pi))))))))

axiom cos_sin_square_add :
  (forall x:complex. (real_(x) -> (infix_pldt(cpower(cos(x), 2),
  cpower(sin(x), 2)) = c_one)))

axiom c_one_minus_sin_square :
  (forall x:complex. (real_(x) -> (infix_mndt(c_one, cpower(sin(x),
  2)) = cpower(cos(x), 2))))

axiom c_one_minus_cos_square :
  (forall x:complex. (real_(x) -> (infix_mndt(c_one, cpower(cos(x),
  2)) = cpower(sin(x), 2))))

function cos_ang(theta: angle) : complex = cos(infix_asdt(ang_meas(theta),
  infix_asdt(infix_pldt(c_one, c_one), pi)))

axiom cos_angqtspec :
  (forall theta:angle. (cos_ang(theta) = t_real_part(ang_exp(theta))))

function sin_ang(theta: angle) : complex = sin(infix_asdt(ang_meas(theta),
  infix_asdt(infix_pldt(c_one, c_one), pi)))

axiom sin_angqtspec :
  (forall theta:angle. (sin_ang(theta) = t_im_part(ang_exp(theta))))

axiom euler_moivre_cos :
  (forall theta:angle. (cos_ang(theta) = infix_asdt(infix_sldt(c_one,
  infix_pldt(c_one, c_one)), infix_pldt(ang_exp(theta),
  ang_exp(ang_inv(theta))))))

axiom euler_moivre_cos_rev :
  (forall theta:angle. (infix_pldt(ang_exp(theta),
  ang_exp(ang_inv(theta))) = infix_asdt(infix_pldt(c_one, c_one),
  cos_ang(theta))))

axiom euler_moivre_cos_int :
  (forall k:int. forall n:int. (cos_ang(infix_sldtsl(k,
  n)) = infix_asdt(infix_sldt(c_one, infix_pldt(c_one, c_one)),
  infix_pldt(ang_exp(infix_sldtsl(k, n)), ang_exp(infix_sldtsl((-k), n))))))

axiom euler_moivre_cos_rev_int :
  (forall k:int. forall n:int. (infix_pldt(ang_exp(infix_sldtsl(k, n)),
  ang_exp(infix_sldtsl((-k), n))) = infix_asdt(infix_pldt(c_one, c_one),
  cos_ang(infix_sldtsl(k, n)))))

axiom euler_moivre_sin :
  (forall theta:angle. (sin_ang(theta) = infix_asdt(infix_sldt(c_one,
  infix_asdt(infix_pldt(c_one, c_one), im)), infix_mndt(ang_exp(theta),
  ang_exp(ang_inv(theta))))))

axiom euler_moivre_sin_rev :
  (forall theta:angle. (infix_mndt(ang_exp(theta),
  ang_exp(ang_inv(theta))) = infix_asdt(infix_asdt(infix_pldt(c_one, c_one),
  im), sin_ang(theta))))

axiom euler_moivre_sin_int :
  (forall k:int. forall n:int. (sin_ang(infix_sldtsl(k,
  n)) = infix_asdt(infix_sldt(c_one, infix_asdt(infix_pldt(c_one, c_one),
  im)), infix_mndt(ang_exp(infix_sldtsl(k, n)), ang_exp(infix_sldtsl((-k),
  n))))))

axiom euler_moivre_sin_rev_int :
  (forall k:int. forall n:int. (infix_mndt(ang_exp(infix_sldtsl(k, n)),
  ang_exp(infix_sldtsl((-k), n))) = infix_asdt(infix_asdt(infix_pldt(c_one,
  c_one), im), sin_ang(infix_sldtsl(k, n)))))

axiom euler_real :
  (forall x:complex. (real_(x) -> (cos(x) = t_real_part(exp(infix_asdt(im,
  x))))))

axiom euler_im :
  (forall x:complex. (real_(x) -> (sin(x) = t_im_part(exp(infix_asdt(im,
  x))))))

logic arc_cos_ang : complex -> angle

axiom arc_cos_angqtspec :
  (forall x:complex. ((infix_lseqdt(prefix_mndt(c_one), x) and
  infix_lseqdt(x, c_one)) -> (cos_ang(arc_cos_ang(x)) = x)))

axiom arc_cos_angqtspec1 :
  (forall x:complex. ((infix_lseqdt(prefix_mndt(c_one), x) and
  infix_lseqdt(x, c_one)) -> infix_lseqdt(c_zero, ang_meas(arc_cos_ang(x)))))

axiom arc_cos_angqtspec2 :
  (forall x:complex. ((infix_lseqdt(prefix_mndt(c_one), x) and
  infix_lseqdt(x, c_one)) -> infix_lseqdt(ang_meas(arc_cos_ang(x)),
  infix_sldt(c_one, infix_pldt(c_one, c_one)))))

axiom arc_cos_angqtspec3 :
  (forall x:complex. ((infix_lseqdt(prefix_mndt(c_one), x) and
  infix_lseqdt(x, c_one)) ->
  (forall t:angle. ((infix_lseqdt(c_zero, ang_meas(t)) and
  infix_lseqdt(ang_meas(t), infix_sldt(c_one, infix_pldt(c_one, c_one)))) ->
  ((cos_ang(t) = x) -> (t = arc_cos_ang(x)))))))

axiom set_arc_cos_ang_exp :
  (forall x:complex. forall o:angle. ((infix_lseqdt(prefix_mndt(c_one),
  x) and infix_lseqdt(x, c_one)) -> ((infix_lseqdt(c_zero, ang_meas(o)) and
  infix_lseqdt(ang_meas(o), infix_sldt(c_one, infix_pldt(c_one, c_one)))) ->
  ((cos_ang(o) = x) -> (arc_cos_ang(x) = o)))))

axiom arc_cos_ang_exp_plus_inv :
  (forall x:complex. ((infix_lseqdt(prefix_mndt(c_one), x) and
  infix_lseqdt(x, c_one)) -> (infix_pldt(ang_exp(arc_cos_ang(x)),
  ang_exp(ang_inv(arc_cos_ang(x)))) = infix_asdt(infix_pldt(c_one, c_one),
  x))))

axiom arc_cos_ang_add_inv :
  (forall x:complex. ((infix_lseqdt(prefix_mndt(c_one), x) and
  infix_lseqdt(x, c_one)) -> (ang_add(arc_cos_ang(x),
  ang_inv(arc_cos_ang(x))) = ang_zero)))

axiom ang_add_incr :
  (forall k:int. forall i:int. (ang_add(infix_sldtsl(i, incr_abs(k)),
  infix_sldtsl(i, incr_abs(k))) = infix_sldtsl(i, k)))

logic pps_cont : pps, int, int, int -> pps

logic fc416 : int, (int,int) farray -> (int,int) farray

logic fc417 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef419 :
  (forall t:int. forall x:(int,int) farray. forall j:int. ((fc416(t,
  x)[j]) = (x[(j + t)])))

axiom fcqtdef420 :
  (forall t:int. forall x:(int,int) farray. forall j:int. ((fc417(t,
  x)[j]) = (x[(j + t)])))

axiom pps_contqtspec :
  (forall h:pps. forall co:int. forall t:int. forall n:int. (((0 <= t) and
  (t <= (n - h_width(h)))) -> (((0 <= co) and (co <  n)) -> (((t <= co) ->
  ((t + h_width(h)) <= co)) -> (h_width(pps_cont(h, co, t, n)) = n)))))

axiom pps_contqtspec1 :
  (forall h:pps. forall co:int. forall t:int. forall n:int. (((0 <= t) and
  (t <= (n - h_width(h)))) -> (((0 <= co) and (co <  n)) -> (((t <= co) ->
  ((t + h_width(h)) <= co)) -> (h_range(pps_cont(h, co, t,
  n)) = h_range(h))))))

axiom pps_contqtspec2 :
  (forall h:pps. forall co:int. forall t:int. forall n:int. (((0 <= t) and
  (t <= (n - h_width(h)))) -> (((0 <= co) and (co <  n)) -> (((t <= co) ->
  ((t + h_width(h)) <= co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_cont(h, co, t,
  n))[x])[y])[i]) = (if (((x[co]) = 1) and ((t <= i) and
  (i <  (t + h_width(h))))) then (((h_basis_ket(h)[fc416(t,
  x)])[y])[(i - t)]) else (x[i])))))))))

axiom pps_contqtspec3 :
  (forall h:pps. forall co:int. forall t:int. forall n:int. (((0 <= t) and
  (t <= (n - h_width(h)))) -> (((0 <= co) and (co <  n)) -> (((t <= co) ->
  ((t + h_width(h)) <= co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_cont(h, co, t,
  n))[x])[y]) = ang_add(ang_mult_int(((h_angle(h)[fc417(t, x)])[y]),
  (x[co])), ang_mult_int(phase_inv_((y[0]),
  arc_cos_ang(pow_inv_sqrt_2(h_range(h)))), (1 - (x[co]))))))))))

axiom pps_apply_cont :
  (forall h:pps. forall co:int. forall t:int. forall n:int. (((0 <= t) and
  (t <= (n - h_width(h)))) -> (((0 <= co) and (co <  n)) -> (((t <= co) ->
  ((t + h_width(h)) <= co)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 0) ->
  (pps_apply_basis(pps_cont(h, co, t, n), bv) = bv_to_ket(bv)))))))))

axiom pps_apply_cont1 :
  (forall h:pps. forall co:int. forall t:int. forall n:int. (((0 <= t) and
  (t <= (n - h_width(h)))) -> (((0 <= co) and (co <  n)) -> (((t <= co) ->
  ((t + h_width(h)) <= co)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 1) ->
  (pps_apply_basis(pps_cont(h, co, t, n), bv) = pps_apply_basis(pps_place(h,
  t, n), bv)))))))))

axiom h_basis_ket_bv_seq :
  (forall h1:pps. forall h2:pps. forall x:bitvec. forall y:bitvec.
  ((h_width(h1) = h_width(h2)) -> ((length(x) = h_width(h1)) ->
  ((length(y) = (h_range(h1) + h_range(h2))) -> (h_basis_ket_bv(pps_seq(h1,
  h2), x, y) = h_basis_ket_bv(h2, h_basis_ket_bv(h1, x, hpart(y,
  h_range(h1))), tpart(y, h_range(h1))))))))

axiom h_angle_bv_seq :
  (forall h1:pps. forall h2:pps. forall x:bitvec. forall y:bitvec.
  ((h_width(h1) = h_width(h2)) -> ((length(x) = h_width(h1)) ->
  ((length(y) = (h_range(h1) + h_range(h2))) -> (h_angle_bv(pps_seq(h1, h2),
  x, y) = ang_add(h_angle_bv(h1, x, hpart(y, h_range(h1))), h_angle_bv(h2,
  h_basis_ket_bv(h1, x, hpart(y, h_range(h1))), tpart(y, h_range(h1)))))))))

logic pps_par : pps, pps -> pps

logic fc418 : pps, (int,int) farray -> (int,int) farray

logic fc419 : pps, (int,int) farray -> (int,int) farray

logic fc420 : pps, (int,int) farray -> (int,int) farray

logic fc421 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef421 :
  (forall h1:pps. forall x:(int,int) farray. forall k:int. ((fc418(h1,
  x)[k]) = (x[(k + h_width(h1))])))

axiom fcqtdef422 :
  (forall h1:pps. forall y:(int,int) farray. forall k:int. ((fc419(h1,
  y)[k]) = (y[(k + h_range(h1))])))

axiom fcqtdef423 :
  (forall h1:pps. forall x:(int,int) farray. forall k:int. ((fc420(h1,
  x)[k]) = (x[(k + h_width(h1))])))

axiom fcqtdef424 :
  (forall h1:pps. forall y:(int,int) farray. forall k:int. ((fc421(h1,
  y)[k]) = (y[(k + h_range(h1))])))

axiom pps_parqtspec :
  (forall h1:pps. forall h2:pps. (h_width(pps_par(h1,
  h2)) = (h_width(h1) + h_width(h2))))

axiom pps_parqtspec1 :
  (forall h1:pps. forall h2:pps. (h_range(pps_par(h1,
  h2)) = (h_range(h1) + h_range(h2))))

axiom pps_parqtspec2 :
  (forall h1:pps. forall h2:pps.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((((h_basis_ket(pps_par(h1,
  h2))[x])[y])[i]) = (if (i <  h_width(h1)) then (((h_basis_ket(h1)[x])[y])[i]) else (((h_basis_ket(h2)[fc418(h1,
  x)])[fc419(h1, y)])[(i - h_width(h1))]))))))

axiom pps_parqtspec3 :
  (forall h1:pps. forall h2:pps.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_par(h1, h2))[x])[y]) = ang_add(((h_angle(h1)[x])[y]),
  ((h_angle(h2)[fc420(h1, x)])[fc421(h1, y)])))))

axiom h_basis_ket_bv_par :
  (forall h1:pps. forall h2:pps. forall x:bitvec. forall y:bitvec.
  ((length(x) = (h_width(h1) + h_width(h2))) ->
  ((length(y) = (h_range(h1) + h_range(h2))) -> (h_basis_ket_bv(pps_par(h1,
  h2), x, y) = concat(h_basis_ket_bv(h1, hpart(x, h_width(h1)), hpart(y,
  h_range(h1))), h_basis_ket_bv(h2, tpart(x, h_width(h1)), tpart(y,
  h_range(h1))))))))

axiom h_angle_bv_par :
  (forall h1:pps. forall h2:pps. forall x:bitvec. forall y:bitvec.
  ((length(x) = (h_width(h1) + h_width(h2))) ->
  ((length(y) = (h_range(h1) + h_range(h2))) -> (h_angle_bv(pps_par(h1, h2),
  x, y) = ang_add(h_angle_bv(h1, hpart(x, h_width(h1)), hpart(y,
  h_range(h1))), h_angle_bv(h2, tpart(x, h_width(h1)), tpart(y,
  h_range(h1))))))))

axiom kron_to_ket_l :
  (forall x:complex matrix. forall l:int. ((0 <= l) ->
  (is_a_ket_l(kronecker(x, ket(1, 0)), (l + 1)) -> is_a_ket_l(x, l))))

logic pps_ancs : pps, int -> pps

logic fc422 : pps, int, (int,int) farray -> (int,int) farray

logic fc423 : pps, int, (int,int) farray -> (int,int) farray

axiom fcqtdef425 :
  (forall h1:pps. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc422(h1, i, x)[k]) = (if (k <  (h_width(h1) - i)) then (x[k]) else 0)))

axiom fcqtdef426 :
  (forall h1:pps. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc423(h1, i, x)[k]) = (if (k <  (h_width(h1) - i)) then (x[k]) else 0)))

axiom pps_ancsqtspec :
  (forall h1:pps. forall i:int. ((1 <= i) -> ((i <= h_width(h1)) ->
  (h_width(pps_ancs(h1, i)) = (h_width(h1) - i)))))

axiom pps_ancsqtspec1 :
  (forall h1:pps. forall i:int. ((1 <= i) -> ((i <= h_width(h1)) ->
  (h_range(pps_ancs(h1, i)) = h_range(h1)))))

axiom pps_ancsqtspec2 :
  (forall h1:pps. forall i:int. ((1 <= i) -> ((i <= h_width(h1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall ii:int. ((((h_basis_ket(pps_ancs(h1,
  i))[x])[y])[ii]) = (((h_basis_ket(h1)[fc422(h1, i, x)])[y])[ii])))))))

axiom pps_ancsqtspec3 :
  (forall h1:pps. forall i:int. ((1 <= i) -> ((i <= h_width(h1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(pps_ancs(h1, i))[x])[y]) = ((h_angle(h1)[fc423(h1, i, x)])[y]))))))

axiom h_basis_ket_bv_anc :
  (forall h:pps. forall x:bitvec. forall y:bitvec. forall i:int. ((1 <= i) ->
  ((i <= h_width(h)) -> ((length(x) = (h_width(h) - i)) ->
  ((length(y) = h_range(h)) -> (h_basis_ket_bv(pps_ancs(h, i), x,
  y) = hpart(h_basis_ket_bv(h, concat(x, int_to_bv(0, i)), y),
  (h_width(h) - i))))))))

axiom h_basis_ket_bv_anc_ :
  (forall h:pps. forall x:bitvec. forall y:bitvec. forall l:int.
  forall i:int. ((1 <= i) -> ((i <= h_width(h)) -> ((tpart(x,
  l) = int_to_bv(0, i)) -> ((length(x) = h_width(h)) ->
  ((l = (h_width(h) - i)) -> ((length(y) = h_range(h)) ->
  (h_basis_ket_bv(pps_ancs(h, i), hpart(x, l), y) = hpart(h_basis_ket_bv(h,
  x, y), (h_width(h) - i))))))))))

axiom h_angle_bv_anc :
  (forall h:pps. forall x:bitvec. forall y:bitvec. forall i:int. ((1 <= i) ->
  ((i <= h_width(h)) -> ((length(x) = (h_width(h) - i)) ->
  ((length(y) = h_range(h)) -> (h_angle_bv(pps_ancs(h, i), x,
  y) = h_angle_bv(h, concat(x, int_to_bv(0, i)), y)))))))

axiom h_angle_bv_anc_ :
  (forall h:pps. forall x:bitvec. forall y:bitvec. forall l:int.
  forall i:int. ((1 <= i) -> ((i <= h_width(h)) -> ((tpart(x,
  l) = int_to_bv(0, i)) -> ((length(x) = h_width(h)) ->
  ((l = (h_width(h) - i)) -> ((length(y) = h_range(h)) ->
  (h_angle_bv(pps_ancs(h, i), hpart(x, l), y) = h_angle_bv(h, x, y)))))))))

axiom kronecker_scalar_distr :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  (kronecker(infix_asdtdt(a, m), n) = infix_asdtdt(a, kronecker(m, n))))

axiom kronecker_scalar_distr_r :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  (kronecker(m, infix_asdtdt(a, n)) = infix_asdtdt(a, kronecker(m, n))))

axiom kronecker_scalar_distr_rev :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  (infix_asdtdt(a, kronecker(m, n)) = kronecker(infix_asdtdt(a, m), n)))

axiom kronecker_scalar_distr_rev_r :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  (infix_asdtdt(a, kronecker(m, n)) = kronecker(m, infix_asdtdt(a, n))))

axiom kronecker_scalars :
  (forall m:complex matrix. forall n:complex matrix. forall a:complex.
  forall b:complex. (kronecker(infix_asdtdt(a, m), infix_asdtdt(b,
  n)) = infix_asdtdt(infix_asdt(a, b), kronecker(m, n))))

logic mat_k_id : complex matrix, int -> complex matrix

axiom mat_k_idqtdef :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (mat_k_id(m,
  n) = kronecker(m, identity(n)))))

logic fc424 : complex matrix, int -> (int,(int,complex) farray) farray

axiom fcqtdef427 :
  (forall m:complex matrix. forall n:int. forall i:int. forall j:int.
  (((fc424(m, n)[i])[j]) = infix_asdt(indic((i % power(2, n)), (j % power(2,
  n))), get(m, (i / power(2, n)), (j / power(2, n))))))

axiom mat_k_idqtspec :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (mat_k_id(m,
  n) = make_f((rows(m) * power(2, n)), (columns(m) * power(2, n)), fc424(m,
  n)))))

axiom mat_k_id_values :
  (forall m:complex matrix. forall n:int. forall i:int. forall j:int.
  ((0 <= n) -> (((0 <= i) and (i <  (rows(m) * power(2, n)))) ->
  (((0 <= j) and (j <  (columns(m) * power(2, n)))) -> (get(mat_k_id(m, n),
  i, j) = infix_asdt(indic((i % power(2, n)), (j % power(2, n))), get(m,
  (i / power(2, n)), (j / power(2, n)))))))))

axiom mat_k_id_rows :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (rows(mat_k_id(m,
  n)) = (rows(m) * power(2, n)))))

axiom mat_k_id_columns :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (columns(mat_k_id(m,
  n)) = (columns(m) * power(2, n)))))

logic id_k_mat : complex matrix, int -> complex matrix

axiom id_k_matqtdef :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (id_k_mat(m,
  n) = kronecker(identity(n), m))))

logic fc425 : complex matrix -> (int,(int,complex) farray) farray

axiom fcqtdef428 :
  (forall m:complex matrix. forall i:int. forall j:int.
  (((fc425(m)[i])[j]) = infix_asdt(indic((i / rows(m)), (j / columns(m))),
  get(m, (i % rows(m)), (j % columns(m))))))

axiom id_k_matqtspec :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (id_k_mat(m,
  n) = make_f((rows(m) * power(2, n)), (columns(m) * power(2, n)),
  fc425(m)))))

axiom id_k_mat_values :
  (forall m:complex matrix. forall n:int. forall i:int. forall j:int.
  ((0 <= n) -> (((0 <= i) and (i <  (rows(m) * power(2, n)))) ->
  (((0 <= j) and (j <  (columns(m) * power(2, n)))) -> (get(id_k_mat(m, n),
  i, j) = infix_asdt(indic((i / rows(m)), (j / columns(m))), get(m,
  (i % rows(m)), (j % columns(m)))))))))

axiom id_k_mat_rows :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (rows(id_k_mat(m,
  n)) = (rows(m) * power(2, n)))))

axiom id_k_mat_columns :
  (forall m:complex matrix. forall n:int. ((0 <= n) -> (columns(id_k_mat(m,
  n)) = (columns(m) * power(2, n)))))

logic mat_prod_k_id : complex matrix, complex matrix, int -> complex matrix

axiom mat_prod_k_idqtdef :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (mat_prod_k_id(m, o,
  n) = kronecker(mat_mult(m, o), identity(n))))))

logic fc426 : complex matrix, complex matrix, int, int,
  int -> (int,complex) farray

logic fc427 : complex matrix, complex matrix,
  int -> (int,(int,complex) farray) farray

axiom fcqtdef429 :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  forall i:int. forall j:int. forall k:int. ((fc426(m, o, n, i,
  j)[k]) = infix_asdt(get(m, (i / power(2, n)), k), get(o, k, (j / power(2,
  n))))))

axiom fcqtdef430 :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  forall i:int. forall j:int. (((fc427(m, o,
  n)[i])[j]) = infix_asdt(indic((i % power(2, n)), (j % power(2, n))),
  ind_sum(fc426(m, o, n, i, j), 0, columns(m)))))

axiom mat_prod_k_idqtspec :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (mat_prod_k_id(m, o,
  n) = make_f((rows(m) * power(2, n)), (columns(o) * power(2, n)), fc427(m,
  o, n))))))

logic id_k_mat_prod : complex matrix, complex matrix, int -> complex matrix

axiom id_k_mat_prodqtdef :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (id_k_mat_prod(m, o,
  n) = kronecker(identity(n), mat_mult(m, o))))))

logic fc428 : complex matrix, complex matrix, int,
  int -> (int,complex) farray

logic fc429 : complex matrix,
  complex matrix -> (int,(int,complex) farray) farray

axiom fcqtdef431 :
  (forall m:complex matrix. forall o:complex matrix. forall i:int.
  forall j:int. forall k:int. ((fc428(m, o, i, j)[k]) = infix_asdt(get(m,
  (i % rows(m)), k), get(o, k, (j % columns(o))))))

axiom fcqtdef432 :
  (forall m:complex matrix. forall o:complex matrix. forall i:int.
  forall j:int. (((fc429(m, o)[i])[j]) = infix_asdt(indic((i / rows(m)),
  (j / columns(o))), ind_sum(fc428(m, o, i, j), 0, columns(m)))))

axiom id_k_mat_prodqtspec :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (id_k_mat_prod(m, o,
  n) = make_f((rows(m) * power(2, n)), (columns(o) * power(2, n)), fc429(m,
  o))))))

logic fc430 : int, int, (int,complex) farray -> (int,complex) farray

axiom fcqtdef433 :
  (forall v:int. forall p:int. forall g:(int,complex) farray. forall k:int.
  ((fc430(v, p, g)[k]) = infix_asdt(indic((k % v), p), (g[(k / v)]))))

axiom filter_sum_mod_indic :
  (forall v:int. forall n:int. forall p:int. forall g:(int,complex) farray.
  ((0 <  n) -> ((0 <  v) -> (((0 <= p) and (p <  v)) -> (sum(to_fset(0,
  (v * n)), fc430(v, p, g)) = sum(to_fset(0, n), g))))))

logic fc431 : int, int, (int,complex) farray -> (int,complex) farray

axiom fcqtdef434 :
  (forall v:int. forall p:int. forall g:(int,complex) farray. forall k:int.
  ((fc431(v, p, g)[k]) = infix_asdt((g[(k % v)]), indic((k / v), p))))

axiom filter_sum_indic_div :
  (forall v:int. forall n:int. forall p:int. forall g:(int,complex) farray.
  ((0 <  n) -> ((0 <  v) -> (((0 <= p) and (p <  n)) -> (sum(to_fset(0,
  (v * n)), fc431(v, p, g)) = sum(to_fset(0, v), g))))))

logic fc432 : int, int, (int,complex) farray -> (int,complex) farray

axiom fcqtdef435 :
  (forall v:int. forall p:int. forall g:(int,complex) farray. forall k:int.
  ((fc432(v, p, g)[k]) = infix_asdt(indic((k % v), p), (g[(k / v)]))))

axiom filtered_ind_sum_mod_indic :
  (forall v:int. forall n:int. forall p:int. forall g:(int,complex) farray.
  ((0 <  n) -> ((0 <  v) -> (((0 <= p) and (p <  v)) -> (ind_sum(fc432(v, p,
  g), 0, (v * n)) = ind_sum(g, 0, n))))))

logic fc433 : int, int, (int,complex) farray -> (int,complex) farray

axiom fcqtdef436 :
  (forall v:int. forall p:int. forall g:(int,complex) farray. forall k:int.
  ((fc433(v, p, g)[k]) = infix_asdt((g[(k % v)]), indic((k / v), p))))

axiom filtered_ind_sum_indic_div :
  (forall v:int. forall n:int. forall p:int. forall g:(int,complex) farray.
  ((0 <  n) -> ((0 <  v) -> (((0 <= p) and (p <  n)) -> (ind_sum(fc433(v, p,
  g), 0, (v * n)) = ind_sum(g, 0, v))))))

logic fc434 : complex matrix, complex matrix, int, int,
  int -> (int,complex) farray

axiom fcqtdef437 :
  (forall m:complex matrix. forall o:complex matrix. forall i:int.
  forall j:int. forall n:int. forall k:int. ((fc434(m, o, i, j,
  n)[k]) = infix_asdt(get(m, (i / power(2, n)), k), get(o, k, (j / power(2,
  n))))))

axiom prod_mat_k_id_pre :
  (forall m:complex matrix. forall o:complex matrix. forall i:int.
  forall j:int. forall n:int. ((0 <= n) -> ((columns(m) = rows(o)) ->
  (((0 <= i) and (i <  (rows(m) * power(2, n)))) -> (((0 <= j) and
  (j <  (columns(o) * power(2, n)))) -> (get(mat_mult(mat_k_id(m, n),
  mat_k_id(o, n)), i, j) = infix_asdt(indic((i % power(2, n)), (j % power(2,
  n))), ind_sum(fc434(m, o, i, j, n), 0, columns(m)))))))))

logic prod_mat_k_id : complex matrix, complex matrix, int -> complex matrix

axiom prod_mat_k_idqtdef :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (prod_mat_k_id(m, o,
  n) = mat_mult(mat_k_id(m, n), mat_k_id(o, n))))))

logic fc435 : complex matrix, complex matrix, int, int,
  int -> (int,complex) farray

logic fc436 : complex matrix, complex matrix,
  int -> (int,(int,complex) farray) farray

axiom fcqtdef438 :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  forall i:int. forall j:int. forall k:int. ((fc435(m, o, n, i,
  j)[k]) = infix_asdt(get(m, (i / power(2, n)), k), get(o, k, (j / power(2,
  n))))))

axiom fcqtdef439 :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  forall i:int. forall j:int. (((fc436(m, o,
  n)[i])[j]) = infix_asdt(indic((i % power(2, n)), (j % power(2, n))),
  ind_sum(fc435(m, o, n, i, j), 0, columns(m)))))

axiom prod_mat_k_idqtspec :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (prod_mat_k_id(m, o,
  n) = make_f((rows(m) * power(2, n)), (columns(o) * power(2, n)), fc436(m,
  o, n))))))

axiom prod_mat_k_id_dec :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (prod_mat_k_id(m, o,
  n) = mat_prod_k_id(m, o, n)))))

logic fc437 : complex matrix, complex matrix, int,
  int -> (int,complex) farray

axiom fcqtdef440 :
  (forall m:complex matrix. forall o:complex matrix. forall i:int.
  forall j:int. forall k:int. ((fc437(m, o, i, j)[k]) = infix_asdt(get(m,
  (i % rows(m)), k), get(o, k, (j % columns(o))))))

axiom k_id_prod_mat_pre :
  (forall m:complex matrix. forall o:complex matrix. forall i:int.
  forall j:int. forall n:int. ((0 <= n) -> ((columns(m) = rows(o)) ->
  (((0 <= i) and (i <  (rows(m) * power(2, n)))) -> (((0 <= j) and
  (j <  (columns(o) * power(2, n)))) -> (get(mat_mult(id_k_mat(m, n),
  id_k_mat(o, n)), i, j) = infix_asdt(indic((i / rows(m)), (j / columns(o))),
  ind_sum(fc437(m, o, i, j), 0, columns(m)))))))))

logic k_id_prod_mat : complex matrix, complex matrix, int -> complex matrix

axiom k_id_prod_matqtdef :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (k_id_prod_mat(m, o,
  n) = mat_mult(id_k_mat(m, n), id_k_mat(o, n))))))

logic fc438 : complex matrix, complex matrix, int,
  int -> (int,complex) farray

logic fc439 : complex matrix,
  complex matrix -> (int,(int,complex) farray) farray

axiom fcqtdef441 :
  (forall m:complex matrix. forall o:complex matrix. forall i:int.
  forall j:int. forall k:int. ((fc438(m, o, i, j)[k]) = infix_asdt(get(m,
  (i % rows(m)), k), get(o, k, (j % columns(o))))))

axiom fcqtdef442 :
  (forall m:complex matrix. forall o:complex matrix. forall i:int.
  forall j:int. (((fc439(m, o)[i])[j]) = infix_asdt(indic((i / rows(m)),
  (j / columns(o))), ind_sum(fc438(m, o, i, j), 0, columns(m)))))

axiom k_id_prod_matqtspec :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (k_id_prod_mat(m, o,
  n) = make_f((rows(m) * power(2, n)), (columns(o) * power(2, n)), fc439(m,
  o))))))

axiom k_id_prod_mat_dec :
  (forall m:complex matrix. forall o:complex matrix. forall n:int.
  ((0 <= n) -> ((columns(m) = rows(o)) -> (k_id_prod_mat(m, o,
  n) = id_k_mat_prod(m, o, n)))))

axiom split_ne_pre :
  (forall m1:complex matrix. forall m2:complex matrix. forall nc1:int.
  forall nc2:int. forall nr1:int. forall nr2:int. forall i:int. forall j:int.
  ((0 <= nr1) -> ((0 <= nr2) -> ((0 <= nc1) -> ((0 <= nc2) ->
  ((columns(m1) = power(2, nc1)) -> ((columns(m2) = power(2, nc2)) ->
  ((rows(m1) = power(2, nr1)) -> ((rows(m2) = power(2, nr2)) ->
  (((0 <= i) and (i <  (power(2, nr1) * power(2, nr2)))) -> (((0 <= j) and
  (j <  (power(2, nc1) * power(2, nc2)))) -> (get(mat_mult(id_k_mat(m1, nr2),
  mat_k_id(m2, nc1)), i, j) = get(kronecker(m2, m1), i, j)))))))))))))

axiom split_nw_pre :
  (forall m1:complex matrix. forall m2:complex matrix. forall nc1:int.
  forall nc2:int. forall nr1:int. forall nr2:int. forall i:int. forall j:int.
  ((0 <= nr1) -> ((0 <= nr2) -> ((0 <= nc1) -> ((0 <= nc2) ->
  ((columns(m1) = power(2, nc1)) -> ((columns(m2) = power(2, nc2)) ->
  ((rows(m1) = power(2, nr1)) -> ((rows(m2) = power(2, nr2)) ->
  (((0 <= i) and (i <  (power(2, nr1) * power(2, nr2)))) -> (((0 <= j) and
  (j <  (power(2, nc1) * power(2, nc2)))) -> (get(mat_mult(mat_k_id(m1, nr2),
  id_k_mat(m2, nc1)), i, j) = get(kronecker(m1, m2), i, j)))))))))))))

axiom split_ne :
  (forall m1:complex matrix. forall m2:complex matrix. forall nc1:int.
  forall nc2:int. forall nr1:int. forall nr2:int. ((0 <= nr1) ->
  ((0 <= nr2) -> ((0 <= nc1) -> ((0 <= nc2) -> ((columns(m1) = power(2,
  nc1)) -> ((columns(m2) = power(2, nc2)) -> ((rows(m1) = power(2, nr1)) ->
  ((rows(m2) = power(2, nr2)) -> (mat_mult(id_k_mat(m1, nr2), mat_k_id(m2,
  nc1)) = kronecker(m2, m1)))))))))))

axiom split_nw :
  (forall m1:complex matrix. forall m2:complex matrix. forall nc1:int.
  forall nc2:int. forall nr1:int. forall nr2:int. ((0 <= nr1) ->
  ((0 <= nr2) -> ((0 <= nc1) -> ((0 <= nc2) -> ((columns(m1) = power(2,
  nc1)) -> ((columns(m2) = power(2, nc2)) -> ((rows(m1) = power(2, nr1)) ->
  ((rows(m2) = power(2, nr2)) -> (mat_mult(mat_k_id(m1, nr2), id_k_mat(m2,
  nc1)) = kronecker(m1, m2)))))))))))

axiom shift_k_id :
  (forall m1:complex matrix. forall m2:complex matrix. forall nc1:int.
  forall nc2:int. forall nr1:int. forall nr2:int. ((0 <= nr1) ->
  ((0 <= nr2) -> ((0 <= nc1) -> ((0 <= nc2) -> ((columns(m1) = power(2,
  nc1)) -> ((columns(m2) = power(2, nc2)) -> ((rows(m1) = power(2, nr1)) ->
  ((rows(m2) = power(2, nr2)) -> (mat_mult(mat_k_id(m1, nr2), id_k_mat(m2,
  nc1)) = mat_mult(id_k_mat(m2, nr1), mat_k_id(m1, nc2))))))))))))

axiom kronecker_mult_commut :
  (forall a:complex matrix. forall b:complex matrix. forall c:complex matrix.
  forall d:complex matrix. forall ra:int. forall ca:int. forall cc:int.
  forall rb:int. forall cb:int. forall cd:int. ((0 <= ra) -> ((0 <= ca) ->
  ((0 <= cc) -> ((0 <= rb) -> ((0 <= cb) -> ((0 <= cd) ->
  ((rows(a) = power(2, ra)) -> ((columns(a) = power(2, ca)) ->
  ((rows(c) = power(2, ca)) -> ((columns(c) = power(2, cc)) ->
  ((rows(b) = power(2, rb)) -> ((columns(b) = power(2, cb)) ->
  ((rows(d) = power(2, cb)) -> ((columns(d) = power(2, cd)) ->
  (mat_mult(kronecker(a, b), kronecker(c, d)) = kronecker(mat_mult(a, c),
  mat_mult(b, d))))))))))))))))))

predicate isa_square(m: complex matrix) = (rows(m) = columns(m))

predicate pow2dim(m: complex matrix) =
  (exists i:int. exists j:int. ((rows(m) = power(2, i)) and
  (columns(m) = power(2, j))))

predicate pow2dim_square(m: complex matrix) =
  (exists i:int. ((rows(m) = power(2, i)) and (columns(m) = power(2, i))))

axiom pow_2dim_kets : (forall m:complex matrix. (is_a_ket(m) -> pow2dim(m)))

logic lnr : complex matrix -> int

axiom lnrqtspec :
  (forall m:complex matrix. (pow2dim(m) -> (rows(m) = power(2, lnr(m)))))

axiom lnrqtspec1 : (forall m:complex matrix. (pow2dim(m) -> (0 <= lnr(m))))

logic lnc : complex matrix -> int

axiom lncqtspec :
  (forall m:complex matrix. (pow2dim(m) -> (columns(m) = power(2, lnc(m)))))

axiom lncqtspec1 : (forall m:complex matrix. (pow2dim(m) -> (0 <= lnc(m))))

axiom get_pow2dim :
  (forall m:complex matrix. (pow2dim(m) ->
  (exists i:int. exists j:int. ((rows(m) = power(2, i)) and
  (columns(m) = power(2, j))))))

axiom set_pow2dim :
  (forall m:complex matrix.
  ((exists i:int. exists j:int. ((rows(m) = power(2, i)) and
   (columns(m) = power(2, j)))) ->
  pow2dim(m)))

axiom get_pow2dim_elt :
  (forall m:complex matrix. forall i:int. forall j:int. (pow2dim(m) ->
  ((lnr(m) = i) -> ((lnc(m) = j) -> (rows(m) = power(2, i))))))

axiom get_pow2dim_elt1 :
  (forall m:complex matrix. forall i:int. forall j:int. (pow2dim(m) ->
  ((lnr(m) = i) -> ((lnc(m) = j) -> (columns(m) = power(2, j))))))

axiom set_pow2dim_elt :
  (forall m:complex matrix. forall i:int. forall j:int. ((0 <= i) ->
  ((0 <= j) -> ((rows(m) = power(2, i)) -> ((columns(m) = power(2, j)) ->
  pow2dim(m))))))

axiom set_pow2dim_elt1 :
  (forall m:complex matrix. forall i:int. forall j:int. ((0 <= i) ->
  ((0 <= j) -> ((rows(m) = power(2, i)) -> ((columns(m) = power(2, j)) ->
  (lnr(m) = i))))))

axiom set_pow2dim_elt2 :
  (forall m:complex matrix. forall i:int. forall j:int. ((0 <= i) ->
  ((0 <= j) -> ((rows(m) = power(2, i)) -> ((columns(m) = power(2, j)) ->
  (lnc(m) = j))))))

logic mat_size : complex matrix -> int

axiom mat_sizeqtdef :
  (forall m:complex matrix. (isa_square(m) -> (mat_size(m) = rows(m))))

axiom mat_sizeqtspec :
  (forall m:complex matrix. (isa_square(m) -> (mat_size(m) = rows(m))))

axiom mat_sizeqtspec1 :
  (forall m:complex matrix. (isa_square(m) -> (mat_size(m) = columns(m))))

axiom get_square :
  (forall m:complex matrix. (isa_square(m) -> (rows(m) = columns(m))))

axiom set_square :
  (forall m:complex matrix. ((rows(m) = columns(m)) -> isa_square(m)))

axiom set_square_elt :
  (forall m:complex matrix. forall i:int. ((rows(m) = i) ->
  ((columns(m) = i) -> isa_square(m))))

axiom set_square_elt1 :
  (forall m:complex matrix. forall i:int. ((rows(m) = i) ->
  ((columns(m) = i) -> (mat_size(m) = i))))

axiom get_square_elt :
  (forall m:complex matrix. forall i:int. (isa_square(m) ->
  ((mat_size(m) = i) -> (rows(m) = i))))

axiom get_square_elt1 :
  (forall m:complex matrix. forall i:int. (isa_square(m) ->
  ((mat_size(m) = i) -> (columns(m) = i))))

axiom pow2dim_square_dec :
  (forall m:complex matrix. (isa_square(m) -> (pow2dim(m) ->
  pow2dim_square(m))))

axiom dec_pow2dim_square :
  (forall m:complex matrix. (pow2dim_square(m) -> isa_square(m)))

axiom dec_pow2dim_square1 :
  (forall m:complex matrix. (pow2dim_square(m) -> pow2dim(m)))

logic ln_size : complex matrix -> int

axiom ln_sizeqtdef :
  (forall m:complex matrix. (pow2dim_square(m) -> (ln_size(m) = lnr(m))))

axiom ln_sizeqtspec :
  (forall m:complex matrix. (pow2dim_square(m) -> (ln_size(m) = lnc(m))))

axiom ln_sizeqtspec1 :
  (forall m:complex matrix. (pow2dim_square(m) -> (rows(m) = power(2,
  ln_size(m)))))

axiom ln_sizeqtspec2 :
  (forall m:complex matrix. (pow2dim_square(m) -> (columns(m) = power(2,
  ln_size(m)))))

axiom set_ln_size_lnc :
  (forall m:complex matrix. forall i:int. (pow2dim_square(m) ->
  ((lnc(m) = i) -> (ln_size(m) = i))))

axiom set_ln_size_lnr :
  (forall m:complex matrix. forall i:int. (pow2dim_square(m) ->
  ((lnr(m) = i) -> (ln_size(m) = i))))

axiom set_ln_size_columns :
  (forall m:complex matrix. forall i:int. ((0 <= i) -> (pow2dim_square(m) ->
  ((columns(m) = power(2, i)) -> (ln_size(m) = i)))))

axiom set_ln_size_rows :
  (forall m:complex matrix. forall i:int. ((0 <= i) -> (pow2dim_square(m) ->
  ((rows(m) = power(2, i)) -> (ln_size(m) = i)))))

axiom set_pow2dim_square :
  (forall m:complex matrix.
  ((exists i:int. ((rows(m) = columns(m)) and (columns(m) = power(2, i)))) ->
  pow2dim_square(m)))

axiom set_pow2dim_square_elt :
  (forall m:complex matrix. forall i:int. ((0 <= i) ->
  (((rows(m) = columns(m)) and (columns(m) = power(2, i))) ->
  pow2dim_square(m))))

axiom set_pow2dim_square_elt1 :
  (forall m:complex matrix. forall i:int. ((0 <= i) ->
  (((rows(m) = columns(m)) and (columns(m) = power(2, i))) ->
  (ln_size(m) = i))))

axiom get_pow2dim_square_elt :
  (forall m:complex matrix. forall i:int. (pow2dim_square(m) ->
  ((ln_size(m) = i) -> (rows(m) = power(2, i)))))

axiom get_pow2dim_square_elt1 :
  (forall m:complex matrix. forall i:int. (pow2dim_square(m) ->
  ((ln_size(m) = i) -> (columns(m) = power(2, i)))))

axiom kronecker_mult_commut_p :
  (forall a:complex matrix. forall b:complex matrix. forall c:complex matrix.
  forall d:complex matrix. ((columns(a) = rows(c)) ->
  ((columns(b) = rows(d)) -> (pow2dim(a) -> (pow2dim(b) -> (pow2dim(c) ->
  (pow2dim(d) -> (mat_mult(kronecker(a, b), kronecker(c,
  d)) = kronecker(mat_mult(a, c), mat_mult(b, d))))))))))

axiom kronecker_mult_commut_p_quant :
  (forall a:complex matrix. forall b:complex matrix. (pow2dim(a) ->
  (pow2dim(b) ->
  (forall c:complex matrix. forall d:complex matrix.
  ((columns(a) = rows(c)) -> ((columns(b) = rows(d)) -> (pow2dim(c) ->
  (pow2dim(d) -> (mat_mult(kronecker(a, b), kronecker(c,
  d)) = kronecker(mat_mult(a, c), mat_mult(b, d)))))))))))

axiom kronecker_add_distr_l :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) ->
  (rows(kronecker(add_mat(m, n), o)) = (rows(m) * rows(o))))))

axiom kronecker_add_distr_l1 :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) ->
  (columns(kronecker(add_mat(m, n), o)) = (columns(m) * columns(o))))))

axiom kronecker_add_distr_l2 :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) -> (kronecker(add_mat(m,
  n), o) = add_mat(kronecker(m, o), kronecker(n, o))))))

axiom kronecker_add_distr_r :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) -> (kronecker(o,
  add_mat(m, n)) = add_mat(kronecker(o, m), kronecker(o, n))))))

axiom kronecker_add_distr_r1 :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) -> (rows(kronecker(o,
  add_mat(m, n))) = (rows(m) * rows(o))))))

axiom kronecker_add_distr_r2 :
  (forall m:complex matrix. forall n:complex matrix. forall o:complex matrix.
  ((rows(m) = rows(n)) -> ((columns(m) = columns(n)) -> (columns(kronecker(o,
  add_mat(m, n))) = (columns(m) * columns(o))))))

axiom kronecker_ket_add_distr_r :
  (forall m:complex matrix. forall n:complex matrix. forall x:complex matrix.
  forall l:int. forall l1:int. forall l2:int. ((l = (l1 + l2)) ->
  (is_a_ket_l(m, l1) -> (is_a_ket_l(n, l1) -> (is_a_ket_l(x, l2) ->
  (add_ket_l(kronecker(m, x), kronecker(n, x), l) = kronecker(add_ket_l(m, n,
  l1), x)))))))

logic fc440 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc441 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc442 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc443 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc444 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc445 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc446 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef443 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc440(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef444 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc441(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef445 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc442(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef446 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc443(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef447 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc444(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef448 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc445(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef449 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc446(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_sum_distr_l :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (columns(mat_sum(s, fc440(f, m))) = columns((fc441(f, m)[choose(s)]))))))

axiom kronecker_sum_distr_l1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (columns((fc442(f,
  m)[choose(s)])) = (columns(m) * columns((f[choose(s)])))))))

axiom kronecker_sum_distr_l2 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (rows(mat_sum(s, fc443(f, m))) = rows((fc444(f, m)[choose(s)]))))))

axiom kronecker_sum_distr_l3 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (rows((fc445(f, m)[choose(s)])) = (rows(m) * rows((f[choose(s)])))))))

axiom kronecker_sum_distr_l4 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (kronecker(mat_sum(s, f), m) = mat_sum(s, fc446(f, m))))))

logic fc447 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc448 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc449 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc450 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc451 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc452 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc453 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef450 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc447(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef451 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc448(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef452 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc449(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef453 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc450(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef454 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc451(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef455 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc452(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef456 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc453(f, m)[k]) = kronecker(m, (f[k]))))

axiom kronecker_sum_distr_r :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (columns(mat_sum(s, fc447(f, m))) = columns((fc448(f, m)[choose(s)]))))))

axiom kronecker_sum_distr_r1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (columns((fc449(f,
  m)[choose(s)])) = (columns(m) * columns((f[choose(s)])))))))

axiom kronecker_sum_distr_r2 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (rows(mat_sum(s, fc450(f, m))) = rows((fc451(f, m)[choose(s)]))))))

axiom kronecker_sum_distr_r3 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (rows((fc452(f, m)[choose(s)])) = (rows(m) * rows((f[choose(s)])))))))

axiom kronecker_sum_distr_r4 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. (constant_size(s, f) -> ((0 <  cardinal(s)) ->
  (kronecker(m, mat_sum(s, f)) = mat_sum(s, fc453(f, m))))))

logic fc454 : ('a,complex matrix) farray,
  complex -> ('a,complex matrix) farray

axiom fcqtdef457 :
  (forall f:('a,complex matrix) farray. forall a1:complex. forall k:'a.
  ((fc454(f, a1)[k]) = infix_asdtdt(a1, (f[k]))))

axiom mat_sum_scalar1 :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall a1:complex.
  (constant_size(s, f) -> ((0 <  cardinal(s)) -> (mat_sum(s, fc454(f,
  a1)) = infix_asdtdt(a1, mat_sum(s, f))))))

logic fc455 : ('a,complex matrix) farray, complex matrix,
  complex -> ('a,complex matrix) farray

logic fc456 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef458 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix.
  forall a1:complex. forall k:'a. ((fc455(f, m,
  a1)[k]) = kronecker(infix_asdtdt(a1, (f[k])), m)))

axiom fcqtdef459 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc456(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_sum_distr_sc :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall a1:complex. (constant_size(s, f) ->
  ((0 <  cardinal(s)) -> (mat_sum(s, fc455(f, m, a1)) = infix_asdtdt(a1,
  mat_sum(s, fc456(f, m)))))))

logic fc457 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc458 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef460 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc457(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef461 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc458(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_ket_sum_distr_l :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <  cardinal(s)) -> is_a_ket_l(ket_sum_l(s, fc457(f, m),
  (l1 + l2)), (l1 + l2))))))

axiom kronecker_ket_sum_distr_l1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <  cardinal(s)) -> (kronecker(ket_sum_l(s, f, l1),
  m) = ket_sum_l(s, fc458(f, m), (l1 + l2)))))))

logic fc459 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc460 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef462 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc459(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef463 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc460(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_ket_sum_distr_l_nol :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket(m) ->
  ((0 <  cardinal(s)) -> is_a_ket_l(ket_sum_l(s, fc459(f, m),
  (l1 + ket_length(m))), (l1 + ket_length(m)))))))

axiom kronecker_ket_sum_distr_l_nol1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket(m) ->
  ((0 <  cardinal(s)) -> (kronecker(ket_sum_l(s, f, l1), m) = ket_sum_l(s,
  fc460(f, m), (l1 + ket_length(m))))))))

logic fc461 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef464 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc461(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_ket_sum_distr_l_rew :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket(m) ->
  ((0 <  cardinal(s)) -> (kronecker(ket_sum_l(s, f, l1), m) = ket_sum_l(s,
  fc461(f, m), (l1 + ket_length(m))))))))

logic fc462 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc463 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef465 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc462(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef466 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc463(f, m)[k]) = kronecker(m, (f[k]))))

axiom kronecker_ket_sum_distr_r :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <  cardinal(s)) -> is_a_ket_l(ket_sum_l(s, fc462(f, m),
  (l1 + l2)), (l1 + l2))))))

axiom kronecker_ket_sum_distr_r1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <  cardinal(s)) -> (kronecker(m, ket_sum_l(s, f,
  l1)) = ket_sum_l(s, fc463(f, m), (l1 + l2)))))))

logic fc464 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc465 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef467 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc464(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef468 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc465(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_ket_sum_distr_l_rev :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <  cardinal(s)) -> is_a_ket_l(ket_sum_l(s, fc464(f, m),
  (l1 + l2)), (l1 + l2))))))

axiom kronecker_ket_sum_distr_l_rev1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <  cardinal(s)) -> (ket_sum_l(s, fc465(f, m),
  (l1 + l2)) = kronecker(ket_sum_l(s, f, l1), m))))))

logic fc466 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc467 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef469 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc466(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef470 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc467(f, m)[k]) = kronecker(m, (f[k]))))

axiom kronecker_ket_sum_distr_r_rev :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <  cardinal(s)) -> is_a_ket_l(ket_sum_l(s, fc466(f, m),
  (l1 + l2)), (l1 + l2))))))

axiom kronecker_ket_sum_distr_r_rev1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <  cardinal(s)) -> (ket_sum_l(s, fc467(f, m),
  (l1 + l2)) = kronecker(m, ket_sum_l(s, f, l1)))))))

logic fc468 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc469 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef471 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc468(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef472 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc469(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_ket_sum_distr_l_ :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <= l1) -> is_a_ket_l(ket_sum_l(s, fc468(f, m), (l1 + l2)),
  (l1 + l2))))))

axiom kronecker_ket_sum_distr_l_1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <= l1) -> (kronecker(ket_sum_l(s, f, l1), m) = ket_sum_l(s,
  fc469(f, m), (l1 + l2)))))))

logic fc470 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc471 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef473 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc470(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef474 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc471(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_ket_sum_distr_l_nol_ :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket(m) ->
  ((0 <= l1) -> is_a_ket_l(ket_sum_l(s, fc470(f, m), (l1 + ket_length(m))),
  (l1 + ket_length(m)))))))

axiom kronecker_ket_sum_distr_l_nol_1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket(m) ->
  ((0 <= l1) -> (kronecker(ket_sum_l(s, f, l1), m) = ket_sum_l(s, fc471(f,
  m), (l1 + ket_length(m))))))))

logic fc472 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef475 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc472(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_ket_sum_distr_l_rew_ :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket(m) ->
  ((0 <= l1) -> (kronecker(ket_sum_l(s, f, l1), m) = ket_sum_l(s, fc472(f,
  m), (l1 + ket_length(m))))))))

logic fc473 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc474 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef476 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc473(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef477 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc474(f, m)[k]) = kronecker(m, (f[k]))))

axiom kronecker_ket_sum_distr_r_ :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <= l1) -> is_a_ket_l(ket_sum_l(s, fc473(f, m), (l1 + l2)),
  (l1 + l2))))))

axiom kronecker_ket_sum_distr_r_1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <= l1) -> (kronecker(m, ket_sum_l(s, f, l1)) = ket_sum_l(s,
  fc474(f, m), (l1 + l2)))))))

logic fc475 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc476 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef478 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc475(f, m)[k]) = kronecker((f[k]), m)))

axiom fcqtdef479 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc476(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_ket_sum_distr_l_rev_ :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <= l1) -> is_a_ket_l(ket_sum_l(s, fc475(f, m), (l1 + l2)),
  (l1 + l2))))))

axiom kronecker_ket_sum_distr_l_rev_1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <= l1) -> (ket_sum_l(s, fc476(f, m),
  (l1 + l2)) = kronecker(ket_sum_l(s, f, l1), m))))))

logic fc477 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

logic fc478 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef480 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc477(f, m)[k]) = kronecker(m, (f[k]))))

axiom fcqtdef481 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc478(f, m)[k]) = kronecker(m, (f[k]))))

axiom kronecker_ket_sum_distr_r_rev_ :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <= l1) -> is_a_ket_l(ket_sum_l(s, fc477(f, m), (l1 + l2)),
  (l1 + l2))))))

axiom kronecker_ket_sum_distr_r_rev_1 :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <= l1) -> (ket_sum_l(s, fc478(f, m), (l1 + l2)) = kronecker(m,
  ket_sum_l(s, f, l1)))))))

logic fc479 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef482 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc479(f, m)[k]) = kronecker(m, (f[k]))))

axiom kronecker_ket_sum_distr_r_rew :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall l1:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket(m) ->
  ((0 <  cardinal(s)) -> (kronecker(m, ket_sum_l(s, f, l1)) = ket_sum_l(s,
  fc479(f, m), (l1 + ket_length(m))))))))

logic fc480 : ('a,complex matrix) farray,
  complex -> ('a,complex matrix) farray

axiom fcqtdef483 :
  (forall f:('a,complex matrix) farray. forall a1:complex. forall k:'a.
  ((fc480(f, a1)[k]) = infix_asdtdt(a1, (f[k]))))

axiom ket_sum_scalar :
  (forall s:'a set. forall f:('a,complex matrix) farray. forall a1:complex.
  forall l:int. ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l))) ->
  ((0 <  cardinal(s)) -> (ket_sum_l(s, fc480(f, a1), l) = infix_asdtdt(a1,
  ket_sum_l(s, f, l))))))

logic fc481 : ('a,complex matrix) farray, complex matrix,
  complex -> ('a,complex matrix) farray

logic fc482 : ('a,complex matrix) farray,
  complex matrix -> ('a,complex matrix) farray

axiom fcqtdef484 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix.
  forall a1:complex. forall k:'a. ((fc481(f, m,
  a1)[k]) = kronecker(infix_asdtdt(a1, (f[k])), m)))

axiom fcqtdef485 :
  (forall f:('a,complex matrix) farray. forall m:complex matrix. forall k:'a.
  ((fc482(f, m)[k]) = kronecker((f[k]), m)))

axiom kronecker_ket_sum_distr_sc :
  (forall s:'a set. forall f:('a,complex matrix) farray.
  forall m:complex matrix. forall a1:complex. forall l1:int. forall l2:int.
  ((forall e:'a. (mem(e, s) -> is_a_ket_l((f[e]), l1))) -> (is_a_ket_l(m,
  l2) -> ((0 <  cardinal(s)) -> (ket_sum_l(s, fc481(f, m, a1),
  (l1 + l2)) = infix_asdtdt(a1, ket_sum_l(s, fc482(f, m), (l1 + l2))))))))

logic fc483 : complex matrix,
  complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef486 :
  (forall m:complex matrix. forall n:complex matrix. forall x:bitvec.
  ((fc483(m, n)[x]) = infix_asdtdt(get(n, bv_to_int(x), 0), kronecker(m,
  bv_to_ket(x)))))

axiom kronecker_decomp_r :
  (forall m:complex matrix. forall n:complex matrix. forall lm:int.
  forall ln:int. (is_a_ket_l(m, lm) -> (is_a_ket_l(n, ln) -> (kronecker(m,
  n) = ket_sum_l(n_bvs(ln), fc483(m, n), (lm + ln))))))

logic fc484 : complex matrix,
  complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef487 :
  (forall m:complex matrix. forall n:complex matrix. forall x:bitvec.
  ((fc484(m, n)[x]) = infix_asdtdt(get(m, bv_to_int(x), 0),
  kronecker(bv_to_ket(x), n))))

axiom kronecker_decomp_l :
  (forall m:complex matrix. forall n:complex matrix. forall lm:int.
  forall ln:int. (is_a_ket_l(m, lm) -> (is_a_ket_l(n, ln) -> (kronecker(m,
  n) = ket_sum_l(n_bvs(lm), fc484(m, n), (lm + ln))))))

logic fc485 : int, (bitvec,complex matrix) farray,
  (bitvec,complex matrix) farray -> (bitvec,complex matrix) farray

axiom fcqtdef488 :
  (forall i:int. forall f:(bitvec,complex matrix) farray.
  forall g:(bitvec,complex matrix) farray. forall k:bitvec. ((fc485(i, f,
  g)[k]) = kronecker((f[hpart(k, i)]), (g[tpart(k, i)]))))

axiom kronecker_ket_sum_distr_double :
  (forall i:int. forall j:int. forall f:(bitvec,complex matrix) farray.
  forall g:(bitvec,complex matrix) farray. forall l1:int. forall l2:int.
  ((0 <= i) -> ((0 <= j) ->
  ((forall bv:bitvec. (mem(bv, n_bvs(i)) -> is_a_ket_l((f[bv]), l1))) ->
  ((forall bv:bitvec. (mem(bv, n_bvs(j)) -> is_a_ket_l((g[bv]), l2))) ->
  (kronecker(ket_sum_l(n_bvs(i), f, l1), ket_sum_l(n_bvs(j), g,
  l2)) = ket_sum_l(n_bvs((i + j)), fc485(i, f, g), (l1 + l2))))))))

axiom kronecker_add_null :
  (forall m:complex matrix. forall m1:complex matrix.
  forall m2:complex matrix. forall x:complex matrix.
  forall xqt:complex matrix. forall l1:int. forall l2:int. (is_a_ket_l(m,
  l1) -> (is_a_ket_l(m1, l1) -> (is_a_ket_l(m2, l1) -> (is_a_ket_l(x, l2) ->
  (is_a_ket_l(xqt, l2) -> (is_a_ket_basis_elt(x) ->
  (is_a_ket_basis_elt(xqt) -> ((not (ket_to_int(x) = ket_to_int(xqt))) ->
  ((kronecker(m, x) = add_ket_l(kronecker(m1, x), kronecker(m2, xqt),
  (l1 + l2))) -> null_mat(kronecker(m2, xqt))))))))))))

axiom kronecker_add_null1 :
  (forall m:complex matrix. forall m1:complex matrix.
  forall m2:complex matrix. forall x:complex matrix.
  forall xqt:complex matrix. forall l1:int. forall l2:int. (is_a_ket_l(m,
  l1) -> (is_a_ket_l(m1, l1) -> (is_a_ket_l(m2, l1) -> (is_a_ket_l(x, l2) ->
  (is_a_ket_l(xqt, l2) -> (is_a_ket_basis_elt(x) ->
  (is_a_ket_basis_elt(xqt) -> ((not (ket_to_int(x) = ket_to_int(xqt))) ->
  ((kronecker(m, x) = add_ket_l(kronecker(m1, x), kronecker(m2, xqt),
  (l1 + l2))) -> null_mat(m2)))))))))))

axiom kronecker_add_null2 :
  (forall m:complex matrix. forall m1:complex matrix.
  forall m2:complex matrix. forall x:complex matrix.
  forall xqt:complex matrix. forall l1:int. forall l2:int. (is_a_ket_l(m,
  l1) -> (is_a_ket_l(m1, l1) -> (is_a_ket_l(m2, l1) -> (is_a_ket_l(x, l2) ->
  (is_a_ket_l(xqt, l2) -> (is_a_ket_basis_elt(x) ->
  (is_a_ket_basis_elt(xqt) -> ((not (ket_to_int(x) = ket_to_int(xqt))) ->
  ((kronecker(m, x) = add_ket_l(kronecker(m1, x), kronecker(m2, xqt),
  (l1 + l2))) ->
  (forall xqt1:complex matrix. null_mat(kronecker(m2, xqt1)))))))))))))

axiom kronecker_injec_eq_left :
  (forall m:complex matrix. forall mqt:complex matrix.
  forall o:complex matrix. ((kronecker(m, o) = kronecker(mqt, o)) ->
  ((not null_mat(o)) -> (m = mqt))))

predicate pps_apply_equiv(h1: pps, h2: pps) =
  ((h_width(h1) = h_width(h2)) and
  (forall x:complex matrix. (is_a_ket_l(x, h_width(h1)) -> (pps_apply(h1,
  x) = pps_apply(h2, x)))))

axiom set_pps_apply_equiv :
  (forall h1:pps. forall h2:pps. ((h_width(h1) = h_width(h2)) ->
  ((forall x:bitvec. ((length(x) = h_width(h1)) -> (pps_apply_basis(h1,
   x) = pps_apply_basis(h2, x)))) ->
  pps_apply_equiv(h1, h2))))

axiom set_pps_apply_equiv_sim :
  (forall h1:pps. forall h2:pps. ((h_width(h1) = h_width(h2)) ->
  ((h_range(h1) = h_range(h2)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(h1))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h1))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h1))) ->
   ((((h_basis_ket(h1)[x])[y])[i]) = (((h_basis_ket(h2)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(h1))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h1))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((h_angle(h1)[x])[y]) = ((h_angle(h2)[x])[y]))))) ->
  pps_apply_equiv(h1, h2))))))

axiom get_pps_apply_equiv :
  (forall h1:pps. forall h2:pps. forall x:complex matrix.
  ((h_width(h1) = h_width(h2)) -> (pps_apply_equiv(h1, h2) -> (is_a_ket_l(x,
  h_width(h1)) -> (pps_apply(h1, x) = pps_apply(h2, x))))))

axiom get_pps_apply_basis_equiv :
  (forall h1:pps. forall h2:pps. forall x:bitvec.
  ((h_width(h1) = h_width(h2)) -> (pps_apply_equiv(h1, h2) ->
  ((length(x) = h_width(h1)) -> (pps_apply_basis(h1, x) = pps_apply_basis(h2,
  x))))))

axiom reflexive_pps_apply_equiv : (forall h:pps. pps_apply_equiv(h, h))

axiom commut_pps_apply_equiv :
  (forall h:pps. forall hqt:pps. (pps_apply_equiv(h, hqt) ->
  pps_apply_equiv(hqt, h)))

axiom transitive_pps_apply_equiv :
  (forall h:pps. forall hqt:pps. forall hqtqt:pps. (pps_apply_equiv(h,
  hqt) -> (pps_apply_equiv(hqt, hqtqt) -> pps_apply_equiv(h, hqtqt))))

axiom pps_apply_basis_seq :
  (forall h1:pps. forall h2:pps. forall x:bitvec.
  ((length(x) = h_width(h1)) -> ((h_width(h1) = h_width(h2)) ->
  (pps_apply_basis(pps_seq(h1, h2), x) = pps_apply(h2, pps_apply_basis(h1,
  x))))))

axiom pps_apply_seq :
  (forall h1:pps. forall h2:pps. forall x:complex matrix.
  ((h_width(h1) = h_width(h2)) -> (is_a_ket_l(x, h_width(h1)) ->
  (pps_apply(pps_seq(h1, h2), x) = pps_apply(h2, pps_apply(h1, x))))))

logic fc486 : pps, (int,int) farray -> (int,int) farray

logic fc487 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef489 :
  (forall h1:pps. forall y:(int,int) farray. forall k:int. ((fc486(h1,
  y)[k]) = (y[(k + h_range(h1))])))

axiom fcqtdef490 :
  (forall h1:pps. forall y:(int,int) farray. forall k:int. ((fc487(h1,
  y)[k]) = (y[(k + h_range(h1))])))

axiom pps_seq_pred :
  (forall h1:pps. forall h2:pps. forall h3:pps.
  (((h_width(h1) = h_width(h2)) and (h_width(h2) = h_width(h3))) ->
  ((h_range(h3) = (h_range(h1) + h_range(h2))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(h3))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h3))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h3))) ->
   ((((h_basis_ket(h3)[x])[y])[i]) = (((h_basis_ket(h2)[((h_basis_ket(h1)[x])[y])])[fc486(h1,
   y)])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(h3))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h3))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((h_angle(h3)[x])[y]) = ang_add(((h_angle(h1)[x])[y]),
   ((h_angle(h2)[((h_basis_ket(h1)[x])[y])])[fc487(h1, y)])))))) ->
  (forall x:complex matrix. (is_a_ket_l(x, h_width(h3)) -> (pps_apply(h3,
  x) = pps_apply(h2, pps_apply(h1, x))))))))))

axiom pps_apply_basis_par :
  (forall h1:pps. forall h2:pps. forall x:bitvec.
  ((length(x) = (h_width(h1) + h_width(h2))) -> (pps_apply_basis(pps_par(h1,
  h2), x) = kronecker(pps_apply_basis(h1, hpart(x, h_width(h1))),
  pps_apply_basis(h2, tpart(x, h_width(h1)))))))

axiom pps_apply_par :
  (forall h1:pps. forall h2:pps. forall x:complex matrix.
  forall y:complex matrix. (is_a_ket_l(x, h_width(h1)) -> (is_a_ket_l(y,
  h_width(h2)) -> (pps_apply(pps_par(h1, h2), kronecker(x,
  y)) = kronecker(pps_apply(h1, x), pps_apply(h2, y))))))

logic fc488 : pps, (int,int) farray -> (int,int) farray

logic fc489 : pps, (int,int) farray -> (int,int) farray

logic fc490 : pps, (int,int) farray -> (int,int) farray

logic fc491 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef491 :
  (forall h1:pps. forall x:(int,int) farray. forall k:int. ((fc488(h1,
  x)[k]) = (x[(k + h_width(h1))])))

axiom fcqtdef492 :
  (forall h1:pps. forall y:(int,int) farray. forall k:int. ((fc489(h1,
  y)[k]) = (y[(k + h_range(h1))])))

axiom fcqtdef493 :
  (forall h1:pps. forall x:(int,int) farray. forall k:int. ((fc490(h1,
  x)[k]) = (x[(k + h_width(h1))])))

axiom fcqtdef494 :
  (forall h1:pps. forall y:(int,int) farray. forall k:int. ((fc491(h1,
  y)[k]) = (y[(k + h_range(h1))])))

axiom pps_par_pred :
  (forall h1:pps. forall h2:pps. forall h3:pps.
  ((h_width(h3) = (h_width(h1) + h_width(h2))) ->
  ((h_range(h3) = (h_range(h1) + h_range(h2))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(h3))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h3))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h3))) ->
   ((((h_basis_ket(h3)[x])[y])[i]) = (if (i <  h_width(h1)) then (((h_basis_ket(h1)[x])[y])[i]) else (((h_basis_ket(h2)[fc488(h1,
   x)])[fc489(h1, y)])[(i - h_width(h1))])))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(h3))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h3))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((h_angle(h3)[x])[y]) = ang_add(((h_angle(h1)[x])[y]),
   ((h_angle(h2)[fc490(h1, x)])[fc491(h1, y)])))))) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  h_width(h1)) -> (is_a_ket_l(y, h_width(h2)) -> (pps_apply(h3, kronecker(x,
  y)) = kronecker(pps_apply(h1, x), pps_apply(h2, y)))))))))))

axiom pps_apply_basis_anc :
  (forall h:pps. forall x:bitvec. forall y:complex matrix. forall i:int.
  ((1 <= i) -> ((i <  h_width(h)) -> ((length(x) = h_width(h)) -> ((tpart(x,
  (h_width(h) - i)) = int_to_bv(0, i)) -> ((pps_apply_basis(h,
  x) = kronecker(y, ket(i, 0))) -> (is_a_ket_l(y, (h_width(h) - i)) ->
  (pps_apply_basis(pps_ancs(h, i), hpart(x, (h_width(h) - i))) = y))))))))

axiom pps_apply_basis_anc_ :
  (forall h:pps. forall x:bitvec. forall y:complex matrix. forall i:int.
  ((1 <= i) -> ((i <  h_width(h)) -> ((length(x) = (h_width(h) - i)) ->
  ((pps_apply_basis(h, concat(x, int_to_bv(0, i))) = kronecker(y, ket(i,
  0))) -> (is_a_ket_l(y, (h_width(h) - i)) -> (pps_apply_basis(pps_ancs(h,
  i), x) = y)))))))

axiom pps_apply_anc :
  (forall h:pps.
  forall path_sem_target:(complex matrix,complex matrix) farray.
  forall x:complex matrix. forall i:int. ((1 <= i) -> ((i <  h_width(h)) ->
  (is_a_ket_l(x, (h_width(h) - i)) ->
  ((forall x1:complex matrix. (is_a_ket_l(x1, (h_width(h) - i)) ->
   (pps_apply(h, kronecker(x1, ket(i, 0))) = kronecker((path_sem_target[x1]),
   ket(i, 0))))) ->
  (is_a_ket_l(x, (h_width(h) - i)) -> (pps_apply(pps_ancs(h, i),
  x) = (path_sem_target[x]))))))))

axiom pps_apply_equiv_seq :
  (forall h1:pps. forall h1qt:pps. forall h2:pps. forall h2qt:pps.
  (pps_apply_equiv(h1, h1qt) -> (pps_apply_equiv(h2, h2qt) ->
  ((h_width(h1) = h_width(h2)) -> pps_apply_equiv(pps_seq(h1, h2),
  pps_seq(h1qt, h2qt))))))

axiom pps_apply_equiv_par :
  (forall h1:pps. forall h1qt:pps. forall h2:pps. forall h2qt:pps.
  (pps_apply_equiv(h1, h1qt) -> (pps_apply_equiv(h2, h2qt) ->
  pps_apply_equiv(pps_par(h1, h2), pps_par(h1qt, h2qt)))))

axiom pps_apply_equiv_anc :
  (forall h:pps. forall hqt:pps. forall i:int. ((1 <= i) ->
  ((i <  h_width(h)) -> (pps_apply_equiv(h, hqt) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall y:complex matrix. (is_a_ket_l(y, (h_width(h) - i)) ->
   (pps_apply(h, kronecker(y, ket(i, 0))) = kronecker((path_sem_target[y]),
   ket(i, 0)))))) ->
  pps_apply_equiv(pps_ancs(h, i), pps_ancs(hqt, i)))))))

axiom pps_place_image :
  (forall h:pps. forall k:int. forall n:int. forall x:bitvec.
  forall y:bitvec. forall z:bitvec. ((0 <= k) -> (((k + h_width(h)) <= n) ->
  ((length(x) = k) -> ((length(y) = h_width(h)) ->
  ((length(z) = ((n - h_width(h)) - k)) -> (pps_apply_basis(pps_place(h, k,
  n), concat(concat(x, y), z)) = kronecker(kronecker(bv_to_ket(x),
  pps_apply_basis(h, y)), bv_to_ket(z)))))))))

axiom pps_place_image_bv :
  (forall h:pps. forall t:int. forall n:int. forall x:bitvec. ((0 <= t) ->
  (((t + h_width(h)) <= n) -> ((length(x) = n) ->
  (pps_apply_basis(pps_place(h, t, n),
  x) = kronecker(kronecker(bv_to_ket(hpart(x, t)), pps_apply_basis(h,
  htpart(x, t, h_width(h)))), bv_to_ket(tpart(x, (t + h_width(h))))))))))

axiom pps_apply_equiv_place :
  (forall h:pps. forall hqt:pps. forall t:int. forall n:int. forall tqt:int.
  forall nqt:int. ((0 <= t) -> (((t + h_width(h)) <= n) -> ((t = tqt) ->
  ((n = nqt) -> (pps_apply_equiv(h, hqt) -> pps_apply_equiv(pps_place(h, t,
  n), pps_place(hqt, tqt, nqt))))))))

axiom pps_apply_equiv_cont :
  (forall h:pps. forall hqt:pps. forall co:int. forall t:int. forall n:int.
  forall coqt:int. forall tqt:int. forall nqt:int. ((co = coqt) ->
  ((t = tqt) -> ((n = nqt) -> (((0 <= t) and (t <= (n - h_width(h)))) ->
  (((0 <= co) and (co <  n)) -> (((t <= co) -> ((t + h_width(h)) <= co)) ->
  (pps_apply_equiv(h, hqt) -> pps_apply_equiv(pps_cont(h, co, t, n),
  pps_cont(hqt, coqt, tqt, nqt))))))))))

logic fc492 : pps, int, (int,int) farray -> (int,int) farray

logic fc493 : pps, int, (int,int) farray -> (int,int) farray

axiom fcqtdef495 :
  (forall h1:pps. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc492(h1, i, x)[k]) = (if (k <  (h_width(h1) - i)) then (x[k]) else 0)))

axiom fcqtdef496 :
  (forall h1:pps. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc493(h1, i, x)[k]) = (if (k <  (h_width(h1) - i)) then (x[k]) else 0)))

axiom pps_anc_pred :
  (forall h1:pps. forall h2:pps.
  forall path_sem_target:(complex matrix,complex matrix) farray.
  forall i:int. ((1 <= i) -> ((i <  h_width(h1)) ->
  ((forall y:complex matrix. (is_a_ket_l(y, (h_width(h1) - i)) ->
   (pps_apply(h1, kronecker(y, ket(i, 0))) = kronecker((path_sem_target[y]),
   ket(i, 0))))) ->
  ((h_width(h2) = (h_width(h1) - i)) -> ((h_range(h2) = h_range(h1)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall ii:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(h2))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h2))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((0 <= ii) and (ii <  h_width(h2))) ->
   ((((h_basis_ket(h2)[x])[y])[ii]) = (((h_basis_ket(h1)[fc492(h1, i,
   x)])[y])[ii]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(h2))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h2))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((h_angle(h2)[x])[y]) = ((h_angle(h1)[fc493(h1, i, x)])[y]))))) ->
  (forall x:bitvec. ((length(x) = h_width(h2)) -> (pps_apply_basis(h2,
  x) = (path_sem_target[bv_to_ket(x)]))))))))))))

logic fc494 : pps, int, (int,int) farray -> (int,int) farray

logic fc495 : pps, int, (int,int) farray -> (int,int) farray

axiom fcqtdef497 :
  (forall h1:pps. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc494(h1, i, x)[k]) = (if (k <  (h_width(h1) - i)) then (x[k]) else 0)))

axiom fcqtdef498 :
  (forall h1:pps. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc495(h1, i, x)[k]) = (if (k <  (h_width(h1) - i)) then (x[k]) else 0)))

axiom pps_anc_pred_ :
  (forall h1:pps. forall h2:pps. forall i:int. ((1 <= i) ->
  ((i <  h_width(h1)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall y:complex matrix. (is_a_ket_l(y, (h_width(h1) - i)) ->
   (pps_apply(h1, kronecker(y, ket(i, 0))) = kronecker((path_sem_target[y]),
   ket(i, 0)))))) ->
  ((h_width(h2) = (h_width(h1) - i)) -> ((h_range(h2) = h_range(h1)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall ii:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(h2))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h2))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((0 <= ii) and (ii <  h_width(h2))) ->
   ((((h_basis_ket(h2)[x])[y])[ii]) = (((h_basis_ket(h1)[fc494(h1, i,
   x)])[y])[ii]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(h2))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(h2))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   (((h_angle(h2)[x])[y]) = ((h_angle(h1)[fc495(h1, i, x)])[y]))))) ->
  (forall x:bitvec. ((length(x) = h_width(h2)) -> (pps_apply_basis(h1,
  concat(x, int_to_bv(0, i))) = kronecker(pps_apply_basis(h2, x), ket(i,
  0)))))))))))))

logic result50 : pps, bitvec, bitvec -> (int,(int,complex) farray) farray

logic result51 : (int,(int,complex) farray) farray

logic result52 : pps, bitvec -> (bitvec,complex matrix) farray

logic result53 : pps -> (bitvec,complex matrix) farray

axiom resultqtdef57 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. forall i:int.
  forall j:int. (((result50(h, x,
  y)[i])[j]) = (if ((i = bv_to_int(h_basis_ket_bv(h, x, y))) and
  (j = bv_to_int(x))) then ang_exp(h_angle_bv(h, x, y)) else c_zero)))

axiom resultqtdef58 :
  (forall us:int. forall us1:int. (((result51[us])[us1]) = c_zero))

axiom resultqtdef59 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. ((result52(h,
  x)[y]) = (if ((length(x) = h_width(h)) and
  (length(y) = h_range(h))) then make_f(power(2, h_width(h)), power(2,
  h_width(h)), result50(h, x, y)) else make_f(power(2, h_width(h)), power(2,
  h_width(h)), result51))))

axiom resultqtdef60 :
  (forall h:pps. forall x:bitvec.
  ((result53(h)[x]) = mat_sum_dim(n_bvs(h_range(h)), result52(h, x), power(2,
  h_width(h)), power(2, h_width(h)))))

function pps_to_mat(h: pps) : complex matrix =
  infix_asdtdt(pow_inv_sqrt_2(h_range(h)), mat_sum_dim(n_bvs(h_width(h)),
  result53(h), power(2, h_width(h)), power(2, h_width(h))))

logic fc496 : pps, bitvec, bitvec -> (int,(int,complex) farray) farray

logic fc497 : pps, bitvec -> (bitvec,complex matrix) farray

logic fc498 : pps -> (bitvec,complex matrix) farray

logic fc499 : pps, bitvec, bitvec -> (int,(int,complex) farray) farray

logic fc500 : pps, bitvec -> (bitvec,complex matrix) farray

logic fc501 : pps -> (bitvec,complex matrix) farray

axiom fcqtdef499 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. forall i:int.
  forall j:int. (((fc496(h, x,
  y)[i])[j]) = (if ((i = bv_to_int(h_basis_ket_bv(h, x, y))) and
  (j = bv_to_int(x))) then ang_exp(h_angle_bv(h, x, y)) else c_zero)))

axiom fcqtdef500 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. ((fc497(h,
  x)[y]) = make_f(power(2, h_width(h)), power(2, h_width(h)), fc496(h, x,
  y))))

axiom fcqtdef501 :
  (forall h:pps. forall x:bitvec.
  ((fc498(h)[x]) = mat_sum_dim(n_bvs(h_range(h)), fc497(h, x), power(2,
  h_width(h)), power(2, h_width(h)))))

axiom fcqtdef502 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. forall i:int.
  forall j:int. (((fc499(h, x,
  y)[i])[j]) = (if ((i = bv_to_int(h_basis_ket_bv(h, x, y))) and
  (j = bv_to_int(x))) then ang_exp(h_angle_bv(h, x, y)) else c_zero)))

axiom fcqtdef503 :
  (forall h:pps. forall x:bitvec. forall y:bitvec. ((fc500(h,
  x)[y]) = make_f(power(2, h_width(h)), power(2, h_width(h)), fc499(h, x,
  y))))

axiom fcqtdef504 :
  (forall h:pps. forall x:bitvec. ((fc501(h)[x]) = mat_sum(n_bvs(h_range(h)),
  fc500(h, x))))

axiom pps_to_matqtspec :
  (forall h:pps. (pps_to_mat(h) = infix_asdtdt(pow_inv_sqrt_2(h_range(h)),
  mat_sum_dim(n_bvs(h_width(h)), fc498(h), power(2, h_width(h)), power(2,
  h_width(h))))))

axiom pps_to_matqtspec1 :
  (forall h:pps. (pps_to_mat(h) = infix_asdtdt(pow_inv_sqrt_2(h_range(h)),
  mat_sum(n_bvs(h_width(h)), fc501(h)))))

axiom pps_to_matqtspec2 :
  (forall h:pps. (rows(pps_to_mat(h)) = power(2, h_width(h))))

axiom pps_to_matqtspec3 :
  (forall h:pps. (columns(pps_to_mat(h)) = power(2, h_width(h))))

axiom pps_to_matqtspec4 :
  (forall h:pps.
  (forall x:bitvec. ((length(x) = h_width(h)) -> (mat_mult(pps_to_mat(h),
  bv_to_ket(x)) = pps_apply_basis(h, x)))))

axiom pps_to_matqtspec5 :
  (forall h:pps.
  (forall x:complex matrix. (is_a_ket_l(x, h_width(h)) ->
  (mat_mult(pps_to_mat(h), x) = pps_apply(h, x)))))

logic indic_closure : ('a,('a,complex) farray) farray

axiom indic_closure_def :
  (forall y:'a. forall y1:'a.
  ((((indic_closure : ('a,('a,complex) farray) farray)[y])[y1]) = indic(y,
  y1)))

function sem_id_mat(us: unit) : complex matrix = make_f(2, 2,
  (indic_closure : (int,(int,complex) farray) farray))

axiom sem_id_matqtspec :
  (forall us:unit. (rows(sem_id_mat(us)) = power(2, 1)))

axiom sem_id_matqtspec1 :
  (forall us:unit. (columns(sem_id_mat(us)) = power(2, 1)))

axiom sem_id_matqtspec2 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 1) -> (mat_mult(sem_id_mat(us),
  bv_to_ket(x)) = bv_to_ket(x)))))

axiom sem_id_matqtspec3 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 1) -> (mat_mult(sem_id_mat(us),
  bv_to_ket(x)) = pps_apply_basis(pps_id, x)))))

logic result54 : int -> (int,(int,complex) farray) farray

axiom resultqtdef61 :
  (forall k:int. forall i:int. forall j:int.
  (((result54(k)[i])[j]) = (if (i = j) then ang_exp(infix_sldtsl(i,
  k)) else c_zero)))

function sem_rz_mat(k: int) : complex matrix = make_f(2, 2, result54(k))

axiom sem_rz_matqtspec : (forall k:int. (rows(sem_rz_mat(k)) = power(2, 1)))

axiom sem_rz_matqtspec1 :
  (forall k:int. (columns(sem_rz_mat(k)) = power(2, 1)))

axiom sem_rz_matqtspec2 :
  (forall k:int.
  (forall x:bitvec. ((length(x) = 1) -> (mat_mult(sem_rz_mat(k),
  bv_to_ket(x)) = infix_asdtdt(ang_exp(infix_sldtsl((value(x)[0]), k)),
  bv_to_ket(x))))))

axiom sem_rz_matqtspec3 :
  (forall k:int.
  (forall x:bitvec. ((length(x) = 1) -> (mat_mult(sem_rz_mat(k),
  bv_to_ket(x)) = pps_apply_basis(pps_rz(k), x)))))

logic result55 : int -> (int,(int,complex) farray) farray

axiom resultqtdef62 :
  (forall k:int. forall i:int. forall j:int.
  (((result55(k)[i])[j]) = (if (i = j) then ang_exp(infix_sldtsl(1,
  k)) else c_zero)))

function sem_phase_mat(k: int) : complex matrix = make_f(2, 2, result55(k))

axiom sem_phase_matqtspec :
  (forall k:int. (rows(sem_phase_mat(k)) = power(2, 1)))

axiom sem_phase_matqtspec1 :
  (forall k:int. (columns(sem_phase_mat(k)) = power(2, 1)))

axiom sem_phase_matqtspec2 :
  (forall k:int.
  (forall x:bitvec. ((length(x) = 1) -> (mat_mult(sem_phase_mat(k),
  bv_to_ket(x)) = infix_asdtdt(ang_exp(infix_sldtsl(1, k)), bv_to_ket(x))))))

axiom sem_phase_matqtspec3 :
  (forall k:int.
  (forall x:bitvec. ((length(x) = 1) -> (mat_mult(sem_phase_mat(k),
  bv_to_ket(x)) = pps_apply_basis(pps_phase(k), x)))))

logic result56 : (int,(int,complex) farray) farray

axiom resultqtdef63 :
  (forall i:int. forall j:int.
  (((result56[i])[j]) = infix_asdt(cpower(prefix_mndt(c_one), (i * j)),
  pow_inv_sqrt_2(1))))

function sem_hadamard_mat(us: unit) : complex matrix = make_f(2, 2, result56)

axiom sem_hadamard_matqtspec :
  (forall us:unit. (rows(sem_hadamard_mat(us)) = power(2, 1)))

axiom sem_hadamard_matqtspec1 :
  (forall us:unit. (columns(sem_hadamard_mat(us)) = power(2, 1)))

axiom sem_hadamard_matqtspec2 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 1) -> (mat_mult(sem_hadamard_mat(us),
  bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(1), add_ket_l(ket(1, 0),
  infix_asdtdt(ang_exp(infix_sldtsl((value(x)[0]), 1)), ket(1, 1)), 1))))))

axiom sem_hadamard_matqtspec3 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 1) -> (mat_mult(sem_hadamard_mat(us),
  bv_to_ket(x)) = pps_apply_basis(pps_hadamard, x)))))

logic cnot_func : bitvec -> bitvec

logic result57 : bitvec -> (int,int) farray

axiom resultqtdef64 :
  (forall x:bitvec. forall i:int.
  ((result57(x)[i]) = (if (i = 0) then (value(x)[i]) else (1 - (value(x)[i])))))

axiom cnot_funcqtdef :
  (forall x:bitvec. ((length(x) = 2) -> (((value(x)[0]) = 0) ->
  (cnot_func(x) = x))))

axiom cnot_funcqtdef1 :
  (forall x:bitvec. ((length(x) = 2) -> ((not ((value(x)[0]) = 0)) ->
  (cnot_func(x) = make_bv(result57(x), 2)))))

axiom cnot_funcqtspec :
  (forall x:bitvec. ((length(x) = 2) -> (length(cnot_func(x)) = 2)))

axiom cnot_funcqtspec1 :
  (forall x:bitvec. ((length(x) = 2) -> ((bv_to_int(x) = 0) ->
  (cnot_func(x) = int_to_bv(0, 2)))))

axiom cnot_funcqtspec2 :
  (forall x:bitvec. ((length(x) = 2) -> ((bv_to_int(x) = 1) ->
  (cnot_func(x) = int_to_bv(1, 2)))))

axiom cnot_funcqtspec3 :
  (forall x:bitvec. ((length(x) = 2) -> ((bv_to_int(x) = 2) ->
  (cnot_func(x) = int_to_bv(3, 2)))))

axiom cnot_funcqtspec4 :
  (forall x:bitvec. ((length(x) = 2) -> ((bv_to_int(x) = 3) ->
  (cnot_func(x) = int_to_bv(2, 2)))))

axiom invol_cnot_func :
  (forall x:bitvec. ((length(x) = 2) -> (cnot_func(cnot_func(x)) = x)))

function cnot_func_int(i: int) : int = bv_to_int(cnot_func(int_to_bv(i, 2)))

axiom cnot_func_intqtspec : (forall i:int. (0 <= cnot_func_int(i)))

axiom cnot_func_intqtspec1 : (forall i:int. (cnot_func_int(i) <  4))

axiom cnot_func_intqtspec2 :
  (forall i:int. ((i = 0) -> (cnot_func_int(i) = 0)))

axiom cnot_func_intqtspec3 :
  (forall i:int. ((i = 1) -> (cnot_func_int(i) = 1)))

axiom cnot_func_intqtspec4 :
  (forall i:int. ((i = 2) -> (cnot_func_int(i) = 3)))

axiom cnot_func_intqtspec5 :
  (forall i:int. ((i = 3) -> (cnot_func_int(i) = 2)))

axiom cnot_func_intqtspec6 :
  (forall i:int. (((0 <= i) and (i <  4)) ->
  (cnot_func_int(i) = (if ((i / 2) = 0) then i else (3 - (i % 2))))))

axiom invol_cnot_func_int :
  (forall i:int. (((0 <= i) and (i <  4)) ->
  (cnot_func_int(cnot_func_int(i)) = i)))

logic result58 : (int,(int,complex) farray) farray

axiom resultqtdef65 :
  (forall i:int. forall j:int.
  (((result58[i])[j]) = (if (j = cnot_func_int(i)) then c_one else c_zero)))

function sem_cnot_mat(us: unit) : complex matrix = make_f(4, 4, result58)

logic fc502 : (int,(int,complex) farray) farray

logic fc503 : bitvec -> (int,int) farray

axiom fcqtdef505 :
  (forall i:int. forall j:int.
  (((fc502[i])[j]) = (if (j = (if ((i / 2) = 0) then i else (3 - (i % 2)))) then c_one else c_zero)))

axiom fcqtdef506 :
  (forall x:bitvec. forall i:int.
  ((fc503(x)[i]) = (if (i = 0) then (value(x)[i]) else (1 - (value(x)[i])))))

axiom sem_cnot_matqtspec :
  (forall us:unit. (rows(sem_cnot_mat(us)) = power(2, 2)))

axiom sem_cnot_matqtspec1 :
  (forall us:unit. (columns(sem_cnot_mat(us)) = power(2, 2)))

axiom sem_cnot_matqtspec2 :
  (forall us:unit. (sem_cnot_mat(us) = make_f(4, 4, fc502)))

axiom sem_cnot_matqtspec3 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 2) -> (mat_mult(sem_cnot_mat(us),
  bv_to_ket(x)) = bv_to_ket((if ((value(x)[0]) = 0) then x else int_to_bv((if (bv_to_int(x) = 2) then 3 else 2),
  2)))))))

axiom sem_cnot_matqtspec4 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 2) -> (mat_mult(sem_cnot_mat(us),
  bv_to_ket(x)) = bv_to_ket((if ((value(x)[0]) = 0) then x else make_bv(fc503(x),
  2)))))))

axiom sem_cnot_matqtspec5 :
  (forall us:unit.
  (forall i:int. (((0 <= i) and (i <  power(2, 2))) ->
  (mat_mult(sem_cnot_mat(us), ket(2, i)) = ket(2,
  (if (i = 0) then 0 else (if (i = 1) then 1 else (if (i = 2) then 3 else 2))))))))

axiom sem_cnot_matqtspec6 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 2) -> (mat_mult(sem_cnot_mat(us),
  bv_to_ket(x)) = bv_to_ket(cnot_func(x))))))

axiom sem_cnot_matqtspec7 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 2) -> (mat_mult(sem_cnot_mat(us),
  bv_to_ket(x)) = pps_apply_basis(pps_cnot(0, 1, 2), x)))))

logic swap_func : bitvec -> bitvec

logic result59 : bitvec -> (int,int) farray

axiom resultqtdef66 :
  (forall x:bitvec. forall i:int. ((result59(x)[i]) = (value(x)[(1 - i)])))

axiom swap_funcqtdef :
  (forall x:bitvec. ((length(x) = 2) -> (swap_func(x) = make_bv(result59(x),
  2))))

axiom swap_funcqtspec :
  (forall x:bitvec. ((length(x) = 2) -> (length(swap_func(x)) = 2)))

axiom swap_funcqtspec1 :
  (forall x:bitvec. ((length(x) = 2) -> ((bv_to_int(x) = 0) ->
  (swap_func(x) = int_to_bv(0, 2)))))

axiom swap_funcqtspec2 :
  (forall x:bitvec. ((length(x) = 2) -> ((bv_to_int(x) = 1) ->
  (swap_func(x) = int_to_bv(2, 2)))))

axiom swap_funcqtspec3 :
  (forall x:bitvec. ((length(x) = 2) -> ((bv_to_int(x) = 2) ->
  (swap_func(x) = int_to_bv(1, 2)))))

axiom swap_funcqtspec4 :
  (forall x:bitvec. ((length(x) = 2) -> ((bv_to_int(x) = 3) ->
  (swap_func(x) = int_to_bv(3, 2)))))

axiom invol_swap_func :
  (forall x:bitvec. ((length(x) = 2) -> (swap_func(swap_func(x)) = x)))

function swap_func_int(i: int) : int = bv_to_int(swap_func(int_to_bv(i, 2)))

axiom swap_func_intqtspec : (forall i:int. (0 <= swap_func_int(i)))

axiom swap_func_intqtspec1 : (forall i:int. (swap_func_int(i) <  4))

axiom swap_func_intqtspec2 :
  (forall i:int. ((i = 0) -> (swap_func_int(i) = 0)))

axiom swap_func_intqtspec3 :
  (forall i:int. ((i = 1) -> (swap_func_int(i) = 2)))

axiom swap_func_intqtspec4 :
  (forall i:int. ((i = 2) -> (swap_func_int(i) = 1)))

axiom swap_func_intqtspec5 :
  (forall i:int. ((i = 3) -> (swap_func_int(i) = 3)))

axiom swap_func_intqtspec6 :
  (forall i:int. (((0 <= i) and (i <  4)) ->
  (swap_func_int(i) = (if ((i / 2) = (i % 2)) then i else (3 - i)))))

axiom invol_swap_func_int :
  (forall i:int. (((0 <= i) and (i <  4)) ->
  (swap_func_int(swap_func_int(i)) = i)))

logic result60 : (int,(int,complex) farray) farray

axiom resultqtdef67 :
  (forall i:int. forall j:int. (((result60[i])[j]) = indic(j,
  swap_func_int(i))))

function sem_swap_mat(us: unit) : complex matrix = make_f(4, 4, result60)

logic fc504 : (int,(int,complex) farray) farray

logic fc505 : bitvec -> (int,int) farray

axiom fcqtdef507 :
  (forall i:int. forall j:int. (((fc504[i])[j]) = indic(j,
  (if (i = 0) then i else (if (i = 1) then 2 else (if (i = 2) then 1 else 3))))))

axiom fcqtdef508 :
  (forall x:bitvec. forall i:int. ((fc505(x)[i]) = (value(x)[(1 - i)])))

axiom sem_swap_matqtspec :
  (forall us:unit. (rows(sem_swap_mat(us)) = power(2, 2)))

axiom sem_swap_matqtspec1 :
  (forall us:unit. (columns(sem_swap_mat(us)) = power(2, 2)))

axiom sem_swap_matqtspec2 :
  (forall us:unit. (sem_swap_mat(us) = make_f(4, 4, fc504)))

axiom sem_swap_matqtspec3 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 2) -> (mat_mult(sem_swap_mat(us),
  bv_to_ket(x)) = bv_to_ket(make_bv(fc505(x), 2))))))

axiom sem_swap_matqtspec4 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 2) -> (mat_mult(sem_swap_mat(us),
  bv_to_ket(x)) = bv_to_ket(swap_func(x))))))

axiom sem_swap_matqtspec5 :
  (forall us:unit.
  (forall i:int. (((0 <= i) and (i <  power(2, 2))) ->
  (mat_mult(sem_swap_mat(us), ket(2, i)) = ket(2,
  (if (i = 0) then 0 else (if (i = 1) then 2 else (if (i = 2) then 1 else 3))))))))

axiom sem_swap_matqtspec6 :
  (forall us:unit.
  (forall x:bitvec. ((length(x) = 2) -> (mat_mult(sem_swap_mat(us),
  bv_to_ket(x)) = pps_apply_basis(pps_swap(0, 1, 2), x)))))

type circuit_pre

logic Phase : int -> circuit_pre

logic Rz : int -> circuit_pre

logic Hadamard : circuit_pre

logic Cnot : circuit_pre

logic Swap : circuit_pre

logic Id : circuit_pre

logic Sequence : circuit_pre, circuit_pre -> circuit_pre

logic Parallel : circuit_pre, circuit_pre -> circuit_pre

logic Ancillas : circuit_pre, int -> circuit_pre

logic match_circuit_pre : circuit_pre, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a,
  'a -> 'a

axiom match_circuit_pre_Phase :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall u:int.
  (match_circuit_pre(Phase(u), z, z1, z2, z3, z4, z5, z6, z7, z8) = z))

axiom match_circuit_pre_Rz :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall u:int.
  (match_circuit_pre(Rz(u), z, z1, z2, z3, z4, z5, z6, z7, z8) = z1))

axiom match_circuit_pre_Hadamard :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a.
  (match_circuit_pre(Hadamard, z, z1, z2, z3, z4, z5, z6, z7, z8) = z2))

axiom match_circuit_pre_Cnot :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a.
  (match_circuit_pre(Cnot, z, z1, z2, z3, z4, z5, z6, z7, z8) = z3))

axiom match_circuit_pre_Swap :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a.
  (match_circuit_pre(Swap, z, z1, z2, z3, z4, z5, z6, z7, z8) = z4))

axiom match_circuit_pre_Id :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a.
  (match_circuit_pre(Id, z, z1, z2, z3, z4, z5, z6, z7, z8) = z5))

axiom match_circuit_pre_Sequence :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a.
  forall u:circuit_pre. forall u1:circuit_pre. (match_circuit_pre(Sequence(u,
  u1), z, z1, z2, z3, z4, z5, z6, z7, z8) = z6))

axiom match_circuit_pre_Parallel :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a.
  forall u:circuit_pre. forall u1:circuit_pre. (match_circuit_pre(Parallel(u,
  u1), z, z1, z2, z3, z4, z5, z6, z7, z8) = z7))

axiom match_circuit_pre_Ancillas :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a.
  forall u:circuit_pre. forall u1:int. (match_circuit_pre(Ancillas(u, u1), z,
  z1, z2, z3, z4, z5, z6, z7, z8) = z8))

logic index_circuit_pre : circuit_pre -> int

axiom index_circuit_pre_Phase :
  (forall u:int [Phase(u)]. (index_circuit_pre(Phase(u)) = 0))

axiom index_circuit_pre_Rz :
  (forall u:int [Rz(u)]. (index_circuit_pre(Rz(u)) = 1))

axiom index_circuit_pre_Hadamard : (index_circuit_pre(Hadamard) = 2)

axiom index_circuit_pre_Cnot : (index_circuit_pre(Cnot) = 3)

axiom index_circuit_pre_Swap : (index_circuit_pre(Swap) = 4)

axiom index_circuit_pre_Id : (index_circuit_pre(Id) = 5)

axiom index_circuit_pre_Sequence :
  (forall u:circuit_pre. forall u1:circuit_pre [Sequence(u, u1)].
  (index_circuit_pre(Sequence(u, u1)) = 6))

axiom index_circuit_pre_Parallel :
  (forall u:circuit_pre. forall u1:circuit_pre [Parallel(u, u1)].
  (index_circuit_pre(Parallel(u, u1)) = 7))

axiom index_circuit_pre_Ancillas :
  (forall u:circuit_pre. forall u1:int [Ancillas(u, u1)].
  (index_circuit_pre(Ancillas(u, u1)) = 8))

logic Phase_proj_1 : circuit_pre -> int

axiom Phase_proj_1qtdef : (forall u:int. (Phase_proj_1(Phase(u)) = u))

logic Rz_proj_1 : circuit_pre -> int

axiom Rz_proj_1qtdef : (forall u:int. (Rz_proj_1(Rz(u)) = u))

logic Sequence_proj_1 : circuit_pre -> circuit_pre

axiom Sequence_proj_1qtdef :
  (forall u:circuit_pre. forall u1:circuit_pre. (Sequence_proj_1(Sequence(u,
  u1)) = u))

logic Sequence_proj_2 : circuit_pre -> circuit_pre

axiom Sequence_proj_2qtdef :
  (forall u:circuit_pre. forall u1:circuit_pre. (Sequence_proj_2(Sequence(u,
  u1)) = u1))

logic Parallel_proj_1 : circuit_pre -> circuit_pre

axiom Parallel_proj_1qtdef :
  (forall u:circuit_pre. forall u1:circuit_pre. (Parallel_proj_1(Parallel(u,
  u1)) = u))

logic Parallel_proj_2 : circuit_pre -> circuit_pre

axiom Parallel_proj_2qtdef :
  (forall u:circuit_pre. forall u1:circuit_pre. (Parallel_proj_2(Parallel(u,
  u1)) = u1))

logic Ancillas_proj_1 : circuit_pre -> circuit_pre

axiom Ancillas_proj_1qtdef :
  (forall u:circuit_pre. forall u1:int. (Ancillas_proj_1(Ancillas(u,
  u1)) = u))

logic Ancillas_proj_2 : circuit_pre -> int

axiom Ancillas_proj_2qtdef :
  (forall u:circuit_pre. forall u1:int. (Ancillas_proj_2(Ancillas(u,
  u1)) = u1))

axiom circuit_pre_inversion :
  (forall u:circuit_pre. (((((((((u = Phase(Phase_proj_1(u))) or
  (u = Rz(Rz_proj_1(u)))) or (u = Hadamard)) or (u = Cnot)) or (u = Swap)) or
  (u = Id)) or (u = Sequence(Sequence_proj_1(u), Sequence_proj_2(u)))) or
  (u = Parallel(Parallel_proj_1(u), Parallel_proj_2(u)))) or
  (u = Ancillas(Ancillas_proj_1(u), Ancillas_proj_2(u)))))

logic width_pre : circuit_pre -> int

axiom width_preqtdef : (forall w:int. (width_pre(Phase(w)) = 1))

axiom width_preqtdef1 : (forall w:int. (width_pre(Rz(w)) = 1))

axiom width_preqtdef2 : (width_pre(Hadamard) = 1)

axiom width_preqtdef3 : (width_pre(Cnot) = 2)

axiom width_preqtdef4 : (width_pre(Swap) = 2)

axiom width_preqtdef5 : (width_pre(Id) = 1)

axiom width_preqtdef6 :
  (forall x:circuit_pre. forall x1:circuit_pre. (width_pre(Sequence(x,
  x1)) = width_pre(x)))

axiom width_preqtdef7 :
  (forall x:circuit_pre. forall x1:circuit_pre. (width_pre(Parallel(x,
  x1)) = (width_pre(x) + width_pre(x1))))

axiom width_preqtdef8 :
  (forall x:circuit_pre. forall x1:int. (width_pre(Ancillas(x,
  x1)) = (width_pre(x) - x1)))

logic build_correct : circuit_pre -> prop

axiom build_correctqtdef : (forall w:int. build_correct(Phase(w)))

axiom build_correctqtdef1 : (forall w:int. build_correct(Rz(w)))

axiom build_correctqtdef2 : build_correct(Hadamard)

axiom build_correctqtdef3 : build_correct(Cnot)

axiom build_correctqtdef4 : build_correct(Swap)

axiom build_correctqtdef5 : build_correct(Id)

axiom build_correctqtdef6 :
  (forall d:circuit_pre. forall e:circuit_pre. (build_correct(Sequence(d,
  e)) -> (width_pre(d) = width_pre(e))))

axiom build_correctqtdef7 :
  (forall d:circuit_pre. forall e:circuit_pre. (build_correct(Sequence(d,
  e)) -> build_correct(d)))

axiom build_correctqtdef8 :
  (forall d:circuit_pre. forall e:circuit_pre. (build_correct(Sequence(d,
  e)) -> build_correct(e)))

axiom build_correctqtdef9 :
  (forall d:circuit_pre. forall e:circuit_pre.
  (((width_pre(d) = width_pre(e)) and (build_correct(d) and
  build_correct(e))) -> build_correct(Sequence(d, e))))

axiom build_correctqtdef10 :
  (forall d:circuit_pre. forall e:circuit_pre. (build_correct(Parallel(d,
  e)) -> build_correct(d)))

axiom build_correctqtdef11 :
  (forall d:circuit_pre. forall e:circuit_pre. (build_correct(Parallel(d,
  e)) -> build_correct(e)))

axiom build_correctqtdef12 :
  (forall d:circuit_pre. forall e:circuit_pre. ((build_correct(d) and
  build_correct(e)) -> build_correct(Parallel(d, e))))

axiom build_correctqtdef13 :
  (forall d:circuit_pre. forall i:int. (build_correct(Ancillas(d, i)) ->
  (1 <= i)))

axiom build_correctqtdef14 :
  (forall d:circuit_pre. forall i:int. (build_correct(Ancillas(d, i)) ->
  ((i + 1) <= width_pre(d))))

axiom build_correctqtdef15 :
  (forall d:circuit_pre. forall i:int. (build_correct(Ancillas(d, i)) ->
  build_correct(d)))

axiom build_correctqtdef16 :
  (forall d:circuit_pre. forall i:int. (((1 <= i) and
  (((i + 1) <= width_pre(d)) and build_correct(d))) ->
  build_correct(Ancillas(d, i))))

logic circ_to_pps_pre : circuit_pre -> pps

axiom circ_to_pps_preqtdef :
  (forall c:circuit_pre. (build_correct(c) ->
  (forall k:int. ((c = Phase(k)) -> (circ_to_pps_pre(c) = pps_phase(k))))))

axiom circ_to_pps_preqtdef1 :
  (forall c:circuit_pre. (build_correct(c) ->
  (forall k:int. ((c = Rz(k)) -> (circ_to_pps_pre(c) = pps_rz(k))))))

axiom circ_to_pps_preqtdef2 :
  (forall c:circuit_pre. (build_correct(c) -> ((c = Hadamard) ->
  (circ_to_pps_pre(c) = pps_hadamard))))

axiom circ_to_pps_preqtdef3 :
  (forall c:circuit_pre. (build_correct(c) -> ((c = Cnot) ->
  (circ_to_pps_pre(c) = pps_cnot(0, 1, 2)))))

axiom circ_to_pps_preqtdef4 :
  (forall c:circuit_pre. (build_correct(c) -> ((c = Swap) ->
  (circ_to_pps_pre(c) = pps_swap(0, 1, 2)))))

axiom circ_to_pps_preqtdef5 :
  (forall c:circuit_pre. (build_correct(c) -> ((c = Id) ->
  (circ_to_pps_pre(c) = pps_id))))

axiom circ_to_pps_preqtdef6 :
  (forall c:circuit_pre. (build_correct(c) ->
  (forall d:circuit_pre. forall e:circuit_pre. ((c = Sequence(d, e)) ->
  (circ_to_pps_pre(c) = pps_seq(circ_to_pps_pre(d), circ_to_pps_pre(e)))))))

axiom circ_to_pps_preqtdef7 :
  (forall c:circuit_pre. (build_correct(c) ->
  (forall d:circuit_pre. forall e:circuit_pre. ((c = Parallel(d, e)) ->
  (circ_to_pps_pre(c) = pps_par(circ_to_pps_pre(d), circ_to_pps_pre(e)))))))

axiom circ_to_pps_preqtdef8 :
  (forall c:circuit_pre. (build_correct(c) ->
  (forall d:circuit_pre. forall i:int. ((c = Ancillas(d, i)) ->
  (circ_to_pps_pre(c) = pps_ancs(circ_to_pps_pre(d), i))))))

axiom circ_to_pps_preqtspec :
  (forall c:circuit_pre. (build_correct(c) ->
  (h_width(circ_to_pps_pre(c)) = width_pre(c))))

axiom circ_to_pps_preqtspec1 :
  (forall c:circuit_pre. (build_correct(c) ->
  (1 <= h_width(circ_to_pps_pre(c)))))

logic ancillable_pre : circuit_pre, int -> prop

axiom ancillable_preqtspec :
  (forall c:circuit_pre. forall i:int. (ancillable_pre(c, i) ->
  (exists path_sem_target:(complex matrix,complex matrix) farray.
  (forall x:complex matrix. (is_a_ket_l(x, (width_pre(c) - i)) ->
  (pps_apply(circ_to_pps_pre(c), kronecker(x, ket(i,
  0))) = kronecker((path_sem_target[x]), ket(i, 0))))))))

axiom ancillable_preqtspec1 :
  (forall c:circuit_pre. forall i:int.
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width_pre(c) - i)) ->
   (pps_apply(circ_to_pps_pre(c), kronecker(x, ket(i,
   0))) = kronecker((path_sem_target[x]), ket(i, 0)))))) ->
  ancillable_pre(c, i)))

logic correct : circuit_pre -> prop

axiom correctqtdef : (forall w:int. correct(Phase(w)))

axiom correctqtdef1 : (forall w:int. correct(Rz(w)))

axiom correctqtdef2 : correct(Hadamard)

axiom correctqtdef3 : correct(Cnot)

axiom correctqtdef4 : correct(Swap)

axiom correctqtdef5 : correct(Id)

axiom correctqtdef6 :
  (forall d:circuit_pre. forall e:circuit_pre. (correct(Sequence(d, e)) ->
  (width_pre(d) = width_pre(e))))

axiom correctqtdef7 :
  (forall d:circuit_pre. forall e:circuit_pre. (correct(Sequence(d, e)) ->
  correct(d)))

axiom correctqtdef8 :
  (forall d:circuit_pre. forall e:circuit_pre. (correct(Sequence(d, e)) ->
  correct(e)))

axiom correctqtdef9 :
  (forall d:circuit_pre. forall e:circuit_pre.
  (((width_pre(d) = width_pre(e)) and (correct(d) and correct(e))) ->
  correct(Sequence(d, e))))

axiom correctqtdef10 :
  (forall d:circuit_pre. forall e:circuit_pre. (correct(Parallel(d, e)) ->
  correct(d)))

axiom correctqtdef11 :
  (forall d:circuit_pre. forall e:circuit_pre. (correct(Parallel(d, e)) ->
  correct(e)))

axiom correctqtdef12 :
  (forall d:circuit_pre. forall e:circuit_pre. ((correct(d) and
  correct(e)) -> correct(Parallel(d, e))))

axiom correctqtdef13 :
  (forall d:circuit_pre. forall i:int. (correct(Ancillas(d, i)) -> (1 <= i)))

axiom correctqtdef14 :
  (forall d:circuit_pre. forall i:int. (correct(Ancillas(d, i)) ->
  ((i + 1) <= width_pre(d))))

axiom correctqtdef15 :
  (forall d:circuit_pre. forall i:int. (correct(Ancillas(d, i)) ->
  correct(d)))

axiom correctqtdef16 :
  (forall d:circuit_pre. forall i:int. (correct(Ancillas(d, i)) ->
  ancillable_pre(d, i)))

axiom correctqtdef17 :
  (forall d:circuit_pre. forall i:int. (((1 <= i) and
  (((i + 1) <= width_pre(d)) and (correct(d) and ancillable_pre(d, i)))) ->
  correct(Ancillas(d, i))))

axiom correctqtspec :
  (forall c:circuit_pre. (correct(c) -> build_correct(c)))

type circuit

logic pre : circuit -> circuit_pre

axiom circuitqtinvariant :
  (forall self:circuit [pre(self)]. correct(pre(self)))

axiom injective_pre :
  (forall c:circuit. forall cqt:circuit. ((not (c = cqt)) ->
  (not (pre(c) = pre(cqt)))))

logic to_qc : circuit_pre -> circuit

axiom to_qcqtspec :
  (forall c:circuit_pre. (correct(c) -> (pre(to_qc(c)) = c)))

type int63

logic int63qtint : int63 -> int

axiom int63qtaxiom :
  (forall i:int63. ((- 4611686018427387904) <= int63qtint(i)))

axiom int63qtaxiom1 :
  (forall i:int63. (int63qtint(i) <= 4611686018427387903))

predicate in_bounds(n: int) = (((- 4611686018427387904) <= n) and
  (n <= 4611686018427387903))

axiom to_int_in_bounds : (forall n:int63. in_bounds(int63qtint(n)))

axiom extensionality1 :
  (forall x:int63. forall y:int63. ((int63qtint(x) = int63qtint(y)) ->
  (x = y)))

logic div : int, int -> int

logic mod : int, int -> int

axiom Div_mod1 :
  (forall x:int. forall y:int. ((not (y = 0)) -> (x = ((y * div(x,
  y)) + mod(x, y)))))

axiom Div_bound2 :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) -> (0 <= div(x, y))))

axiom Div_bound3 :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) -> (div(x, y) <= x)))

axiom Mod_bound2 :
  (forall x:int. forall y:int. ((not (y = 0)) -> ((-abs(y)) <  mod(x, y))))

axiom Mod_bound3 :
  (forall x:int. forall y:int. ((not (y = 0)) -> (mod(x, y) <  abs(y))))

axiom Div_sign_pos :
  (forall x:int. forall y:int. (((0 <= x) and (0 <  y)) -> (0 <= div(x, y))))

axiom Div_sign_neg :
  (forall x:int. forall y:int. (((x <= 0) and (0 <  y)) -> (div(x, y) <= 0)))

axiom Mod_sign_pos :
  (forall x:int. forall y:int. (((0 <= x) and (not (y = 0))) -> (0 <= mod(x,
  y))))

axiom Mod_sign_neg :
  (forall x:int. forall y:int. (((x <= 0) and (not (y = 0))) -> (mod(x,
  y) <= 0)))

axiom Rounds_toward_zero :
  (forall x:int. forall y:int. ((not (y = 0)) -> (abs((div(x,
  y) * y)) <= abs(x))))

axiom Div_11 : (forall x:int. (div(x, 1) = x))

axiom Mod_11 : (forall x:int. (mod(x, 1) = 0))

axiom Div_inf1 :
  (forall x:int. forall y:int. (((0 <= x) and (x <  y)) -> (div(x, y) = 0)))

axiom Mod_inf :
  (forall x:int. forall y:int. (((0 <= x) and (x <  y)) -> (mod(x, y) = x)))

axiom Div_mult1 :
  (forall x:int. forall y:int. forall z:int [div(((x * y) + z), x)].
  (((0 <  x) and ((0 <= y) and (0 <= z))) -> (div(((x * y) + z),
  x) = (y + div(z, x)))))

axiom Mod_mult1 :
  (forall x:int. forall y:int. forall z:int [mod(((x * y) + z), x)].
  (((0 <  x) and ((0 <= y) and (0 <= z))) -> (mod(((x * y) + z), x) = mod(z,
  x))))

logic max_int1 : int63

axiom max_intqtdef : (int63qtint(max_int1) = 4611686018427387903)

logic min_int1 : int63

axiom min_intqtdef : (int63qtint(min_int1) = (- 4611686018427387904))

logic concat1 : string, string -> string

axiom concat_assoc :
  (forall s1:string. forall s2:string. forall s3:string. (concat1(concat1(s1,
  s2), s3) = concat1(s1, concat1(s2, s3))))

logic rliteral : string

axiom concat_empty :
  (forall s:string. (concat1(s, rliteral) = concat1(rliteral, s)))

axiom concat_empty1 : (forall s:string. (concat1(rliteral, s) = s))

logic length1 : string -> int

axiom length_empty : (length1(rliteral) = 0)

axiom length_concat :
  (forall s1:string. forall s2:string. (length1(concat1(s1,
  s2)) = (length1(s1) + length1(s2))))

logic lt : string, string -> prop

axiom lt_empty : (forall s:string. ((not (s = rliteral)) -> lt(rliteral, s)))

axiom lt_not_com :
  (forall s1:string. forall s2:string. (lt(s1, s2) -> (not lt(s2, s1))))

axiom lt_ref : (forall s1:string. (not lt(s1, s1)))

axiom lt_trans :
  (forall s1:string. forall s2:string. forall s3:string. ((lt(s1, s2) and
  lt(s2, s3)) -> lt(s1, s3)))

logic le : string, string -> prop

axiom le_empty : (forall s:string. le(rliteral, s))

axiom le_ref : (forall s1:string. le(s1, s1))

axiom lt_le :
  (forall s1:string. forall s2:string. (lt(s1, s2) -> le(s1, s2)))

axiom lt_le_eq :
  (forall s1:string. forall s2:string. (le(s1, s2) -> (lt(s1, s2) or
  (s1 = s2))))

axiom le_trans :
  (forall s1:string. forall s2:string. forall s3:string. ((le(s1, s2) and
  le(s2, s3)) -> le(s1, s3)))

logic s_at : string, int -> string

axiom at_out_of_range :
  (forall s:string. forall i:int. (((i <  0) or (length1(s) <= i)) ->
  (s_at(s, i) = rliteral)))

axiom at_empty : (forall i:int. (s_at(rliteral, i) = rliteral))

axiom at_length :
  (forall s:string. forall i:int. (((0 <= i) and (i <  length1(s))) ->
  (length1(s_at(s, i)) = 1)))

axiom at_length1 :
  (forall s:string. forall i:int. ((not ((0 <= i) and (i <  length1(s)))) ->
  (length1(s_at(s, i)) = 0)))

axiom concat_at :
  (forall s1:string. forall s2:string.
  (forall i:int. (((0 <= i) and (i <  length1(s1))) -> (s_at(concat1(s1, s2),
  i) = s_at(s1, i)))))

axiom concat_at1 :
  (forall s1:string. forall s2:string. (let s = concat1(s1, s2) : string in
  (forall i:int. (((length1(s1) <= i) and (i <  length1(s))) -> (s_at(s,
  i) = s_at(s2, (i - length1(s1))))))))

logic substring : string, int, int -> string

axiom substring_out_of_range :
  (forall s:string. forall i:int. forall x:int. (((i <  0) or
  (length1(s) <= i)) -> (substring(s, i, x) = rliteral)))

axiom substring_of_length_zero_or_less :
  (forall s:string. forall i:int. forall x:int. ((x <= 0) -> (substring(s, i,
  x) = rliteral)))

axiom substring_of_empty :
  (forall i:int. forall x:int. (substring(rliteral, i, x) = rliteral))

axiom substring_smaller :
  (forall s:string. forall i:int. forall x:int. (length1(substring(s, i,
  x)) <= length1(s)))

axiom substring_smaller_x :
  (forall s:string. forall i:int. forall x:int. ((0 <= x) ->
  (length1(substring(s, i, x)) <= x)))

axiom substring_length :
  (forall s:string. forall i:int. forall x:int. (((0 <= x) and ((0 <= i) and
  (i <  length1(s)))) -> ((length1(s) <  (i + x)) -> (length1(substring(s, i,
  x)) = (length1(s) - i)))))

axiom substring_length1 :
  (forall s:string. forall i:int. forall x:int. (((0 <= x) and ((0 <= i) and
  (i <  length1(s)))) -> ((not (length1(s) <  (i + x))) ->
  (length1(substring(s, i, x)) = x))))

axiom substring_at :
  (forall s:string. forall i:int. (s_at(s, i) = substring(s, i, 1)))

axiom substring_substring :
  (forall s:string. forall ofs:int. forall len:int. forall ofsqt:int.
  forall lenqt:int. (((0 <= ofs) and (ofs <= length1(s))) -> ((0 <= len) ->
  (((ofs + len) <= length1(s)) -> (((0 <= ofsqt) and (ofsqt <= len)) ->
  ((0 <= lenqt) -> (((ofsqt + lenqt) <= len) -> (substring(substring(s, ofs,
  len), ofsqt, lenqt) = substring(s, (ofs + ofsqt), lenqt)))))))))

axiom concat_substring :
  (forall s:string. forall ofs:int. forall len:int. forall lenqt:int.
  (((0 <= ofs) and (ofs <= length1(s))) -> ((0 <= len) ->
  (((ofs + len) <= length1(s)) -> ((0 <= lenqt) ->
  (((0 <= ((ofs + len) + lenqt)) and
  (((ofs + len) + lenqt) <= length1(s))) -> (concat1(substring(s, ofs, len),
  substring(s, (ofs + len), lenqt)) = substring(s, ofs, (len + lenqt)))))))))

logic prefixof : string, string -> prop

axiom prefixof_substring :
  (forall s1:string. forall s2:string. (prefixof(s1, s2) ->
  (s1 = substring(s2, 0, length1(s1)))))

axiom prefixof_substring1 :
  (forall s1:string. forall s2:string. ((s1 = substring(s2, 0,
  length1(s1))) -> prefixof(s1, s2)))

axiom prefixof_concat :
  (forall s1:string. forall s2:string. prefixof(s1, concat1(s1, s2)))

axiom prefixof_empty : (forall s2:string. prefixof(rliteral, s2))

axiom prefixof_empty2 :
  (forall s1:string. ((not (s1 = rliteral)) -> (not prefixof(s1, rliteral))))

logic suffixof : string, string -> prop

axiom suffixof_substring :
  (forall s1:string. forall s2:string. (suffixof(s1, s2) ->
  (s1 = substring(s2, (length1(s2) - length1(s1)), length1(s1)))))

axiom suffixof_substring1 :
  (forall s1:string. forall s2:string. ((s1 = substring(s2,
  (length1(s2) - length1(s1)), length1(s1))) -> suffixof(s1, s2)))

axiom suffixof_concat :
  (forall s1:string. forall s2:string. suffixof(s2, concat1(s1, s2)))

axiom suffixof_empty : (forall s2:string. suffixof(rliteral, s2))

axiom suffixof_empty2 :
  (forall s1:string. ((not (s1 = rliteral)) -> (not suffixof(s1, rliteral))))

logic contains : string, string -> prop

axiom contains_prefixof :
  (forall s1:string. forall s2:string. (prefixof(s1, s2) -> contains(s2,
  s1)))

axiom contains_suffixof :
  (forall s1:string. forall s2:string. (suffixof(s1, s2) -> contains(s2,
  s1)))

axiom contains_empty :
  (forall s2:string. (contains(rliteral, s2) -> (s2 = rliteral)))

axiom contains_empty1 :
  (forall s2:string. ((s2 = rliteral) -> contains(rliteral, s2)))

axiom contains_empty2 : (forall s1:string. contains(s1, rliteral))

axiom contains_substring :
  (forall s1:string. forall s2:string. forall i:int. ((substring(s1, i,
  length1(s2)) = s2) -> contains(s1, s2)))

axiom contains_concat :
  (forall s1:string. forall s2:string. contains(concat1(s1, s2), s1))

axiom contains_concat1 :
  (forall s1:string. forall s2:string. contains(concat1(s1, s2), s2))

axiom contains_at :
  (forall s1:string. forall s2:string. forall i:int. ((s_at(s1, i) = s2) ->
  contains(s1, s2)))

logic indexof : string, string, int -> int

axiom indexof_empty :
  (forall s:string. forall i:int. (((0 <= i) and (i <= length1(s))) ->
  (indexof(s, rliteral, i) = i)))

axiom indexof_empty1 :
  (forall s:string. forall i:int. (let j = indexof(rliteral, s, i) : int in
  ((j = (- 1)) or ((s = rliteral) and ((i = j) and (j = 0))))))

axiom indexof_contains :
  (forall s1:string. forall s2:string. (contains(s1, s2) -> (0 <= indexof(s1,
  s2, 0))))

axiom indexof_contains1 :
  (forall s1:string. forall s2:string. (contains(s1, s2) -> (indexof(s1, s2,
  0) <= length1(s1))))

axiom indexof_contains2 :
  (forall s1:string. forall s2:string. (contains(s1, s2) -> (substring(s1,
  indexof(s1, s2, 0), length1(s2)) = s2)))

axiom contains_indexof :
  (forall s1:string. forall s2:string. forall i:int. ((0 <= indexof(s1, s2,
  i)) -> contains(s1, s2)))

axiom not_contains_indexof :
  (forall s1:string. forall s2:string. forall i:int. ((not contains(s1,
  s2)) -> (indexof(s1, s2, i) = (- 1))))

axiom substring_indexof :
  (forall s1:string. forall s2:string. forall i:int. (let j = indexof(s1, s2,
  i) : int in ((0 <= j) -> (substring(s1, j, length1(s2)) = s2))))

axiom indexof_out_of_range :
  (forall i:int. forall s1:string. forall s2:string. ((not ((0 <= i) and
  (i <= length1(s1)))) -> (indexof(s1, s2, i) = (- 1))))

axiom indexof_in_range :
  (forall s1:string. forall s2:string. forall i:int. (let j = indexof(s1, s2,
  i) : int in (((0 <= i) and (i <= length1(s1))) -> ((j = (- 1)) or
  ((i <= j) and (j <= length1(s1)))))))

axiom indexof_contains_substring :
  (forall s1:string. forall s2:string. forall i:int. ((((0 <= i) and
  (i <= length1(s1))) and contains(substring(s1, i, (length1(s1) - i)),
  s2)) -> (i <= indexof(s1, s2, i))))

axiom indexof_contains_substring1 :
  (forall s1:string. forall s2:string. forall i:int. ((((0 <= i) and
  (i <= length1(s1))) and contains(substring(s1, i, (length1(s1) - i)),
  s2)) -> (indexof(s1, s2, i) <= length1(s1))))

logic replace : string, string, string -> string

axiom replace_empty :
  (forall s1:string. forall s3:string. (replace(s1, rliteral,
  s3) = concat1(s3, s1)))

axiom replace_not_contains :
  (forall s1:string. forall s2:string. forall s3:string. ((not contains(s1,
  s2)) -> (replace(s1, s2, s3) = s1)))

axiom replace_empty2 :
  (forall s2:string. forall s3:string. ((s2 = rliteral) -> (replace(rliteral,
  s2, s3) = s3)))

axiom replace_empty21 :
  (forall s2:string. forall s3:string. ((not (s2 = rliteral)) ->
  (replace(rliteral, s2, s3) = rliteral)))

axiom replace_substring_indexof :
  (forall s1:string. forall s2:string. forall s3:string. (let j = indexof(s1,
  s2, 0) : int in (replace(s1, s2,
  s3) = (if (j <  0) then s1 else concat1(concat1(substring(s1, 0, j), s3),
  substring(s1, (j + length1(s2)), ((length1(s1) - j) - length1(s2))))))))

logic replaceall : string, string, string -> string

axiom replaceall_empty1 :
  (forall s1:string. forall s3:string. (replaceall(s1, rliteral, s3) = s1))

axiom not_contains_replaceall :
  (forall s1:string. forall s2:string. forall s3:string. ((not contains(s1,
  s2)) -> (replaceall(s1, s2, s3) = s1)))

logic to_int : string -> int

axiom to_int_gt_minus_1 : (forall s:string. ((- 1) <= to_int(s)))

axiom to_int_empty : (to_int(rliteral) = (- 1))

predicate is_digit(s: string) = (((0 <= to_int(s)) and (to_int(s) <= 9)) and
  (length1(s) = 1))

logic from_int2 : int -> string

axiom from_int_negative :
  (forall i:int. ((i <  0) -> (from_int2(i) = rliteral)))

axiom from_int_negative1 :
  (forall i:int. ((from_int2(i) = rliteral) -> (i <  0)))

axiom from_int_to_int :
  (forall i:int. ((0 <= i) -> (to_int(from_int2(i)) = i)))

axiom from_int_to_int1 :
  (forall i:int. ((not (0 <= i)) -> (to_int(from_int2(i)) = (- 1))))

type char

logic contents1 : char -> string

axiom charqtinvariant :
  (forall self:char [contents1(self)]. (length1(contents1(self)) = 1))

axiom char_eq :
  (forall c1:char. forall c2:char. ((contents1(c1) = contents1(c2)) ->
  (c1 = c2)))

logic code : char -> int

axiom code1 : (forall c:char. (0 <= code(c)))

axiom code2 : (forall c:char. (code(c) <  256))

logic chr : int -> char

axiom code_chr :
  (forall n:int. (((0 <= n) and (n <  256)) -> (code(chr(n)) = n)))

axiom chr_code : (forall c:char. (chr(code(c)) = c))

logic get1 : string, int -> char

axiom get2 :
  (forall s:string. forall i:int. (((0 <= i) and (i <  length1(s))) ->
  (contents1(get1(s, i)) = s_at(s, i))))

axiom substring_get :
  (forall s:string. forall ofs:int. forall len:int. forall i:int.
  (((0 <= ofs) and (ofs <= length1(s))) -> ((0 <= len) ->
  (((ofs + len) <= length1(s)) -> (((0 <= i) and (i <  len)) ->
  (get1(substring(s, ofs, len), i) = get1(s, (ofs + i))))))))

axiom concat_first :
  (forall s1:string. forall s2:string.
  (forall i:int. (((0 <= i) and (i <  length1(s1))) -> (get1(concat1(s1, s2),
  i) = get1(s1, i)))))

axiom concat_second :
  (forall s1:string. forall s2:string.
  (forall i:int. (((length1(s1) <= i) and
  (i <  (length1(s1) + length1(s2)))) -> (get1(concat1(s1, s2), i) = get1(s2,
  (i - length1(s1)))))))

predicate eq_string(s1: string, s2: string) =
  ((length1(s1) = length1(s2)) and
  (forall i:int. (((0 <= i) and (i <  length1(s1))) -> (get1(s1,
  i) = get1(s2, i)))))

axiom extensionality2 :
  (forall s1:string. forall s2:string. (eq_string(s1, s2) -> (s1 = s2)))

logic make1 : int, char -> string

axiom make_length :
  (forall size:int. forall v:char. ((0 <= size) -> (length1(make1(size,
  v)) = size)))

axiom make_contents :
  (forall size:int. forall v:char. ((0 <= size) ->
  (forall i:int. (((0 <= i) and (i <  size)) -> (get1(make1(size, v),
  i) = v)))))

logic int_to_string : int -> string

logic circ_to_string_ : circuit -> string

logic rliteral1 : string

logic rliteral2 : string

logic rliteral3 : string

logic rliteral4 : string

logic rliteral5 : string

logic rliteral6 : string

logic rliteral7 : string

logic rliteral8 : string

logic rliteral9 : string

logic rliteral10 : string

logic rliteral11 : string

axiom circ_to_string_qtdef :
  (forall c:circuit.
  (forall x:int. ((pre(c) = Phase(x)) ->
  (circ_to_string_(c) = concat1(concat1(rliteral1, int_to_string(x)),
  rliteral2)))))

axiom circ_to_string_qtdef1 :
  (forall c:circuit.
  (forall x:int. ((pre(c) = Rz(x)) ->
  (circ_to_string_(c) = concat1(concat1(rliteral3, int_to_string(x)),
  rliteral2)))))

axiom circ_to_string_qtdef2 :
  (forall c:circuit. ((pre(c) = Hadamard) ->
  (circ_to_string_(c) = rliteral4)))

axiom circ_to_string_qtdef3 :
  (forall c:circuit. ((pre(c) = Cnot) -> (circ_to_string_(c) = rliteral5)))

axiom circ_to_string_qtdef4 :
  (forall c:circuit. ((pre(c) = Swap) -> (circ_to_string_(c) = rliteral6)))

axiom circ_to_string_qtdef5 :
  (forall c:circuit. ((pre(c) = Id) -> (circ_to_string_(c) = rliteral7)))

axiom circ_to_string_qtdef6 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Sequence(x,
  x1)) -> (circ_to_string_(c) = concat1(concat1(circ_to_string_(to_qc(x)),
  rliteral8), circ_to_string_(to_qc(x1)))))))

axiom circ_to_string_qtdef7 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Parallel(x,
  x1)) -> (circ_to_string_(c) = concat1(concat1(concat1(concat1(rliteral9,
  circ_to_string_(to_qc(x))), rliteral10), circ_to_string_(to_qc(x1))),
  rliteral2)))))

axiom circ_to_string_qtdef8 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:int. ((pre(c) = Ancillas(x, x1)) ->
  (circ_to_string_(c) = concat1(concat1(rliteral11,
  circ_to_string_(to_qc(x))), rliteral2)))))

logic rliteral12 : string

function circ_to_string(c: circuit) : string = concat1(circ_to_string_(c),
  rliteral12)

axiom to_qc_rev : (forall c:circuit. (c = to_qc(pre(c))))

axiom to_qc_pre : (forall c:circuit. (to_qc(pre(c)) = c))

axiom pre_rev : (forall c:circuit_pre. (correct(c) -> (c = pre(to_qc(c)))))

axiom pre_to_qc : (forall c:circuit_pre. (correct(c) -> (pre(to_qc(c)) = c)))

logic circ_to_pps : circuit -> pps

axiom circ_to_ppsqtdef :
  (forall c:circuit.
  (forall k:int. ((pre(c) = Phase(k)) -> (circ_to_pps(c) = pps_phase(k)))))

axiom circ_to_ppsqtdef1 :
  (forall c:circuit.
  (forall k:int. ((pre(c) = Rz(k)) -> (circ_to_pps(c) = pps_rz(k)))))

axiom circ_to_ppsqtdef2 :
  (forall c:circuit. ((pre(c) = Hadamard) ->
  (circ_to_pps(c) = pps_hadamard)))

axiom circ_to_ppsqtdef3 :
  (forall c:circuit. ((pre(c) = Cnot) -> (circ_to_pps(c) = pps_cnot(0, 1,
  2))))

axiom circ_to_ppsqtdef4 :
  (forall c:circuit. ((pre(c) = Swap) -> (circ_to_pps(c) = pps_swap(0, 1,
  2))))

axiom circ_to_ppsqtdef5 :
  (forall c:circuit. ((pre(c) = Id) -> (circ_to_pps(c) = pps_id)))

axiom circ_to_ppsqtdef6 :
  (forall c:circuit.
  (forall d:circuit_pre. forall e:circuit_pre. ((pre(c) = Sequence(d, e)) ->
  (circ_to_pps(c) = pps_seq(circ_to_pps(to_qc(d)), circ_to_pps(to_qc(e)))))))

axiom circ_to_ppsqtdef7 :
  (forall c:circuit.
  (forall d:circuit_pre. forall e:circuit_pre. ((pre(c) = Parallel(d, e)) ->
  (circ_to_pps(c) = pps_par(circ_to_pps(to_qc(d)), circ_to_pps(to_qc(e)))))))

axiom circ_to_ppsqtdef8 :
  (forall c:circuit.
  (forall d:circuit_pre. forall i:int. ((pre(c) = Ancillas(d, i)) ->
  (circ_to_pps(c) = pps_ancs(circ_to_pps(to_qc(d)), i)))))

axiom circ_to_ppsqtspec :
  (forall c:circuit. (circ_to_pps(c) = circ_to_pps_pre(pre(c))))

axiom circ_to_ppsqtspec1 :
  (forall c:circuit. (h_width(circ_to_pps(c)) = width_pre(pre(c))))

axiom circ_to_ppsqtspec2 : (forall c:circuit. (1 <= h_width(circ_to_pps(c))))

function width(c: circuit) : int = width_pre(pre(c))

axiom widthqtspec : (forall c:circuit. (1 <= width(c)))

axiom widthqtspec1 : (forall c:circuit. (width(c) = h_width(circ_to_pps(c))))

logic mat_sem : circuit -> complex matrix

axiom mat_semqtdef :
  (forall c:circuit.
  (forall k:int. ((pre(c) = Phase(k)) -> (mat_sem(c) = sem_phase_mat(k)))))

axiom mat_semqtdef1 :
  (forall c:circuit.
  (forall k:int. ((pre(c) = Rz(k)) -> (mat_sem(c) = sem_rz_mat(k)))))

axiom mat_semqtdef2 :
  (forall c:circuit. ((pre(c) = Hadamard) ->
  (mat_sem(c) = sem_hadamard_mat(void))))

axiom mat_semqtdef3 :
  (forall c:circuit. ((pre(c) = Cnot) -> (mat_sem(c) = sem_cnot_mat(void))))

axiom mat_semqtdef4 :
  (forall c:circuit. ((pre(c) = Swap) -> (mat_sem(c) = sem_swap_mat(void))))

axiom mat_semqtdef5 :
  (forall c:circuit. ((pre(c) = Id) -> (mat_sem(c) = sem_id_mat(void))))

axiom mat_semqtdef6 :
  (forall c:circuit.
  (forall d:circuit_pre. forall e:circuit_pre. ((pre(c) = Sequence(d, e)) ->
  (mat_sem(c) = mat_mult(mat_sem(to_qc(e)), mat_sem(to_qc(d)))))))

axiom mat_semqtdef7 :
  (forall c:circuit.
  (forall d:circuit_pre. forall e:circuit_pre. ((pre(c) = Parallel(d, e)) ->
  (mat_sem(c) = kronecker(mat_sem(to_qc(d)), mat_sem(to_qc(e)))))))

axiom mat_semqtdef8 :
  (forall c:circuit.
  (forall d:circuit_pre. forall i:int. ((pre(c) = Ancillas(d, i)) ->
  (mat_sem(c) = pps_to_mat(pps_ancs(circ_to_pps(to_qc(d)), i))))))

axiom mat_semqtspec :
  (forall c:circuit. (rows(mat_sem(c)) = power(2, width_pre(pre(c)))))

axiom mat_semqtspec1 :
  (forall c:circuit. (columns(mat_sem(c)) = power(2, width_pre(pre(c)))))

axiom mat_semqtspec2 :
  (forall c:circuit.
  (forall x:bitvec. ((length(x) = width_pre(pre(c))) -> (mat_mult(mat_sem(c),
  bv_to_ket(x)) = pps_apply_basis(circ_to_pps(c), x)))))

axiom mat_semqtspec3 :
  (forall c:circuit.
  (forall x:complex matrix. (is_a_ket_l(x, width_pre(pre(c))) ->
  (mat_mult(mat_sem(c), x) = pps_apply(circ_to_pps(c), x)))))

axiom pps_to_mat_mat_sem :
  (forall c:circuit. (mat_sem(c) = pps_to_mat(circ_to_pps(c))))

axiom sem_correction_gen :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (mat_mult(mat_sem(c), x) = pps_apply(circ_to_pps(c), x))))

axiom sem_correction_gen_rev :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (pps_apply(circ_to_pps(c), x) = mat_mult(mat_sem(c), x))))

logic size : circuit -> int

axiom sizeqtdef :
  (forall c:circuit. (forall w:int. ((pre(c) = Phase(w)) -> (size(c) = 1))))

axiom sizeqtdef1 :
  (forall c:circuit. (forall w:int. ((pre(c) = Rz(w)) -> (size(c) = 1))))

axiom sizeqtdef2 : (forall c:circuit. ((pre(c) = Hadamard) -> (size(c) = 1)))

axiom sizeqtdef3 : (forall c:circuit. ((pre(c) = Cnot) -> (size(c) = 1)))

axiom sizeqtdef4 : (forall c:circuit. ((pre(c) = Swap) -> (size(c) = 0)))

axiom sizeqtdef5 : (forall c:circuit. ((pre(c) = Id) -> (size(c) = 0)))

axiom sizeqtdef6 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Sequence(x,
  x1)) -> (size(c) = (size(to_qc(x)) + size(to_qc(x1)))))))

axiom sizeqtdef7 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Parallel(x,
  x1)) -> (size(c) = (size(to_qc(x)) + size(to_qc(x1)))))))

axiom sizeqtdef8 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:int. ((pre(c) = Ancillas(x, x1)) ->
  (size(c) = size(to_qc(x))))))

axiom sizeqtspec : (forall c:circuit. (0 <= size(c)))

function min(x: int, y: int) : int = (if (x <= y) then x else y)

function max(x: int, y: int) : int = (if (x <= y) then y else x)

axiom Min_r : (forall x:int. forall y:int. ((y <= x) -> (min(x, y) = y)))

axiom Max_l : (forall x:int. forall y:int. ((y <= x) -> (max(x, y) = x)))

axiom Min_comm : (forall x:int. forall y:int. (min(x, y) = min(y, x)))

axiom Max_comm : (forall x:int. forall y:int. (max(x, y) = max(y, x)))

axiom Min_assoc :
  (forall x:int. forall y:int. forall z:int. (min(min(x, y), z) = min(x,
  min(y, z))))

axiom Max_assoc :
  (forall x:int. forall y:int. forall z:int. (max(max(x, y), z) = max(x,
  max(y, z))))

logic min_set : int set -> int

axiom min_setqtdef :
  (forall s:int set. ((0 <  cardinal(s)) -> ((cardinal(s) = 1) ->
  (min_set(s) = choose(s)))))

axiom min_setqtdef1 :
  (forall s:int set. ((0 <  cardinal(s)) -> ((not (cardinal(s) = 1)) ->
  (min_set(s) = min(choose(s), min_set(remove(choose(s), s)))))))

axiom min_setqtspec :
  (forall s:int set. ((0 <  cardinal(s)) -> mem(min_set(s), s)))

axiom min_setqtspec1 :
  (forall s:int set. ((0 <  cardinal(s)) ->
  (forall e:int. (mem(e, s) -> (min_set(s) <= e)))))

logic max_set : int set -> int

axiom max_setqtdef :
  (forall s:int set. ((0 <  cardinal(s)) -> ((cardinal(s) = 1) ->
  (max_set(s) = choose(s)))))

axiom max_setqtdef1 :
  (forall s:int set. ((0 <  cardinal(s)) -> ((not (cardinal(s) = 1)) ->
  (max_set(s) = max(choose(s), max_set(remove(choose(s), s)))))))

axiom max_setqtspec :
  (forall s:int set. ((0 <  cardinal(s)) -> mem(max_set(s), s)))

axiom max_setqtspec1 :
  (forall s:int set. ((0 <  cardinal(s)) ->
  (forall e:int. (mem(e, s) -> (e <= max_set(s))))))

function max3(a: int, b: int, c: int) : int = max(max(a, b), c)

axiom max3qtspec :
  (forall a:int. forall b:int. forall c:int. (a <= max3(a, b, c)))

axiom max3qtspec1 :
  (forall a:int. forall b:int. forall c:int. (b <= max3(a, b, c)))

axiom max3qtspec2 :
  (forall a:int. forall b:int. forall c:int. (c <= max3(a, b, c)))

axiom max3qtspec3 :
  (forall a:int. forall b:int. forall c:int. (max3(a, b, c) = max(a, max(b,
  c))))

function min3(a: int, b: int, c: int) : int = min(min(a, b), c)

axiom min3qtspec :
  (forall a:int. forall b:int. forall c:int. (min3(a, b, c) <= a))

axiom min3qtspec1 :
  (forall a:int. forall b:int. forall c:int. (min3(a, b, c) <= b))

axiom min3qtspec2 :
  (forall a:int. forall b:int. forall c:int. (min3(a, b, c) <= c))

axiom min3qtspec3 :
  (forall a:int. forall b:int. forall c:int. (min3(a, b, c) = min(a, min(b,
  c))))

function midd3(a: int, b: int, c: int) : int = (if (min3(a, b,
  c) = a) then (if (max3(a, b, c) = b) then c else b) else (if (min3(a, b,
  c) = b) then (if (max3(a, b, c) = a) then c else a) else (if (max3(a, b,
  c) = a) then b else a)))

axiom midd3qtspec :
  (forall a:int. forall b:int. forall c:int. (min3(a, b, c) <= midd3(a, b,
  c)))

axiom midd3qtspec1 :
  (forall a:int. forall b:int. forall c:int. (midd3(a, b, c) <= max3(a, b,
  c)))

logic max3_strict : int, int, int -> int

axiom max3_strictqtdef :
  (forall a:int. forall b:int. forall c:int. ((not (a = b)) ->
  ((not (a = c)) -> ((not (b = c)) -> (max3_strict(a, b, c) = max3(a, b,
  c))))))

axiom max3_strictqtspec :
  (forall a:int. forall b:int. forall c:int. ((not (a = b)) ->
  ((not (a = c)) -> ((not (b = c)) -> (min3(a, b, c) <  midd3(a, b, c))))))

axiom max3_strictqtspec1 :
  (forall a:int. forall b:int. forall c:int. ((not (a = b)) ->
  ((not (a = c)) -> ((not (b = c)) -> (midd3(a, b, c) <  max3_strict(a, b,
  c))))))

logic min3_strict : int, int, int -> int

axiom min3_strictqtdef :
  (forall a:int. forall b:int. forall c:int. ((not (a = b)) ->
  ((not (a = c)) -> ((not (b = c)) -> (min3_strict(a, b, c) = min3(a, b,
  c))))))

axiom min3_strictqtspec :
  (forall a:int. forall b:int. forall c:int. ((not (a = b)) ->
  ((not (a = c)) -> ((not (b = c)) -> (min3_strict(a, b, c) <  midd3(a, b,
  c))))))

axiom min3_strictqtspec1 :
  (forall a:int. forall b:int. forall c:int. ((not (a = b)) ->
  ((not (a = c)) -> ((not (b = c)) -> (midd3(a, b, c) <  max3_strict(a, b,
  c))))))

logic midd3_strict : int, int, int -> int

axiom midd3_strictqtdef :
  (forall a:int. forall b:int. forall c:int. ((not (a = b)) ->
  ((not (a = c)) -> ((not (b = c)) -> (midd3_strict(a, b, c) = midd3(a, b,
  c))))))

axiom midd3_strictqtspec :
  (forall a:int. forall b:int. forall c:int. ((not (a = b)) ->
  ((not (a = c)) -> ((not (b = c)) -> (min3_strict(a, b,
  c) <  midd3_strict(a, b, c))))))

axiom midd3_strictqtspec1 :
  (forall a:int. forall b:int. forall c:int. ((not (a = b)) ->
  ((not (a = c)) -> ((not (b = c)) -> (midd3_strict(a, b,
  c) <  max3_strict(a, b, c))))))

axiom max_right : (forall a:int. forall b:int. ((a <= b) -> (max(a, b) = b)))

axiom max_left : (forall a:int. forall b:int. ((b <= a) -> (max(a, b) = a)))

logic min_filter : int set, (int,bool) farray -> int

axiom min_filterqtdef :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) ->
  (((p[min_set(s)]) = true) -> (min_filter(s, p) = min_set(s)))))

axiom min_filterqtdef1 :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) ->
  ((not ((p[min_set(s)]) = true)) -> (min_filter(s,
  p) = min_filter(remove(min_set(s), s), p)))))

axiom min_filterqtspec :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) -> ((p[min_filter(s,
  p)]) = true)))

axiom min_filterqtspec1 :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) -> mem(min_filter(s, p),
  s)))

axiom min_filterqtspec2 :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) ->
  (forall e:int. (mem(e, s) -> (((p[e]) = true) -> (min_filter(s, p) <= e))))))

axiom min_filterqtspec3 :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) ->
  (forall e:int. (mem(e, s) -> ((e <  min_filter(s, p)) ->
  (not ((p[e]) = true)))))))

axiom min_filter_min_set :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) -> (min_filter(s,
  p) = min_set(my_filter(s, p)))))

logic max_filter : int set, (int,bool) farray -> int

axiom max_filterqtdef :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) ->
  (((p[max_set(s)]) = true) -> (max_filter(s, p) = max_set(s)))))

axiom max_filterqtdef1 :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) ->
  ((not ((p[max_set(s)]) = true)) -> (max_filter(s,
  p) = max_filter(remove(max_set(s), s), p)))))

axiom max_filterqtspec :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) -> ((p[max_filter(s,
  p)]) = true)))

axiom max_filterqtspec1 :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) -> mem(max_filter(s, p),
  s)))

axiom max_filterqtspec2 :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) ->
  (forall e:int. (mem(e, s) -> (((p[e]) = true) -> (e <= max_filter(s, p)))))))

axiom max_filterqtspec3 :
  (forall s:int set. forall p:(int,bool) farray.
  ((exists e:int. (mem(e, s) and ((p[e]) = true))) ->
  (forall e:int. (mem(e, s) -> ((max_filter(s, p) <  e) ->
  (not ((p[e]) = true)))))))

axiom appr_pre :
  (forall theta:complex. forall n:int. ((0 <  n) -> (real_(theta) ->
  ((infix_lsdt(c_zero, theta) and infix_lseqdt(theta, c_one)) ->
  (exists k:int. (mem(k, to_fset(0, (n + 1))) and
  infix_lseqdt(modulus(infix_mndt(theta, infix_sldt(i_to_c(k), i_to_c(n)))),
  infix_sldt(c_one, i_to_c((n * 2))))))))))

axiom appr :
  (forall theta:complex. forall n:int. ((0 <  n) -> (real_(theta) ->
  ((infix_lseqdt(c_zero, theta) and infix_lseqdt(theta, c_one)) ->
  (exists k:int. (mem(k, to_fset(0, (n + 1))) and
  infix_lseqdt(modulus(infix_mndt(theta, infix_sldt(i_to_c(k), i_to_c(n)))),
  infix_sldt(c_one, i_to_c((n * 2))))))))))

logic min_complex : complex, complex -> complex

axiom min_complexqtdef :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  (infix_lseqdt(a, b) -> (min_complex(a, b) = a)))))

axiom min_complexqtdef1 :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  ((not infix_lseqdt(a, b)) -> (min_complex(a, b) = b)))))

axiom min_complexqtspec :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  real_(min_complex(a, b)))))

axiom min_complexqtspec1 :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  infix_lseqdt(min_complex(a, b), a))))

axiom min_complexqtspec2 :
  (forall a:complex. forall b:complex. (real_(a) -> (real_(b) ->
  infix_lseqdt(min_complex(a, b), b))))

logic min_set_complex : 'a set, ('a,complex) farray -> complex

axiom min_set_complexqtdef :
  (forall s:'a set. forall f:('a,complex) farray. ((0 <  cardinal(s)) ->
  ((forall x:'a. (mem(x, s) -> real_((f[x])))) -> ((cardinal(s) = 1) ->
  (min_set_complex(s, f) = (f[choose(s)]))))))

axiom min_set_complexqtdef1 :
  (forall s:'a set. forall f:('a,complex) farray. ((0 <  cardinal(s)) ->
  ((forall x:'a. (mem(x, s) -> real_((f[x])))) -> ((not (cardinal(s) = 1)) ->
  (min_set_complex(s, f) = min_complex((f[choose(s)]),
  min_set_complex(remove(choose(s), s), f)))))))

axiom min_set_complexqtspec :
  (forall s:'a set. forall f:('a,complex) farray. ((0 <  cardinal(s)) ->
  ((forall x:'a. (mem(x, s) -> real_((f[x])))) ->
  (exists e:'a. (mem(e, s) and (min_set_complex(s, f) = (f[e])))))))

axiom min_set_complexqtspec1 :
  (forall s:'a set. forall f:('a,complex) farray. ((0 <  cardinal(s)) ->
  ((forall x:'a. (mem(x, s) -> real_((f[x])))) -> real_(min_set_complex(s,
  f)))))

axiom min_set_complexqtspec2 :
  (forall s:'a set. forall f:('a,complex) farray. ((0 <  cardinal(s)) ->
  ((forall x:'a. (mem(x, s) -> real_((f[x])))) ->
  (forall e:'a. (mem(e, s) -> infix_lseqdt(min_set_complex(s, f), (f[e])))))))

axiom min_set_complex_pos :
  (forall s:'a set. forall f:('a,complex) farray. ((0 <  cardinal(s)) ->
  ((forall x:'a. (mem(x, s) -> real_((f[x])))) ->
  ((forall x:'a. (mem(x, s) -> infix_lseqdt(c_zero, (f[x])))) ->
  infix_lseqdt(c_zero, min_set_complex(s, f))))))

logic ancillas : circuit -> int

axiom ancillasqtdef :
  (forall c:circuit.
  (forall w:int. ((pre(c) = Phase(w)) -> (ancillas(c) = 0))))

axiom ancillasqtdef1 :
  (forall c:circuit. (forall w:int. ((pre(c) = Rz(w)) -> (ancillas(c) = 0))))

axiom ancillasqtdef2 :
  (forall c:circuit. ((pre(c) = Hadamard) -> (ancillas(c) = 0)))

axiom ancillasqtdef3 :
  (forall c:circuit. ((pre(c) = Cnot) -> (ancillas(c) = 0)))

axiom ancillasqtdef4 :
  (forall c:circuit. ((pre(c) = Swap) -> (ancillas(c) = 0)))

axiom ancillasqtdef5 :
  (forall c:circuit. ((pre(c) = Id) -> (ancillas(c) = 0)))

axiom ancillasqtdef6 :
  (forall c:circuit.
  (forall d:circuit_pre. forall e:circuit_pre. ((pre(c) = Sequence(d, e)) ->
  (ancillas(c) = max(ancillas(to_qc(d)), ancillas(to_qc(e)))))))

axiom ancillasqtdef7 :
  (forall c:circuit.
  (forall d:circuit_pre. forall e:circuit_pre. ((pre(c) = Parallel(d, e)) ->
  (ancillas(c) = (ancillas(to_qc(d)) + ancillas(to_qc(e)))))))

axiom ancillasqtdef8 :
  (forall c:circuit.
  (forall d:circuit_pre. forall i:int. ((pre(c) = Ancillas(d, i)) ->
  (ancillas(c) = (ancillas(to_qc(d)) + i)))))

axiom ancillasqtspec : (forall c:circuit. (0 <= ancillas(c)))

function range(c: circuit) : int = h_range(circ_to_pps(c))

axiom rangeqtspec : (forall c:circuit. (0 <= range(c)))

function basis_ket(c: circuit, x: (int,int) farray, y: (int,int) farray,
  i: int) : int = (((h_basis_ket(circ_to_pps(c))[x])[y])[i])

axiom basis_ketqtspec :
  (forall c:circuit. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  width(c))) -> ((0 <= (x[i1])) and
   ((x[i1]) <  2)))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  range(c))) -> ((0 <= (y[i1])) and
   ((y[i1]) <  2)))) ->
  (((0 <= i) and (i <  width(c))) -> (0 <= basis_ket(c, x, y, i))))))

axiom basis_ketqtspec1 :
  (forall c:circuit. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  width(c))) -> ((0 <= (x[i1])) and
   ((x[i1]) <  2)))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  range(c))) -> ((0 <= (y[i1])) and
   ((y[i1]) <  2)))) ->
  (((0 <= i) and (i <  width(c))) -> (basis_ket(c, x, y, i) <  2)))))

logic basis_ket_closure : (circuit,((int,int) farray,((int,int) farray,(int,int) farray) farray) farray) farray

axiom basis_ket_closure_def :
  (forall y:circuit. forall y1:(int,int) farray. forall y2:(int,int) farray.
  forall y3:int. (((((basis_ket_closure[y])[y1])[y2])[y3]) = basis_ket(y, y1,
  y2, y3)))

axiom binary_basis_ket :
  (forall c:circuit. forall w:int. forall x:(int,int) farray.
  forall y:(int,int) farray. ((w = width(c)) -> (binary_l(x, w) ->
  (binary_l(y, range(c)) -> binary_l((((basis_ket_closure[c])[x])[y]), w)))))

axiom basis_ket_invariant :
  (forall c:circuit.
  (forall x:(int,int) farray. forall xqt:(int,int) farray.
  forall y:(int,int) farray. forall yqt:(int,int) farray.
  ((forall i:int. (((0 <= i) and (i <  width(c))) -> ((x[i]) = (xqt[i])))) ->
  ((forall i:int. (((0 <= i) and (i <  range(c))) -> ((y[i]) = (yqt[i])))) ->
  (forall i:int. (((0 <= i) and (i <  width(c))) -> (basis_ket(c, x, y,
  i) = basis_ket(c, xqt, yqt, i))))))))

function ang_ind(c: circuit, x: (int,int) farray,
  y: (int,int) farray) : angle = ((h_angle(circ_to_pps(c))[x])[y])

axiom ang_ind_invariant :
  (forall c:circuit.
  (forall x:(int,int) farray. forall xqt:(int,int) farray.
  forall y:(int,int) farray. forall yqt:(int,int) farray.
  ((forall i:int. (((0 <= i) and (i <  width(c))) -> ((x[i]) = (xqt[i])))) ->
  ((forall i:int. (((0 <= i) and (i <  range(c))) -> ((y[i]) = (yqt[i])))) ->
  (ang_ind(c, x, y) = ang_ind(c, xqt, yqt))))))

logic phase : int -> circuit

axiom phaseqtspec : (forall k:int. (pre(phase(k)) = Phase(k)))

axiom phaseqtspec1 : (forall k:int. (circ_to_pps(phase(k)) = pps_phase(k)))

axiom phaseqtspec2 : (forall k:int. (ancillas(phase(k)) = 0))

axiom phaseqtspec3 : (forall k:int. (size(phase(k)) = 1))

axiom phaseqtspec4 : (forall k:int. (range(phase(k)) = 0))

axiom phaseqtspec5 : (forall k:int. (width(phase(k)) = 1))

axiom phaseqtspec6 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket(phase(k), x, y, i) = (x[i])))))

axiom phaseqtspec7 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(phase(k),
  x, y) = infix_sldtsl(1, k))))

logic rz : int -> circuit

axiom rzqtspec : (forall k:int. (pre(rz(k)) = Rz(k)))

axiom rzqtspec1 : (forall k:int. (circ_to_pps(rz(k)) = pps_rz(k)))

axiom rzqtspec2 : (forall k:int. (ancillas(rz(k)) = 0))

axiom rzqtspec3 : (forall k:int. (size(rz(k)) = 1))

axiom rzqtspec4 : (forall k:int. (range(rz(k)) = 0))

axiom rzqtspec5 : (forall k:int. (width(rz(k)) = 1))

axiom rzqtspec6 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket(rz(k), x, y, i) = (x[i])))))

axiom rzqtspec7 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(rz(k), x,
  y) = infix_sldtsl((x[0]), k))))

logic hadamard : circuit

axiom hadamardqtdef : (pre(hadamard) = Hadamard)

axiom hadamardqtdef1 : (circ_to_pps(hadamard) = pps_hadamard)

axiom hadamardqtdef2 : (ancillas(hadamard) = 0)

axiom hadamardqtdef3 : (size(hadamard) = 1)

axiom hadamardqtdef4 : (range(hadamard) = 1)

axiom hadamardqtdef5 : (width(hadamard) = 1)

axiom hadamardqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket(hadamard, x, y, i) = (y[i]))))

axiom hadamardqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(hadamard,
  x, y) = infix_sldtsl(((x[0]) * (y[0])), 1)))

logic cnot : circuit

axiom cnotqtdef : (pre(cnot) = Cnot)

axiom cnotqtdef1 : (circ_to_pps(cnot) = pps_cnot(0, 1, 2))

axiom cnotqtdef2 : (ancillas(cnot) = 0)

axiom cnotqtdef3 : (size(cnot) = 1)

axiom cnotqtdef4 : (range(cnot) = 0)

axiom cnotqtdef5 : (width(cnot) = 2)

axiom cnotqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = 1)) -> (basis_ket(cnot, x, y, i) = (x[i])))))

axiom cnotqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = 1) -> (basis_ket(cnot, x, y,
  i) = (((x[0]) * (1 - (x[i]))) + ((x[i]) * (1 - (x[0]))))))))

axiom cnotqtdef8 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(cnot, x,
  y) = ang_zero))

logic id : circuit

axiom idqtdef : (pre(id) = Id)

axiom idqtdef1 : (circ_to_pps(id) = pps_id)

axiom idqtdef2 : (ancillas(id) = 0)

axiom idqtdef3 : (size(id) = 0)

axiom idqtdef4 : (range(id) = 0)

axiom idqtdef5 : (width(id) = 1)

axiom idqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket(id, x, y, i) = (x[i]))))

axiom idqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(id, x,
  y) = ang_zero))

logic swap : circuit

axiom swapqtdef : (pre(swap) = Swap)

axiom swapqtdef1 : (circ_to_pps(swap) = pps_swap(0, 1, 2))

axiom swapqtdef2 : (ancillas(swap) = 0)

axiom swapqtdef3 : (size(swap) = 0)

axiom swapqtdef4 : (range(swap) = 0)

axiom swapqtdef5 : (width(swap) = 2)

axiom swapqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (basis_ket(swap, x,
  y, 0) = (x[1])))

axiom swapqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (basis_ket(swap, x,
  y, 1) = (x[0])))

axiom swapqtdef8 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  2)) -> (basis_ket(swap, x, y,
  i) = (x[(1 - i)])))))

axiom swapqtdef9 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(swap, x,
  y) = ang_zero))

logic sequence : circuit, circuit -> circuit

axiom sequenceqtspec :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (pre(sequence(d, e)) = Sequence(pre(d), pre(e)))))

axiom sequenceqtspec1 :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) -> (sequence(d,
  e) = to_qc(Sequence(pre(d), pre(e))))))

axiom sequenceqtspec2 :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (circ_to_pps(sequence(d, e)) = pps_seq(circ_to_pps(d), circ_to_pps(e)))))

logic ancilla : circuit, int -> circuit

axiom ancillaqtspec :
  (forall d:circuit. forall i:int. ((1 <= i) -> (((i + 1) <= width(d)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width(d) - i)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(circ_to_pps(d), kronecker(x, ket(i,
   0))) = kronecker((path_sem_target[x]), ket(i, 0))))))) ->
  (pre(ancilla(d, i)) = Ancillas(pre(d), i))))))

axiom ancillaqtspec1 :
  (forall d:circuit. forall i:int. ((1 <= i) -> (((i + 1) <= width(d)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width(d) - i)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(circ_to_pps(d), kronecker(x, ket(i,
   0))) = kronecker((path_sem_target[x]), ket(i, 0))))))) ->
  (ancilla(d, i) = to_qc(Ancillas(pre(d), i)))))))

axiom ancillaqtspec2 :
  (forall d:circuit. forall i:int. ((1 <= i) -> (((i + 1) <= width(d)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width(d) - i)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(circ_to_pps(d), kronecker(x, ket(i,
   0))) = kronecker((path_sem_target[x]), ket(i, 0))))))) ->
  (circ_to_pps(ancilla(d, i)) = pps_ancs(circ_to_pps(d), i))))))

axiom ancilla_pre_cond :
  (forall d:circuit. forall e:circuit_pre. forall i:int.
  ((pre(d) = Ancillas(e, i)) ->
  (exists path_sem_target:(complex matrix,complex matrix) farray.
  (forall x:complex matrix. (is_a_ket_l(x, width(d)) ->
  (pps_apply(circ_to_pps_pre(e), kronecker(x, ket(i,
  0))) = kronecker((path_sem_target[x]), ket(i, 0))))))))

logic parallel : circuit, circuit -> circuit

axiom parallelqtspec :
  (forall d:circuit. forall e:circuit. (pre(parallel(d,
  e)) = Parallel(pre(d), pre(e))))

axiom parallelqtspec1 :
  (forall d:circuit. forall e:circuit. (parallel(d,
  e) = to_qc(Parallel(pre(d), pre(e)))))

axiom parallelqtspec2 :
  (forall d:circuit. forall e:circuit. (circ_to_pps(parallel(d,
  e)) = pps_par(circ_to_pps(d), circ_to_pps(e))))

axiom circ_to_pps_width :
  (forall c:circuit. (h_width(circ_to_pps(c)) = width(c)))

axiom circ_to_pps_range :
  (forall c:circuit. (h_range(circ_to_pps(c)) = range(c)))

axiom circ_to_pps_basis_ket :
  (forall c:circuit. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((((h_basis_ket(circ_to_pps(c))[x])[y])[i]) = basis_ket(c, x,
  y, i)))

axiom circ_to_pps_basis_ket_gen :
  (forall c:circuit. forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_basis_ket(circ_to_pps(c))[x])[y]) = (((basis_ket_closure[c])[x])[y])))

axiom circ_to_pps_angle :
  (forall c:circuit. forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(circ_to_pps(c))[x])[y]) = ang_ind(c, x, y)))

logic path_sem_basis : circuit, complex matrix -> complex matrix

logic result61 : circuit, complex matrix -> (bitvec,complex matrix) farray

axiom resultqtdef68 :
  (forall c:circuit. forall x:complex matrix. forall y:bitvec. ((result61(c,
  x)[y]) = infix_asdtdt(ang_exp(ang_ind(c, value(ket_to_bv(x)), value(y))),
  bv_to_ket(make_bv((((basis_ket_closure[c])[value(ket_to_bv(x))])[value(y)]),
  width(c))))))

axiom path_sem_basisqtdef :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis(c,
  x) = infix_asdtdt(pow_inv_sqrt_2(range(c)), ket_sum_l(n_bvs(range(c)),
  result61(c, x), width(c)))))))

axiom path_sem_basisqtspec :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> is_a_ket_l(path_sem_basis(c, x), width(c)))))

axiom path_sem_basisqtspec1 :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis(c,
  x) = pps_apply_basis(circ_to_pps(c), ket_to_bv(x))))))

logic path_sem : circuit, complex matrix -> complex matrix

logic result62 : circuit, complex matrix -> (bitvec,complex matrix) farray

axiom resultqtdef69 :
  (forall c:circuit. forall x:complex matrix. forall y:bitvec. ((result62(c,
  x)[y]) = (if (length(y) = width(c)) then infix_asdtdt(get(x, bv_to_int(y),
  0), path_sem_basis(c, bv_to_ket(y))) else x)))

axiom path_semqtdef :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(c, x) = ket_sum_l(n_bvs(width(c)), result62(c, x), width(c)))))

axiom path_semqtspec :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  is_a_ket_l(path_sem(c, x), width(c))))

axiom path_semqtspec1 :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(c, x) = pps_apply(circ_to_pps(c), x))))

axiom mat_sem_to_path :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (mat_mult(mat_sem(c), x) = path_sem(c, x))))

axiom path_sem_to_mat :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(c, x) = mat_mult(mat_sem(c), x))))

predicate sem(c: circuit, x: complex matrix, y: complex matrix) =
  (is_a_ket_l(x, width(c)) and infix_eqeq(y, path_sem(c, x)))

axiom path_sem_to_sem :
  (forall c:circuit. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, width(c)) -> ((path_sem(c, x) = y) -> sem(c, x, y))))

axiom sem_to_path_sem :
  (forall c:circuit. forall x:complex matrix. forall y:complex matrix.
  (sem(c, x, y) -> (path_sem(c, x) = y)))

axiom path_sem_basis_apply :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis(c,
  x) = pps_apply_basis(circ_to_pps(c), ket_to_bv(x))))))

logic fc506 : circuit, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef509 :
  (forall c:circuit. forall x:complex matrix. forall y:bitvec. ((fc506(c,
  x)[y]) = infix_asdtdt(ang_exp(ang_ind(c, value(ket_to_bv(x)), value(y))),
  bv_to_ket(make_bv((((basis_ket_closure[c])[value(ket_to_bv(x))])[value(y)]),
  width(c))))))

axiom path_sem_basis_value :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis(c,
  x) = infix_asdtdt(pow_inv_sqrt_2(range(c)), ket_sum_l(n_bvs(range(c)),
  fc506(c, x), width(c)))))))

logic fc507 : circuit, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef510 :
  (forall c:circuit. forall x:complex matrix. forall y:bitvec. ((fc507(c,
  x)[y]) = infix_asdtdt(ang_exp(ang_ind(c, value(ket_to_bv(x)), value(y))),
  bv_to_ket(make_bv((((basis_ket_closure[c])[value(ket_to_bv(x))])[value(y)]),
  width(c))))))

axiom path_sem_value_for_basis :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem(c,
  x) = infix_asdtdt(pow_inv_sqrt_2(range(c)), ket_sum_l(n_bvs(range(c)),
  fc507(c, x), width(c)))))))

axiom apply_path_sem_basis :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (pps_apply_basis(circ_to_pps(c),
  ket_to_bv(x)) = path_sem_basis(c, x)))))

axiom path_sem_apply :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(c, x) = pps_apply(circ_to_pps(c), x))))

axiom apply_path_sem :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (pps_apply(circ_to_pps(c), x) = path_sem(c, x))))

axiom ancilla_pre_cond_path_sem :
  (forall d:circuit. forall e:circuit_pre. forall i:int.
  ((pre(d) = Ancillas(e, i)) ->
  (exists path_sem_target:(complex matrix,complex matrix) farray.
  (forall x:complex matrix. (is_a_ket_l(x, width(d)) -> (path_sem(to_qc(e),
  kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))))))

axiom ancilla_pre_path_sem :
  (forall d:circuit. forall e:circuit_pre. forall i:int.
  ((pre(d) = Ancillas(e, i)) ->
  (forall x:complex matrix. (is_a_ket_l(x, width(d)) -> (path_sem(to_qc(e),
  kronecker(x, ket(i, 0))) = kronecker(path_sem(d, x), ket(i, 0)))))))

axiom pre_ancilla :
  (forall d:circuit. forall e:circuit. forall i:int.
  ((pre(d) = Ancillas(pre(e), i)) -> (d = ancilla(e, i))))

axiom set_mat_sem_path_sem :
  (forall c:circuit. forall x:complex matrix. ((rows(x) = power(2,
  width(c))) -> ((columns(x) = power(2, width(c))) ->
  ((forall ket1:complex matrix. (is_a_ket_l(ket1, width(c)) ->
   (is_a_ket_basis_elt(ket1) -> (mat_mult(x, ket1) = path_sem(c, ket1))))) ->
  (x = mat_sem(c))))))

axiom path_sem_basis_ket_l :
  (forall c:circuit. forall x:complex matrix. forall l:int. (is_a_ket_l(x,
  width(c)) -> ((l = width(c)) -> (is_a_ket_basis_elt(x) ->
  is_a_ket_l(path_sem_basis(c, x), l)))))

axiom path_sem_ket_l :
  (forall c:circuit. forall x:complex matrix. forall l:int. (is_a_ket_l(x,
  width(c)) -> ((l = width(c)) -> is_a_ket_l(path_sem(c, x), l))))

axiom path_sem_ket :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  is_a_ket(path_sem(c, x))))

axiom path_sem_ket_length :
  (forall c:circuit. forall x:complex matrix. forall l:int. (is_a_ket_l(x,
  width(c)) -> ((l = width(c)) -> (ket_length(path_sem(c, x)) = l))))

axiom path_sem_to_ket_l :
  (forall c:circuit. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, width(c)) -> ((path_sem(c, x) = y) -> is_a_ket_l(y,
  width(c)))))

logic fc508 : circuit, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef511 :
  (forall c:circuit. forall x:complex matrix. forall y:bitvec. ((fc508(c,
  x)[y]) = infix_asdtdt(get(x, bv_to_int(y), 0), path_sem_basis(c,
  bv_to_ket(y)))))

axiom get_path_sem :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(c, x) = ket_sum_l(n_bvs(width(c)), fc508(c, x), width(c)))))

axiom get_path_sem_basis :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem(c, x) = path_sem_basis(c, x)))))

axiom set_path_sem_basis :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis(c, x) = path_sem(c, x)))))

axiom circ_to_pps_parallel :
  (forall d:circuit. forall e:circuit. (circ_to_pps(parallel(d,
  e)) = pps_par(circ_to_pps(d), circ_to_pps(e))))

axiom parallel_width :
  (forall d:circuit. forall e:circuit. (width(parallel(d,
  e)) = (width(d) + width(e))))

axiom parallel_range :
  (forall d:circuit. forall e:circuit. (range(parallel(d,
  e)) = (range(d) + range(e))))

axiom parallel_size :
  (forall d:circuit. forall e:circuit. (size(parallel(d,
  e)) = (size(d) + size(e))))

axiom parallel_ancilla :
  (forall d:circuit. forall e:circuit. (ancillas(parallel(d,
  e)) = (ancillas(d) + ancillas(e))))

logic fc509 : circuit, (int,int) farray -> (int,int) farray

logic fc510 : circuit, (int,int) farray -> (int,int) farray

axiom fcqtdef512 :
  (forall d:circuit. forall x:(int,int) farray. forall k:int. ((fc509(d,
  x)[k]) = (x[(k + width(d))])))

axiom fcqtdef513 :
  (forall d:circuit. forall y:(int,int) farray. forall k:int. ((fc510(d,
  y)[k]) = (y[(k + range(d))])))

axiom parallel_basis_ket :
  (forall d:circuit. forall e:circuit. forall x:(int,int) farray.
  forall y:(int,int) farray. forall i:int. (basis_ket(parallel(d, e), x, y,
  i) = (if (i <  width(d)) then basis_ket(d, x, y, i) else basis_ket(e,
  fc509(d, x), fc510(d, y), (i - width(d))))))

logic fc511 : circuit, (int,int) farray -> (int,int) farray

logic fc512 : circuit, (int,int) farray -> (int,int) farray

axiom fcqtdef514 :
  (forall d:circuit. forall x:(int,int) farray. forall k:int. ((fc511(d,
  x)[k]) = (x[(k + width(d))])))

axiom fcqtdef515 :
  (forall d:circuit. forall y:(int,int) farray. forall k:int. ((fc512(d,
  y)[k]) = (y[(k + range(d))])))

axiom parallel_angle :
  (forall d:circuit. forall e:circuit. forall x:(int,int) farray.
  forall y:(int,int) farray. (ang_ind(parallel(d, e), x,
  y) = ang_add(ang_ind(d, x, y), ang_ind(e, fc511(d, x), fc512(d, y)))))

axiom circ_to_pps_sequence :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (circ_to_pps(sequence(d, e)) = pps_seq(circ_to_pps(d), circ_to_pps(e)))))

axiom sequence_width :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (width(sequence(d, e)) = width(d))))

axiom sequence_size :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (size(sequence(d, e)) = (size(d) + size(e)))))

axiom sequence_ancillas :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (ancillas(sequence(d, e)) = max(ancillas(d), ancillas(e)))))

axiom sequence_range :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (range(sequence(d, e)) = (range(d) + range(e)))))

logic fc513 : circuit, (int,int) farray -> (int,int) farray

axiom fcqtdef516 :
  (forall d:circuit. forall y:(int,int) farray. forall k:int. ((fc513(d,
  y)[k]) = (y[(k + range(d))])))

axiom sequence_basis_ket :
  (forall d:circuit. forall e:circuit. forall x:(int,int) farray.
  forall y:(int,int) farray. forall i:int. ((width(d) = width(e)) ->
  (basis_ket(sequence(d, e), x, y, i) = basis_ket(e,
  (((basis_ket_closure[d])[x])[y]), fc513(d, y), i))))

logic fc514 : circuit, (int,int) farray -> (int,int) farray

axiom fcqtdef517 :
  (forall d:circuit. forall y:(int,int) farray. forall k:int. ((fc514(d,
  y)[k]) = (y[(k + range(d))])))

axiom sequence_angle :
  (forall d:circuit. forall e:circuit. forall x:(int,int) farray.
  forall y:(int,int) farray. ((width(d) = width(e)) -> (ang_ind(sequence(d,
  e), x, y) = ang_add(ang_ind(d, x, y), ang_ind(e,
  (((basis_ket_closure[d])[x])[y]), fc514(d, y))))))

axiom circ_to_pps_ancilla :
  (forall c:circuit. forall i:int. ((1 <= i) -> (((i + 1) <= width(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0)))))) ->
  (circ_to_pps(ancilla(c, i)) = pps_ancs(circ_to_pps(c), i))))))

axiom ancilla_width :
  (forall c:circuit. forall i:int. ((1 <= i) -> (((i + 1) <= width(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0)))))) ->
  (width(ancilla(c, i)) = (width(c) - i))))))

axiom ancilla_size :
  (forall c:circuit. forall i:int. ((1 <= i) -> (((i + 1) <= width(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0)))))) ->
  (size(ancilla(c, i)) = size(c))))))

axiom ancilla_range :
  (forall c:circuit. forall i:int. ((1 <= i) -> (((i + 1) <= width(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0)))))) ->
  (range(ancilla(c, i)) = range(c))))))

axiom ancilla_ancilla :
  (forall c:circuit. forall i:int. ((1 <= i) -> (((i + 1) <= width(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0)))))) ->
  (ancillas(ancilla(c, i)) = (ancillas(c) + i))))))

logic fc515 : circuit, (int,int) farray, int -> (int,int) farray

axiom fcqtdef518 :
  (forall c:circuit. forall x:(int,int) farray. forall i:int. forall k:int.
  ((fc515(c, x, i)[k]) = (if (k <  (width(c) - i)) then (x[k]) else 0)))

axiom ancilla_basis_ket :
  (forall c:circuit. forall x:(int,int) farray. forall y:(int,int) farray.
  forall l:int. forall i:int. ((1 <= i) -> (((i + 1) <= width(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x1:complex matrix. (is_a_ket_l(x1, (width(c) - i)) -> (path_sem(c,
   kronecker(x1, ket(i, 0))) = kronecker((path_sem_target[x1]), ket(i, 0)))))) ->
  (basis_ket(ancilla(c, i), x, y, l) = basis_ket(c, fc515(c, x, i), y,
  l))))))

logic fc516 : circuit, (int,int) farray, int -> (int,int) farray

axiom fcqtdef519 :
  (forall c:circuit. forall x:(int,int) farray. forall i:int. forall k:int.
  ((fc516(c, x, i)[k]) = (if (k <  (width(c) - i)) then (x[k]) else 0)))

axiom ancilla_angle :
  (forall c:circuit. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((1 <= i) -> (((i + 1) <= width(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x1:complex matrix. (is_a_ket_l(x1, (width(c) - i)) -> (path_sem(c,
   kronecker(x1, ket(i, 0))) = kronecker((path_sem_target[x1]), ket(i, 0)))))) ->
  (ang_ind(ancilla(c, i), x, y) = ang_ind(c, fc516(c, x, i), y))))))

axiom sequence_eq :
  (forall d:circuit. forall dqt:circuit. forall e:circuit.
  forall eqt:circuit. ((width(d) = width(e)) -> ((d = dqt) -> ((e = eqt) ->
  (sequence(d, e) = sequence(dqt, eqt))))))

logic ancilla_closure : (circuit,(int,circuit) farray) farray

axiom ancilla_closure_def :
  (forall y:circuit. forall y1:int. (((ancilla_closure[y])[y1]) = ancilla(y,
  y1)))

axiom ancilla_eq :
  (forall c:circuit. forall cqt:circuit.
  forall path_sem_target:(complex matrix,complex matrix) farray.
  ((forall x:complex matrix. (is_a_ket_l(x, width(c)) -> (path_sem(c,
   kronecker(x, ket(1, 0))) = kronecker((path_sem_target[x]), ket(1, 0))))) ->
  ((width(c) = width(cqt)) -> ((c = cqt) ->
  ((ancilla_closure[c]) = (ancilla_closure[cqt]))))))

axiom parallel_eq :
  (forall d:circuit. forall dqt:circuit. forall e:circuit.
  forall eqt:circuit. ((d = dqt) -> ((e = eqt) -> (parallel(d,
  e) = parallel(dqt, eqt)))))

logic fc517 : circuit, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef520 :
  (forall c:circuit. forall x:complex matrix. forall z:bitvec. ((fc517(c,
  x)[z]) = infix_asdtdt(get(x, bv_to_int(z), 0), path_sem(c, bv_to_ket(z)))))

axiom path_sem_decomp :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(c, x) = ket_sum_l(n_bvs(width(c)), fc517(c, x), width(c)))))

axiom path_sem_scal_ :
  (forall c:circuit. forall x:complex matrix. forall y:complex matrix.
  forall sc:complex. (is_a_ket_l(x, width(c)) -> ((path_sem(c, x) = y) ->
  (path_sem(c, infix_asdtdt(sc, x)) = infix_asdtdt(sc, y)))))

axiom path_sem_scal :
  (forall c:circuit. forall x:complex matrix. forall sc:complex.
  (is_a_ket_l(x, width(c)) -> (path_sem(c, infix_asdtdt(sc,
  x)) = infix_asdtdt(sc, path_sem(c, x)))))

axiom path_sem_scal_rev :
  (forall c:circuit. forall x:complex matrix. forall sc:complex.
  (is_a_ket_l(x, width(c)) -> (infix_asdtdt(sc, path_sem(c, x)) = path_sem(c,
  infix_asdtdt(sc, x)))))

axiom path_sem_add :
  (forall c:circuit. forall x:complex matrix. forall xqt:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix. (is_a_ket_l(x,
  width(c)) -> (is_a_ket_l(xqt, width(c)) -> ((path_sem(c, x) = y) ->
  ((path_sem(c, xqt) = yqt) -> (path_sem(c, add_ket_l(x, xqt,
  width(c))) = add_ket_l(y, yqt, width(c))))))))

axiom path_sem_add_ :
  (forall c:circuit. forall x:complex matrix. forall xqt:complex matrix.
  forall l:int. (is_a_ket_l(x, width(c)) -> (is_a_ket_l(xqt, width(c)) ->
  ((l = width(c)) -> (path_sem(c, add_ket_l(x, xqt,
  l)) = add_ket_l(path_sem(c, x), path_sem(c, xqt), l))))))

axiom path_sem_scal_add_ket_l :
  (forall c:circuit. forall x:complex matrix. forall xqt:complex matrix.
  forall a:complex. forall aqt:complex. forall n:int. ((width(c) = n) ->
  (is_a_ket_l(x, n) -> (is_a_ket_l(xqt, n) -> (path_sem(c,
  add_ket_l(infix_asdtdt(a, x), infix_asdtdt(aqt, xqt),
  n)) = add_ket_l(infix_asdtdt(a, path_sem(c, x)), infix_asdtdt(aqt,
  path_sem(c, xqt)), n))))))

axiom path_sem_substr :
  (forall c:circuit. forall x:complex matrix. forall xqt:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix. (is_a_ket_l(x,
  width(c)) -> (is_a_ket_l(xqt, width(c)) -> ((path_sem(c, x) = y) ->
  ((path_sem(c, xqt) = yqt) -> (path_sem(c, mat_substr(x,
  xqt)) = mat_substr(y, yqt)))))))

axiom path_sem_scal_add :
  (forall c:circuit. forall x:complex matrix. forall xqt:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix. forall scal:complex.
  (is_a_ket_l(x, width(c)) -> (is_a_ket_l(xqt, width(c)) -> ((path_sem(c,
  x) = y) -> ((path_sem(c, xqt) = yqt) -> (path_sem(c, infix_asdtdt(scal,
  add_ket_l(x, xqt, width(c)))) = infix_asdtdt(scal, add_ket_l(y, yqt,
  width(c)))))))))

logic fc518 : circuit, bitvec, int -> (bitvec,complex) farray

axiom fcqtdef521 :
  (forall c:circuit. forall x:bitvec. forall i:int. forall y:bitvec.
  ((fc518(c, x, i)[y]) = infix_asdt(ang_exp(ang_ind(c, value(x), value(y))),
  indic(make_bv((((basis_ket_closure[c])[value(x)])[value(y)]), width(c)),
  int_to_bv(i, width(c))))))

axiom pat_sem_apply_basis_value :
  (forall c:circuit. forall x:bitvec. ((length(x) = width(c)) ->
  (forall i:int. (((0 <= i) and (i <  power(2, width(c)))) ->
  (get(path_sem(c, bv_to_ket(x)), i,
  0) = infix_asdt(pow_inv_sqrt_2(range(c)), sum(n_bvs(range(c)), fc518(c, x,
  i))))))))

axiom path_sem_scal_substr :
  (forall c:circuit. forall x:complex matrix. forall xqt:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix. forall scal:complex.
  (is_a_ket_l(x, width(c)) -> (is_a_ket_l(xqt, width(c)) -> ((path_sem(c,
  x) = y) -> ((path_sem(c, xqt) = yqt) -> (path_sem(c, infix_asdtdt(scal,
  mat_substr(x, xqt))) = infix_asdtdt(scal, mat_substr(y, yqt))))))))

axiom path_sem_sum :
  (forall c:circuit. forall s:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall n:int. ((1 <= cardinal(s)) ->
  ((n = width(c)) ->
  ((forall x:'a. (mem(x, s) -> is_a_ket_l((f[x]), width(c)))) ->
  ((forall x:'a. (mem(x, s) -> (path_sem(c, (f[x])) = (g[x])))) ->
  (path_sem(c, ket_sum_l(s, f, n)) = ket_sum_l(s, g, n)))))))

logic fc519 : circuit,
  (bitvec,complex) farray -> (bitvec,complex matrix) farray

axiom fcqtdef522 :
  (forall c:circuit. forall f:(bitvec,complex) farray. forall x:bitvec.
  ((fc519(c, f)[x]) = infix_asdtdt((f[x]), path_sem(c, bv_to_ket(x)))))

axiom path_sem_sum_diag :
  (forall c:circuit. forall s:bitvec set. forall f:(bitvec,complex) farray.
  forall l:int. ((s = n_bvs(l)) -> ((l = width(c)) -> (path_sem(c,
  ket_sum_l_diag(f, l)) = ket_sum_l(s, fc519(c, f), l)))))

logic fc520 : circuit,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef523 :
  (forall c:circuit. forall f:('a,complex matrix) farray. forall x:'a.
  ((fc520(c, f)[x]) = path_sem(c, (f[x]))))

axiom path_sem_sum_ :
  (forall c:circuit. forall s:'a set. forall f:('a,complex matrix) farray.
  forall n:int. ((1 <= cardinal(s)) -> ((n = width(c)) ->
  ((forall x:'a. (mem(x, s) -> is_a_ket_l((f[x]), width(c)))) -> (path_sem(c,
  ket_sum_l(s, f, n)) = ket_sum_l(s, fc520(c, f), n))))))

axiom path_sem_sum_gen :
  (forall c:circuit. forall s:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall n:int. ((1 <= cardinal(s)) ->
  ((n = width(c)) ->
  ((forall x:'a. (mem(x, s) -> is_a_ket_l((f[x]), width(c)))) ->
  ((forall x:'a. (mem(x, s) -> (path_sem(c, (f[x])) = (g[x])))) ->
  (path_sem(c, ket_sum_l(s, f, n)) = ket_sum_l(s, g, n)))))))

axiom scal_path_sem_sum_gen :
  (forall c:circuit. forall s:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall n:int. forall nqt:int.
  forall a1:complex. forall b:complex. ((1 <= cardinal(s)) ->
  ((n = width(c)) ->
  ((forall x:'a. (mem(x, s) -> is_a_ket_l((f[x]), width(c)))) ->
  ((forall x:'a. (mem(x, s) -> (path_sem(c, (f[x])) = (g[x])))) ->
  ((a1 = b) -> ((n = nqt) -> (infix_asdtdt(a1, path_sem(c, ket_sum_l(s, f,
  n))) = infix_asdtdt(b, ket_sum_l(s, g, nqt))))))))))

logic fc521 : circuit,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef524 :
  (forall c:circuit. forall f:('a,complex matrix) farray. forall x:'a.
  ((fc521(c, f)[x]) = path_sem(c, (f[x]))))

axiom scal_path_sem_sum :
  (forall c:circuit. forall s:'a set. forall f:('a,complex matrix) farray.
  forall n:int. forall a1:complex. ((1 <= cardinal(s)) -> ((n = width(c)) ->
  ((forall x:'a. (mem(x, s) -> is_a_ket_l((f[x]), width(c)))) ->
  (infix_asdtdt(a1, path_sem(c, ket_sum_l(s, f, n))) = infix_asdtdt(a1,
  ket_sum_l(s, fc521(c, f), n)))))))

logic fc522 : circuit,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef525 :
  (forall c:circuit. forall f:('a,complex matrix) farray. forall x:'a.
  ((fc522(c, f)[x]) = path_sem(c, (f[x]))))

axiom path_sem_scal_sum :
  (forall c:circuit. forall s:'a set. forall f:('a,complex matrix) farray.
  forall n:int. forall a1:complex. ((1 <= cardinal(s)) -> ((n = width(c)) ->
  ((forall x:'a. (mem(x, s) -> is_a_ket_l((f[x]), width(c)))) -> (path_sem(c,
  infix_asdtdt(a1, ket_sum_l(s, f, n))) = infix_asdtdt(a1, ket_sum_l(s,
  fc522(c, f), n)))))))

axiom path_sem_comp_basis :
  (forall d:circuit. forall e:circuit. forall x:complex matrix.
  (is_a_ket_l(x, width(d)) -> (is_a_ket_basis_elt(x) ->
  ((width(d) = width(e)) -> (path_sem_basis(sequence(d, e), x) = path_sem(e,
  path_sem_basis(d, x)))))))

axiom path_sem_comp_pre :
  (forall d:circuit. forall e:circuit. forall x:complex matrix.
  (is_a_ket_l(x, width(d)) -> ((width(d) = width(e)) -> (path_sem(sequence(d,
  e), x) = path_sem(e, path_sem(d, x))))))

axiom path_sem_comp :
  (forall d:circuit. forall e:circuit. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. (is_a_ket_l(x,
  width(d)) -> ((path_sem(d, x) = y) -> ((path_sem(e, y) = z) ->
  ((width(d) = width(e)) -> (path_sem(sequence(d, e), x) = z))))))

axiom path_sem_comp_ :
  (forall d:circuit. forall e:circuit. forall x:complex matrix.
  (is_a_ket_l(x, width(d)) -> ((width(d) = width(e)) -> (path_sem(sequence(d,
  e), x) = path_sem(e, path_sem(d, x))))))

axiom sem_comp :
  (forall d:circuit. forall e:circuit. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. (sem(d, x, y) -> (sem(e,
  y, z) -> ((width(d) = width(e)) -> sem(sequence(d, e), x, z)))))

axiom path_sem_kron_basis :
  (forall d:circuit. forall e:circuit. forall x:complex matrix.
  forall y:complex matrix. (is_a_ket_l(x, width(d)) -> (is_a_ket_l(y,
  width(e)) -> (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (path_sem_basis(parallel(d, e), kronecker(x,
  y)) = kronecker(path_sem_basis(d, x), path_sem_basis(e, y))))))))

axiom path_sem_kron_pre :
  (forall d:circuit. forall e:circuit. forall x:complex matrix.
  forall y:complex matrix. (is_a_ket_l(x, width(d)) -> (is_a_ket_l(y,
  width(e)) -> (path_sem(parallel(d, e), kronecker(x,
  y)) = kronecker(path_sem(d, x), path_sem(e, y))))))

axiom path_sem_kron :
  (forall d:circuit. forall e:circuit. forall x:complex matrix.
  forall xqt:complex matrix. forall y:complex matrix.
  forall yqt:complex matrix. (is_a_ket_l(x, width(d)) -> (is_a_ket_l(y,
  width(e)) -> ((path_sem(d, x) = xqt) -> ((path_sem(e, y) = yqt) ->
  (path_sem(parallel(d, e), kronecker(x, y)) = kronecker(xqt, yqt)))))))

axiom path_sem_kron_ :
  (forall d:circuit. forall e:circuit. forall x:complex matrix.
  forall y:complex matrix. (is_a_ket_l(x, width(d)) -> (is_a_ket_l(y,
  width(e)) -> (path_sem(parallel(d, e), kronecker(x,
  y)) = kronecker(path_sem(d, x), path_sem(e, y))))))

axiom path_sem_sequence_parallel_basis :
  (forall a:circuit. forall b:circuit. forall d:circuit. forall e:circuit.
  forall x:complex matrix. (is_a_ket_l(x, (width(a) + width(b))) ->
  ((width(a) = width(d)) -> ((width(b) = width(e)) ->
  (is_a_ket_basis_elt(x) -> (path_sem(sequence(parallel(a, b), parallel(d,
  e)), x) = path_sem(parallel(sequence(a, d), sequence(b, e)), x)))))))

axiom path_sem_sequence_parallel :
  (forall a:circuit. forall b:circuit. forall d:circuit. forall e:circuit.
  forall x:complex matrix. (is_a_ket_l(x, (width(a) + width(b))) ->
  ((width(a) = width(d)) -> ((width(b) = width(e)) ->
  (path_sem(sequence(parallel(a, b), parallel(d, e)),
  x) = path_sem(parallel(sequence(a, d), sequence(b, e)), x))))))

axiom path_sem_id_basis :
  (forall x:complex matrix. (is_a_ket_l(x, 1) -> (is_a_ket_basis_elt(x) ->
  (path_sem_basis(id, x) = x))))

axiom path_sem_id :
  (forall x:complex matrix. (is_a_ket_l(x, 1) -> (path_sem(id, x) = x)))

axiom path_sem_phase_basis :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (is_a_ket_basis_elt(x) -> (path_sem(phase(k),
  x) = infix_asdtdt(ang_exp(infix_sldtsl(1, k)), x)))))

axiom path_sem_phase_basis_inv :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (is_a_ket_basis_elt(x) -> (path_sem(phase(k), path_sem(phase((-k)),
  x)) = x))))

axiom path_sem_phase_inv :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem(phase(k), path_sem(phase((-k)), x)) = x)))

axiom path_sem_rz_basis :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (is_a_ket_basis_elt(x) -> (path_sem(rz(k),
  x) = infix_asdtdt(ang_exp(infix_sldtsl((value(ket_to_bv(x))[0]), k)),
  x)))))

axiom path_sem_rz_basis_inv :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (is_a_ket_basis_elt(x) -> (path_sem(rz(k), path_sem(rz((-k)), x)) = x))))

axiom path_sem_rz_inv :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem(rz(k), path_sem(rz((-k)), x)) = x)))

axiom qbit_zeroqtspec : (get(ket(1, 0), 0, 0) = c_one)

axiom qbit_zeroqtspec1 : (get(ket(1, 0), 1, 0) = c_zero)

axiom qbit_zeroqtspec2 : is_a_ket_l(ket(1, 0), 1)

axiom qbit_zeroqtspec3 : (rows(ket(1, 0)) = 2)

axiom qbit_zeroqtspec4 : (columns(ket(1, 0)) = 1)

axiom qbit_zeroqtspec5 : (get(ket(1, 0), 0, 0) = c_one)

axiom qbit_zeroqtspec6 : (get(ket(1, 0), 1, 0) = c_zero)

axiom qbit_zeroqtspec7 : is_a_ket_basis_elt(ket(1, 0))

axiom qbit_oneqtspec : (get(ket(1, 1), 0, 0) = c_zero)

axiom qbit_oneqtspec1 : (get(ket(1, 1), 1, 0) = c_one)

axiom qbit_oneqtspec2 : is_a_ket_l(ket(1, 1), 1)

axiom qbit_oneqtspec3 : (rows(ket(1, 1)) = 2)

axiom qbit_oneqtspec4 : (columns(ket(1, 1)) = 1)

axiom qbit_oneqtspec5 : (get(ket(1, 1), 0, 0) = c_zero)

axiom qbit_oneqtspec6 : (get(ket(1, 1), 1, 0) = c_one)

axiom qbit_oneqtspec7 : is_a_ket_basis_elt(ket(1, 1))

axiom get_ket_one :
  (forall x:complex matrix. (is_a_ket_l(x, 1) -> (is_a_ket_basis_elt(x) ->
  ((not (x = ket(1, 0))) -> (x = ket(1, 1))))))

axiom get_ket_zero :
  (forall x:complex matrix. (is_a_ket_l(x, 1) -> (is_a_ket_basis_elt(x) ->
  ((not (x = ket(1, 1))) -> (x = ket(1, 0))))))

axiom get_ket_one_decomp_z :
  (forall a:complex. forall b:complex. (get(add_ket_l(infix_asdtdt(a, ket(1,
  0)), infix_asdtdt(b, ket(1, 1)), 1), 0, 0) = a))

axiom get_ket_one_decomp_o :
  (forall a:complex. forall b:complex. (get(add_ket_l(infix_asdtdt(a, ket(1,
  0)), infix_asdtdt(b, ket(1, 1)), 1), 1, 0) = b))

axiom zero_to_bv :
  (forall f:(int,int) farray. forall l:int. (((f[0]) = 0) -> ((l = 1) ->
  (ket(1, 0) = bv_to_ket(make_bv(f, l))))))

axiom one_to_bv :
  (forall f:(int,int) farray. forall l:int. (((f[0]) = 1) -> ((l = 1) ->
  (ket(1, 1) = bv_to_ket(make_bv(f, l))))))

axiom bv_to_zero :
  (forall f:(int,int) farray. forall l:int. (((f[0]) = 0) -> ((l = 1) ->
  (bv_to_ket(make_bv(f, l)) = ket(1, 0)))))

axiom bv_to_one :
  (forall f:(int,int) farray. forall l:int. (((f[0]) = 1) -> ((l = 1) ->
  (bv_to_ket(make_bv(f, l)) = ket(1, 1)))))

axiom qbit_plusqtspec : (pps_apply(pps_hadamard, ket(1,
  0)) = infix_asdtdt(pow_inv_sqrt_2(1), add_ket_l(ket(1, 0), ket(1, 1), 1)))

axiom qbit_plusqtspec1 : is_a_ket_l(pps_apply(pps_hadamard, ket(1, 0)), 1)

axiom qbit_plusqtspec2 : (rows(pps_apply(pps_hadamard, ket(1, 0))) = 2)

axiom qbit_plusqtspec3 : (columns(pps_apply(pps_hadamard, ket(1, 0))) = 1)

axiom qbit_plusqtspec4 : (get(pps_apply(pps_hadamard, ket(1, 0)), 0,
  0) = pow_inv_sqrt_2(1))

axiom qbit_plusqtspec5 : (get(pps_apply(pps_hadamard, ket(1, 0)), 1,
  0) = pow_inv_sqrt_2(1))

axiom qbit_minusqtspec : (pps_apply(pps_hadamard, ket(1,
  1)) = infix_asdtdt(pow_inv_sqrt_2(1), add_ket_l(ket(1, 0),
  infix_asdtdt(prefix_mndt(c_one), ket(1, 1)), 1)))

axiom qbit_minusqtspec1 : is_a_ket_l(pps_apply(pps_hadamard, ket(1, 1)), 1)

axiom qbit_minusqtspec2 : (rows(pps_apply(pps_hadamard, ket(1, 1))) = 2)

axiom qbit_minusqtspec3 : (columns(pps_apply(pps_hadamard, ket(1, 1))) = 1)

axiom qbit_minusqtspec4 : (get(pps_apply(pps_hadamard, ket(1, 1)), 0,
  0) = pow_inv_sqrt_2(1))

axiom qbit_minusqtspec5 : (get(pps_apply(pps_hadamard, ket(1, 1)), 1,
  0) = prefix_mndt(pow_inv_sqrt_2(1)))

axiom add_plus_minus : (add_ket_l(pps_apply(pps_hadamard, ket(1, 0)),
  pps_apply(pps_hadamard, ket(1, 1)),
  1) = infix_asdtdt(square_rt(infix_pldt(c_one, c_one)), ket(1, 0)))

axiom add_plus_minus1 : (add_ket_l(infix_asdtdt(pow_inv_sqrt_2(1),
  pps_apply(pps_hadamard, ket(1, 0))), infix_asdtdt(pow_inv_sqrt_2(1),
  pps_apply(pps_hadamard, ket(1, 1))), 1) = ket(1, 0))

axiom substr_plus_minus : (add_ket_l(pps_apply(pps_hadamard, ket(1, 0)),
  infix_asdtdt(prefix_mndt(c_one), pps_apply(pps_hadamard, ket(1, 1))),
  1) = infix_asdtdt(square_rt(infix_pldt(c_one, c_one)), ket(1, 1)))

axiom substr_plus_minus1 : (add_ket_l(infix_asdtdt(pow_inv_sqrt_2(1),
  pps_apply(pps_hadamard, ket(1, 0))),
  infix_asdtdt(prefix_mndt(pow_inv_sqrt_2(1)), pps_apply(pps_hadamard, ket(1,
  1))), 1) = ket(1, 1))

axiom plus_to_zero : (pps_apply(pps_hadamard, pps_apply(pps_hadamard, ket(1,
  0))) = ket(1, 0))

axiom plus_to_one : (pps_apply(pps_hadamard, pps_apply(pps_hadamard, ket(1,
  1))) = ket(1, 1))

axiom hadamard_comp :
  (forall x:bitvec. ((length(x) = 1) -> (pps_apply(pps_hadamard,
  pps_apply(pps_hadamard, bv_to_ket(x))) = bv_to_ket(x))))

axiom set_equal_qbit :
  (forall a:complex matrix. forall b:complex matrix. (is_a_ket_l(a, 1) ->
  (is_a_ket_l(b, 1) -> ((get(a, 0, 0) = get(b, 0, 0)) -> ((get(a, 1,
  0) = get(b, 1, 0)) -> (a = b))))))

logic xor_qbits : complex matrix, complex matrix -> complex matrix

logic result63 : complex matrix, complex matrix -> (int,complex) farray

axiom resultqtdef70 :
  (forall x:complex matrix. forall y:complex matrix. forall i:int.
  ((result63(x, y)[i]) = (if (i = 0) then infix_pldt(infix_asdt(get(x, 0, 0),
  get(y, 0, 0)), infix_asdt(get(x, 1, 0), get(y, 1,
  0))) else infix_pldt(infix_asdt(get(x, 0, 0), get(y, 1, 0)),
  infix_asdt(get(x, 1, 0), get(y, 0, 0))))))

axiom xor_qbitsqtdef :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (xor_qbits(x, y) = make_ket(1, result63(x, y))))))

axiom xor_qbitsqtspec :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> is_a_ket_l(xor_qbits(x, y), 1))))

axiom xor_qbitsqtspec1 :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (xor_qbits(x, y) = ket(1, xor_i(ket_to_int(x), ket_to_int(y)))))))))

axiom xor_qbitsqtspec2 :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (get(xor_qbits(x, y), 0,
  0) = infix_pldt(infix_asdt(get(x, 0, 0), get(y, 0, 0)), infix_asdt(get(x,
  1, 0), get(y, 1, 0)))))))

axiom xor_qbitsqtspec3 :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (get(xor_qbits(x, y), 1,
  0) = infix_pldt(infix_asdt(get(x, 0, 0), get(y, 1, 0)), infix_asdt(get(x,
  1, 0), get(y, 0, 0)))))))

axiom xor_int_to_ket :
  (forall x:complex matrix. forall i:int. (is_a_ket_l(x, 1) ->
  is_a_ket_l(xor_qbits(ket(1, i), x), 1)))

axiom xor_qbit_minus :
  (forall i:int. (((0 <= i) and (i <  2)) -> (xor_qbits(ket(1, i),
  pps_apply(pps_hadamard, ket(1,
  1))) = infix_asdtdt(cpower(prefix_mndt(c_one), i), pps_apply(pps_hadamard,
  ket(1, 1))))))

logic fc523 : ('a,int) farray -> ('a,complex matrix) farray

logic fc524 : ('a,int) farray -> ('a,complex matrix) farray

axiom fcqtdef526 :
  (forall f:('a,int) farray. forall e:'a. ((fc523(f)[e]) = xor_qbits(ket(1,
  (f[e])), pps_apply(pps_hadamard, ket(1, 1)))))

axiom fcqtdef527 :
  (forall f:('a,int) farray. forall e:'a.
  ((fc524(f)[e]) = infix_asdtdt(cpower(prefix_mndt(c_one), (f[e])),
  pps_apply(pps_hadamard, ket(1, 1)))))

axiom ket_sum_xor_qbit_minus :
  (forall s:'a set. forall f:('a,int) farray.
  ((forall e:'a. (mem(e, s) -> ((0 <= (f[e])) and ((f[e]) <  2)))) ->
  (ket_sum_l(s, fc523(f), 1) = ket_sum_l(s, fc524(f), 1))))

logic fc525 : (bitvec,int) farray -> (bitvec,complex matrix) farray

logic fc526 : (bitvec,int) farray -> (bitvec,complex matrix) farray

axiom fcqtdef528 :
  (forall f:(bitvec,int) farray. forall x:bitvec.
  ((fc525(f)[x]) = infix_asdtdt(cpower(prefix_mndt(c_one), (f[x])),
  bv_to_ket(x))))

axiom fcqtdef529 :
  (forall f:(bitvec,int) farray. forall e:bitvec.
  ((fc526(f)[e]) = kronecker(bv_to_ket(e), xor_qbits(ket(1, (f[e])),
  pps_apply(pps_hadamard, ket(1, 1))))))

axiom superposition_xor_qbit_minus :
  (forall f:(bitvec,int) farray. forall n:int.
  ((forall e:bitvec. ((length(e) = n) -> ((0 <= (f[e])) and ((f[e]) <  2)))) ->
  ((0 <= n) -> (kronecker(infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n),
  fc525(f), n)), pps_apply(pps_hadamard, ket(1,
  1))) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc526(f),
  (n + 1)))))))

logic fc527 : int, bitvec -> (int,angle) farray

axiom fcqtdef530 :
  (forall n:int. forall y:bitvec. forall i:int. ((fc527(n,
  y)[i]) = infix_sldtsl(((value(ket_to_bv(ket(n, 0)))[i]) * (value(y)[i])),
  1)))

axiom sum_ket_zero :
  (forall n:int. ((0 <= n) ->
  (forall y:bitvec. (ang_sum(fc527(n, y), 0, n) = ang_zero))))

logic repeat_pps_had : int -> pps

axiom repeat_pps_hadqtdef :
  (forall n:int. ((1 <= n) -> ((n = 1) ->
  (repeat_pps_had(n) = pps_hadamard))))

axiom repeat_pps_hadqtdef1 :
  (forall n:int. ((1 <= n) -> ((not (n = 1)) ->
  (repeat_pps_had(n) = pps_par(repeat_pps_had((n - 1)), pps_hadamard)))))

logic fc528 : (int,int) farray, (int,int) farray -> (int,angle) farray

axiom fcqtdef531 :
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  ((fc528(x, y)[i]) = infix_sldtsl(((x[i]) * (y[i])), 1)))

axiom repeat_pps_hadqtspec :
  (forall n:int. ((1 <= n) -> (h_width(repeat_pps_had(n)) = n)))

axiom repeat_pps_hadqtspec1 :
  (forall n:int. ((1 <= n) -> (h_range(repeat_pps_had(n)) = n)))

axiom repeat_pps_hadqtspec2 :
  (forall n:int. ((1 <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) ->
  ((((h_basis_ket(repeat_pps_had(n))[x])[y])[i]) = (y[i])))))))

axiom repeat_pps_hadqtspec3 :
  (forall n:int. ((1 <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(repeat_pps_had(n))[x])[y]) = ang_sum(fc528(x, y), 0, n)))))

logic kron_had_coeffs : int, int, int -> complex

logic result64 : int, int, int -> (int,int) farray

axiom resultqtdef71 :
  (forall n:int. forall i:int. forall j:int. forall k:int. ((result64(n, i,
  j)[k]) = ((value(int_to_bv(i, n))[k]) * (value(int_to_bv(j, n))[k]))))

axiom kron_had_coeffsqtdef :
  (forall n:int. forall i:int. forall j:int. ((0 <= n) -> (kron_had_coeffs(n,
  i, j) = infix_asdt(pow_inv_sqrt_2(n), cpower(prefix_mndt(c_one),
  ind_isum(result64(n, i, j), 0, n))))))

logic superposition_state : int -> complex matrix

axiom superposition_stateqtdef :
  (forall n:int. ((1 <= n) ->
  (superposition_state(n) = pps_apply(repeat_pps_had(n), ket(n, 0)))))

logic bv_to_ket_closure : (bitvec,complex matrix) farray

logic ket_closure : (int,(int,complex matrix) farray) farray

axiom bv_to_ket_closure_def :
  (forall y:bitvec. ((bv_to_ket_closure[y]) = bv_to_ket(y)))

axiom ket_closure_def :
  (forall y:int. forall y1:int. (((ket_closure[y])[y1]) = ket(y, y1)))

axiom superposition_stateqtspec :
  (forall n:int. ((1 <= n) ->
  (superposition_state(n) = infix_asdtdt(pow_inv_sqrt_2(n),
  ket_sum_l(n_bvs(n), bv_to_ket_closure, n)))))

axiom superposition_stateqtspec1 :
  (forall n:int. ((1 <= n) ->
  (superposition_state(n) = infix_asdtdt(pow_inv_sqrt_2(n),
  ket_sum_l(to_fset(0, power(2, n)), (ket_closure[n]), n)))))

axiom superposition_stateqtspec2 :
  (forall n:int. ((1 <= n) -> is_a_ket_l(superposition_state(n), n)))

axiom get_ket_superposition :
  (forall n:int. forall i:int. ((1 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (get(superposition_state(n), i, 0) = infix_sldt(c_one,
  square_rt(i_to_c(power(2, n))))))))

axiom repeat_had_twice_bv :
  (forall n:int. forall x:bitvec. ((1 <= n) -> ((length(x) = n) ->
  (pps_apply(repeat_pps_had(n), pps_apply(repeat_pps_had(n),
  bv_to_ket(x))) = bv_to_ket(x)))))

axiom repeat_had_twice_bv_gen :
  (forall n:int. ((1 <= n) ->
  (forall x:bitvec. ((length(x) = n) -> (pps_apply(repeat_pps_had(n),
  pps_apply(repeat_pps_had(n), bv_to_ket(x))) = bv_to_ket(x))))))

axiom repeat_had_twice_ket :
  (forall n:int. ((1 <= n) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) ->
  (pps_apply(repeat_pps_had(n), pps_apply(repeat_pps_had(n), x)) = x)))))

logic fc529 : bitvec, bitvec -> (int,int) farray

logic fc530 : int, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef532 :
  (forall x:bitvec. forall y:bitvec. forall k:int. ((fc529(x,
  y)[k]) = ((value(x)[k]) * (value(y)[k]))))

axiom fcqtdef533 :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((fc530(n,
  x)[y]) = infix_asdtdt(cpower(prefix_mndt(c_one), ind_isum(fc529(x, y), 0,
  n)), bv_to_ket(y))))

axiom repeat_pps_had_basis_bv :
  (forall n:int. forall x:bitvec. ((1 <= n) -> ((length(x) = n) ->
  (pps_apply(repeat_pps_had(n),
  bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n),
  fc530(n, x), n))))))

logic fc531 : int, int, bitvec -> (int,int) farray

logic fc532 : int, int -> (bitvec,complex matrix) farray

axiom fcqtdef534 :
  (forall n:int. forall i:int. forall y:bitvec. forall k:int. ((fc531(n, i,
  y)[k]) = ((value(int_to_bv(i, n))[k]) * (value(y)[k]))))

axiom fcqtdef535 :
  (forall n:int. forall i:int. forall y:bitvec. ((fc532(n,
  i)[y]) = infix_asdtdt(cpower(prefix_mndt(c_one), ind_isum(fc531(n, i, y),
  0, n)), bv_to_ket(y))))

axiom repeat_pps_had_basis :
  (forall n:int. forall i:int. ((1 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (pps_apply(repeat_pps_had(n), ket(n,
  i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc532(n, i),
  n))))))

axiom repeat_had_superposition :
  (forall n:int. ((1 <= n) -> (pps_apply(repeat_pps_had(n),
  superposition_state(n)) = ket(n, 0))))

axiom path_sem_repeat_at_zero_bv :
  (forall n:int. forall x:bitvec. ((1 <= n) -> ((length(x) = n) ->
  (get(pps_apply(repeat_pps_had(n), bv_to_ket(x)), 0,
  0) = pow_inv_sqrt_2(n)))))

logic fc533 : (complex matrix,(int,complex) farray) farray

axiom fcqtdef536 :
  (forall y0:complex matrix. forall y1:int. (((fc533[y0])[y1]) = get(y0, y1,
  0)))

axiom path_sem_repeat_at_zero :
  (forall n:int. forall x:complex matrix. ((1 <= n) -> (is_a_ket_l(x, n) ->
  (get(pps_apply(repeat_pps_had(n), x), 0, 0) = infix_asdt(pow_inv_sqrt_2(n),
  ind_sum((fc533[x]), 0, power(2, n)))))))

logic fc534 : (bitvec,(bitvec,int) farray) farray,
  bitvec -> (bitvec,complex matrix) farray

logic fc535 : (bitvec,int) farray, (bitvec,(bitvec,int) farray) farray,
  int -> (bitvec,complex matrix) farray

logic fc536 : (bitvec,int) farray, (bitvec,(bitvec,int) farray) farray,
  bitvec -> (bitvec,complex) farray

logic fc537 : (bitvec,int) farray, (bitvec,(bitvec,int) farray) farray,
  int -> (bitvec,complex matrix) farray

axiom fcqtdef537 :
  (forall g:(bitvec,(bitvec,int) farray) farray. forall x:bitvec.
  forall y:bitvec. ((fc534(g,
  x)[y]) = infix_asdtdt(cpower(prefix_mndt(c_one), ((g[x])[y])),
  bv_to_ket(y))))

axiom fcqtdef538 :
  (forall f:(bitvec,int) farray.
  forall g:(bitvec,(bitvec,int) farray) farray. forall n:int.
  forall x:bitvec. ((fc535(f, g,
  n)[x]) = infix_asdtdt(cpower(prefix_mndt(c_one), (f[x])),
  ket_sum_l(n_bvs(n), fc534(g, x), n))))

axiom fcqtdef539 :
  (forall f:(bitvec,int) farray.
  forall g:(bitvec,(bitvec,int) farray) farray. forall y:bitvec.
  forall x:bitvec. ((fc536(f, g, y)[x]) = cpower(prefix_mndt(c_one),
  (((g[x])[y]) + (f[x])))))

axiom fcqtdef540 :
  (forall f:(bitvec,int) farray.
  forall g:(bitvec,(bitvec,int) farray) farray. forall n:int.
  forall y:bitvec. ((fc537(f, g, n)[y]) = infix_asdtdt(sum(n_bvs(n), fc536(f,
  g, y)), bv_to_ket(y))))

axiom ket_sum_power_minus_one :
  (forall f:(bitvec,int) farray.
  forall g:(bitvec,(bitvec,int) farray) farray. forall n:int. ((0 <= n) ->
  (ket_sum_l(n_bvs(n), fc535(f, g, n), n) = ket_sum_l(n_bvs(n), fc537(f, g,
  n), n))))

axiom path_sem_hadamard_zero :
  (forall x:complex matrix. ((x = ket(1, 0)) -> (path_sem(hadamard,
  x) = pps_apply(pps_hadamard, ket(1, 0)))))

axiom path_sem_hadamard_one :
  (forall x:complex matrix. ((x = ket(1, 1)) -> (path_sem(hadamard,
  x) = pps_apply(pps_hadamard, ket(1, 1)))))

axiom path_sem_hadamard_plus :
  (forall x:complex matrix. ((x = pps_apply(pps_hadamard, ket(1, 0))) ->
  (path_sem(hadamard, x) = ket(1, 0))))

axiom path_sem_hadamard_minus :
  (forall x:complex matrix. ((x = pps_apply(pps_hadamard, ket(1, 1))) ->
  (path_sem(hadamard, x) = ket(1, 1))))

axiom path_sem_cnot_basis :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (is_a_ket_basis_elt(x) ->
  (path_sem(cnot, x) = (if (ket_to_int(x) = 0) then ket(2,
  0) else (if (ket_to_int(x) = 1) then ket(2,
  1) else (if (ket_to_int(x) = 2) then ket(2, 3) else ket(2, 2))))))))

axiom path_sem_swap_basis :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (is_a_ket_basis_elt(x) ->
  (path_sem(swap, x) = (if (ket_to_int(x) = 0) then ket(2,
  0) else (if (ket_to_int(x) = 1) then ket(2,
  2) else (if (ket_to_int(x) = 2) then ket(2, 1) else ket(2, 3))))))))

axiom hadamard_invol :
  (forall x:complex matrix. (is_a_ket_l(x, 1) -> (path_sem(hadamard,
  path_sem(hadamard, x)) = x)))

logic ancilla_g : circuit, int,
  (complex matrix,complex matrix) farray -> circuit

axiom ancilla_gqtdef :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (ancilla_g(c, i, path_sem_target) = ancilla(c, i))))))

logic fc538 : circuit, int, (int,int) farray -> (int,int) farray

logic fc539 : circuit, int, (int,int) farray -> (int,int) farray

axiom fcqtdef541 :
  (forall c:circuit. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc538(c, i, x)[k]) = (if (k <  (width(c) - i)) then (x[k]) else 0)))

axiom fcqtdef542 :
  (forall c:circuit. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc539(c, i, x)[k]) = (if (k <  (width(c) - i)) then (x[k]) else 0)))

axiom ancilla_gqtspec :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (ancillas(ancilla_g(c, i, path_sem_target)) = (ancillas(c) + i))))))

axiom ancilla_gqtspec1 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (size(ancilla_g(c, i, path_sem_target)) = size(c))))))

axiom ancilla_gqtspec2 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (range(ancilla_g(c, i, path_sem_target)) = range(c))))))

axiom ancilla_gqtspec3 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (width(ancilla_g(c, i, path_sem_target)) = (width(c) - i))))))

axiom ancilla_gqtspec4 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall ii:int. (basis_ket(ancilla_g(c, i, path_sem_target), x, y,
  ii) = basis_ket(c, fc538(c, i, x), y, ii))))))))

axiom ancilla_gqtspec5 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(ancilla_g(c, i, path_sem_target), x, y) = ang_ind(c, fc539(c, i,
  x), y)))))))

axiom ancilla_gqtspec6 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (forall x:complex matrix. (is_a_ket_l(x, width(ancilla_g(c, i,
  path_sem_target))) -> (kronecker(path_sem(ancilla_g(c, i, path_sem_target),
  x), ket(i, 0)) = path_sem(c, kronecker(x, ket(i, 0))))))))))

axiom ancilla_gqtspec7 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (forall x:complex matrix. (is_a_ket_l(x, width(ancilla_g(c, i,
  path_sem_target))) -> (path_sem(ancilla_g(c, i, path_sem_target),
  x) = (path_sem_target[x]))))))))

logic ancilla_spec : circuit, int, (bitvec,complex matrix) farray -> circuit

logic result65 : (bitvec,complex matrix) farray,
  complex matrix -> (bitvec,complex matrix) farray

logic result66 : circuit, int,
  (bitvec,complex matrix) farray -> (complex matrix,complex matrix) farray

axiom resultqtdef72 :
  (forall path_sem_target:(bitvec,complex matrix) farray.
  forall z:complex matrix. forall x:bitvec. ((result65(path_sem_target,
  z)[x]) = infix_asdtdt(get(z, bv_to_int(x), 0), (path_sem_target[x]))))

axiom resultqtdef73 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray.
  forall z:complex matrix. ((result66(c, i,
  path_sem_target)[z]) = (if is_a_ket_l(z,
  (width(c) - i)) then ket_sum_l(n_bvs((width(c) - i)),
  result65(path_sem_target, z), (width(c) - i)) else make(1, 1, c_one))))

axiom ancilla_specqtdef :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:bitvec. ((length(x) = (width(c) - i)) -> (path_sem(c,
   kronecker(bv_to_ket(x), ket(i, 0))) = kronecker((path_sem_target[x]),
   ket(i, 0))))) ->
  (ancilla_spec(c, i, path_sem_target) = ancilla_g(c, i, result66(c, i,
  path_sem_target)))))))

logic fc540 : circuit, int, (int,int) farray -> (int,int) farray

logic fc541 : circuit, int, (int,int) farray -> (int,int) farray

logic fc542 : (bitvec,complex matrix) farray,
  complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef543 :
  (forall c:circuit. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc540(c, i, x)[k]) = (if (k <  (width(c) - i)) then (x[k]) else 0)))

axiom fcqtdef544 :
  (forall c:circuit. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc541(c, i, x)[k]) = (if (k <  (width(c) - i)) then (x[k]) else 0)))

axiom fcqtdef545 :
  (forall path_sem_target:(bitvec,complex matrix) farray.
  forall z:complex matrix. forall x:bitvec. ((fc542(path_sem_target,
  z)[x]) = infix_asdtdt(get(z, bv_to_int(x), 0), (path_sem_target[x]))))

axiom ancilla_specqtspec :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:bitvec. ((length(x) = (width(c) - i)) -> (path_sem(c,
   kronecker(bv_to_ket(x), ket(i, 0))) = kronecker((path_sem_target[x]),
   ket(i, 0))))) ->
  (ancillas(ancilla_spec(c, i, path_sem_target)) = (ancillas(c) + i))))))

axiom ancilla_specqtspec1 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:bitvec. ((length(x) = (width(c) - i)) -> (path_sem(c,
   kronecker(bv_to_ket(x), ket(i, 0))) = kronecker((path_sem_target[x]),
   ket(i, 0))))) ->
  (size(ancilla_spec(c, i, path_sem_target)) = size(c))))))

axiom ancilla_specqtspec2 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:bitvec. ((length(x) = (width(c) - i)) -> (path_sem(c,
   kronecker(bv_to_ket(x), ket(i, 0))) = kronecker((path_sem_target[x]),
   ket(i, 0))))) ->
  (range(ancilla_spec(c, i, path_sem_target)) = range(c))))))

axiom ancilla_specqtspec3 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:bitvec. ((length(x) = (width(c) - i)) -> (path_sem(c,
   kronecker(bv_to_ket(x), ket(i, 0))) = kronecker((path_sem_target[x]),
   ket(i, 0))))) ->
  (width(ancilla_spec(c, i, path_sem_target)) = (width(c) - i))))))

axiom ancilla_specqtspec4 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:bitvec. ((length(x) = (width(c) - i)) -> (path_sem(c,
   kronecker(bv_to_ket(x), ket(i, 0))) = kronecker((path_sem_target[x]),
   ket(i, 0))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall ii:int. (basis_ket(ancilla_spec(c, i, path_sem_target), x, y,
  ii) = basis_ket(c, fc540(c, i, x), y, ii))))))))

axiom ancilla_specqtspec5 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:bitvec. ((length(x) = (width(c) - i)) -> (path_sem(c,
   kronecker(bv_to_ket(x), ket(i, 0))) = kronecker((path_sem_target[x]),
   ket(i, 0))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(ancilla_spec(c, i, path_sem_target), x, y) = ang_ind(c, fc541(c,
  i, x), y)))))))

axiom ancilla_specqtspec6 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:bitvec. ((length(x) = (width(c) - i)) -> (path_sem(c,
   kronecker(bv_to_ket(x), ket(i, 0))) = kronecker((path_sem_target[x]),
   ket(i, 0))))) ->
  (forall x:complex matrix. (is_a_ket_l(x, width(ancilla_spec(c, i,
  path_sem_target))) -> (kronecker(path_sem(ancilla_spec(c, i,
  path_sem_target), x), ket(i, 0)) = path_sem(c, kronecker(x, ket(i, 0))))))))))

axiom ancilla_specqtspec7 :
  (forall c:circuit. forall i:int.
  forall path_sem_target:(bitvec,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width(c)) ->
  ((forall x:bitvec. ((length(x) = (width(c) - i)) -> (path_sem(c,
   kronecker(bv_to_ket(x), ket(i, 0))) = kronecker((path_sem_target[x]),
   ket(i, 0))))) ->
  (forall z:complex matrix. (is_a_ket_l(z, width(ancilla_spec(c, i,
  path_sem_target))) -> (path_sem(ancilla_spec(c, i, path_sem_target),
  z) = ket_sum_l(n_bvs((width(c) - i)), fc542(path_sem_target, z),
  (width(c) - i)))))))))

axiom mat_sem_seq :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (mat_sem(sequence(d, e)) = mat_mult(mat_sem(e), mat_sem(d)))))

axiom mat_sem_par :
  (forall d:circuit. forall e:circuit. (mat_sem(parallel(d,
  e)) = kronecker(mat_sem(d), mat_sem(e))))

axiom mat_sem_anc :
  (forall c:circuit. forall mat_sem_target:complex matrix. forall i:int.
  ((1 <= i) -> (((i + 1) <= width(c)) -> ((rows(mat_sem_target) = power(2,
  (width(c) - i))) -> ((columns(mat_sem_target) = power(2,
  (width(c) - i))) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) ->
   (mat_mult(mat_sem(c), kronecker(x, ket(i,
   0))) = kronecker(mat_mult(mat_sem_target, x), ket(i, 0))))) ->
  (mat_sem(ancilla(c, i)) = mat_sem_target)))))))

axiom mat_sem_anc_ :
  (forall c:circuit. forall mat_sem_target:complex matrix. forall i:int.
  ((1 <= i) -> ((rows(mat_sem_target) = power(2, (width(c) - i))) ->
  ((columns(mat_sem_target) = power(2, (width(c) - i))) ->
  (((i + 1) <= width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) ->
   (is_a_ket_basis_elt(x) -> (mat_mult(mat_sem(c), kronecker(x, ket(i,
   0))) = kronecker(mat_mult(mat_sem_target, x), ket(i, 0)))))) ->
  (mat_sem(ancilla(c, i)) = mat_sem_target)))))))

axiom mat_sem_id : (mat_sem(id) = make_f(2, 2,
  (indic_closure : (int,(int,complex) farray) farray)))

predicate correct_path_sum_basis(c: circuit, h: pps, x: bitvec) = ((let q1_ =
  h_width(h) : int in ((length(x) = q1_) and (q1_ = width(c)))) and
  infix_eqeq(mat_mult(mat_sem(c), bv_to_ket(x)), pps_apply_basis(h, x)))

predicate correct_path_sum_(c: circuit, h: pps) =
  ((h_width(h) = width(c)) and
  (forall x:complex matrix. (is_a_ket_l(x, width(c)) -> (pps_apply(h,
  x) = mat_mult(mat_sem(c), x)))))

axiom set_correct_path_sum :
  (forall c:circuit. forall h:pps. ((h_width(h) = width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width(c)) -> (pps_apply(h,
   x) = mat_mult(mat_sem(c), x)))) ->
  correct_path_sum_(c, h))))

axiom get_correct_path_sum :
  (forall c:circuit. forall h:pps. forall x:complex matrix.
  ((h_width(h) = width(c)) -> (is_a_ket_l(x, width(c)) ->
  (correct_path_sum_(c, h) -> (pps_apply(h, x) = mat_mult(mat_sem(c), x))))))

axiom get_correct_path_sum_path :
  (forall c:circuit. forall h:pps. forall x:complex matrix.
  ((h_width(h) = width(c)) -> (is_a_ket_l(x, width(c)) ->
  (correct_path_sum_(c, h) -> (pps_apply(h, x) = path_sem(c, x))))))

axiom set_correct_path_sum_basis :
  (forall c:circuit. forall h:pps. ((h_width(h) = width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(h, x) = mat_mult(mat_sem(c), x))))) ->
  correct_path_sum_(c, h))))

axiom set_correct_pps :
  (forall c:circuit. forall h:pps. ((h_width(h) = width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(h, x) = path_sem_basis(c, x))))) ->
  correct_path_sum_(c, h))))

axiom set_correct_pps_ :
  (forall c:circuit. forall h:pps. ((h_width(h) = width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(h, x) = path_sem(c, x))))) ->
  correct_path_sum_(c, h))))

logic fc543 : pps, (int,int) farray -> (int,int) farray

logic fc544 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef546 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc543(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef547 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc544(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom correct_seq :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc543(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc544(h,
   y)])[i]))))))) ->
  correct_path_sum_(sequence(c, cqt), hqtqt)))))))))

logic seq_pps : circuit, circuit, pps, pps, pps -> circuit

logic fc545 : pps, (int,int) farray -> (int,int) farray

logic fc546 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef548 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc545(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef549 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc546(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom seq_ppsqtdef :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc545(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc546(h,
   y)])[i]))))))) ->
  (seq_pps(c, cqt, h, hqt, hqtqt) = sequence(c, cqt))))))))))

logic fc547 : pps, (int,int) farray -> (int,int) farray

logic fc548 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef550 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc547(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef551 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc548(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom seq_ppsqtspec :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc547(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc548(h,
   y)])[i]))))))) ->
  (width(seq_pps(c, cqt, h, hqt, hqtqt)) = width(c))))))))))

axiom seq_ppsqtspec1 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc547(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc548(h,
   y)])[i]))))))) ->
  (size(seq_pps(c, cqt, h, hqt, hqtqt)) = (size(c) + size(cqt)))))))))))

axiom seq_ppsqtspec2 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc547(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc548(h,
   y)])[i]))))))) ->
  (ancillas(seq_pps(c, cqt, h, hqt, hqtqt)) = max(ancillas(c),
  ancillas(cqt)))))))))))

axiom seq_ppsqtspec3 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc547(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc548(h,
   y)])[i]))))))) ->
  correct_path_sum_(seq_pps(c, cqt, h, hqt, hqtqt), hqtqt)))))))))

axiom seq_ppsqtspec4 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc547(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc548(h,
   y)])[i]))))))) ->
  (seq_pps(c, cqt, h, hqt, hqtqt) = sequence(c, cqt))))))))))

logic fc549 : pps, (int,int) farray -> (int,int) farray

logic fc550 : pps, (int,int) farray -> (int,int) farray

logic fc551 : pps, (int,int) farray -> (int,int) farray

logic fc552 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef552 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc549(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef553 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc550(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef554 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc551(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef555 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc552(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom correct_par :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((h_width(hqtqt) = (width(c) + width(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc549(h, x)])[fc550(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc551(h,
   x)])[fc552(h, y)])[(i - h_width(h))]))))))) ->
  correct_path_sum_(parallel(c, cqt), hqtqt)))))))))

logic sequence_ghost_pps : circuit, circuit, pps, pps, pps -> circuit

logic fc553 : pps, (int,int) farray -> (int,int) farray

logic fc554 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef556 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc553(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef557 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc554(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom sequence_ghost_ppsqtdef :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc553(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc554(h,
   y)])[i]))))))) ->
  (sequence_ghost_pps(c, cqt, h, hqt, hqtqt) = sequence(c, cqt))))))))))

logic fc555 : pps, (int,int) farray -> (int,int) farray

logic fc556 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef558 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc555(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef559 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc556(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom sequence_ghost_ppsqtspec :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc555(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc556(h,
   y)])[i]))))))) ->
  (width(sequence_ghost_pps(c, cqt, h, hqt, hqtqt)) = width(c))))))))))

axiom sequence_ghost_ppsqtspec1 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc555(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc556(h,
   y)])[i]))))))) ->
  (size(sequence_ghost_pps(c, cqt, h, hqt,
  hqtqt)) = (size(c) + size(cqt)))))))))))

axiom sequence_ghost_ppsqtspec2 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc555(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc556(h,
   y)])[i]))))))) ->
  (ancillas(sequence_ghost_pps(c, cqt, h, hqt, hqtqt)) = max(ancillas(c),
  ancillas(cqt)))))))))))

axiom sequence_ghost_ppsqtspec3 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc555(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc556(h,
   y)])[i]))))))) ->
  correct_path_sum_(sequence_ghost_pps(c, cqt, h, hqt, hqtqt), hqtqt)))))))))

axiom sequence_ghost_ppsqtspec4 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((width(c) = width(cqt)) -> ((h_width(hqtqt) = width(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc555(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc556(h,
   y)])[i]))))))) ->
  (sequence_ghost_pps(c, cqt, h, hqt, hqtqt) = sequence(c, cqt))))))))))

logic parallel_ghost_pps : circuit, circuit, pps, pps, pps -> circuit

logic fc557 : pps, (int,int) farray -> (int,int) farray

logic fc558 : pps, (int,int) farray -> (int,int) farray

logic fc559 : pps, (int,int) farray -> (int,int) farray

logic fc560 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef560 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc557(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef561 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc558(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef562 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc559(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef563 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc560(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom parallel_ghost_ppsqtdef :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((h_width(hqtqt) = (width(c) + width(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc557(h, x)])[fc558(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc559(h,
   x)])[fc560(h, y)])[(i - h_width(h))]))))))) ->
  (parallel_ghost_pps(c, cqt, h, hqt, hqtqt) = parallel(c, cqt))))))))))

logic fc561 : pps, (int,int) farray -> (int,int) farray

logic fc562 : pps, (int,int) farray -> (int,int) farray

logic fc563 : pps, (int,int) farray -> (int,int) farray

logic fc564 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef564 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc561(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef565 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc562(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef566 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc563(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef567 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc564(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom parallel_ghost_ppsqtspec :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((h_width(hqtqt) = (width(c) + width(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc561(h, x)])[fc562(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc563(h,
   x)])[fc564(h, y)])[(i - h_width(h))]))))))) ->
  correct_path_sum_(parallel_ghost_pps(c, cqt, h, hqt, hqtqt), hqtqt)))))))))

axiom parallel_ghost_ppsqtspec1 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((h_width(hqtqt) = (width(c) + width(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc561(h, x)])[fc562(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc563(h,
   x)])[fc564(h, y)])[(i - h_width(h))]))))))) ->
  (width(parallel_ghost_pps(c, cqt, h, hqt,
  hqtqt)) = (width(c) + width(cqt)))))))))))

axiom parallel_ghost_ppsqtspec2 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((h_width(hqtqt) = (width(c) + width(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc561(h, x)])[fc562(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc563(h,
   x)])[fc564(h, y)])[(i - h_width(h))]))))))) ->
  (size(parallel_ghost_pps(c, cqt, h, hqt,
  hqtqt)) = (size(c) + size(cqt)))))))))))

axiom parallel_ghost_ppsqtspec3 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((h_width(hqtqt) = (width(c) + width(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc561(h, x)])[fc562(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc563(h,
   x)])[fc564(h, y)])[(i - h_width(h))]))))))) ->
  (ancillas(parallel_ghost_pps(c, cqt, h, hqt,
  hqtqt)) = (ancillas(c) + ancillas(cqt)))))))))))

axiom parallel_ghost_ppsqtspec4 :
  (forall c:circuit. forall cqt:circuit. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum_(c, h) -> (correct_path_sum_(cqt,
  hqt) -> ((h_width(hqtqt) = (width(c) + width(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc561(h, x)])[fc562(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc563(h,
   x)])[fc564(h, y)])[(i - h_width(h))]))))))) ->
  (parallel_ghost_pps(c, cqt, h, hqt, hqtqt) = parallel(c, cqt))))))))))

logic fc565 : circuit, int, (int,int) farray -> (int,int) farray

logic fc566 : circuit, int, (int,int) farray -> (int,int) farray

axiom fcqtdef568 :
  (forall c:circuit. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc565(c, i, x)[k]) = (if (k <  (width(c) - i)) then (x[k]) else 0)))

axiom fcqtdef569 :
  (forall c:circuit. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc566(c, i, x)[k]) = (if (k <  (width(c) - i)) then (x[k]) else 0)))

axiom correct_ancilla :
  (forall c:circuit. forall h:pps. forall hqt:pps. forall i:int. ((1 <= i) ->
  (((i + 1) <= width(c)) -> (correct_path_sum_(c, h) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width(c) - i)) -> (path_sem(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0)))))) ->
  ((h_width(hqt) = (width(c) - i)) -> ((h_range(hqt) = h_range(h)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall ii:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqt))) -> ((0 <= (x[j])) and
    ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqt))) -> ((0 <= (y[j])) and
    ((y[j]) <  2)))) ->
   ((((h_basis_ket(hqt)[x])[y])[ii]) = (((h_basis_ket(h)[fc565(c, i,
   x)])[y])[ii])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (((h_angle(hqt)[x])[y]) = ((h_angle(h)[fc566(c, i, x)])[y]))) ->
  correct_path_sum_(ancilla(c, i), hqt))))))))))

axiom set_correct_main_path_sum :
  (forall c:circuit. forall h:pps. ((h_width(h) = width(c)) ->
  ((h_range(h) = range(c)) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = range(c)) ->
   (((h_angle(h)[value(x)])[value(y)]) = ang_ind(c, value(x), value(y)))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. (((0 <= i) and (i <  width(c))) ->
   ((length(x) = width(c)) -> ((length(y) = range(c)) ->
   ((((h_basis_ket(h)[value(x)])[value(y)])[i]) = basis_ket(c, value(x),
   value(y), i))))))) ->
  correct_path_sum_(c, h))))))

axiom set_correct_circ_to_pps :
  (forall c:circuit. correct_path_sum_(c, circ_to_pps(c)))

predicate circuit_equiv(c: circuit, cqt: circuit) =
  ((width(c) = width(cqt)) and
  (forall x:bitvec. ((length(x) = width(c)) -> (path_sem(c,
  bv_to_ket(x)) = path_sem(cqt, bv_to_ket(x))))))

axiom path_to_mat_sem :
  (forall c:circuit. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, width(c)) -> ((path_sem(c, x) = y) -> (mat_mult(mat_sem(c),
  x) = y))))

axiom path_to_mat_sem_rev :
  (forall c:circuit. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, width(c)) -> ((path_sem(c, x) = y) ->
  (y = mat_mult(mat_sem(c), x)))))

axiom mat_to_path_sem :
  (forall c:circuit. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, width(c)) -> ((mat_mult(mat_sem(c), x) = y) -> (path_sem(c,
  x) = y))))

axiom path_to_mat_sem_exp :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(c, x) = mat_mult(mat_sem(c), x))))

axiom mat_to_path_sem_exp :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (mat_mult(mat_sem(c), x) = path_sem(c, x))))

axiom set_path_sem_by_correct_pps :
  (forall c:circuit. forall h:pps. forall x:complex matrix.
  (correct_path_sum_(c, h) -> (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem(c, x) = pps_apply(h, x))))))

logic fc567 : circuit, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef570 :
  (forall c:circuit. forall x:bitvec. forall y:bitvec. ((fc567(c,
  x)[y]) = infix_asdtdt(ang_exp(ang_ind(c, value(x), value(y))),
  bv_to_ket(make_bv((((basis_ket_closure[c])[value(x)])[value(y)]),
  width(c))))))

axiom set_path_sem_by_main_pps :
  (forall c:circuit. forall x:bitvec. ((length(x) = width(c)) -> (path_sem(c,
  bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(range(c)),
  ket_sum_l(n_bvs(range(c)), fc567(c, x), width(c))))))

axiom set_path_sem_by_correct_pps_gen :
  (forall c:circuit. forall h:pps. (correct_path_sum_(c, h) ->
  (forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem(c, x) = pps_apply(h, x)))))))

axiom set_correct_path_sum_sim :
  (forall c:circuit. forall h:pps. forall hqt:pps.
  ((h_range(h) = h_range(hqt)) -> ((h_width(h) = h_width(hqt)) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = h_range(h)) ->
   (((h_angle(h)[value(x)])[value(y)]) = ((h_angle(hqt)[value(x)])[value(y)]))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. ((length(x) = width(c)) -> ((length(y) = h_range(h)) ->
   (((0 <= i) and (i <  width(c))) ->
   ((((h_basis_ket(h)[value(x)])[value(y)])[i]) = (((h_basis_ket(hqt)[value(x)])[value(y)])[i]))))))) ->
  (correct_path_sum_(c, h) -> correct_path_sum_(c, hqt)))))))

axiom set_correct_path_sum_by_main_sim :
  (forall c:circuit. forall h:pps. ((h_range(h) = range(c)) ->
  ((h_width(h) = width(c)) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = h_range(h)) ->
   (((h_angle(h)[value(x)])[value(y)]) = ang_ind(c, value(x), value(y)))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. ((length(x) = width(c)) -> ((length(y) = h_range(h)) ->
   (((0 <= i) and (i <  width(c))) ->
   ((((h_basis_ket(h)[value(x)])[value(y)])[i]) = basis_ket(c, value(x),
   value(y), i))))))) ->
  correct_path_sum_(c, h))))))

axiom path_sum_equiv :
  (forall c:circuit. forall h:pps. forall hqt:pps. ((0 <= h_range(h)) ->
  ((h_range(h) = h_range(hqt)) -> ((h_width(h) = h_width(hqt)) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = h_range(h)) ->
   (((h_angle(h)[value(x)])[value(y)]) = ((h_angle(hqt)[value(x)])[value(y)]))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. (((0 <= i) and (i <  width(c))) ->
   ((length(x) = width(c)) -> ((length(y) = h_range(h)) ->
   ((((h_basis_ket(h)[value(x)])[value(y)])[i]) = (((h_basis_ket(hqt)[value(x)])[value(y)])[i]))))))) ->
  (correct_path_sum_(c, h) -> correct_path_sum_(c, hqt))))))))

axiom path_sum_equiv1 :
  (forall c:circuit. forall h:pps. forall hqt:pps. ((0 <= h_range(h)) ->
  ((h_range(h) = h_range(hqt)) -> ((h_width(h) = h_width(hqt)) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = h_range(h)) ->
   (((h_angle(h)[value(x)])[value(y)]) = ((h_angle(hqt)[value(x)])[value(y)]))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. (((0 <= i) and (i <  width(c))) ->
   ((length(x) = width(c)) -> ((length(y) = h_range(h)) ->
   ((((h_basis_ket(h)[value(x)])[value(y)])[i]) = (((h_basis_ket(hqt)[value(x)])[value(y)])[i]))))))) ->
  (correct_path_sum_(c, hqt) -> correct_path_sum_(c, h))))))))

axiom path_sum_pps_apply_equiv :
  (forall c:circuit. forall h:pps. forall hqt:pps. (pps_apply_equiv(h,
  hqt) -> (correct_path_sum_(c, h) -> correct_path_sum_(c, hqt))))

axiom path_sum_pps_apply_equiv_ref :
  (forall c:circuit. forall h:pps. (pps_apply_equiv(h, circ_to_pps(c)) ->
  correct_path_sum_(c, h)))

axiom path_sum_pps_apply_equiv_rev :
  (forall c:circuit. forall h:pps. forall hqt:pps. (correct_path_sum_(c,
  h) -> (correct_path_sum_(c, hqt) -> pps_apply_equiv(h, hqt))))

axiom path_sum_pps_apply_equiv_ref_rev :
  (forall c:circuit. forall h:pps. (correct_path_sum_(c, h) ->
  pps_apply_equiv(h, circ_to_pps(c))))

axiom correct_to_path_sem :
  (forall c:circuit. forall h:pps. (correct_path_sum_(c, h) ->
  (forall x:complex matrix. (is_a_ket_l(x, width(c)) -> (pps_apply(h,
  x) = path_sem(c, x))))))

axiom correct_to_mat_sem :
  (forall c:circuit. forall h:pps. (correct_path_sum_(c, h) ->
  (forall x:complex matrix. (is_a_ket_l(x, width(c)) -> (pps_apply(h,
  x) = mat_mult(mat_sem(c), x))))))

axiom swap_invol_basis :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (is_a_ket_basis_elt(x) ->
  (path_sem(swap, path_sem(swap, x)) = x))))

axiom cnot_invol_basis :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (is_a_ket_basis_elt(x) ->
  (path_sem(cnot, path_sem(cnot, x)) = x))))

axiom swap_invol :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (path_sem(swap,
  path_sem(swap, x)) = x)))

axiom cnot_invol :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (path_sem(cnot,
  path_sem(cnot, x)) = x)))

axiom mat_sem_to_correct :
  (forall c:circuit. forall h:pps. ((h_width(h) = width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(h, x) = mat_mult(mat_sem(c), x))))) ->
  correct_path_sum_(c, h))))

axiom path_sem_to_correct :
  (forall c:circuit. forall h:pps. ((h_width(h) = width(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(h, x) = path_sem(c, x))))) ->
  correct_path_sum_(c, h))))

axiom correct_main_path_sum :
  (forall c:circuit. correct_path_sum_(c, circ_to_pps(c)))

logic correct_path_sum_bv : circuit, int,
  (bitvec,(bitvec,bitvec) farray) farray,
  (bitvec,(bitvec,angle) farray) farray -> prop

axiom correct_path_sum_bvqtdef :
  (forall c:circuit. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width(c))))) ->
  (correct_path_sum_bv(c, r, k, a) -> correct_path_sum_(c,
  build_pps_bv(width(c), r, k, a))))))

axiom correct_path_sum_bvqtdef1 :
  (forall c:circuit. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width(c))))) ->
  (correct_path_sum_(c, build_pps_bv(width(c), r, k, a)) ->
  correct_path_sum_bv(c, r, k, a)))))

axiom correct_path_sum_to_bv :
  (forall c:circuit. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width(c))))) ->
  (correct_path_sum_(c, build_pps_bv(width(c), r, k, a)) ->
  correct_path_sum_bv(c, r, k, a)))))

axiom correct_path_sum_by_bv :
  (forall c:circuit. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray.
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width(c))))) ->
  ((0 <= r) -> (correct_path_sum_bv(c, r, k, a) -> correct_path_sum_(c,
  build_pps_bv(width(c), r, k, a))))))

axiom correct_path_sum_bv_main :
  (forall c:circuit. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width(c))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. ((length(x) = width(c)) -> ((length(y) = r) ->
   (((0 <= i) and (i <  width(c))) -> ((value(((k[x])[y]))[i]) = basis_ket(c,
   value(x), value(y), i))))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r) -> (((a[x])[y]) = ang_ind(c, value(x), value(y)))))) ->
  ((r = range(c)) -> correct_path_sum_bv(c, r, k, a)))))))

logic fc568 : (bitvec,(bitvec,bitvec) farray) farray,
  (bitvec,(bitvec,angle) farray) farray,
  bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef571 :
  (forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. forall x:bitvec.
  forall y:bitvec. ((fc568(k, a, x)[y]) = infix_asdtdt(ang_exp(((a[x])[y])),
  bv_to_ket(((k[x])[y])))))

axiom correct_path_sum_bv_apply :
  (forall c:circuit. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. forall x:bitvec.
  ((0 <= r) ->
  ((forall x1:bitvec. forall y:bitvec. ((length(x1) = width(c)) ->
   ((length(y) = r) -> (length(((k[x1])[y])) = width(c))))) ->
  ((length(x) = width(c)) -> (correct_path_sum_bv(c, r, k, a) -> (path_sem(c,
  bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(r), ket_sum_l(n_bvs(r),
  fc568(k, a, x), width(c)))))))))

axiom correct_path_sum_bv_sim :
  (forall c:circuit. forall r1:int.
  forall k1:(bitvec,(bitvec,bitvec) farray) farray.
  forall a1:(bitvec,(bitvec,angle) farray) farray. forall r2:int.
  forall k2:(bitvec,(bitvec,bitvec) farray) farray.
  forall a2:(bitvec,(bitvec,angle) farray) farray. ((0 <= r1) ->
  ((r1 = r2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r1) -> (length(((k1[x])[y])) = width(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r1) -> (((k1[x])[y]) = ((k2[x])[y]))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r1) -> (((a1[x])[y]) = ((a2[x])[y]))))) ->
  (correct_path_sum_bv(c, r1, k1, a1) -> correct_path_sum_bv(c, r2, k2,
  a2))))))))

logic ids : int -> circuit

axiom idsqtdef : (forall n:int. ((1 <= n) -> ((n = 1) -> (ids(n) = id))))

axiom idsqtdef1 :
  (forall n:int. ((1 <= n) -> ((not (n = 1)) ->
  (ids(n) = parallel(ids((n - 1)), id)))))

axiom idsqtspec : (forall n:int. ((1 <= n) -> (width(ids(n)) = n)))

axiom idsqtspec1 : (forall n:int. ((1 <= n) -> (size(ids(n)) = 0)))

axiom idsqtspec2 : (forall n:int. ((1 <= n) -> (ancillas(ids(n)) = 0)))

axiom idsqtspec3 : (forall n:int. ((1 <= n) -> (range(ids(n)) = 0)))

axiom idsqtspec4 :
  (forall n:int. ((1 <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket(ids(n), x, y, i) = (x[i]))))))

axiom idsqtspec5 :
  (forall n:int. ((1 <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(ids(n), x,
  y) = ang_zero))))

axiom idsqtspec6 :
  (forall n:int. ((1 <= n) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (path_sem(ids(n), x) = x))))))

axiom idsqtspec7 :
  (forall n:int. ((1 <= n) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (path_sem(ids(n), x) = x)))))

logic place_zero : circuit, int -> circuit

axiom place_zeroqtdef :
  (forall c:circuit. forall n:int. ((width(c) <= n) -> ((n = width(c)) ->
  (place_zero(c, n) = c))))

axiom place_zeroqtdef1 :
  (forall c:circuit. forall n:int. ((width(c) <= n) ->
  ((not (n = width(c))) -> (place_zero(c, n) = parallel(c,
  ids((n - width(c))))))))

axiom place_zeroqtspec :
  (forall c:circuit. forall n:int. ((width(c) <= n) ->
  (ancillas(place_zero(c, n)) = ancillas(c))))

axiom place_zeroqtspec1 :
  (forall c:circuit. forall n:int. ((width(c) <= n) -> (size(place_zero(c,
  n)) = size(c))))

axiom place_zeroqtspec2 :
  (forall c:circuit. forall n:int. ((width(c) <= n) -> (range(place_zero(c,
  n)) = range(c))))

axiom place_zeroqtspec3 :
  (forall c:circuit. forall n:int. ((width(c) <= n) -> (width(place_zero(c,
  n)) = n)))

axiom place_zeroqtspec4 :
  (forall c:circuit. forall n:int. ((width(c) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) -> (basis_ket(place_zero(c, n), x,
  y, i) = (if ((0 <= i) and (i <  width(c))) then basis_ket(c, x, y,
  i) else (x[i]))))))))

axiom place_zeroqtspec5 :
  (forall c:circuit. forall n:int. ((width(c) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(place_zero(c, n), x, y) = ang_ind(c, x, y)))))

axiom place_zeroqtspec6 :
  (forall c:circuit. forall n:int. ((width(c) <= n) -> (place_zero(c,
  n) = (if (n = width(c)) then c else parallel(c, ids((n - width(c))))))))

logic place : circuit, int, int -> circuit

axiom placeqtdef :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> ((k = 0) -> (place(c, k, n) = place_zero(c,
  n))))))

axiom placeqtdef1 :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> ((not (k = 0)) -> (place(c, k,
  n) = parallel(ids(k), place_zero(c, (n - k))))))))

logic fc569 : int, (int,int) farray -> (int,int) farray

logic fc570 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef572 :
  (forall k:int. forall x:(int,int) farray. forall j:int. ((fc569(k,
  x)[j]) = (x[(j + k)])))

axiom fcqtdef573 :
  (forall k:int. forall x:(int,int) farray. forall j:int. ((fc570(k,
  x)[j]) = (x[(j + k)])))

axiom placeqtspec :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> (ancillas(place(c, k, n)) = ancillas(c)))))

axiom placeqtspec1 :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> (size(place(c, k, n)) = size(c)))))

axiom placeqtspec2 :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> (range(place(c, k, n)) = range(c)))))

axiom placeqtspec3 :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> (width(place(c, k, n)) = n))))

axiom placeqtspec4 :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) -> (basis_ket(place(c, k, n), x, y,
  i) = (if ((k <= i) and (i <  (k + width(c)))) then basis_ket(c, fc569(k,
  x), y, (i - k)) else (x[i])))))))))

axiom placeqtspec5 :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(place(c, k,
  n), x, y) = ang_ind(c, fc570(k, x), y))))))

axiom placeqtspec6 :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> (place(c, k, n) = (if ((k = 0) and
  (n = (k + width(c)))) then c else (if (k = 0) then parallel(c,
  ids(((n - k) - width(c)))) else (if (n = (k + width(c))) then parallel(ids(k),
  c) else parallel(ids(k), parallel(c, ids(((n - k) - width(c))))))))))))

logic ket_zero4 : complex matrix

axiom ket_zeroqtdef : is_a_ket_l(ket_zero4, 0)

axiom ket_zeroqtdef1 : is_a_ket_basis_elt(ket_zero4)

axiom ket_zeroqtdef2 :
  (forall i:int. ((i = 0) -> (get(ket_zero4, i, 0) = c_one)))

axiom ket_zeroqtdef3 : (rows(ket_zero4) = 1)

axiom ket_zeroqtdef4 : (columns(ket_zero4) = 1)

axiom get_ket_zero1 :
  (forall x:complex matrix. ((x = ket_zero4) -> is_a_ket_l(x, 0)))

axiom get_ket_zero2 :
  (forall x:complex matrix. ((x = ket_zero4) ->
  (forall i:int. ((i = 0) -> (get(x, i, 0) = c_one)))))

axiom set_ket_zero :
  (forall x:complex matrix. ((rows(x) = 1) -> ((columns(x) = 1) -> ((get(x,
  0, 0) = c_one) -> (x = ket_zero4)))))

axiom ket_to_bv_zero :
  (forall x:bitvec. ((length(x) = 0) -> (x = ket_to_bv(ket_zero4))))

axiom bv_to_ket_zero :
  (forall x:bitvec. ((length(x) = 0) -> (bv_to_ket(x) = ket_zero4)))

axiom ket_zero_kron :
  (forall x:complex matrix. forall y:complex matrix. ((x = ket_zero4) ->
  (kronecker(x, y) = y)))

axiom kron_ket_zero :
  (forall x:complex matrix. forall y:complex matrix. ((x = ket_zero4) ->
  (kronecker(y, x) = y)))

axiom place_circ_to_pps :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> correct_path_sum_(place(c, k, n),
  pps_place(circ_to_pps(c), k, n)))))

axiom pps_apply_equiv_by_circ :
  (forall c:circuit. forall h:pps. forall hqt:pps. (correct_path_sum_(c,
  h) -> (correct_path_sum_(c, hqt) -> pps_apply_equiv(h, hqt))))

axiom place_pps :
  (forall c:circuit. forall h:pps. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> (correct_path_sum_(c, h) ->
  correct_path_sum_(place(c, k, n), pps_place(h, k, n))))))

axiom place_kron :
  (forall c:circuit. forall k:int. forall n:int. forall x:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix.
  forall z:complex matrix. ((0 <  k) -> (((width(c) + k) <  n) ->
  (is_a_ket_l(x, k) -> (is_a_ket_l(y, width(c)) -> (is_a_ket_l(z,
  ((n - width(c)) - k)) -> ((path_sem(c, y) = yqt) -> (path_sem(place(c, k,
  n), kronecker(x, kronecker(y, z))) = kronecker(x, kronecker(yqt,
  z))))))))))

axiom place_kron_left :
  (forall c:circuit. forall n:int. forall y:complex matrix.
  forall yqt:complex matrix. forall z:complex matrix. ((width(c) <  n) ->
  (is_a_ket_l(y, width(c)) -> (is_a_ket_l(z, (n - width(c))) -> ((path_sem(c,
  y) = yqt) -> (path_sem(place(c, 0, n), kronecker(y, z)) = kronecker(yqt,
  z)))))))

axiom place_kron_right :
  (forall c:circuit. forall k:int. forall n:int. ((0 <  k) ->
  ((n = (width(c) + k)) ->
  (forall y:complex matrix. forall x:complex matrix. (is_a_ket_l(x, k) ->
  (is_a_ket_l(y, (n - k)) -> (path_sem(place(c, k, n), kronecker(x,
  y)) = kronecker(x, path_sem(c, y)))))))))

axiom place_kron_right_sem :
  (forall c:circuit. forall k:int. forall n:int. ((0 <  k) ->
  ((n = (width(c) + k)) ->
  (forall y:complex matrix. forall x:complex matrix. forall z:complex matrix.
  (is_a_ket_l(x, k) -> (is_a_ket_l(y, (n - k)) -> (sem(c, y, z) ->
  sem(place(c, k, n), kronecker(x, y), kronecker(x, z)))))))))

axiom place_zero_kron :
  (forall c:circuit. forall n:int. forall x:bitvec. ((width(c) <= n) ->
  ((length(x) = n) -> (path_sem(place_zero(c, n),
  bv_to_ket(x)) = (if (n = width(c)) then path_sem(c,
  bv_to_ket(x)) else kronecker(path_sem(c, bv_to_ket(hpart(x, width(c)))),
  bv_to_ket(tpart(x, width(c)))))))))

axiom place_kron_gen :
  (forall c:circuit. forall k:int. forall n:int. forall x:bitvec.
  ((0 <= k) -> (((width(c) + k) <= n) -> ((length(x) = n) ->
  (path_sem(place(c, k, n),
  bv_to_ket(x)) = (if (k = 0) then (if (n = width(c)) then path_sem(c,
  bv_to_ket(x)) else kronecker(path_sem(c, bv_to_ket(hpart(x, width(c)))),
  bv_to_ket(tpart(x,
  width(c))))) else (if (n = (k + width(c))) then kronecker(bv_to_ket(hpart(x,
  k)), path_sem(c, bv_to_ket(tpart(x, k)))) else kronecker(bv_to_ket(hpart(x,
  k)), kronecker(path_sem(c, bv_to_ket(htpart(x, k, width(c)))),
  bv_to_ket(tpart(x, (width(c) + k))))))))))))

axiom place_kronecker :
  (forall c:circuit. forall k:int. forall n:int. forall x:bitvec.
  ((0 <= k) -> (((width(c) + k) <= n) -> ((length(x) = n) ->
  (path_sem(place(c, k, n), bv_to_ket(x)) = kronecker(bv_to_ket(hpart(x, k)),
  kronecker(path_sem(c, bv_to_ket(htpart(x, k, width(c)))),
  bv_to_ket(tpart(x, (width(c) + k))))))))))

axiom place_kron_gen_ :
  (forall c:circuit. forall k:int. forall n:int. ((0 <  k) ->
  (((width(c) + k) <  n) ->
  (forall x:complex matrix. forall y:complex matrix.
  forall yqt:complex matrix. forall z:complex matrix. (is_a_ket_l(x, k) ->
  (is_a_ket_l(y, width(c)) -> (is_a_ket_l(z, ((n - width(c)) - k)) -> (sem(c,
  y, yqt) -> sem(place(c, k, n), kronecker(x, kronecker(y, z)), kronecker(x,
  kronecker(yqt, z)))))))))))

axiom place_zero_place :
  (forall c:circuit. forall k:int. forall n:int. forall nqt:int.
  forall x:bitvec. ((0 <= k) -> (((width(c) + k) <= n) -> ((n <= nqt) ->
  ((length(x) = nqt) -> (path_sem(place_zero(place(c, k, n), nqt),
  bv_to_ket(x)) = path_sem(place(c, k, nqt), bv_to_ket(x))))))))

axiom place_place :
  (forall c:circuit. forall k:int. forall kqt:int. forall n:int.
  forall nqt:int. forall x:bitvec. ((0 <= k) -> (((width(c) + k) <= n) ->
  ((0 <= kqt) -> (((n + kqt) <= nqt) -> ((length(x) = nqt) ->
  (path_sem(place(place(c, k, n), kqt, nqt),
  bv_to_ket(x)) = path_sem(place(c, (k + kqt), nqt), bv_to_ket(x)))))))))

logic fc571 : int, bitvec -> (int,int) farray

logic fc572 : int, bitvec -> (int,int) farray

axiom fcqtdef574 :
  (forall k:int. forall x:bitvec. forall i:int. ((fc571(k,
  x)[i]) = (value(x)[(i + k)])))

axiom fcqtdef575 :
  (forall k:int. forall y:bitvec. forall i:int. ((fc572(k,
  y)[i]) = (value(y)[(i + k)])))

axiom place_get_ket :
  (forall c:circuit. forall k:int. forall n:int. forall x:bitvec.
  forall y:bitvec. ((0 <= k) -> (((width(c) + k) <= n) -> ((length(x) = n) ->
  ((length(y) = n) -> ((hpart(x, k) = hpart(y, k)) -> ((tpart(x,
  (k + width(c))) = tpart(y, (k + width(c)))) -> (get(path_sem(place(c, k,
  n), bv_to_ket(x)), bv_to_int(y), 0) = get(path_sem(c,
  bv_to_ket(make_bv(fc571(k, x), width(c)))), bv_to_int(make_bv(fc572(k, y),
  width(c))), 0)))))))))

axiom place_get_ket_hpart_null :
  (forall c:circuit. forall k:int. forall n:int. forall x:bitvec.
  forall y:bitvec. ((0 <= k) -> (((width(c) + k) <= n) -> ((length(x) = n) ->
  ((length(y) = n) -> ((not (hpart(x, k) = hpart(y, k))) ->
  (get(path_sem(place(c, k, n), bv_to_ket(x)), bv_to_int(y),
  0) = c_zero)))))))

axiom place_get_ket_tpart_null :
  (forall c:circuit. forall k:int. forall n:int. forall x:bitvec.
  forall y:bitvec. ((0 <= k) -> (((width(c) + k) <= n) -> ((length(x) = n) ->
  ((length(y) = n) -> ((not (tpart(x, (k + width(c))) = tpart(y,
  (k + width(c))))) -> (get(path_sem(place(c, k, n), bv_to_ket(x)),
  bv_to_int(y), 0) = c_zero)))))))

logic place_hadamard : int, int -> circuit

axiom place_hadamardqtdef :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) -> (place_hadamard(k,
  n) = place(hadamard, k, n))))

axiom place_hadamardqtspec :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (range(place_hadamard(k, n)) = 1)))

axiom place_hadamardqtspec1 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (width(place_hadamard(k, n)) = n)))

axiom place_hadamardqtspec2 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (size(place_hadamard(k, n)) = 1)))

axiom place_hadamardqtspec3 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (ancillas(place_hadamard(k, n)) = 0)))

axiom place_hadamardqtspec4 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) -> (basis_ket(place_hadamard(k, n),
  x, y, i) = (if (i = k) then (y[0]) else (x[i]))))))))

axiom place_hadamardqtspec5 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(place_hadamard(k, n), x, y) = infix_sldtsl(((x[k]) * (y[0])), 1)))))

axiom place_hadamardqtspec6 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall m:int. ((1 <= m) -> (ang_ind(place_hadamard(k, n), x,
  y) = infix_sldtsl((((x[k]) * (y[0])) * power(2, (m - 1))), m)))))))

logic place_hadamard_bv : int, int -> circuit

axiom place_hadamard_bvqtdef :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (place_hadamard_bv(k, n) = place_hadamard(k, n))))

logic fc573 : int, bitvec, bitvec -> (int,int) farray

logic fc574 : int, int -> (bitvec,(bitvec,bitvec) farray) farray

logic fc575 : int, int -> (bitvec,(bitvec,angle) farray) farray

axiom fcqtdef576 :
  (forall k:int. forall x:bitvec. forall y:bitvec. forall i:int. ((fc573(k,
  x, y)[i]) = (if (i = k) then (value(y)[0]) else (value(x)[i]))))

axiom fcqtdef577 :
  (forall k:int. forall n:int. forall x:bitvec. forall y:bitvec. (((fc574(k,
  n)[x])[y]) = make_bv(fc573(k, x, y), n)))

axiom fcqtdef578 :
  (forall k:int. forall n:int. forall x:bitvec. forall y:bitvec. (((fc575(k,
  n)[x])[y]) = infix_sldtsl((((value(x)[k]) * (value(y)[0])) * power(2,
  (n - 1))), n)))

axiom place_hadamard_bvqtspec :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (range(place_hadamard_bv(k, n)) = 1)))

axiom place_hadamard_bvqtspec1 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (width(place_hadamard_bv(k, n)) = n)))

axiom place_hadamard_bvqtspec2 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (size(place_hadamard_bv(k, n)) = 1)))

axiom place_hadamard_bvqtspec3 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (ancillas(place_hadamard_bv(k, n)) = 0)))

axiom place_hadamard_bvqtspec4 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) -> (basis_ket(place_hadamard_bv(k,
  n), x, y, i) = (if (i = k) then (y[0]) else (x[i]))))))))

axiom place_hadamard_bvqtspec5 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(place_hadamard_bv(k, n), x, y) = infix_sldtsl(((x[k]) * (y[0])),
  1)))))

axiom place_hadamard_bvqtspec6 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(place_hadamard_bv(k, n), x,
  y) = infix_sldtsl((((x[k]) * (y[0])) * power(2, (n - 1))), n)))))

axiom place_hadamard_bvqtspec7 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  correct_path_sum_bv(place_hadamard_bv(k, n), 1, fc574(k, n), fc575(k, n))))

logic cont_size : int

axiom cont_sizeqtdef : (0 <  cont_size)

function rz_(k: int) : circuit = seq_pps(phase((-incr_abs(k))), rz(k),
  pps_phase((-incr_abs(k))), pps_rz(k), pps_rz_b(k))

axiom rz_qtspec :
  (forall k:int. (pre(rz_(k)) = Sequence(Phase((-incr_abs(k))), Rz(k))))

axiom rz_qtspec1 : (forall k:int. correct_path_sum_(rz_(k), pps_rz_b(k)))

axiom rz_qtspec2 : (forall k:int. (ancillas(rz_(k)) = 0))

axiom rz_qtspec3 : (forall k:int. (size(rz_(k)) = 2))

axiom rz_qtspec4 : (forall k:int. (range(rz_(k)) = 0))

axiom rz_qtspec5 : (forall k:int. (width(rz_(k)) = 1))

axiom rz_qtspec6 :
  (forall k:int. (path_sem(rz_(k), ket(1,
  0)) = infix_asdtdt(ang_exp(infix_sldtsl((- 1), incr_abs(k))), ket(1, 0))))

axiom rz_qtspec7 :
  (forall k:int. (path_sem(rz_(k), ket(1,
  1)) = infix_asdtdt(ang_exp(infix_sldtsl(1, incr_abs(k))), ket(1, 1))))

axiom rz_qtspec8 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket(rz_(k), x, y, i) = (x[i])))))

axiom rz_qtspec9 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (((0 <= (x[0])) and
  ((x[0]) <  2)) -> (ang_ind(rz_(k), x, y) = phase_inv_(((x[0]) - 1),
  infix_sldtsl(1, incr_abs(k)))))))

function rx(k: int) : circuit = seq_pps(hadamard, seq_pps(rz_(k), hadamard,
  pps_rz_b(k), pps_hadamard, pps_seq(pps_rz_b(k), pps_hadamard)),
  pps_hadamard, pps_seq(pps_rz_b(k), pps_hadamard), pps_rx(k))

axiom rxqtspec :
  (forall k:int. (rx(k) = sequence(hadamard, sequence(rz_(k), hadamard))))

axiom rxqtspec1 :
  (forall k:int. (pre(rx(k)) = Sequence(Hadamard,
  Sequence(Sequence(Phase((-incr_abs(k))), Rz(k)), Hadamard))))

axiom rxqtspec2 : (forall k:int. correct_path_sum_(rx(k), pps_rx(k)))

axiom rxqtspec3 : (forall k:int. (width(rx(k)) = 1))

logic zz : circuit

axiom zzqtdef : correct_path_sum_(zz, pps_zz)

axiom zzqtdef1 : (width(zz) = 1)

axiom path_sem_zz_zero :
  (forall x:complex matrix. ((x = ket(1, 0)) -> (path_sem(zz, x) = ket(1,
  0))))

axiom path_sem_zz_one :
  (forall x:complex matrix. ((x = ket(1, 1)) -> (path_sem(zz,
  x) = infix_asdtdt(prefix_mndt(c_one), ket(1, 1)))))

axiom path_sem_zz_plus :
  (forall x:complex matrix. ((x = pps_apply(pps_hadamard, ket(1, 0))) ->
  (path_sem(zz, x) = pps_apply(pps_hadamard, ket(1, 1)))))

axiom path_sem_zz_minus :
  (forall x:complex matrix. ((x = pps_apply(pps_hadamard, ket(1, 1))) ->
  (path_sem(zz, x) = pps_apply(pps_hadamard, ket(1, 0)))))

logic xx : circuit

axiom xxqtdef : correct_path_sum_(xx, pps_xx)

axiom xxqtdef1 : (width(xx) = 1)

logic path_sem_xx : complex matrix -> complex matrix

axiom path_sem_xxqtdef :
  (forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem_xx(x) = path_sem(xx, x))))

axiom path_sem_xxqtspec :
  (forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem_xx(x) = add_ket_l(infix_asdtdt(get(x, 1, 0), ket(1, 0)),
  infix_asdtdt(get(x, 0, 0), ket(1, 1)), 1))))

axiom path_sem_xx_add_rev :
  (forall a:complex. forall b:complex. (path_sem_xx(add_ket_l(infix_asdtdt(a,
  ket(1, 0)), infix_asdtdt(b, ket(1, 1)), 1)) = add_ket_l(infix_asdtdt(b,
  ket(1, 0)), infix_asdtdt(a, ket(1, 1)), 1)))

axiom path_sem_xx_z : (path_sem_xx(ket(1, 0)) = ket(1, 1))

axiom path_sem_xx_o : (path_sem_xx(ket(1, 1)) = ket(1, 0))

axiom path_sem_xx_invol :
  (forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem_xx(path_sem_xx(x)) = x)))

logic path_sem_cnot_basis_left : complex matrix,
  complex matrix -> complex matrix

axiom path_sem_cnot_basis_leftqtdef :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (path_sem_cnot_basis_left(x, y) = path_sem(cnot, kronecker(x, y))))))))

axiom path_sem_cnot_basis_leftqtspec :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (path_sem_cnot_basis_left(x, y) = (if (x = ket(1, 0)) then kronecker(x,
  y) else kronecker(x, path_sem_xx(y)))))))))

axiom path_sem_cnot_basis_leftqtspec1 :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  ((x = ket(1, 0)) -> (path_sem_cnot_basis_left(x, y) = kronecker(x,
  y))))))))

axiom path_sem_cnot_basis_leftqtspec2 :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  ((x = ket(1, 1)) -> (path_sem_cnot_basis_left(x, y) = kronecker(x,
  path_sem_xx(y)))))))))

logic path_sem_cnot : complex matrix, complex matrix -> complex matrix

axiom path_sem_cnotqtdef :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> (path_sem_cnot(x,
  y) = path_sem(cnot, kronecker(x, y)))))))

axiom path_sem_cnotqtspec :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> (path_sem_cnot(x,
  y) = (if (x = ket(1, 0)) then kronecker(x, y) else kronecker(x,
  path_sem_xx(y))))))))

axiom path_sem_cnotqtspec1 :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> ((x = ket(1, 0)) ->
  (path_sem_cnot(x, y) = kronecker(x, y)))))))

axiom path_sem_cnotqtspec2 :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> ((x = ket(1, 1)) ->
  (path_sem_cnot(x, y) = kronecker(x, path_sem_xx(y))))))))

logic path_sem_swap : complex matrix, complex matrix -> complex matrix

axiom path_sem_swapqtdef :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (path_sem_swap(x, y) = path_sem(swap, kronecker(x,
  y))))))

axiom path_sem_swapqtspec :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (path_sem_swap(x, y) = kronecker(y, x)))))

logic yy : circuit

axiom yyqtdef : correct_path_sum_(yy, pps_yy)

axiom yyqtdef1 : (width(yy) = 1)

function ry(k: int) : circuit = seq_pps(seq_pps(rz((- 2)), rx(k),
  pps_rz((- 2)), pps_rx(k), pps_seq(pps_rz((- 2)), pps_rx(k))), rz(2),
  pps_seq(pps_rz((- 2)), pps_rx(k)), pps_rz(2), pps_ry(k))

axiom ryqtspec :
  (forall k:int. (ry(k) = sequence(sequence(rz((- 2)), rx(k)), rz(2))))

axiom ryqtspec1 :
  (forall k:int. (pre(ry(k)) = Sequence(Sequence(Rz((- 2)), pre(rx(k))),
  Rz(2))))

axiom ryqtspec2 : (forall k:int. correct_path_sum_(ry(k), pps_ry(k)))

axiom ryqtspec3 : (forall k:int. (width(ry(k)) = 1))

logic c_inverse_pre : (int,int) farray, int, int -> int

axiom c_inverse_preqtspec :
  (forall f:(int,int) farray. forall n:int. forall i:int. (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (((0 <= i) and (i <  n)) ->
  (0 <= c_inverse_pre(f, n, i)))))

axiom c_inverse_preqtspec1 :
  (forall f:(int,int) farray. forall n:int. forall i:int. (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (((0 <= i) and (i <  n)) ->
  (c_inverse_pre(f, n, i) <  n))))

axiom c_inverse_preqtspec2 :
  (forall f:(int,int) farray. forall n:int. forall i:int. (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (((0 <= i) and (i <  n)) ->
  ((f[c_inverse_pre(f, n, i)]) = i))))

logic c_inverse : (int,int) farray, int -> (int,int) farray

axiom c_inverseqtdef :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall x:int. ((c_inverse(f, n)[x]) = (if ((0 <= x) and
  (x <  n)) then c_inverse_pre(f, n, x) else x)))))

axiom c_inverseqtspec :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall b:int. (((0 <= b) and (b <  n)) -> (0 <= (c_inverse(f, n)[b]))))))

axiom c_inverseqtspec1 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall b:int. (((0 <= b) and (b <  n)) -> ((c_inverse(f, n)[b]) <  n)))))

axiom c_inverseqtspec2 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall b:int. (((0 <= b) and (b <  n)) -> ((f[(c_inverse(f,
  n)[b])]) = b)))))

axiom c_inverseqtspec3 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) -> p_bijective(c_inverse(f, n), to_fset(0, n), to_fset(0,
  n))))

axiom c_inverseqtspec4 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall b:int. (((0 <= b) and (b <  n)) -> ((c_inverse(f,
  n)[(f[b])]) = b)))))

axiom c_inverseqtspec5 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall b:int. (((0 <= b) and (b <  n)) -> ((c_inverse(f,
  n)[b]) = (inv_func_int(f, n)[b]))))))

axiom unic_inverse_c :
  (forall f:(int,int) farray. forall fqt:(int,int) farray. forall n:int.
  (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  ((forall a:int. (((0 <= a) and (a <  n)) -> ((fqt[(f[a])]) = a))) ->
  (forall b:int. (((0 <= b) and (b <  n)) -> ((fqt[b]) = (c_inverse(f,
  n)[b])))))))

logic c_inv_func_int : (int,int) farray, int -> (int,int) farray

axiom c_inv_func_intqtdef :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) -> (c_inv_func_int(f, n) = c_inverse(f, n))))

axiom c_inv_func_intqtspec :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall b:int. (((0 <= b) and (b <  n)) -> ((c_inv_func_int(f,
  n)[b]) = (inv_func_int(f, n)[b]))))))

axiom c_inv_func_intqtspec1 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) -> p_bijective(c_inv_func_int(f, n), to_fset(0, n),
  to_fset(0, n))))

axiom c_inv_func_intqtspec2 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. (((0 <= a) and (a <  n)) -> (0 <= (c_inv_func_int(f,
  n)[a]))))))

axiom c_inv_func_intqtspec3 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. (((0 <= a) and (a <  n)) -> ((c_inv_func_int(f,
  n)[a]) <  n)))))

axiom c_inv_func_intqtspec4 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. (((0 <= a) and (a <  n)) -> ((f[(c_inv_func_int(f,
  n)[a])]) = a)))))

axiom c_inv_func_intqtspec5 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. (((0 <= a) and (a <  n)) -> ((c_inv_func_int(f,
  n)[(f[a])]) = a)))))

axiom c_inv_func_intqtspec6 :
  (forall f:(int,int) farray. forall n:int. (p_bijective(f, to_fset(0, n),
  to_fset(0, n)) ->
  (forall a:int. forall b:int. (((0 <= a) and (a <  n)) -> (((0 <= b) and
  (b <  n)) -> (((f[a]) = b) -> ((c_inv_func_int(f, n)[b]) = a)))))))

axiom unic_inverse_c_int :
  (forall f:(int,int) farray. forall fqt:(int,int) farray. forall n:int.
  (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  ((forall a:int. (((0 <= a) and (a <  n)) -> ((fqt[(f[a])]) = a))) ->
  (forall b:int. (((0 <= b) and (b <  n)) -> ((c_inv_func_int(f,
  n)[b]) = (fqt[b])))))))

logic qbit_permutes : circuit -> prop

axiom qbit_permutesqtdef :
  (forall c:circuit.
  (forall x:int. ((pre(c) = Phase(x)) -> (not qbit_permutes(c)))))

axiom qbit_permutesqtdef1 :
  (forall c:circuit.
  (forall x:int. ((pre(c) = Rz(x)) -> (not qbit_permutes(c)))))

axiom qbit_permutesqtdef2 :
  (forall c:circuit. ((pre(c) = Hadamard) -> (not qbit_permutes(c))))

axiom qbit_permutesqtdef3 :
  (forall c:circuit. ((pre(c) = Cnot) -> (not qbit_permutes(c))))

axiom qbit_permutesqtdef4 :
  (forall c:circuit. ((pre(c) = Swap) -> qbit_permutes(c)))

axiom qbit_permutesqtdef5 :
  (forall c:circuit. ((pre(c) = Id) -> qbit_permutes(c)))

axiom qbit_permutesqtdef6 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Sequence(x,
  x1)) -> (qbit_permutes(c) -> qbit_permutes(to_qc(x))))))

axiom qbit_permutesqtdef7 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Sequence(x,
  x1)) -> (qbit_permutes(c) -> qbit_permutes(to_qc(x1))))))

axiom qbit_permutesqtdef8 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Sequence(x,
  x1)) -> ((qbit_permutes(to_qc(x)) and qbit_permutes(to_qc(x1))) ->
  qbit_permutes(c)))))

axiom qbit_permutesqtdef9 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Parallel(x,
  x1)) -> (qbit_permutes(c) -> qbit_permutes(to_qc(x))))))

axiom qbit_permutesqtdef10 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Parallel(x,
  x1)) -> (qbit_permutes(c) -> qbit_permutes(to_qc(x1))))))

axiom qbit_permutesqtdef11 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:circuit_pre. ((pre(c) = Parallel(x,
  x1)) -> ((qbit_permutes(to_qc(x)) and qbit_permutes(to_qc(x1))) ->
  qbit_permutes(c)))))

axiom qbit_permutesqtdef12 :
  (forall c:circuit.
  (forall x:circuit_pre. forall x1:int. ((pre(c) = Ancillas(x, x1)) ->
  (not qbit_permutes(c)))))

axiom qbit_permutesqtspec :
  (forall c:circuit. (qbit_permutes(c) -> (size(c) = 0)))

axiom qbit_permutesqtspec1 :
  (forall c:circuit. (qbit_permutes(c) -> (ancillas(c) = 0)))

axiom qbit_permutesqtspec2 :
  (forall c:circuit. (qbit_permutes(c) -> (range(c) = 0)))

axiom qbit_permutesqtspec3 :
  (forall c:circuit. (qbit_permutes(c) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(c, x,
  y) = ang_zero))))

logic qbit_permutation : circuit -> (int,int) farray

logic identity2 : (int,int) farray

axiom identity_def1 : (forall y:int. ((identity2[y]) = y))

axiom qbit_permutationqtdef :
  (forall c:circuit. (qbit_permutes(c) ->
  (forall w:int. ((pre(c) = Phase(w)) -> (qbit_permutation(c) = identity2)))))

axiom qbit_permutationqtdef1 :
  (forall c:circuit. (qbit_permutes(c) ->
  (forall w:int. ((pre(c) = Rz(w)) -> (qbit_permutation(c) = identity2)))))

axiom qbit_permutationqtdef2 :
  (forall c:circuit. (qbit_permutes(c) -> ((pre(c) = Hadamard) ->
  (qbit_permutation(c) = identity2))))

axiom qbit_permutationqtdef3 :
  (forall c:circuit. (qbit_permutes(c) -> ((pre(c) = Cnot) ->
  (qbit_permutation(c) = identity2))))

axiom qbit_permutationqtdef4 :
  (forall c:circuit. (qbit_permutes(c) -> ((pre(c) = Swap) ->
  (forall i:int.
  ((qbit_permutation(c)[i]) = (if (i = 0) then 1 else (if (i = 1) then 0 else i)))))))

axiom qbit_permutationqtdef5 :
  (forall c:circuit. (qbit_permutes(c) -> ((pre(c) = Id) ->
  (qbit_permutation(c) = identity2))))

axiom qbit_permutationqtdef6 :
  (forall c:circuit. (qbit_permutes(c) ->
  (forall d:circuit_pre. forall e:circuit_pre. ((pre(c) = Sequence(d, e)) ->
  (forall i:int.
  ((qbit_permutation(c)[i]) = (qbit_permutation(to_qc(d))[(qbit_permutation(to_qc(e))[i])])))))))

axiom qbit_permutationqtdef7 :
  (forall c:circuit. (qbit_permutes(c) ->
  (forall d:circuit_pre. forall e:circuit_pre. ((pre(c) = Parallel(d, e)) ->
  (forall i:int.
  ((qbit_permutation(c)[i]) = (if (i <  width(to_qc(d))) then (qbit_permutation(to_qc(d))[i]) else ((qbit_permutation(to_qc(e))[(i - width(to_qc(d)))]) + width(to_qc(d))))))))))

axiom qbit_permutationqtdef8 :
  (forall c:circuit. (qbit_permutes(c) ->
  (forall w:circuit_pre. forall w1:int. ((pre(c) = Ancillas(w, w1)) ->
  (qbit_permutation(c) = identity2)))))

axiom qbit_permutationqtspec :
  (forall c:circuit. (qbit_permutes(c) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  width(c))) -> (basis_ket(c, x, y,
  i) = (x[(qbit_permutation(c)[i])])))))))

axiom qbit_permutationqtspec1 :
  (forall c:circuit. (qbit_permutes(c) -> p_bijective(qbit_permutation(c),
  to_fset(0, width(c)), to_fset(0, width(c)))))

axiom in_to_fset_qp :
  (forall c:circuit. forall i:int. (qbit_permutes(c) -> (((0 <= i) and
  (i <  width(c))) -> mem((qbit_permutation(c)[i]), to_fset(0, width(c))))))

axiom bound_qp :
  (forall c:circuit. forall i:int. (qbit_permutes(c) -> (((0 <= i) and
  (i <  width(c))) -> (0 <= (qbit_permutation(c)[i])))))

axiom bound_qp1 :
  (forall c:circuit. forall i:int. (qbit_permutes(c) -> (((0 <= i) and
  (i <  width(c))) -> ((qbit_permutation(c)[i]) <  width(c)))))

logic qbit_permute_sequence : circuit, circuit -> circuit

axiom qbit_permute_sequenceqtdef :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (qbit_permutes(d) -> (qbit_permutes(e) -> (qbit_permute_sequence(d,
  e) = sequence(d, e))))))

axiom qbit_permute_sequenceqtspec :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (qbit_permutes(d) -> (qbit_permutes(e) ->
  qbit_permutes(qbit_permute_sequence(d, e))))))

axiom qbit_permute_sequenceqtspec1 :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (qbit_permutes(d) -> (qbit_permutes(e) ->
  (forall i:int. ((qbit_permutation(qbit_permute_sequence(d,
  e))[i]) = (qbit_permutation(d)[(qbit_permutation(e)[i])])))))))

axiom qbit_permute_sequenceqtspec2 :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (qbit_permutes(d) -> (qbit_permutes(e) -> (width(qbit_permute_sequence(d,
  e)) = width(d))))))

logic qbit_permute_parallel : circuit, circuit -> circuit

axiom qbit_permute_parallelqtdef :
  (forall d:circuit. forall e:circuit. (qbit_permutes(d) ->
  (qbit_permutes(e) -> (qbit_permute_parallel(d, e) = parallel(d, e)))))

axiom qbit_permute_parallelqtspec :
  (forall d:circuit. forall e:circuit. (qbit_permutes(d) ->
  (qbit_permutes(e) -> qbit_permutes(qbit_permute_parallel(d, e)))))

axiom qbit_permute_parallelqtspec1 :
  (forall d:circuit. forall e:circuit. (qbit_permutes(d) ->
  (qbit_permutes(e) ->
  (forall i:int. ((qbit_permutation(qbit_permute_parallel(d,
  e))[i]) = (if (i <  width(d)) then (qbit_permutation(d)[i]) else ((qbit_permutation(e)[(i - width(d))]) + width(d))))))))

axiom qbit_permute_parallelqtspec2 :
  (forall d:circuit. forall e:circuit. (qbit_permutes(d) ->
  (qbit_permutes(e) -> (width(qbit_permute_parallel(d,
  e)) = (width(d) + width(e))))))

logic ids_permute : int -> circuit

axiom ids_permuteqtdef :
  (forall n:int. ((1 <= n) -> ((n = 1) -> (ids_permute(n) = id))))

axiom ids_permuteqtdef1 :
  (forall n:int. ((1 <= n) -> ((not (n = 1)) ->
  (ids_permute(n) = qbit_permute_parallel(ids_permute((n - 1)), id)))))

axiom ids_permuteqtspec :
  (forall n:int. ((1 <= n) -> (ids_permute(n) = ids(n))))

axiom ids_permuteqtspec1 :
  (forall n:int. ((1 <= n) -> (width(ids_permute(n)) = n)))

axiom ids_permuteqtspec2 :
  (forall n:int. ((1 <= n) -> qbit_permutes(ids_permute(n))))

axiom ids_permuteqtspec3 :
  (forall n:int. ((1 <= n) ->
  (forall i:int. ((qbit_permutation(ids_permute(n))[i]) = i))))

logic permute_place : circuit, int, int -> circuit

axiom permute_placeqtspec :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> (qbit_permutes(c) -> (width(permute_place(c, k,
  n)) = n)))))

axiom permute_placeqtspec1 :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> (qbit_permutes(c) ->
  qbit_permutes(permute_place(c, k, n))))))

axiom permute_placeqtspec2 :
  (forall c:circuit. forall k:int. forall n:int. ((0 <= k) ->
  (((width(c) + k) <= n) -> (qbit_permutes(c) ->
  (forall i:int. (((0 <= i) and (i <  n)) ->
  ((qbit_permutation(permute_place(c, k, n))[i]) = (if ((k <= i) and
  (i <  (k + width(c)))) then ((qbit_permutation(c)[(i - k)]) + k) else i))))))))

logic permute_plus_one : int, int -> circuit

axiom permute_plus_oneqtdef :
  (forall k:int. forall n:int. ((0 <= k) -> (((k + 2) <= n) ->
  (permute_plus_one(k, n) = permute_place(swap, k, n)))))

axiom permute_plus_oneqtspec :
  (forall k:int. forall n:int. ((0 <= k) -> (((k + 2) <= n) ->
  (width(permute_plus_one(k, n)) = n))))

axiom permute_plus_oneqtspec1 :
  (forall k:int. forall n:int. ((0 <= k) -> (((k + 2) <= n) ->
  qbit_permutes(permute_plus_one(k, n)))))

axiom permute_plus_oneqtspec2 :
  (forall k:int. forall n:int. ((0 <= k) -> (((k + 2) <= n) ->
  (forall i:int. (((0 <= i) and (i <  n)) ->
  ((qbit_permutation(permute_plus_one(k,
  n))[i]) = (if (i = k) then (k + 1) else (if (i = (k + 1)) then k else i))))))))

logic up_to_image : int, int, int -> circuit

axiom up_to_imageqtdef :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <= fk)) ->
  ((fk <  n) -> ((k = fk) -> (up_to_image(k, fk, n) = ids_permute(n))))))

axiom up_to_imageqtdef1 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <= fk)) ->
  ((fk <  n) -> ((not (k = fk)) -> (up_to_image(k, fk,
  n) = qbit_permute_sequence(up_to_image((k + 1), fk, n), permute_plus_one(k,
  n)))))))

axiom up_to_imageqtspec :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <= fk)) ->
  ((fk <  n) -> (width(up_to_image(k, fk, n)) = n))))

axiom up_to_imageqtspec1 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <= fk)) ->
  ((fk <  n) -> qbit_permutes(up_to_image(k, fk, n)))))

axiom up_to_imageqtspec2 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <= fk)) ->
  ((fk <  n) ->
  (forall i:int. (((0 <= i) and (i <  n)) ->
  ((qbit_permutation(up_to_image(k, fk,
  n))[i]) = (if (i = k) then fk else (if ((k <  i) and
  (i <= fk)) then (i - 1) else i))))))))

logic down_to_image : int, int, int -> circuit

axiom down_to_imageqtdef :
  (forall k:int. forall fk:int. forall n:int. (((0 <= fk) and (fk <= k)) ->
  ((k <  n) -> ((k = fk) -> (down_to_image(k, fk, n) = ids_permute(n))))))

axiom down_to_imageqtdef1 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= fk) and (fk <= k)) ->
  ((k <  n) -> ((not (k = fk)) -> (down_to_image(k, fk,
  n) = qbit_permute_sequence(down_to_image((k - 1), fk, n),
  permute_plus_one((k - 1), n)))))))

axiom down_to_imageqtspec :
  (forall k:int. forall fk:int. forall n:int. (((0 <= fk) and (fk <= k)) ->
  ((k <  n) -> (width(down_to_image(k, fk, n)) = n))))

axiom down_to_imageqtspec1 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= fk) and (fk <= k)) ->
  ((k <  n) -> qbit_permutes(down_to_image(k, fk, n)))))

axiom down_to_imageqtspec2 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= fk) and (fk <= k)) ->
  ((k <  n) ->
  (forall i:int. (((0 <= i) and (i <  n)) ->
  ((qbit_permutation(down_to_image(k, fk,
  n))[i]) = (if (i = k) then fk else (if ((fk <= i) and
  (i <= k)) then (i + 1) else i))))))))

logic permute_up : int, int, int -> circuit

axiom permute_upqtdef :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and ((k <= fk) and
  (fk <  n))) -> ((fk <  n) -> ((k = fk) -> (permute_up(k, fk,
  n) = ids_permute(n))))))

axiom permute_upqtdef1 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and ((k <= fk) and
  (fk <  n))) -> ((fk <  n) -> ((not (k = fk)) -> (permute_up(k, fk,
  n) = qbit_permute_sequence(down_to_image((fk - 1), k, n), up_to_image(k,
  fk, n)))))))

axiom permute_upqtspec :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and ((k <= fk) and
  (fk <  n))) -> ((fk <  n) -> (width(permute_up(k, fk, n)) = n))))

axiom permute_upqtspec1 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and ((k <= fk) and
  (fk <  n))) -> ((fk <  n) -> qbit_permutes(permute_up(k, fk, n)))))

axiom permute_upqtspec2 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and ((k <= fk) and
  (fk <  n))) -> ((fk <  n) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((qbit_permutation(permute_up(k,
  fk, n))[i]) = (if (i = k) then fk else (if (i = fk) then k else i))))))))

logic permute_atom : int, int, int -> circuit

axiom permute_atomqtdef :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (((0 <= fk) and (fk <  n)) -> ((k <= fk) -> (permute_atom(k, fk,
  n) = permute_up(k, fk, n))))))

axiom permute_atomqtdef1 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (((0 <= fk) and (fk <  n)) -> ((not (k <= fk)) -> (permute_atom(k, fk,
  n) = permute_up(fk, k, n))))))

axiom permute_atomqtspec :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (((0 <= fk) and (fk <  n)) -> (width(permute_atom(k, fk, n)) = n))))

axiom permute_atomqtspec1 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (((0 <= fk) and (fk <  n)) -> qbit_permutes(permute_atom(k, fk, n)))))

axiom permute_atomqtspec2 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (((0 <= fk) and (fk <  n)) -> ((qbit_permutation(permute_atom(k, fk,
  n))[k]) = fk))))

axiom permute_atomqtspec3 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (((0 <= fk) and (fk <  n)) -> ((qbit_permutation(permute_atom(k, fk,
  n))[fk]) = k))))

axiom permute_atomqtspec4 :
  (forall k:int. forall fk:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (((0 <= fk) and (fk <  n)) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((not (i = k)) ->
  ((not (i = fk)) -> ((qbit_permutation(permute_atom(k, fk, n))[i]) = i))))))))

logic permutation_circuit_pre : int, int, (int,int) farray -> circuit

axiom permutation_circuit_preqtdef :
  (forall k:int. forall n:int. forall f:(int,int) farray. ((0 <  n) ->
  (p_bijective(f, to_fset(0, n), to_fset(0, n)) -> (((0 <= k) and
  (k <  n)) -> ((k = (n - 1)) -> (permutation_circuit_pre(k, n,
  f) = permute_atom((c_inv_func_int(f, n)[(n - 1)]), (n - 1), n)))))))

axiom permutation_circuit_preqtdef1 :
  (forall k:int. forall n:int. forall f:(int,int) farray. ((0 <  n) ->
  (p_bijective(f, to_fset(0, n), to_fset(0, n)) -> (((0 <= k) and
  (k <  n)) -> ((not (k = (n - 1))) -> (let o =
  permutation_circuit_pre((k + 1), n, f) : circuit in
  (permutation_circuit_pre(k, n, f) = qbit_permute_sequence(permute_atom(k,
  (qbit_permutation(o)[(c_inv_func_int(f, n)[k])]), n), o))))))))

axiom permutation_circuit_preqtspec :
  (forall k:int. forall n:int. forall f:(int,int) farray. ((0 <  n) ->
  (p_bijective(f, to_fset(0, n), to_fset(0, n)) -> (((0 <= k) and
  (k <  n)) -> (width(permutation_circuit_pre(k, n, f)) = n)))))

axiom permutation_circuit_preqtspec1 :
  (forall k:int. forall n:int. forall f:(int,int) farray. ((0 <  n) ->
  (p_bijective(f, to_fset(0, n), to_fset(0, n)) -> (((0 <= k) and
  (k <  n)) -> qbit_permutes(permutation_circuit_pre(k, n, f))))))

axiom permutation_circuit_preqtspec2 :
  (forall k:int. forall n:int. forall f:(int,int) farray. ((0 <  n) ->
  (p_bijective(f, to_fset(0, n), to_fset(0, n)) -> (((0 <= k) and
  (k <  n)) ->
  (forall i:int. (((k <= i) and (i <  n)) ->
  ((qbit_permutation(permutation_circuit_pre(k, n, f))[(c_inv_func_int(f,
  n)[i])]) = i)))))))

axiom permutation_circuit_preqtspec3 :
  (forall k:int. forall n:int. forall f:(int,int) farray. ((0 <  n) ->
  (p_bijective(f, to_fset(0, n), to_fset(0, n)) -> (((0 <= k) and
  (k <  n)) ->
  (forall i:int. (((0 <= i) and (i <  k)) ->
  (0 <= (qbit_permutation(permutation_circuit_pre(k, n,
  f))[(c_inv_func_int(f, n)[i])]))))))))

axiom permutation_circuit_preqtspec4 :
  (forall k:int. forall n:int. forall f:(int,int) farray. ((0 <  n) ->
  (p_bijective(f, to_fset(0, n), to_fset(0, n)) -> (((0 <= k) and
  (k <  n)) ->
  (forall i:int. (((0 <= i) and (i <  k)) ->
  ((qbit_permutation(permutation_circuit_pre(k, n, f))[(c_inv_func_int(f,
  n)[i])]) <  k)))))))

logic permutation_circuit : int, (int,int) farray -> circuit

axiom permutation_circuitqtdef :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (permutation_circuit(n,
  f) = permutation_circuit_pre(0, n, f)))))

logic fc576 : (int,int) farray, bitvec -> (int,int) farray

axiom fcqtdef579 :
  (forall f:(int,int) farray. forall x:bitvec. forall i:int. ((fc576(f,
  x)[i]) = (value(x)[(f[i])])))

axiom permutation_circuitqtspec :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (width(permutation_circuit(n, f)) = n))))

axiom permutation_circuitqtspec1 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> qbit_permutes(permutation_circuit(n,
  f)))))

axiom permutation_circuitqtspec2 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) ->
  (forall i:int. (((0 <= i) and (i <  n)) ->
  ((qbit_permutation(permutation_circuit(n, f))[i]) = (f[i])))))))

axiom permutation_circuitqtspec3 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) ->
  (forall i:int. (((0 <= i) and (i <  n)) ->
  ((qbit_permutation(permutation_circuit(n, f))[(c_inv_func_int(f,
  n)[i])]) = i))))))

axiom permutation_circuitqtspec4 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem(permutation_circuit(n, f),
  bv_to_ket(x)) = bv_to_ket(make_bv(fc576(f, x), n))))))))

axiom permutation_circuitqtspec5 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  n)) -> (basis_ket(permutation_circuit(n, f), x, y,
  i) = (x[(f[i])])))))))

axiom permutation_circuitqtspec6 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(permutation_circuit(n, f), x, y) = ang_zero)))))

axiom permutation_circuitqtspec7 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (width(permutation_circuit(n, f)) = n))))

axiom permutation_circuitqtspec8 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (range(permutation_circuit(n, f)) = 0))))

logic with_permutation : circuit, (int,int) farray -> circuit

logic fc577 : (int,int) farray, (int,int) farray -> (int,int) farray

logic fc578 : (int,int) farray, (int,int) farray -> (int,int) farray

logic fc579 : circuit, (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef580 :
  (forall f:(int,int) farray. forall x:(int,int) farray. forall i:int.
  ((fc577(f, x)[i]) = (x[(f[i])])))

axiom fcqtdef581 :
  (forall f:(int,int) farray. forall x:(int,int) farray. forall i:int.
  ((fc578(f, x)[i]) = (x[(f[i])])))

axiom fcqtdef582 :
  (forall c:circuit. forall f:(int,int) farray. forall x:(int,int) farray.
  forall i:int. ((fc579(c, f, x)[i]) = (x[(c_inv_func_int(f,
  width(c))[i])])))

axiom with_permutationqtspec :
  (forall c:circuit. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width(c)), to_fset(0, width(c))) -> (size(with_permutation(c,
  f)) = size(c))))

axiom with_permutationqtspec1 :
  (forall c:circuit. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width(c)), to_fset(0, width(c))) -> (ancillas(with_permutation(c,
  f)) = ancillas(c))))

axiom with_permutationqtspec2 :
  (forall c:circuit. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width(c)), to_fset(0, width(c))) -> (width(with_permutation(c,
  f)) = width(c))))

axiom with_permutationqtspec3 :
  (forall c:circuit. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width(c)), to_fset(0, width(c))) -> (range(with_permutation(c,
  f)) = range(c))))

axiom with_permutationqtspec4 :
  (forall c:circuit. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width(c)), to_fset(0, width(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(with_permutation(c, f), x, y) = ang_ind(c, fc577(f, x), y)))))

axiom with_permutationqtspec5 :
  (forall c:circuit. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width(c)), to_fset(0, width(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  width(c))) ->
  (basis_ket(with_permutation(c, f), x, y, i) = basis_ket(c, fc578(f, x), y,
  (c_inv_func_int(f, width(c))[i]))))))))

axiom with_permutationqtspec6 :
  (forall c:circuit. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width(c)), to_fset(0, width(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  width(c))) ->
  (basis_ket(with_permutation(c, f), fc579(c, f, x), y, i) = basis_ket(c, x,
  y, (c_inv_func_int(f, width(c))[i]))))))))

axiom with_permutationqtspec7 :
  (forall c:circuit. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width(c)), to_fset(0, width(c))) -> (with_permutation(c,
  f) = sequence(sequence(permutation_circuit(width(c), f), c),
  permutation_circuit(width(c), c_inv_func_int(f, width(c)))))))

logic c_swap_int : int, int, int -> (int,int) farray

axiom c_swap_intqtdef :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall i:int. ((c_swap_int(t1, t2,
  n)[i]) = (if (i = t1) then t2 else (if (i = t2) then t1 else i)))))))

axiom c_swap_intqtspec :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall a:int. ((a = t1) -> ((c_swap_int(t1, t2, n)[a]) = t2))))))

axiom c_swap_intqtspec1 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall a:int. ((a = t2) -> ((c_swap_int(t1, t2, n)[a]) = t1))))))

axiom c_swap_intqtspec2 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall a:int. ((not (a = t1)) -> ((not (a = t2)) -> ((c_swap_int(t1, t2,
  n)[a]) = a)))))))

axiom c_swap_intqtspec3 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> p_bijective(c_swap_int(t1, t2, n), to_fset(0,
  n), to_fset(0, n)))))

axiom c_swap_intqtspec4 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((c_inv_func_int(c_swap_int(t1,
  t2, n), n)[i]) = (c_swap_int(t1, t2, n)[i])))))))

logic with_int_swap : circuit, int, int -> circuit

axiom with_int_swapqtdef :
  (forall c:circuit. forall t1:int. forall t2:int. (((0 <= t1) and
  (t1 <  width(c))) -> (((0 <= t2) and (t2 <  width(c))) -> (with_int_swap(c,
  t1, t2) = with_permutation(c, c_swap_int(t1, t2, width(c)))))))

logic fc580 : int, int, (int,int) farray -> (int,int) farray

logic fc581 : int, int, (int,int) farray -> (int,int) farray

logic fc582 : int, int, (int,int) farray -> (int,int) farray

logic fc583 : int, int, (int,int) farray -> (int,int) farray

axiom fcqtdef583 :
  (forall t1:int. forall t2:int. forall x:(int,int) farray. forall i:int.
  ((fc580(t1, t2,
  x)[i]) = (x[(if (i = t1) then t2 else (if (i = t2) then t1 else i))])))

axiom fcqtdef584 :
  (forall t1:int. forall t2:int. forall x:(int,int) farray. forall i:int.
  ((fc581(t1, t2,
  x)[i]) = (x[(if (i = t1) then t2 else (if (i = t2) then t1 else i))])))

axiom fcqtdef585 :
  (forall t1:int. forall t2:int. forall x:(int,int) farray. forall i:int.
  ((fc582(t1, t2,
  x)[i]) = (x[(if (i = t1) then t2 else (if (i = t2) then t1 else i))])))

axiom fcqtdef586 :
  (forall t1:int. forall t2:int. forall x:(int,int) farray. forall i:int.
  ((fc583(t1, t2,
  x)[i]) = (x[(if (i = t1) then t2 else (if (i = t2) then t1 else i))])))

axiom with_int_swapqtspec :
  (forall c:circuit. forall t1:int. forall t2:int. (((0 <= t1) and
  (t1 <  width(c))) -> (((0 <= t2) and (t2 <  width(c))) ->
  (size(with_int_swap(c, t1, t2)) = size(c)))))

axiom with_int_swapqtspec1 :
  (forall c:circuit. forall t1:int. forall t2:int. (((0 <= t1) and
  (t1 <  width(c))) -> (((0 <= t2) and (t2 <  width(c))) ->
  (ancillas(with_int_swap(c, t1, t2)) = ancillas(c)))))

axiom with_int_swapqtspec2 :
  (forall c:circuit. forall t1:int. forall t2:int. (((0 <= t1) and
  (t1 <  width(c))) -> (((0 <= t2) and (t2 <  width(c))) ->
  (width(with_int_swap(c, t1, t2)) = width(c)))))

axiom with_int_swapqtspec3 :
  (forall c:circuit. forall t1:int. forall t2:int. (((0 <= t1) and
  (t1 <  width(c))) -> (((0 <= t2) and (t2 <  width(c))) ->
  (range(with_int_swap(c, t1, t2)) = range(c)))))

axiom with_int_swapqtspec4 :
  (forall c:circuit. forall t1:int. forall t2:int. (((0 <= t1) and
  (t1 <  width(c))) -> (((0 <= t2) and (t2 <  width(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(with_int_swap(c, t1, t2), x, y) = ang_ind(c, fc580(t1, t2, x),
  y))))))

axiom with_int_swapqtspec5 :
  (forall c:circuit. forall t1:int. forall t2:int. (((0 <= t1) and
  (t1 <  width(c))) -> (((0 <= t2) and (t2 <  width(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t1) -> (basis_ket(with_int_swap(c, t1, t2), x, y,
  i) = basis_ket(c, fc581(t1, t2, x), y, t2))))))))

axiom with_int_swapqtspec6 :
  (forall c:circuit. forall t1:int. forall t2:int. (((0 <= t1) and
  (t1 <  width(c))) -> (((0 <= t2) and (t2 <  width(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t2) -> (basis_ket(with_int_swap(c, t1, t2), x, y,
  i) = basis_ket(c, fc582(t1, t2, x), y, t1))))))))

axiom with_int_swapqtspec7 :
  (forall c:circuit. forall t1:int. forall t2:int. (((0 <= t1) and
  (t1 <  width(c))) -> (((0 <= t2) and (t2 <  width(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  width(c))) -> ((not (i = t1)) ->
  ((not (i = t2)) -> (basis_ket(with_int_swap(c, t1, t2), x, y,
  i) = basis_ket(c, fc583(t1, t2, x), y, i))))))))))

axiom permutation_circuit_equiv :
  (forall n:int. forall f:(int,int) farray. forall fqt:(int,int) farray.
  ((0 <  n) -> (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  ((forall x:int. (((0 <= x) and (x <  n)) -> ((f[x]) = (fqt[x])))) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) ->
  (path_sem(permutation_circuit(n, f), x) = path_sem(permutation_circuit(n,
  fqt), x))))))))

logic fc584 : (int,int) farray, bitvec -> (int,int) farray

logic fc585 : (int,int) farray, bitvec -> (int,int) farray

axiom fcqtdef587 :
  (forall f:(int,int) farray. forall x:bitvec. forall i:int. ((fc584(f,
  x)[i]) = (value(x)[(f[i])])))

axiom fcqtdef588 :
  (forall f:(int,int) farray. forall y:bitvec. forall i:int. ((fc585(f,
  y)[i]) = (value(y)[(f[i])])))

axiom with_permutation_get_ket :
  (forall c:circuit. forall f:(int,int) farray. forall x:bitvec.
  forall y:bitvec. ((length(x) = width(c)) -> ((length(y) = width(c)) ->
  (p_bijective(f, to_fset(0, width(c)), to_fset(0, width(c))) ->
  (get(path_sem(with_permutation(c, f), bv_to_ket(x)), bv_to_int(y),
  0) = get(path_sem(c, bv_to_ket(make_bv(fc584(f, x), width(c)))),
  bv_to_int(make_bv(fc585(f, y), width(c))), 0))))))

logic fc586 : (int,int) farray, complex matrix -> (int,int) farray

logic fc587 : circuit, (int,int) farray, int -> (int,int) farray

axiom fcqtdef589 :
  (forall f:(int,int) farray. forall x:complex matrix. forall j:int.
  ((fc586(f, x)[j]) = (value(ket_to_bv(x))[(f[j])])))

axiom fcqtdef590 :
  (forall c:circuit. forall f:(int,int) farray. forall i:int. forall j:int.
  ((fc587(c, f, i)[j]) = (value(int_to_bv(i, width(c)))[(f[j])])))

axiom with_permutation_get_ket_ :
  (forall c:circuit. forall f:(int,int) farray. forall x:complex matrix.
  forall i:int. (is_a_ket_l(x, width(c)) -> (is_a_ket_basis_elt(x) ->
  (((0 <= i) and (i <  power(2, width(c)))) -> (p_bijective(f, to_fset(0,
  width(c)), to_fset(0, width(c))) -> (get(path_sem(with_permutation(c, f),
  x), i, 0) = get(path_sem(c, bv_to_ket(make_bv(fc586(f, x), width(c)))),
  bv_to_int(make_bv(fc587(c, f, i), width(c))), 0)))))))

logic fc588 : int, int -> (int,int) farray

axiom fcqtdef591 :
  (forall k:int. forall n:int. forall i:int. ((fc588(k,
  n)[i]) = (if (i <  k) then ((i + n) - k) else (i - k))))

axiom with_permutation_kronecker :
  (forall c:circuit. forall im1:complex matrix. forall im_d:complex matrix.
  forall ant:complex matrix. forall ant_d:complex matrix. forall k:int.
  forall n:int. ((width(c) = n) -> (((0 <= k) and (k <  n)) ->
  (is_a_ket_l(im1, k) -> (is_a_ket_l(im_d, (n - k)) -> (is_a_ket_l(ant, k) ->
  (is_a_ket_l(ant_d, (n - k)) -> (is_a_ket_basis_elt(ant) ->
  (is_a_ket_basis_elt(ant_d) -> ((path_sem(c, kronecker(ant,
  ant_d)) = kronecker(im1, im_d)) -> (path_sem(with_permutation(c, fc588(k,
  n)), kronecker(ant_d, ant)) = kronecker(im_d, im1))))))))))))

logic fc589 : int, int -> (int,int) farray

axiom fcqtdef592 :
  (forall k:int. forall n:int. forall i:int. ((fc589(k,
  n)[i]) = (if (i <  k) then ((i + n) - k) else (i - k))))

axiom with_permutation_kronecker_gen :
  (forall c:circuit. forall k:int. forall n:int. ((width(c) = n) ->
  (((0 <= k) and (k <  n)) ->
  (forall im1:complex matrix. forall im_d:complex matrix.
  forall ant:complex matrix. forall ant_d:complex matrix. (is_a_ket_l(ant,
  k) -> (is_a_ket_l(ant_d, (n - k)) -> (is_a_ket_l(im1, k) ->
  (is_a_ket_l(im_d, (n - k)) -> (is_a_ket_basis_elt(ant) ->
  (is_a_ket_basis_elt(ant_d) -> ((path_sem(c, kronecker(ant,
  ant_d)) = kronecker(im1, im_d)) -> (path_sem(with_permutation(c, fc589(k,
  n)), kronecker(ant_d, ant)) = kronecker(im_d, im1)))))))))))))

logic fc590 : int, int, int -> (int,int) farray

axiom fcqtdef593 :
  (forall n1:int. forall n2:int. forall n3:int. forall j:int. ((fc590(n1, n2,
  n3)[j]) = (if (j <  n1) then j else (if (j <  (n1 + n3)) then (j + n2) else (j - n3)))))

axiom permutation_three_blocks :
  (forall n1:int. forall n2:int. forall n3:int. forall n:int.
  forall x:bitvec. forall y:bitvec. forall z:bitvec. ((length(x) = n1) ->
  ((length(y) = n2) -> ((length(z) = n3) -> ((0 <= n1) -> ((0 <= n2) ->
  ((0 <= n3) -> ((0 <  n) -> ((n = ((n1 + n2) + n3)) ->
  (path_sem(permutation_circuit(n, fc590(n1, n2, n3)),
  kronecker(kronecker(bv_to_ket(x), bv_to_ket(y)),
  bv_to_ket(z))) = kronecker(kronecker(bv_to_ket(x), bv_to_ket(z)),
  bv_to_ket(y))))))))))))

logic insert_qbits : circuit, int, int, int -> circuit

logic result67 : int, int, int -> (int,int) farray

axiom resultqtdef74 :
  (forall k:int. forall n:int. forall i:int. forall j:int. ((result67(k, n,
  i)[j]) = (if (j <  k) then j else (if (j <  n) then (j + i) else ((j - n) + k)))))

axiom insert_qbitsqtdef :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (insert_qbits(c, k, n, i) = with_permutation(parallel(c, ids(i)),
  result67(k, n, i)))))))

logic fc591 : int, int, int, (int,int) farray -> (int,int) farray

logic fc592 : int, int, int, (int,int) farray -> (int,int) farray

logic fc593 : int, int, int, (int,int) farray -> (int,int) farray

axiom fcqtdef594 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall j:int. ((fc591(k, n, i,
  x)[j]) = (x[(if (j <  k) then j else (if (j <  n) then (j + i) else ((j - n) + k)))])))

axiom fcqtdef595 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall ii:int. ((fc592(k, n, i,
  x)[ii]) = (x[(if (ii <  k) then ii else (if (ii <  n) then (ii + i) else ((ii - n) + k)))])))

axiom fcqtdef596 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall ii:int. ((fc593(k, n, i,
  x)[ii]) = (x[(if (ii <  k) then ii else (if (ii <  n) then (ii + i) else ((ii - n) + k)))])))

axiom insert_qbitsqtspec :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (ancillas(insert_qbits(c, k, n, i)) = ancillas(c))))))

axiom insert_qbitsqtspec1 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (width(insert_qbits(c, k, n, i)) = (n + i))))))

axiom insert_qbitsqtspec2 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (size(insert_qbits(c, k, n, i)) = size(c))))))

axiom insert_qbitsqtspec3 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (range(insert_qbits(c, k, n, i)) = range(c))))))

axiom insert_qbitsqtspec4 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(insert_qbits(c, k, n, i), x, y) = ang_ind(c, fc591(k, n, i, x),
  y)))))))

axiom insert_qbitsqtspec5 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. (((0 <= j) and (j <  k)) -> (basis_ket(insert_qbits(c, k, n,
  i), x, y, j) = basis_ket(c, fc592(k, n, i, x), y, j)))))))))

axiom insert_qbitsqtspec6 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. ((((k + i) <= j) and (j <  (n + i))) ->
  (basis_ket(insert_qbits(c, k, n, i), x, y, j) = basis_ket(c, fc593(k, n, i,
  x), y, (j - i))))))))))

axiom insert_qbitsqtspec7 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. (((k <= j) and (j <  (k + i))) -> (basis_ket(insert_qbits(c,
  k, n, i), x, y, j) = (x[j])))))))))

logic insert_qbits_gen : circuit, int, int, int -> circuit

axiom insert_qbits_genqtdef :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) -> ((0 <  i) ->
  (insert_qbits_gen(c, k, n, i) = insert_qbits(c, k, n, i)))))))

axiom insert_qbits_genqtdef1 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  ((not (0 <  i)) -> (insert_qbits_gen(c, k, n, i) = c))))))

logic fc594 : int, int, int, (int,int) farray -> (int,int) farray

logic fc595 : int, int, int, (int,int) farray -> (int,int) farray

logic fc596 : int, int, int, (int,int) farray -> (int,int) farray

axiom fcqtdef597 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall j:int. ((fc594(k, n, i,
  x)[j]) = (x[(if (j <  k) then j else (if (j <  n) then (j + i) else ((j - n) + k)))])))

axiom fcqtdef598 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall ii:int. ((fc595(k, n, i,
  x)[ii]) = (x[(if (ii <  k) then ii else (if (ii <  n) then (ii + i) else ((ii - n) + k)))])))

axiom fcqtdef599 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall ii:int. ((fc596(k, n, i,
  x)[ii]) = (x[(if (ii <  k) then ii else (if (ii <  n) then (ii + i) else ((ii - n) + k)))])))

axiom insert_qbits_genqtspec :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (ancillas(insert_qbits_gen(c, k, n, i)) = ancillas(c))))))

axiom insert_qbits_genqtspec1 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (width(insert_qbits_gen(c, k, n, i)) = (n + i))))))

axiom insert_qbits_genqtspec2 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (size(insert_qbits_gen(c, k, n, i)) = size(c))))))

axiom insert_qbits_genqtspec3 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (range(insert_qbits_gen(c, k, n, i)) = range(c))))))

axiom insert_qbits_genqtspec4 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(insert_qbits_gen(c, k, n, i), x, y) = ang_ind(c, fc594(k, n, i,
  x), y)))))))

axiom insert_qbits_genqtspec5 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. (((0 <= j) and (j <  k)) -> (basis_ket(insert_qbits_gen(c,
  k, n, i), x, y, j) = basis_ket(c, fc595(k, n, i, x), y, j)))))))))

axiom insert_qbits_genqtspec6 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. ((((k + i) <= j) and (j <  (n + i))) ->
  (basis_ket(insert_qbits_gen(c, k, n, i), x, y, j) = basis_ket(c, fc596(k,
  n, i, x), y, (j - i))))))))))

axiom insert_qbits_genqtspec7 :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. (((k <= j) and (j <  (k + i))) ->
  (basis_ket(insert_qbits_gen(c, k, n, i), x, y, j) = (x[j])))))))))

axiom insert_qbits_path_sem :
  (forall c:circuit. forall k:int. forall n:int. forall i:int.
  forall x:bitvec. forall im1:complex matrix. forall im_d:complex matrix.
  ((width(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  ((length(x) = (n + i)) -> (is_a_ket_l(im1, k) -> (is_a_ket_l(im_d,
  (n - k)) -> ((path_sem(c, bv_to_ket(concat(hpart(x, k), tpart(x,
  (k + i))))) = kronecker(im1, im_d)) -> (path_sem(insert_qbits(c, k, n, i),
  bv_to_ket(x)) = kronecker(im1, kronecker(bv_to_ket(htpart(x, k, i)),
  im_d)))))))))))

axiom cos_add :
  (forall x:complex. forall xqt:complex. (real_(x) -> (real_(xqt) ->
  (cos(infix_pldt(x, xqt)) = infix_mndt(infix_asdt(cos(x), cos(xqt)),
  infix_asdt(sin(x), sin(xqt)))))))

axiom sin_add :
  (forall x:complex. forall xqt:complex. (real_(x) -> (real_(xqt) ->
  (sin(infix_pldt(x, xqt)) = infix_pldt(infix_asdt(sin(x), cos(xqt)),
  infix_asdt(cos(x), sin(xqt)))))))

axiom cos_ang_add :
  (forall theta:angle. forall thetaqt:angle. (cos_ang(ang_add(theta,
  thetaqt)) = infix_mndt(infix_asdt(cos_ang(theta), cos_ang(thetaqt)),
  infix_asdt(sin_ang(theta), sin_ang(thetaqt)))))

axiom sin_ang_add :
  (forall theta:angle. forall thetaqt:angle. (sin_ang(ang_add(theta,
  thetaqt)) = infix_pldt(infix_asdt(sin_ang(theta), cos_ang(thetaqt)),
  infix_asdt(cos_ang(theta), sin_ang(thetaqt)))))

axiom cos_ang_add_rev :
  (forall theta:angle. forall thetaqt:angle.
  (infix_mndt(infix_asdt(cos_ang(theta), cos_ang(thetaqt)),
  infix_asdt(sin_ang(theta), sin_ang(thetaqt))) = cos_ang(ang_add(theta,
  thetaqt))))

axiom sin_ang_add_rev :
  (forall theta:angle. forall thetaqt:angle.
  (infix_pldt(infix_asdt(sin_ang(theta), cos_ang(thetaqt)),
  infix_asdt(cos_ang(theta), sin_ang(thetaqt))) = sin_ang(ang_add(theta,
  thetaqt))))

axiom sin_ang_add_rev_rev :
  (forall theta:angle. forall thetaqt:angle.
  (infix_pldt(infix_asdt(cos_ang(theta), sin_ang(thetaqt)),
  infix_asdt(sin_ang(theta), cos_ang(thetaqt))) = sin_ang(ang_add(theta,
  thetaqt))))

axiom sin_ang_inv :
  (forall theta:angle.
  (sin_ang(ang_inv(theta)) = prefix_mndt(sin_ang(theta))))

axiom cos_ang_inv :
  (forall theta:angle. (cos_ang(ang_inv(theta)) = cos_ang(theta)))

axiom sin_ang_inv_int :
  (forall k:int. forall n:int. (sin_ang(infix_sldtsl((-k),
  n)) = prefix_mndt(sin_ang(infix_sldtsl(k, n)))))

axiom cos_ang_inv_int : true

axiom sin_ang_zero : (sin_ang(infix_sldtsl(1, 0)) = c_zero)

axiom sin_ang_one : (sin_ang(infix_sldtsl(1, 1)) = c_zero)

axiom sin_ang_two : (sin_ang(infix_sldtsl(1, 2)) = c_one)

axiom sin_ang_three : (sin_ang(infix_sldtsl(1, 3)) = pow_inv_sqrt_2(1))

axiom cos_ang_zero : (cos_ang(infix_sldtsl(1, 0)) = c_one)

axiom cos_ang_one : (cos_ang(infix_sldtsl(1, 1)) = prefix_mndt(c_one))

axiom cos_ang_two : (cos_ang(infix_sldtsl(1, 2)) = c_zero)

axiom cos_ang_three : (cos_ang(infix_sldtsl(1, 3)) = pow_inv_sqrt_2(1))

axiom cos_two_x :
  (forall x:complex. (real_(x) -> (cos(infix_asdt(infix_pldt(c_one, c_one),
  x)) = infix_mndt(cpower(cos(x), 2), cpower(sin(x), 2)))))

axiom sin_two_x :
  (forall x:complex. forall xqt:complex. (real_(x) -> (real_(xqt) ->
  (sin(infix_asdt(infix_pldt(c_one, c_one),
  x)) = infix_asdt(infix_asdt(infix_pldt(c_one, c_one), sin(x)), cos(x))))))

axiom cos_minus :
  (forall x:complex. (real_(x) -> (cos(prefix_mndt(x)) = cos(x))))

axiom sin_minus :
  (forall x:complex. (real_(x) ->
  (sin(prefix_mndt(x)) = prefix_mndt(sin(x)))))

axiom symetries_vert :
  (forall x:complex. (real_(x) -> (sin(infix_pldt(infix_sldt(pi,
  infix_pldt(c_one, c_one)), x)) = sin(infix_mndt(infix_sldt(pi,
  infix_pldt(c_one, c_one)), x)))))

axiom symetries_vert1 :
  (forall x:complex. (real_(x) -> (cos(infix_pldt(infix_sldt(pi,
  infix_pldt(c_one, c_one)), x)) = prefix_mndt(cos(infix_mndt(infix_sldt(pi,
  infix_pldt(c_one, c_one)), x))))))

axiom pi_minus :
  (forall x:complex. (real_(x) -> (sin(infix_mndt(pi, x)) = sin(x))))

axiom pi_minus1 :
  (forall x:complex. (real_(x) -> (cos(infix_mndt(pi,
  x)) = prefix_mndt(cos(x)))))

axiom sin_plus_pi_pos :
  (forall x:complex. forall k:int. (real_(x) -> ((0 <= k) ->
  ((even(k) = true) -> (sin(infix_asdt(pi, infix_pldt(x,
  i_to_c(k)))) = sin(infix_asdt(pi, x)))))))

axiom sin_plus_pi_pos1 :
  (forall x:complex. forall k:int. (real_(x) -> ((0 <= k) ->
  ((odd(k) = true) -> (sin(infix_asdt(pi, infix_pldt(x,
  i_to_c(k)))) = prefix_mndt(sin(infix_asdt(pi, x))))))))

axiom sin_plus_pi :
  (forall x:complex. forall k:int. (real_(x) -> ((even(k) = true) ->
  (sin(infix_asdt(pi, infix_pldt(x, i_to_c(k)))) = sin(infix_asdt(pi, x))))))

axiom sin_plus_pi1 :
  (forall x:complex. forall k:int. (real_(x) -> ((odd(k) = true) ->
  (sin(infix_asdt(pi, infix_pldt(x,
  i_to_c(k)))) = prefix_mndt(sin(infix_asdt(pi, x)))))))

axiom cos_plus_pi_pos :
  (forall x:complex. forall k:int. (real_(x) -> ((0 <= k) ->
  ((even(k) = true) -> (cos(infix_asdt(pi, infix_pldt(x,
  i_to_c(k)))) = cos(infix_asdt(pi, x)))))))

axiom cos_plus_pi_pos1 :
  (forall x:complex. forall k:int. (real_(x) -> ((0 <= k) ->
  ((odd(k) = true) -> (cos(infix_asdt(pi, infix_pldt(x,
  i_to_c(k)))) = prefix_mndt(cos(infix_asdt(pi, x))))))))

axiom cos_plus_pi :
  (forall x:complex. forall k:int. (real_(x) -> ((even(k) = true) ->
  (cos(infix_asdt(pi, infix_pldt(x, i_to_c(k)))) = cos(infix_asdt(pi, x))))))

axiom cos_plus_pi1 :
  (forall x:complex. forall k:int. (real_(x) -> ((odd(k) = true) ->
  (cos(infix_asdt(pi, infix_pldt(x,
  i_to_c(k)))) = prefix_mndt(cos(infix_asdt(pi, x)))))))

axiom mod_sin_plus_pi :
  (forall x:complex. forall k:int. (real_(x) -> (modulus(sin(infix_asdt(pi,
  infix_pldt(x, i_to_c(k))))) = modulus(sin(infix_asdt(pi, x))))))

axiom mod_cos_plus_pi :
  (forall x:complex. forall k:int. (real_(x) -> (modulus(cos(infix_asdt(pi,
  infix_pldt(x, i_to_c(k))))) = modulus(cos(infix_asdt(pi, x))))))

axiom sin_mod_two_pi :
  (forall x:complex. (real_(x) ->
  (sin(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  x)) = sin(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  dec_part(x))))))

axiom cos_mod_two_pi :
  (forall x:complex. (real_(x) ->
  (cos(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  x)) = cos(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  dec_part(x))))))

axiom square_modulus_c_one_minus :
  (forall phi:complex. (real_(phi) -> (cpower(modulus(infix_mndt(c_one,
  ang_exp(real_to_ang(phi)))), 2) = infix_asdt(i_to_c(4),
  cpower(modulus(sin(infix_asdt(pi, phi))), 2)))))

axiom growing_sine :
  (forall a:complex. forall b:complex. ((infix_lseqdt(c_zero, a) and
  (infix_lsdt(a, b) and infix_lseqdt(b, infix_sldt(c_one, infix_pldt(c_one,
  c_one))))) -> infix_lsdt(sin(infix_asdt(pi, a)), sin(infix_asdt(pi, b)))))

axiom non_null_sine :
  (forall x:complex. ((infix_lsdt(c_zero, x) and infix_lsdt(x, pi)) ->
  infix_lsdt(c_zero, sin(x))))

axiom bounded_by_sine :
  (forall x:complex. (real_(x) -> ((infix_lseqdt(c_zero, modulus(x)) and
  infix_lseqdt(modulus(x), infix_sldt(c_one, infix_pldt(c_one, c_one)))) ->
  infix_lseqdt(modulus(infix_asdt(infix_pldt(c_one, c_one), x)),
  modulus(sin(infix_asdt(pi, x)))))))

axiom bounded_by_sine_one :
  (forall x:complex. forall k:int. ((0 <= k) -> (real_(x) ->
  (infix_lseqdt(modulus(infix_mndt(x, c_one)), infix_sldt(c_one,
  i_to_c(power(2, (k + 1))))) ->
  infix_lseqdt(modulus(infix_asdt(infix_asdt(infix_pldt(c_one, c_one),
  infix_mndt(x, c_one)), i_to_c(power(2, k)))),
  modulus(sin(infix_asdt(infix_asdt(pi, i_to_c(power(2, k))), x))))))))

axiom bounded_sine :
  (forall x:complex. (real_(x) -> infix_lseqdt(modulus(sin(x)), modulus(x))))

axiom non_c_zero_sin :
  (forall x:complex. (real_(x) -> (infix_lsdt(c_zero, dec_part(x)) ->
  (not (sin(infix_asdt(pi, x)) = c_zero)))))

axiom non_c_zero_sin_bounded_mod :
  (forall x:complex. (real_(x) -> ((infix_lsdt(c_zero, modulus(x)) and
  infix_lsdt(modulus(x), c_one)) -> (not (sin(infix_asdt(pi,
  x)) = c_zero)))))

axiom non_ang_zero_bounded_mod :
  (forall x:complex. (real_(x) -> ((infix_lsdt(c_zero, modulus(x)) and
  infix_lsdt(modulus(x), c_one)) -> (not (real_to_ang(x) = ang_zero)))))

axiom non_ang_zero_int_to_ang :
  (forall k:int. forall n:int. ((0 <= n) -> ((not ((k % power(2, n)) = 0)) ->
  (not (infix_sldtsl(k, n) = ang_zero)))))

axiom modulus_ang_exp : (forall a:angle. (modulus(ang_exp(a)) = c_one))

function ket_zero_y(k: int) : complex matrix = path_sem(ry(k), ket(1, 0))

axiom ket_zero_yqtspec :
  (forall k:int. (ket_zero_y(k) = infix_asdtdt(pow_inv_sqrt_2(2),
  add_ket_l(infix_asdtdt(infix_pldt(ang_exp(infix_sldtsl((- 1),
  incr_abs(k))), ang_exp(infix_sldtsl(1, incr_abs(k)))), ket(1, 0)),
  infix_asdtdt(infix_asdt(im, infix_mndt(ang_exp(infix_sldtsl((- 1),
  incr_abs(k))), ang_exp(infix_sldtsl(1, incr_abs(k))))), ket(1, 1)), 1))))

axiom ket_zero_yqtspec1 :
  (forall k:int.
  (ket_zero_y(k) = add_ket_l(infix_asdtdt(cos_ang(infix_sldtsl(1,
  incr_abs(k))), ket(1, 0)), infix_asdtdt(sin_ang(infix_sldtsl(1,
  incr_abs(k))), ket(1, 1)), 1)))

function ket_one_y(k: int) : complex matrix = path_sem(ry(k), ket(1, 1))

axiom ket_one_yqtspec :
  (forall k:int. (ket_one_y(k) = infix_asdtdt(pow_inv_sqrt_2(2),
  add_ket_l(infix_asdtdt(infix_asdt(prefix_mndt(im),
  infix_mndt(ang_exp(infix_sldtsl((- 1), incr_abs(k))),
  ang_exp(infix_sldtsl(1, incr_abs(k))))), ket(1, 0)),
  infix_asdtdt(infix_pldt(ang_exp(infix_sldtsl((- 1), incr_abs(k))),
  ang_exp(infix_sldtsl(1, incr_abs(k)))), ket(1, 1)), 1))))

axiom ket_one_yqtspec1 :
  (forall k:int.
  (ket_one_y(k) = add_ket_l(infix_asdtdt(prefix_mndt(sin_ang(infix_sldtsl(1,
  incr_abs(k)))), ket(1, 0)), infix_asdtdt(cos_ang(infix_sldtsl(1,
  incr_abs(k))), ket(1, 1)), 1)))

function ket_zero_z(k: int) : complex matrix = path_sem(rz_(k), ket(1, 0))

axiom ket_zero_zqtspec :
  (forall k:int. (ket_zero_z(k) = infix_asdtdt(ang_exp(infix_sldtsl((- 1),
  incr_abs(k))), ket(1, 0))))

function ket_one_z(k: int) : complex matrix = path_sem(rz_(k), ket(1, 1))

axiom ket_one_zqtspec :
  (forall k:int. (ket_one_z(k) = infix_asdtdt(ang_exp(infix_sldtsl(1,
  incr_abs(k))), ket(1, 1))))

axiom path_sem_ry_add_zero :
  (forall k:int. (path_sem(ry((-k)), ket_zero_y(k)) = ket(1, 0)))

axiom path_sem_ry_add_one :
  (forall k:int. (path_sem(ry((-k)), ket_one_y(k)) = ket(1, 1)))

axiom path_sem_ry_add :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem(ry((-k)), path_sem(ry(k), x)) = x)))

axiom path_sem_ry_twice_zero :
  (forall k:int. (path_sem(ry(incr_abs(k)),
  ket_zero_y(incr_abs(k))) = ket_zero_y(k)))

axiom path_sem_ry_twice_one :
  (forall k:int. (path_sem(ry(incr_abs(k)),
  ket_one_y(incr_abs(k))) = ket_one_y(k)))

axiom path_sem_ry_twice :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem(ry(incr_abs(k)), path_sem(ry(incr_abs(k)), x)) = path_sem(ry(k),
  x))))

axiom ket_zero_inv_y :
  (forall k:int. (path_sem_xx(ket_zero_y(k)) = ket_one_y((-k))))

axiom ket_one_inv_y :
  (forall k:int. (path_sem_xx(ket_one_y(k)) = ket_zero_y((-k))))

axiom ket_inv_y :
  (forall k:int. forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem_xx(path_sem(ry(k), x)) = path_sem(ry((-k)), path_sem_xx(x)))))

axiom ket_inv_y_rev :
  (forall k:int. forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem(ry((-k)), path_sem_xx(x)) = path_sem_xx(path_sem(ry(k), x)))))

axiom ket_zero_inv_z :
  (forall k:int. (path_sem_xx(ket_zero_z(k)) = ket_one_z((-k))))

axiom ket_one_inv_z :
  (forall k:int. (path_sem_xx(ket_one_z(k)) = ket_zero_z((-k))))

axiom ket_inv_z :
  (forall k:int. forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem_xx(path_sem(rz_(k), x)) = path_sem(rz_((-k)), path_sem_xx(x)))))

axiom ket_inv_z_rev :
  (forall k:int. forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem(rz_((-k)), path_sem_xx(x)) = path_sem_xx(path_sem(rz_(k), x)))))

function contph(k: int) : circuit = parallel(rz(k), id)

axiom contphqtspec : (forall k:int. (width(contph(k)) = 2))

axiom contphqtspec1 : (forall k:int. (range(contph(k)) = 0))

axiom contphqtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  2)) -> (basis_ket(contph(k), x, y, i) = (x[i])))))

axiom contphqtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(contph(k),
  x, y) = infix_sldtsl((x[0]), k))))

axiom path_sem_contph_z :
  (forall k:int. forall bv:bitvec. ((length(bv) = 2) ->
  (((value(bv)[0]) = 0) -> (path_sem(contph(k),
  bv_to_ket(bv)) = bv_to_ket(bv)))))

axiom path_sem_contph_o :
  (forall k:int. forall bv:bitvec. ((length(bv) = 2) ->
  (((value(bv)[0]) = 1) -> (path_sem(contph(k),
  bv_to_ket(bv)) = path_sem(place(phase(k), 1, 2), bv_to_ket(bv))))))

function contrz_pre(k: int) : circuit =
  sequence(sequence(place(rz(incr_abs(k)), 1, 2), cnot),
  place(rz((-incr_abs(k))), 1, 2))

axiom contrz_preqtspec : (forall k:int. (width(contrz_pre(k)) = 2))

axiom contrz_preqtspec1 : (forall k:int. (range(contrz_pre(k)) = 0))

axiom contrz_preqtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  2)) -> (basis_ket(contrz_pre(k), x, y,
  i) = basis_ket(cnot, x, y, i)))))

axiom contrz_preqtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, 2) ->
  (ang_ind(contrz_pre(k), x, y) = phase_inv_((1 - (x[1])),
  infix_sldtsl((x[0]), incr_abs(k)))))))

function contrz_(k: int) : circuit = sequence(contrz_pre(k), cnot)

axiom contrz_qtspec : (forall k:int. (width(contrz_(k)) = 2))

axiom contrz_qtspec1 : (forall k:int. (range(contrz_(k)) = 0))

axiom contrz_qtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  2)) -> (binary_l(x, 2) -> (basis_ket(contrz_(k), x, y,
  i) = (x[i]))))))

axiom contrz_qtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, 2) ->
  (ang_ind(contrz_(k), x, y) = phase_inv_((1 - (x[1])), infix_sldtsl((x[0]),
  incr_abs(k)))))))

function contrz(k: int) : circuit = sequence(contrz_(k), contph(incr_abs(k)))

axiom contrzqtspec : (forall k:int. (width(contrz(k)) = 2))

axiom contrzqtspec1 : (forall k:int. (range(contrz(k)) = 0))

axiom contrzqtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  2)) -> (binary_l(x, 2) -> (basis_ket(contrz(k), x, y,
  i) = (x[i]))))))

axiom contrzqtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, 2) ->
  (ang_ind(contrz(k), x, y) = infix_sldtsl(((x[0]) * (x[1])), k)))))

axiom path_sem_contrz_z :
  (forall k:int. forall bv:bitvec. ((length(bv) = 2) ->
  (((value(bv)[0]) = 0) -> (path_sem(contrz(k),
  bv_to_ket(bv)) = bv_to_ket(bv)))))

axiom path_sem_contrz_o :
  (forall k:int. forall bv:bitvec. ((length(bv) = 2) ->
  (((value(bv)[0]) = 1) -> (path_sem(contrz(k),
  bv_to_ket(bv)) = path_sem(place(rz(k), 1, 2), bv_to_ket(bv))))))

function contrz1_2(k: int) : circuit = parallel(contrz(k), id)

axiom contrz1_2qtspec : (forall k:int. (width(contrz1_2(k)) = 3))

axiom contrz1_2qtspec1 : (forall k:int. (range(contrz1_2(k)) = 0))

axiom contrz1_2qtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  2)) -> (binary_l(x, 2) -> (basis_ket(contrz1_2(k), x,
  y, i) = (x[i]))))))

axiom contrz1_2qtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, 3) ->
  (ang_ind(contrz1_2(k), x, y) = infix_sldtsl(((x[0]) * (x[1])), k)))))

logic swap_1_2_in3 : circuit

axiom swap_1_2_in3qtdef : (width(swap_1_2_in3) = 3)

axiom swap_1_2_in3qtdef1 : (range(swap_1_2_in3) = 0)

axiom swap_1_2_in3qtdef2 :
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  2)) -> (basis_ket(swap_1_2_in3, x, y,
  i) = (x[(if (i = 0) then 1 else (if (i = 1) then 0 else i))]))))

axiom swap_1_2_in3qtdef3 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(swap_1_2_in3, x, y) = infix_sldtsl(0, 1)))

axiom swap_1_2_in3qtdef4 :
  (forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_l(y, 1) -> (is_a_ket_l(z, 1) ->
  (path_sem(swap_1_2_in3, kronecker(kronecker(x, y),
  z)) = kronecker(kronecker(y, x), z))))))

logic swap_2_3_in3 : circuit

axiom swap_2_3_in3qtdef : (width(swap_2_3_in3) = 3)

axiom swap_2_3_in3qtdef1 : (range(swap_2_3_in3) = 0)

axiom swap_2_3_in3qtdef2 :
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  2)) -> (basis_ket(swap_2_3_in3, x, y,
  i) = (x[(if (i = 0) then i else (if (i = 1) then 2 else 1))]))))

axiom swap_2_3_in3qtdef3 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(swap_2_3_in3, x, y) = infix_sldtsl(0, 1)))

axiom swap_2_3_in3qtdef4 :
  (forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_l(y, 1) -> (is_a_ket_l(z, 1) ->
  (path_sem(swap_2_3_in3, kronecker(kronecker(x, y),
  z)) = kronecker(kronecker(x, z), y))))))

function contrz1_3(k: int) : circuit = insert_qbits(contrz(k), 1, 2, 1)

axiom contrz1_3qtspec : (forall k:int. (width(contrz1_3(k)) = 3))

axiom contrz1_3qtspec1 : (forall k:int. (range(contrz1_3(k)) = 0))

axiom contrz1_3qtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  3)) -> (binary_l(x, 3) -> (basis_ket(contrz1_3(k), x,
  y, i) = (x[i]))))))

axiom contrz1_3qtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, 3) ->
  (ang_ind(contrz1_3(k), x, y) = infix_sldtsl(((x[0]) * (x[2])), k)))))

function contrz2_3(k: int) : circuit = parallel(id, contrz(k))

axiom contrz2_3qtspec : (forall k:int. (width(contrz2_3(k)) = 3))

axiom contrz2_3qtspec1 : (forall k:int. (range(contrz2_3(k)) = 0))

axiom contrz2_3qtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  3)) -> (binary_l(x, 3) -> (basis_ket(contrz2_3(k), x,
  y, i) = (x[i]))))))

axiom contrz2_3qtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, 3) ->
  (ang_ind(contrz2_3(k), x, y) = infix_sldtsl(((x[1]) * (x[2])), k)))))

logic contrz_xor_3 : int -> circuit

axiom contrz_xor_3qtspec : (forall k:int. (width(contrz_xor_3(k)) = 3))

axiom contrz_xor_3qtspec1 : (forall k:int. (range(contrz_xor_3(k)) = 0))

axiom contrz_xor_3qtspec2 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  3)) -> (binary_l(x, 3) -> (basis_ket(contrz_xor_3(k),
  x, y, i) = (x[i]))))))

axiom contrz_xor_3qtspec3 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, 3) ->
  (ang_ind(contrz_xor_3(k), x,
  y) = infix_sldtsl(((((x[0]) * (1 - (x[1]))) + ((x[1]) * (1 - (x[0])))) * (x[2])),
  k)))))

axiom path_sem_xx_plus : (path_sem_xx(pps_apply(pps_hadamard, ket(1,
  0))) = pps_apply(pps_hadamard, ket(1, 0)))

axiom path_sem_xx_minus : (path_sem_xx(pps_apply(pps_hadamard, ket(1,
  1))) = infix_asdtdt(prefix_mndt(c_one), pps_apply(pps_hadamard, ket(1,
  1))))

axiom ket_zero_y2 : (ket_zero_y(2) = pps_apply(pps_hadamard, ket(1, 0)))

axiom ket_zero_y21 : (ket_zero_y(2) = path_sem_xx(pps_apply(pps_hadamard,
  ket(1, 0))))

axiom ket_one_y2 : (ket_one_y(2) = infix_asdtdt(prefix_mndt(c_one),
  pps_apply(pps_hadamard, ket(1, 1))))

axiom ket_one_y21 : (ket_one_y(2) = path_sem_xx(pps_apply(pps_hadamard,
  ket(1, 1))))

logic contry_pre_ : int, complex matrix -> circuit

axiom contry_pre_qtdef :
  (forall k:int. forall y:complex matrix. (is_a_ket_l(y, 1) ->
  (contry_pre_(k, y) = sequence(sequence(place(ry((-incr_abs(k))), 1, 2),
  cnot), place(ry(incr_abs(k)), 1, 2)))))

axiom contry_pre_qtspec :
  (forall k:int. forall y:complex matrix. (is_a_ket_l(y, 1) ->
  (path_sem(contry_pre_(k, y), kronecker(ket(1, 0), y)) = kronecker(ket(1,
  0), y))))

axiom contry_pre_qtspec1 :
  (forall k:int. forall y:complex matrix. (is_a_ket_l(y, 1) ->
  (path_sem(contry_pre_(k, y), kronecker(ket(1, 1), y)) = kronecker(ket(1,
  1), path_sem(ry(k), path_sem_xx(y))))))

axiom contry_pre_qtspec2 :
  (forall k:int. forall y:complex matrix. (is_a_ket_l(y, 1) ->
  (width(contry_pre_(k, y)) = 2)))

function contry_pre(k: int) : circuit =
  sequence(sequence(place(ry((-incr_abs(k))), 1, 2), cnot),
  place(ry(incr_abs(k)), 1, 2))

axiom contry_preqtspec :
  (forall k:int.
  (forall y:complex matrix. (is_a_ket_l(y, 1) -> (path_sem(contry_pre(k),
  kronecker(ket(1, 0), y)) = kronecker(ket(1, 0), y)))))

axiom contry_preqtspec1 :
  (forall k:int.
  (forall y:complex matrix. (is_a_ket_l(y, 1) -> (path_sem(contry_pre(k),
  kronecker(ket(1, 1), y)) = kronecker(ket(1, 1), path_sem(ry(k),
  path_sem_xx(y)))))))

axiom contry_preqtspec2 : (forall k:int. (width(contry_pre(k)) = 2))

function contry(k: int) : circuit = sequence(contry_pre(k), cnot)

axiom contryqtspec :
  (forall k:int.
  (forall y:complex matrix. (is_a_ket_l(y, 1) -> (path_sem(contry(k),
  kronecker(ket(1, 0), y)) = kronecker(ket(1, 0), y)))))

axiom contryqtspec1 :
  (forall k:int.
  (forall y:complex matrix. (is_a_ket_l(y, 1) -> (path_sem(contry(k),
  kronecker(ket(1, 1), y)) = kronecker(ket(1, 1), path_sem(ry((-k)), y))))))

axiom contryqtspec2 : (forall k:int. (width(contry(k)) = 2))

logic conth : circuit

axiom conthqtdef : (path_sem(conth, kronecker(ket(1, 0), ket(1,
  0))) = kronecker(ket(1, 0), ket(1, 0)))

axiom conthqtdef1 : (path_sem(conth, kronecker(ket(1, 0), ket(1,
  1))) = kronecker(ket(1, 0), ket(1, 1)))

axiom conthqtdef2 : (path_sem(conth, kronecker(ket(1, 1), ket(1,
  0))) = kronecker(ket(1, 1), pps_apply(pps_hadamard, ket(1, 0))))

axiom conthqtdef3 : (path_sem(conth, kronecker(ket(1, 1), ket(1,
  1))) = kronecker(ket(1, 1), pps_apply(pps_hadamard, ket(1, 1))))

axiom conthqtdef4 : (width(conth) = 2)

axiom conth_z :
  (forall z:complex matrix. (is_a_ket_l(z, 1) -> (path_sem(conth,
  kronecker(ket(1, 0), z)) = kronecker(ket(1, 0), z))))

axiom conth_o :
  (forall z:complex matrix. (is_a_ket_l(z, 1) -> (path_sem(conth,
  kronecker(ket(1, 1), z)) = kronecker(ket(1, 1), path_sem(hadamard, z)))))

logic conth1_3 : circuit

axiom conth1_3qtdef :
  (forall y:complex matrix. forall z:complex matrix. (is_a_ket_l(y, 1) ->
  (is_a_ket_l(z, 1) -> (path_sem(conth1_3, kronecker(kronecker(ket(1, 0), y),
  z)) = kronecker(kronecker(ket(1, 0), y), z)))))

axiom conth1_3qtdef1 :
  (forall y:complex matrix. forall z:complex matrix. (is_a_ket_l(y, 1) ->
  (is_a_ket_l(z, 1) -> (path_sem(conth1_3, kronecker(kronecker(ket(1, 1), y),
  z)) = kronecker(kronecker(ket(1, 1), y), path_sem(hadamard, z))))))

logic ccz : circuit

axiom cczqtdef : (width(ccz) = 3)

axiom cczqtdef1 : (range(ccz) = 0)

axiom cczqtdef2 :
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  3)) -> (binary_l(x, 3) -> (basis_ket(ccz, x, y,
  i) = (x[i])))))

axiom cczqtdef3 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, 3) ->
  (ang_ind(ccz, x, y) = infix_sldtsl((((x[0]) * (x[1])) * (x[2])), 1))))

axiom cczqtdef4 :
  (forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_l(y, 1) -> (is_a_ket_l(z, 1) ->
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (is_a_ket_basis_elt(z) -> (path_sem(ccz, kronecker(kronecker(x, y),
  z)) = kronecker(kronecker(x, y), infix_asdtdt(cpower(prefix_mndt(c_one),
  ((ket_to_int(x) * ket_to_int(y)) * ket_to_int(z))), z))))))))))

axiom ccz_cont_null :
  (forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_l(y, 1) -> (is_a_ket_l(z, 1) ->
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  ((not ((ket_to_int(x) * ket_to_int(y)) = 1)) -> (path_sem(ccz,
  kronecker(kronecker(x, y), z)) = kronecker(kronecker(x, y), z)))))))))

axiom ccz_had_basis :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (((ket_to_int(x) * ket_to_int(y)) = 1) -> (path_sem(ccz,
  kronecker(kronecker(x, y), pps_apply(pps_hadamard, ket(1,
  0)))) = kronecker(kronecker(x, y), pps_apply(pps_hadamard, ket(1,
  1))))))))))

axiom ccz_had_basis1 :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_l(y, 1) -> (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (((ket_to_int(x) * ket_to_int(y)) = 1) -> (path_sem(ccz,
  kronecker(kronecker(x, y), pps_apply(pps_hadamard, ket(1,
  1)))) = kronecker(kronecker(x, y), pps_apply(pps_hadamard, ket(1,
  0))))))))))

logic toffoli : circuit

axiom toffoliqtdef : (width(toffoli) = 3)

axiom toffoliqtdef1 :
  (forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_l(y, 1) -> (is_a_ket_l(z, 1) ->
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (is_a_ket_basis_elt(z) -> (path_sem(toffoli, kronecker(kronecker(x, y),
  z)) = kronecker(kronecker(x, y), ket(1,
  ((ket_to_int(z) + (ket_to_int(x) * ket_to_int(y))) % 2)))))))))))

axiom toffoliqtdef2 :
  (forall bv:bitvec. ((length(bv) = 3) -> (((value(bv)[0]) = 0) ->
  (path_sem(toffoli, bv_to_ket(bv)) = bv_to_ket(bv)))))

axiom toffoliqtdef3 :
  (forall bv:bitvec. ((length(bv) = 3) -> (((value(bv)[0]) = 1) ->
  (path_sem(toffoli, bv_to_ket(bv)) = path_sem(place(cnot, 1, 3),
  bv_to_ket(bv))))))

logic toffoli_cont_1_3 : circuit

axiom toffoli_cont_1_3qtdef : (width(toffoli_cont_1_3) = 3)

axiom toffoli_cont_1_3qtdef1 :
  (forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_l(y, 1) -> (is_a_ket_l(z, 1) ->
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (is_a_ket_basis_elt(z) -> (path_sem(toffoli_cont_1_3,
  kronecker(kronecker(x, y), z)) = kronecker(kronecker(x, ket(1,
  ((ket_to_int(y) + (ket_to_int(x) * ket_to_int(z))) % 2))), z)))))))))

axiom toffoli_cont_1_3_id :
  (forall bv:bitvec. ((length(bv) = 3) -> ((((value(bv)[0]) = 1) ->
  ((value(bv)[2]) = 0)) -> (path_sem(toffoli_cont_1_3,
  bv_to_ket(bv)) = bv_to_ket(bv)))))

logic fredkin : circuit

axiom fredkinqtdef : (width(fredkin) = 3)

axiom fredkinqtdef1 :
  (forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_l(y, 1) -> (is_a_ket_l(z, 1) ->
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (is_a_ket_basis_elt(z) -> (path_sem(fredkin, kronecker(kronecker(x, y),
  z)) = (if (x = ket(1, 0)) then kronecker(kronecker(x, y),
  z) else kronecker(kronecker(x, z), y))))))))))

axiom fredkinqtdef2 :
  (forall bv:bitvec. ((length(bv) = 3) -> (((value(bv)[0]) = 0) ->
  (path_sem(fredkin, bv_to_ket(bv)) = bv_to_ket(bv)))))

axiom fredkinqtdef3 :
  (forall bv:bitvec. ((length(bv) = 3) -> (((value(bv)[0]) = 1) ->
  (path_sem(fredkin, bv_to_ket(bv)) = path_sem(place(swap, 1, 3),
  bv_to_ket(bv))))))

logic notc : circuit

axiom notcqtdef : (range(notc) = 0)

axiom notcqtdef1 : (width(notc) = 2)

axiom notcqtdef2 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, 2) -> ((i = 1) -> (basis_ket(notc, x, y,
  i) = (x[i]))))))

axiom notcqtdef3 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, 2) -> ((i = 0) -> (basis_ket(notc, x, y,
  i) = (((x[0]) * (1 - (x[1]))) + ((x[1]) * (1 - (x[0])))))))))

axiom notcqtdef4 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind(notc, x,
  y) = ang_zero))

logic place_cnot : int, int, int -> circuit

axiom place_cnotqtspec :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) -> (width(place_cnot(c, t,
  n)) = n)))))

axiom place_cnotqtspec1 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) -> (range(place_cnot(c, t,
  n)) = 0)))))

axiom place_cnotqtspec2 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind(place_cnot(c, t, n), x, y) = ang_zero))))))

axiom place_cnotqtspec3 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) -> (binary_l(x, n) ->
  ((not (i = t)) -> (basis_ket(place_cnot(c, t, n), x, y, i) = (x[i])))))))))))

axiom place_cnotqtspec4 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) -> (binary_l(x, n) -> ((i = t) ->
  (basis_ket(place_cnot(c, t, n), x, y,
  i) = (((x[c]) * (1 - (x[t]))) + ((1 - (x[c])) * (x[t])))))))))))))

axiom place_cnotqtspec5 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) ->
  correct_path_sum_(place_cnot(c, t, n), pps_cnot(c, t, n))))))

logic cont_zero : circuit -> circuit

axiom cont_zeroqtspec :
  (forall c:circuit. (width(cont_zero(c)) = (width(c) + 1)))

axiom cont_zeroqtspec1 :
  (forall c:circuit.
  (forall bv:bitvec. ((length(bv) = (width(c) + 1)) ->
  (((value(bv)[0]) = 0) -> (path_sem(cont_zero(c),
  bv_to_ket(bv)) = bv_to_ket(bv))))))

axiom cont_zeroqtspec2 :
  (forall c:circuit.
  (forall bv:bitvec. ((length(bv) = (width(c) + 1)) ->
  (((value(bv)[0]) = 1) -> (path_sem(cont_zero(c),
  bv_to_ket(bv)) = path_sem(place(c, 1, (width(c) + 1)), bv_to_ket(bv)))))))

axiom cont_zeroqtspec3 :
  (forall c:circuit.
  (forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(cont_zero(c), kronecker(ket(1, 0), x)) = kronecker(ket(1, 0),
  x)))))

axiom cont_zeroqtspec4 :
  (forall c:circuit.
  (forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(cont_zero(c), kronecker(ket(1, 1), x)) = kronecker(ket(1, 1),
  path_sem(c, x))))))

axiom cont_zero_path_sem_kron :
  (forall c:circuit. forall x:bitvec. ((length(x) = width(c)) ->
  (path_sem(cont_zero(c), kronecker(ket(1, 0),
  bv_to_ket(x))) = kronecker(ket(1, 0), bv_to_ket(x)))))

axiom cont_zero_path_sem_kron1 :
  (forall c:circuit. forall x:bitvec. ((length(x) = width(c)) ->
  (path_sem(cont_zero(c), kronecker(ket(1, 1),
  bv_to_ket(x))) = kronecker(ket(1, 1), path_sem(c, bv_to_ket(x))))))

axiom cont_zero_sem_kronqtspec :
  (forall c:circuit. (width(cont_zero(c)) = (width(c) + 1)))

axiom cont_zero_sem_kronqtspec1 :
  (forall c:circuit.
  (forall x:complex matrix. forall y:complex matrix. (sem(c, x, y) ->
  sem(cont_zero(c), kronecker(ket(1, 1), x), kronecker(ket(1, 1), y)))))

axiom cont_zero_sem_kronqtspec2 :
  (forall c:circuit.
  (forall x:complex matrix. (is_a_ket_l(x, width(c)) -> sem(cont_zero(c),
  kronecker(ket(1, 0), x), kronecker(ket(1, 0), x)))))

logic result68 : circuit -> (int,int) farray

axiom resultqtdef75 :
  (forall c:circuit. forall i:int.
  ((result68(c)[i]) = (if (i <  1) then (i + width(c)) else (i - 1))))

function cont_last_qbit(c: circuit) : circuit =
  with_permutation(cont_zero(c), result68(c))

axiom cont_last_qbitqtspec :
  (forall c:circuit. (width(cont_last_qbit(c)) = (width(c) + 1)))

axiom cont_last_qbitqtspec1 :
  (forall c:circuit.
  (forall bv:bitvec. ((length(bv) = width(c)) -> (path_sem(cont_last_qbit(c),
  kronecker(bv_to_ket(bv), ket(1, 0))) = kronecker(bv_to_ket(bv), ket(1,
  0))))))

axiom cont_last_qbitqtspec2 :
  (forall c:circuit.
  (forall bv:bitvec. ((length(bv) = width(c)) -> (path_sem(cont_last_qbit(c),
  kronecker(bv_to_ket(bv), ket(1, 1))) = kronecker(path_sem(c,
  bv_to_ket(bv)), ket(1, 1))))))

axiom cont_last_qbitqtspec3 :
  (forall c:circuit.
  (forall bv:bitvec. ((length(bv) = (width(c) + 1)) ->
  (((value(bv)[width(c)]) = 0) -> (path_sem(cont_last_qbit(c),
  bv_to_ket(bv)) = bv_to_ket(bv))))))

axiom cont_last_qbitqtspec4 :
  (forall c:circuit.
  (forall bv:bitvec. ((length(bv) = (width(c) + 1)) ->
  (((value(bv)[width(c)]) = 1) -> (path_sem(cont_last_qbit(c),
  bv_to_ket(bv)) = path_sem(place(c, 0, (width(c) + 1)), bv_to_ket(bv)))))))

axiom cont_last_qbit_kronqtspec :
  (forall c:circuit. (width(cont_last_qbit(c)) = (width(c) + 1)))

axiom cont_last_qbit_kronqtspec1 :
  (forall c:circuit.
  (forall x:complex matrix. forall y:complex matrix. (sem(c, x, y) ->
  sem(cont_last_qbit(c), kronecker(x, ket(1, 1)), kronecker(y, ket(1, 1))))))

axiom cont_last_qbit_kronqtspec2 :
  (forall c:circuit.
  (forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  sem(cont_last_qbit(c), kronecker(x, ket(1, 0)), kronecker(x, ket(1, 0))))))

logic cont_zero_gen : circuit, int, int -> circuit

axiom cont_zero_genqtdef :
  (forall c:circuit. forall k:int. forall n:int. (((1 <= k) and
  (k <= (n - width(c)))) -> (cont_zero_gen(c, k, n) = cont_zero(place(c,
  (k - 1), (n - 1))))))

axiom cont_zero_genqtspec :
  (forall c:circuit. forall k:int. forall n:int. (((1 <= k) and
  (k <= (n - width(c)))) -> (width(cont_zero_gen(c, k, n)) = n)))

axiom cont_zero_genqtspec1 :
  (forall c:circuit. forall k:int. forall n:int. (((1 <= k) and
  (k <= (n - width(c)))) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[0]) = 0) ->
  (path_sem(cont_zero_gen(c, k, n), bv_to_ket(bv)) = bv_to_ket(bv)))))))

axiom cont_zero_genqtspec2 :
  (forall c:circuit. forall k:int. forall n:int. (((1 <= k) and
  (k <= (n - width(c)))) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[0]) = 1) ->
  (path_sem(cont_zero_gen(c, k, n), bv_to_ket(bv)) = path_sem(place(c, k, n),
  bv_to_ket(bv))))))))

logic cont_before : circuit, int, int, int -> circuit

axiom cont_beforeqtdef :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  ((co <  k) -> (cont_before(c, co, k, n) = place(cont_zero_gen(c, (k - co),
  (n - co)), co, n))))))

axiom cont_beforeqtspec :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  ((co <  k) -> (width(cont_before(c, co, k, n)) = n)))))

axiom cont_beforeqtspec1 :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  ((co <  k) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 0) ->
  (path_sem(cont_before(c, co, k, n), bv_to_ket(bv)) = bv_to_ket(bv)))))))))

axiom cont_beforeqtspec2 :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  ((co <  k) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 1) ->
  (path_sem(cont_before(c, co, k, n), bv_to_ket(bv)) = path_sem(place(c, k,
  n), bv_to_ket(bv))))))))))

logic cont_last_gen : circuit, int, int -> circuit

axiom cont_last_genqtdef :
  (forall c:circuit. forall k:int. forall co:int. (((0 <= k) and
  (k <= (co - width(c)))) -> (cont_last_gen(c, k,
  co) = cont_last_qbit(place(c, k, co)))))

axiom cont_last_genqtspec :
  (forall c:circuit. forall k:int. forall co:int. (((0 <= k) and
  (k <= (co - width(c)))) -> (width(cont_last_gen(c, k, co)) = (co + 1))))

axiom cont_last_genqtspec1 :
  (forall c:circuit. forall k:int. forall co:int. (((0 <= k) and
  (k <= (co - width(c)))) ->
  (forall bv:bitvec. ((length(bv) = (co + 1)) -> (((value(bv)[co]) = 0) ->
  (path_sem(cont_last_gen(c, k, co), bv_to_ket(bv)) = bv_to_ket(bv)))))))

axiom cont_last_genqtspec2 :
  (forall c:circuit. forall k:int. forall co:int. (((0 <= k) and
  (k <= (co - width(c)))) ->
  (forall bv:bitvec. ((length(bv) = (co + 1)) -> (((value(bv)[co]) = 1) ->
  (path_sem(cont_last_gen(c, k, co), bv_to_ket(bv)) = path_sem(place(c, k,
  (co + 1)), bv_to_ket(bv))))))))

logic cont_after : circuit, int, int, int -> circuit

axiom cont_afterqtdef :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> ((0 <= k) -> (((k + width(c)) <= co) ->
  (cont_after(c, co, k, n) = place(cont_last_gen(c, k, co), 0, n))))))

axiom cont_afterqtspec :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> ((0 <= k) -> (((k + width(c)) <= co) ->
  (width(cont_after(c, co, k, n)) = n)))))

axiom cont_afterqtspec1 :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> ((0 <= k) -> (((k + width(c)) <= co) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 0) ->
  (path_sem(cont_after(c, co, k, n), bv_to_ket(bv)) = bv_to_ket(bv)))))))))

axiom cont_afterqtspec2 :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> ((0 <= k) -> (((k + width(c)) <= co) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 1) ->
  (path_sem(cont_after(c, co, k, n), bv_to_ket(bv)) = path_sem(place(c, k,
  n), bv_to_ket(bv))))))))))

logic cont : circuit, int, int, int -> circuit

axiom contqtdef :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) -> ((co <  k) -> (cont(c, co, k,
  n) = cont_before(c, co, k, n)))))))

axiom contqtdef1 :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) -> ((not (co <  k)) -> (cont(c, co,
  k, n) = cont_after(c, co, k, n)))))))

axiom contqtspec :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) -> (width(cont(c, co, k,
  n)) = n)))))

axiom contqtspec1 :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 0) ->
  (path_sem(cont(c, co, k, n), bv_to_ket(bv)) = bv_to_ket(bv)))))))))

axiom contqtspec2 :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 1) ->
  (path_sem(cont(c, co, k, n), bv_to_ket(bv)) = path_sem(place(c, k, n),
  bv_to_ket(bv))))))))))

axiom cont_circ_to_pps :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) -> correct_path_sum_(cont(c, co, k,
  n), pps_cont(circ_to_pps(c), co, k, n))))))

axiom cont_pps :
  (forall c:circuit. forall h:pps. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) -> (correct_path_sum_(c, h) ->
  correct_path_sum_(cont(c, co, k, n), pps_cont(h, co, k, n)))))))

axiom path_cont :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 0) ->
  (path_sem(cont(c, co, k, n), bv_to_ket(bv)) = bv_to_ket(bv)))))))))

axiom path_cont1 :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 1) ->
  (path_sem(cont(c, co, k, n), bv_to_ket(bv)) = path_sem(place(c, k, n),
  bv_to_ket(bv))))))))))

axiom path_cont_ketz :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  forall x:complex matrix. (((0 <= co) and (co <  n)) -> (((0 <= k) and
  (k <= (n - width(c)))) -> (((k <= co) -> ((k + width(c)) <= co)) ->
  (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[co]) = 0) -> (path_sem(cont(c, co, k, n),
  x) = x))))))))

axiom path_cont_keto :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  forall x:complex matrix. (((0 <= co) and (co <  n)) -> (((0 <= k) and
  (k <= (n - width(c)))) -> (((k <= co) -> ((k + width(c)) <= co)) ->
  (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[co]) = 1) -> (path_sem(cont(c, co, k, n),
  x) = path_sem(place(c, k, n), x)))))))))

axiom path_cont_ketz_gen :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[co]) = 0) -> (path_sem(cont(c, co, k, n),
  x) = x)))))))))

axiom path_cont_keto_gen :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[co]) = 1) -> (path_sem(cont(c, co, k, n),
  x) = path_sem(place(c, k, n), x))))))))))

axiom cont_kron_left_bv_to_ket :
  (forall c:circuit. forall n:int. forall x:complex matrix.
  (((0 <= width(c)) and (width(c) = (n - 1))) -> (is_a_ket_l(x, width(c)) ->
  (forall y:bitvec. ((length(y) = 1) -> (((value(y)[0]) = 0) ->
  (path_sem(cont(c, (n - 1), 0, n), kronecker(x,
  bv_to_ket(y))) = kronecker(x, bv_to_ket(y)))))))))

axiom cont_kron_left_bv_to_ket1 :
  (forall c:circuit. forall n:int. forall x:complex matrix.
  (((0 <= width(c)) and (width(c) = (n - 1))) -> (is_a_ket_l(x, width(c)) ->
  (forall y:bitvec. ((length(y) = 1) -> (((value(y)[0]) = 1) ->
  (path_sem(cont(c, (n - 1), 0, n), kronecker(x,
  bv_to_ket(y))) = kronecker(path_sem(c, x), bv_to_ket(y)))))))))

axiom place_kron_left_path :
  (forall c:circuit. forall n:int. ((width(c) <  n) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  width(c)) -> (is_a_ket_l(y, (n - width(c))) -> (path_sem(place(c, 0, n),
  kronecker(x, y)) = kronecker(path_sem(c, x), y)))))))

axiom place_kron_left_sem :
  (forall c:circuit. forall n:int. ((width(c) <  n) ->
  (forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (is_a_ket_l(y, (n - width(c))) -> (sem(c, x, z) -> sem(place(c, 0, n),
  kronecker(x, y), kronecker(z, y)))))))

axiom cont_kron_pat_right :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  forall y:complex matrix. (((0 <= co) and (co <  k)) ->
  ((n = (k + width(c))) -> (is_a_ket_l(y, width(c)) ->
  (forall x:complex matrix. (is_a_ket_basis_elt(x) -> (is_a_ket_l(x, k) ->
  (((value(ket_to_bv(x))[co]) = 0) -> (path_sem(cont(c, co, k, n),
  kronecker(x, y)) = kronecker(x, y))))))))))

axiom cont_kron_pat_right1 :
  (forall c:circuit. forall co:int. forall k:int. forall n:int.
  forall y:complex matrix. (((0 <= co) and (co <  k)) ->
  ((n = (k + width(c))) -> (is_a_ket_l(y, width(c)) ->
  (forall x:complex matrix. (is_a_ket_basis_elt(x) -> (is_a_ket_l(x, k) ->
  (((value(ket_to_bv(x))[co]) = 1) -> (path_sem(cont(c, co, k, n),
  kronecker(x, y)) = kronecker(x, path_sem(c, y)))))))))))

axiom cont_kron_pat_right_gen :
  (forall circ:circuit. forall c:int. forall k:int. forall n:int.
  (((0 <= c) and (c <  k)) -> ((n = (k + width(circ))) ->
  (forall y:complex matrix.
  (forall x:bitvec. (is_a_ket_l(y, width(circ)) -> ((length(x) = k) ->
  (((value(x)[c]) = 0) -> (path_sem(cont(circ, c, k, n),
  kronecker(bv_to_ket(x), y)) = kronecker(bv_to_ket(x), y))))))))))

axiom cont_kron_pat_right_gen1 :
  (forall circ:circuit. forall c:int. forall k:int. forall n:int.
  (((0 <= c) and (c <  k)) -> ((n = (k + width(circ))) ->
  (forall y:complex matrix.
  (forall x:bitvec. (is_a_ket_l(y, width(circ)) -> ((length(x) = k) ->
  (((value(x)[c]) = 1) -> (path_sem(cont(circ, c, k, n),
  kronecker(bv_to_ket(x), y)) = kronecker(bv_to_ket(x), path_sem(circ,
  y)))))))))))

axiom size_cont :
  (forall c:circuit. forall co:int. forall k:int. forall n:int. forall s:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width(c)))) ->
  (((k <= co) -> ((k + width(c)) <= co)) -> ((size(c) <= s) -> (size(cont(c,
  co, k, n)) <= (cont_size * s)))))))

logic place_xx : int, int -> circuit

axiom place_xxqtdef :
  (forall t:int. forall n:int. (((0 <= t) and (t <  n)) -> (place_xx(t,
  n) = place(xx, t, n))))

logic fc597 : int, bitvec -> (int,int) farray

axiom fcqtdef600 :
  (forall t:int. forall bv:bitvec. forall i:int. ((fc597(t,
  bv)[i]) = (if (i = t) then (1 - (value(bv)[i])) else (value(bv)[i]))))

axiom place_xxqtspec :
  (forall t:int. forall n:int. (((0 <= t) and (t <  n)) -> (width(place_xx(t,
  n)) = n)))

axiom place_xxqtspec1 :
  (forall t:int. forall n:int. (((0 <= t) and (t <  n)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (path_sem(place_xx(t, n),
  bv_to_ket(bv)) = bv_to_ket(make_bv(fc597(t, bv), n)))))))

axiom place_xxqtspec2 :
  (forall t:int. forall n:int. (((0 <= t) and (t <  n)) ->
  (forall bv:bitvec. ((length(bv) = n) ->
  is_a_ket_basis_elt(path_sem(place_xx(t, n), bv_to_ket(bv)))))))

axiom place_xxqtspec3 :
  (forall t:int. forall n:int. (((0 <= t) and (t <  n)) ->
  (forall bv:bitvec. ((length(bv) = n) ->
  ((value(ket_to_bv(path_sem(place_xx(t, n),
  bv_to_ket(bv))))[t]) = (1 - (value(bv)[t])))))))

axiom place_xxqtspec4 :
  (forall t:int. forall n:int. (((0 <= t) and (t <  n)) ->
  (forall bv:bitvec.
  (forall i:int. ((length(bv) = n) -> (((0 <= i) and (i <  n)) ->
  ((not (i = t)) -> ((value(ket_to_bv(path_sem(place_xx(t, n),
  bv_to_ket(bv))))[i]) = (value(bv)[i])))))))))

logic place_cnot_ps : int, int, int -> circuit

axiom place_cnot_psqtdef :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) -> (place_cnot_ps(c, t,
  n) = place_cnot(c, t, n))))))

axiom place_cnot_psqtspec :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) -> (width(place_cnot_ps(c, t,
  n)) = n)))))

axiom place_cnot_psqtspec1 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) ->
  (forall bv:bitvec. ((length(bv) = n) ->
  is_a_ket_basis_elt(path_sem(place_cnot_ps(c, t, n), bv_to_ket(bv)))))))))

axiom place_cnot_psqtspec2 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[c]) = 0) ->
  (path_sem(place_cnot_ps(c, t, n), bv_to_ket(bv)) = bv_to_ket(bv)))))))))

axiom place_cnot_psqtspec3 :
  (forall c:int. forall t:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t) and (t <  n)) -> ((not (c = t)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[c]) = 1) ->
  (path_sem(place_cnot_ps(c, t, n), bv_to_ket(bv)) = path_sem(place_xx(t, n),
  bv_to_ket(bv))))))))))

logic place_toffoli_tcc : int, int, int, int -> circuit

axiom place_toffoli_tccqtdef :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= t) and
  ((t <  c1) and ((c1 <  c2) and (c2 <  n)))) -> (place_toffoli_tcc(c1, c2,
  t, n) = cont(place_cnot_ps((c1 - t), 0, ((c1 - t) + 1)), c2, t, n))))

logic fc598 : int, int, int, complex matrix -> (int,int) farray

axiom fcqtdef601 :
  (forall c1:int. forall c2:int. forall t:int. forall x:complex matrix.
  forall i:int. ((fc598(c1, c2, t,
  x)[i]) = (if (i = t) then ((((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2])) * (1 - (value(ket_to_bv(x))[t]))) + ((value(ket_to_bv(x))[t]) * (1 - ((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2]))))) else (value(ket_to_bv(x))[i]))))

axiom place_toffoli_tccqtspec :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= t) and
  ((t <  c1) and ((c1 <  c2) and (c2 <  n)))) -> (width(place_toffoli_tcc(c1,
  c2, t, n)) = n)))

axiom place_toffoli_tccqtspec1 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= t) and
  ((t <  c1) and ((c1 <  c2) and (c2 <  n)))) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (path_sem(place_toffoli_tcc(c1, c2, t, n), x) = bv_to_ket(make_bv(fc598(c1,
  c2, t, x), n))))))))

logic place_toffoli_ctc : int, int, int, int -> circuit

axiom place_toffoli_ctcqtdef :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  ((c1 <  t) and ((t <  c2) and (c2 <  n)))) -> (place_toffoli_ctc(c1, c2, t,
  n) = cont(place_cnot_ps(0, (t - c1), ((t - c1) + 1)), c2, c1, n))))

logic fc599 : int, int, int, complex matrix -> (int,int) farray

axiom fcqtdef602 :
  (forall c1:int. forall c2:int. forall t:int. forall x:complex matrix.
  forall i:int. ((fc599(c1, c2, t,
  x)[i]) = (if (i = t) then ((((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2])) * (1 - (value(ket_to_bv(x))[t]))) + ((value(ket_to_bv(x))[t]) * (1 - ((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2]))))) else (value(ket_to_bv(x))[i]))))

axiom place_toffoli_ctcqtspec :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  ((c1 <  t) and ((t <  c2) and (c2 <  n)))) -> (width(place_toffoli_ctc(c1,
  c2, t, n)) = n)))

axiom place_toffoli_ctcqtspec1 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  ((c1 <  t) and ((t <  c2) and (c2 <  n)))) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (path_sem(place_toffoli_ctc(c1, c2, t, n), x) = bv_to_ket(make_bv(fc599(c1,
  c2, t, x), n))))))))

logic place_toffoli_cct : int, int, int, int -> circuit

axiom place_toffoli_cctqtdef :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  ((c1 <  c2) and ((c2 <  t) and (t <  n)))) -> (place_toffoli_cct(c1, c2, t,
  n) = cont(place_cnot_ps(0, (t - c2), ((t - c2) + 1)), c1, c2, n))))

logic fc600 : int, int, int, complex matrix -> (int,int) farray

axiom fcqtdef603 :
  (forall c1:int. forall c2:int. forall t:int. forall x:complex matrix.
  forall i:int. ((fc600(c1, c2, t,
  x)[i]) = (if (i = t) then ((((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2])) * (1 - (value(ket_to_bv(x))[t]))) + ((value(ket_to_bv(x))[t]) * (1 - ((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2]))))) else (value(ket_to_bv(x))[i]))))

axiom place_toffoli_cctqtspec :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  ((c1 <  c2) and ((c2 <  t) and (t <  n)))) -> (width(place_toffoli_cct(c1,
  c2, t, n)) = n)))

axiom place_toffoli_cctqtspec1 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  ((c1 <  c2) and ((c2 <  t) and (t <  n)))) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (path_sem(place_toffoli_cct(c1, c2, t, n), x) = bv_to_ket(make_bv(fc600(c1,
  c2, t, x), n))))))))

logic place_toffoli : int, int, int, int -> circuit

axiom place_toffoliqtdef :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t)) -> ((not (c2 = t)) -> (let mincont =
  min(c1, c2) : int in ((t <  mincont) -> (place_toffoli(c1, c2, t,
  n) = place_toffoli_tcc(mincont, max(c1, c2), t, n)))))))))))

axiom place_toffoliqtdef1 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t)) -> ((not (c2 = t)) -> (let mincont =
  min(c1, c2) : int in (let maxcont = max(c1, c2) : int in
  ((not (t <  mincont)) -> ((t <  maxcont) -> (place_toffoli(c1, c2, t,
  n) = place_toffoli_ctc(mincont, maxcont, t, n)))))))))))))

axiom place_toffoliqtdef2 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t)) -> ((not (c2 = t)) -> (let mincont =
  min(c1, c2) : int in (let maxcont = max(c1, c2) : int in
  ((not (t <  mincont)) -> ((not (t <  maxcont)) -> (place_toffoli(c1, c2, t,
  n) = place_toffoli_cct(mincont, maxcont, t, n)))))))))))))

logic fc601 : int, int, int, complex matrix -> (int,int) farray

axiom fcqtdef604 :
  (forall c1:int. forall c2:int. forall t:int. forall x:complex matrix.
  forall i:int. ((fc601(c1, c2, t,
  x)[i]) = (if (i = t) then ((((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2])) * (1 - (value(ket_to_bv(x))[t]))) + ((value(ket_to_bv(x))[t]) * (1 - ((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2]))))) else (value(ket_to_bv(x))[i]))))

axiom place_toffoliqtspec :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t)) -> ((not (c2 = t)) ->
  (width(place_toffoli(c1, c2, t, n)) = n))))))))

axiom place_toffoliqtspec1 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t)) -> ((not (c2 = t)) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (path_sem(place_toffoli(c1, c2, t, n), x) = bv_to_ket(make_bv(fc601(c1, c2,
  t, x), n)))))))))))))

axiom place_toffoliqtspec2 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t)) -> ((not (c2 = t)) ->
  correct_path_sum_(place_toffoli(c1, c2, t, n), pps_toffoli(c1, c2, t,
  n)))))))))

axiom place_toffoliqtspec3 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t)) -> ((not (c2 = t)) ->
  (forall bv:bitvec. ((length(bv) = n) ->
  is_a_ket_basis_elt(path_sem(place_toffoli(c1, c2, t, n), bv_to_ket(bv))))))))))))

axiom place_toffoliqtspec4 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t)) -> ((not (c2 = t)) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  ((value(ket_to_bv(path_sem(place_toffoli(c1, c2, t, n),
  x)))[t]) = ((((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2])) * (1 - (value(ket_to_bv(x))[t]))) + ((value(ket_to_bv(x))[t]) * (1 - ((value(ket_to_bv(x))[c1]) * (value(ket_to_bv(x))[c2]))))))))))))))))

axiom place_toffoliqtspec5 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t) and (t <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t)) -> ((not (c2 = t)) ->
  (forall x:complex matrix.
  (forall i:int. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((0 <= i) and (i <  n)) -> ((not (i = t)) ->
  ((value(ket_to_bv(path_sem(place_toffoli(c1, c2, t, n),
  x)))[i]) = (value(ket_to_bv(x))[i])))))))))))))))

axiom bricks_toffoli_path : correct_path_sum_(toffoli, pps_toffoli(0, 1, 2,
  3))

logic place_fredkin : int, int, int, int -> circuit

axiom place_fredkinqtdef :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) -> (place_fredkin(c,
  t1, t2, n) = sequence(sequence(place_toffoli(c, t1, t2, n),
  place_toffoli(c, t2, t1, n)), place_toffoli(c, t1, t2, n))))))))))

logic fc602 : int, int, int, bitvec -> (int,int) farray

logic fc603 : (int,int) farray

axiom fcqtdef605 :
  (forall c:int. forall t1:int. forall t2:int. forall bv:bitvec.
  forall i:int. ((fc602(c, t1, t2,
  bv)[i]) = (if (i = t1) then (((value(bv)[c]) * (value(bv)[t2])) + ((1 - (value(bv)[c])) * (value(bv)[t1]))) else (if (i = t2) then (((value(bv)[c]) * (value(bv)[t1])) + ((1 - (value(bv)[c])) * (value(bv)[t2]))) else (value(bv)[i])))))

axiom fcqtdef606 : (forall us:int. ((fc603[us]) = 0))

axiom place_fredkinqtspec :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) ->
  (forall bv:bitvec.
  (forall i:int. ((length(bv) = n) -> (((value(bv)[c]) = 0) -> (((0 <= i) and
  (i <  n)) -> ((value(ket_to_bv(path_sem(place_fredkin(c, t1, t2, n),
  bv_to_ket(bv))))[i]) = (value(bv)[i]))))))))))))))

axiom place_fredkinqtspec1 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[c]) = 1) ->
  ((value(ket_to_bv(path_sem(place_fredkin(c, t1, t2, n),
  bv_to_ket(bv))))[t1]) = (value(bv)[t2]))))))))))))

axiom place_fredkinqtspec2 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[c]) = 1) ->
  ((value(ket_to_bv(path_sem(place_fredkin(c, t1, t2, n),
  bv_to_ket(bv))))[t2]) = (value(bv)[t1]))))))))))))

axiom place_fredkinqtspec3 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) ->
  (forall bv:bitvec.
  (forall i:int. ((length(bv) = n) -> (((value(bv)[c]) = 1) -> (((0 <= i) and
  (i <  n)) -> ((not (i = t1)) -> ((not (i = t2)) ->
  ((value(ket_to_bv(path_sem(place_fredkin(c, t1, t2, n),
  bv_to_ket(bv))))[i]) = (value(bv)[i]))))))))))))))))

axiom place_fredkinqtspec4 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) ->
  (forall bv:bitvec. ((length(bv) = n) ->
  is_a_ket_basis_elt(path_sem(place_fredkin(c, t1, t2, n), bv_to_ket(bv))))))))))))

axiom place_fredkinqtspec5 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (path_sem(place_fredkin(c, t1, t2,
  n), bv_to_ket(bv)) = bv_to_ket(make_bv(fc602(c, t1, t2, bv), n))))))))))))

axiom place_fredkinqtspec6 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (path_sem(place_fredkin(c, t1, t2,
  n), bv_to_ket(bv)) = bv_to_ket(make_bv(((h_basis_ket(pps_fredkin(c, t1, t2,
  n))[value(bv)])[fc603]), n))))))))))))

axiom place_fredkinqtspec7 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) ->
  correct_path_sum_(place_fredkin(c, t1, t2, n), pps_fredkin(c, t1, t2,
  n)))))))))

axiom place_fredkinqtspec8 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (t2 = c)) ->
  (width(place_fredkin(c, t1, t2, n)) = n))))))))

axiom bricks_fredkin_path : correct_path_sum_(fredkin, pps_fredkin(0, 1, 2,
  3))

logic swap_c : int, int, int -> circuit

axiom swap_cqtdef :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (swap_c(t1, t2,
  n) = permute_atom(t1, t2, n))))))

axiom swap_cqtspec :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (width(swap_c(t1, t2,
  n)) = n)))))

axiom swap_cqtspec1 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  correct_path_sum_(swap_c(t1, t2, n), pps_swap(t1, t2, n))))))

type wired_circuit

logic Skip : wired_circuit

logic Phase1 : int -> wired_circuit

logic Rx : int -> wired_circuit

logic Ry : int -> wired_circuit

logic Rz1 : int -> wired_circuit

logic Rzp : int -> wired_circuit

logic Hadamard1 : wired_circuit

logic S : wired_circuit

logic T : wired_circuit

logic X : wired_circuit

logic Y : wired_circuit

logic Z : wired_circuit

logic Bricks_Cnot : wired_circuit

logic Bricks_Toffoli : wired_circuit

logic Bricks_Fredkin : wired_circuit

logic Bricks_Swap : wired_circuit

logic Swap1 : int, int, int -> wired_circuit

logic Cnot1 : int, int, int -> wired_circuit

logic Toffoli : int, int, int, int -> wired_circuit

logic Fredkin : int, int, int, int -> wired_circuit

logic Place : wired_circuit, int, int -> wired_circuit

logic Cont : wired_circuit, int, int, int -> wired_circuit

logic Sequence1 : wired_circuit, wired_circuit -> wired_circuit

logic Parallel1 : wired_circuit, wired_circuit -> wired_circuit

logic Ancillas1 : wired_circuit, int -> wired_circuit

logic match_wired_circuit : wired_circuit, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a,
  'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a, 'a -> 'a

axiom match_wired_circuit_Skip :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(Skip, z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11,
  z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23, z24) = z))

axiom match_wired_circuit_Phase :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:int. (match_wired_circuit(Phase1(u), z, z1, z2, z3, z4, z5, z6,
  z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z1))

axiom match_wired_circuit_Rx :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:int. (match_wired_circuit(Rx(u), z, z1, z2, z3, z4, z5, z6, z7,
  z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22,
  z23, z24) = z2))

axiom match_wired_circuit_Ry :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:int. (match_wired_circuit(Ry(u), z, z1, z2, z3, z4, z5, z6, z7,
  z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22,
  z23, z24) = z3))

axiom match_wired_circuit_Rz :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:int. (match_wired_circuit(Rz1(u), z, z1, z2, z3, z4, z5, z6, z7,
  z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22,
  z23, z24) = z4))

axiom match_wired_circuit_Rzp :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:int. (match_wired_circuit(Rzp(u), z, z1, z2, z3, z4, z5, z6, z7,
  z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22,
  z23, z24) = z5))

axiom match_wired_circuit_Hadamard :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(Hadamard1, z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10,
  z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23,
  z24) = z6))

axiom match_wired_circuit_S :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(S, z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11,
  z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23, z24) = z7))

axiom match_wired_circuit_T :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(T, z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11,
  z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23, z24) = z8))

axiom match_wired_circuit_X :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(X, z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11,
  z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23, z24) = z9))

axiom match_wired_circuit_Y :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(Y, z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11,
  z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23, z24) = z10))

axiom match_wired_circuit_Z :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(Z, z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11,
  z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23, z24) = z11))

axiom match_wired_circuit_Bricks_Cnot :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(Bricks_Cnot, z, z1, z2, z3, z4, z5, z6, z7, z8, z9,
  z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23,
  z24) = z12))

axiom match_wired_circuit_Bricks_Toffoli :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(Bricks_Toffoli, z, z1, z2, z3, z4, z5, z6, z7, z8, z9,
  z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23,
  z24) = z13))

axiom match_wired_circuit_Bricks_Fredkin :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(Bricks_Fredkin, z, z1, z2, z3, z4, z5, z6, z7, z8, z9,
  z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23,
  z24) = z14))

axiom match_wired_circuit_Bricks_Swap :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  (match_wired_circuit(Bricks_Swap, z, z1, z2, z3, z4, z5, z6, z7, z8, z9,
  z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23,
  z24) = z15))

axiom match_wired_circuit_Swap :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:int. forall u1:int. forall u2:int. (match_wired_circuit(Swap1(u,
  u1, u2), z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14,
  z15, z16, z17, z18, z19, z20, z21, z22, z23, z24) = z16))

axiom match_wired_circuit_Cnot :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:int. forall u1:int. forall u2:int. (match_wired_circuit(Cnot1(u,
  u1, u2), z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14,
  z15, z16, z17, z18, z19, z20, z21, z22, z23, z24) = z17))

axiom match_wired_circuit_Toffoli :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (match_wired_circuit(Toffoli(u, u1, u2, u3), z, z1, z2, z3, z4, z5, z6, z7,
  z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22,
  z23, z24) = z18))

axiom match_wired_circuit_Fredkin :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (match_wired_circuit(Fredkin(u, u1, u2, u3), z, z1, z2, z3, z4, z5, z6, z7,
  z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22,
  z23, z24) = z19))

axiom match_wired_circuit_Place :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:wired_circuit. forall u1:int. forall u2:int.
  (match_wired_circuit(Place(u, u1, u2), z, z1, z2, z3, z4, z5, z6, z7, z8,
  z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23,
  z24) = z20))

axiom match_wired_circuit_Cont :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:wired_circuit. forall u1:int. forall u2:int. forall u3:int.
  (match_wired_circuit(Cont(u, u1, u2, u3), z, z1, z2, z3, z4, z5, z6, z7,
  z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22,
  z23, z24) = z21))

axiom match_wired_circuit_Sequence :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:wired_circuit. forall u1:wired_circuit.
  (match_wired_circuit(Sequence1(u, u1), z, z1, z2, z3, z4, z5, z6, z7, z8,
  z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23,
  z24) = z22))

axiom match_wired_circuit_Parallel :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:wired_circuit. forall u1:wired_circuit.
  (match_wired_circuit(Parallel1(u, u1), z, z1, z2, z3, z4, z5, z6, z7, z8,
  z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21, z22, z23,
  z24) = z23))

axiom match_wired_circuit_Ancillas :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  forall z5:'a. forall z6:'a. forall z7:'a. forall z8:'a. forall z9:'a.
  forall z10:'a. forall z11:'a. forall z12:'a. forall z13:'a. forall z14:'a.
  forall z15:'a. forall z16:'a. forall z17:'a. forall z18:'a. forall z19:'a.
  forall z20:'a. forall z21:'a. forall z22:'a. forall z23:'a. forall z24:'a.
  forall u:wired_circuit. forall u1:int. (match_wired_circuit(Ancillas1(u,
  u1), z, z1, z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15,
  z16, z17, z18, z19, z20, z21, z22, z23, z24) = z24))

logic index_wired_circuit : wired_circuit -> int

axiom index_wired_circuit_Skip : (index_wired_circuit(Skip) = 0)

axiom index_wired_circuit_Phase :
  (forall u:int [Phase1(u)]. (index_wired_circuit(Phase1(u)) = 1))

axiom index_wired_circuit_Rx :
  (forall u:int [Rx(u)]. (index_wired_circuit(Rx(u)) = 2))

axiom index_wired_circuit_Ry :
  (forall u:int [Ry(u)]. (index_wired_circuit(Ry(u)) = 3))

axiom index_wired_circuit_Rz :
  (forall u:int [Rz1(u)]. (index_wired_circuit(Rz1(u)) = 4))

axiom index_wired_circuit_Rzp :
  (forall u:int [Rzp(u)]. (index_wired_circuit(Rzp(u)) = 5))

axiom index_wired_circuit_Hadamard : (index_wired_circuit(Hadamard1) = 6)

axiom index_wired_circuit_S : (index_wired_circuit(S) = 7)

axiom index_wired_circuit_T : (index_wired_circuit(T) = 8)

axiom index_wired_circuit_X : (index_wired_circuit(X) = 9)

axiom index_wired_circuit_Y : (index_wired_circuit(Y) = 10)

axiom index_wired_circuit_Z : (index_wired_circuit(Z) = 11)

axiom index_wired_circuit_Bricks_Cnot :
  (index_wired_circuit(Bricks_Cnot) = 12)

axiom index_wired_circuit_Bricks_Toffoli :
  (index_wired_circuit(Bricks_Toffoli) = 13)

axiom index_wired_circuit_Bricks_Fredkin :
  (index_wired_circuit(Bricks_Fredkin) = 14)

axiom index_wired_circuit_Bricks_Swap :
  (index_wired_circuit(Bricks_Swap) = 15)

axiom index_wired_circuit_Swap :
  (forall u:int. forall u1:int. forall u2:int [Swap1(u, u1, u2)].
  (index_wired_circuit(Swap1(u, u1, u2)) = 16))

axiom index_wired_circuit_Cnot :
  (forall u:int. forall u1:int. forall u2:int [Cnot1(u, u1, u2)].
  (index_wired_circuit(Cnot1(u, u1, u2)) = 17))

axiom index_wired_circuit_Toffoli :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int [Toffoli(u, u1,
  u2, u3)]. (index_wired_circuit(Toffoli(u, u1, u2, u3)) = 18))

axiom index_wired_circuit_Fredkin :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int [Fredkin(u, u1,
  u2, u3)]. (index_wired_circuit(Fredkin(u, u1, u2, u3)) = 19))

axiom index_wired_circuit_Place :
  (forall u:wired_circuit. forall u1:int. forall u2:int [Place(u, u1, u2)].
  (index_wired_circuit(Place(u, u1, u2)) = 20))

axiom index_wired_circuit_Cont :
  (forall u:wired_circuit. forall u1:int. forall u2:int. forall u3:int
  [Cont(u, u1, u2, u3)]. (index_wired_circuit(Cont(u, u1, u2, u3)) = 21))

axiom index_wired_circuit_Sequence :
  (forall u:wired_circuit. forall u1:wired_circuit [Sequence1(u, u1)].
  (index_wired_circuit(Sequence1(u, u1)) = 22))

axiom index_wired_circuit_Parallel :
  (forall u:wired_circuit. forall u1:wired_circuit [Parallel1(u, u1)].
  (index_wired_circuit(Parallel1(u, u1)) = 23))

axiom index_wired_circuit_Ancillas :
  (forall u:wired_circuit. forall u1:int [Ancillas1(u, u1)].
  (index_wired_circuit(Ancillas1(u, u1)) = 24))

logic Phase_proj_11 : wired_circuit -> int

axiom Phase_proj_1qtdef1 : (forall u:int. (Phase_proj_11(Phase1(u)) = u))

logic Rx_proj_1 : wired_circuit -> int

axiom Rx_proj_1qtdef : (forall u:int. (Rx_proj_1(Rx(u)) = u))

logic Ry_proj_1 : wired_circuit -> int

axiom Ry_proj_1qtdef : (forall u:int. (Ry_proj_1(Ry(u)) = u))

logic Rz_proj_11 : wired_circuit -> int

axiom Rz_proj_1qtdef1 : (forall u:int. (Rz_proj_11(Rz1(u)) = u))

logic Rzp_proj_1 : wired_circuit -> int

axiom Rzp_proj_1qtdef : (forall u:int. (Rzp_proj_1(Rzp(u)) = u))

logic Swap_proj_1 : wired_circuit -> int

axiom Swap_proj_1qtdef :
  (forall u:int. forall u1:int. forall u2:int. (Swap_proj_1(Swap1(u, u1,
  u2)) = u))

logic Swap_proj_2 : wired_circuit -> int

axiom Swap_proj_2qtdef :
  (forall u:int. forall u1:int. forall u2:int. (Swap_proj_2(Swap1(u, u1,
  u2)) = u1))

logic Swap_proj_3 : wired_circuit -> int

axiom Swap_proj_3qtdef :
  (forall u:int. forall u1:int. forall u2:int. (Swap_proj_3(Swap1(u, u1,
  u2)) = u2))

logic Cnot_proj_1 : wired_circuit -> int

axiom Cnot_proj_1qtdef :
  (forall u:int. forall u1:int. forall u2:int. (Cnot_proj_1(Cnot1(u, u1,
  u2)) = u))

logic Cnot_proj_2 : wired_circuit -> int

axiom Cnot_proj_2qtdef :
  (forall u:int. forall u1:int. forall u2:int. (Cnot_proj_2(Cnot1(u, u1,
  u2)) = u1))

logic Cnot_proj_3 : wired_circuit -> int

axiom Cnot_proj_3qtdef :
  (forall u:int. forall u1:int. forall u2:int. (Cnot_proj_3(Cnot1(u, u1,
  u2)) = u2))

logic Toffoli_proj_1 : wired_circuit -> int

axiom Toffoli_proj_1qtdef :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (Toffoli_proj_1(Toffoli(u, u1, u2, u3)) = u))

logic Toffoli_proj_2 : wired_circuit -> int

axiom Toffoli_proj_2qtdef :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (Toffoli_proj_2(Toffoli(u, u1, u2, u3)) = u1))

logic Toffoli_proj_3 : wired_circuit -> int

axiom Toffoli_proj_3qtdef :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (Toffoli_proj_3(Toffoli(u, u1, u2, u3)) = u2))

logic Toffoli_proj_4 : wired_circuit -> int

axiom Toffoli_proj_4qtdef :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (Toffoli_proj_4(Toffoli(u, u1, u2, u3)) = u3))

logic Fredkin_proj_1 : wired_circuit -> int

axiom Fredkin_proj_1qtdef :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (Fredkin_proj_1(Fredkin(u, u1, u2, u3)) = u))

logic Fredkin_proj_2 : wired_circuit -> int

axiom Fredkin_proj_2qtdef :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (Fredkin_proj_2(Fredkin(u, u1, u2, u3)) = u1))

logic Fredkin_proj_3 : wired_circuit -> int

axiom Fredkin_proj_3qtdef :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (Fredkin_proj_3(Fredkin(u, u1, u2, u3)) = u2))

logic Fredkin_proj_4 : wired_circuit -> int

axiom Fredkin_proj_4qtdef :
  (forall u:int. forall u1:int. forall u2:int. forall u3:int.
  (Fredkin_proj_4(Fredkin(u, u1, u2, u3)) = u3))

logic Place_proj_1 : wired_circuit -> wired_circuit

axiom Place_proj_1qtdef :
  (forall u:wired_circuit. forall u1:int. forall u2:int.
  (Place_proj_1(Place(u, u1, u2)) = u))

logic Place_proj_2 : wired_circuit -> int

axiom Place_proj_2qtdef :
  (forall u:wired_circuit. forall u1:int. forall u2:int.
  (Place_proj_2(Place(u, u1, u2)) = u1))

logic Place_proj_3 : wired_circuit -> int

axiom Place_proj_3qtdef :
  (forall u:wired_circuit. forall u1:int. forall u2:int.
  (Place_proj_3(Place(u, u1, u2)) = u2))

logic Cont_proj_1 : wired_circuit -> wired_circuit

axiom Cont_proj_1qtdef :
  (forall u:wired_circuit. forall u1:int. forall u2:int. forall u3:int.
  (Cont_proj_1(Cont(u, u1, u2, u3)) = u))

logic Cont_proj_2 : wired_circuit -> int

axiom Cont_proj_2qtdef :
  (forall u:wired_circuit. forall u1:int. forall u2:int. forall u3:int.
  (Cont_proj_2(Cont(u, u1, u2, u3)) = u1))

logic Cont_proj_3 : wired_circuit -> int

axiom Cont_proj_3qtdef :
  (forall u:wired_circuit. forall u1:int. forall u2:int. forall u3:int.
  (Cont_proj_3(Cont(u, u1, u2, u3)) = u2))

logic Cont_proj_4 : wired_circuit -> int

axiom Cont_proj_4qtdef :
  (forall u:wired_circuit. forall u1:int. forall u2:int. forall u3:int.
  (Cont_proj_4(Cont(u, u1, u2, u3)) = u3))

logic Sequence_proj_11 : wired_circuit -> wired_circuit

axiom Sequence_proj_1qtdef1 :
  (forall u:wired_circuit. forall u1:wired_circuit.
  (Sequence_proj_11(Sequence1(u, u1)) = u))

logic Sequence_proj_21 : wired_circuit -> wired_circuit

axiom Sequence_proj_2qtdef1 :
  (forall u:wired_circuit. forall u1:wired_circuit.
  (Sequence_proj_21(Sequence1(u, u1)) = u1))

logic Parallel_proj_11 : wired_circuit -> wired_circuit

axiom Parallel_proj_1qtdef1 :
  (forall u:wired_circuit. forall u1:wired_circuit.
  (Parallel_proj_11(Parallel1(u, u1)) = u))

logic Parallel_proj_21 : wired_circuit -> wired_circuit

axiom Parallel_proj_2qtdef1 :
  (forall u:wired_circuit. forall u1:wired_circuit.
  (Parallel_proj_21(Parallel1(u, u1)) = u1))

logic Ancillas_proj_11 : wired_circuit -> wired_circuit

axiom Ancillas_proj_1qtdef1 :
  (forall u:wired_circuit. forall u1:int. (Ancillas_proj_11(Ancillas1(u,
  u1)) = u))

logic Ancillas_proj_21 : wired_circuit -> int

axiom Ancillas_proj_2qtdef1 :
  (forall u:wired_circuit. forall u1:int. (Ancillas_proj_21(Ancillas1(u,
  u1)) = u1))

axiom wired_circuit_inversion :
  (forall u:wired_circuit. (((((((((((((((((((((((((u = Skip) or
  (u = Phase1(Phase_proj_11(u)))) or (u = Rx(Rx_proj_1(u)))) or
  (u = Ry(Ry_proj_1(u)))) or (u = Rz1(Rz_proj_11(u)))) or
  (u = Rzp(Rzp_proj_1(u)))) or (u = Hadamard1)) or (u = S)) or (u = T)) or
  (u = X)) or (u = Y)) or (u = Z)) or (u = Bricks_Cnot)) or
  (u = Bricks_Toffoli)) or (u = Bricks_Fredkin)) or (u = Bricks_Swap)) or
  (u = Swap1(Swap_proj_1(u), Swap_proj_2(u), Swap_proj_3(u)))) or
  (u = Cnot1(Cnot_proj_1(u), Cnot_proj_2(u), Cnot_proj_3(u)))) or
  (u = Toffoli(Toffoli_proj_1(u), Toffoli_proj_2(u), Toffoli_proj_3(u),
  Toffoli_proj_4(u)))) or (u = Fredkin(Fredkin_proj_1(u), Fredkin_proj_2(u),
  Fredkin_proj_3(u), Fredkin_proj_4(u)))) or (u = Place(Place_proj_1(u),
  Place_proj_2(u), Place_proj_3(u)))) or (u = Cont(Cont_proj_1(u),
  Cont_proj_2(u), Cont_proj_3(u), Cont_proj_4(u)))) or
  (u = Sequence1(Sequence_proj_11(u), Sequence_proj_21(u)))) or
  (u = Parallel1(Parallel_proj_11(u), Parallel_proj_21(u)))) or
  (u = Ancillas1(Ancillas_proj_11(u), Ancillas_proj_21(u)))))

logic width_pre_ : wired_circuit -> int

axiom width_pre_qtdef : (width_pre_(Skip) = 1)

axiom width_pre_qtdef1 : (forall w:int. (width_pre_(Phase1(w)) = 1))

axiom width_pre_qtdef2 : (forall w:int. (width_pre_(Rx(w)) = 1))

axiom width_pre_qtdef3 : (forall w:int. (width_pre_(Ry(w)) = 1))

axiom width_pre_qtdef4 : (forall w:int. (width_pre_(Rz1(w)) = 1))

axiom width_pre_qtdef5 : (forall w:int. (width_pre_(Rzp(w)) = 1))

axiom width_pre_qtdef6 : (width_pre_(Hadamard1) = 1)

axiom width_pre_qtdef7 : (width_pre_(S) = 1)

axiom width_pre_qtdef8 : (width_pre_(T) = 1)

axiom width_pre_qtdef9 : (width_pre_(X) = 1)

axiom width_pre_qtdef10 : (width_pre_(Y) = 1)

axiom width_pre_qtdef11 : (width_pre_(Z) = 1)

axiom width_pre_qtdef12 : (width_pre_(Bricks_Cnot) = 2)

axiom width_pre_qtdef13 : (width_pre_(Bricks_Toffoli) = 3)

axiom width_pre_qtdef14 : (width_pre_(Bricks_Fredkin) = 3)

axiom width_pre_qtdef15 : (width_pre_(Bricks_Swap) = 2)

axiom width_pre_qtdef16 :
  (forall x:int. forall x1:int. forall x2:int. (width_pre_(Swap1(x, x1,
  x2)) = x2))

axiom width_pre_qtdef17 :
  (forall x:int. forall x1:int. forall x2:int. (width_pre_(Cnot1(x, x1,
  x2)) = x2))

axiom width_pre_qtdef18 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (width_pre_(Toffoli(x, x1, x2, x3)) = x3))

axiom width_pre_qtdef19 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (width_pre_(Fredkin(x, x1, x2, x3)) = x3))

axiom width_pre_qtdef20 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. (width_pre_(Place(x,
  x1, x2)) = x2))

axiom width_pre_qtdef21 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  (width_pre_(Cont(x, x1, x2, x3)) = x3))

axiom width_pre_qtdef22 :
  (forall x:wired_circuit. forall x1:wired_circuit. (width_pre_(Sequence1(x,
  x1)) = width_pre_(x)))

axiom width_pre_qtdef23 :
  (forall x:wired_circuit. forall x1:wired_circuit. (width_pre_(Parallel1(x,
  x1)) = (width_pre_(x) + width_pre_(x1))))

axiom width_pre_qtdef24 :
  (forall x:wired_circuit. forall x1:int. (width_pre_(Ancillas1(x,
  x1)) = (width_pre_(x) - x1)))

logic build_correct_ : wired_circuit -> prop

axiom build_correct_qtdef : build_correct_(Skip)

axiom build_correct_qtdef1 : (forall w:int. build_correct_(Phase1(w)))

axiom build_correct_qtdef2 : (forall w:int. build_correct_(Rx(w)))

axiom build_correct_qtdef3 : (forall w:int. build_correct_(Ry(w)))

axiom build_correct_qtdef4 : (forall w:int. build_correct_(Rz1(w)))

axiom build_correct_qtdef5 : (forall w:int. build_correct_(Rzp(w)))

axiom build_correct_qtdef6 : build_correct_(Hadamard1)

axiom build_correct_qtdef7 : build_correct_(S)

axiom build_correct_qtdef8 : build_correct_(T)

axiom build_correct_qtdef9 : build_correct_(X)

axiom build_correct_qtdef10 : build_correct_(Y)

axiom build_correct_qtdef11 : build_correct_(Z)

axiom build_correct_qtdef12 : build_correct_(Bricks_Cnot)

axiom build_correct_qtdef13 : build_correct_(Bricks_Toffoli)

axiom build_correct_qtdef14 : build_correct_(Bricks_Fredkin)

axiom build_correct_qtdef15 : build_correct_(Bricks_Swap)

axiom build_correct_qtdef16 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct_(Swap1(t1, t2,
  n)) -> (0 <= t1)))

axiom build_correct_qtdef17 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct_(Swap1(t1, t2,
  n)) -> (t1 <  n)))

axiom build_correct_qtdef18 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct_(Swap1(t1, t2,
  n)) -> (0 <= t2)))

axiom build_correct_qtdef19 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct_(Swap1(t1, t2,
  n)) -> (t2 <  n)))

axiom build_correct_qtdef20 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct_(Swap1(t1, t2,
  n)) -> (not (t1 = t2))))

axiom build_correct_qtdef21 :
  (forall t1:int. forall t2:int. forall n:int. ((((0 <= t1) and
  (t1 <  n)) and (((0 <= t2) and (t2 <  n)) and (not (t1 = t2)))) ->
  build_correct_(Swap1(t1, t2, n))))

axiom build_correct_qtdef22 :
  (forall c:int. forall t:int. forall n:int. (build_correct_(Cnot1(c, t,
  n)) -> (0 <= c)))

axiom build_correct_qtdef23 :
  (forall c:int. forall t:int. forall n:int. (build_correct_(Cnot1(c, t,
  n)) -> (c <  n)))

axiom build_correct_qtdef24 :
  (forall c:int. forall t:int. forall n:int. (build_correct_(Cnot1(c, t,
  n)) -> (0 <= t)))

axiom build_correct_qtdef25 :
  (forall c:int. forall t:int. forall n:int. (build_correct_(Cnot1(c, t,
  n)) -> (t <  n)))

axiom build_correct_qtdef26 :
  (forall c:int. forall t:int. forall n:int. (build_correct_(Cnot1(c, t,
  n)) -> (not (c = t))))

axiom build_correct_qtdef27 :
  (forall c:int. forall t:int. forall n:int. ((((0 <= c) and (c <  n)) and
  (((0 <= t) and (t <  n)) and (not (c = t)))) -> build_correct_(Cnot1(c, t,
  n))))

axiom build_correct_qtdef28 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Toffoli(c1, c2, t, n)) -> (0 <= c1)))

axiom build_correct_qtdef29 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Toffoli(c1, c2, t, n)) -> (c1 <  n)))

axiom build_correct_qtdef30 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Toffoli(c1, c2, t, n)) -> (0 <= c2)))

axiom build_correct_qtdef31 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Toffoli(c1, c2, t, n)) -> (c2 <  n)))

axiom build_correct_qtdef32 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Toffoli(c1, c2, t, n)) -> (0 <= t)))

axiom build_correct_qtdef33 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Toffoli(c1, c2, t, n)) -> (t <  n)))

axiom build_correct_qtdef34 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Toffoli(c1, c2, t, n)) -> (not (c1 = t))))

axiom build_correct_qtdef35 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Toffoli(c1, c2, t, n)) -> (not (c2 = t))))

axiom build_correct_qtdef36 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Toffoli(c1, c2, t, n)) -> (not (c1 = c2))))

axiom build_correct_qtdef37 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. ((((0 <= c1) and
  (c1 <  n)) and (((0 <= c2) and (c2 <  n)) and (((0 <= t) and (t <  n)) and
  ((not (c1 = t)) and ((not (c2 = t)) and (not (c1 = c2))))))) ->
  build_correct_(Toffoli(c1, c2, t, n))))

axiom build_correct_qtdef38 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Fredkin(c1, c2, t, n)) -> (0 <= c1)))

axiom build_correct_qtdef39 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Fredkin(c1, c2, t, n)) -> (c1 <  n)))

axiom build_correct_qtdef40 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Fredkin(c1, c2, t, n)) -> (0 <= c2)))

axiom build_correct_qtdef41 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Fredkin(c1, c2, t, n)) -> (c2 <  n)))

axiom build_correct_qtdef42 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Fredkin(c1, c2, t, n)) -> (0 <= t)))

axiom build_correct_qtdef43 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Fredkin(c1, c2, t, n)) -> (t <  n)))

axiom build_correct_qtdef44 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Fredkin(c1, c2, t, n)) -> (not (c1 = t))))

axiom build_correct_qtdef45 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Fredkin(c1, c2, t, n)) -> (not (c2 = t))))

axiom build_correct_qtdef46 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct_(Fredkin(c1, c2, t, n)) -> (not (c1 = c2))))

axiom build_correct_qtdef47 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. ((((0 <= c1) and
  (c1 <  n)) and (((0 <= c2) and (c2 <  n)) and (((0 <= t) and (t <  n)) and
  ((not (c1 = t)) and ((not (c2 = t)) and (not (c1 = c2))))))) ->
  build_correct_(Fredkin(c1, c2, t, n))))

axiom build_correct_qtdef48 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  (build_correct_(Place(c, t, n)) -> build_correct_(c)))

axiom build_correct_qtdef49 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  (build_correct_(Place(c, t, n)) -> (0 <= t)))

axiom build_correct_qtdef50 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  (build_correct_(Place(c, t, n)) -> (t <  n)))

axiom build_correct_qtdef51 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  (build_correct_(Place(c, t, n)) -> ((t + width_pre_(c)) <= n)))

axiom build_correct_qtdef52 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  ((build_correct_(c) and (((0 <= t) and (t <  n)) and
  ((t + width_pre_(c)) <= n))) -> build_correct_(Place(c, t, n))))

axiom build_correct_qtdef53 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct_(Cont(c, co, t, n)) -> build_correct_(c)))

axiom build_correct_qtdef54 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct_(Cont(c, co, t, n)) -> (0 <= co)))

axiom build_correct_qtdef55 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct_(Cont(c, co, t, n)) -> (co <  n)))

axiom build_correct_qtdef56 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct_(Cont(c, co, t, n)) -> (0 <= t)))

axiom build_correct_qtdef57 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct_(Cont(c, co, t, n)) -> (t <= (n - width_pre_(c)))))

axiom build_correct_qtdef58 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct_(Cont(c, co, t, n)) -> ((co <  t) or
  ((t + width_pre_(c)) <= co))))

axiom build_correct_qtdef59 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  ((build_correct_(c) and (((0 <= co) and (co <  n)) and (((0 <= t) and
  (t <= (n - width_pre_(c)))) and ((co <  t) or
  ((t + width_pre_(c)) <= co))))) -> build_correct_(Cont(c, co, t, n))))

axiom build_correct_qtdef60 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct_(Sequence1(d, e)) -> (width_pre_(d) = width_pre_(e))))

axiom build_correct_qtdef61 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct_(Sequence1(d, e)) -> build_correct_(d)))

axiom build_correct_qtdef62 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct_(Sequence1(d, e)) -> build_correct_(e)))

axiom build_correct_qtdef63 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (((width_pre_(d) = width_pre_(e)) and (build_correct_(d) and
  build_correct_(e))) -> build_correct_(Sequence1(d, e))))

axiom build_correct_qtdef64 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct_(Parallel1(d, e)) -> build_correct_(d)))

axiom build_correct_qtdef65 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct_(Parallel1(d, e)) -> build_correct_(e)))

axiom build_correct_qtdef66 :
  (forall d:wired_circuit. forall e:wired_circuit. ((build_correct_(d) and
  build_correct_(e)) -> build_correct_(Parallel1(d, e))))

axiom build_correct_qtdef67 :
  (forall d:wired_circuit. forall i:int. (build_correct_(Ancillas1(d, i)) ->
  (1 <= i)))

axiom build_correct_qtdef68 :
  (forall d:wired_circuit. forall i:int. (build_correct_(Ancillas1(d, i)) ->
  ((i + 1) <= width_pre_(d))))

axiom build_correct_qtdef69 :
  (forall d:wired_circuit. forall i:int. (build_correct_(Ancillas1(d, i)) ->
  build_correct_(d)))

axiom build_correct_qtdef70 :
  (forall d:wired_circuit. forall i:int. (((1 <= i) and
  (((i + 1) <= width_pre_(d)) and build_correct_(d))) ->
  build_correct_(Ancillas1(d, i))))

logic width_pre1 : wired_circuit -> int

axiom width_preqtdef9 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = Skip) ->
  (width_pre1(c) = 1))))

axiom width_preqtdef10 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall w:int. ((c = Phase1(w)) -> (width_pre1(c) = 1)))))

axiom width_preqtdef11 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall w:int. ((c = Rx(w)) -> (width_pre1(c) = 1)))))

axiom width_preqtdef12 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall w:int. ((c = Ry(w)) -> (width_pre1(c) = 1)))))

axiom width_preqtdef13 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall w:int. ((c = Rz1(w)) -> (width_pre1(c) = 1)))))

axiom width_preqtdef14 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall w:int. ((c = Rzp(w)) -> (width_pre1(c) = 1)))))

axiom width_preqtdef15 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = Hadamard1) ->
  (width_pre1(c) = 1))))

axiom width_preqtdef16 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = S) ->
  (width_pre1(c) = 1))))

axiom width_preqtdef17 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = T) ->
  (width_pre1(c) = 1))))

axiom width_preqtdef18 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = X) ->
  (width_pre1(c) = 1))))

axiom width_preqtdef19 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = Y) ->
  (width_pre1(c) = 1))))

axiom width_preqtdef20 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = Z) ->
  (width_pre1(c) = 1))))

axiom width_preqtdef21 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = Bricks_Cnot) ->
  (width_pre1(c) = 2))))

axiom width_preqtdef22 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = Bricks_Toffoli) ->
  (width_pre1(c) = 3))))

axiom width_preqtdef23 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = Bricks_Fredkin) ->
  (width_pre1(c) = 3))))

axiom width_preqtdef24 :
  (forall c:wired_circuit. (build_correct_(c) -> ((c = Bricks_Swap) ->
  (width_pre1(c) = 2))))

axiom width_preqtdef25 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall x:int. forall x1:int. forall x2:int. ((c = Swap1(x, x1, x2)) ->
  (width_pre1(c) = x2)))))

axiom width_preqtdef26 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall x:int. forall x1:int. forall x2:int. ((c = Cnot1(x, x1, x2)) ->
  (width_pre1(c) = x2)))))

axiom width_preqtdef27 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  ((c = Toffoli(x, x1, x2, x3)) -> (width_pre1(c) = x3)))))

axiom width_preqtdef28 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  ((c = Fredkin(x, x1, x2, x3)) -> (width_pre1(c) = x3)))))

axiom width_preqtdef29 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((c = Place(x, x1,
  x2)) -> (width_pre1(c) = x2)))))

axiom width_preqtdef30 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((c = Cont(x, x1, x2, x3)) -> (width_pre1(c) = x3)))))

axiom width_preqtdef31 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Sequence1(x,
  x1)) -> (width_pre1(c) = width_pre1(x))))))

axiom width_preqtdef32 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Parallel1(x,
  x1)) -> (width_pre1(c) = (width_pre1(x) + width_pre1(x1)))))))

axiom width_preqtdef33 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (forall x:wired_circuit. forall x1:int. ((c = Ancillas1(x, x1)) ->
  (width_pre1(c) = (width_pre1(x) - x1))))))

axiom width_preqtspec :
  (forall c:wired_circuit. (build_correct_(c) -> (1 <= width_pre1(c))))

axiom width_preqtspec1 :
  (forall c:wired_circuit. (build_correct_(c) ->
  (width_pre1(c) = width_pre_(c))))

logic build_correct1 : wired_circuit -> prop

axiom build_correctqtdef17 : build_correct1(Skip)

axiom build_correctqtdef18 : (forall w:int. build_correct1(Phase1(w)))

axiom build_correctqtdef19 : (forall w:int. build_correct1(Rx(w)))

axiom build_correctqtdef20 : (forall w:int. build_correct1(Ry(w)))

axiom build_correctqtdef21 : (forall w:int. build_correct1(Rz1(w)))

axiom build_correctqtdef22 : (forall w:int. build_correct1(Rzp(w)))

axiom build_correctqtdef23 : build_correct1(Hadamard1)

axiom build_correctqtdef24 : build_correct1(S)

axiom build_correctqtdef25 : build_correct1(T)

axiom build_correctqtdef26 : build_correct1(X)

axiom build_correctqtdef27 : build_correct1(Y)

axiom build_correctqtdef28 : build_correct1(Z)

axiom build_correctqtdef29 : build_correct1(Bricks_Cnot)

axiom build_correctqtdef30 : build_correct1(Bricks_Toffoli)

axiom build_correctqtdef31 : build_correct1(Bricks_Fredkin)

axiom build_correctqtdef32 : build_correct1(Bricks_Swap)

axiom build_correctqtdef33 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct1(Swap1(t1, t2,
  n)) -> (0 <= t1)))

axiom build_correctqtdef34 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct1(Swap1(t1, t2,
  n)) -> (t1 <  n)))

axiom build_correctqtdef35 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct1(Swap1(t1, t2,
  n)) -> (0 <= t2)))

axiom build_correctqtdef36 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct1(Swap1(t1, t2,
  n)) -> (t2 <  n)))

axiom build_correctqtdef37 :
  (forall t1:int. forall t2:int. forall n:int. (build_correct1(Swap1(t1, t2,
  n)) -> (not (t1 = t2))))

axiom build_correctqtdef38 :
  (forall t1:int. forall t2:int. forall n:int. ((((0 <= t1) and
  (t1 <  n)) and (((0 <= t2) and (t2 <  n)) and (not (t1 = t2)))) ->
  build_correct1(Swap1(t1, t2, n))))

axiom build_correctqtdef39 :
  (forall c:int. forall t:int. forall n:int. (build_correct1(Cnot1(c, t,
  n)) -> (0 <= c)))

axiom build_correctqtdef40 :
  (forall c:int. forall t:int. forall n:int. (build_correct1(Cnot1(c, t,
  n)) -> (c <  n)))

axiom build_correctqtdef41 :
  (forall c:int. forall t:int. forall n:int. (build_correct1(Cnot1(c, t,
  n)) -> (0 <= t)))

axiom build_correctqtdef42 :
  (forall c:int. forall t:int. forall n:int. (build_correct1(Cnot1(c, t,
  n)) -> (t <  n)))

axiom build_correctqtdef43 :
  (forall c:int. forall t:int. forall n:int. (build_correct1(Cnot1(c, t,
  n)) -> (not (c = t))))

axiom build_correctqtdef44 :
  (forall c:int. forall t:int. forall n:int. ((((0 <= c) and (c <  n)) and
  (((0 <= t) and (t <  n)) and (not (c = t)))) -> build_correct1(Cnot1(c, t,
  n))))

axiom build_correctqtdef45 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Toffoli(c1, c2, t, n)) -> (0 <= c1)))

axiom build_correctqtdef46 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Toffoli(c1, c2, t, n)) -> (c1 <  n)))

axiom build_correctqtdef47 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Toffoli(c1, c2, t, n)) -> (0 <= c2)))

axiom build_correctqtdef48 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Toffoli(c1, c2, t, n)) -> (c2 <  n)))

axiom build_correctqtdef49 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Toffoli(c1, c2, t, n)) -> (0 <= t)))

axiom build_correctqtdef50 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Toffoli(c1, c2, t, n)) -> (t <  n)))

axiom build_correctqtdef51 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Toffoli(c1, c2, t, n)) -> (not (c1 = t))))

axiom build_correctqtdef52 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Toffoli(c1, c2, t, n)) -> (not (c2 = t))))

axiom build_correctqtdef53 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Toffoli(c1, c2, t, n)) -> (not (c1 = c2))))

axiom build_correctqtdef54 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. ((((0 <= c1) and
  (c1 <  n)) and (((0 <= c2) and (c2 <  n)) and (((0 <= t) and (t <  n)) and
  ((not (c1 = t)) and ((not (c2 = t)) and (not (c1 = c2))))))) ->
  build_correct1(Toffoli(c1, c2, t, n))))

axiom build_correctqtdef55 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Fredkin(c1, c2, t, n)) -> (0 <= c1)))

axiom build_correctqtdef56 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Fredkin(c1, c2, t, n)) -> (c1 <  n)))

axiom build_correctqtdef57 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Fredkin(c1, c2, t, n)) -> (0 <= c2)))

axiom build_correctqtdef58 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Fredkin(c1, c2, t, n)) -> (c2 <  n)))

axiom build_correctqtdef59 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Fredkin(c1, c2, t, n)) -> (0 <= t)))

axiom build_correctqtdef60 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Fredkin(c1, c2, t, n)) -> (t <  n)))

axiom build_correctqtdef61 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Fredkin(c1, c2, t, n)) -> (not (c1 = t))))

axiom build_correctqtdef62 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Fredkin(c1, c2, t, n)) -> (not (c2 = t))))

axiom build_correctqtdef63 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  (build_correct1(Fredkin(c1, c2, t, n)) -> (not (c1 = c2))))

axiom build_correctqtdef64 :
  (forall c1:int. forall c2:int. forall t:int. forall n:int. ((((0 <= c1) and
  (c1 <  n)) and (((0 <= c2) and (c2 <  n)) and (((0 <= t) and (t <  n)) and
  ((not (c1 = t)) and ((not (c2 = t)) and (not (c1 = c2))))))) ->
  build_correct1(Fredkin(c1, c2, t, n))))

axiom build_correctqtdef65 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  (build_correct1(Place(c, t, n)) -> build_correct1(c)))

axiom build_correctqtdef66 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  (build_correct1(Place(c, t, n)) -> (0 <= t)))

axiom build_correctqtdef67 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  (build_correct1(Place(c, t, n)) -> (t <  n)))

axiom build_correctqtdef68 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  (build_correct1(Place(c, t, n)) -> ((t + width_pre1(c)) <= n)))

axiom build_correctqtdef69 :
  (forall c:wired_circuit. forall t:int. forall n:int.
  ((build_correct1(c) and (((0 <= t) and (t <  n)) and
  ((t + width_pre1(c)) <= n))) -> build_correct1(Place(c, t, n))))

axiom build_correctqtdef70 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct1(Cont(c, co, t, n)) -> build_correct1(c)))

axiom build_correctqtdef71 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct1(Cont(c, co, t, n)) -> (0 <= co)))

axiom build_correctqtdef72 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct1(Cont(c, co, t, n)) -> (co <  n)))

axiom build_correctqtdef73 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct1(Cont(c, co, t, n)) -> (0 <= t)))

axiom build_correctqtdef74 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct1(Cont(c, co, t, n)) -> (t <= (n - width_pre1(c)))))

axiom build_correctqtdef75 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  (build_correct1(Cont(c, co, t, n)) -> ((co <  t) or
  ((t + width_pre1(c)) <= co))))

axiom build_correctqtdef76 :
  (forall c:wired_circuit. forall co:int. forall t:int. forall n:int.
  ((build_correct1(c) and (((0 <= co) and (co <  n)) and (((0 <= t) and
  (t <= (n - width_pre1(c)))) and ((co <  t) or
  ((t + width_pre1(c)) <= co))))) -> build_correct1(Cont(c, co, t, n))))

axiom build_correctqtdef77 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct1(Sequence1(d, e)) -> build_correct1(d)))

axiom build_correctqtdef78 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct1(Sequence1(d, e)) -> build_correct1(e)))

axiom build_correctqtdef79 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct1(Sequence1(d, e)) -> (width_pre1(d) = width_pre1(e))))

axiom build_correctqtdef80 :
  (forall d:wired_circuit. forall e:wired_circuit. ((build_correct1(d) and
  (build_correct1(e) and (width_pre1(d) = width_pre1(e)))) ->
  build_correct1(Sequence1(d, e))))

axiom build_correctqtdef81 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct1(Parallel1(d, e)) -> build_correct1(d)))

axiom build_correctqtdef82 :
  (forall d:wired_circuit. forall e:wired_circuit.
  (build_correct1(Parallel1(d, e)) -> build_correct1(e)))

axiom build_correctqtdef83 :
  (forall d:wired_circuit. forall e:wired_circuit. ((build_correct1(d) and
  build_correct1(e)) -> build_correct1(Parallel1(d, e))))

axiom build_correctqtdef84 :
  (forall d:wired_circuit. forall i:int. (build_correct1(Ancillas1(d, i)) ->
  build_correct1(d)))

axiom build_correctqtdef85 :
  (forall d:wired_circuit. forall i:int. (build_correct1(Ancillas1(d, i)) ->
  (1 <= i)))

axiom build_correctqtdef86 :
  (forall d:wired_circuit. forall i:int. (build_correct1(Ancillas1(d, i)) ->
  ((i + 1) <= width_pre1(d))))

axiom build_correctqtdef87 :
  (forall d:wired_circuit. forall i:int. ((build_correct1(d) and
  ((1 <= i) and ((i + 1) <= width_pre1(d)))) -> build_correct1(Ancillas1(d,
  i))))

axiom build_correctqtspec :
  (forall c:wired_circuit. (build_correct1(c) -> build_correct_(c)))

axiom build_correctqtspec1 :
  (forall c:wired_circuit. (build_correct_(c) -> build_correct1(c)))

logic depth_pre : wired_circuit -> int

axiom depth_preqtdef :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Skip) ->
  (depth_pre(c) = 0))))

axiom depth_preqtdef1 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Phase1(w)) -> (depth_pre(c) = 1)))))

axiom depth_preqtdef2 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rx(w)) -> (depth_pre(c) = 1)))))

axiom depth_preqtdef3 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Ry(w)) -> (depth_pre(c) = 1)))))

axiom depth_preqtdef4 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rz1(w)) -> (depth_pre(c) = 1)))))

axiom depth_preqtdef5 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rzp(w)) -> (depth_pre(c) = 1)))))

axiom depth_preqtdef6 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Hadamard1) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef7 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = S) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef8 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = T) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef9 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = X) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef10 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Y) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef11 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Z) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef12 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Cnot) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef13 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Toffoli) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef14 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Fredkin) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef15 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Swap) ->
  (depth_pre(c) = 1))))

axiom depth_preqtdef16 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. ((c = Swap1(w, w1, w2)) ->
  (depth_pre(c) = 1)))))

axiom depth_preqtdef17 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. ((c = Cnot1(w, w1, w2)) ->
  (depth_pre(c) = 1)))))

axiom depth_preqtdef18 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((c = Toffoli(w, w1, w2, w3)) -> (depth_pre(c) = 1)))))

axiom depth_preqtdef19 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((c = Fredkin(w, w1, w2, w3)) -> (depth_pre(c) = 1)))))

axiom depth_preqtdef20 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((c = Place(x, x1,
  x2)) -> (depth_pre(c) = depth_pre(x))))))

axiom depth_preqtdef21 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((c = Cont(x, x1, x2, x3)) -> (depth_pre(c) = depth_pre(x))))))

axiom depth_preqtdef22 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Sequence1(x,
  x1)) -> (depth_pre(c) = (depth_pre(x) + depth_pre(x1)))))))

axiom depth_preqtdef23 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Parallel1(x,
  x1)) -> (depth_pre(c) = max(depth_pre(x), depth_pre(x1)))))))

axiom depth_preqtdef24 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. ((c = Ancillas1(x, x1)) ->
  (depth_pre(c) = depth_pre(x))))))

logic cont_size1 : int

axiom cont_sizeqtdef1 : (1 <= cont_size1)

logic ancillas_pre : wired_circuit -> int

axiom ancillas_preqtdef :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Skip) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef1 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Phase1(w)) -> (ancillas_pre(c) = 0)))))

axiom ancillas_preqtdef2 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rx(w)) -> (ancillas_pre(c) = 0)))))

axiom ancillas_preqtdef3 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Ry(w)) -> (ancillas_pre(c) = 0)))))

axiom ancillas_preqtdef4 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rz1(w)) -> (ancillas_pre(c) = 0)))))

axiom ancillas_preqtdef5 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rzp(w)) -> (ancillas_pre(c) = 0)))))

axiom ancillas_preqtdef6 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Hadamard1) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef7 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = S) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef8 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = T) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef9 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = X) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef10 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Y) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef11 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Z) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef12 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Cnot) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef13 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Toffoli) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef14 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Fredkin) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef15 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Swap) ->
  (ancillas_pre(c) = 0))))

axiom ancillas_preqtdef16 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. ((c = Swap1(w, w1, w2)) ->
  (ancillas_pre(c) = 0)))))

axiom ancillas_preqtdef17 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. ((c = Cnot1(w, w1, w2)) ->
  (ancillas_pre(c) = 0)))))

axiom ancillas_preqtdef18 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((c = Toffoli(w, w1, w2, w3)) -> (ancillas_pre(c) = 0)))))

axiom ancillas_preqtdef19 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((c = Fredkin(w, w1, w2, w3)) -> (ancillas_pre(c) = 0)))))

axiom ancillas_preqtdef20 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((c = Place(x, x1,
  x2)) -> (ancillas_pre(c) = ancillas_pre(x))))))

axiom ancillas_preqtdef21 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((c = Cont(x, x1, x2, x3)) -> (ancillas_pre(c) = ancillas_pre(x))))))

axiom ancillas_preqtdef22 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Sequence1(x,
  x1)) -> (ancillas_pre(c) = max(ancillas_pre(x), ancillas_pre(x1)))))))

axiom ancillas_preqtdef23 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Parallel1(x,
  x1)) -> (ancillas_pre(c) = (ancillas_pre(x) + ancillas_pre(x1)))))))

axiom ancillas_preqtdef24 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. ((c = Ancillas1(x, x1)) ->
  (ancillas_pre(c) = (ancillas_pre(x) + x1))))))

axiom ancillas_preqtspec :
  (forall c:wired_circuit. (build_correct1(c) -> (0 <= ancillas_pre(c))))

predicate atomic(c: wired_circuit) = ((((((((((((((not (c = Skip)) and
  (not (c = Bricks_Cnot))) and (not (c = Bricks_Toffoli))) and
  (not (c = Bricks_Fredkin))) and (not (c = Bricks_Swap))) and
  (forall w:int. forall w1:int. forall w2:int. (not (c = Swap1(w, w1, w2))))) and
  (forall w:int. forall w1:int. forall w2:int. (not (c = Cnot1(w, w1, w2))))) and
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  (not (c = Toffoli(w, w1, w2, w3))))) and
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  (not (c = Fredkin(w, w1, w2, w3))))) and
  (forall w:wired_circuit. forall w1:int. forall w2:int. (not (c = Place(w,
  w1, w2))))) and
  (forall w:wired_circuit. forall w1:int. forall w2:int. forall w3:int.
  (not (c = Cont(w, w1, w2, w3))))) and
  (forall w:wired_circuit. forall w1:wired_circuit. (not (c = Sequence1(w,
  w1))))) and
  (forall w:wired_circuit. forall w1:wired_circuit. (not (c = Parallel1(w,
  w1))))) and
  (forall w:wired_circuit. forall w1:int. (not (c = Ancillas1(w, w1)))))

logic size_pre : wired_circuit -> int

axiom size_preqtdef :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Skip) ->
  (size_pre(c) = 0))))

axiom size_preqtdef1 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Phase1(w)) -> (size_pre(c) = 1)))))

axiom size_preqtdef2 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rx(w)) -> (size_pre(c) = 1)))))

axiom size_preqtdef3 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Ry(w)) -> (size_pre(c) = 1)))))

axiom size_preqtdef4 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rz1(w)) -> (size_pre(c) = 1)))))

axiom size_preqtdef5 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rzp(w)) -> (size_pre(c) = 1)))))

axiom size_preqtdef6 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Hadamard1) ->
  (size_pre(c) = 1))))

axiom size_preqtdef7 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = S) ->
  (size_pre(c) = 1))))

axiom size_preqtdef8 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = T) ->
  (size_pre(c) = 1))))

axiom size_preqtdef9 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = X) ->
  (size_pre(c) = 1))))

axiom size_preqtdef10 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Y) ->
  (size_pre(c) = 1))))

axiom size_preqtdef11 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Z) ->
  (size_pre(c) = 1))))

axiom size_preqtdef12 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Cnot) ->
  (size_pre(c) = 1))))

axiom size_preqtdef13 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Toffoli) ->
  (size_pre(c) = 1))))

axiom size_preqtdef14 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Fredkin) ->
  (size_pre(c) = 1))))

axiom size_preqtdef15 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Swap) ->
  (size_pre(c) = 1))))

axiom size_preqtdef16 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. ((c = Swap1(w, w1, w2)) ->
  (size_pre(c) = 1)))))

axiom size_preqtdef17 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. ((c = Cnot1(w, w1, w2)) ->
  (size_pre(c) = 1)))))

axiom size_preqtdef18 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((c = Toffoli(w, w1, w2, w3)) -> (size_pre(c) = 1)))))

axiom size_preqtdef19 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((c = Fredkin(w, w1, w2, w3)) -> (size_pre(c) = 1)))))

axiom size_preqtdef20 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((c = Place(x, x1,
  x2)) -> (size_pre(c) = size_pre(x))))))

axiom size_preqtdef21 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((c = Cont(x, x1, x2, x3)) -> (size_pre(c) = (size_pre(x) * cont_size1))))))

axiom size_preqtdef22 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Sequence1(x,
  x1)) -> (size_pre(c) = (size_pre(x) + size_pre(x1)))))))

axiom size_preqtdef23 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Parallel1(x,
  x1)) -> (size_pre(c) = (size_pre(x) + size_pre(x1)))))))

axiom size_preqtdef24 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. ((c = Ancillas1(x, x1)) ->
  (size_pre(c) = size_pre(x))))))

logic range_pre : wired_circuit -> int

axiom range_preqtdef :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Skip) ->
  (range_pre(c) = 0))))

axiom range_preqtdef1 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Phase1(w)) -> (range_pre(c) = 0)))))

axiom range_preqtdef2 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. ((c = Rx(x)) -> (range_pre(c) = 2)))))

axiom range_preqtdef3 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. ((c = Ry(x)) -> (range_pre(c) = 2)))))

axiom range_preqtdef4 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rz1(w)) -> (range_pre(c) = 0)))))

axiom range_preqtdef5 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. ((c = Rzp(w)) -> (range_pre(c) = 0)))))

axiom range_preqtdef6 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Hadamard1) ->
  (range_pre(c) = 1))))

axiom range_preqtdef7 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = S) ->
  (range_pre(c) = 0))))

axiom range_preqtdef8 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = T) ->
  (range_pre(c) = 0))))

axiom range_preqtdef9 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = X) ->
  (range_pre(c) = 0))))

axiom range_preqtdef10 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Y) ->
  (range_pre(c) = 0))))

axiom range_preqtdef11 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Z) ->
  (range_pre(c) = 0))))

axiom range_preqtdef12 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Cnot) ->
  (range_pre(c) = 0))))

axiom range_preqtdef13 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Toffoli) ->
  (range_pre(c) = 0))))

axiom range_preqtdef14 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Fredkin) ->
  (range_pre(c) = 0))))

axiom range_preqtdef15 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Swap) ->
  (range_pre(c) = 0))))

axiom range_preqtdef16 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. ((c = Swap1(w, w1, w2)) ->
  (range_pre(c) = 0)))))

axiom range_preqtdef17 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. ((c = Cnot1(w, w1, w2)) ->
  (range_pre(c) = 0)))))

axiom range_preqtdef18 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((c = Toffoli(w, w1, w2, w3)) -> (range_pre(c) = 0)))))

axiom range_preqtdef19 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((c = Fredkin(w, w1, w2, w3)) -> (range_pre(c) = 0)))))

axiom range_preqtdef20 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((c = Place(x, x1,
  x2)) -> (range_pre(c) = range_pre(x))))))

axiom range_preqtdef21 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((c = Cont(x, x1, x2, x3)) -> (range_pre(c) = range_pre(x))))))

axiom range_preqtdef22 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Sequence1(x,
  x1)) -> (range_pre(c) = (range_pre(x) + range_pre(x1)))))))

axiom range_preqtdef23 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Parallel1(x,
  x1)) -> (range_pre(c) = (range_pre(x) + range_pre(x1)))))))

axiom range_preqtdef24 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. ((c = Ancillas1(x, x1)) ->
  (range_pre(c) = range_pre(x))))))

axiom range_preqtspec :
  (forall c:wired_circuit. (build_correct1(c) -> (0 <= range_pre(c))))

logic circ_to_pps_pre1 : wired_circuit -> pps

axiom circ_to_pps_preqtdef9 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Skip) ->
  (circ_to_pps_pre1(c) = pps_id))))

axiom circ_to_pps_preqtdef10 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall k:int. ((c = Phase1(k)) -> (circ_to_pps_pre1(c) = pps_phase(k))))))

axiom circ_to_pps_preqtdef11 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall k:int. ((c = Rx(k)) -> (circ_to_pps_pre1(c) = pps_rx(k))))))

axiom circ_to_pps_preqtdef12 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall k:int. ((c = Ry(k)) -> (circ_to_pps_pre1(c) = pps_ry(k))))))

axiom circ_to_pps_preqtdef13 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall k:int. ((c = Rz1(k)) -> (circ_to_pps_pre1(c) = pps_rz_b(k))))))

axiom circ_to_pps_preqtdef14 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall k:int. ((c = Rzp(k)) -> (circ_to_pps_pre1(c) = pps_rz(k))))))

axiom circ_to_pps_preqtdef15 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Hadamard1) ->
  (circ_to_pps_pre1(c) = pps_hadamard))))

axiom circ_to_pps_preqtdef16 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = S) ->
  (circ_to_pps_pre1(c) = pps_rz(2)))))

axiom circ_to_pps_preqtdef17 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = T) ->
  (circ_to_pps_pre1(c) = pps_rz(3)))))

axiom circ_to_pps_preqtdef18 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = X) ->
  (circ_to_pps_pre1(c) = pps_xx))))

axiom circ_to_pps_preqtdef19 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Y) ->
  (circ_to_pps_pre1(c) = pps_yy))))

axiom circ_to_pps_preqtdef20 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Z) ->
  (circ_to_pps_pre1(c) = pps_zz))))

axiom circ_to_pps_preqtdef21 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Cnot) ->
  (circ_to_pps_pre1(c) = pps_cnot(0, 1, 2)))))

axiom circ_to_pps_preqtdef22 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Toffoli) ->
  (circ_to_pps_pre1(c) = pps_toffoli(0, 1, 2, 3)))))

axiom circ_to_pps_preqtdef23 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Fredkin) ->
  (circ_to_pps_pre1(c) = pps_fredkin(0, 1, 2, 3)))))

axiom circ_to_pps_preqtdef24 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Swap) ->
  (circ_to_pps_pre1(c) = pps_swap(0, 1, 2)))))

axiom circ_to_pps_preqtdef25 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall t1:int. forall t2:int. forall n:int. ((c = Swap1(t1, t2, n)) ->
  (circ_to_pps_pre1(c) = pps_swap(t1, t2, n))))))

axiom circ_to_pps_preqtdef26 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall c1:int. forall t:int. forall n:int. ((c = Cnot1(c1, t, n)) ->
  (circ_to_pps_pre1(c) = pps_cnot(c1, t, n))))))

axiom circ_to_pps_preqtdef27 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  ((c = Toffoli(c1, c2, t, n)) -> (circ_to_pps_pre1(c) = pps_toffoli(c1, c2,
  t, n))))))

axiom circ_to_pps_preqtdef28 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  ((c = Fredkin(c1, c2, t, n)) -> (circ_to_pps_pre1(c) = pps_fredkin(c1, c2,
  t, n))))))

axiom circ_to_pps_preqtdef29 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall c1:wired_circuit. forall t:int. forall n:int. ((c = Place(c1, t,
  n)) -> (circ_to_pps_pre1(c) = pps_place(circ_to_pps_pre1(c1), t, n))))))

axiom circ_to_pps_preqtdef30 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall c1:wired_circuit. forall co:int. forall t:int. forall n:int.
  ((c = Cont(c1, co, t, n)) ->
  (circ_to_pps_pre1(c) = pps_cont(circ_to_pps_pre1(c1), co, t, n))))))

axiom circ_to_pps_preqtdef31 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall d:wired_circuit. forall e:wired_circuit. ((c = Sequence1(d, e)) ->
  (circ_to_pps_pre1(c) = pps_seq(circ_to_pps_pre1(d), circ_to_pps_pre1(e)))))))

axiom circ_to_pps_preqtdef32 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall d:wired_circuit. forall e:wired_circuit. ((c = Parallel1(d, e)) ->
  (circ_to_pps_pre1(c) = pps_par(circ_to_pps_pre1(d), circ_to_pps_pre1(e)))))))

axiom circ_to_pps_preqtdef33 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall d:wired_circuit. forall i:int. ((c = Ancillas1(d, i)) ->
  (circ_to_pps_pre1(c) = pps_ancs(circ_to_pps_pre1(d), i))))))

axiom circ_to_pps_preqtspec2 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (1 <= h_width(circ_to_pps_pre1(c)))))

axiom circ_to_pps_preqtspec3 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (h_width(circ_to_pps_pre1(c)) = width_pre1(c))))

axiom circ_to_pps_preqtspec4 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (h_range(circ_to_pps_pre1(c)) = range_pre(c))))

logic ancillable : wired_circuit, int -> prop

axiom ancillableqtspec :
  (forall c:wired_circuit. forall i:int. (ancillable(c, i) ->
  (exists path_sem_target:(complex matrix,complex matrix) farray.
  (forall x:complex matrix. (is_a_ket_l(x, (width_pre1(c) - i)) ->
  (pps_apply(circ_to_pps_pre1(c), kronecker(x, ket(i,
  0))) = kronecker((path_sem_target[x]), ket(i, 0))))))))

axiom ancillableqtspec1 :
  (forall c:wired_circuit. forall i:int.
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width_pre1(c) - i)) ->
   (pps_apply(circ_to_pps_pre1(c), kronecker(x, ket(i,
   0))) = kronecker((path_sem_target[x]), ket(i, 0)))))) ->
  ancillable(c, i)))

logic correct1 : wired_circuit -> prop

axiom correctqtdef18 : correct1(Skip)

axiom correctqtdef19 : (forall x:int. correct1(Phase1(x)))

axiom correctqtdef20 : (forall x:int. correct1(Rx(x)))

axiom correctqtdef21 : (forall x:int. correct1(Ry(x)))

axiom correctqtdef22 : (forall x:int. correct1(Rz1(x)))

axiom correctqtdef23 : (forall x:int. correct1(Rzp(x)))

axiom correctqtdef24 : correct1(Hadamard1)

axiom correctqtdef25 : correct1(S)

axiom correctqtdef26 : correct1(T)

axiom correctqtdef27 : correct1(X)

axiom correctqtdef28 : correct1(Y)

axiom correctqtdef29 : correct1(Z)

axiom correctqtdef30 : correct1(Bricks_Cnot)

axiom correctqtdef31 : correct1(Bricks_Toffoli)

axiom correctqtdef32 : correct1(Bricks_Fredkin)

axiom correctqtdef33 : correct1(Bricks_Swap)

axiom correctqtdef34 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Swap1(x, x1, x2)) ->
  (0 <= x)))

axiom correctqtdef35 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Swap1(x, x1, x2)) ->
  (x <  x2)))

axiom correctqtdef36 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Swap1(x, x1, x2)) ->
  (0 <= x1)))

axiom correctqtdef37 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Swap1(x, x1, x2)) ->
  (x1 <  x2)))

axiom correctqtdef38 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Swap1(x, x1, x2)) ->
  (not (x = x1))))

axiom correctqtdef39 :
  (forall x:int. forall x1:int. forall x2:int. ((((0 <= x) and (x <  x2)) and
  (((0 <= x1) and (x1 <  x2)) and (not (x = x1)))) -> correct1(Swap1(x, x1,
  x2))))

axiom correctqtdef40 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Cnot1(x, x1, x2)) ->
  (0 <= x)))

axiom correctqtdef41 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Cnot1(x, x1, x2)) ->
  (x <  x2)))

axiom correctqtdef42 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Cnot1(x, x1, x2)) ->
  (0 <= x1)))

axiom correctqtdef43 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Cnot1(x, x1, x2)) ->
  (x1 <  x2)))

axiom correctqtdef44 :
  (forall x:int. forall x1:int. forall x2:int. (correct1(Cnot1(x, x1, x2)) ->
  (not (x = x1))))

axiom correctqtdef45 :
  (forall x:int. forall x1:int. forall x2:int. ((((0 <= x) and (x <  x2)) and
  (((0 <= x1) and (x1 <  x2)) and (not (x = x1)))) -> correct1(Cnot1(x, x1,
  x2))))

axiom correctqtdef46 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Toffoli(x, x1, x2, x3)) -> (0 <= x)))

axiom correctqtdef47 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Toffoli(x, x1, x2, x3)) -> (x <  x3)))

axiom correctqtdef48 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Toffoli(x, x1, x2, x3)) -> (0 <= x1)))

axiom correctqtdef49 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Toffoli(x, x1, x2, x3)) -> (x1 <  x3)))

axiom correctqtdef50 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Toffoli(x, x1, x2, x3)) -> (0 <= x2)))

axiom correctqtdef51 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Toffoli(x, x1, x2, x3)) -> (x2 <  x3)))

axiom correctqtdef52 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Toffoli(x, x1, x2, x3)) -> (not (x = x2))))

axiom correctqtdef53 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Toffoli(x, x1, x2, x3)) -> (not (x1 = x2))))

axiom correctqtdef54 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Toffoli(x, x1, x2, x3)) -> (not (x = x1))))

axiom correctqtdef55 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int. ((((0 <= x) and
  (x <  x3)) and (((0 <= x1) and (x1 <  x3)) and (((0 <= x2) and
  (x2 <  x3)) and ((not (x = x2)) and ((not (x1 = x2)) and
  (not (x = x1))))))) -> correct1(Toffoli(x, x1, x2, x3))))

axiom correctqtdef56 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Fredkin(x, x1, x2, x3)) -> (0 <= x)))

axiom correctqtdef57 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Fredkin(x, x1, x2, x3)) -> (x <  x3)))

axiom correctqtdef58 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Fredkin(x, x1, x2, x3)) -> (0 <= x1)))

axiom correctqtdef59 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Fredkin(x, x1, x2, x3)) -> (x1 <  x3)))

axiom correctqtdef60 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Fredkin(x, x1, x2, x3)) -> (0 <= x2)))

axiom correctqtdef61 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Fredkin(x, x1, x2, x3)) -> (x2 <  x3)))

axiom correctqtdef62 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Fredkin(x, x1, x2, x3)) -> (not (x = x2))))

axiom correctqtdef63 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Fredkin(x, x1, x2, x3)) -> (not (x1 = x2))))

axiom correctqtdef64 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Fredkin(x, x1, x2, x3)) -> (not (x = x1))))

axiom correctqtdef65 :
  (forall x:int. forall x1:int. forall x2:int. forall x3:int. ((((0 <= x) and
  (x <  x3)) and (((0 <= x1) and (x1 <  x3)) and (((0 <= x2) and
  (x2 <  x3)) and ((not (x = x2)) and ((not (x1 = x2)) and
  (not (x = x1))))))) -> correct1(Fredkin(x, x1, x2, x3))))

axiom correctqtdef66 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. (correct1(Place(x,
  x1, x2)) -> correct1(x)))

axiom correctqtdef67 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. (correct1(Place(x,
  x1, x2)) -> (0 <= x1)))

axiom correctqtdef68 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. (correct1(Place(x,
  x1, x2)) -> (x1 <= x2)))

axiom correctqtdef69 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. (correct1(Place(x,
  x1, x2)) -> ((x1 + width_pre1(x)) <= x2)))

axiom correctqtdef70 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((correct1(x) and
  (((0 <= x1) and (x1 <= x2)) and ((x1 + width_pre1(x)) <= x2))) ->
  correct1(Place(x, x1, x2))))

axiom correctqtdef71 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Cont(x, x1, x2, x3)) -> correct1(x)))

axiom correctqtdef72 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Cont(x, x1, x2, x3)) -> (0 <= x1)))

axiom correctqtdef73 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Cont(x, x1, x2, x3)) -> (x1 <  x3)))

axiom correctqtdef74 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Cont(x, x1, x2, x3)) -> (0 <= x2)))

axiom correctqtdef75 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Cont(x, x1, x2, x3)) -> (x2 <= (x3 - width_pre1(x)))))

axiom correctqtdef76 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  (correct1(Cont(x, x1, x2, x3)) -> ((x1 <  x2) or
  ((x2 + width_pre1(x)) <= x1))))

axiom correctqtdef77 :
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((correct1(x) and (((0 <= x1) and (x1 <  x3)) and (((0 <= x2) and
  (x2 <= (x3 - width_pre1(x)))) and ((x1 <  x2) or
  ((x2 + width_pre1(x)) <= x1))))) -> correct1(Cont(x, x1, x2, x3))))

axiom correctqtdef78 :
  (forall x:wired_circuit. forall x1:wired_circuit. (correct1(Sequence1(x,
  x1)) -> correct1(x)))

axiom correctqtdef79 :
  (forall x:wired_circuit. forall x1:wired_circuit. (correct1(Sequence1(x,
  x1)) -> correct1(x1)))

axiom correctqtdef80 :
  (forall x:wired_circuit. forall x1:wired_circuit. (correct1(Sequence1(x,
  x1)) -> (width_pre1(x) = width_pre1(x1))))

axiom correctqtdef81 :
  (forall x:wired_circuit. forall x1:wired_circuit. ((correct1(x) and
  (correct1(x1) and (width_pre1(x) = width_pre1(x1)))) ->
  correct1(Sequence1(x, x1))))

axiom correctqtdef82 :
  (forall x:wired_circuit. forall x1:wired_circuit. (correct1(Parallel1(x,
  x1)) -> correct1(x)))

axiom correctqtdef83 :
  (forall x:wired_circuit. forall x1:wired_circuit. (correct1(Parallel1(x,
  x1)) -> correct1(x1)))

axiom correctqtdef84 :
  (forall x:wired_circuit. forall x1:wired_circuit. ((correct1(x) and
  correct1(x1)) -> correct1(Parallel1(x, x1))))

axiom correctqtdef85 :
  (forall x:wired_circuit. forall x1:int. (correct1(Ancillas1(x, x1)) ->
  correct1(x)))

axiom correctqtdef86 :
  (forall x:wired_circuit. forall x1:int. (correct1(Ancillas1(x, x1)) ->
  (1 <= x1)))

axiom correctqtdef87 :
  (forall x:wired_circuit. forall x1:int. (correct1(Ancillas1(x, x1)) ->
  ((x1 + 1) <= width_pre1(x))))

axiom correctqtdef88 :
  (forall x:wired_circuit. forall x1:int. (correct1(Ancillas1(x, x1)) ->
  ancillable(x, x1)))

axiom correctqtdef89 :
  (forall x:wired_circuit. forall x1:int. ((correct1(x) and ((1 <= x1) and
  (((x1 + 1) <= width_pre1(x)) and ancillable(x, x1)))) ->
  correct1(Ancillas1(x, x1))))

axiom correctqtspec1 :
  (forall c:wired_circuit. (correct1(c) -> build_correct_(c)))

type circuit1

logic pre1 : circuit1 -> wired_circuit

axiom circuitqtinvariant1 :
  (forall self:circuit1 [pre1(self)]. correct1(pre1(self)))

axiom injective_pre1 :
  (forall c:circuit1. forall cqt:circuit1. ((not (c = cqt)) ->
  (not (pre1(c) = pre1(cqt)))))

axiom build_correct_pre : (forall c:circuit1. build_correct_(pre1(c)))

logic to_qc1 : wired_circuit -> circuit1

axiom to_qcqtdef :
  (forall c:wired_circuit. (correct1(c) -> (pre1(to_qc1(c)) = c)))

logic range1 : circuit1 -> int

axiom rangeqtdef : (forall c:circuit1. ((pre1(c) = Skip) -> (range1(c) = 0)))

axiom rangeqtdef1 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Phase1(w)) -> (range1(c) = 0))))

axiom rangeqtdef2 :
  (forall c:circuit1. (forall x:int. ((pre1(c) = Rx(x)) -> (range1(c) = 2))))

axiom rangeqtdef3 :
  (forall c:circuit1. (forall x:int. ((pre1(c) = Ry(x)) -> (range1(c) = 2))))

axiom rangeqtdef4 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Rz1(w)) -> (range1(c) = 0))))

axiom rangeqtdef5 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Rzp(w)) -> (range1(c) = 0))))

axiom rangeqtdef6 :
  (forall c:circuit1. ((pre1(c) = Hadamard1) -> (range1(c) = 1)))

axiom rangeqtdef7 : (forall c:circuit1. ((pre1(c) = S) -> (range1(c) = 0)))

axiom rangeqtdef8 : (forall c:circuit1. ((pre1(c) = T) -> (range1(c) = 0)))

axiom rangeqtdef9 : (forall c:circuit1. ((pre1(c) = X) -> (range1(c) = 0)))

axiom rangeqtdef10 : (forall c:circuit1. ((pre1(c) = Y) -> (range1(c) = 0)))

axiom rangeqtdef11 : (forall c:circuit1. ((pre1(c) = Z) -> (range1(c) = 0)))

axiom rangeqtdef12 :
  (forall c:circuit1. ((pre1(c) = Bricks_Cnot) -> (range1(c) = 0)))

axiom rangeqtdef13 :
  (forall c:circuit1. ((pre1(c) = Bricks_Toffoli) -> (range1(c) = 0)))

axiom rangeqtdef14 :
  (forall c:circuit1. ((pre1(c) = Bricks_Fredkin) -> (range1(c) = 0)))

axiom rangeqtdef15 :
  (forall c:circuit1. ((pre1(c) = Bricks_Swap) -> (range1(c) = 0)))

axiom rangeqtdef16 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. ((pre1(c) = Swap1(w, w1,
  w2)) -> (range1(c) = 0))))

axiom rangeqtdef17 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. ((pre1(c) = Cnot1(w, w1,
  w2)) -> (range1(c) = 0))))

axiom rangeqtdef18 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((pre1(c) = Toffoli(w, w1, w2, w3)) -> (range1(c) = 0))))

axiom rangeqtdef19 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((pre1(c) = Fredkin(w, w1, w2, w3)) -> (range1(c) = 0))))

axiom rangeqtdef20 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((pre1(c) = Place(x,
  x1, x2)) -> (range1(c) = range1(to_qc1(x))))))

axiom rangeqtdef21 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((pre1(c) = Cont(x, x1, x2, x3)) -> (range1(c) = range1(to_qc1(x))))))

axiom rangeqtdef22 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:wired_circuit. ((pre1(c) = Sequence1(x,
  x1)) -> (range1(c) = (range1(to_qc1(x)) + range1(to_qc1(x1)))))))

axiom rangeqtdef23 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:wired_circuit. ((pre1(c) = Parallel1(x,
  x1)) -> (range1(c) = (range1(to_qc1(x)) + range1(to_qc1(x1)))))))

axiom rangeqtdef24 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. ((pre1(c) = Ancillas1(x, x1)) ->
  (range1(c) = range1(to_qc1(x))))))

axiom rangeqtspec1 : (forall c:circuit1. (range1(c) = range_pre(pre1(c))))

axiom rangeqtspec2 :
  (forall c:circuit1. (range1(c) = h_range(circ_to_pps_pre1(pre1(c)))))

axiom rangeqtspec3 : (forall c:circuit1. (0 <= range1(c)))

logic size1 : circuit1 -> int

axiom sizeqtdef9 : (forall c:circuit1. ((pre1(c) = Skip) -> (size1(c) = 0)))

axiom sizeqtdef10 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Phase1(w)) -> (size1(c) = 1))))

axiom sizeqtdef11 :
  (forall c:circuit1. (forall w:int. ((pre1(c) = Rx(w)) -> (size1(c) = 1))))

axiom sizeqtdef12 :
  (forall c:circuit1. (forall w:int. ((pre1(c) = Ry(w)) -> (size1(c) = 1))))

axiom sizeqtdef13 :
  (forall c:circuit1. (forall w:int. ((pre1(c) = Rz1(w)) -> (size1(c) = 1))))

axiom sizeqtdef14 :
  (forall c:circuit1. (forall w:int. ((pre1(c) = Rzp(w)) -> (size1(c) = 1))))

axiom sizeqtdef15 :
  (forall c:circuit1. ((pre1(c) = Hadamard1) -> (size1(c) = 1)))

axiom sizeqtdef16 : (forall c:circuit1. ((pre1(c) = S) -> (size1(c) = 1)))

axiom sizeqtdef17 : (forall c:circuit1. ((pre1(c) = T) -> (size1(c) = 1)))

axiom sizeqtdef18 : (forall c:circuit1. ((pre1(c) = X) -> (size1(c) = 1)))

axiom sizeqtdef19 : (forall c:circuit1. ((pre1(c) = Y) -> (size1(c) = 1)))

axiom sizeqtdef20 : (forall c:circuit1. ((pre1(c) = Z) -> (size1(c) = 1)))

axiom sizeqtdef21 :
  (forall c:circuit1. ((pre1(c) = Bricks_Cnot) -> (size1(c) = 1)))

axiom sizeqtdef22 :
  (forall c:circuit1. ((pre1(c) = Bricks_Toffoli) -> (size1(c) = 1)))

axiom sizeqtdef23 :
  (forall c:circuit1. ((pre1(c) = Bricks_Fredkin) -> (size1(c) = 1)))

axiom sizeqtdef24 :
  (forall c:circuit1. ((pre1(c) = Bricks_Swap) -> (size1(c) = 1)))

axiom sizeqtdef25 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. ((pre1(c) = Swap1(w, w1,
  w2)) -> (size1(c) = 1))))

axiom sizeqtdef26 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. ((pre1(c) = Cnot1(w, w1,
  w2)) -> (size1(c) = 1))))

axiom sizeqtdef27 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((pre1(c) = Toffoli(w, w1, w2, w3)) -> (size1(c) = 1))))

axiom sizeqtdef28 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((pre1(c) = Fredkin(w, w1, w2, w3)) -> (size1(c) = 1))))

axiom sizeqtdef29 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((pre1(c) = Place(x,
  x1, x2)) -> (size1(c) = size_pre(x)))))

axiom sizeqtdef30 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((pre1(c) = Cont(x, x1, x2, x3)) ->
  (size1(c) = (size1(to_qc1(x)) * cont_size1)))))

axiom sizeqtdef31 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:wired_circuit. ((pre1(c) = Sequence1(x,
  x1)) -> (size1(c) = (size1(to_qc1(x)) + size1(to_qc1(x1)))))))

axiom sizeqtdef32 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:wired_circuit. ((pre1(c) = Parallel1(x,
  x1)) -> (size1(c) = (size1(to_qc1(x)) + size1(to_qc1(x1)))))))

axiom sizeqtdef33 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. ((pre1(c) = Ancillas1(x, x1)) ->
  (size1(c) = size_pre(x)))))

axiom sizeqtspec1 : (forall c:circuit1. (size1(c) = size_pre(pre1(c))))

logic ancillas1 : circuit1 -> int

axiom ancillasqtdef9 :
  (forall c:circuit1. ((pre1(c) = Skip) -> (ancillas1(c) = 0)))

axiom ancillasqtdef10 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Phase1(w)) -> (ancillas1(c) = 0))))

axiom ancillasqtdef11 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Rx(w)) -> (ancillas1(c) = 0))))

axiom ancillasqtdef12 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Ry(w)) -> (ancillas1(c) = 0))))

axiom ancillasqtdef13 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Rz1(w)) -> (ancillas1(c) = 0))))

axiom ancillasqtdef14 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Rzp(w)) -> (ancillas1(c) = 0))))

axiom ancillasqtdef15 :
  (forall c:circuit1. ((pre1(c) = Hadamard1) -> (ancillas1(c) = 0)))

axiom ancillasqtdef16 :
  (forall c:circuit1. ((pre1(c) = S) -> (ancillas1(c) = 0)))

axiom ancillasqtdef17 :
  (forall c:circuit1. ((pre1(c) = T) -> (ancillas1(c) = 0)))

axiom ancillasqtdef18 :
  (forall c:circuit1. ((pre1(c) = X) -> (ancillas1(c) = 0)))

axiom ancillasqtdef19 :
  (forall c:circuit1. ((pre1(c) = Y) -> (ancillas1(c) = 0)))

axiom ancillasqtdef20 :
  (forall c:circuit1. ((pre1(c) = Z) -> (ancillas1(c) = 0)))

axiom ancillasqtdef21 :
  (forall c:circuit1. ((pre1(c) = Bricks_Cnot) -> (ancillas1(c) = 0)))

axiom ancillasqtdef22 :
  (forall c:circuit1. ((pre1(c) = Bricks_Toffoli) -> (ancillas1(c) = 0)))

axiom ancillasqtdef23 :
  (forall c:circuit1. ((pre1(c) = Bricks_Fredkin) -> (ancillas1(c) = 0)))

axiom ancillasqtdef24 :
  (forall c:circuit1. ((pre1(c) = Bricks_Swap) -> (ancillas1(c) = 0)))

axiom ancillasqtdef25 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. ((pre1(c) = Swap1(w, w1,
  w2)) -> (ancillas1(c) = 0))))

axiom ancillasqtdef26 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. ((pre1(c) = Cnot1(w, w1,
  w2)) -> (ancillas1(c) = 0))))

axiom ancillasqtdef27 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((pre1(c) = Toffoli(w, w1, w2, w3)) -> (ancillas1(c) = 0))))

axiom ancillasqtdef28 :
  (forall c:circuit1.
  (forall w:int. forall w1:int. forall w2:int. forall w3:int.
  ((pre1(c) = Fredkin(w, w1, w2, w3)) -> (ancillas1(c) = 0))))

axiom ancillasqtdef29 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((pre1(c) = Place(x,
  x1, x2)) -> (ancillas1(c) = ancillas1(to_qc1(x))))))

axiom ancillasqtdef30 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((pre1(c) = Cont(x, x1, x2, x3)) -> (ancillas1(c) = ancillas1(to_qc1(x))))))

axiom ancillasqtdef31 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:wired_circuit. ((pre1(c) = Sequence1(x,
  x1)) -> (ancillas1(c) = max(ancillas1(to_qc1(x)), ancillas1(to_qc1(x1)))))))

axiom ancillasqtdef32 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:wired_circuit. ((pre1(c) = Parallel1(x,
  x1)) -> (ancillas1(c) = (ancillas1(to_qc1(x)) + ancillas1(to_qc1(x1)))))))

axiom ancillasqtdef33 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. ((pre1(c) = Ancillas1(x, x1)) ->
  (ancillas1(c) = (ancillas1(to_qc1(x)) + x1)))))

axiom ancillasqtspec1 :
  (forall c:circuit1. (ancillas1(c) = ancillas_pre(pre1(c))))

axiom ancillas_pos : (forall c:circuit1. (0 <= ancillas1(c)))

axiom size_pos : (forall c:circuit1. (0 <= size1(c)))

logic width1 : circuit1 -> int

axiom widthqtdef : (forall c:circuit1. ((pre1(c) = Skip) -> (width1(c) = 1)))

axiom widthqtdef1 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Phase1(w)) -> (width1(c) = 1))))

axiom widthqtdef2 :
  (forall c:circuit1. (forall w:int. ((pre1(c) = Rx(w)) -> (width1(c) = 1))))

axiom widthqtdef3 :
  (forall c:circuit1. (forall w:int. ((pre1(c) = Ry(w)) -> (width1(c) = 1))))

axiom widthqtdef4 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Rz1(w)) -> (width1(c) = 1))))

axiom widthqtdef5 :
  (forall c:circuit1.
  (forall w:int. ((pre1(c) = Rzp(w)) -> (width1(c) = 1))))

axiom widthqtdef6 :
  (forall c:circuit1. ((pre1(c) = Hadamard1) -> (width1(c) = 1)))

axiom widthqtdef7 : (forall c:circuit1. ((pre1(c) = S) -> (width1(c) = 1)))

axiom widthqtdef8 : (forall c:circuit1. ((pre1(c) = T) -> (width1(c) = 1)))

axiom widthqtdef9 : (forall c:circuit1. ((pre1(c) = X) -> (width1(c) = 1)))

axiom widthqtdef10 : (forall c:circuit1. ((pre1(c) = Y) -> (width1(c) = 1)))

axiom widthqtdef11 : (forall c:circuit1. ((pre1(c) = Z) -> (width1(c) = 1)))

axiom widthqtdef12 :
  (forall c:circuit1. ((pre1(c) = Bricks_Cnot) -> (width1(c) = 2)))

axiom widthqtdef13 :
  (forall c:circuit1. ((pre1(c) = Bricks_Toffoli) -> (width1(c) = 3)))

axiom widthqtdef14 :
  (forall c:circuit1. ((pre1(c) = Bricks_Fredkin) -> (width1(c) = 3)))

axiom widthqtdef15 :
  (forall c:circuit1. ((pre1(c) = Bricks_Swap) -> (width1(c) = 2)))

axiom widthqtdef16 :
  (forall c:circuit1.
  (forall x:int. forall x1:int. forall x2:int. ((pre1(c) = Swap1(x, x1,
  x2)) -> (width1(c) = x2))))

axiom widthqtdef17 :
  (forall c:circuit1.
  (forall x:int. forall x1:int. forall x2:int. ((pre1(c) = Cnot1(x, x1,
  x2)) -> (width1(c) = x2))))

axiom widthqtdef18 :
  (forall c:circuit1.
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  ((pre1(c) = Toffoli(x, x1, x2, x3)) -> (width1(c) = x3))))

axiom widthqtdef19 :
  (forall c:circuit1.
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  ((pre1(c) = Fredkin(x, x1, x2, x3)) -> (width1(c) = x3))))

axiom widthqtdef20 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((pre1(c) = Place(x,
  x1, x2)) -> (width1(c) = x2))))

axiom widthqtdef21 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((pre1(c) = Cont(x, x1, x2, x3)) -> (width1(c) = x3))))

axiom widthqtdef22 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:wired_circuit. ((pre1(c) = Sequence1(x,
  x1)) -> (width1(c) = width1(to_qc1(x))))))

axiom widthqtdef23 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:wired_circuit. ((pre1(c) = Parallel1(x,
  x1)) -> (width1(c) = (width1(to_qc1(x)) + width1(to_qc1(x1)))))))

axiom widthqtdef24 :
  (forall c:circuit1.
  (forall x:wired_circuit. forall x1:int. ((pre1(c) = Ancillas1(x, x1)) ->
  (width1(c) = (width1(to_qc1(x)) - x1)))))

axiom widthqtspec2 : (forall c:circuit1. (1 <= width1(c)))

axiom widthqtspec3 : (forall c:circuit1. (width1(c) = width_pre1(pre1(c))))

logic basis_ket1 : circuit1, (int,int) farray, (int,int) farray, int -> int

logic result69 : (int,int) farray, int -> (int,int) farray

logic result70 : (int,int) farray, int -> (int,int) farray

logic basis_ket_closure1 : (circuit1,((int,int) farray,((int,int) farray,(int,int) farray) farray) farray) farray

logic result71 : (int,int) farray, wired_circuit -> (int,int) farray

logic result72 : (int,int) farray, wired_circuit -> (int,int) farray

logic result73 : (int,int) farray, wired_circuit -> (int,int) farray

logic result74 : (int,int) farray, wired_circuit, int -> (int,int) farray

axiom resultqtdef76 :
  (forall x:(int,int) farray. forall x1:int. forall j:int. ((result69(x,
  x1)[j]) = (x[(j + x1)])))

axiom resultqtdef77 :
  (forall x:(int,int) farray. forall x1:int. forall j:int. ((result70(x,
  x1)[j]) = (x[(j + x1)])))

axiom basis_ket_closure_def1 :
  (forall y:circuit1. forall y1:(int,int) farray. forall y2:(int,int) farray.
  forall y3:int. (((((basis_ket_closure1[y])[y1])[y2])[y3]) = basis_ket1(y,
  y1, y2, y3)))

axiom resultqtdef78 :
  (forall y:(int,int) farray. forall x:wired_circuit. forall k:int.
  ((result71(y, x)[k]) = (y[(k + range1(to_qc1(x)))])))

axiom resultqtdef79 :
  (forall x:(int,int) farray. forall x1:wired_circuit. forall k:int.
  ((result72(x, x1)[k]) = (x[(k + width1(to_qc1(x1)))])))

axiom resultqtdef80 :
  (forall y:(int,int) farray. forall x:wired_circuit. forall k:int.
  ((result73(y, x)[k]) = (y[(k + range1(to_qc1(x)))])))

axiom resultqtdef81 :
  (forall x:(int,int) farray. forall x1:wired_circuit. forall x2:int.
  forall k:int. ((result74(x, x1,
  x2)[k]) = (if (k <  (width1(to_qc1(x1)) - x2)) then (x[k]) else 0)))

axiom basis_ketqtdef :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Skip) -> (basis_ket1(c, x, y, i) = (x[i]))))

axiom basis_ketqtdef1 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. ((pre1(c) = Phase1(x1)) -> (basis_ket1(c, x, y,
  i) = (x[i])))))

axiom basis_ketqtdef2 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. ((pre1(c) = Rx(x1)) -> (basis_ket1(c, x, y, i) = (y[1])))))

axiom basis_ketqtdef3 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. ((pre1(c) = Ry(x1)) -> (basis_ket1(c, x, y, i) = (y[1])))))

axiom basis_ketqtdef4 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. ((pre1(c) = Rz1(x1)) -> (basis_ket1(c, x, y, i) = (x[i])))))

axiom basis_ketqtdef5 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. ((pre1(c) = Rzp(x1)) -> (basis_ket1(c, x, y, i) = (x[i])))))

axiom basis_ketqtdef6 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Hadamard1) -> (basis_ket1(c, x, y, i) = (y[i]))))

axiom basis_ketqtdef7 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = S) -> (basis_ket1(c, x, y, i) = (x[i]))))

axiom basis_ketqtdef8 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = T) -> (basis_ket1(c, x, y, i) = (x[i]))))

axiom basis_ketqtdef9 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = X) -> (basis_ket1(c, x, y, i) = (1 - (x[i])))))

axiom basis_ketqtdef10 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Y) -> (basis_ket1(c, x, y, i) = (1 - (x[i])))))

axiom basis_ketqtdef11 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Z) -> (basis_ket1(c, x, y, i) = (x[i]))))

axiom basis_ketqtdef12 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Cnot) -> ((i = 1) -> (basis_ket1(c, x, y,
  i) = (((x[0]) * (1 - (x[1]))) + ((x[1]) * (1 - (x[0]))))))))

axiom basis_ketqtdef13 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Cnot) -> ((not (i = 1)) -> (basis_ket1(c,
  x, y, i) = (x[i])))))

axiom basis_ketqtdef14 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Toffoli) -> ((i = 2) -> (basis_ket1(c, x,
  y,
  i) = ((((x[0]) * (x[1])) * (1 - (x[2]))) + ((x[2]) * (1 - ((x[0]) * (x[1])))))))))

axiom basis_ketqtdef15 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Toffoli) -> ((not (i = 2)) ->
  (basis_ket1(c, x, y, i) = (x[i])))))

axiom basis_ketqtdef16 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Fredkin) -> ((i = 1) -> (basis_ket1(c, x,
  y, i) = (((x[0]) * (x[2])) + ((1 - (x[0])) * (x[1])))))))

axiom basis_ketqtdef17 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Fredkin) -> ((not (i = 1)) -> ((i = 2) ->
  (basis_ket1(c, x, y,
  i) = (((x[0]) * (x[1])) + ((1 - (x[0])) * (x[2]))))))))

axiom basis_ketqtdef18 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Fredkin) -> ((not (i = 1)) ->
  ((not (i = 2)) -> (basis_ket1(c, x, y, i) = (x[i]))))))

axiom basis_ketqtdef19 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Swap) -> ((i = 0) -> (basis_ket1(c, x, y,
  i) = (x[1])))))

axiom basis_ketqtdef20 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Swap) -> ((not (i = 0)) -> ((i = 1) ->
  (basis_ket1(c, x, y, i) = (x[0]))))))

axiom basis_ketqtdef21 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((pre1(c) = Bricks_Swap) -> ((not (i = 0)) ->
  ((not (i = 1)) -> (basis_ket1(c, x, y, i) = (x[i]))))))

axiom basis_ketqtdef22 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. ((pre1(c) = Swap1(x1, x2,
  x3)) -> ((i = x1) -> (basis_ket1(c, x, y, i) = (x[x2]))))))

axiom basis_ketqtdef23 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. ((pre1(c) = Swap1(x1, x2,
  x3)) -> ((not (i = x1)) -> ((i = x2) -> (basis_ket1(c, x, y,
  i) = (x[x1])))))))

axiom basis_ketqtdef24 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. ((pre1(c) = Swap1(x1, x2,
  x3)) -> ((not (i = x1)) -> ((not (i = x2)) -> (basis_ket1(c, x, y,
  i) = (x[i])))))))

axiom basis_ketqtdef25 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. ((pre1(c) = Cnot1(x1, x2,
  x3)) -> ((i = x2) -> (basis_ket1(c, x, y,
  i) = (((x[x1]) * (1 - (x[x2]))) + ((x[x2]) * (1 - (x[x1])))))))))

axiom basis_ketqtdef26 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. ((pre1(c) = Cnot1(x1, x2,
  x3)) -> ((not (i = x2)) -> (basis_ket1(c, x, y, i) = (x[i]))))))

axiom basis_ketqtdef27 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. forall x4:int.
  ((pre1(c) = Toffoli(x1, x2, x3, x4)) -> ((i = x3) -> (basis_ket1(c, x, y,
  i) = ((((x[x1]) * (x[x2])) * (1 - (x[x3]))) + ((x[x3]) * (1 - ((x[x1]) * (x[x2]))))))))))

axiom basis_ketqtdef28 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. forall x4:int.
  ((pre1(c) = Toffoli(x1, x2, x3, x4)) -> ((not (i = x3)) -> (basis_ket1(c,
  x, y, i) = (x[i]))))))

axiom basis_ketqtdef29 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. forall x4:int.
  ((pre1(c) = Fredkin(x1, x2, x3, x4)) -> ((i = x2) -> (basis_ket1(c, x, y,
  i) = (((x[x1]) * (x[x3])) + ((1 - (x[x1])) * (x[x2]))))))))

axiom basis_ketqtdef30 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. forall x4:int.
  ((pre1(c) = Fredkin(x1, x2, x3, x4)) -> ((not (i = x2)) -> ((i = x3) ->
  (basis_ket1(c, x, y,
  i) = (((x[x1]) * (x[x2])) + ((1 - (x[x1])) * (x[x3])))))))))

axiom basis_ketqtdef31 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:int. forall x2:int. forall x3:int. forall x4:int.
  ((pre1(c) = Fredkin(x1, x2, x3, x4)) -> ((not (i = x2)) ->
  ((not (i = x3)) -> (basis_ket1(c, x, y, i) = (x[i])))))))

axiom basis_ketqtdef32 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:wired_circuit. forall x2:int. forall x3:int.
  ((pre1(c) = Place(x1, x2, x3)) -> (((x2 <= i) and
  (i <  (x2 + width1(to_qc1(x1))))) -> (basis_ket1(c, x, y,
  i) = basis_ket1(to_qc1(x1), result69(x, x2), y, (i - x2)))))))

axiom basis_ketqtdef33 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:wired_circuit. forall x2:int. forall x3:int.
  ((pre1(c) = Place(x1, x2, x3)) -> ((not ((x2 <= i) and
  (i <  (x2 + width1(to_qc1(x1)))))) -> (basis_ket1(c, x, y, i) = (x[i]))))))

axiom basis_ketqtdef34 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:wired_circuit. forall x2:int. forall x3:int. forall x4:int.
  ((pre1(c) = Cont(x1, x2, x3, x4)) -> ((((x[x2]) = 1) and ((x3 <= i) and
  (i <  (x3 + width1(to_qc1(x1)))))) -> (basis_ket1(c, x, y,
  i) = basis_ket1(to_qc1(x1), result70(x, x3), y, (i - x3)))))))

axiom basis_ketqtdef35 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:wired_circuit. forall x2:int. forall x3:int. forall x4:int.
  ((pre1(c) = Cont(x1, x2, x3, x4)) -> ((not (((x[x2]) = 1) and
  ((x3 <= i) and (i <  (x3 + width1(to_qc1(x1))))))) -> (basis_ket1(c, x, y,
  i) = (x[i]))))))

axiom basis_ketqtdef36 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:wired_circuit. forall x2:wired_circuit.
  ((pre1(c) = Sequence1(x1, x2)) -> (basis_ket1(c, x, y,
  i) = basis_ket1(to_qc1(x2), (((basis_ket_closure1[to_qc1(x1)])[x])[y]),
  result71(y, x1), i)))))

axiom basis_ketqtdef37 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:wired_circuit. forall x2:wired_circuit.
  ((pre1(c) = Parallel1(x1, x2)) -> ((i <  width1(to_qc1(x1))) ->
  (basis_ket1(c, x, y, i) = basis_ket1(to_qc1(x1), x, y, i))))))

axiom basis_ketqtdef38 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:wired_circuit. forall x2:wired_circuit.
  ((pre1(c) = Parallel1(x1, x2)) -> ((not (i <  width1(to_qc1(x1)))) ->
  (basis_ket1(c, x, y, i) = basis_ket1(to_qc1(x2), result72(x, x1),
  result73(y, x1), (i - width1(to_qc1(x1)))))))))

axiom basis_ketqtdef39 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  (forall x1:wired_circuit. forall x2:int. ((pre1(c) = Ancillas1(x1, x2)) ->
  (basis_ket1(c, x, y, i) = basis_ket1(to_qc1(x1), result74(x, x1, x2), y,
  i)))))

axiom basis_ketqtspec2 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. (basis_ket1(c, x, y,
  i) = (((h_basis_ket(circ_to_pps_pre1(pre1(c)))[x])[y])[i])))

axiom basis_ketqtspec3 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  width1(c))) -> ((0 <= (x[i1])) and
   ((x[i1]) <  2)))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  range1(c))) -> ((0 <= (y[i1])) and
   ((y[i1]) <  2)))) ->
  (((0 <= i) and (i <  width1(c))) -> (0 <= basis_ket1(c, x, y, i))))))

axiom basis_ketqtspec4 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int.
  ((forall i1:int. (((0 <= i1) and (i1 <  width1(c))) -> ((0 <= (x[i1])) and
   ((x[i1]) <  2)))) ->
  ((forall i1:int. (((0 <= i1) and (i1 <  range1(c))) -> ((0 <= (y[i1])) and
   ((y[i1]) <  2)))) ->
  (((0 <= i) and (i <  width1(c))) -> (basis_ket1(c, x, y, i) <  2)))))

axiom basis_ket_invariant1 :
  (forall c:circuit1.
  (forall x:(int,int) farray. forall xqt:(int,int) farray.
  forall y:(int,int) farray. forall yqt:(int,int) farray.
  ((forall i:int. (((0 <= i) and (i <  width1(c))) -> ((x[i]) = (xqt[i])))) ->
  ((forall i:int. (((0 <= i) and (i <  range1(c))) -> ((y[i]) = (yqt[i])))) ->
  (forall i:int. (((0 <= i) and (i <  width1(c))) -> (basis_ket1(c, x, y,
  i) = basis_ket1(c, xqt, yqt, i))))))))

axiom binary_l_basis_ket :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall w:int. (binary_l(x, width1(c)) -> (binary_l(y, range1(c)) ->
  ((width1(c) = w) -> binary_l((((basis_ket_closure1[c])[x])[y]), w)))))

logic result75 : circuit1, (int,int) farray -> (int,int) farray

logic result76 : circuit1, (int,int) farray -> (int,int) farray

logic result77 : (int,int) farray, wired_circuit -> (int,int) farray

logic result78 : (int,int) farray, wired_circuit -> (int,int) farray

logic result79 : (int,int) farray, wired_circuit -> (int,int) farray

logic result80 : circuit1, (int,int) farray,
  wired_circuit -> (int,int) farray

axiom resultqtdef82 :
  (forall c:circuit1. forall x:(int,int) farray. forall j:int. ((result75(c,
  x)[j]) = (x[(j + Place_proj_2(pre1(c)))])))

axiom resultqtdef83 :
  (forall c:circuit1. forall x:(int,int) farray. forall j:int. ((result76(c,
  x)[j]) = (x[(j + Cont_proj_3(pre1(c)))])))

axiom resultqtdef84 :
  (forall y:(int,int) farray. forall x:wired_circuit. forall k:int.
  ((result77(y, x)[k]) = (y[(k + range1(to_qc1(x)))])))

axiom resultqtdef85 :
  (forall x:(int,int) farray. forall x1:wired_circuit. forall k:int.
  ((result78(x, x1)[k]) = (x[(k + width1(to_qc1(x1)))])))

axiom resultqtdef86 :
  (forall y:(int,int) farray. forall x:wired_circuit. forall k:int.
  ((result79(y, x)[k]) = (y[(k + range1(to_qc1(x)))])))

axiom resultqtdef87 :
  (forall c:circuit1. forall x:(int,int) farray. forall x1:wired_circuit.
  forall k:int. ((result80(c, x,
  x1)[k]) = (if (k <  (width1(to_qc1(x1)) - Ancillas_proj_21(pre1(c)))) then (x[k]) else 0)))

function ang_ind1(c: circuit1, x: (int,int) farray,
  y: (int,int) farray) : angle = match_wired_circuit(pre1(c), infix_sldtsl(0,
  0), infix_sldtsl(1, Phase_proj_11(pre1(c))),
  ang_add(ang_add(infix_sldtsl(((x[0]) * (y[0])), 1),
  infix_sldtsl(((y[0]) * (y[1])), 1)), phase_inv_(((y[0]) - 1),
  infix_sldtsl(1, incr_abs(Rx_proj_1(pre1(c)))))),
  ang_add(ang_add(ang_add(infix_sldtsl(((x[0]) * (y[0])), 1),
  infix_sldtsl(((y[0]) * (y[1])), 1)), phase_inv_(((y[0]) - 1),
  infix_sldtsl(1, incr_abs(Ry_proj_1(pre1(c)))))),
  infix_sldtsl(((y[1]) - (x[0])), 2)), phase_inv_(((x[0]) - 1),
  infix_sldtsl(1, incr_abs(Rz_proj_11(pre1(c))))), infix_sldtsl((x[0]),
  Rzp_proj_1(pre1(c))), infix_sldtsl(((x[0]) * (y[0])), 1),
  infix_sldtsl((x[0]), 2), infix_sldtsl((x[0]), 3), infix_sldtsl(1, 0),
  phase_inv_((x[0]), infix_sldtsl(1, 2)), infix_sldtsl((x[0]), 1),
  infix_sldtsl(1, 0), infix_sldtsl(1, 0), infix_sldtsl(1, 0), infix_sldtsl(1,
  0), infix_sldtsl(1, 0), infix_sldtsl(1, 0), infix_sldtsl(1, 0),
  infix_sldtsl(1, 0),
  ((h_angle(circ_to_pps_pre1(Place_proj_1(pre1(c))))[result75(c, x)])[y]),
  (let x1 = Cont_proj_2(pre1(c)) : int in (let x2 = Cont_proj_1(pre1(c))
  : wired_circuit in
  ang_add(ang_mult_int(((h_angle(circ_to_pps_pre1(x2))[result76(c, x)])[y]),
  (x[x1])), ang_mult_int(phase_inv_((y[0]),
  arc_cos_ang(pow_inv_sqrt_2(range1(to_qc1(x2))))), (1 - (x[x1])))))),
  (let x1 = Sequence_proj_11(pre1(c)) : wired_circuit in
  ang_add(((h_angle(circ_to_pps_pre1(x1))[x])[y]),
  ((h_angle(circ_to_pps_pre1(Sequence_proj_21(pre1(c))))[(((basis_ket_closure1[to_qc1(x1)])[x])[y])])[result77(y,
  x1)]))), (let x1 = Parallel_proj_11(pre1(c)) : wired_circuit in
  ang_add(((h_angle(circ_to_pps_pre1(x1))[x])[y]),
  ((h_angle(circ_to_pps_pre1(Parallel_proj_21(pre1(c))))[result78(x,
  x1)])[result79(y, x1)]))), (let x1 = Ancillas_proj_11(pre1(c))
  : wired_circuit in ((h_angle(circ_to_pps_pre1(x1))[result80(c, x,
  x1)])[y])))

axiom ang_indqtspec :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(c, x, y) = ((h_angle(circ_to_pps_pre1(pre1(c)))[x])[y])))

axiom ang_ind_invariant1 :
  (forall c:circuit1.
  (forall x:(int,int) farray. forall xqt:(int,int) farray.
  forall y:(int,int) farray. forall yqt:(int,int) farray.
  ((forall i:int. (((0 <= i) and (i <  width1(c))) -> ((x[i]) = (xqt[i])))) ->
  ((forall i:int. (((0 <= i) and (i <  range1(c))) -> ((y[i]) = (yqt[i])))) ->
  (ang_ind1(c, x, y) = ang_ind1(c, xqt, yqt))))))

logic unwire_pre : wired_circuit -> circuit

axiom unwire_preqtdef :
  (forall c:wired_circuit. (correct1(c) -> ((c = Skip) ->
  (unwire_pre(c) = id))))

axiom unwire_preqtdef1 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall k:int. ((c = Phase1(k)) -> (unwire_pre(c) = phase(k))))))

axiom unwire_preqtdef2 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall k:int. ((c = Rx(k)) -> (unwire_pre(c) = rx(k))))))

axiom unwire_preqtdef3 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall k:int. ((c = Ry(k)) -> (unwire_pre(c) = ry(k))))))

axiom unwire_preqtdef4 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall k:int. ((c = Rz1(k)) -> (unwire_pre(c) = rz_(k))))))

axiom unwire_preqtdef5 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall k:int. ((c = Rzp(k)) -> (unwire_pre(c) = rz(k))))))

axiom unwire_preqtdef6 :
  (forall c:wired_circuit. (correct1(c) -> ((c = Hadamard1) ->
  (unwire_pre(c) = hadamard))))

axiom unwire_preqtdef7 :
  (forall c:wired_circuit. (correct1(c) -> ((c = S) ->
  (unwire_pre(c) = rz(2)))))

axiom unwire_preqtdef8 :
  (forall c:wired_circuit. (correct1(c) -> ((c = T) ->
  (unwire_pre(c) = rz(3)))))

axiom unwire_preqtdef9 :
  (forall c:wired_circuit. (correct1(c) -> ((c = X) ->
  (unwire_pre(c) = xx))))

axiom unwire_preqtdef10 :
  (forall c:wired_circuit. (correct1(c) -> ((c = Y) ->
  (unwire_pre(c) = yy))))

axiom unwire_preqtdef11 :
  (forall c:wired_circuit. (correct1(c) -> ((c = Z) ->
  (unwire_pre(c) = zz))))

axiom unwire_preqtdef12 :
  (forall c:wired_circuit. (correct1(c) -> ((c = Bricks_Cnot) ->
  (unwire_pre(c) = cnot))))

axiom unwire_preqtdef13 :
  (forall c:wired_circuit. (correct1(c) -> ((c = Bricks_Toffoli) ->
  (unwire_pre(c) = toffoli))))

axiom unwire_preqtdef14 :
  (forall c:wired_circuit. (correct1(c) -> ((c = Bricks_Fredkin) ->
  (unwire_pre(c) = fredkin))))

axiom unwire_preqtdef15 :
  (forall c:wired_circuit. (correct1(c) -> ((c = Bricks_Swap) ->
  (unwire_pre(c) = swap))))

axiom unwire_preqtdef16 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall t1:int. forall t2:int. forall n:int. ((c = Swap1(t1, t2, n)) ->
  (unwire_pre(c) = swap_c(t1, t2, n))))))

axiom unwire_preqtdef17 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall c1:int. forall t:int. forall n:int. ((c = Cnot1(c1, t, n)) ->
  (unwire_pre(c) = place_cnot(c1, t, n))))))

axiom unwire_preqtdef18 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall c1:int. forall c2:int. forall t:int. forall n:int.
  ((c = Toffoli(c1, c2, t, n)) -> (unwire_pre(c) = place_toffoli(c1, c2, t,
  n))))))

axiom unwire_preqtdef19 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall c1:int. forall t1:int. forall t2:int. forall n:int.
  ((c = Fredkin(c1, t1, t2, n)) -> (unwire_pre(c) = place_fredkin(c1, t1, t2,
  n))))))

axiom unwire_preqtdef20 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall c1:wired_circuit. forall p:int. forall n:int. ((c = Place(c1, p,
  n)) -> (unwire_pre(c) = place(unwire_pre(c1), p, n))))))

axiom unwire_preqtdef21 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall c1:wired_circuit. forall co:int. forall t:int. forall n:int.
  ((c = Cont(c1, co, t, n)) -> (unwire_pre(c) = cont(unwire_pre(c1), co, t,
  n))))))

axiom unwire_preqtdef22 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall d:wired_circuit. forall e:wired_circuit. ((c = Sequence1(d, e)) ->
  (unwire_pre(c) = sequence(unwire_pre(d), unwire_pre(e)))))))

axiom unwire_preqtdef23 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall d:wired_circuit. forall e:wired_circuit. ((c = Parallel1(d, e)) ->
  (unwire_pre(c) = parallel(unwire_pre(d), unwire_pre(e)))))))

axiom unwire_preqtdef24 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall d:wired_circuit. forall l:int. ((c = Ancillas1(d, l)) ->
  (unwire_pre(c) = ancilla(unwire_pre(d), l))))))

axiom unwire_preqtspec :
  (forall c:wired_circuit. (correct1(c) ->
  (width(unwire_pre(c)) = width_pre1(c))))

axiom unwire_preqtspec1 :
  (forall c:wired_circuit. (correct1(c) -> correct_path_sum_(unwire_pre(c),
  circ_to_pps_pre1(c))))

axiom unwire_preqtspec2 :
  (forall c:wired_circuit. (correct1(c) ->
  (forall x:complex matrix. (is_a_ket_l(x, width_pre1(c)) ->
  (path_sem(unwire_pre(c), x) = pps_apply(circ_to_pps_pre1(c), x))))))

function circ_to_pps1(c: circuit1) : pps = circ_to_pps_pre1(pre1(c))

axiom circ_to_ppsqtspec3 :
  (forall c:circuit1. (1 <= h_width(circ_to_pps1(c))))

axiom circ_to_ppsqtspec4 :
  (forall c:circuit1. (h_width(circ_to_pps1(c)) = width1(c)))

axiom circ_to_ppsqtspec5 :
  (forall c:circuit1. (h_range(circ_to_pps1(c)) = range1(c)))

axiom circ_to_ppsqtspec6 :
  (forall c:circuit1.
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  ((((h_basis_ket(circ_to_pps1(c))[x])[y])[i]) = basis_ket1(c, x, y, i))))

axiom circ_to_ppsqtspec7 :
  (forall c:circuit1.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(circ_to_pps1(c))[x])[y]) = ang_ind1(c, x, y))))

function unwire(c: circuit1) : circuit = unwire_pre(pre1(c))

axiom unwireqtspec :
  (forall c:circuit1.
  (forall x:complex matrix. (is_a_ket_l(x, width1(c)) -> (path_sem(unwire(c),
  x) = pps_apply(circ_to_pps1(c), x)))))

logic phase1 : int -> circuit1

axiom phaseqtspec8 : (forall k:int. (pre1(phase1(k)) = Phase1(k)))

axiom phaseqtspec9 : (forall k:int. (ancillas1(phase1(k)) = 0))

axiom phaseqtspec10 : (forall k:int. (size1(phase1(k)) = 1))

axiom phaseqtspec11 : (forall k:int. (range1(phase1(k)) = 0))

axiom phaseqtspec12 : (forall k:int. (width1(phase1(k)) = 1))

axiom phaseqtspec13 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(phase1(k), x, y, i) = (x[i])))))

axiom phaseqtspec14 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(phase1(k),
  x, y) = infix_sldtsl(1, k))))

logic skip : circuit1

axiom skipqtdef : (pre1(skip) = Skip)

axiom skipqtdef1 : (ancillas1(skip) = 0)

axiom skipqtdef2 : (size1(skip) = 0)

axiom skipqtdef3 : (range1(skip) = 0)

axiom skipqtdef4 : (width1(skip) = 1)

axiom skipqtdef5 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(skip, x, y, i) = (x[i]))))

axiom skipqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(skip, x,
  y) = infix_sldtsl(1, 0)))

axiom skipqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall k:int. (ang_ind1(skip, x, y) = infix_sldtsl(0, k))))

logic rz1 : int -> circuit1

axiom rzqtspec8 : (forall k:int. (pre1(rz1(k)) = Rz1(k)))

axiom rzqtspec9 : (forall k:int. (ancillas1(rz1(k)) = 0))

axiom rzqtspec10 : (forall k:int. (size1(rz1(k)) = 1))

axiom rzqtspec11 : (forall k:int. (range1(rz1(k)) = 0))

axiom rzqtspec12 : (forall k:int. (width1(rz1(k)) = 1))

axiom rzqtspec13 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(rz1(k), x, y, i) = (x[i])))))

axiom rzqtspec14 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (((0 <= (x[0])) and
  ((x[0]) <  2)) -> ((k <  0) -> (ang_ind1(rz1(k), x,
  y) = phase_inv_(((x[0]) - 1), infix_sldtsl(1, (k - 1))))))))

axiom rzqtspec15 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (((0 <= (x[0])) and
  ((x[0]) <  2)) -> ((0 <= k) -> (ang_ind1(rz1(k), x,
  y) = phase_inv_(((x[0]) - 1), infix_sldtsl(1, (k + 1))))))))

axiom rzqtspec16 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (((0 <= (x[0])) and
  ((x[0]) <  2)) -> (ang_ind1(rz1(k), x, y) = phase_inv_(((x[0]) - 1),
  infix_sldtsl(1, incr_abs(k)))))))

logic rzp : int -> circuit1

axiom rzpqtspec : (forall k:int. (pre1(rzp(k)) = Rzp(k)))

axiom rzpqtspec1 : (forall k:int. (ancillas1(rzp(k)) = 0))

axiom rzpqtspec2 : (forall k:int. (size1(rzp(k)) = 1))

axiom rzpqtspec3 : (forall k:int. (range1(rzp(k)) = 0))

axiom rzpqtspec4 : (forall k:int. (width1(rzp(k)) = 1))

axiom rzpqtspec5 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(rzp(k), x, y, i) = (x[i])))))

axiom rzpqtspec6 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(rzp(k), x,
  y) = infix_sldtsl((x[0]), k))))

logic rx1 : int -> circuit1

axiom rxqtspec4 : (forall k:int. (pre1(rx1(k)) = Rx(k)))

axiom rxqtspec5 : (forall k:int. (ancillas1(rx1(k)) = 0))

axiom rxqtspec6 : (forall k:int. (size1(rx1(k)) = 1))

axiom rxqtspec7 : (forall k:int. (range1(rx1(k)) = 2))

axiom rxqtspec8 : (forall k:int. (width1(rx1(k)) = 1))

axiom rxqtspec9 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(rx1(k), x, y, i) = (y[1])))))

axiom rxqtspec10 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(rx1(k), x,
  y) = ang_add(ang_add(infix_sldtsl(((x[0]) * (y[0])), 1),
  infix_sldtsl(((y[0]) * (y[1])), 1)), phase_inv_(((y[0]) - 1),
  infix_sldtsl(1, incr_abs(k)))))))

logic ry1 : int -> circuit1

axiom ryqtspec4 : (forall k:int. (pre1(ry1(k)) = Ry(k)))

axiom ryqtspec5 : (forall k:int. (ancillas1(ry1(k)) = 0))

axiom ryqtspec6 : (forall k:int. (size1(ry1(k)) = 1))

axiom ryqtspec7 : (forall k:int. (range1(ry1(k)) = 2))

axiom ryqtspec8 : (forall k:int. (width1(ry1(k)) = 1))

axiom ryqtspec9 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(ry1(k), x, y, i) = (y[1])))))

axiom ryqtspec10 :
  (forall k:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(ry1(k), x,
  y) = ang_add(ang_add(ang_add(infix_sldtsl(((x[0]) * (y[0])), 1),
  infix_sldtsl(((y[0]) * (y[1])), 1)), phase_inv_(((y[0]) - 1),
  infix_sldtsl(1, incr_abs(k)))), infix_sldtsl(((y[1]) - (x[0])), 2)))))

logic hadamard1 : circuit1

axiom hadamardqtdef8 : (pre1(hadamard1) = Hadamard1)

axiom hadamardqtdef9 : (ancillas1(hadamard1) = 0)

axiom hadamardqtdef10 : (size1(hadamard1) = 1)

axiom hadamardqtdef11 : (range1(hadamard1) = 1)

axiom hadamardqtdef12 : (width1(hadamard1) = 1)

axiom hadamardqtdef13 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(hadamard1, x, y, i) = (y[i]))))

axiom hadamardqtdef14 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(hadamard1,
  x, y) = infix_sldtsl(((x[0]) * (y[0])), 1)))

logic s : circuit1

axiom sqtdef : (pre1(s) = S)

axiom sqtdef1 : (ancillas1(s) = 0)

axiom sqtdef2 : (size1(s) = 1)

axiom sqtdef3 : (range1(s) = 0)

axiom sqtdef4 : (width1(s) = 1)

axiom sqtdef5 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(s, x, y, i) = (x[i]))))

axiom sqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(s, x,
  y) = infix_sldtsl((x[0]), 2)))

logic t : circuit1

axiom tqtdef : (pre1(t) = T)

axiom tqtdef1 : (ancillas1(t) = 0)

axiom tqtdef2 : (size1(t) = 1)

axiom tqtdef3 : (range1(t) = 0)

axiom tqtdef4 : (width1(t) = 1)

axiom tqtdef5 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(t, x, y, i) = (x[i]))))

axiom tqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(t, x,
  y) = infix_sldtsl((x[0]), 3)))

logic xx1 : circuit1

axiom xxqtdef2 : (pre1(xx1) = X)

axiom xxqtdef3 : (ancillas1(xx1) = 0)

axiom xxqtdef4 : (size1(xx1) = 1)

axiom xxqtdef5 : (range1(xx1) = 0)

axiom xxqtdef6 : (width1(xx1) = 1)

axiom xxqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(xx1, x, y, i) = (1 - (x[i])))))

axiom xxqtdef8 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(xx1, x,
  y) = infix_sldtsl(1, 0)))

logic yy1 : circuit1

axiom yyqtdef2 : (pre1(yy1) = Y)

axiom yyqtdef3 : (ancillas1(yy1) = 0)

axiom yyqtdef4 : (size1(yy1) = 1)

axiom yyqtdef5 : (range1(yy1) = 0)

axiom yyqtdef6 : (width1(yy1) = 1)

axiom yyqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(yy1, x, y, i) = (1 - (x[i])))))

axiom yyqtdef8 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(yy1, x,
  y) = phase_inv_((x[0]), infix_sldtsl(1, 2))))

logic zz1 : circuit1

axiom zzqtdef2 : (pre1(zz1) = Z)

axiom zzqtdef3 : (ancillas1(zz1) = 0)

axiom zzqtdef4 : (size1(zz1) = 1)

axiom zzqtdef5 : (range1(zz1) = 0)

axiom zzqtdef6 : (width1(zz1) = 1)

axiom zzqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(zz1, x, y, i) = (x[i]))))

axiom zzqtdef8 :
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(zz1, x,
  y) = infix_sldtsl((x[0]), 1)))

logic bricks_cnot : circuit1

axiom bricks_cnotqtdef : (pre1(bricks_cnot) = Bricks_Cnot)

axiom bricks_cnotqtdef1 : (ancillas1(bricks_cnot) = 0)

axiom bricks_cnotqtdef2 : (size1(bricks_cnot) = 1)

axiom bricks_cnotqtdef3 : (range1(bricks_cnot) = 0)

axiom bricks_cnotqtdef4 : (width1(bricks_cnot) = 2)

axiom bricks_cnotqtdef5 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = 1)) -> (basis_ket1(bricks_cnot, x, y,
  i) = (x[i])))))

axiom bricks_cnotqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = 1) -> (basis_ket1(bricks_cnot, x, y,
  i) = (((x[0]) * (1 - (x[1]))) + ((x[1]) * (1 - (x[0]))))))))

axiom bricks_cnotqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(bricks_cnot, x, y) = infix_sldtsl(1, 0)))

logic bricks_toffoli : circuit1

axiom bricks_toffoliqtdef : (pre1(bricks_toffoli) = Bricks_Toffoli)

axiom bricks_toffoliqtdef1 : (ancillas1(bricks_toffoli) = 0)

axiom bricks_toffoliqtdef2 : (size1(bricks_toffoli) = 1)

axiom bricks_toffoliqtdef3 : (range1(bricks_toffoli) = 0)

axiom bricks_toffoliqtdef4 : (width1(bricks_toffoli) = 3)

axiom bricks_toffoliqtdef5 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = 2)) -> (basis_ket1(bricks_toffoli, x, y,
  i) = (x[i])))))

axiom bricks_toffoliqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = 2) -> (basis_ket1(bricks_toffoli, x, y,
  i) = ((((x[0]) * (x[1])) * (1 - (x[2]))) + ((x[2]) * (1 - ((x[0]) * (x[1])))))))))

axiom bricks_toffoliqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(bricks_toffoli, x, y) = infix_sldtsl(1, 0)))

logic bricks_fredkin : circuit1

axiom bricks_fredkinqtdef : (pre1(bricks_fredkin) = Bricks_Fredkin)

axiom bricks_fredkinqtdef1 : (ancillas1(bricks_fredkin) = 0)

axiom bricks_fredkinqtdef2 : (size1(bricks_fredkin) = 1)

axiom bricks_fredkinqtdef3 : (range1(bricks_fredkin) = 0)

axiom bricks_fredkinqtdef4 : (width1(bricks_fredkin) = 3)

axiom bricks_fredkinqtdef5 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = 1) -> (basis_ket1(bricks_fredkin, x, y,
  i) = (((x[0]) * (x[2])) + ((1 - (x[0])) * (x[1])))))))

axiom bricks_fredkinqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = 2) -> (basis_ket1(bricks_fredkin, x, y,
  i) = (((x[0]) * (x[1])) + ((1 - (x[0])) * (x[2])))))))

axiom bricks_fredkinqtdef7 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = 1)) -> ((not (i = 2)) ->
  (basis_ket1(bricks_fredkin, x, y, i) = (x[i]))))))

axiom bricks_fredkinqtdef8 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(bricks_fredkin, x, y) = infix_sldtsl(1, 0)))

logic bricks_swap : circuit1

axiom bricks_swapqtdef : (pre1(bricks_swap) = Bricks_Swap)

axiom bricks_swapqtdef1 : (ancillas1(bricks_swap) = 0)

axiom bricks_swapqtdef2 : (size1(bricks_swap) = 1)

axiom bricks_swapqtdef3 : (range1(bricks_swap) = 0)

axiom bricks_swapqtdef4 : (width1(bricks_swap) = 2)

axiom bricks_swapqtdef5 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(bricks_swap, x, y,
  i) = (if (i = 0) then (x[1]) else (if (i = 1) then (x[0]) else (x[i]))))))

axiom bricks_swapqtdef6 :
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(bricks_swap, x, y) = infix_sldtsl(1, 0)))

logic cnot1 : int, int, int -> circuit1

axiom cnotqtspec :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = co)) -> (pre1(cnot1(co, t1,
  n)) = Cnot1(co, t1, n))))))

axiom cnotqtspec1 :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = co)) -> (ancillas1(cnot1(co, t1,
  n)) = 0)))))

axiom cnotqtspec2 :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = co)) -> (size1(cnot1(co, t1,
  n)) = 1)))))

axiom cnotqtspec3 :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = co)) -> (range1(cnot1(co, t1,
  n)) = 0)))))

axiom cnotqtspec4 :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = co)) -> (width1(cnot1(co, t1,
  n)) = n)))))

axiom cnotqtspec5 :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = t1)) -> (basis_ket1(cnot1(co, t1, n), x, y,
  i) = (x[i])))))))))

axiom cnotqtspec6 :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t1) -> (basis_ket1(cnot1(co, t1, n), x, y,
  i) = (((x[co]) * (1 - (x[t1]))) + ((x[t1]) * (1 - (x[co]))))))))))))

axiom cnotqtspec7 :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(cnot1(co,
  t1, n), x, y) = infix_sldtsl(1, 0)))))))

logic toffoli1 : int, int, int, int -> circuit1

axiom toffoliqtspec :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (pre1(toffoli1(c1, c2, t1, n)) = Toffoli(c1, c2, t1, n)))))))))

axiom toffoliqtspec1 :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (ancillas1(toffoli1(c1, c2, t1, n)) = 0))))))))

axiom toffoliqtspec2 :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (size1(toffoli1(c1, c2, t1, n)) = 1))))))))

axiom toffoliqtspec3 :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (range1(toffoli1(c1, c2, t1, n)) = 0))))))))

axiom toffoliqtspec4 :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (width1(toffoli1(c1, c2, t1, n)) = n))))))))

axiom toffoliqtspec5 :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = t1)) -> (basis_ket1(toffoli1(c1, c2, t1, n), x,
  y, i) = (x[i]))))))))))))

axiom toffoliqtspec6 :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t1) -> (basis_ket1(toffoli1(c1, c2, t1, n), x, y,
  i) = ((((x[c1]) * (x[c2])) * (1 - (x[t1]))) + ((x[t1]) * (1 - ((x[c1]) * (x[c2]))))))))))))))))

axiom toffoliqtspec7 :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(toffoli1(c1, c2, t1, n), x, y) = infix_sldtsl(1, 0))))))))))

logic fredkin1 : int, int, int, int -> circuit1

axiom fredkinqtspec :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) -> (pre1(fredkin1(c,
  t1, t2, n)) = Fredkin(c, t1, t2, n)))))))))

axiom fredkinqtspec1 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (ancillas1(fredkin1(c, t1, t2, n)) = 0))))))))

axiom fredkinqtspec2 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (size1(fredkin1(c, t1, t2, n)) = 1))))))))

axiom fredkinqtspec3 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (range1(fredkin1(c, t1, t2, n)) = 0))))))))

axiom fredkinqtspec4 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (width1(fredkin1(c, t1, t2, n)) = n))))))))

axiom fredkinqtspec5 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t1) -> (basis_ket1(fredkin1(c, t1, t2, n), x, y,
  i) = (((x[c]) * (x[t2])) + ((1 - (x[c])) * (x[t1]))))))))))))))

axiom fredkinqtspec6 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t2) -> (basis_ket1(fredkin1(c, t1, t2, n), x, y,
  i) = (((x[c]) * (x[t1])) + ((1 - (x[c])) * (x[t2]))))))))))))))

axiom fredkinqtspec7 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = t1)) -> ((not (i = t2)) ->
  (basis_ket1(fredkin1(c, t1, t2, n), x, y, i) = (x[i])))))))))))))

axiom fredkinqtspec8 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(fredkin1(c, t1, t2, n), x, y) = infix_sldtsl(1, 0))))))))))

logic swap1 : int, int, int -> circuit1

axiom swapqtspec :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (pre1(swap1(t1, t2,
  n)) = Swap1(t1, t2, n))))))

axiom swapqtspec1 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (ancillas1(swap1(t1, t2,
  n)) = 0)))))

axiom swapqtspec2 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (size1(swap1(t1, t2,
  n)) = 1)))))

axiom swapqtspec3 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (range1(swap1(t1, t2,
  n)) = 0)))))

axiom swapqtspec4 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (width1(swap1(t1, t2,
  n)) = n)))))

axiom swapqtspec5 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t1) -> (basis_ket1(swap1(t1, t2, n), x, y,
  i) = (x[t2])))))))))

axiom swapqtspec6 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((i = t2) -> (basis_ket1(swap1(t1, t2, n), x, y,
  i) = (x[t1])))))))))

axiom swapqtspec7 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. ((not (i = t1)) -> ((not (i = t2)) -> (basis_ket1(swap1(t1,
  t2, n), x, y, i) = (x[i]))))))))))

axiom swapqtspec8 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(swap1(t1,
  t2, n), x, y) = infix_sldtsl(1, 0)))))))

logic place1 : circuit1, int, int -> circuit1

logic fc604 : int, (int,int) farray -> (int,int) farray

logic fc605 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef607 :
  (forall k:int. forall x:(int,int) farray. forall j:int. ((fc604(k,
  x)[j]) = (x[(j + k)])))

axiom fcqtdef608 :
  (forall k:int. forall x:(int,int) farray. forall j:int. ((fc605(k,
  x)[j]) = (x[(j + k)])))

axiom placeqtspec7 :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (pre1(place1(c, k, n)) = Place(pre1(c), k,
  n)))))

axiom placeqtspec8 :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (ancillas1(place1(c, k, n)) = ancillas1(c)))))

axiom placeqtspec9 :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (size1(place1(c, k, n)) = size1(c)))))

axiom placeqtspec10 :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (width1(place1(c, k, n)) = n))))

axiom placeqtspec11 :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (range1(place1(c, k, n)) = range1(c)))))

axiom placeqtspec12 :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(place1(c, k, n), x, y, i) = (if ((k <= i) and
  (i <  (k + width1(c)))) then basis_ket1(c, fc604(k, x), y,
  (i - k)) else (x[i]))))))))

axiom placeqtspec13 :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(place1(c,
  k, n), x, y) = ang_ind1(c, fc605(k, x), y))))))

logic cont1 : circuit1, int, int, int -> circuit1

logic fc606 : int, (int,int) farray -> (int,int) farray

logic fc607 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef609 :
  (forall k:int. forall x:(int,int) farray. forall j:int. ((fc606(k,
  x)[j]) = (x[(j + k)])))

axiom fcqtdef610 :
  (forall k:int. forall x:(int,int) farray. forall j:int. ((fc607(k,
  x)[j]) = (x[(j + k)])))

axiom contqtspec3 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (pre1(cont1(c, co, k,
  n)) = Cont(pre1(c), co, k, n))))))

axiom contqtspec4 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (width1(cont1(c, co, k,
  n)) = n)))))

axiom contqtspec5 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (ancillas1(cont1(c, co, k,
  n)) = ancillas1(c))))))

axiom contqtspec6 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (size1(cont1(c, co, k,
  n)) = (size1(c) * cont_size1))))))

axiom contqtspec7 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (range1(cont1(c, co, k,
  n)) = range1(c))))))

axiom contqtspec8 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(cont1(c, co, k, n), x, y,
  i) = (if (((x[co]) = 1) and ((k <= i) and
  (i <  (k + width1(c))))) then basis_ket1(c, fc606(k, x), y,
  (i - k)) else (x[i])))))))))

axiom contqtspec9 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(cont1(c,
  co, k, n), x, y) = ang_add(ang_mult_int(ang_ind1(c, fc607(k, x), y),
  (x[co])), ang_mult_int(phase_inv_((y[0]),
  arc_cos_ang(pow_inv_sqrt_2(range1(c)))), (1 - (x[co]))))))))))

logic infix_mnmn : circuit1, circuit1 -> circuit1

logic fc608 : circuit1, (int,int) farray -> (int,int) farray

logic fc609 : circuit1, (int,int) farray -> (int,int) farray

axiom fcqtdef611 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc608(d,
  y)[k]) = (y[(k + range1(d))])))

axiom fcqtdef612 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc609(d,
  y)[k]) = (y[(k + range1(d))])))

axiom infix_mnmnqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  (pre1(infix_mnmn(d, e)) = Sequence1(pre1(d), pre1(e)))))

axiom infix_mnmnqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  (ancillas1(infix_mnmn(d, e)) = max(ancillas1(d), ancillas1(e)))))

axiom infix_mnmnqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  (size1(infix_mnmn(d, e)) = (size1(d) + size1(e)))))

axiom infix_mnmnqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  (width1(infix_mnmn(d, e)) = width1(d))))

axiom infix_mnmnqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  (range1(infix_mnmn(d, e)) = (range1(d) + range1(e)))))

axiom infix_mnmnqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(infix_mnmn(d, e), x, y, i) = basis_ket1(e,
  (((basis_ket_closure1[d])[x])[y]), fc608(d, y), i))))))

axiom infix_mnmnqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(infix_mnmn(d, e), x, y) = ang_add(ang_ind1(d, x, y), ang_ind1(e,
  (((basis_ket_closure1[d])[x])[y]), fc609(d, y)))))))

axiom sequence_eq1 :
  (forall d:circuit1. forall dqt:circuit1. forall e:circuit1.
  forall eqt:circuit1. ((width1(d) = width1(e)) -> ((d = dqt) ->
  ((e = eqt) -> (infix_mnmn(d, e) = infix_mnmn(dqt, eqt))))))

logic infix_slsl : circuit1, circuit1 -> circuit1

logic fc610 : circuit1, (int,int) farray -> (int,int) farray

logic fc611 : circuit1, (int,int) farray -> (int,int) farray

logic fc612 : circuit1, (int,int) farray -> (int,int) farray

logic fc613 : circuit1, (int,int) farray -> (int,int) farray

axiom fcqtdef613 :
  (forall d:circuit1. forall x:(int,int) farray. forall k:int. ((fc610(d,
  x)[k]) = (x[(k + width1(d))])))

axiom fcqtdef614 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc611(d,
  y)[k]) = (y[(k + range1(d))])))

axiom fcqtdef615 :
  (forall d:circuit1. forall x:(int,int) farray. forall k:int. ((fc612(d,
  x)[k]) = (x[(k + width1(d))])))

axiom fcqtdef616 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc613(d,
  y)[k]) = (y[(k + range1(d))])))

axiom infix_slslqtspec :
  (forall d:circuit1. forall e:circuit1. (pre1(infix_slsl(d,
  e)) = Parallel1(pre1(d), pre1(e))))

axiom infix_slslqtspec1 :
  (forall d:circuit1. forall e:circuit1. (ancillas1(infix_slsl(d,
  e)) = (ancillas1(d) + ancillas1(e))))

axiom infix_slslqtspec2 :
  (forall d:circuit1. forall e:circuit1. (size1(infix_slsl(d,
  e)) = (size1(d) + size1(e))))

axiom infix_slslqtspec3 :
  (forall d:circuit1. forall e:circuit1. (width1(infix_slsl(d,
  e)) = (width1(d) + width1(e))))

axiom infix_slslqtspec4 :
  (forall d:circuit1. forall e:circuit1. (range1(infix_slsl(d,
  e)) = (range1(d) + range1(e))))

axiom infix_slslqtspec5 :
  (forall d:circuit1. forall e:circuit1.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(infix_slsl(d, e), x, y,
  i) = (if (i <  width1(d)) then basis_ket1(d, x, y, i) else basis_ket1(e,
  fc610(d, x), fc611(d, y), (i - width1(d))))))))

axiom infix_slslqtspec6 :
  (forall d:circuit1. forall e:circuit1.
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(infix_slsl(d, e), x, y) = ang_add(ang_ind1(d, x, y), ang_ind1(e,
  fc612(d, x), fc613(d, y))))))

logic path_sem_basis1 : circuit1, complex matrix -> complex matrix

logic result81 : circuit1, complex matrix -> (bitvec,complex matrix) farray

axiom resultqtdef88 :
  (forall c:circuit1. forall x:complex matrix. forall y:bitvec. ((result81(c,
  x)[y]) = infix_asdtdt(ang_exp(ang_ind1(c, value(ket_to_bv(x)), value(y))),
  bv_to_ket(make_bv((((basis_ket_closure1[c])[value(ket_to_bv(x))])[value(y)]),
  width1(c))))))

axiom path_sem_basisqtdef1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(c,
  x) = infix_asdtdt(pow_inv_sqrt_2(range1(c)), ket_sum_l(n_bvs(range1(c)),
  result81(c, x), width1(c)))))))

axiom path_sem_basisqtspec2 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> is_a_ket_l(path_sem_basis1(c, x), width1(c)))))

axiom path_sem_basisqtspec3 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(c,
  x) = pps_apply_basis(circ_to_pps1(c), ket_to_bv(x))))))

logic path_sem1 : circuit1, complex matrix -> complex matrix

logic result82 : circuit1, complex matrix -> (bitvec,complex matrix) farray

axiom resultqtdef89 :
  (forall c:circuit1. forall x:complex matrix. forall y:bitvec. ((result82(c,
  x)[y]) = (if (length(y) = width1(c)) then infix_asdtdt(get(x, bv_to_int(y),
  0), path_sem_basis1(c, bv_to_ket(y))) else x)))

axiom path_semqtdef1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (path_sem1(c, x) = ket_sum_l(n_bvs(width1(c)), result82(c, x),
  width1(c)))))

axiom path_semqtspec2 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  is_a_ket_l(path_sem1(c, x), width1(c))))

axiom path_semqtspec3 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (path_sem1(c, x) = pps_apply(circ_to_pps1(c), x))))

logic ancilla_pre : circuit1, int -> circuit1

logic fc614 : circuit1, int, (int,int) farray -> (int,int) farray

logic fc615 : circuit1, int, (int,int) farray -> (int,int) farray

axiom fcqtdef617 :
  (forall c:circuit1. forall l:int. forall x:(int,int) farray. forall k:int.
  ((fc614(c, l, x)[k]) = (if (k <  (width1(c) - l)) then (x[k]) else 0)))

axiom fcqtdef618 :
  (forall c:circuit1. forall l:int. forall x:(int,int) farray. forall k:int.
  ((fc615(c, l, x)[k]) = (if (k <  (width1(c) - l)) then (x[k]) else 0)))

axiom ancilla_preqtspec :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (pps_apply(circ_to_pps1(c), kronecker(x, ket(l,
   0))) = kronecker((path_sem_target[x]), ket(l, 0)))))) ->
  (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
  (pps_apply(circ_to_pps1(c), kronecker(x, ket(l,
  0))) = kronecker(path_sem1(ancilla_pre(c, l), x), ket(l, 0)))))))))

axiom ancilla_preqtspec1 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (pps_apply(circ_to_pps1(c), kronecker(x, ket(l,
   0))) = kronecker((path_sem_target[x]), ket(l, 0)))))) ->
  (pre1(ancilla_pre(c, l)) = Ancillas1(pre1(c), l))))))

axiom ancilla_preqtspec2 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (pps_apply(circ_to_pps1(c), kronecker(x, ket(l,
   0))) = kronecker((path_sem_target[x]), ket(l, 0)))))) ->
  (ancillas1(ancilla_pre(c, l)) = (ancillas1(c) + l))))))

axiom ancilla_preqtspec3 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (pps_apply(circ_to_pps1(c), kronecker(x, ket(l,
   0))) = kronecker((path_sem_target[x]), ket(l, 0)))))) ->
  (size1(ancilla_pre(c, l)) = size1(c))))))

axiom ancilla_preqtspec4 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (pps_apply(circ_to_pps1(c), kronecker(x, ket(l,
   0))) = kronecker((path_sem_target[x]), ket(l, 0)))))) ->
  (width1(ancilla_pre(c, l)) = (width1(c) - l))))))

axiom ancilla_preqtspec5 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (pps_apply(circ_to_pps1(c), kronecker(x, ket(l,
   0))) = kronecker((path_sem_target[x]), ket(l, 0)))))) ->
  (range1(ancilla_pre(c, l)) = range1(c))))))

axiom ancilla_preqtspec6 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (pps_apply(circ_to_pps1(c), kronecker(x, ket(l,
   0))) = kronecker((path_sem_target[x]), ket(l, 0)))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(ancilla_pre(c, l), x, y, i) = basis_ket1(c,
  fc614(c, l, x), y, i))))))))

axiom ancilla_preqtspec7 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((exists path_sem_target:(complex matrix,complex matrix) farray.
   (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (pps_apply(circ_to_pps1(c), kronecker(x, ket(l,
   0))) = kronecker((path_sem_target[x]), ket(l, 0)))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(ancilla_pre(c, l), x, y) = ang_ind1(c, fc615(c, l, x), y)))))))

logic ancilla1 : circuit1, int -> circuit1

logic fc616 : circuit1, int, (int,int) farray -> (int,int) farray

logic fc617 : circuit1, int, (int,int) farray -> (int,int) farray

axiom fcqtdef619 :
  (forall c:circuit1. forall l:int. forall x:(int,int) farray. forall k:int.
  ((fc616(c, l, x)[k]) = (if (k <  (width1(c) - l)) then (x[k]) else 0)))

axiom fcqtdef620 :
  (forall c:circuit1. forall l:int. forall x:(int,int) farray. forall k:int.
  ((fc617(c, l, x)[k]) = (if (k <  (width1(c) - l)) then (x[k]) else 0)))

axiom ancillaqtspec3 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (is_a_ket_basis_elt(x) ->
   (exists y:complex matrix. (path_sem1(c, kronecker(x, ket(l,
   0))) = kronecker(y, ket(l, 0))))))) ->
  (forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) -> (path_sem1(c,
  kronecker(x, ket(l, 0))) = kronecker(path_sem1(ancilla1(c, l), x), ket(l,
  0)))))))))

axiom ancillaqtspec4 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (is_a_ket_basis_elt(x) ->
   (exists y:complex matrix. (path_sem1(c, kronecker(x, ket(l,
   0))) = kronecker(y, ket(l, 0))))))) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  (width1(c) - l)) -> ((path_sem1(c, kronecker(x, ket(l, 0))) = kronecker(y,
  ket(l, 0))) -> (path_sem1(ancilla1(c, l), x) = y))))))))

axiom ancillaqtspec5 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (is_a_ket_basis_elt(x) ->
   (exists y:complex matrix. (path_sem1(c, kronecker(x, ket(l,
   0))) = kronecker(y, ket(l, 0))))))) ->
  (pre1(ancilla1(c, l)) = Ancillas1(pre1(c), l))))))

axiom ancillaqtspec6 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (is_a_ket_basis_elt(x) ->
   (exists y:complex matrix. (path_sem1(c, kronecker(x, ket(l,
   0))) = kronecker(y, ket(l, 0))))))) ->
  (ancillas1(ancilla1(c, l)) = (ancillas1(c) + l))))))

axiom ancillaqtspec7 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (is_a_ket_basis_elt(x) ->
   (exists y:complex matrix. (path_sem1(c, kronecker(x, ket(l,
   0))) = kronecker(y, ket(l, 0))))))) ->
  (size1(ancilla1(c, l)) = size1(c))))))

axiom ancillaqtspec8 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (is_a_ket_basis_elt(x) ->
   (exists y:complex matrix. (path_sem1(c, kronecker(x, ket(l,
   0))) = kronecker(y, ket(l, 0))))))) ->
  (width1(ancilla1(c, l)) = (width1(c) - l))))))

axiom ancillaqtspec9 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (is_a_ket_basis_elt(x) ->
   (exists y:complex matrix. (path_sem1(c, kronecker(x, ket(l,
   0))) = kronecker(y, ket(l, 0))))))) ->
  (range1(ancilla1(c, l)) = range1(c))))))

axiom ancillaqtspec10 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (is_a_ket_basis_elt(x) ->
   (exists y:complex matrix. (path_sem1(c, kronecker(x, ket(l,
   0))) = kronecker(y, ket(l, 0))))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(ancilla1(c, l), x, y, i) = basis_ket1(c,
  fc616(c, l, x), y, i))))))))

axiom ancillaqtspec11 :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - l)) ->
   (is_a_ket_basis_elt(x) ->
   (exists y:complex matrix. (path_sem1(c, kronecker(x, ket(l,
   0))) = kronecker(y, ket(l, 0))))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(ancilla1(c, l), x, y) = ang_ind1(c, fc617(c, l, x), y)))))))

axiom set_ancilla_circ :
  (forall x:wired_circuit. forall c:circuit1. forall l:int. ((1 <= l) ->
  ((l <  width1(c)) -> (correct1(x) -> ((pre1(c) = Ancillas1(x, l)) ->
  (c = ancilla1(to_qc1(x), l)))))))

axiom get_path_sem_basis1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(c, x) = path_sem_basis1(c, x)))))

logic fc618 : circuit1, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef621 :
  (forall c:circuit1. forall x:complex matrix. forall y:bitvec. ((fc618(c,
  x)[y]) = infix_asdtdt(ang_exp(ang_ind1(c, value(ket_to_bv(x)), value(y))),
  bv_to_ket(make_bv((((basis_ket_closure1[c])[value(ket_to_bv(x))])[value(y)]),
  width1(c))))))

axiom rewrite_path_sem_basis :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(c,
  x) = infix_asdtdt(pow_inv_sqrt_2(range1(c)), ket_sum_l(n_bvs(range1(c)),
  fc618(c, x), width1(c)))))))

axiom path_sem_basis_comp_ :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  (is_a_ket_l(x, width1(d)) -> (is_a_ket_basis_elt(x) ->
  ((width1(d) = width1(e)) -> (path_sem_basis1(infix_mnmn(d, e),
  x) = path_sem1(e, path_sem_basis1(d, x)))))))

axiom path_sem_basis_kron :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  forall xqt:complex matrix. forall y:complex matrix.
  forall yqt:complex matrix. (is_a_ket_l(x, width1(d)) -> (is_a_ket_l(y,
  width1(e)) -> (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  ((path_sem_basis1(d, x) = xqt) -> ((path_sem_basis1(e, y) = yqt) ->
  (path_sem_basis1(infix_slsl(d, e), kronecker(x, y)) = kronecker(xqt,
  yqt)))))))))

axiom path_sem_basis_par :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  (is_a_ket_l(x, (width1(d) + width1(e))) -> (is_a_ket_basis_elt(x) ->
  (path_sem1(infix_slsl(d, e), x) = kronecker(path_sem1(d,
  bv_to_ket(hpart(ket_to_bv(x), width1(d)))), path_sem1(e,
  bv_to_ket(tpart(ket_to_bv(x), width1(d)))))))))

axiom path_sem_comp_1 :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  (is_a_ket_l(x, width1(d)) -> ((width1(d) = width1(e)) ->
  (path_sem1(infix_mnmn(d, e), x) = path_sem1(e, path_sem1(d, x))))))

axiom path_sem_kron1 :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  forall xqt:complex matrix. forall y:complex matrix.
  forall yqt:complex matrix. (is_a_ket_l(x, width1(d)) -> (is_a_ket_l(y,
  width1(e)) -> ((path_sem1(d, x) = xqt) -> ((path_sem1(e, y) = yqt) ->
  (path_sem1(infix_slsl(d, e), kronecker(x, y)) = kronecker(xqt, yqt)))))))

axiom path_sem_comp_rev :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  (is_a_ket_l(x, width1(d)) -> ((width1(d) = width1(e)) -> (path_sem1(e,
  path_sem1(d, x)) = path_sem1(infix_mnmn(d, e), x)))))

axiom unwire_path_sem :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (path_sem1(c, x) = path_sem(unwire(c), x))))

axiom unwire_path_sem_basis :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(c,
  x) = path_sem_basis(unwire(c), x)))))

axiom unwire_width : (forall c:circuit1. (width1(c) = width(unwire(c))))

logic wire_pre : circuit_pre -> circuit1

axiom wire_preqtdef :
  (forall c:circuit_pre. (correct(c) ->
  (forall k:int. ((c = Phase(k)) -> (wire_pre(c) = phase1(k))))))

axiom wire_preqtdef1 :
  (forall c:circuit_pre. (correct(c) ->
  (forall k:int. ((c = Rz(k)) -> (wire_pre(c) = rzp(k))))))

axiom wire_preqtdef2 :
  (forall c:circuit_pre. (correct(c) -> ((c = Hadamard) ->
  (wire_pre(c) = hadamard1))))

axiom wire_preqtdef3 :
  (forall c:circuit_pre. (correct(c) -> ((c = Cnot) ->
  (wire_pre(c) = bricks_cnot))))

axiom wire_preqtdef4 :
  (forall c:circuit_pre. (correct(c) -> ((c = Swap) ->
  (wire_pre(c) = bricks_swap))))

axiom wire_preqtdef5 :
  (forall c:circuit_pre. (correct(c) -> ((c = Id) -> (wire_pre(c) = skip))))

axiom wire_preqtdef6 :
  (forall c:circuit_pre. (correct(c) ->
  (forall d:circuit_pre. forall e:circuit_pre. ((c = Sequence(d, e)) ->
  (wire_pre(c) = infix_mnmn(wire_pre(d), wire_pre(e)))))))

axiom wire_preqtdef7 :
  (forall c:circuit_pre. (correct(c) ->
  (forall d:circuit_pre. forall e:circuit_pre. ((c = Parallel(d, e)) ->
  (wire_pre(c) = infix_slsl(wire_pre(d), wire_pre(e)))))))

axiom wire_preqtdef8 :
  (forall c:circuit_pre. (correct(c) ->
  (forall d:circuit_pre. forall l:int. ((c = Ancillas(d, l)) ->
  (wire_pre(c) = ancilla1(wire_pre(d), l))))))

axiom wire_preqtspec :
  (forall c:circuit_pre. (correct(c) ->
  (width1(wire_pre(c)) = width_pre(c))))

axiom wire_preqtspec1 :
  (forall c:circuit_pre. (correct(c) ->
  (forall x:complex matrix. (is_a_ket_l(x, width1(wire_pre(c))) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(wire_pre(c),
  x) = path_sem_basis(to_qc(c), x)))))))

axiom wire_preqtspec2 :
  (forall c:circuit_pre. (correct(c) ->
  (forall x:complex matrix. (is_a_ket_l(x, width1(wire_pre(c))) ->
  (path_sem1(wire_pre(c), x) = path_sem(to_qc(c), x))))))

function wire(c: circuit) : circuit1 = wire_pre(pre(c))

axiom wireqtspec : (forall c:circuit. (width1(wire(c)) = width(c)))

axiom wireqtspec1 :
  (forall c:circuit.
  (forall x:complex matrix. (is_a_ket_l(x, width1(wire(c))) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(wire(c), x) = path_sem_basis(c,
  x))))))

axiom wireqtspec2 :
  (forall c:circuit.
  (forall x:complex matrix. (is_a_ket_l(x, width1(wire(c))) ->
  (path_sem1(wire(c), x) = path_sem(c, x)))))

axiom wire_path_sem :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (path_sem(c, x) = path_sem1(wire(c), x))))

axiom wire_path_sem_basis :
  (forall c:circuit. forall x:complex matrix. (is_a_ket_l(x, width(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis(c, x) = path_sem_basis1(wire(c),
  x)))))

axiom wire_width : (forall c:circuit. (width(c) = width1(wire(c))))

axiom unwire_embedding_path_sem :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (path_sem1(c, x) = path_sem1(wire(unwire(c)), x))))

axiom unwire_embedding_path_sem_basis :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(c,
  x) = path_sem_basis1(wire(unwire(c)), x)))))

axiom to_qc_rev1 : (forall c:circuit1. (c = to_qc1(pre1(c))))

axiom to_qc_pre1 : (forall c:circuit1. (to_qc1(pre1(c)) = c))

axiom pre_rev1 :
  (forall c:wired_circuit. (correct1(c) -> (c = pre1(to_qc1(c)))))

axiom pre_to_qc1 :
  (forall c:wired_circuit. (correct1(c) -> (pre1(to_qc1(c)) = c)))

axiom path_sem_apply1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (path_sem1(c, x) = pps_apply(circ_to_pps1(c), x))))

axiom apply_path_sem1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (pps_apply(circ_to_pps1(c), x) = path_sem1(c, x))))

predicate correct_path_sum(c: circuit1, p: pps) =
  pps_apply_equiv(circ_to_pps1(c), p)

axiom set_correct_pps_basis :
  (forall c:circuit1. forall h:pps. ((h_width(h) = width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(h, x) = path_sem_basis1(c, x))))) ->
  correct_path_sum(c, h))))

axiom set_correct_pps1 :
  (forall c:circuit1. forall h:pps. ((h_width(h) = width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(h, x) = path_sem1(c, x))))) ->
  correct_path_sum(c, h))))

axiom get_correct_pps :
  (forall c:circuit1. forall h:pps. forall x:complex matrix.
  ((h_width(h) = width1(c)) -> (is_a_ket_l(x, width1(c)) ->
  (correct_path_sum(c, h) -> (pps_apply(h, x) = path_sem1(c, x))))))

axiom unwire_correct :
  (forall c:circuit1. forall h:pps. (correct_path_sum(c, h) ->
  correct_path_sum_(unwire(c), h)))

axiom unwire_correct_rev :
  (forall c:circuit1. forall h:pps. (correct_path_sum_(unwire(c), h) ->
  correct_path_sum(c, h)))

axiom wire_correct :
  (forall c:circuit. forall h:pps. (correct_path_sum_(c, h) ->
  correct_path_sum(wire(c), h)))

axiom unwire_ancillable :
  (forall c:circuit1. forall l:int. ((0 <= l) -> (ancillable(pre1(c), l) ->
  ancillable_pre(pre(unwire(c)), l))))

axiom unwire_sequence :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  (unwire(infix_mnmn(d, e)) = sequence(unwire(d), unwire(e)))))

axiom unwire_parallel :
  (forall d:circuit1. forall e:circuit1. (unwire(infix_slsl(d,
  e)) = parallel(unwire(d), unwire(e))))

axiom unwire_place :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (unwire(place1(c, k, n)) = place(unwire(c), k,
  n)))))

axiom unwire_cont :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (unwire(cont1(c, co, k,
  n)) = cont(unwire(c), co, k, n))))))

axiom unwire_ancilla :
  (forall c:circuit1. forall l:int. ((1 <= l) -> ((l <  width1(c)) ->
  (ancillable(pre1(c), l) -> (unwire(ancilla1(c, l)) = ancilla(unwire(c),
  l))))))

axiom unwire_skip : (unwire(skip) = id)

axiom unwire_hadamard : (unwire(hadamard1) = hadamard)

axiom unwire_s : (unwire(s) = rz(2))

axiom unwire_t : (unwire(t) = rz(3))

axiom unwire_xx : (unwire(xx1) = xx)

axiom unwire_yy : (unwire(yy1) = yy)

axiom unwire_zz : (unwire(zz1) = zz)

axiom unwire_phase : (forall k:int. (unwire(phase1(k)) = phase(k)))

axiom unwire_rx : (forall k:int. (unwire(rx1(k)) = rx(k)))

axiom unwire_ry : (forall k:int. (unwire(ry1(k)) = ry(k)))

axiom unwire_rz : (forall k:int. (unwire(rz1(k)) = rz_(k)))

axiom unwire_rzp : (forall k:int. (unwire(rzp(k)) = rz(k)))

axiom unwire_cnot :
  (forall c:int. forall t1:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = c)) -> (unwire(cnot1(c, t1,
  n)) = place_cnot(c, t1, n))))))

axiom unwire_swap :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t2 = t1)) -> (unwire(swap1(t1, t2,
  n)) = swap_c(t1, t2, n))))))

axiom unwire_toffoli :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (unwire(toffoli1(c1, c2, t1, n)) = place_toffoli(c1, c2, t1, n)))))))))

axiom unwire_fredkin :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (unwire(fredkin1(c, t1, t2, n)) = place_fredkin(c, t1, t2, n)))))))))

axiom wire_sequence :
  (forall d:circuit. forall e:circuit. ((width(d) = width(e)) ->
  (wire(sequence(d, e)) = infix_mnmn(wire(d), wire(e)))))

axiom wire_parallel :
  (forall d:circuit. forall e:circuit. (wire(parallel(d,
  e)) = infix_slsl(wire(d), wire(e))))

axiom wire_ancilla :
  (forall c:circuit. forall l:int. ((1 <= l) -> ((l <  width(c)) ->
  (ancillable_pre(pre(c), l) -> (wire(ancilla(c, l)) = ancilla1(wire(c),
  l))))))

axiom positive_width : (forall c:circuit1. (0 <= width1(c)))

axiom circ_to_pps_width1 :
  (forall c:circuit1. (h_width(circ_to_pps1(c)) = width1(c)))

axiom circ_to_pps_range1 :
  (forall c:circuit1. (h_range(circ_to_pps1(c)) = range1(c)))

axiom circ_to_pps_basis_ket1 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  forall i:int. ((((h_basis_ket(circ_to_pps1(c))[x])[y])[i]) = basis_ket1(c,
  x, y, i)))

axiom circ_to_pps_basis_ket_gen1 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_basis_ket(circ_to_pps1(c))[x])[y]) = (((basis_ket_closure1[c])[x])[y])))

axiom circ_to_pps_angle1 :
  (forall c:circuit1. forall x:(int,int) farray. forall y:(int,int) farray.
  (((h_angle(circ_to_pps1(c))[x])[y]) = ang_ind1(c, x, y)))

predicate sem1(c: circuit1, x: complex matrix, y: complex matrix) =
  (is_a_ket_l(x, width1(c)) and infix_eqeq(y, path_sem1(c, x)))

axiom path_sem_to_sem1 :
  (forall c:circuit1. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, width1(c)) -> ((path_sem1(c, x) = y) -> sem1(c, x, y))))

axiom sem_to_path_sem1 :
  (forall c:circuit1. forall x:complex matrix. forall y:complex matrix.
  (sem1(c, x, y) -> (path_sem1(c, x) = y)))

logic fc619 : circuit1, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef622 :
  (forall c:circuit1. forall x:complex matrix. forall y:bitvec. ((fc619(c,
  x)[y]) = infix_asdtdt(get(x, bv_to_int(y), 0), path_sem_basis1(c,
  bv_to_ket(y)))))

axiom get_path_sem1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (path_sem1(c, x) = ket_sum_l(n_bvs(width1(c)), fc619(c, x), width1(c)))))

logic fc620 : circuit1, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef623 :
  (forall c:circuit1. forall x:complex matrix. forall y:bitvec. ((fc620(c,
  x)[y]) = infix_asdtdt(get(x, bv_to_int(y), 0), path_sem_basis1(c,
  bv_to_ket(y)))))

axiom get_path_sem_gen :
  (forall c:circuit1.
  (forall x:complex matrix. (is_a_ket_l(x, width1(c)) -> (path_sem1(c,
  x) = ket_sum_l(n_bvs(width1(c)), fc620(c, x), width1(c))))))

logic fc621 : circuit1, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef624 :
  (forall c:circuit1. forall x:complex matrix. forall z:bitvec. ((fc621(c,
  x)[z]) = infix_asdtdt(get(x, bv_to_int(z), 0), path_sem1(c,
  bv_to_ket(z)))))

axiom path_sem_decomp1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (path_sem1(c, x) = ket_sum_l(n_bvs(width1(c)), fc621(c, x), width1(c)))))

logic ancilla_g1 : circuit1, int,
  (complex matrix,complex matrix) farray -> circuit1

axiom ancilla_gqtdef1 :
  (forall c:circuit1. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - i)) -> (path_sem1(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (ancilla_g1(c, i, path_sem_target) = ancilla1(c, i))))))

logic fc622 : circuit1, int, (int,int) farray -> (int,int) farray

logic fc623 : circuit1, int, (int,int) farray -> (int,int) farray

axiom fcqtdef625 :
  (forall c:circuit1. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc622(c, i, x)[k]) = (if (k <  (width1(c) - i)) then (x[k]) else 0)))

axiom fcqtdef626 :
  (forall c:circuit1. forall i:int. forall x:(int,int) farray. forall k:int.
  ((fc623(c, i, x)[k]) = (if (k <  (width1(c) - i)) then (x[k]) else 0)))

axiom ancilla_gqtspec8 :
  (forall c:circuit1. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - i)) -> (path_sem1(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (ancillas1(ancilla_g1(c, i, path_sem_target)) = (ancillas1(c) + i))))))

axiom ancilla_gqtspec9 :
  (forall c:circuit1. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - i)) -> (path_sem1(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (size1(ancilla_g1(c, i, path_sem_target)) = size1(c))))))

axiom ancilla_gqtspec10 :
  (forall c:circuit1. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - i)) -> (path_sem1(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (range1(ancilla_g1(c, i, path_sem_target)) = range1(c))))))

axiom ancilla_gqtspec11 :
  (forall c:circuit1. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - i)) -> (path_sem1(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (width1(ancilla_g1(c, i, path_sem_target)) = (width1(c) - i))))))

axiom ancilla_gqtspec12 :
  (forall c:circuit1. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - i)) -> (path_sem1(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall ii:int. (basis_ket1(ancilla_g1(c, i, path_sem_target), x, y,
  ii) = basis_ket1(c, fc622(c, i, x), y, ii))))))))

axiom ancilla_gqtspec13 :
  (forall c:circuit1. forall i:int.
  forall path_sem_target:(complex matrix,complex matrix) farray. ((1 <= i) ->
  (((i + 1) <= width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, (width1(c) - i)) -> (path_sem1(c,
   kronecker(x, ket(i, 0))) = kronecker((path_sem_target[x]), ket(i, 0))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(ancilla_g1(c, i, path_sem_target), x, y) = ang_ind1(c, fc623(c,
  i, x), y)))))))

logic sequence_ghost_pps1 : circuit1, circuit1, pps, pps, pps -> circuit1

logic fc624 : pps, (int,int) farray -> (int,int) farray

logic fc625 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef627 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc624(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef628 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc625(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom sequence_ghost_ppsqtdef1 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((width1(c) = width1(cqt)) -> ((h_width(hqtqt) = width1(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc624(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc625(h,
   y)])[i]))))))) ->
  (sequence_ghost_pps1(c, cqt, h, hqt, hqtqt) = infix_mnmn(c, cqt))))))))))

logic fc626 : pps, (int,int) farray -> (int,int) farray

logic fc627 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef629 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc626(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef630 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc627(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom sequence_ghost_ppsqtspec5 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((width1(c) = width1(cqt)) -> ((h_width(hqtqt) = width1(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc626(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc627(h,
   y)])[i]))))))) ->
  (width1(sequence_ghost_pps1(c, cqt, h, hqt, hqtqt)) = width1(c))))))))))

axiom sequence_ghost_ppsqtspec6 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((width1(c) = width1(cqt)) -> ((h_width(hqtqt) = width1(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc626(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc627(h,
   y)])[i]))))))) ->
  (size1(sequence_ghost_pps1(c, cqt, h, hqt,
  hqtqt)) = (size1(c) + size1(cqt)))))))))))

axiom sequence_ghost_ppsqtspec7 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((width1(c) = width1(cqt)) -> ((h_width(hqtqt) = width1(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc626(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc627(h,
   y)])[i]))))))) ->
  (ancillas1(sequence_ghost_pps1(c, cqt, h, hqt, hqtqt)) = max(ancillas1(c),
  ancillas1(cqt)))))))))))

axiom sequence_ghost_ppsqtspec8 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((width1(c) = width1(cqt)) -> ((h_width(hqtqt) = width1(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc626(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc627(h,
   y)])[i]))))))) ->
  correct_path_sum(sequence_ghost_pps1(c, cqt, h, hqt, hqtqt), hqtqt)))))))))

logic parallel_ghost_pps1 : circuit1, circuit1, pps, pps, pps -> circuit1

logic fc628 : pps, (int,int) farray -> (int,int) farray

logic fc629 : pps, (int,int) farray -> (int,int) farray

logic fc630 : pps, (int,int) farray -> (int,int) farray

logic fc631 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef631 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc628(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef632 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc629(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef633 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc630(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef634 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc631(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom parallel_ghost_ppsqtdef1 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((h_width(hqtqt) = (width1(c) + width1(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc628(h, x)])[fc629(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc630(h,
   x)])[fc631(h, y)])[(i - h_width(h))]))))))) ->
  (parallel_ghost_pps1(c, cqt, h, hqt, hqtqt) = infix_slsl(c, cqt))))))))))

logic fc632 : pps, (int,int) farray -> (int,int) farray

logic fc633 : pps, (int,int) farray -> (int,int) farray

logic fc634 : pps, (int,int) farray -> (int,int) farray

logic fc635 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef635 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc632(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef636 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc633(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef637 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc634(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef638 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc635(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom parallel_ghost_ppsqtspec5 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((h_width(hqtqt) = (width1(c) + width1(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc632(h, x)])[fc633(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc634(h,
   x)])[fc635(h, y)])[(i - h_width(h))]))))))) ->
  correct_path_sum(parallel_ghost_pps1(c, cqt, h, hqt, hqtqt), hqtqt)))))))))

axiom parallel_ghost_ppsqtspec6 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((h_width(hqtqt) = (width1(c) + width1(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc632(h, x)])[fc633(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc634(h,
   x)])[fc635(h, y)])[(i - h_width(h))]))))))) ->
  (width1(parallel_ghost_pps1(c, cqt, h, hqt,
  hqtqt)) = (width1(c) + width1(cqt)))))))))))

axiom parallel_ghost_ppsqtspec7 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((h_width(hqtqt) = (width1(c) + width1(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc632(h, x)])[fc633(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc634(h,
   x)])[fc635(h, y)])[(i - h_width(h))]))))))) ->
  (size1(parallel_ghost_pps1(c, cqt, h, hqt,
  hqtqt)) = (size1(c) + size1(cqt)))))))))))

axiom parallel_ghost_ppsqtspec8 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((h_width(hqtqt) = (width1(c) + width1(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc632(h, x)])[fc633(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc634(h,
   x)])[fc635(h, y)])[(i - h_width(h))]))))))) ->
  (ancillas1(parallel_ghost_pps1(c, cqt, h, hqt,
  hqtqt)) = (ancillas1(c) + ancillas1(cqt)))))))))))

axiom path_sem_scal_1 :
  (forall c:circuit1. forall x:complex matrix. forall y:complex matrix.
  forall sc:complex. (is_a_ket_l(x, width1(c)) -> ((path_sem1(c, x) = y) ->
  (path_sem1(c, infix_asdtdt(sc, x)) = infix_asdtdt(sc, y)))))

axiom path_sem_scal1 :
  (forall c:circuit1. forall x:complex matrix. forall sc:complex.
  (is_a_ket_l(x, width1(c)) -> (path_sem1(c, infix_asdtdt(sc,
  x)) = infix_asdtdt(sc, path_sem1(c, x)))))

axiom path_sem_scal_rev1 :
  (forall c:circuit1. forall x:complex matrix. forall sc:complex.
  (is_a_ket_l(x, width1(c)) -> (infix_asdtdt(sc, path_sem1(c,
  x)) = path_sem1(c, infix_asdtdt(sc, x)))))

logic fc636 : circuit1, (int,int) farray -> (int,int) farray

logic fc637 : circuit1, (int,int) farray -> (int,int) farray

axiom fcqtdef639 :
  (forall d:circuit1. forall x:(int,int) farray. forall k:int. ((fc636(d,
  x)[k]) = (x[(k + width1(d))])))

axiom fcqtdef640 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc637(d,
  y)[k]) = (y[(k + range1(d))])))

axiom parallel_basis_ket1 :
  (forall d:circuit1. forall e:circuit1. forall x:(int,int) farray.
  forall y:(int,int) farray. forall i:int. (basis_ket1(infix_slsl(d, e), x,
  y, i) = (if (i <  width1(d)) then basis_ket1(d, x, y, i) else basis_ket1(e,
  fc636(d, x), fc637(d, y), (i - width1(d))))))

logic fc638 : circuit1, (int,int) farray -> (int,int) farray

logic fc639 : circuit1, (int,int) farray -> (int,int) farray

axiom fcqtdef641 :
  (forall d:circuit1. forall x:(int,int) farray. forall k:int. ((fc638(d,
  x)[k]) = (x[(k + width1(d))])))

axiom fcqtdef642 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc639(d,
  y)[k]) = (y[(k + range1(d))])))

axiom parallel_angle1 :
  (forall d:circuit1. forall e:circuit1. forall x:(int,int) farray.
  forall y:(int,int) farray. (ang_ind1(infix_slsl(d, e), x,
  y) = ang_add(ang_ind1(d, x, y), ang_ind1(e, fc638(d, x), fc639(d, y)))))

axiom path_sem_add1 :
  (forall c:circuit1. forall x:complex matrix. forall xqt:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix. (is_a_ket_l(x,
  width1(c)) -> (is_a_ket_l(xqt, width1(c)) -> ((path_sem1(c, x) = y) ->
  ((path_sem1(c, xqt) = yqt) -> (path_sem1(c, add_ket_l(x, xqt,
  width1(c))) = add_ket_l(y, yqt, width1(c))))))))

axiom path_sem_add_1 :
  (forall c:circuit1. forall x:complex matrix. forall xqt:complex matrix.
  forall n:int. (is_a_ket_l(x, width1(c)) -> (is_a_ket_l(xqt, width1(c)) ->
  ((width1(c) = n) -> (path_sem1(c, add_ket_l(x, xqt,
  n)) = add_ket_l(path_sem1(c, x), path_sem1(c, xqt), n))))))

axiom path_sem_scal_add_ket_l1 :
  (forall c:circuit1. forall x:complex matrix. forall xqt:complex matrix.
  forall a:complex. forall aqt:complex. forall n:int. ((width1(c) = n) ->
  (is_a_ket_l(x, n) -> (is_a_ket_l(xqt, n) -> (path_sem1(c,
  add_ket_l(infix_asdtdt(a, x), infix_asdtdt(aqt, xqt),
  n)) = add_ket_l(infix_asdtdt(a, path_sem1(c, x)), infix_asdtdt(aqt,
  path_sem1(c, xqt)), n))))))

axiom path_sem_substr1 :
  (forall c:circuit1. forall x:complex matrix. forall xqt:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix. (is_a_ket_l(x,
  width1(c)) -> (is_a_ket_l(xqt, width1(c)) -> ((path_sem1(c, x) = y) ->
  ((path_sem1(c, xqt) = yqt) -> (path_sem1(c, mat_substr(x,
  xqt)) = mat_substr(y, yqt)))))))

axiom path_sem_scal_add1 :
  (forall c:circuit1. forall x:complex matrix. forall xqt:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix. forall scal:complex.
  (is_a_ket_l(x, width1(c)) -> (is_a_ket_l(xqt, width1(c)) -> ((path_sem1(c,
  x) = y) -> ((path_sem1(c, xqt) = yqt) -> (path_sem1(c, infix_asdtdt(scal,
  add_ket_l(x, xqt, width1(c)))) = infix_asdtdt(scal, add_ket_l(y, yqt,
  width1(c)))))))))

axiom path_sem_basis_apply1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(c,
  x) = pps_apply_basis(circ_to_pps1(c), ket_to_bv(x))))))

logic fc640 : circuit1, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef643 :
  (forall c:circuit1. forall x:complex matrix. forall y:bitvec. ((fc640(c,
  x)[y]) = infix_asdtdt(ang_exp(ang_ind1(c, value(ket_to_bv(x)), value(y))),
  bv_to_ket(make_bv((((basis_ket_closure1[c])[value(ket_to_bv(x))])[value(y)]),
  width1(c))))))

axiom path_sem_basis_value1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(c,
  x) = infix_asdtdt(pow_inv_sqrt_2(range1(c)), ket_sum_l(n_bvs(range1(c)),
  fc640(c, x), width1(c)))))))

logic fc641 : circuit1, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef644 :
  (forall c:circuit1. forall x:complex matrix. forall y:bitvec. ((fc641(c,
  x)[y]) = infix_asdtdt(ang_exp(ang_ind1(c, value(ket_to_bv(x)), value(y))),
  bv_to_ket(make_bv((((basis_ket_closure1[c])[value(ket_to_bv(x))])[value(y)]),
  width1(c))))))

axiom path_sem_value_for_basis1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(c,
  x) = infix_asdtdt(pow_inv_sqrt_2(range1(c)), ket_sum_l(n_bvs(range1(c)),
  fc641(c, x), width1(c)))))))

axiom apply_path_sem_basis1 :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (pps_apply_basis(circ_to_pps1(c),
  ket_to_bv(x)) = path_sem_basis1(c, x)))))

axiom path_sem_ket_l1 :
  (forall c:circuit1. forall x:complex matrix. forall l:int. (is_a_ket_l(x,
  width1(c)) -> ((l = width1(c)) -> is_a_ket_l(path_sem1(c, x), l))))

axiom path_sem_scal_substr1 :
  (forall c:circuit1. forall x:complex matrix. forall xqt:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix. forall scal:complex.
  (is_a_ket_l(x, width1(c)) -> (is_a_ket_l(xqt, width1(c)) -> ((path_sem1(c,
  x) = y) -> ((path_sem1(c, xqt) = yqt) -> (path_sem1(c, infix_asdtdt(scal,
  mat_substr(x, xqt))) = infix_asdtdt(scal, mat_substr(y, yqt))))))))

axiom path_sem_sum1 :
  (forall c:circuit1. forall s1:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall n:int. ((1 <= cardinal(s1)) ->
  ((n = width1(c)) ->
  ((forall x:'a. (mem(x, s1) -> is_a_ket_l((f[x]), width1(c)))) ->
  ((forall x:'a. (mem(x, s1) -> (path_sem1(c, (f[x])) = (g[x])))) ->
  (path_sem1(c, ket_sum_l(s1, f, n)) = ket_sum_l(s1, g, n)))))))

logic fc642 : circuit1,
  (bitvec,complex) farray -> (bitvec,complex matrix) farray

axiom fcqtdef645 :
  (forall c:circuit1. forall f:(bitvec,complex) farray. forall x:bitvec.
  ((fc642(c, f)[x]) = infix_asdtdt((f[x]), path_sem1(c, bv_to_ket(x)))))

axiom path_sem_sum_diag1 :
  (forall c:circuit1. forall s1:bitvec set. forall f:(bitvec,complex) farray.
  forall l:int. ((s1 = n_bvs(l)) -> ((l = width1(c)) -> (path_sem1(c,
  ket_sum_l_diag(f, l)) = ket_sum_l(s1, fc642(c, f), l)))))

logic fc643 : circuit1,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef646 :
  (forall c:circuit1. forall f:('a,complex matrix) farray. forall x:'a.
  ((fc643(c, f)[x]) = path_sem1(c, (f[x]))))

axiom path_sem_sum_1 :
  (forall c:circuit1. forall s1:'a set. forall f:('a,complex matrix) farray.
  forall n:int. ((1 <= cardinal(s1)) -> ((n = width1(c)) ->
  ((forall x:'a. (mem(x, s1) -> is_a_ket_l((f[x]), width1(c)))) ->
  (path_sem1(c, ket_sum_l(s1, f, n)) = ket_sum_l(s1, fc643(c, f), n))))))

axiom path_sem_sum_gen1 :
  (forall c:circuit1. forall s1:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall n:int. ((1 <= cardinal(s1)) ->
  ((n = width1(c)) ->
  ((forall x:'a. (mem(x, s1) -> is_a_ket_l((f[x]), width1(c)))) ->
  ((forall x:'a. (mem(x, s1) -> (path_sem1(c, (f[x])) = (g[x])))) ->
  (path_sem1(c, ket_sum_l(s1, f, n)) = ket_sum_l(s1, g, n)))))))

axiom scal_path_sem_sum_gen1 :
  (forall c:circuit1. forall s1:'a set. forall f:('a,complex matrix) farray.
  forall g:('a,complex matrix) farray. forall n:int. forall nqt:int.
  forall a1:complex. forall b:complex. ((1 <= cardinal(s1)) ->
  ((n = width1(c)) ->
  ((forall x:'a. (mem(x, s1) -> is_a_ket_l((f[x]), width1(c)))) ->
  ((forall x:'a. (mem(x, s1) -> (path_sem1(c, (f[x])) = (g[x])))) ->
  ((a1 = b) -> ((n = nqt) -> (infix_asdtdt(a1, path_sem1(c, ket_sum_l(s1, f,
  n))) = infix_asdtdt(b, ket_sum_l(s1, g, nqt))))))))))

logic fc644 : circuit1,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef647 :
  (forall c:circuit1. forall f:('a,complex matrix) farray. forall x:'a.
  ((fc644(c, f)[x]) = path_sem1(c, (f[x]))))

axiom scal_path_sem_sum1 :
  (forall c:circuit1. forall s1:'a set. forall f:('a,complex matrix) farray.
  forall n:int. forall a1:complex. ((1 <= cardinal(s1)) ->
  ((n = width1(c)) ->
  ((forall x:'a. (mem(x, s1) -> is_a_ket_l((f[x]), width1(c)))) ->
  (infix_asdtdt(a1, path_sem1(c, ket_sum_l(s1, f, n))) = infix_asdtdt(a1,
  ket_sum_l(s1, fc644(c, f), n)))))))

logic fc645 : circuit1,
  ('a,complex matrix) farray -> ('a,complex matrix) farray

axiom fcqtdef648 :
  (forall c:circuit1. forall f:('a,complex matrix) farray. forall x:'a.
  ((fc645(c, f)[x]) = path_sem1(c, (f[x]))))

axiom path_sem_scal_sum1 :
  (forall c:circuit1. forall s1:'a set. forall f:('a,complex matrix) farray.
  forall n:int. forall a1:complex. ((1 <= cardinal(s1)) ->
  ((n = width1(c)) ->
  ((forall x:'a. (mem(x, s1) -> is_a_ket_l((f[x]), width1(c)))) ->
  (path_sem1(c, infix_asdtdt(a1, ket_sum_l(s1, f, n))) = infix_asdtdt(a1,
  ket_sum_l(s1, fc645(c, f), n)))))))

axiom path_sem_sequence_parallel_basis1 :
  (forall a:circuit1. forall b:circuit1. forall d:circuit1.
  forall e:circuit1. forall x:complex matrix. (is_a_ket_l(x,
  (width1(a) + width1(b))) -> ((width1(a) = width1(d)) ->
  ((width1(b) = width1(e)) -> (is_a_ket_basis_elt(x) ->
  (path_sem1(infix_mnmn(infix_slsl(a, b), infix_slsl(d, e)),
  x) = path_sem1(infix_slsl(infix_mnmn(a, d), infix_mnmn(b, e)), x)))))))

axiom path_sem_sequence_parallel1 :
  (forall a:circuit1. forall b:circuit1. forall d:circuit1.
  forall e:circuit1. forall x:complex matrix. (is_a_ket_l(x,
  (width1(a) + width1(b))) -> ((width1(a) = width1(d)) ->
  ((width1(b) = width1(e)) -> (path_sem1(infix_mnmn(infix_slsl(a, b),
  infix_slsl(d, e)), x) = path_sem1(infix_slsl(infix_mnmn(a, d),
  infix_mnmn(b, e)), x))))))

axiom path_sem_phase_basis1 :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(phase1(k),
  x) = (if (0 <= k) then infix_asdtdt(ang_exp(int_to_ang(1, k)),
  x) else infix_asdtdt(ang_exp(int_to_ang((- 1), (-k))), x))))))

axiom path_sem_phase_basis_inv1 :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(phase1(k), path_sem1(phase1((-k)),
  x)) = x))))

axiom path_sem_phase_inv1 :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem1(phase1(k), path_sem1(phase1((-k)), x)) = x)))

axiom path_sem_rz_basis1 :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(rzp(k),
  x) = infix_asdtdt(ang_exp(infix_sldtsl((value(ket_to_bv(x))[0]), k)),
  x)))))

axiom path_sem_rz_basis_inv1 :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(rzp(k), path_sem1(rzp((-k)),
  x)) = x))))

axiom path_sem_rz_inv1 :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem1(rzp(k), path_sem1(rzp((-k)), x)) = x)))

axiom path_sem_hadamard_zero1 :
  (forall x:complex matrix. ((x = ket(1, 0)) -> (path_sem1(hadamard1,
  x) = pps_apply(pps_hadamard, ket(1, 0)))))

axiom path_sem_hadamard_one1 :
  (forall x:complex matrix. ((x = ket(1, 1)) -> (path_sem1(hadamard1,
  x) = pps_apply(pps_hadamard, ket(1, 1)))))

axiom path_sem_hadamard_plus1 :
  (forall x:complex matrix. ((x = pps_apply(pps_hadamard, ket(1, 0))) ->
  (path_sem1(hadamard1, x) = ket(1, 0))))

axiom path_sem_hadamard_minus1 :
  (forall x:complex matrix. ((x = pps_apply(pps_hadamard, ket(1, 1))) ->
  (path_sem1(hadamard1, x) = ket(1, 1))))

axiom path_semnot_basis :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (is_a_ket_basis_elt(x) ->
  (path_sem1(bricks_cnot, x) = (if (ket_to_int(x) = 0) then ket(2,
  0) else (if (ket_to_int(x) = 1) then ket(2,
  1) else (if (ket_to_int(x) = 2) then ket(2, 3) else ket(2, 2))))))))

axiom path_sem_swap_basis1 :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (is_a_ket_basis_elt(x) ->
  (path_sem1(bricks_swap, x) = (if (ket_to_int(x) = 0) then ket(2,
  0) else (if (ket_to_int(x) = 1) then ket(2,
  2) else (if (ket_to_int(x) = 2) then ket(2, 1) else ket(2, 3))))))))

axiom hadamard_invol1 :
  (forall x:complex matrix. (is_a_ket_l(x, 1) -> (path_sem1(hadamard1,
  path_sem1(hadamard1, x)) = x)))

logic fc646 : pps, (int,int) farray -> (int,int) farray

logic fc647 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef649 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc646(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef650 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc647(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom correct_seq1 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((width1(c) = width1(cqt)) -> ((h_width(hqtqt) = width1(c)) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[((h_basis_ket(h)[x])[y])])[fc646(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[((h_basis_ket(h)[x])[y])])[fc647(h,
   y)])[i]))))))) ->
  correct_path_sum(infix_mnmn(c, cqt), hqtqt)))))))))

logic fc648 : pps, (int,int) farray -> (int,int) farray

logic fc649 : pps, (int,int) farray -> (int,int) farray

logic fc650 : pps, (int,int) farray -> (int,int) farray

logic fc651 : pps, (int,int) farray -> (int,int) farray

axiom fcqtdef651 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc648(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef652 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc649(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom fcqtdef653 :
  (forall h:pps. forall x:(int,int) farray. forall k:int. ((fc650(h,
  x)[k]) = (x[(k + h_width(h))])))

axiom fcqtdef654 :
  (forall h:pps. forall y:(int,int) farray. forall k:int. ((fc651(h,
  y)[k]) = (y[(k + h_range(h))])))

axiom correct_par1 :
  (forall c:circuit1. forall cqt:circuit1. forall h:pps. forall hqt:pps.
  forall hqtqt:pps. (correct_path_sum(c, h) -> (correct_path_sum(cqt, hqt) ->
  ((h_width(hqtqt) = (width1(c) + width1(cqt))) ->
  ((h_range(hqtqt) = (h_range(h) + h_range(hqt))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_angle(hqtqt)[x])[y]) = ang_add(((h_angle(h)[x])[y]),
   ((h_angle(hqt)[fc648(h, x)])[fc649(h, y)])))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((0 <= i) and (i <  h_width(h))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(h)[x])[y])[i]))))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray.
   (forall i:int.
   ((forall j:int. (((0 <= j) and (j <  h_width(hqtqt))) ->
    ((0 <= (x[j])) and ((x[j]) <  2)))) ->
   ((forall j:int. (((0 <= j) and (j <  h_range(hqtqt))) ->
    ((0 <= (y[j])) and ((y[j]) <  2)))) ->
   (((h_width(h) <= i) and (i <  h_width(hqtqt))) ->
   ((((h_basis_ket(hqtqt)[x])[y])[i]) = (((h_basis_ket(hqt)[fc650(h,
   x)])[fc651(h, y)])[(i - h_width(h))]))))))) ->
  correct_path_sum(infix_slsl(c, cqt), hqtqt)))))))))

axiom set_correct_main_path_sum1 :
  (forall c:circuit1. forall h:pps. ((h_width(h) = width1(c)) ->
  ((h_range(h) = range1(c)) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = range1(c)) ->
   (((h_angle(h)[value(x)])[value(y)]) = ang_ind1(c, value(x), value(y)))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. (((0 <= i) and (i <  width1(c))) ->
   ((length(x) = width1(c)) -> ((length(y) = range1(c)) ->
   ((((h_basis_ket(h)[value(x)])[value(y)])[i]) = basis_ket1(c, value(x),
   value(y), i))))))) ->
  correct_path_sum(c, h))))))

axiom set_path_sem_by_correct_pps1 :
  (forall c:circuit1. forall h:pps. forall x:complex matrix.
  (correct_path_sum(c, h) -> (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(c, x) = pps_apply(h, x))))))

logic fc652 : circuit1, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef655 :
  (forall c:circuit1. forall x:bitvec. forall y:bitvec. ((fc652(c,
  x)[y]) = infix_asdtdt(ang_exp(ang_ind1(c, value(x), value(y))),
  bv_to_ket(make_bv((((basis_ket_closure1[c])[value(x)])[value(y)]),
  width1(c))))))

axiom set_path_sem_by_main_pps1 :
  (forall c:circuit1. forall x:bitvec. ((length(x) = width1(c)) ->
  (path_sem1(c, bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(range1(c)),
  ket_sum_l(n_bvs(range1(c)), fc652(c, x), width1(c))))))

axiom set_path_sem_by_correct_pps_gen1 :
  (forall c:circuit1. forall h:pps. (correct_path_sum(c, h) ->
  (forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(c, x) = pps_apply(h, x)))))))

axiom set_correct_path_sum_sim1 :
  (forall c:circuit1. forall h:pps. forall hqt:pps.
  ((h_range(h) = h_range(hqt)) -> ((h_width(h) = h_width(hqt)) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = h_range(h)) ->
   (((h_angle(h)[value(x)])[value(y)]) = ((h_angle(hqt)[value(x)])[value(y)]))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. ((length(x) = width1(c)) -> ((length(y) = h_range(h)) ->
   (((0 <= i) and (i <  width1(c))) ->
   ((((h_basis_ket(h)[value(x)])[value(y)])[i]) = (((h_basis_ket(hqt)[value(x)])[value(y)])[i]))))))) ->
  (correct_path_sum(c, h) -> correct_path_sum(c, hqt)))))))

axiom path_sum_equiv2 :
  (forall c:circuit1. forall h:pps. forall hqt:pps. ((0 <= h_range(h)) ->
  ((h_range(h) = h_range(hqt)) -> ((h_width(h) = h_width(hqt)) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = h_range(h)) ->
   (((h_angle(h)[value(x)])[value(y)]) = ((h_angle(hqt)[value(x)])[value(y)]))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. (((0 <= i) and (i <  width1(c))) ->
   ((length(x) = width1(c)) -> ((length(y) = h_range(h)) ->
   ((((h_basis_ket(h)[value(x)])[value(y)])[i]) = (((h_basis_ket(hqt)[value(x)])[value(y)])[i]))))))) ->
  (correct_path_sum(c, h) -> correct_path_sum(c, hqt))))))))

axiom path_sum_equiv3 :
  (forall c:circuit1. forall h:pps. forall hqt:pps. ((0 <= h_range(h)) ->
  ((h_range(h) = h_range(hqt)) -> ((h_width(h) = h_width(hqt)) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = h_range(h)) ->
   (((h_angle(h)[value(x)])[value(y)]) = ((h_angle(hqt)[value(x)])[value(y)]))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. (((0 <= i) and (i <  width1(c))) ->
   ((length(x) = width1(c)) -> ((length(y) = h_range(h)) ->
   ((((h_basis_ket(h)[value(x)])[value(y)])[i]) = (((h_basis_ket(hqt)[value(x)])[value(y)])[i]))))))) ->
  (correct_path_sum(c, hqt) -> correct_path_sum(c, h))))))))

axiom correct_to_path_sem1 :
  (forall c:circuit1. forall h:pps. (correct_path_sum(c, h) ->
  (forall x:complex matrix. (is_a_ket_l(x, width1(c)) -> (pps_apply(h,
  x) = path_sem1(c, x))))))

axiom swap_invol_basis1 :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (is_a_ket_basis_elt(x) ->
  (path_sem1(bricks_swap, path_sem1(bricks_swap, x)) = x))))

axiom path_sem_to_correct1 :
  (forall c:circuit1. forall h:pps. ((h_width(h) = width1(c)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
   (is_a_ket_basis_elt(x) -> (pps_apply(h, x) = path_sem1(c, x))))) ->
  correct_path_sum(c, h))))

axiom correct_main_path_sum1 :
  (forall c:circuit1. correct_path_sum(c, circ_to_pps1(c)))

logic correct_path_sum_bv1 : circuit1, int,
  (bitvec,(bitvec,bitvec) farray) farray,
  (bitvec,(bitvec,angle) farray) farray -> prop

axiom correct_path_sum_bvqtdef2 :
  (forall c:circuit1. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width1(c))))) ->
  (correct_path_sum_bv1(c, r, k, a) -> correct_path_sum(c,
  build_pps_bv(width1(c), r, k, a))))))

axiom correct_path_sum_bvqtdef3 :
  (forall c:circuit1. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width1(c))))) ->
  (correct_path_sum(c, build_pps_bv(width1(c), r, k, a)) ->
  correct_path_sum_bv1(c, r, k, a)))))

axiom correct_path_sum_to_bv1 :
  (forall c:circuit1. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width1(c))))) ->
  (correct_path_sum(c, build_pps_bv(width1(c), r, k, a)) ->
  correct_path_sum_bv1(c, r, k, a)))))

axiom unwire_correct_bv :
  (forall c:circuit1. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width1(c))))) ->
  (correct_path_sum_bv1(c, r, k, a) -> correct_path_sum_bv(unwire(c), r, k,
  a)))))

axiom unwire_correct_bv_rev :
  (forall c:circuit1. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width1(c))))) ->
  (correct_path_sum_bv(unwire(c), r, k, a) -> correct_path_sum_bv1(c, r, k,
  a)))))

axiom wire_correct_bv :
  (forall c:circuit. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width(c))))) ->
  (correct_path_sum_bv(c, r, k, a) -> correct_path_sum_bv1(wire(c), r, k,
  a)))))

axiom correct_path_sum_by_bv1 :
  (forall c:circuit1. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width1(c))))) ->
  (correct_path_sum_bv1(c, r, k, a) -> correct_path_sum(c,
  build_pps_bv(width1(c), r, k, a))))))

axiom correct_path_sum_bv_main1 :
  (forall c:circuit1. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. ((0 <= r) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r) -> (length(((k[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec.
   (forall i:int. ((length(x) = width1(c)) -> ((length(y) = r) ->
   (((0 <= i) and (i <  width1(c))) ->
   ((value(((k[x])[y]))[i]) = basis_ket1(c, value(x), value(y), i))))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r) -> (((a[x])[y]) = ang_ind1(c, value(x), value(y)))))) ->
  ((r = range1(c)) -> correct_path_sum_bv1(c, r, k, a)))))))

logic fc653 : (bitvec,(bitvec,bitvec) farray) farray,
  (bitvec,(bitvec,angle) farray) farray,
  bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef656 :
  (forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. forall x:bitvec.
  forall y:bitvec. ((fc653(k, a, x)[y]) = infix_asdtdt(ang_exp(((a[x])[y])),
  bv_to_ket(((k[x])[y])))))

axiom correct_path_sum_bv_apply1 :
  (forall c:circuit1. forall r:int.
  forall k:(bitvec,(bitvec,bitvec) farray) farray.
  forall a:(bitvec,(bitvec,angle) farray) farray. forall x:bitvec.
  ((0 <= r) ->
  ((forall x1:bitvec. forall y:bitvec. ((length(x1) = width1(c)) ->
   ((length(y) = r) -> (length(((k[x1])[y])) = width1(c))))) ->
  ((length(x) = width1(c)) -> (correct_path_sum_bv1(c, r, k, a) ->
  (path_sem1(c, bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(r),
  ket_sum_l(n_bvs(r), fc653(k, a, x), width1(c)))))))))

logic seq_pps_bv : circuit1, circuit1, int, int, int,
  (bitvec,(bitvec,bitvec) farray) farray,
  (bitvec,(bitvec,bitvec) farray) farray,
  (bitvec,(bitvec,bitvec) farray) farray,
  (bitvec,(bitvec,angle) farray) farray,
  (bitvec,(bitvec,angle) farray) farray,
  (bitvec,(bitvec,angle) farray) farray -> circuit1

axiom seq_pps_bvqtdef :
  (forall c:circuit1. forall cqt:circuit1. forall r1:int. forall r2:int.
  forall r3:int. forall k1:(bitvec,(bitvec,bitvec) farray) farray.
  forall k2:(bitvec,(bitvec,bitvec) farray) farray.
  forall k3:(bitvec,(bitvec,bitvec) farray) farray.
  forall a1:(bitvec,(bitvec,angle) farray) farray.
  forall a2:(bitvec,(bitvec,angle) farray) farray.
  forall a3:(bitvec,(bitvec,angle) farray) farray. ((0 <= r1) ->
  ((0 <= r2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r1) -> (length(((k1[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r2) -> (length(((k2[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (length(((k3[x])[y])) = width1(c))))) ->
  ((width1(c) = width1(cqt)) -> ((r3 = (r1 + r2)) -> (correct_path_sum_bv1(c,
  r1, k1, a1) -> (correct_path_sum_bv1(cqt, r2, k2, a2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((a3[x])[y]) = ang_add(((a1[x])[hpart(y, r1)]),
   ((a2[((k1[x])[hpart(y, r1)])])[tpart(y, r1)])))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((k3[x])[y]) = ((k2[((k1[x])[hpart(y,
   r1)])])[tpart(y, r1)]))))) ->
  (seq_pps_bv(c, cqt, r1, r2, r3, k1, k2, k3, a1, a2, a3) = infix_mnmn(c,
  cqt))))))))))))))

axiom seq_pps_bvqtspec :
  (forall c:circuit1. forall cqt:circuit1. forall r1:int. forall r2:int.
  forall r3:int. forall k1:(bitvec,(bitvec,bitvec) farray) farray.
  forall k2:(bitvec,(bitvec,bitvec) farray) farray.
  forall k3:(bitvec,(bitvec,bitvec) farray) farray.
  forall a1:(bitvec,(bitvec,angle) farray) farray.
  forall a2:(bitvec,(bitvec,angle) farray) farray.
  forall a3:(bitvec,(bitvec,angle) farray) farray. ((0 <= r1) ->
  ((0 <= r2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r1) -> (length(((k1[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r2) -> (length(((k2[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (length(((k3[x])[y])) = width1(c))))) ->
  ((width1(c) = width1(cqt)) -> ((r3 = (r1 + r2)) -> (correct_path_sum_bv1(c,
  r1, k1, a1) -> (correct_path_sum_bv1(cqt, r2, k2, a2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((a3[x])[y]) = ang_add(((a1[x])[hpart(y, r1)]),
   ((a2[((k1[x])[hpart(y, r1)])])[tpart(y, r1)])))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((k3[x])[y]) = ((k2[((k1[x])[hpart(y,
   r1)])])[tpart(y, r1)]))))) ->
  (seq_pps_bv(c, cqt, r1, r2, r3, k1, k2, k3, a1, a2, a3) = infix_mnmn(c,
  cqt))))))))))))))

axiom seq_pps_bvqtspec1 :
  (forall c:circuit1. forall cqt:circuit1. forall r1:int. forall r2:int.
  forall r3:int. forall k1:(bitvec,(bitvec,bitvec) farray) farray.
  forall k2:(bitvec,(bitvec,bitvec) farray) farray.
  forall k3:(bitvec,(bitvec,bitvec) farray) farray.
  forall a1:(bitvec,(bitvec,angle) farray) farray.
  forall a2:(bitvec,(bitvec,angle) farray) farray.
  forall a3:(bitvec,(bitvec,angle) farray) farray. ((0 <= r1) ->
  ((0 <= r2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r1) -> (length(((k1[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r2) -> (length(((k2[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (length(((k3[x])[y])) = width1(c))))) ->
  ((width1(c) = width1(cqt)) -> ((r3 = (r1 + r2)) -> (correct_path_sum_bv1(c,
  r1, k1, a1) -> (correct_path_sum_bv1(cqt, r2, k2, a2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((a3[x])[y]) = ang_add(((a1[x])[hpart(y, r1)]),
   ((a2[((k1[x])[hpart(y, r1)])])[tpart(y, r1)])))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((k3[x])[y]) = ((k2[((k1[x])[hpart(y,
   r1)])])[tpart(y, r1)]))))) ->
  (width1(seq_pps_bv(c, cqt, r1, r2, r3, k1, k2, k3, a1, a2,
  a3)) = width1(c))))))))))))))

axiom seq_pps_bvqtspec2 :
  (forall c:circuit1. forall cqt:circuit1. forall r1:int. forall r2:int.
  forall r3:int. forall k1:(bitvec,(bitvec,bitvec) farray) farray.
  forall k2:(bitvec,(bitvec,bitvec) farray) farray.
  forall k3:(bitvec,(bitvec,bitvec) farray) farray.
  forall a1:(bitvec,(bitvec,angle) farray) farray.
  forall a2:(bitvec,(bitvec,angle) farray) farray.
  forall a3:(bitvec,(bitvec,angle) farray) farray. ((0 <= r1) ->
  ((0 <= r2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r1) -> (length(((k1[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r2) -> (length(((k2[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (length(((k3[x])[y])) = width1(c))))) ->
  ((width1(c) = width1(cqt)) -> ((r3 = (r1 + r2)) -> (correct_path_sum_bv1(c,
  r1, k1, a1) -> (correct_path_sum_bv1(cqt, r2, k2, a2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((a3[x])[y]) = ang_add(((a1[x])[hpart(y, r1)]),
   ((a2[((k1[x])[hpart(y, r1)])])[tpart(y, r1)])))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((k3[x])[y]) = ((k2[((k1[x])[hpart(y,
   r1)])])[tpart(y, r1)]))))) ->
  (size1(seq_pps_bv(c, cqt, r1, r2, r3, k1, k2, k3, a1, a2,
  a3)) = (size1(c) + size1(cqt)))))))))))))))

axiom seq_pps_bvqtspec3 :
  (forall c:circuit1. forall cqt:circuit1. forall r1:int. forall r2:int.
  forall r3:int. forall k1:(bitvec,(bitvec,bitvec) farray) farray.
  forall k2:(bitvec,(bitvec,bitvec) farray) farray.
  forall k3:(bitvec,(bitvec,bitvec) farray) farray.
  forall a1:(bitvec,(bitvec,angle) farray) farray.
  forall a2:(bitvec,(bitvec,angle) farray) farray.
  forall a3:(bitvec,(bitvec,angle) farray) farray. ((0 <= r1) ->
  ((0 <= r2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r1) -> (length(((k1[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r2) -> (length(((k2[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (length(((k3[x])[y])) = width1(c))))) ->
  ((width1(c) = width1(cqt)) -> ((r3 = (r1 + r2)) -> (correct_path_sum_bv1(c,
  r1, k1, a1) -> (correct_path_sum_bv1(cqt, r2, k2, a2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((a3[x])[y]) = ang_add(((a1[x])[hpart(y, r1)]),
   ((a2[((k1[x])[hpart(y, r1)])])[tpart(y, r1)])))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((k3[x])[y]) = ((k2[((k1[x])[hpart(y,
   r1)])])[tpart(y, r1)]))))) ->
  (ancillas1(seq_pps_bv(c, cqt, r1, r2, r3, k1, k2, k3, a1, a2,
  a3)) = max(ancillas1(c), ancillas1(cqt)))))))))))))))

axiom seq_pps_bvqtspec4 :
  (forall c:circuit1. forall cqt:circuit1. forall r1:int. forall r2:int.
  forall r3:int. forall k1:(bitvec,(bitvec,bitvec) farray) farray.
  forall k2:(bitvec,(bitvec,bitvec) farray) farray.
  forall k3:(bitvec,(bitvec,bitvec) farray) farray.
  forall a1:(bitvec,(bitvec,angle) farray) farray.
  forall a2:(bitvec,(bitvec,angle) farray) farray.
  forall a3:(bitvec,(bitvec,angle) farray) farray. ((0 <= r1) ->
  ((0 <= r2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r1) -> (length(((k1[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r2) -> (length(((k2[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (length(((k3[x])[y])) = width1(c))))) ->
  ((width1(c) = width1(cqt)) -> ((r3 = (r1 + r2)) -> (correct_path_sum_bv1(c,
  r1, k1, a1) -> (correct_path_sum_bv1(cqt, r2, k2, a2) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((a3[x])[y]) = ang_add(((a1[x])[hpart(y, r1)]),
   ((a2[((k1[x])[hpart(y, r1)])])[tpart(y, r1)])))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r3) -> (((k3[x])[y]) = ((k2[((k1[x])[hpart(y,
   r1)])])[tpart(y, r1)]))))) ->
  correct_path_sum_bv1(seq_pps_bv(c, cqt, r1, r2, r3, k1, k2, k3, a1, a2,
  a3), r3, k3, a3)))))))))))))

axiom correct_path_sum_bv_sim1 :
  (forall c:circuit1. forall r1:int.
  forall k1:(bitvec,(bitvec,bitvec) farray) farray.
  forall a1:(bitvec,(bitvec,angle) farray) farray. forall r2:int.
  forall k2:(bitvec,(bitvec,bitvec) farray) farray.
  forall a2:(bitvec,(bitvec,angle) farray) farray. ((r1 = r2) ->
  ((0 <= r1) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r1) -> (length(((k1[x])[y])) = width1(c))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r1) -> (((k1[x])[y]) = ((k2[x])[y]))))) ->
  ((forall x:bitvec. forall y:bitvec. ((length(x) = width1(c)) ->
   ((length(y) = r1) -> (((a1[x])[y]) = ((a2[x])[y]))))) ->
  (correct_path_sum_bv1(c, r1, k1, a1) -> correct_path_sum_bv1(c, r2, k2,
  a2))))))))

axiom path_sem_comp1 :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. (is_a_ket_l(x,
  width1(d)) -> ((path_sem1(d, x) = y) -> ((path_sem1(e, y) = z) ->
  ((width1(d) = width1(e)) -> (path_sem1(infix_mnmn(d, e), x) = z))))))

logic path_seq : circuit1, circuit1, complex matrix, complex matrix,
  complex matrix, int -> circuit1

axiom path_seqqtdef :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. forall w:int.
  (is_a_ket_l(x, w) -> ((path_sem1(d, x) = y) -> ((path_sem1(e, y) = z) ->
  (((width1(d) = width1(e)) and (width1(e) = w)) -> (path_seq(d, e, x, y, z,
  w) = infix_mnmn(d, e)))))))

axiom path_seqqtspec :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. forall w:int.
  (is_a_ket_l(x, w) -> ((path_sem1(d, x) = y) -> ((path_sem1(e, y) = z) ->
  (((width1(d) = width1(e)) and (width1(e) = w)) -> (width1(path_seq(d, e, x,
  y, z, w)) = w))))))

axiom path_seqqtspec1 :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. forall w:int.
  (is_a_ket_l(x, w) -> ((path_sem1(d, x) = y) -> ((path_sem1(e, y) = z) ->
  (((width1(d) = width1(e)) and (width1(e) = w)) -> (path_sem1(path_seq(d, e,
  x, y, z, w), x) = z))))))

axiom path_seqqtspec2 :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. forall w:int.
  (is_a_ket_l(x, w) -> ((path_sem1(d, x) = y) -> ((path_sem1(e, y) = z) ->
  (((width1(d) = width1(e)) and (width1(e) = w)) -> is_a_ket_l(z, w))))))

axiom path_seqqtspec3 :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. forall w:int.
  (is_a_ket_l(x, w) -> ((path_sem1(d, x) = y) -> ((path_sem1(e, y) = z) ->
  (((width1(d) = width1(e)) and (width1(e) = w)) -> (path_seq(d, e, x, y, z,
  w) = infix_mnmn(d, e)))))))

axiom path_sem_comp_2 :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  (is_a_ket_l(x, width1(d)) -> ((width1(d) = width1(e)) ->
  (path_sem1(infix_mnmn(d, e), x) = path_sem1(e, path_sem1(d, x))))))

axiom sem_comp1 :
  (forall d:circuit1. forall e:circuit1. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. (sem1(d, x, y) ->
  (sem1(e, y, z) -> ((width1(d) = width1(e)) -> sem1(infix_mnmn(d, e), x,
  z)))))

axiom path_sem_cnot_basis1 :
  (forall x:complex matrix. (is_a_ket_l(x, 2) -> (is_a_ket_basis_elt(x) ->
  (path_sem1(bricks_cnot, x) = (if (ket_to_int(x) = 0) then ket(2,
  0) else (if (ket_to_int(x) = 1) then ket(2,
  1) else (if (ket_to_int(x) = 2) then ket(2, 3) else ket(2, 2))))))))

axiom place_kron1 :
  (forall c:circuit1. forall k:int. forall n:int. forall x:complex matrix.
  forall y:complex matrix. forall yqt:complex matrix.
  forall z:complex matrix. ((0 <= k) -> (((width1(c) + k) <= n) ->
  (is_a_ket_l(x, k) -> (is_a_ket_l(y, width1(c)) -> (is_a_ket_l(z,
  ((n - width1(c)) - k)) -> ((path_sem1(c, y) = yqt) -> (path_sem1(place1(c,
  k, n), kronecker(x, kronecker(y, z))) = kronecker(x, kronecker(yqt,
  z))))))))))

axiom place_width :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (width1(place1(c, k, n)) = n))))

logic fc654 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef657 :
  (forall k:int. forall x:(int,int) farray. forall j:int. ((fc654(k,
  x)[j]) = (x[(j + k)])))

axiom place_bv_in :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (binary_l(x, n) -> (((k <= i) and (i <  (k + width1(c)))) ->
  (basis_ket1(place1(c, k, n), x, y, i) = basis_ket1(c, fc654(k, x), y,
  (i - k)))))))))

axiom place_bv_out :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (binary_l(x, n) -> (((0 <= i) and (i <  n)) -> ((not ((k <= i) and
  (i <  (k + width1(c))))) -> (basis_ket1(place1(c, k, n), x, y,
  i) = (x[i])))))))))

axiom sequence_width1 :
  (forall c:circuit1. forall d:circuit1. ((width1(c) = width1(d)) ->
  (width1(infix_mnmn(c, d)) = width1(c))))

axiom place_kron_bv :
  (forall c:circuit1. forall k:int. forall n:int. forall bv:bitvec.
  ((0 <= k) -> (((width1(c) + k) <= n) -> ((length(bv) = n) ->
  (path_sem1(place1(c, k, n),
  bv_to_ket(bv)) = kronecker(kronecker(bv_to_ket(hpart(bv, k)), path_sem1(c,
  bv_to_ket(htpart(bv, k, width1(c))))), bv_to_ket(tpart(bv,
  (k + width1(c))))))))))

axiom place_kron_exp :
  (forall c:circuit1. forall k:int. forall n:int. forall x:complex matrix.
  forall y:complex matrix. forall z:complex matrix. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (is_a_ket_l(x, k) -> (is_a_ket_l(y,
  width1(c)) -> (is_a_ket_l(z, ((n - width1(c)) - k)) -> (path_sem1(place1(c,
  k, n), kronecker(x, kronecker(y, z))) = kronecker(x, kronecker(path_sem1(c,
  y), z)))))))))

axiom place_kron_left1 :
  (forall c:circuit1. forall n:int. forall y:complex matrix.
  forall yqt:complex matrix. forall z:complex matrix. ((width1(c) <= n) ->
  (is_a_ket_l(y, width1(c)) -> (is_a_ket_l(z, (n - width1(c))) ->
  ((path_sem1(c, y) = yqt) -> (path_sem1(place1(c, 0, n), kronecker(y,
  z)) = kronecker(yqt, z)))))))

axiom place_kron_right1 :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <  k) ->
  ((n = (width1(c) + k)) ->
  (forall y:complex matrix. forall x:complex matrix. (is_a_ket_l(x, k) ->
  (is_a_ket_l(y, (n - k)) -> (path_sem1(place1(c, k, n), kronecker(x,
  y)) = kronecker(x, path_sem1(c, y)))))))))

axiom place_place1 :
  (forall c:circuit1. forall k:int. forall kqt:int. forall n:int.
  forall nqt:int. forall x:bitvec. ((0 <= k) -> (((width1(c) + k) <= n) ->
  ((0 <= kqt) -> (((n + kqt) <= nqt) -> ((length(x) = nqt) ->
  (path_sem1(place1(place1(c, k, n), kqt, nqt),
  bv_to_ket(x)) = path_sem1(place1(c, (k + kqt), nqt), bv_to_ket(x)))))))))

logic fc655 : int, bitvec -> (int,int) farray

logic fc656 : int, bitvec -> (int,int) farray

axiom fcqtdef658 :
  (forall k:int. forall x:bitvec. forall i:int. ((fc655(k,
  x)[i]) = (value(x)[(i + k)])))

axiom fcqtdef659 :
  (forall k:int. forall y:bitvec. forall i:int. ((fc656(k,
  y)[i]) = (value(y)[(i + k)])))

axiom place_get_ket1 :
  (forall c:circuit1. forall k:int. forall n:int. forall x:bitvec.
  forall y:bitvec. ((0 <= k) -> (((width1(c) + k) <= n) ->
  ((length(x) = n) -> ((length(y) = n) -> ((hpart(x, k) = hpart(y, k)) ->
  ((tpart(x, (k + width1(c))) = tpart(y, (k + width1(c)))) ->
  (get(path_sem1(place1(c, k, n), bv_to_ket(x)), bv_to_int(y),
  0) = get(path_sem1(c, bv_to_ket(make_bv(fc655(k, x), width1(c)))),
  bv_to_int(make_bv(fc656(k, y), width1(c))), 0)))))))))

axiom place_get_ket_hpart_null1 :
  (forall c:circuit1. forall k:int. forall n:int. forall x:bitvec.
  forall y:bitvec. ((0 <= k) -> (((width1(c) + k) <= n) ->
  ((length(x) = n) -> ((length(y) = n) -> ((not (hpart(x, k) = hpart(y,
  k))) -> (get(path_sem1(place1(c, k, n), bv_to_ket(x)), bv_to_int(y),
  0) = c_zero)))))))

axiom place_get_ket_tpart_null1 :
  (forall c:circuit1. forall k:int. forall n:int. forall x:bitvec.
  forall y:bitvec. ((0 <= k) -> (((width1(c) + k) <= n) ->
  ((length(x) = n) -> ((length(y) = n) -> ((not (tpart(x,
  (k + width1(c))) = tpart(y, (k + width1(c))))) -> (get(path_sem1(place1(c,
  k, n), bv_to_ket(x)), bv_to_int(y), 0) = c_zero)))))))

logic place_hadamard1 : int, int -> circuit1

axiom place_hadamardqtdef1 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (place_hadamard1(k, n) = place1(hadamard1, k, n))))

axiom place_hadamardqtspec7 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (range1(place_hadamard1(k, n)) = 1)))

axiom place_hadamardqtspec8 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (size1(place_hadamard1(k, n)) = 1)))

axiom place_hadamardqtspec9 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (width1(place_hadamard1(k, n)) = n)))

axiom place_hadamardqtspec10 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (ancillas1(place_hadamard1(k, n)) = 0)))

axiom place_hadamardqtspec11 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) -> (basis_ket1(place_hadamard1(k,
  n), x, y, i) = (if (i = k) then (y[0]) else (x[i]))))))))

axiom place_hadamardqtspec12 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(place_hadamard1(k, n), x, y) = infix_sldtsl(((x[k]) * (y[0])),
  1)))))

axiom place_hadamardqtspec13 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall m:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. ((1 <= m) ->
  (ang_ind1(place_hadamard1(k, n), x,
  y) = infix_sldtsl((((x[k]) * (y[0])) * power(2, (m - 1))), m)))))))

axiom place_hadamardqtspec14 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall m:int.
  (forall x:(int,int) farray. forall y:(int,int) farray. ((1 <= m) ->
  (ang_ind1(place_hadamard1(k, n), x,
  y) = infix_sldtsl((-(((x[k]) * (y[0])) * power(2, (m - 1)))), m)))))))

logic place_hadamard_bv1 : int, int -> circuit1

axiom place_hadamard_bvqtdef1 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (place_hadamard_bv1(k, n) = place_hadamard1(k, n))))

logic fc657 : int, bitvec, bitvec -> (int,int) farray

logic fc658 : int, int -> (bitvec,(bitvec,bitvec) farray) farray

logic fc659 : int, int -> (bitvec,(bitvec,angle) farray) farray

axiom fcqtdef660 :
  (forall k:int. forall x:bitvec. forall y:bitvec. forall i:int. ((fc657(k,
  x, y)[i]) = (if (i = k) then (value(y)[0]) else (value(x)[i]))))

axiom fcqtdef661 :
  (forall k:int. forall n:int. forall x:bitvec. forall y:bitvec. (((fc658(k,
  n)[x])[y]) = make_bv(fc657(k, x, y), n)))

axiom fcqtdef662 :
  (forall k:int. forall n:int. forall x:bitvec. forall y:bitvec. (((fc659(k,
  n)[x])[y]) = infix_sldtsl((((value(x)[k]) * (value(y)[0])) * power(2,
  (n - 1))), n)))

axiom place_hadamard_bvqtspec8 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (range1(place_hadamard_bv1(k, n)) = 1)))

axiom place_hadamard_bvqtspec9 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (width1(place_hadamard_bv1(k, n)) = n)))

axiom place_hadamard_bvqtspec10 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (size1(place_hadamard_bv1(k, n)) = 1)))

axiom place_hadamard_bvqtspec11 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (ancillas1(place_hadamard_bv1(k, n)) = 0)))

axiom place_hadamard_bvqtspec12 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) ->
  (basis_ket1(place_hadamard_bv1(k, n), x, y,
  i) = (if (i = k) then (y[0]) else (x[i]))))))))

axiom place_hadamard_bvqtspec13 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(place_hadamard_bv1(k, n), x, y) = infix_sldtsl(((x[k]) * (y[0])),
  1)))))

axiom place_hadamard_bvqtspec14 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall m:int. ((1 <= m) -> (ang_ind1(place_hadamard_bv1(k, n), x,
  y) = infix_sldtsl((((x[k]) * (y[0])) * power(2, (m - 1))), m)))))))

axiom place_hadamard_bvqtspec15 :
  (forall k:int. forall n:int. (((0 <= k) and (k <  n)) ->
  correct_path_sum_bv1(place_hadamard_bv1(k, n), 1, fc658(k, n), fc659(k,
  n))))

axiom path_cont2 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 0) ->
  (path_sem1(cont1(c, co, k, n), bv_to_ket(bv)) = bv_to_ket(bv)))))))))

axiom path_cont3 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) ->
  (forall bv:bitvec. ((length(bv) = n) -> (((value(bv)[co]) = 1) ->
  (path_sem1(cont1(c, co, k, n), bv_to_ket(bv)) = path_sem1(place1(c, k, n),
  bv_to_ket(bv))))))))))

axiom cont_width :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (width1(cont1(c, co, k,
  n)) = n)))))

axiom path_cont_ketz1 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  forall x:complex matrix. (((0 <= co) and (co <  n)) -> (((0 <= k) and
  (k <= (n - width1(c)))) -> (((k <= co) -> ((k + width1(c)) <= co)) ->
  (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[co]) = 0) -> (path_sem1(cont1(c, co, k, n),
  x) = x))))))))

axiom path_cont_keto1 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  forall x:complex matrix. (((0 <= co) and (co <  n)) -> (((0 <= k) and
  (k <= (n - width1(c)))) -> (((k <= co) -> ((k + width1(c)) <= co)) ->
  (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[co]) = 1) -> (path_sem1(cont1(c, co, k, n),
  x) = path_sem1(place1(c, k, n), x)))))))))

axiom path_cont_ketz_gen1 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[co]) = 0) -> (path_sem1(cont1(c, co, k, n),
  x) = x)))))))))

axiom path_cont_keto_gen1 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[co]) = 1) -> (path_sem1(cont1(c, co, k, n),
  x) = path_sem1(place1(c, k, n), x))))))))))

axiom cont_kron_left_bv_to_ket2 :
  (forall c:circuit1. forall n:int. forall x:complex matrix.
  (((0 <= width1(c)) and (width1(c) = (n - 1))) -> (is_a_ket_l(x,
  width1(c)) ->
  (forall y:bitvec. ((length(y) = 1) -> (((value(y)[0]) = 0) ->
  (path_sem1(cont1(c, (n - 1), 0, n), kronecker(x,
  bv_to_ket(y))) = kronecker(x, bv_to_ket(y)))))))))

axiom cont_kron_left_bv_to_ket3 :
  (forall c:circuit1. forall n:int. forall x:complex matrix.
  (((0 <= width1(c)) and (width1(c) = (n - 1))) -> (is_a_ket_l(x,
  width1(c)) ->
  (forall y:bitvec. ((length(y) = 1) -> (((value(y)[0]) = 1) ->
  (path_sem1(cont1(c, (n - 1), 0, n), kronecker(x,
  bv_to_ket(y))) = kronecker(path_sem1(c, x), bv_to_ket(y)))))))))

axiom place_kron_left_path1 :
  (forall c:circuit1. forall n:int. ((width1(c) <  n) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  width1(c)) -> (is_a_ket_l(y, (n - width1(c))) -> (path_sem1(place1(c, 0,
  n), kronecker(x, y)) = kronecker(path_sem1(c, x), y)))))))

axiom place_kron_left_sem1 :
  (forall c:circuit1. forall n:int. ((width1(c) <  n) ->
  (forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (is_a_ket_l(y, (n - width1(c))) -> (sem1(c, x, z) -> sem1(place1(c, 0, n),
  kronecker(x, y), kronecker(z, y)))))))

axiom cont_kron_pat_right2 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  forall y:complex matrix. (((0 <= co) and (co <  k)) ->
  ((n = (k + width1(c))) -> (is_a_ket_l(y, width1(c)) ->
  (forall x:complex matrix. (is_a_ket_basis_elt(x) -> (is_a_ket_l(x, k) ->
  (((value(ket_to_bv(x))[co]) = 0) -> (path_sem1(cont1(c, co, k, n),
  kronecker(x, y)) = kronecker(x, y))))))))))

axiom cont_kron_pat_right3 :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  forall y:complex matrix. (((0 <= co) and (co <  k)) ->
  ((n = (k + width1(c))) -> (is_a_ket_l(y, width1(c)) ->
  (forall x:complex matrix. (is_a_ket_basis_elt(x) -> (is_a_ket_l(x, k) ->
  (((value(ket_to_bv(x))[co]) = 1) -> (path_sem1(cont1(c, co, k, n),
  kronecker(x, y)) = kronecker(x, path_sem1(c, y)))))))))))

axiom cont_kron_zero :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (is_a_ket_l(x, k) ->
  (is_a_ket_l(y, width1(c)) -> (is_a_ket_l(z, ((n - k) - width1(c))) ->
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(z) -> (((co <  k) ->
  ((value(ket_to_bv(x))[co]) = 0)) -> (((k <= co) ->
  ((value(ket_to_bv(z))[((co - k) - width1(c))]) = 0)) -> (path_sem1(cont1(c,
  co, k, n), kronecker(kronecker(x, y), z)) = kronecker(kronecker(x, y),
  z)))))))))))))

axiom cont_kron_one :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (is_a_ket_l(x, k) ->
  (is_a_ket_l(y, width1(c)) -> (is_a_ket_l(z, ((n - k) - width1(c))) ->
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(z) -> (((co <  k) ->
  ((value(ket_to_bv(x))[co]) = 1)) -> (((k <= co) ->
  ((value(ket_to_bv(z))[((co - k) - width1(c))]) = 1)) -> (path_sem1(cont1(c,
  co, k, n), kronecker(kronecker(x, y), z)) = path_sem1(place1(c, k, n),
  kronecker(kronecker(x, y), z))))))))))))))

axiom cont_kron_pat_right_gen2 :
  (forall circ:circuit1. forall c:int. forall k:int. forall n:int.
  (((0 <= c) and (c <  k)) -> ((n = (k + width1(circ))) ->
  (forall y:complex matrix.
  (forall x:bitvec. (is_a_ket_l(y, width1(circ)) -> ((length(x) = k) ->
  (((value(x)[c]) = 0) -> (path_sem1(cont1(circ, c, k, n),
  kronecker(bv_to_ket(x), y)) = kronecker(bv_to_ket(x), y))))))))))

axiom cont_kron_pat_right_gen3 :
  (forall circ:circuit1. forall c:int. forall k:int. forall n:int.
  (((0 <= c) and (c <  k)) -> ((n = (k + width1(circ))) ->
  (forall y:complex matrix.
  (forall x:bitvec. (is_a_ket_l(y, width1(circ)) -> ((length(x) = k) ->
  (((value(x)[c]) = 1) -> (path_sem1(cont1(circ, c, k, n),
  kronecker(bv_to_ket(x), y)) = kronecker(bv_to_ket(x), path_sem1(circ,
  y)))))))))))

axiom cont_kron_pat_right_gen_ket :
  (forall circ:circuit1. forall c:int. forall k:int. forall n:int.
  (((0 <= c) and (c <  k)) -> ((n = (k + width1(circ))) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(y,
  width1(circ)) -> (is_a_ket_l(x, k) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[c]) = 0) -> (path_sem1(cont1(circ, c, k, n),
  kronecker(x, y)) = kronecker(x, y))))))))))

axiom cont_kron_pat_right_gen_ket1 :
  (forall circ:circuit1. forall c:int. forall k:int. forall n:int.
  (((0 <= c) and (c <  k)) -> ((n = (k + width1(circ))) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(y,
  width1(circ)) -> (is_a_ket_l(x, k) -> (is_a_ket_basis_elt(x) ->
  (((value(ket_to_bv(x))[c]) = 1) -> (path_sem1(cont1(circ, c, k, n),
  kronecker(x, y)) = kronecker(x, path_sem1(circ, y)))))))))))

function cont_last_qbit_kron(c: circuit1) : circuit1 = cont1(c, width1(c), 0,
  (width1(c) + 1))

axiom cont_last_qbit_kronqtspec3 :
  (forall c:circuit1.
  (size1(cont_last_qbit_kron(c)) <= (size1(c) * cont_size1)))

axiom cont_last_qbit_kronqtspec4 :
  (forall c:circuit1. (ancillas1(cont_last_qbit_kron(c)) = ancillas1(c)))

axiom cont_last_qbit_kronqtspec5 :
  (forall c:circuit1. (range1(cont_last_qbit_kron(c)) = range1(c)))

axiom cont_last_qbit_kronqtspec6 :
  (forall c:circuit1. (width1(cont_last_qbit_kron(c)) = (width1(c) + 1)))

axiom cont_last_qbit_kronqtspec7 :
  (forall c:circuit1.
  (forall x:complex matrix. forall y:complex matrix. (sem1(c, x, y) ->
  sem1(cont_last_qbit_kron(c), kronecker(x, ket(1, 1)), kronecker(y, ket(1,
  1))))))

axiom cont_last_qbit_kronqtspec8 :
  (forall c:circuit1.
  (forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  sem1(cont_last_qbit_kron(c), kronecker(x, ket(1, 0)), kronecker(x, ket(1,
  0))))))

function cont_last_qbit_kron_path(c: circuit1) : circuit1 = cont1(c,
  width1(c), 0, (width1(c) + 1))

axiom cont_last_qbit_kron_pathqtspec :
  (forall c:circuit1.
  (size1(cont_last_qbit_kron_path(c)) <= (size1(c) * cont_size1)))

axiom cont_last_qbit_kron_pathqtspec1 :
  (forall c:circuit1.
  (ancillas1(cont_last_qbit_kron_path(c)) = ancillas1(c)))

axiom cont_last_qbit_kron_pathqtspec2 :
  (forall c:circuit1. (range1(cont_last_qbit_kron_path(c)) = range1(c)))

axiom cont_last_qbit_kron_pathqtspec3 :
  (forall c:circuit1.
  (width1(cont_last_qbit_kron_path(c)) = (width1(c) + 1)))

axiom cont_last_qbit_kron_pathqtspec4 :
  (forall c:circuit1.
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  width1(c)) -> ((path_sem1(c, x) = y) ->
  (path_sem1(cont_last_qbit_kron_path(c), kronecker(x, ket(1,
  1))) = kronecker(y, ket(1, 1)))))))

axiom cont_last_qbit_kron_pathqtspec5 :
  (forall c:circuit1.
  (forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (path_sem1(cont_last_qbit_kron_path(c), kronecker(x, ket(1,
  0))) = kronecker(x, ket(1, 0))))))

logic seq_diag : circuit1, circuit1 -> circuit1

axiom seq_diagqtdef :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (seq_diag(d, e) = infix_mnmn(d, e))))))))

axiom seq_diagqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (size1(seq_diag(d, e)) = (size1(d) + size1(e)))))))))

axiom seq_diagqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (ancillas1(seq_diag(d, e)) = max(ancillas1(d), ancillas1(e)))))))))

axiom seq_diagqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (pre1(seq_diag(d, e)) = Sequence1(pre1(d), pre1(e)))))))))

axiom seq_diagqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
  (basis_ket1(seq_diag(d, e), x, y, i) = (x[i])))))))))))

axiom seq_diagqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (width1(seq_diag(d, e)) = width1(d))))))))

axiom seq_diagqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (range1(seq_diag(d, e)) = 0)))))))

axiom seq_diagqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(d)) -> (ang_ind1(seq_diag(d, e), x, y) = ang_add(ang_ind1(d, x, y),
  ang_ind1(e, x, y)))))))))))

logic cont_diag : circuit1, int, int, int -> circuit1

axiom cont_diagqtdef :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  ((range1(c) = 0) -> (cont_diag(c, co, t1, n) = cont1(c, co, t1, n))))))))

logic fc660 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef663 :
  (forall t1:int. forall x:(int,int) farray. forall j:int. ((fc660(t1,
  x)[j]) = (x[(j + t1)])))

axiom cont_diagqtspec :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  ((range1(c) = 0) -> (size1(cont_diag(c, co, t1,
  n)) <= (cont_size1 * size1(c)))))))))

axiom cont_diagqtspec1 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  ((range1(c) = 0) -> (ancillas1(cont_diag(c, co, t1,
  n)) = ancillas1(c))))))))

axiom cont_diagqtspec2 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  ((range1(c) = 0) -> (pre1(cont_diag(c, co, t1, n)) = Cont(pre1(c), co, t1,
  n))))))))

axiom cont_diagqtspec3 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  ((range1(c) = 0) -> (width1(cont_diag(c, co, t1, n)) = n)))))))

axiom cont_diagqtspec4 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  ((range1(c) = 0) -> (range1(cont_diag(c, co, t1, n)) = 0)))))))

axiom cont_diagqtspec5 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  ((range1(c) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (forall i:int. (basis_ket1(cont_diag(c, co, t1, n), x, y, i) = (x[i])))))))))))

axiom cont_diagqtspec6 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  ((range1(c) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cont_diag(c, co, t1, n), x, y) = ang_mult_int(ang_ind1(c,
  fc660(t1, x), y), (x[co])))))))))))

logic place_diag : circuit1, int, int -> circuit1

axiom place_diagqtdef :
  (forall c:circuit1. forall t1:int. forall n:int. ((0 <= t1) ->
  (((t1 + width1(c)) <= n) -> ((range1(c) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  (place_diag(c, t1, n) = place1(c, t1, n)))))))

logic fc661 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef664 :
  (forall t1:int. forall x:(int,int) farray. forall j:int. ((fc661(t1,
  x)[j]) = (x[(j + t1)])))

axiom place_diagqtspec :
  (forall c:circuit1. forall t1:int. forall n:int. ((0 <= t1) ->
  (((t1 + width1(c)) <= n) -> ((range1(c) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  (ancillas1(place_diag(c, t1, n)) = ancillas1(c)))))))

axiom place_diagqtspec1 :
  (forall c:circuit1. forall t1:int. forall n:int. ((0 <= t1) ->
  (((t1 + width1(c)) <= n) -> ((range1(c) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  (size1(place_diag(c, t1, n)) = size1(c)))))))

axiom place_diagqtspec2 :
  (forall c:circuit1. forall t1:int. forall n:int. ((0 <= t1) ->
  (((t1 + width1(c)) <= n) -> ((range1(c) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  (pre1(place_diag(c, t1, n)) = Place(pre1(c), t1, n)))))))

axiom place_diagqtspec3 :
  (forall c:circuit1. forall t1:int. forall n:int. ((0 <= t1) ->
  (((t1 + width1(c)) <= n) -> ((range1(c) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  (width1(place_diag(c, t1, n)) = n))))))

axiom place_diagqtspec4 :
  (forall c:circuit1. forall t1:int. forall n:int. ((0 <= t1) ->
  (((t1 + width1(c)) <= n) -> ((range1(c) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  (range1(place_diag(c, t1, n)) = 0))))))

axiom place_diagqtspec5 :
  (forall c:circuit1. forall t1:int. forall n:int. ((0 <= t1) ->
  (((t1 + width1(c)) <= n) -> ((range1(c) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, n) -> (basis_ket1(place_diag(c, t1, n), x, y,
  i) = (x[i]))))))))))

axiom place_diagqtspec6 :
  (forall c:circuit1. forall t1:int. forall n:int. ((0 <= t1) ->
  (((t1 + width1(c)) <= n) -> ((range1(c) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (((0 <= i) and (i <  width1(c))) ->
   (basis_ket1(c, x, y, i) = (x[i]))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(place_diag(c, t1, n), x, y) = ang_ind1(c, fc661(t1, x), y)))))))))

logic seq_diag_right : circuit1, circuit1 -> circuit1

axiom seq_diag_rightqtdef :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (((0 <= i) and (i <  width1(e))) -> (binary_l(x, width1(e)) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (seq_diag_right(d, e) = infix_mnmn(d, e))))))

logic fc662 : circuit1, (int,int) farray -> (int,int) farray

axiom fcqtdef665 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc662(d,
  y)[k]) = (y[(k + range1(d))])))

axiom seq_diag_rightqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (((0 <= i) and (i <  width1(e))) -> (binary_l(x, width1(e)) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (size1(seq_diag_right(d, e)) = (size1(d) + size1(e)))))))

axiom seq_diag_rightqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (((0 <= i) and (i <  width1(e))) -> (binary_l(x, width1(e)) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (ancillas1(seq_diag_right(d, e)) = max(ancillas1(d), ancillas1(e)))))))

axiom seq_diag_rightqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (((0 <= i) and (i <  width1(e))) -> (binary_l(x, width1(e)) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (pre1(seq_diag_right(d, e)) = Sequence1(pre1(d), pre1(e)))))))

axiom seq_diag_rightqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (((0 <= i) and (i <  width1(e))) -> (binary_l(x, width1(e)) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (width1(seq_diag_right(d, e)) = width1(d))))))

axiom seq_diag_rightqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (((0 <= i) and (i <  width1(e))) -> (binary_l(x, width1(e)) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (range1(seq_diag_right(d, e)) = range1(d))))))

axiom seq_diag_rightqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (((0 <= i) and (i <  width1(e))) -> (binary_l(x, width1(e)) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, width1(seq_diag_right(d, e))) -> (binary_l(y,
  range1(seq_diag_right(d, e))) -> (((0 <= i) and (i <  width1(d))) ->
  (basis_ket1(seq_diag_right(d, e), x, y, i) = basis_ket1(d, x, y, i)))))))))))

axiom seq_diag_rightqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (((0 <= i) and (i <  width1(e))) -> (binary_l(x, width1(e)) ->
   (basis_ket1(e, x, y, i) = (x[i]))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(seq_diag_right(d, e))) -> (binary_l(y, range1(seq_diag_right(d,
  e))) -> (ang_ind1(seq_diag_right(d, e), x, y) = ang_add(ang_ind1(d, x, y),
  ang_ind1(e, (((basis_ket_closure1[d])[x])[y]), fc662(d, y)))))))))))

logic seq_diag_left : circuit1, circuit1 -> circuit1

axiom seq_diag_leftqtdef :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  (seq_diag_left(d, e) = infix_mnmn(d, e))))))

axiom seq_diag_leftqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  (size1(seq_diag_left(d, e)) = (size1(d) + size1(e)))))))

axiom seq_diag_leftqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  (ancillas1(seq_diag_left(d, e)) = max(ancillas1(d), ancillas1(e)))))))

axiom seq_diag_leftqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  (pre1(seq_diag_left(d, e)) = Sequence1(pre1(d), pre1(e)))))))

axiom seq_diag_leftqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  (width1(seq_diag_left(d, e)) = width1(d))))))

axiom seq_diag_leftqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  (range1(seq_diag_left(d, e)) = range1(e))))))

axiom seq_diag_leftqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, width1(seq_diag_left(d, e))) -> (((0 <= i) and
  (i <  width1(d))) -> (basis_ket1(seq_diag_left(d, e), x, y,
  i) = basis_ket1(e, x, y, i))))))))))

axiom seq_diag_leftqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(e)) -> (((0 <= i) and (i <  width1(e))) ->
   (basis_ket1(d, x, y, i) = (x[i]))))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(seq_diag_left(d, e))) -> (ang_ind1(seq_diag_left(d, e), x,
  y) = ang_add(ang_ind1(d, x, y), ang_ind1(e, x, y)))))))))

axiom path_sem_diag :
  (forall d:circuit1. forall x:bitvec. ((length(x) = width1(d)) ->
  ((range1(d) = 0) ->
  ((forall x1:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x1, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x1, y, i) = (x1[i]))))) ->
  (path_sem1(d, bv_to_ket(x)) = infix_asdtdt(ang_exp(ang_ind1(d, value(x),
  identity2)), bv_to_ket(x)))))))

axiom path_sem_diag_basis :
  (forall d:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(d)) ->
  (is_a_ket_basis_elt(x) -> ((range1(d) = 0) ->
  ((forall x1:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x1, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x1, y, i) = (x1[i]))))) ->
  (path_sem1(d, x) = infix_asdtdt(ang_exp(ang_ind1(d, value(ket_to_bv(x)),
  identity2)), x)))))))

axiom path_sem_diag_apply :
  (forall d:circuit1. forall x:bitvec. forall a:complex.
  ((length(x) = width1(d)) -> ((range1(d) = 0) ->
  ((forall x1:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x1, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x1, y, i) = (x1[i]))))) ->
  ((forall y:bitvec. ((length(y) = 0) -> (ang_exp(ang_ind1(d, value(x),
   value(y))) = a))) ->
  (path_sem1(d, bv_to_ket(x)) = infix_asdtdt(a, bv_to_ket(x))))))))

logic m_skip : int -> circuit1

axiom m_skipqtdef :
  (forall k:int. ((0 <  k) -> ((k = 1) -> (m_skip(k) = skip))))

axiom m_skipqtdef1 :
  (forall k:int. ((0 <  k) -> ((not (k = 1)) ->
  (m_skip(k) = infix_slsl(m_skip((k - 1)), skip)))))

axiom m_skipqtspec : (forall k:int. ((0 <  k) -> (size1(m_skip(k)) = 0)))

axiom m_skipqtspec1 :
  (forall k:int. ((0 <  k) -> (unwire(m_skip(k)) = ids(k))))

axiom m_skipqtspec2 :
  (forall k:int. ((0 <  k) -> (ancillas1(m_skip(k)) = 0)))

axiom m_skipqtspec3 : (forall k:int. ((0 <  k) -> (size1(m_skip(k)) = 0)))

axiom m_skipqtspec4 : (forall k:int. ((0 <  k) -> (range1(m_skip(k)) = 0)))

axiom m_skipqtspec5 : (forall k:int. ((0 <  k) -> (width1(m_skip(k)) = k)))

axiom m_skipqtspec6 :
  (forall k:int. ((0 <  k) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(m_skip(k), x, y, i) = (x[i]))))))

axiom m_skipqtspec7 :
  (forall k:int. ((0 <  k) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(m_skip(k),
  x, y) = infix_sldtsl(1, 0)))))

axiom m_skipqtspec8 :
  (forall k:int. ((0 <  k) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall k1:int. (ang_ind1(m_skip(k), x, y) = infix_sldtsl(0, k1))))))

axiom m_skip_path_sem :
  (forall k:int. forall x:complex matrix. ((0 <  k) -> (is_a_ket_l(x, k) ->
  (path_sem1(m_skip(k), x) = x))))

logic permutation_circuit_pre1 : int, int, (int,int) farray -> circuit1

axiom permutation_circuit_preqtspec5 :
  (forall k:int. forall n:int. forall f:(int,int) farray. (((0 <= k) and
  (k <  n)) -> (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  (unwire(permutation_circuit_pre1(k, n, f)) = permutation_circuit_pre(k, n,
  f)))))

axiom permutation_circuit_preqtspec6 :
  (forall k:int. forall n:int. forall f:(int,int) farray. (((0 <= k) and
  (k <  n)) -> (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  (width1(permutation_circuit_pre1(k, n, f)) = n))))

axiom permutation_circuit_preqtspec7 :
  (forall k:int. forall n:int. forall f:(int,int) farray. (((0 <= k) and
  (k <  n)) -> (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  (size1(permutation_circuit_pre1(k, n, f)) <= (n - k)))))

axiom permutation_circuit_preqtspec8 :
  (forall k:int. forall n:int. forall f:(int,int) farray. (((0 <= k) and
  (k <  n)) -> (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  (ancillas1(permutation_circuit_pre1(k, n, f)) = 0))))

axiom permutation_circuit_preqtspec9 :
  (forall k:int. forall n:int. forall f:(int,int) farray. (((0 <= k) and
  (k <  n)) -> (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  (range1(permutation_circuit_pre1(k, n, f)) = 0))))

axiom permutation_circuit_preqtspec10 :
  (forall k:int. forall n:int. forall f:(int,int) farray. (((0 <= k) and
  (k <  n)) -> (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(permutation_circuit_pre1(k, n, f), x,
  y) = ang_ind(permutation_circuit_pre(k, n, f), x, y))))))

axiom permutation_circuit_preqtspec11 :
  (forall k:int. forall n:int. forall f:(int,int) farray. (((0 <= k) and
  (k <  n)) -> (p_bijective(f, to_fset(0, n), to_fset(0, n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) ->
  (basis_ket1(permutation_circuit_pre1(k, n, f), x, y,
  i) = basis_ket(permutation_circuit_pre(k, n, f), x, y, i))))))))

logic permutation_circuit1 : int, (int,int) farray -> circuit1

axiom permutation_circuitqtdef1 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (permutation_circuit1(n,
  f) = permutation_circuit_pre1(0, n, f)))))

logic fc663 : (int,int) farray, bitvec -> (int,int) farray

axiom fcqtdef666 :
  (forall f:(int,int) farray. forall x:bitvec. forall i:int. ((fc663(f,
  x)[i]) = (value(x)[(f[i])])))

axiom permutation_circuitqtspec9 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (unwire(permutation_circuit1(n,
  f)) = permutation_circuit(n, f)))))

axiom permutation_circuitqtspec10 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (width1(permutation_circuit1(n,
  f)) = n))))

axiom permutation_circuitqtspec11 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (size1(permutation_circuit1(n,
  f)) <= n))))

axiom permutation_circuitqtspec12 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (ancillas1(permutation_circuit1(n,
  f)) = 0))))

axiom permutation_circuitqtspec13 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) -> (range1(permutation_circuit1(n,
  f)) = 0))))

axiom permutation_circuitqtspec14 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(permutation_circuit1(n, f), x, y) = ang_zero)))))

axiom permutation_circuitqtspec15 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) ->
  (basis_ket1(permutation_circuit1(n, f), x, y, i) = (x[(f[i])]))))))))

axiom permutation_circuitqtspec16 :
  (forall n:int. forall f:(int,int) farray. ((0 <  n) -> (p_bijective(f,
  to_fset(0, n), to_fset(0, n)) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem1(permutation_circuit1(n,
  f), bv_to_ket(x)) = bv_to_ket(make_bv(fc663(f, x), n))))))))

logic gen_phase : int, int -> circuit1

axiom gen_phaseqtdef :
  (forall k:int. forall n:int. ((0 <  n) -> ((0 <= k) -> (gen_phase(k,
  n) = place1(phase1(k), 0, n)))))

axiom gen_phaseqtspec :
  (forall k:int. forall n:int. ((0 <  n) -> ((0 <= k) -> (size1(gen_phase(k,
  n)) = 1))))

axiom gen_phaseqtspec1 :
  (forall k:int. forall n:int. ((0 <  n) -> ((0 <= k) -> (range1(gen_phase(k,
  n)) = 0))))

axiom gen_phaseqtspec2 :
  (forall k:int. forall n:int. ((0 <  n) -> ((0 <= k) -> (width1(gen_phase(k,
  n)) = n))))

axiom gen_phaseqtspec3 :
  (forall k:int. forall n:int. ((0 <  n) -> ((0 <= k) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (basis_ket1(gen_phase(k, n), x, y, i) = (x[i])))))))

axiom gen_phaseqtspec4 :
  (forall k:int. forall n:int. ((0 <  n) -> ((0 <= k) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(gen_phase(k, n), x, y) = infix_sldtsl(1, k))))))

logic crz : int, int, int, int -> circuit1

axiom crzqtdef :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> (crz(c, t1,
  k, n) = cont1(rzp(k), c, t1, n))))))

axiom crzqtspec :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) ->
  (width1(crz(c, t1, k, n)) = n)))))

axiom crzqtspec1 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> (size1(crz(c,
  t1, k, n)) = cont_size1)))))

axiom crzqtspec2 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) ->
  (range1(crz(c, t1, k, n)) = 0)))))

axiom crzqtspec3 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) ->
  (ancillas1(crz(c, t1, k, n)) = 0)))))

axiom crzqtspec4 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (basis_ket1(crz(c, t1, k, n), x, y, i) = (x[i])))))))

axiom crzqtspec5 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(crz(c, t1,
  k, n), x, y) = infix_sldtsl(((x[c]) * (x[t1])), k)))))))

axiom crzqtspec6 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall kqt:int.
  (((0 <= k) and (k <= kqt)) -> (ang_ind1(crz(c, t1, k, n), x,
  y) = infix_sldtsl((((x[c]) * (x[t1])) * power(2, (kqt - k))), kqt))))))))

logic prz : int, int, int -> circuit1

axiom przqtdef :
  (forall k:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (prz(k, t1, n) = place1(rzp(k), t1, n))))

axiom przqtspec :
  (forall k:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (width1(prz(k, t1, n)) = n)))

axiom przqtspec1 :
  (forall k:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (size1(prz(k, t1, n)) = 1)))

axiom przqtspec2 :
  (forall k:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (range1(prz(k, t1, n)) = 0)))

axiom przqtspec3 :
  (forall k:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (ancillas1(prz(k, t1, n)) = 0)))

axiom przqtspec4 :
  (forall k:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (basis_ket1(prz(k, t1, n), x, y, i) = (x[i])))))

axiom przqtspec5 :
  (forall k:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (((0 <= k) and
  (k <= n)) -> (ang_ind1(prz(k, t1, n), x,
  y) = infix_sldtsl(((x[t1]) * power(2, (n - k))), n))))))

logic crzn : int, int, int, int -> circuit1

axiom crznqtdef :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> ((k <= 0) ->
  (crzn(c, t1, k, n) = cont1(rzp(k), c, t1, n)))))))

axiom crznqtspec :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> ((k <= 0) ->
  (width1(crzn(c, t1, k, n)) = n))))))

axiom crznqtspec1 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> ((k <= 0) ->
  (size1(crzn(c, t1, k, n)) = cont_size1))))))

axiom crznqtspec2 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> ((k <= 0) ->
  (range1(crzn(c, t1, k, n)) = 0))))))

axiom crznqtspec3 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> ((k <= 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (basis_ket1(crzn(c, t1, k, n), x, y, i) = (x[i]))))))))

axiom crznqtspec4 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> ((k <= 0) ->
  (ancillas1(crzn(c, t1, k, n)) = 0))))))

axiom crznqtspec5 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. (((0 <= c) and
  (c <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> ((k <= 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall kqt:int.
  (((-k) <= kqt) -> (ang_ind1(crzn(c, t1, k, n), x,
  y) = infix_sldtsl((-(((x[c]) * (x[t1])) * power(2, (kqt + k)))), kqt)))))))))

logic crzn_up : int, int, int, int, int -> circuit1

axiom crzn_upqtdef :
  (forall c:int. forall t1:int. forall k:int. forall n:int. forall den:int.
  (((0 <= c) and (c <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c = t1)) -> ((k <= 0) -> (((-k) <= den) -> (crzn_up(c, t1, k, n,
  den) = cont1(rzp(k), c, t1, n))))))))

axiom crzn_upqtspec :
  (forall c:int. forall t1:int. forall k:int. forall n:int. forall den:int.
  (((0 <= c) and (c <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c = t1)) -> ((k <= 0) -> (((-k) <= den) -> (width1(crzn_up(c, t1, k,
  n, den)) = n)))))))

axiom crzn_upqtspec1 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. forall den:int.
  (((0 <= c) and (c <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c = t1)) -> ((k <= 0) -> (((-k) <= den) -> (size1(crzn_up(c, t1, k,
  n, den)) = cont_size1)))))))

axiom crzn_upqtspec2 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. forall den:int.
  (((0 <= c) and (c <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c = t1)) -> ((k <= 0) -> (((-k) <= den) -> (range1(crzn_up(c, t1, k,
  n, den)) = 0)))))))

axiom crzn_upqtspec3 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. forall den:int.
  (((0 <= c) and (c <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c = t1)) -> ((k <= 0) -> (((-k) <= den) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (basis_ket1(crzn_up(c, t1, k, n, den), x, y, i) = (x[i])))))))))

axiom crzn_upqtspec4 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. forall den:int.
  (((0 <= c) and (c <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c = t1)) -> ((k <= 0) -> (((-k) <= den) -> (ancillas1(crzn_up(c, t1,
  k, n, den)) = 0)))))))

axiom crzn_upqtspec5 :
  (forall c:int. forall t1:int. forall k:int. forall n:int. forall den:int.
  (((0 <= c) and (c <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c = t1)) -> ((k <= 0) -> (((-k) <= den) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (ang_ind1(crzn_up(c,
  t1, k, n, den), x, y) = infix_sldtsl((-(((x[c]) * (x[t1])) * power(2,
  (den + k)))), den)))))))))

axiom bv_to_int_zero :
  (forall x:bitvec. forall n:int. ((0 <  n) -> ((length(x) = n) ->
  ((forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 0))) ->
  (bv_to_int(x) = 0)))))

axiom bv_to_int_all_one :
  (forall x:bitvec. forall n:int. ((0 <  n) -> ((length(x) = n) ->
  ((forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 1))) ->
  (bv_to_int(x) = (power(2, n) - 1))))))

axiom bv_to_int_zero_gen :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) ->
  ((forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 0))) ->
  (bv_to_int(x) = 0))))))

axiom bv_to_int_zero_gen_rev :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) -> ((bv_to_int(x) = 0) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 0))))))))

axiom bv_to_int_all_one_gen :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) ->
  ((forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 1))) ->
  (bv_to_int(x) = (power(2, n) - 1)))))))

axiom bv_to_int_all_one_gen_rev :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) -> ((bv_to_int(x) = (power(2,
  n) - 1)) ->
  (forall i:int. (((0 <= i) and (i <  n)) -> ((value(x)[i]) = 1))))))))

logic bin_check_zero : (int,int) farray, int -> angle

logic result83 : (int,int) farray -> (int,int) farray

axiom resultqtdef90 :
  (forall x:(int,int) farray. forall i:int.
  ((result83(x)[i]) = (x[(i + 1)])))

axiom bin_check_zeroqtdef :
  (forall x:(int,int) farray. forall n:int. ((0 <= n) -> (binary_l(x, n) ->
  ((n = 0) -> (bin_check_zero(x, n) = infix_sldtsl(1, 1))))))

axiom bin_check_zeroqtdef1 :
  (forall x:(int,int) farray. forall n:int. ((0 <= n) -> (binary_l(x, n) ->
  ((not (n = 0)) -> ((n = 1) -> (((x[0]) = 1) -> (bin_check_zero(x,
  n) = infix_sldtsl(1, 1))))))))

axiom bin_check_zeroqtdef2 :
  (forall x:(int,int) farray. forall n:int. ((0 <= n) -> (binary_l(x, n) ->
  ((not (n = 0)) -> ((n = 1) -> ((not ((x[0]) = 1)) -> (bin_check_zero(x,
  n) = ang_zero)))))))

axiom bin_check_zeroqtdef3 :
  (forall x:(int,int) farray. forall n:int. ((0 <= n) -> (binary_l(x, n) ->
  ((not (n = 0)) -> ((not (n = 1)) -> (((x[0]) = 1) -> (bin_check_zero(x,
  n) = bin_check_zero(result83(x), (n - 1)))))))))

axiom bin_check_zeroqtdef4 :
  (forall x:(int,int) farray. forall n:int. ((0 <= n) -> (binary_l(x, n) ->
  ((not (n = 0)) -> ((not (n = 1)) -> ((not ((x[0]) = 1)) ->
  (bin_check_zero(x, n) = ang_zero)))))))

axiom bin_check_zeroqtspec :
  (forall x:(int,int) farray. forall n:int. ((0 <= n) -> (binary_l(x, n) ->
  (bin_check_zero(x,
  n) = (if (forall j:int. (((0 <= j) and (j <  n)) -> ((x[j]) = 1))) then infix_sldtsl(1,
  1) else ang_zero)))))

axiom bin_check_zero_int :
  (forall i:int. forall n:int. ((0 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (bin_check_zero(int_to_bin(i, n), n) = (if (i = (power(2,
  n) - 1)) then infix_sldtsl(1, 1) else ang_zero)))))

logic fc664 : (int,int) farray -> (int,int) farray

axiom fcqtdef667 :
  (forall x:(int,int) farray. forall i:int. ((fc664(x)[i]) = (x[(i + 1)])))

axiom bin_check_zero_plus_one :
  (forall x:(int,int) farray. forall n:int. (binary_l(x, n) -> ((1 <  n) ->
  (bin_check_zero(x, n) = (if ((x[0]) = 1) then bin_check_zero(fc664(x),
  (n - 1)) else ang_zero)))))

axiom bin_check_zero_two :
  (forall x:(int,int) farray. (binary_l(x, 2) -> (bin_check_zero(x,
  2) = (if (((x[0]) = (x[1])) and ((x[1]) = 1)) then infix_sldtsl(1,
  1) else ang_zero))))

logic c_rzp_one : int, int, int -> circuit1

axiom c_rzp_oneqtdef :
  (forall c:int. forall t1:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> (c_rzp_one(c, t1,
  n) = crz(c, t1, 1, n))))))

axiom c_rzp_oneqtspec :
  (forall c:int. forall t1:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> (width1(c_rzp_one(c, t1,
  n)) = n)))))

axiom c_rzp_oneqtspec1 :
  (forall c:int. forall t1:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> (size1(c_rzp_one(c, t1,
  n)) = cont_size1)))))

axiom c_rzp_oneqtspec2 :
  (forall c:int. forall t1:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> (range1(c_rzp_one(c, t1,
  n)) = 0)))))

axiom c_rzp_oneqtspec3 :
  (forall c:int. forall t1:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (basis_ket1(c_rzp_one(c, t1, n), x, y, i) = (x[i])))))))

axiom c_rzp_oneqtspec4 :
  (forall c:int. forall t1:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) -> (ancillas1(c_rzp_one(c,
  t1, n)) = 0)))))

axiom c_rzp_oneqtspec5 :
  (forall c:int. forall t1:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(c_rzp_one(c, t1, n), x, y) = infix_sldtsl(((x[c]) * (x[t1])),
  1)))))))

axiom c_rzp_oneqtspec6 :
  (forall c:int. forall t1:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (c = t1)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. ((n = 2) ->
  (binary_l(x, 2) -> (ang_ind1(c_rzp_one(c, t1, n), x, y) = bin_check_zero(x,
  2)))))))))

logic repeat_had : int -> circuit1

axiom repeat_hadqtdef :
  (forall n:int. ((1 <= n) -> ((n = 1) -> (repeat_had(n) = hadamard1))))

axiom repeat_hadqtdef1 :
  (forall n:int. ((1 <= n) -> ((not (n = 1)) ->
  (repeat_had(n) = infix_slsl(repeat_had((n - 1)), hadamard1)))))

logic fc665 : (int,int) farray, (int,int) farray -> (int,angle) farray

axiom fcqtdef668 :
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  ((fc665(x, y)[i]) = int_to_ang((if (((x[i]) = (y[i])) and
  ((y[i]) = 1)) then 1 else 0), 1)))

axiom repeat_hadqtspec :
  (forall n:int. ((1 <= n) -> (width1(repeat_had(n)) = n)))

axiom repeat_hadqtspec1 :
  (forall n:int. ((1 <= n) -> (range1(repeat_had(n)) = n)))

axiom repeat_hadqtspec2 :
  (forall n:int. ((1 <= n) -> (size1(repeat_had(n)) = n)))

axiom repeat_hadqtspec3 :
  (forall n:int. ((1 <= n) -> (ancillas1(repeat_had(n)) = 0)))

axiom repeat_hadqtspec4 :
  (forall n:int. ((1 <= n) ->
  (circ_to_pps1(repeat_had(n)) = repeat_pps_had(n))))

axiom repeat_hadqtspec5 :
  (forall n:int. ((1 <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) -> (basis_ket1(repeat_had(n), x, y,
  i) = (y[i])))))))

axiom repeat_hadqtspec6 :
  (forall n:int. ((1 <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (binary_l(y, n) -> (ang_ind1(repeat_had(n), x, y) = ang_sum(fc665(x, y), 0,
  n)))))))

logic fc666 : bitvec, bitvec -> (int,int) farray

logic fc667 : int, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef669 :
  (forall x:bitvec. forall y:bitvec. forall k:int. ((fc666(x,
  y)[k]) = ((value(x)[k]) * (value(y)[k]))))

axiom fcqtdef670 :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((fc667(n,
  x)[y]) = infix_asdtdt(cpower(prefix_mndt(c_one), ind_isum(fc666(x, y), 0,
  n)), bv_to_ket(y))))

axiom repeat_had_basis_bv :
  (forall n:int. forall x:bitvec. ((1 <= n) -> ((length(x) = n) ->
  (path_sem1(repeat_had(n), bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(n),
  ket_sum_l(n_bvs(n), fc667(n, x), n))))))

logic fc668 : int, int, bitvec -> (int,int) farray

logic fc669 : int, int -> (bitvec,complex matrix) farray

axiom fcqtdef671 :
  (forall n:int. forall i:int. forall y:bitvec. forall k:int. ((fc668(n, i,
  y)[k]) = ((value(int_to_bv(i, n))[k]) * (value(y)[k]))))

axiom fcqtdef672 :
  (forall n:int. forall i:int. forall y:bitvec. ((fc669(n,
  i)[y]) = infix_asdtdt(cpower(prefix_mndt(c_one), ind_isum(fc668(n, i, y),
  0, n)), bv_to_ket(y))))

axiom repeat_had_basis :
  (forall n:int. forall i:int. ((1 <= n) -> (((0 <= i) and (i <  power(2,
  n))) -> (path_sem1(repeat_had(n), ket(n,
  i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc669(n, i),
  n))))))

axiom path_sem_repeat_had_superposition :
  (forall n:int. ((1 <= n) -> (path_sem1(repeat_had(n),
  superposition_state(n)) = ket(n, 0))))

axiom path_sem_repeat_had_invol :
  (forall n:int. forall x:complex matrix. (is_a_ket_l(x, n) -> ((1 <= n) ->
  (path_sem1(repeat_had(n), path_sem1(repeat_had(n), x)) = x))))

axiom path_sem_repeat_had_to_superposition :
  (forall n:int. ((1 <= n) -> (path_sem1(repeat_had(n), ket(n,
  0)) = superposition_state(n))))

logic seq_flat_mute : circuit1, circuit1 -> circuit1

axiom seq_flat_muteqtdef :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (seq_flat_mute(d, e) = infix_mnmn(d, e))))))))

axiom seq_flat_muteqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (size1(seq_flat_mute(d, e)) = (size1(d) + size1(e)))))))))

axiom seq_flat_muteqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (ancillas1(seq_flat_mute(d, e)) = max(ancillas1(d), ancillas1(e)))))))))

axiom seq_flat_muteqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (pre1(seq_flat_mute(d, e)) = Sequence1(pre1(d), pre1(e)))))))))

axiom seq_flat_muteqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (width1(seq_flat_mute(d, e)) = width1(d))))))))

axiom seq_flat_muteqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, width1(d)) -> (((0 <= i) and
  (i <  width1(d))) -> (basis_ket1(seq_flat_mute(d, e), x, y,
  i) = basis_ket1(e, (((basis_ket_closure1[d])[x])[y]), y, i))))))))))))

axiom seq_flat_muteqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (width1(seq_flat_mute(d, e)) = width1(d))))))))

axiom seq_flat_muteqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (range1(seq_flat_mute(d, e)) = 0)))))))

axiom seq_flat_muteqtspec7 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(d)) -> (ang_ind1(seq_flat_mute(d, e), x, y) = infix_sldtsl(1, 0))))))))))

logic cont_flat_mute : circuit1, int, int, int -> circuit1

axiom cont_flat_muteqtdef :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) -> (cont_flat_mute(c, co, t1, n) = cont1(c, co, t1,
  n))))))))

logic fc670 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef673 :
  (forall t1:int. forall x:(int,int) farray. forall j:int. ((fc670(t1,
  x)[j]) = (x[(j + t1)])))

axiom cont_flat_muteqtspec :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) -> (size1(cont_flat_mute(c, co, t1,
  n)) <= (cont_size1 * size1(c)))))))))

axiom cont_flat_muteqtspec1 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) -> (ancillas1(cont_flat_mute(c, co, t1,
  n)) = ancillas1(c))))))))

axiom cont_flat_muteqtspec2 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) -> (pre1(cont_flat_mute(c, co, t1, n)) = Cont(pre1(c), co,
  t1, n))))))))

axiom cont_flat_muteqtspec3 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) -> (width1(cont_flat_mute(c, co, t1, n)) = n)))))))

axiom cont_flat_muteqtspec4 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) -> (range1(cont_flat_mute(c, co, t1, n)) = 0)))))))

axiom cont_flat_muteqtspec5 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, n) -> (((0 <= i) and (i <  n)) ->
  (basis_ket1(cont_flat_mute(c, co, t1, n), x, y, i) = (if (((x[co]) = 1) and
  ((t1 <= i) and (i <  (t1 + width1(c))))) then basis_ket1(c, fc670(t1, x),
  y, (i - t1)) else (x[i])))))))))))))

axiom cont_flat_muteqtspec6 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cont_flat_mute(c, co, t1, n), x, y) = infix_sldtsl(1, 0))))))))))

logic cont_flat_mute_lemma : circuit1, int, int, int -> unit

axiom cont_flat_mute_lemmaqtdef :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) -> (cont_flat_mute_lemma(c, co, t1, n) = void)))))))

logic fc671 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef674 :
  (forall t1:int. forall x:(int,int) farray. forall j:int. ((fc671(t1,
  x)[j]) = (x[(j + t1)])))

axiom cont_flat_mute_lemmaqtspec :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) -> (range1(cont1(c, co, t1, n)) = 0)))))))

axiom cont_flat_mute_lemmaqtspec1 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, n) -> (((0 <= i) and (i <  n)) ->
  (basis_ket1(cont1(c, co, t1, n), x, y, i) = (if (((x[co]) = 1) and
  ((t1 <= i) and (i <  (t1 + width1(c))))) then basis_ket1(c, fc671(t1, x),
  y, (i - t1)) else (x[i])))))))))))))

axiom cont_flat_mute_lemmaqtspec2 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (ang_ind1(c, x, y) = infix_sldtsl(1, 0)))) ->
  ((range1(c) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cont1(c, co, t1, n), x, y) = infix_sldtsl(1, 0))))))))))

logic seq_flat_mute_right : circuit1, circuit1 -> circuit1

axiom seq_flat_mute_rightqtdef :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (seq_flat_mute_right(d, e) = infix_mnmn(d, e))))))

logic fc672 : circuit1, (int,int) farray -> (int,int) farray

axiom fcqtdef675 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc672(d,
  y)[k]) = (y[(k + range1(d))])))

axiom seq_flat_mute_rightqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (size1(seq_flat_mute_right(d, e)) = (size1(d) + size1(e)))))))

axiom seq_flat_mute_rightqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (ancillas1(seq_flat_mute_right(d, e)) = max(ancillas1(d),
  ancillas1(e)))))))

axiom seq_flat_mute_rightqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (width1(seq_flat_mute_right(d, e)) = width1(d))))))

axiom seq_flat_mute_rightqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (pre1(seq_flat_mute_right(d, e)) = Sequence1(pre1(d), pre1(e)))))))

axiom seq_flat_mute_rightqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (range1(seq_flat_mute_right(d, e)) = range1(d))))))

axiom seq_flat_mute_rightqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, width1(d)) -> (binary_l(y, range1(d)) ->
  (((0 <= i) and (i <  width1(d))) -> (basis_ket1(seq_flat_mute_right(d, e),
  x, y, i) = basis_ket1(e, (((basis_ket_closure1[d])[x])[y]), fc672(d, y),
  i)))))))))))

axiom seq_flat_mute_rightqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(e)) -> (ang_ind1(e, x, y) = infix_sldtsl(1, 0)))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(d)) -> (binary_l(y, range1(d)) -> (ang_ind1(seq_flat_mute_right(d,
  e), x, y) = ang_ind1(d, x, y)))))))))

logic seq_flat_mute_left : circuit1, circuit1 -> circuit1

axiom seq_flat_mute_leftqtdef :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (seq_flat_mute_left(d, e) = infix_mnmn(d, e))))))

axiom seq_flat_mute_leftqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (size1(seq_flat_mute_left(d, e)) = (size1(d) + size1(e)))))))

axiom seq_flat_mute_leftqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (ancillas1(seq_flat_mute_left(d, e)) = max(ancillas1(d), ancillas1(e)))))))

axiom seq_flat_mute_leftqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (pre1(seq_flat_mute_left(d, e)) = Sequence1(pre1(d), pre1(e)))))))

axiom seq_flat_mute_leftqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (width1(seq_flat_mute_left(d, e)) = width1(d))))))

axiom seq_flat_mute_leftqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (range1(seq_flat_mute_left(d, e)) = range1(e))))))

axiom seq_flat_mute_leftqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, width1(d)) -> (binary_l(y, range1(e)) ->
  (((0 <= i) and (i <  width1(d))) -> (basis_ket1(seq_flat_mute_left(d, e),
  x, y, i) = basis_ket1(e, (((basis_ket_closure1[d])[x])[y]), y, i)))))))))))

axiom seq_flat_mute_leftqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(d)) -> (binary_l(y, range1(e)) -> (ang_ind1(seq_flat_mute_left(d,
  e), x, y) = ang_ind1(e, (((basis_ket_closure1[d])[x])[y]), y)))))))))

axiom path_sem_flat_mute :
  (forall d:circuit1. forall x:bitvec. ((length(x) = width1(d)) ->
  ((range1(d) = 0) ->
  ((forall x1:(int,int) farray. forall y:(int,int) farray. (binary_l(x1,
   width1(d)) -> (ang_ind1(d, x1, y) = infix_sldtsl(1, 0)))) ->
  (path_sem1(d,
  bv_to_ket(x)) = bv_to_ket(make_bv((((basis_ket_closure1[d])[value(x)])[identity2]),
  width1(d))))))))

axiom path_sem_flat_mute_gen :
  (forall d:circuit1. ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (forall x:bitvec. ((length(x) = width1(d)) -> (path_sem1(d,
  bv_to_ket(x)) = bv_to_ket(make_bv((((basis_ket_closure1[d])[value(x)])[identity2]),
  width1(d)))))))))

axiom path_sem_flat_mute_ket :
  (forall d:circuit1. ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = infix_sldtsl(1, 0)))) ->
  (forall x:complex matrix. (is_a_ket_l(x, width1(d)) ->
  (is_a_ket_basis_elt(x) -> (path_sem1(d,
  x) = bv_to_ket(make_bv((((basis_ket_closure1[d])[value(ket_to_bv(x))])[identity2]),
  width1(d))))))))))

axiom path_sem_flat_mute_bv :
  (forall d:circuit1. forall x:bitvec. forall y:bitvec.
  ((length(x) = width1(d)) -> ((length(y) = width1(d)) -> ((range1(d) = 0) ->
  ((forall i:int. (((0 <= i) and (i <  width1(d))) -> (basis_ket1(d,
   value(x), identity2, i) = (value(y)[i])))) ->
  ((forall x1:(int,int) farray. forall y1:(int,int) farray. (binary_l(x1,
   width1(d)) -> (ang_ind1(d, x1, y1) = infix_sldtsl(1, 0)))) ->
  (path_sem1(d, bv_to_ket(x)) = bv_to_ket(y))))))))

logic fc673 : int, complex matrix -> (int,int) farray

axiom fcqtdef676 :
  (forall k:int. forall ket1:complex matrix. forall i:int. ((fc673(k,
  ket1)[i]) = (if (i = k) then (1 - (value(ket_to_bv(ket1))[i])) else (value(ket_to_bv(ket1))[i]))))

axiom sem_ind_cnot :
  (forall c:int. forall k:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= k) and (k <  n)) -> ((not (k = c)) ->
  (forall ket1:complex matrix. (is_a_ket_l(ket1, n) ->
  (is_a_ket_basis_elt(ket1) -> (((value(ket_to_bv(ket1))[c]) = 0) ->
  (path_sem1(cnot1(c, k, n), ket1) = ket1)))))))))

axiom sem_ind_cnot1 :
  (forall c:int. forall k:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= k) and (k <  n)) -> ((not (k = c)) ->
  (forall ket1:complex matrix. (is_a_ket_l(ket1, n) ->
  (is_a_ket_basis_elt(ket1) -> (((value(ket_to_bv(ket1))[c]) = 1) ->
  (path_sem1(cnot1(c, k, n), ket1) = bv_to_ket(make_bv(fc673(k, ket1),
  n)))))))))))

axiom sem_ind_cnot_zero :
  (forall n:int. ((1 <  n) ->
  (forall ket1:complex matrix.
  (forall i:int. (is_a_ket_l(ket1, (n - 1)) -> (is_a_ket_basis_elt(ket1) ->
  (((0 <= i) and (i <  2)) -> (((value(ket_to_bv(ket1))[0]) = 1) ->
  (path_sem1(cnot1(0, (n - 1), n), kronecker(ket1, ket(1,
  i))) = kronecker(ket1, ket(1, (1 - i))))))))))))

axiom sem_ind_cnot_zero1 :
  (forall n:int. ((1 <  n) ->
  (forall ket1:complex matrix.
  (forall i:int. (is_a_ket_l(ket1, (n - 1)) -> (is_a_ket_basis_elt(ket1) ->
  (((0 <= i) and (i <  2)) -> (((value(ket_to_bv(ket1))[0]) = 0) ->
  (path_sem1(cnot1(0, (n - 1), n), kronecker(ket1, ket(1,
  i))) = kronecker(ket1, ket(1, i)))))))))))

logic ind_neg_cnot : int, int, int -> circuit1

logic fc674 : int, int, bitvec -> (int,int) farray

axiom fcqtdef677 :
  (forall c:int. forall k:int. forall x:bitvec. forall i:int. ((fc674(c, k,
  x)[i]) = (if (i = k) then (if ((value(x)[c]) = 0) then (1 - (value(x)[i])) else (value(x)[i])) else (value(x)[i]))))

axiom ind_neg_cnotqtspec :
  (forall c:int. forall k:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= k) and (k <  n)) -> ((not (k = c)) -> (range1(ind_neg_cnot(c, k,
  n)) = 0)))))

axiom ind_neg_cnotqtspec1 :
  (forall c:int. forall k:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= k) and (k <  n)) -> ((not (k = c)) -> (ancillas1(ind_neg_cnot(c, k,
  n)) = 0)))))

axiom ind_neg_cnotqtspec2 :
  (forall c:int. forall k:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= k) and (k <  n)) -> ((not (k = c)) -> (size1(ind_neg_cnot(c, k,
  n)) = 3)))))

axiom ind_neg_cnotqtspec3 :
  (forall c:int. forall k:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= k) and (k <  n)) -> ((not (k = c)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (binary_l(x, n) -> (((0 <= i) and (i <  n)) -> (basis_ket1(ind_neg_cnot(c,
  k, n), x, y,
  i) = (if (i = k) then (if ((x[c]) = 0) then (1 - (x[i])) else (x[i])) else (x[i]))))))))))

axiom ind_neg_cnotqtspec4 :
  (forall c:int. forall k:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= k) and (k <  n)) -> ((not (k = c)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(ind_neg_cnot(c, k, n), x, y) = ang_zero)))))))

axiom ind_neg_cnotqtspec5 :
  (forall c:int. forall k:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= k) and (k <  n)) -> ((not (k = c)) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem1(ind_neg_cnot(c, k, n),
  bv_to_ket(x)) = bv_to_ket(make_bv(fc674(c, k, x), n)))))))))

axiom ind_neg_cnotqtspec6 :
  (forall c:int. forall k:int. forall n:int. (((0 <= c) and (c <  n)) ->
  (((0 <= k) and (k <  n)) -> ((not (k = c)) -> (width1(ind_neg_cnot(c, k,
  n)) = n)))))

logic fc675 : int, complex matrix -> (int,int) farray

axiom fcqtdef678 :
  (forall n:int. forall ket1:complex matrix. forall i:int. ((fc675(n,
  ket1)[i]) = (if (i = n) then (1 - (value(ket_to_bv(ket1))[i])) else (value(ket_to_bv(ket1))[i]))))

axiom sem_ind_neg_cnot_zero :
  (forall n:int. ((0 <  n) ->
  (forall i:int. (((0 <= i) and (i <  power(2, (n - 1)))) ->
  (path_sem1(ind_neg_cnot(0, n, (n + 1)), kronecker(ket(n, i), ket(1,
  1))) = kronecker(ket(n, i), ket(1, 0)))))))

axiom sem_ind_neg_cnot_zero1 :
  (forall n:int. ((0 <  n) ->
  (forall i:int. (((power(2, (n - 1)) <= i) and (i <  power(2, n))) ->
  (path_sem1(ind_neg_cnot(0, n, (n + 1)), kronecker(ket(n, i), ket(1,
  0))) = kronecker(ket(n, i), ket(1, 0)))))))

axiom sem_ind_neg_cnot_zero2 :
  (forall n:int. ((0 <  n) ->
  (forall ket1:complex matrix. (is_a_ket_l(ket1, (n + 1)) ->
  (is_a_ket_basis_elt(ket1) -> (((value(ket_to_bv(ket1))[0]) = 1) ->
  (path_sem1(ind_neg_cnot(0, n, (n + 1)), ket1) = ket1)))))))

axiom sem_ind_neg_cnot_zero3 :
  (forall n:int. ((0 <  n) ->
  (forall ket1:complex matrix. (is_a_ket_l(ket1, (n + 1)) ->
  (is_a_ket_basis_elt(ket1) -> (((value(ket_to_bv(ket1))[0]) = 0) ->
  (path_sem1(ind_neg_cnot(0, n, (n + 1)), ket1) = bv_to_ket(make_bv(fc675(n,
  ket1), (n + 1))))))))))

logic repeat_xx : int -> circuit1

axiom repeat_xxqtdef :
  (forall n:int. ((1 <= n) -> ((n = 1) -> (repeat_xx(n) = xx1))))

axiom repeat_xxqtdef1 :
  (forall n:int. ((1 <= n) -> ((not (n = 1)) ->
  (repeat_xx(n) = infix_slsl(repeat_xx((n - 1)), xx1)))))

axiom repeat_xxqtspec :
  (forall n:int. ((1 <= n) -> (width1(repeat_xx(n)) = n)))

axiom repeat_xxqtspec1 :
  (forall n:int. ((1 <= n) -> (range1(repeat_xx(n)) = 0)))

axiom repeat_xxqtspec2 :
  (forall n:int. ((1 <= n) -> (size1(repeat_xx(n)) = n)))

axiom repeat_xxqtspec3 :
  (forall n:int. ((1 <= n) -> (ancillas1(repeat_xx(n)) = 0)))

axiom repeat_xxqtspec4 :
  (forall n:int. ((1 <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  n)) -> (basis_ket1(repeat_xx(n), x, y,
  i) = (1 - (x[i]))))))))

axiom repeat_xxqtspec5 :
  (forall n:int. ((1 <= n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(repeat_xx(n), x, y) = ang_zero))))

logic with_permutation1 : circuit1, (int,int) farray -> circuit1

logic fc676 : (int,int) farray, (int,int) farray -> (int,int) farray

logic fc677 : (int,int) farray, (int,int) farray -> (int,int) farray

logic fc678 : circuit1, (int,int) farray,
  (int,int) farray -> (int,int) farray

axiom fcqtdef679 :
  (forall f:(int,int) farray. forall x:(int,int) farray. forall i:int.
  ((fc676(f, x)[i]) = (x[(f[i])])))

axiom fcqtdef680 :
  (forall f:(int,int) farray. forall x:(int,int) farray. forall i:int.
  ((fc677(f, x)[i]) = (x[(f[i])])))

axiom fcqtdef681 :
  (forall c:circuit1. forall f:(int,int) farray. forall x:(int,int) farray.
  forall i:int. ((fc678(c, f, x)[i]) = (x[(c_inv_func_int(f,
  width1(c))[i])])))

axiom with_permutationqtspec8 :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) -> (unwire(with_permutation1(c,
  f)) = with_permutation(unwire(c), f))))

axiom with_permutationqtspec9 :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) -> (size1(with_permutation1(c,
  f)) <= ((2 * width1(c)) + size1(c)))))

axiom with_permutationqtspec10 :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) -> (ancillas1(with_permutation1(c,
  f)) = ancillas1(c))))

axiom with_permutationqtspec11 :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) -> (width1(with_permutation1(c,
  f)) = width1(c))))

axiom with_permutationqtspec12 :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) -> (range1(with_permutation1(c,
  f)) = range1(c))))

axiom with_permutationqtspec13 :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(with_permutation1(c, f), x, y) = ang_ind1(c, fc676(f, x), y)))))

axiom with_permutationqtspec14 :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  width1(c))) ->
  (basis_ket1(with_permutation1(c, f), x, y, i) = basis_ket1(c, fc677(f, x),
  y, (c_inv_func_int(f, width1(c))[i]))))))))

axiom with_permutationqtspec15 :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  width1(c))) ->
  (basis_ket1(with_permutation1(c, f), fc678(c, f, x), y, i) = basis_ket1(c,
  x, y, (c_inv_func_int(f, width1(c))[i]))))))))

axiom with_permutationqtspec16 :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) -> (with_permutation1(c,
  f) = infix_mnmn(infix_mnmn(permutation_circuit1(width1(c), f), c),
  permutation_circuit1(width1(c), c_inv_func_int(f, width1(c)))))))

logic unwire_with_permutation : circuit1, (int,int) farray -> unit

axiom unwire_with_permutationqtdef :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) -> (unwire_with_permutation(c,
  f) = void)))

axiom unwire_with_permutationqtspec :
  (forall c:circuit1. forall f:(int,int) farray. (p_bijective(f, to_fset(0,
  width1(c)), to_fset(0, width1(c))) ->
  (forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (path_sem1(with_permutation1(c, f),
  x) = path_sem(with_permutation(unwire(c), f), x))))))

logic fc679 : int, int -> (int,int) farray

axiom fcqtdef682 :
  (forall k:int. forall n:int. forall i:int. ((fc679(k,
  n)[i]) = (if (i <  k) then ((i + n) - k) else (i - k))))

axiom with_permutation_kronecker_gen1 :
  (forall c:circuit1. forall k:int. forall n:int. ((width1(c) = n) ->
  (((0 <= k) and (k <  n)) ->
  (forall im1:complex matrix. forall im_d:complex matrix.
  forall ant:complex matrix. forall ant_d:complex matrix. (is_a_ket_l(ant,
  k) -> (is_a_ket_l(ant_d, (n - k)) -> (is_a_ket_l(im1, k) ->
  (is_a_ket_l(im_d, (n - k)) -> (is_a_ket_basis_elt(ant) ->
  (is_a_ket_basis_elt(ant_d) -> ((path_sem1(c, kronecker(ant,
  ant_d)) = kronecker(im1, im_d)) -> (path_sem1(with_permutation1(c, fc679(k,
  n)), kronecker(ant_d, ant)) = kronecker(im_d, im1)))))))))))))

logic permutation_three_blocks1 : int, int, int, int -> circuit1

logic result84 : int, int, int -> (int,int) farray

axiom resultqtdef91 :
  (forall n1:int. forall n2:int. forall n3:int. forall j:int. ((result84(n1,
  n2,
  n3)[j]) = (if (j <  n1) then j else (if (j <  (n1 + n3)) then (j + n2) else (j - n3)))))

axiom permutation_three_blocksqtdef :
  (forall n1:int. forall n2:int. forall n3:int. forall n:int. ((0 <= n1) ->
  ((0 <= n2) -> ((0 <= n3) -> ((0 <  n) -> ((n = ((n1 + n2) + n3)) ->
  (permutation_three_blocks1(n1, n2, n3, n) = permutation_circuit1(n,
  result84(n1, n2, n3)))))))))

axiom permutation_three_blocksqtspec :
  (forall n1:int. forall n2:int. forall n3:int. forall n:int. ((0 <= n1) ->
  ((0 <= n2) -> ((0 <= n3) -> ((0 <  n) -> ((n = ((n1 + n2) + n3)) ->
  (size1(permutation_three_blocks1(n1, n2, n3, n)) <= n)))))))

axiom permutation_three_blocksqtspec1 :
  (forall n1:int. forall n2:int. forall n3:int. forall n:int. ((0 <= n1) ->
  ((0 <= n2) -> ((0 <= n3) -> ((0 <  n) -> ((n = ((n1 + n2) + n3)) ->
  (ancillas1(permutation_three_blocks1(n1, n2, n3, n)) = 0)))))))

axiom permutation_three_blocksqtspec2 :
  (forall n1:int. forall n2:int. forall n3:int. forall n:int. ((0 <= n1) ->
  ((0 <= n2) -> ((0 <= n3) -> ((0 <  n) -> ((n = ((n1 + n2) + n3)) ->
  (width1(permutation_three_blocks1(n1, n2, n3, n)) = n)))))))

axiom permutation_three_blocksqtspec3 :
  (forall n1:int. forall n2:int. forall n3:int. forall n:int. ((0 <= n1) ->
  ((0 <= n2) -> ((0 <= n3) -> ((0 <  n) -> ((n = ((n1 + n2) + n3)) ->
  (forall x:bitvec. forall y:bitvec. forall z:bitvec. ((length(x) = n1) ->
  ((length(y) = n2) -> ((length(z) = n3) ->
  (path_sem1(permutation_three_blocks1(n1, n2, n3, n),
  kronecker(kronecker(bv_to_ket(x), bv_to_ket(y)),
  bv_to_ket(z))) = kronecker(kronecker(bv_to_ket(x), bv_to_ket(z)),
  bv_to_ket(y)))))))))))))

logic insert_qbits1 : circuit1, int, int, int -> circuit1

logic result85 : int, int, int -> (int,int) farray

axiom resultqtdef92 :
  (forall k:int. forall n:int. forall i:int. forall j:int. ((result85(k, n,
  i)[j]) = (if (j <  k) then j else (if (j <  n) then (j + i) else ((j - n) + k)))))

axiom insert_qbitsqtdef1 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (insert_qbits1(c, k, n, i) = with_permutation1(infix_slsl(c, m_skip(i)),
  result85(k, n, i)))))))

logic fc680 : int, int, int, (int,int) farray -> (int,int) farray

logic fc681 : int, int, int, (int,int) farray -> (int,int) farray

logic fc682 : int, int, int, (int,int) farray -> (int,int) farray

axiom fcqtdef683 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall j:int. ((fc680(k, n, i,
  x)[j]) = (x[(if (j <  k) then j else (if (j <  n) then (j + i) else ((j - n) + k)))])))

axiom fcqtdef684 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall ii:int. ((fc681(k, n, i,
  x)[ii]) = (x[(if (ii <  k) then ii else (if (ii <  n) then (ii + i) else ((ii - n) + k)))])))

axiom fcqtdef685 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall ii:int. ((fc682(k, n, i,
  x)[ii]) = (x[(if (ii <  k) then ii else (if (ii <  n) then (ii + i) else ((ii - n) + k)))])))

axiom insert_qbitsqtspec8 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (ancillas1(insert_qbits1(c, k, n, i)) = ancillas1(c))))))

axiom insert_qbitsqtspec9 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (width1(insert_qbits1(c, k, n, i)) = (n + i))))))

axiom insert_qbitsqtspec10 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (size1(insert_qbits1(c, k, n, i)) <= ((2 * (n + i)) + size1(c)))))))

axiom insert_qbitsqtspec11 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (range1(insert_qbits1(c, k, n, i)) = range1(c))))))

axiom insert_qbitsqtspec12 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(insert_qbits1(c, k, n, i), x, y) = ang_ind1(c, fc680(k, n, i, x),
  y)))))))

axiom insert_qbitsqtspec13 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. (((0 <= j) and (j <  k)) -> (basis_ket1(insert_qbits1(c, k,
  n, i), x, y, j) = basis_ket1(c, fc681(k, n, i, x), y, j)))))))))

axiom insert_qbitsqtspec14 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. ((((k + i) <= j) and (j <  (n + i))) ->
  (basis_ket1(insert_qbits1(c, k, n, i), x, y, j) = basis_ket1(c, fc682(k, n,
  i, x), y, (j - i))))))))))

axiom insert_qbitsqtspec15 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. (((k <= j) and (j <  (k + i))) ->
  (basis_ket1(insert_qbits1(c, k, n, i), x, y, j) = (x[j])))))))))

axiom insert_qbits_path_sem1 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  forall x:bitvec. forall im1:complex matrix. forall im_d:complex matrix.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  ((length(x) = (n + i)) -> (is_a_ket_l(im1, k) -> (is_a_ket_l(im_d,
  (n - k)) -> ((path_sem1(c, bv_to_ket(concat(hpart(x, k), tpart(x,
  (k + i))))) = kronecker(im1, im_d)) -> (path_sem1(insert_qbits1(c, k, n,
  i), bv_to_ket(x)) = kronecker(im1, kronecker(bv_to_ket(htpart(x, k, i)),
  im_d)))))))))))

axiom insert_qbits_path_sem_basis :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  forall x:complex matrix. forall y:complex matrix. forall z:complex matrix.
  forall xqt:complex matrix. forall zqt:complex matrix. ((width1(c) = n) ->
  (((0 <= k) and (k <  n)) -> ((0 <  i) -> (is_a_ket_l(x, k) ->
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (is_a_ket_basis_elt(z) -> (is_a_ket_l(xqt, k) -> (is_a_ket_l(y, i) ->
  (is_a_ket_l(z, (n - k)) -> (is_a_ket_l(zqt, (n - k)) -> ((path_sem1(c,
  kronecker(x, z)) = kronecker(xqt, zqt)) -> (path_sem1(insert_qbits1(c, k,
  n, i), kronecker(x, kronecker(y, z))) = kronecker(xqt, kronecker(y,
  zqt))))))))))))))))

logic insert_qbits_gen1 : circuit1, int, int, int -> circuit1

axiom insert_qbits_genqtdef2 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) -> ((0 <  i) ->
  (insert_qbits_gen1(c, k, n, i) = insert_qbits1(c, k, n, i)))))))

axiom insert_qbits_genqtdef3 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  ((not (0 <  i)) -> (insert_qbits_gen1(c, k, n, i) = c))))))

logic fc683 : int, int, int, (int,int) farray -> (int,int) farray

logic fc684 : int, int, int, (int,int) farray -> (int,int) farray

logic fc685 : int, int, int, (int,int) farray -> (int,int) farray

axiom fcqtdef686 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall j:int. ((fc683(k, n, i,
  x)[j]) = (x[(if (j <  k) then j else (if (j <  n) then (j + i) else ((j - n) + k)))])))

axiom fcqtdef687 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall ii:int. ((fc684(k, n, i,
  x)[ii]) = (x[(if (ii <  k) then ii else (if (ii <  n) then (ii + i) else ((ii - n) + k)))])))

axiom fcqtdef688 :
  (forall k:int. forall n:int. forall i:int. forall x:(int,int) farray.
  forall ii:int. ((fc685(k, n, i,
  x)[ii]) = (x[(if (ii <  k) then ii else (if (ii <  n) then (ii + i) else ((ii - n) + k)))])))

axiom insert_qbits_genqtspec8 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (ancillas1(insert_qbits_gen1(c, k, n, i)) = ancillas1(c))))))

axiom insert_qbits_genqtspec9 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (width1(insert_qbits_gen1(c, k, n, i)) = (n + i))))))

axiom insert_qbits_genqtspec10 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (size1(insert_qbits_gen1(c, k, n, i)) <= ((2 * (n + i)) + size1(c)))))))

axiom insert_qbits_genqtspec11 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (range1(insert_qbits_gen1(c, k, n, i)) = range1(c))))))

axiom insert_qbits_genqtspec12 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (ang_ind1(insert_qbits_gen1(c, k, n, i), x, y) = ang_ind1(c, fc683(k, n, i,
  x), y)))))))

axiom insert_qbits_genqtspec13 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. (((0 <= j) and (j <  k)) -> (basis_ket1(insert_qbits_gen1(c,
  k, n, i), x, y, j) = basis_ket1(c, fc684(k, n, i, x), y, j)))))))))

axiom insert_qbits_genqtspec14 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. ((((k + i) <= j) and (j <  (n + i))) ->
  (basis_ket1(insert_qbits_gen1(c, k, n, i), x, y, j) = basis_ket1(c,
  fc685(k, n, i, x), y, (j - i))))))))))

axiom insert_qbits_genqtspec15 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall j:int. (((k <= j) and (j <  (k + i))) ->
  (basis_ket1(insert_qbits_gen1(c, k, n, i), x, y, j) = (x[j])))))))))

axiom insert_qbits_genqtspec16 :
  (forall c:circuit1. forall k:int. forall n:int. forall i:int.
  ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <= i) ->
  (forall im1:complex matrix. forall im_d:complex matrix.
  forall inserted:complex matrix. forall x:bitvec. (is_a_ket_l(im1, k) ->
  (is_a_ket_l(im_d, (n - k)) -> ((inserted = bv_to_ket(htpart(x, k, i))) ->
  ((length(x) = (n + i)) -> ((path_sem1(c, bv_to_ket(concat(hpart(x, k),
  tpart(x, (k + i))))) = kronecker(im1, im_d)) ->
  (path_sem1(insert_qbits_gen1(c, k, n, i), bv_to_ket(x)) = kronecker(im1,
  kronecker(inserted, im_d)))))))))))))

logic swap_lists : int, int, int, int -> circuit1

axiom swap_listsqtdef :
  (forall c1:int. forall c2:int. forall l:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> ((0 <  l) -> (((c2 + l) <= n) -> (((c1 + l) <= c2) ->
  ((not (c1 = c2)) -> (swap_lists(c1, c2, l,
  n) = place1(insert_qbits_gen1(permutation_three_blocks1(0, l, l, (2 * l)),
  l, (2 * l), (c2 - l)), 0, n))))))))

axiom swap_listsqtspec :
  (forall c1:int. forall c2:int. forall l:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> ((0 <  l) -> (((c2 + l) <= n) -> (((c1 + l) <= c2) ->
  ((not (c1 = c2)) -> (size1(swap_lists(c1, c2, l,
  n)) <= (2 * ((2 * l) + c2)))))))))

axiom swap_listsqtspec1 :
  (forall c1:int. forall c2:int. forall l:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> ((0 <  l) -> (((c2 + l) <= n) -> (((c1 + l) <= c2) ->
  ((not (c1 = c2)) -> (ancillas1(swap_lists(c1, c2, l, n)) = 0)))))))

axiom swap_listsqtspec2 :
  (forall c1:int. forall c2:int. forall l:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> ((0 <  l) -> (((c2 + l) <= n) -> (((c1 + l) <= c2) ->
  ((not (c1 = c2)) -> (width1(swap_lists(c1, c2, l, n)) = n)))))))

axiom swap_lists_kets_basis :
  (forall c2:int. forall l:int. forall n:int. ((0 <  l) ->
  (((0 <= (c2 + l)) and ((c2 + l) <= n)) ->
  (forall a:complex matrix. forall x:complex matrix. forall y:complex matrix.
  forall z:complex matrix. (is_a_ket_l(a, (c2 - l)) -> (is_a_ket_l(x, l) ->
  (is_a_ket_l(y, l) -> (is_a_ket_l(z, ((n - c2) - l)) ->
  (is_a_ket_basis_elt(x) -> (is_a_ket_basis_elt(y) ->
  (is_a_ket_basis_elt(a) -> (is_a_ket_basis_elt(z) ->
  (path_sem1(swap_lists(0, c2, l, n), kronecker(x, kronecker(kronecker(a, y),
  z))) = kronecker(y, kronecker(kronecker(a, x), z)))))))))))))))

axiom swap_lists_kets :
  (forall c2:int. forall l:int. forall n:int. ((0 <  l) ->
  (((0 <= (c2 + l)) and ((c2 + l) <= n)) ->
  (forall a:complex matrix. forall x:complex matrix. forall y:complex matrix.
  forall z:complex matrix. (is_a_ket_l(a, (c2 - l)) -> (is_a_ket_l(x, l) ->
  (is_a_ket_l(y, l) -> (is_a_ket_l(z, ((n - c2) - l)) ->
  (path_sem1(swap_lists(0, c2, l, n), kronecker(x, kronecker(kronecker(a, y),
  z))) = kronecker(y, kronecker(kronecker(a, x), z)))))))))))

logic cascade_cont_rz_neg : int, int, int, int, int -> circuit1

axiom cascade_cont_rz_negqtdef :
  (forall first_k:int. forall first_c:int. forall t1:int. forall l:int.
  forall n:int. (((0 <= l) and (l <  n)) -> (((0 <= first_c) and
  (first_c <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((first_c + l) <  n) ->
  ((0 <= first_k) -> (((first_k + l) <= n) -> (((t1 <= (first_c + l)) ->
  (t1 <  first_c)) -> ((l = 0) -> (cascade_cont_rz_neg(first_k, first_c, t1,
  l, n) = crzn_up(first_c, t1, (-first_k), n, n)))))))))))

axiom cascade_cont_rz_negqtdef1 :
  (forall first_k:int. forall first_c:int. forall t1:int. forall l:int.
  forall n:int. (((0 <= l) and (l <  n)) -> (((0 <= first_c) and
  (first_c <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((first_c + l) <  n) ->
  ((0 <= first_k) -> (((first_k + l) <= n) -> (((t1 <= (first_c + l)) ->
  (t1 <  first_c)) -> ((not (l = 0)) -> (cascade_cont_rz_neg(first_k,
  first_c, t1, l, n) = seq_diag(cascade_cont_rz_neg(first_k, first_c, t1,
  (l - 1), n), crzn_up((first_c + l), t1, (-(first_k + l)), n, n))))))))))))

logic fc686 : int, int, int, int, (int,int) farray -> (int,int) farray

axiom fcqtdef689 :
  (forall first_k:int. forall first_c:int. forall t1:int. forall n:int.
  forall x:(int,int) farray. forall k:int. ((fc686(first_k, first_c, t1, n,
  x)[k]) = (((x[(first_c + k)]) * (x[t1])) * power(2, (n - (k + first_k))))))

axiom cascade_cont_rz_negqtspec :
  (forall first_k:int. forall first_c:int. forall t1:int. forall l:int.
  forall n:int. (((0 <= l) and (l <  n)) -> (((0 <= first_c) and
  (first_c <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((first_c + l) <  n) ->
  ((0 <= first_k) -> (((first_k + l) <= n) -> (((t1 <= (first_c + l)) ->
  (t1 <  first_c)) -> (width1(cascade_cont_rz_neg(first_k, first_c, t1, l,
  n)) = n)))))))))

axiom cascade_cont_rz_negqtspec1 :
  (forall first_k:int. forall first_c:int. forall t1:int. forall l:int.
  forall n:int. (((0 <= l) and (l <  n)) -> (((0 <= first_c) and
  (first_c <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((first_c + l) <  n) ->
  ((0 <= first_k) -> (((first_k + l) <= n) -> (((t1 <= (first_c + l)) ->
  (t1 <  first_c)) -> (range1(cascade_cont_rz_neg(first_k, first_c, t1, l,
  n)) = 0)))))))))

axiom cascade_cont_rz_negqtspec2 :
  (forall first_k:int. forall first_c:int. forall t1:int. forall l:int.
  forall n:int. (((0 <= l) and (l <  n)) -> (((0 <= first_c) and
  (first_c <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((first_c + l) <  n) ->
  ((0 <= first_k) -> (((first_k + l) <= n) -> (((t1 <= (first_c + l)) ->
  (t1 <  first_c)) -> (ancillas1(cascade_cont_rz_neg(first_k, first_c, t1, l,
  n)) = 0)))))))))

axiom cascade_cont_rz_negqtspec3 :
  (forall first_k:int. forall first_c:int. forall t1:int. forall l:int.
  forall n:int. (((0 <= l) and (l <  n)) -> (((0 <= first_c) and
  (first_c <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((first_c + l) <  n) ->
  ((0 <= first_k) -> (((first_k + l) <= n) -> (((t1 <= (first_c + l)) ->
  (t1 <  first_c)) -> (size1(cascade_cont_rz_neg(first_k, first_c, t1, l,
  n)) <= (cont_size1 * (l + 1)))))))))))

axiom cascade_cont_rz_negqtspec4 :
  (forall first_k:int. forall first_c:int. forall t1:int. forall l:int.
  forall n:int. (((0 <= l) and (l <  n)) -> (((0 <= first_c) and
  (first_c <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((first_c + l) <  n) ->
  ((0 <= first_k) -> (((first_k + l) <= n) -> (((t1 <= (first_c + l)) ->
  (t1 <  first_c)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  n)) -> (binary_l(x, n) ->
  (basis_ket1(cascade_cont_rz_neg(first_k, first_c, t1, l, n), x, y,
  i) = (x[i])))))))))))))

axiom cascade_cont_rz_negqtspec5 :
  (forall first_k:int. forall first_c:int. forall t1:int. forall l:int.
  forall n:int. (((0 <= l) and (l <  n)) -> (((0 <= first_c) and
  (first_c <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((first_c + l) <  n) ->
  ((0 <= first_k) -> (((first_k + l) <= n) -> (((t1 <= (first_c + l)) ->
  (t1 <  first_c)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cascade_cont_rz_neg(first_k, first_c, t1, l, n), x,
  y) = infix_sldtsl((-ind_isum(fc686(first_k, first_c, t1, n, x), 0,
  (l + 1))), n))))))))))))

logic cascade_cont_qft : int, int -> circuit1

axiom cascade_cont_qftqtdef :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  (n - 1))) ->
  (cascade_cont_qft(t1, n) = cascade_cont_rz_neg(2, (t1 + 1), t1,
  (n - (t1 + 2)), n))))

logic fc687 : int, int, (int,int) farray -> (int,int) farray

logic fc688 : int, int, (int,int) farray -> (int,int) farray

axiom fcqtdef690 :
  (forall t1:int. forall n:int. forall x:(int,int) farray. forall k:int.
  ((fc687(t1, n, x)[k]) = (((x[((t1 + 1) + k)]) * (x[t1])) * power(2,
  (n - (k + 2))))))

axiom fcqtdef691 :
  (forall t1:int. forall n:int. forall x:(int,int) farray. forall k:int.
  ((fc688(t1, n, x)[k]) = (((x[t1]) * (x[k])) * power(2,
  (((n - k) - 1) + t1)))))

axiom cascade_cont_qftqtspec :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  (n - 1))) ->
  (width1(cascade_cont_qft(t1, n)) = n)))

axiom cascade_cont_qftqtspec1 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  (n - 1))) ->
  (size1(cascade_cont_qft(t1, n)) <= (cont_size1 * ((n - t1) - 1)))))

axiom cascade_cont_qftqtspec2 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  (n - 1))) ->
  (ancillas1(cascade_cont_qft(t1, n)) = 0)))

axiom cascade_cont_qftqtspec3 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  (n - 1))) ->
  (range1(cascade_cont_qft(t1, n)) = 0)))

axiom cascade_cont_qftqtspec4 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  (n - 1))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  n)) -> (binary_l(x, n) ->
  (basis_ket1(cascade_cont_qft(t1, n), x, y, i) = (x[i])))))))

axiom cascade_cont_qftqtspec5 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  (n - 1))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cascade_cont_qft(t1, n), x,
  y) = infix_sldtsl((-ind_isum(fc687(t1, n, x), 0, ((n - (t1 + 2)) + 1))),
  n))))))

axiom cascade_cont_qftqtspec6 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  (n - 1))) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cascade_cont_qft(t1, n), x,
  y) = infix_sldtsl((-ind_isum(fc688(t1, n, x), (t1 + 1), n)), n))))))

logic qft_rev_line : int, int -> circuit1

axiom qft_rev_lineqtdef :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  ((t1 = (n - 1)) -> (qft_rev_line(t1, n) = place_hadamard1(t1, n)))))

axiom qft_rev_lineqtdef1 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = (n - 1))) -> (qft_rev_line(t1,
  n) = seq_diag_right(place_hadamard1(t1, n), cascade_cont_qft(t1, n))))))

logic fc689 : int, int, (int,int) farray,
  (int,int) farray -> (int,int) farray

axiom fcqtdef692 :
  (forall t1:int. forall n:int. forall x:(int,int) farray.
  forall y:(int,int) farray. forall j:int. ((fc689(t1, n, x,
  y)[j]) = (((x[j]) * (y[0])) * power(2, (((n - j) - 1) + t1)))))

axiom qft_rev_lineqtspec :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (size1(qft_rev_line(t1, n)) <= ((cont_size1 * ((n - t1) - 1)) + 1))))

axiom qft_rev_lineqtspec1 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (ancillas1(qft_rev_line(t1, n)) = 0)))

axiom qft_rev_lineqtspec2 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (width1(qft_rev_line(t1, n)) = n)))

axiom qft_rev_lineqtspec3 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (range1(qft_rev_line(t1, n)) = 1)))

axiom qft_rev_lineqtspec4 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  n)) -> (binary_l(x, n) -> (binary_l(y, 1) ->
  (basis_ket1(qft_rev_line(t1, n), x, y,
  i) = (if (i = t1) then (y[0]) else (x[i])))))))))

axiom qft_rev_lineqtspec5 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (binary_l(y, 1) -> (ang_ind1(qft_rev_line(t1, n), x,
  y) = infix_sldtsl((-ind_isum(fc689(t1, n, x, y), t1, n)), n)))))))

logic qft_rev_be : int -> circuit1

logic fc690 : int, (int,int) farray, (int,int) farray,
  int -> (int,int) farray

logic fc691 : int, (int,int) farray, (int,int) farray -> (int,int) farray

axiom fcqtdef693 :
  (forall n:int. forall x:(int,int) farray. forall y:(int,int) farray.
  forall l:int. forall k:int. ((fc690(n, x, y,
  l)[k]) = (((x[k]) * (y[l])) * power(2, (((n - k) - 1) + l)))))

axiom fcqtdef694 :
  (forall n:int. forall x:(int,int) farray. forall y:(int,int) farray.
  forall l:int. ((fc691(n, x, y)[l]) = (-ind_isum(fc690(n, x, y, l), l, n))))

axiom qft_rev_beqtspec :
  (forall n:int. ((0 <  n) ->
  (size1(qft_rev_be(n)) <= ((cont_size1 * ind_isum(identity2, 0, n)) + n))))

axiom qft_rev_beqtspec1 :
  (forall n:int. ((0 <  n) -> (ancillas1(qft_rev_be(n)) = 0)))

axiom qft_rev_beqtspec2 :
  (forall n:int. ((0 <  n) -> (width1(qft_rev_be(n)) = n)))

axiom qft_rev_beqtspec3 :
  (forall n:int. ((0 <  n) -> (range1(qft_rev_be(n)) = n)))

axiom qft_rev_beqtspec4 :
  (forall n:int. ((0 <  n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= i) and (i <  n)) -> (binary_l(x, n) -> (binary_l(y, n) ->
  (basis_ket1(qft_rev_be(n), x, y, i) = (y[i]))))))))

axiom qft_rev_beqtspec5 :
  (forall n:int. ((0 <  n) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (binary_l(y, n) -> (ang_ind1(qft_rev_be(n), x,
  y) = infix_sldtsl(ind_isum(fc691(n, x, y), 0, n), n)))))))

logic qft_rev_coeff : bitvec, bitvec, int -> complex

axiom qft_rev_coeffqtdef :
  (forall x:bitvec. forall y:bitvec. forall n:int. ((0 <  n) ->
  (qft_rev_coeff(x, y,
  n) = ang_exp(real_to_ang(infix_asdt(infix_asdt(i_to_c((-bv_to_int(x))),
  i_to_c(bv_to_int(bv_inversion(y)))), pow_inv_2(n)))))))

logic fc692 : bitvec, bitvec, int, int -> (int,int) farray

logic fc693 : bitvec, bitvec, int -> (int,int) farray

axiom fcqtdef695 :
  (forall x:bitvec. forall y:bitvec. forall n:int. forall l:int.
  forall k:int. ((fc692(x, y, n,
  l)[k]) = (((value(x)[k]) * (value(y)[l])) * power(2,
  (((n - k) - 1) + l)))))

axiom fcqtdef696 :
  (forall x:bitvec. forall y:bitvec. forall n:int. forall l:int. ((fc693(x,
  y, n)[l]) = (-ind_isum(fc692(x, y, n, l), l, n))))

axiom qft_rev_coeffqtspec :
  (forall x:bitvec. forall y:bitvec. forall n:int. ((0 <  n) ->
  ((length(x) = n) -> ((length(y) = n) -> (qft_rev_coeff(x, y,
  n) = ang_exp(infix_sldtsl(ind_isum(fc693(x, y, n), 0, n), n)))))))

logic fc694 : int, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef697 :
  (forall n:int. forall x:complex matrix. forall y:bitvec. ((fc694(n,
  x)[y]) = infix_asdtdt(qft_rev_coeff(ket_to_bv(x), y, n), bv_to_ket(y))))

axiom path_sem_rev_qft_unit_be :
  (forall n:int. ((0 <  n) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (path_sem1(qft_rev_be(n), x) = infix_asdtdt(pow_inv_sqrt_2(n),
  ket_sum_l(n_bvs(n), fc694(n, x), n))))))))

logic int_qft_rev_coeff : int, int, int -> complex

axiom int_qft_rev_coeffqtdef :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) ->
  (int_qft_rev_coeff(i, j,
  n) = ang_exp(real_to_ang(infix_asdt(infix_asdt(i_to_c(((-i) % power(2,
  n))), i_to_c(int_bit_inversion((j % power(2, n)), n))), pow_inv_2(n)))))))

axiom int_qft_rev_coeffqtspec :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) ->
  (int_qft_rev_coeff(i, j,
  n) = ang_exp(real_to_ang(infix_asdt(infix_asdt(i_to_c((-(i % power(2,
  n)))), i_to_c(int_bit_inversion((j % power(2, n)), n))), pow_inv_2(n)))))))

axiom int_qft_rev_coeffqtspec1 :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) ->
  (int_qft_rev_coeff(i, j, n) = qft_rev_coeff(int_to_bv((i % power(2, n)),
  n), int_to_bv((j % power(2, n)), n), n))))

axiom qft_rev_coeff_int_to_ang :
  (forall x:bitvec. forall y:bitvec. forall n:int. ((0 <  n) ->
  ((length(x) = n) -> ((length(y) = n) -> (qft_rev_coeff(x, y,
  n) = ang_exp(infix_sldtsl(((-bv_to_int(x)) * bv_to_int(bv_inversion(y))),
  n)))))))

logic fc695 : int, int -> (bitvec,complex matrix) farray

axiom fcqtdef698 :
  (forall i:int. forall n:int. forall y:bitvec. ((fc695(i,
  n)[y]) = infix_asdtdt(qft_rev_coeff(int_to_bv(i, n), y, n), bv_to_ket(y))))

axiom path_sem_rev_qft_ket_be :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (path_sem1(qft_rev_be(n), ket(n,
  i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc695(i, n),
  n))))))

axiom get_path_sem_rev_qft_ket_be :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= j) and (j <  power(2, n))) ->
  (get(path_sem1(qft_rev_be(n), ket(n, i)), j,
  0) = infix_asdt(pow_inv_sqrt_2(n), qft_rev_coeff(int_to_bv(i, n),
  int_to_bv(j, n), n)))))))

logic fc696 : int, int -> (bitvec,complex matrix) farray

axiom fcqtdef699 :
  (forall i:int. forall n:int. forall y:bitvec. ((fc696(i,
  n)[y]) = infix_asdtdt(int_qft_rev_coeff(i, bv_to_int(y), n),
  bv_to_ket(y))))

axiom path_sem_rev_qft_ket_ind_be :
  (forall i:int. forall n:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (path_sem1(qft_rev_be(n), ket(n,
  i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc696(i, n),
  n))))))

logic fc697 : int, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef700 :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((fc697(n,
  x)[y]) = infix_asdtdt(qft_rev_coeff(x, y, n), bv_to_ket(y))))

axiom path_sem_rev_qft_bv_be :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem1(qft_rev_be(n),
  bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n),
  fc697(n, x), n)))))))

axiom int_qft_rev_coeff_expo :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) ->
  (int_qft_rev_coeff(i, j,
  n) = cpower(ang_exp(real_to_ang(infix_asdt(i_to_c((-(i % power(2, n)))),
  pow_inv_2(n)))), int_bit_inversion((j % power(2, n)), n)))))

logic qft_rev : int -> circuit1

axiom qft_revqtdef :
  (forall n:int. ((0 <  n) -> ((n = 1) -> (qft_rev(n) = qft_rev_be(n)))))

axiom qft_revqtdef1 :
  (forall n:int. ((0 <  n) -> ((not (n = 1)) -> ((n = 2) ->
  (qft_rev(n) = infix_mnmn(qft_rev_be(n), bricks_swap))))))

axiom qft_revqtdef2 :
  (forall n:int. ((0 <  n) -> ((not (n = 1)) -> ((not (n = 2)) ->
  (qft_rev(n) = infix_mnmn(qft_rev_be(n), permutation_circuit1(n,
  (infix_mn_closure[(n - 1)]))))))))

logic fc698 : int, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef701 :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((fc698(n,
  x)[y]) = infix_asdtdt(qft_rev_coeff(x, bv_inversion(y), n), bv_to_ket(y))))

axiom qft_revqtspec :
  (forall n:int. ((0 <  n) -> (size1(qft_rev(n)) <= polysquare(n, cont_size1,
  0, 0))))

axiom qft_revqtspec1 :
  (forall n:int. ((0 <  n) -> (ancillas1(qft_rev(n)) = 0)))

axiom qft_revqtspec2 : (forall n:int. ((0 <  n) -> (width1(qft_rev(n)) = n)))

axiom qft_revqtspec3 :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem1(qft_rev(n),
  bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n),
  fc698(n, x), n)))))))

axiom qft_revqtspec4 :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec.
  (forall i:int. ((length(x) = n) -> (((0 <= i) and (i <  power(2, n))) ->
  (get(path_sem1(qft_rev(n), bv_to_ket(x)), i,
  0) = infix_asdt(pow_inv_sqrt_2(n), qft_rev_coeff(x,
  bv_inversion(int_to_bv(i, n)), n)))))))))

predicate infix_lseqgt(c: circuit1, cqt: circuit1) =
  ((width1(c) = width1(cqt)) and
  (forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(c, x) = path_sem_basis1(cqt,
  x))))))

axiom set_equiv_circuits_basis :
  (forall c:circuit1. forall cqt:circuit1. ((width1(c) = width1(cqt)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
   (is_a_ket_basis_elt(x) -> (path_sem_basis1(c, x) = path_sem_basis1(cqt,
   x))))) ->
  infix_lseqgt(c, cqt))))

axiom set_equiv_circuits_bv :
  (forall c:circuit1. forall cqt:circuit1. ((width1(c) = width1(cqt)) ->
  ((forall x:bitvec. ((length(x) = width1(c)) -> (path_sem1(c,
   bv_to_ket(x)) = path_sem1(cqt, bv_to_ket(x))))) ->
  infix_lseqgt(c, cqt))))

axiom set_equiv_circuits :
  (forall c:circuit1. forall cqt:circuit1. ((width1(c) = width1(cqt)) ->
  ((forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
   (is_a_ket_basis_elt(x) -> (path_sem1(c, x) = path_sem1(cqt, x))))) ->
  infix_lseqgt(c, cqt))))

axiom set_equiv_circuits_path_sem :
  (forall c:circuit1. forall cqt:circuit1. ((width1(c) = width1(cqt)) ->
  ((range1(c) = range1(cqt)) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(c)) -> (binary_l(y, range1(c)) -> (ang_ind1(c, x,
   y) = ang_ind1(cqt, x, y))))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(c)) -> (binary_l(y, range1(c)) -> (((0 <= i) and
   (i <  width1(c))) -> (basis_ket1(c, x, y, i) = basis_ket1(cqt, x, y,
   i)))))) ->
  infix_lseqgt(c, cqt))))))

axiom get_equiv_circuits_basis :
  (forall c1:circuit1. forall c2:circuit1. forall x:complex matrix.
  (infix_lseqgt(c1, c2) -> (is_a_ket_l(x, width1(c1)) ->
  (is_a_ket_basis_elt(x) -> (path_sem_basis1(c1, x) = path_sem_basis1(c2,
  x))))))

axiom get_equiv_circuits :
  (forall c1:circuit1. forall c2:circuit1. forall x:complex matrix.
  (infix_lseqgt(c1, c2) -> (is_a_ket_l(x, width1(c1)) -> (path_sem1(c1,
  x) = path_sem1(c2, x)))))

axiom get_correct_path_sum_equiv :
  (forall c1:circuit1. forall c2:circuit1. forall h:pps. (infix_lseqgt(c1,
  c2) -> (correct_path_sum(c1, h) -> correct_path_sum(c2, h))))

axiom get_equiv_circuits_width :
  (forall c1:circuit1. forall c2:circuit1. (infix_lseqgt(c1, c2) ->
  (width1(c1) = width1(c2))))

axiom refl_circuit_equiv :
  (forall c:circuit1. forall cqt:circuit1. ((c = cqt) -> infix_lseqgt(c,
  cqt)))

axiom sym_circuit_equiv :
  (forall c:circuit1. forall cqt:circuit1. (infix_lseqgt(c, cqt) ->
  infix_lseqgt(cqt, c)))

axiom transitive_circuit_equiv :
  (forall c:circuit1. forall cqt:circuit1. forall cqtqt:circuit1.
  (infix_lseqgt(c, cqt) -> (infix_lseqgt(cqt, cqtqt) -> infix_lseqgt(c,
  cqtqt))))

axiom sequence_assoc :
  (forall c:circuit1. forall cqt:circuit1. forall cqtqt:circuit1.
  (((width1(c) = width1(cqt)) and (width1(cqt) = width1(cqtqt))) ->
  infix_lseqgt(infix_mnmn(infix_mnmn(c, cqt), cqtqt), infix_mnmn(c,
  infix_mnmn(cqt, cqtqt)))))

axiom parallel_assoc :
  (forall c:circuit1. forall cqt:circuit1. forall cqtqt:circuit1.
  (((width1(c) = width1(cqt)) and (width1(cqt) = width1(cqtqt))) ->
  infix_lseqgt(infix_slsl(infix_slsl(c, cqt), cqtqt), infix_slsl(c,
  infix_slsl(cqt, cqtqt)))))

axiom sequence_equiv :
  (forall c1:circuit1. forall c2:circuit1. forall c3:circuit1.
  forall c4:circuit1. (infix_lseqgt(c1, c2) -> (infix_lseqgt(c3, c4) ->
  ((width1(c1) = width1(c3)) -> infix_lseqgt(infix_mnmn(c1, c3),
  infix_mnmn(c2, c4))))))

axiom parallel_equiv :
  (forall c1:circuit1. forall c2:circuit1. forall c3:circuit1.
  forall c4:circuit1. (infix_lseqgt(c1, c2) -> (infix_lseqgt(c3, c4) ->
  infix_lseqgt(infix_slsl(c1, c3), infix_slsl(c2, c4)))))

axiom place_equiv :
  (forall c:circuit1. forall cqt:circuit1. forall k:int. forall n:int.
  forall kqt:int. forall nqt:int. ((0 <= k) -> (((width1(c) + k) <= n) ->
  (infix_lseqgt(c, cqt) -> ((k = kqt) -> ((n = nqt) -> infix_lseqgt(place1(c,
  k, n), place1(cqt, kqt, nqt))))))))

axiom cont_equiv :
  (forall c:circuit1. forall cqt:circuit1. forall co:int. forall k:int.
  forall n:int. forall coqt:int. forall kqt:int. forall nqt:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (infix_lseqgt(c, cqt) ->
  ((co = coqt) -> ((k = kqt) -> ((n = nqt) -> infix_lseqgt(cont1(c, co, k,
  n), cont1(cqt, coqt, kqt, nqt))))))))))

function remove_parallel(c: circuit1, cqt: circuit1) : circuit1 =
  infix_mnmn(place1(c, 0, (width1(c) + width1(cqt))), place1(cqt, width1(c),
  (width1(c) + width1(cqt))))

axiom remove_parallelqtspec :
  (forall c:circuit1. forall cqt:circuit1. infix_lseqgt(remove_parallel(c,
  cqt), infix_slsl(c, cqt)))

axiom par_seq_commut :
  (forall a:circuit1. forall b:circuit1. forall c:circuit1.
  forall d:circuit1. ((width1(a) = width1(c)) -> ((width1(b) = width1(d)) ->
  infix_lseqgt(infix_mnmn(infix_slsl(a, b), infix_slsl(c, d)),
  infix_slsl(infix_mnmn(a, c), infix_mnmn(b, d))))))

axiom with_permutation_equiv :
  (forall c:circuit1. forall d:circuit1. forall f:(int,int) farray.
  (infix_lseqgt(c, d) -> (p_bijective(f, to_fset(0, width1(c)), to_fset(0,
  width1(c))) -> infix_lseqgt(with_permutation1(c, f), with_permutation1(d,
  f)))))

axiom insert_qbits_equiv :
  (forall c:circuit1. forall d:circuit1. forall k:int. forall n:int.
  forall i:int. ((width1(c) = n) -> (((0 <= k) and (k <  n)) -> ((0 <  i) ->
  (infix_lseqgt(c, d) -> infix_lseqgt(insert_qbits1(c, k, n, i),
  insert_qbits1(d, k, n, i)))))))

logic seq_flat : circuit1, circuit1 -> circuit1

axiom seq_flatqtdef :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) -> (seq_flat(d, e) = infix_mnmn(d,
  e))))))

axiom seq_flatqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) -> (size1(seq_flat(d,
  e)) = (size1(d) + size1(e)))))))

axiom seq_flatqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) -> (ancillas1(seq_flat(d,
  e)) = max(ancillas1(d), ancillas1(e)))))))

axiom seq_flatqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) -> (pre1(seq_flat(d,
  e)) = Sequence1(pre1(d), pre1(e)))))))

axiom seq_flatqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, width1(d)) -> (((0 <= i) and
  (i <  width1(d))) -> (basis_ket1(seq_flat(d, e), x, y, i) = basis_ket1(e,
  (((basis_ket_closure1[d])[x])[y]), y, i))))))))))

axiom seq_flatqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) -> (width1(seq_flat(d,
  e)) = width1(d))))))

axiom seq_flatqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) -> (range1(seq_flat(d, e)) = 0)))))

axiom seq_flatqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> ((range1(e) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(d)) -> (ang_ind1(seq_flat(d, e), x, y) = ang_add(ang_ind1(d, x, y),
  ang_ind1(e, (((basis_ket_closure1[d])[x])[y]), y)))))))))

logic cont_flat : circuit1, int, int, int -> circuit1

axiom cont_flatqtdef :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) -> ((range1(c) = 0) ->
  (cont_flat(c, co, t1, n) = cont1(c, co, t1, n)))))))

logic fc699 : int, (int,int) farray -> (int,int) farray

logic fc700 : int, (int,int) farray -> (int,int) farray

axiom fcqtdef702 :
  (forall t1:int. forall x:(int,int) farray. forall j:int. ((fc699(t1,
  x)[j]) = (x[(j + t1)])))

axiom fcqtdef703 :
  (forall t1:int. forall x:(int,int) farray. forall j:int. ((fc700(t1,
  x)[j]) = (x[(j + t1)])))

axiom cont_flatqtspec :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) -> ((range1(c) = 0) ->
  (ancillas1(cont_flat(c, co, t1, n)) = ancillas1(c)))))))

axiom cont_flatqtspec1 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) -> ((range1(c) = 0) ->
  (size1(cont_flat(c, co, t1, n)) <= (cont_size1 * size1(c))))))))

axiom cont_flatqtspec2 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) -> ((range1(c) = 0) ->
  (pre1(cont_flat(c, co, t1, n)) = Cont(pre1(c), co, t1, n)))))))

axiom cont_flatqtspec3 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) -> ((range1(c) = 0) ->
  (width1(cont_flat(c, co, t1, n)) = n))))))

axiom cont_flatqtspec4 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) -> ((range1(c) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, width1(c)) -> (((0 <= i) and
  (i <  width1(c))) -> (basis_ket1(cont_flat(c, co, t1, n), x, y,
  i) = (if (((x[co]) = 1) and ((t1 <= i) and
  (i <  (t1 + width1(c))))) then basis_ket1(c, fc699(t1, x), y,
  (i - t1)) else (x[i]))))))))))))

axiom cont_flatqtspec5 :
  (forall c:circuit1. forall co:int. forall t1:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= t1) and (t1 <= (n - width1(c)))) ->
  (((t1 <= co) -> ((t1 + width1(c)) <= co)) -> ((range1(c) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(c)) -> (ang_ind1(cont_flat(c, co, t1, n), x,
  y) = ang_mult_int(ang_ind1(c, fc700(t1, x), y), (x[co]))))))))))

logic seq_flat_right : circuit1, circuit1 -> circuit1

axiom seq_flat_rightqtdef :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) -> (seq_flat_right(d, e) = infix_mnmn(d, e)))))

logic fc701 : circuit1, (int,int) farray -> (int,int) farray

logic fc702 : circuit1, (int,int) farray -> (int,int) farray

axiom fcqtdef704 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc701(d,
  y)[k]) = (y[(k + range1(d))])))

axiom fcqtdef705 :
  (forall d:circuit1. forall y:(int,int) farray. forall k:int. ((fc702(d,
  y)[k]) = (y[(k + range1(d))])))

axiom seq_flat_rightqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) -> (size1(seq_flat_right(d,
  e)) = (size1(d) + size1(e))))))

axiom seq_flat_rightqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) -> (ancillas1(seq_flat_right(d, e)) = max(ancillas1(d),
  ancillas1(e))))))

axiom seq_flat_rightqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) -> (pre1(seq_flat_right(d, e)) = Sequence1(pre1(d),
  pre1(e))))))

axiom seq_flat_rightqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) -> (width1(seq_flat_right(d, e)) = width1(d)))))

axiom seq_flat_rightqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) -> (range1(seq_flat_right(d, e)) = range1(d)))))

axiom seq_flat_rightqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  width1(d))) -> (binary_l(x,
  width1(seq_flat_right(d, e))) -> (basis_ket1(seq_flat_right(d, e), x, y,
  i) = basis_ket1(e, (((basis_ket_closure1[d])[x])[y]), fc701(d, y), i)))))))))

axiom seq_flat_rightqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(seq_flat_right(d, e))) -> (ang_ind1(seq_flat_right(d, e), x,
  y) = ang_add(ang_ind1(d, x, y), ang_ind1(e,
  (((basis_ket_closure1[d])[x])[y]), fc702(d, y)))))))))

logic seq_flat_left : circuit1, circuit1 -> circuit1

axiom seq_flat_leftqtdef :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> (seq_flat_left(d, e) = infix_mnmn(d, e)))))

axiom seq_flat_leftqtspec :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> (size1(seq_flat_left(d, e)) = (size1(d) + size1(e))))))

axiom seq_flat_leftqtspec1 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> (ancillas1(seq_flat_left(d, e)) = max(ancillas1(d),
  ancillas1(e))))))

axiom seq_flat_leftqtspec2 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> (pre1(seq_flat_left(d, e)) = Sequence1(pre1(d),
  pre1(e))))))

axiom seq_flat_leftqtspec3 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> (width1(seq_flat_left(d, e)) = width1(d)))))

axiom seq_flat_leftqtspec4 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) -> (range1(seq_flat_left(d, e)) = range1(e)))))

axiom seq_flat_leftqtspec5 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (((0 <= i) and (i <  width1(d))) -> (binary_l(x,
  width1(d)) -> (basis_ket1(seq_flat_left(d, e), x, y, i) = basis_ket1(e,
  (((basis_ket_closure1[d])[x])[y]), y, i)))))))))

axiom seq_flat_leftqtspec6 :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(d) = 0) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
  width1(seq_flat_left(d, e))) -> (ang_ind1(seq_flat_left(d, e), x,
  y) = ang_add(ang_ind1(d, x, y), ang_ind1(e,
  (((basis_ket_closure1[d])[x])[y]), y))))))))

axiom path_sem_flat :
  (forall d:circuit1. forall x:bitvec. ((length(x) = width1(d)) ->
  ((range1(d) = 0) -> (path_sem1(d,
  bv_to_ket(x)) = infix_asdtdt(ang_exp(ang_ind1(d, value(x), identity2)),
  bv_to_ket(make_bv((((basis_ket_closure1[d])[value(x)])[identity2]),
  width1(d))))))))

axiom path_sem_flat_gen :
  (forall d:circuit1. ((range1(d) = 0) ->
  (forall x:bitvec. ((length(x) = width1(d)) -> (path_sem1(d,
  bv_to_ket(x)) = infix_asdtdt(ang_exp(ang_ind1(d, value(x), identity2)),
  bv_to_ket(make_bv((((basis_ket_closure1[d])[value(x)])[identity2]),
  width1(d)))))))))

axiom circuit_equiv_by_unwire :
  (forall c:circuit1. forall d:circuit1. ((unwire(c) = unwire(d)) ->
  infix_lseqgt(c, d)))

axiom circuit_equiv_by_unwire_equiv :
  (forall c:circuit1. forall d:circuit1.
  ((forall x:complex matrix. (is_a_ket_basis_elt(x) -> (is_a_ket_l(x,
   width1(c)) -> (path_sem(unwire(c), x) = path_sem(unwire(d), x))))) ->
  ((width1(c) = width1(d)) -> infix_lseqgt(c, d))))

axiom place_place2 :
  (forall c:circuit1. forall k:int. forall kqt:int. forall n:int.
  forall nqt:int. ((0 <= k) -> (((width1(c) + k) <= n) -> ((0 <= kqt) ->
  (((n + kqt) <= nqt) -> infix_lseqgt(place1(place1(c, k, n), kqt, nqt),
  place1(c, (k + kqt), nqt)))))))

axiom place_cont :
  (forall c:circuit1. forall co:int. forall k:int. forall kqt:int.
  forall n:int. forall nqt:int. ((0 <= k) -> (((0 <= co) and (co <  n)) ->
  (((width1(c) + k) <= n) -> ((0 <= kqt) -> (((n + kqt) <= nqt) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> infix_lseqgt(place1(cont1(c, co,
  k, n), kqt, nqt), cont1(c, (co + kqt), (k + kqt), nqt)))))))))

axiom cont_place :
  (forall c:circuit1. forall co:int. forall k:int. forall kqt:int.
  forall n:int. forall nqt:int. ((0 <= k) -> (((width1(c) + k) <= n) ->
  (((0 <= co) and (co <  nqt)) -> ((0 <= kqt) -> (((n + kqt) <= nqt) ->
  (((kqt <= co) -> ((kqt + n) <= co)) -> infix_lseqgt(cont1(place1(c, k, n),
  co, kqt, nqt), cont1(c, co, (k + kqt), nqt)))))))))

axiom cont_sequence_comm :
  (forall co:int. forall k:int. forall n:int. forall c:circuit1.
  forall d:circuit1. ((0 <= k) -> (((width1(c) + k) <= n) -> (((k <= co) ->
  ((k + width1(c)) <= co)) -> ((width1(c) = width1(d)) -> (((0 <= co) and
  (co <  n)) -> infix_lseqgt(cont1(infix_mnmn(c, d), co, k, n),
  infix_mnmn(cont1(c, co, k, n), cont1(d, co, k, n)))))))))

axiom cont_sequence :
  (forall co:int. forall k:int. forall n:int. forall c:circuit1.
  forall d:circuit1. ((0 <= k) -> (((width1(c) + k) <= n) -> (((k <= co) ->
  ((k + n) <= co)) -> ((width1(c) = width1(d)) -> (((0 <= co) and
  (co <  n)) -> infix_lseqgt(infix_mnmn(cont1(c, co, k, n), cont1(d, co, k,
  n)), cont1(infix_mnmn(c, d), co, k, n))))))))

axiom place_sequence_comm :
  (forall k:int. forall n:int. forall c:circuit1. forall d:circuit1.
  ((0 <= k) -> (((width1(c) + k) <= n) -> ((width1(c) = width1(d)) ->
  infix_lseqgt(place1(infix_mnmn(c, d), k, n), infix_mnmn(place1(c, k, n),
  place1(d, k, n)))))))

axiom place_sequence :
  (forall k:int. forall n:int. forall c:circuit1. forall d:circuit1.
  ((0 <= k) -> (((width1(c) + k) <= n) -> ((width1(c) = width1(d)) ->
  infix_lseqgt(infix_mnmn(place1(c, k, n), place1(d, k, n)),
  place1(infix_mnmn(c, d), k, n))))))

axiom hadamard_zero : (path_sem1(hadamard1, ket(1,
  0)) = pps_apply(pps_hadamard, ket(1, 0)))

axiom hadamard_one : (path_sem1(hadamard1, ket(1,
  1)) = pps_apply(pps_hadamard, ket(1, 1)))

axiom hadamard_plus : (path_sem1(hadamard1, pps_apply(pps_hadamard, ket(1,
  0))) = ket(1, 0))

axiom hadamard_minus : (path_sem1(hadamard1, pps_apply(pps_hadamard, ket(1,
  1))) = ket(1, 1))

axiom xx_zero : (path_sem1(xx1, ket(1, 0)) = ket(1, 1))

axiom xx_one : (path_sem1(xx1, ket(1, 1)) = ket(1, 0))

axiom xx_plus : (path_sem1(xx1, pps_apply(pps_hadamard, ket(1,
  0))) = pps_apply(pps_hadamard, ket(1, 0)))

axiom xx_minus : (path_sem1(xx1, pps_apply(pps_hadamard, ket(1,
  1))) = infix_asdtdt(prefix_mndt(c_one), pps_apply(pps_hadamard, ket(1,
  1))))

axiom xx_invol :
  (forall x:complex matrix. (is_a_ket_l(x, 1) -> (path_sem1(xx1,
  path_sem1(xx1, x)) = x)))

axiom zz_zero : (path_sem1(zz1, ket(1, 0)) = ket(1, 0))

axiom zz_one : (path_sem1(zz1, ket(1, 1)) = infix_asdtdt(prefix_mndt(c_one),
  ket(1, 1)))

axiom zz_invol :
  (forall x:complex matrix. (is_a_ket_l(x, 1) -> (path_sem1(zz1,
  path_sem1(zz1, x)) = x)))

axiom zz_plus : (path_sem1(zz1, pps_apply(pps_hadamard, ket(1,
  0))) = pps_apply(pps_hadamard, ket(1, 1)))

axiom zz_minus : (path_sem1(zz1, pps_apply(pps_hadamard, ket(1,
  1))) = pps_apply(pps_hadamard, ket(1, 0)))

axiom ry_zero :
  (forall k:int. (path_sem1(ry1(k), ket(1, 0)) = ket_zero_y(k)))

axiom ry_one : (forall k:int. (path_sem1(ry1(k), ket(1, 1)) = ket_one_y(k)))

axiom yy_zero : (path_sem1(yy1, ket(1, 0)) = infix_asdtdt(im, ket_zero_y(1)))

axiom yy_one : (path_sem1(yy1, ket(1, 1)) = infix_asdtdt(im, ket_one_y(1)))

axiom ry_add_opp :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem1(ry1((-k)), path_sem1(ry1(k), x)) = x)))

axiom ry_twice :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem1(ry1(incr_abs(k)), path_sem1(ry1(incr_abs(k)),
  x)) = path_sem1(ry1(k), x))))

axiom rz_zero :
  (forall k:int. (path_sem1(rz1(k), ket(1,
  0)) = infix_asdtdt(ang_exp(infix_sldtsl((- 1), incr_abs(k))), ket(1, 0))))

axiom rz_one :
  (forall k:int. (path_sem1(rz1(k), ket(1,
  1)) = infix_asdtdt(ang_exp(infix_sldtsl(1, incr_abs(k))), ket(1, 1))))

axiom ry_inv :
  (forall k:int. forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem1(xx1, path_sem1(ry1(k), x)) = path_sem1(ry1((-k)), path_sem1(xx1,
  x)))))

axiom ry_inv_rev :
  (forall k:int. forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem1(ry1((-k)), path_sem1(xx1, x)) = path_sem1(xx1, path_sem1(ry1(k),
  x)))))

axiom rz_inv :
  (forall k:int. forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem1(xx1, path_sem1(rz1(k), x)) = path_sem1(rz1((-k)), path_sem1(xx1,
  x)))))

axiom rz_inv_rev :
  (forall k:int. forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem1(rz1((-k)), path_sem1(xx1, x)) = path_sem1(xx1, path_sem1(rz1(k),
  x)))))

axiom rzp_zero : (forall k:int. (path_sem1(rzp(k), ket(1, 0)) = ket(1, 0)))

axiom path_sem_phase :
  (forall k:int. forall x:complex matrix. (is_a_ket_l(x, 1) ->
  (path_sem1(phase1(k), x) = infix_asdtdt(ang_exp(infix_sldtsl(1, k)), x))))

axiom rzp_one :
  (forall k:int. (path_sem1(rzp(k), ket(1,
  1)) = infix_asdtdt(ang_exp(infix_sldtsl(1, k)), ket(1, 1))))

axiom rz_twice_ :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem1(rz1(incr_abs(k)), path_sem1(rz1(incr_abs(k)),
  x)) = path_sem1(rz1(k), x))))

axiom rzp_twice_ :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem1(rzp(incr_abs(k)), path_sem1(rzp(incr_abs(k)),
  x)) = path_sem1(rzp(k), x))))

axiom phase_twice_ :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem1(phase1(incr_abs(k)), path_sem1(phase1(incr_abs(k)),
  x)) = path_sem1(phase1(k), x))))

axiom hadamard_twice_ :
  (forall x:complex matrix. (is_a_ket_l(x, 1) -> (path_sem1(hadamard1,
  path_sem1(hadamard1, x)) = x)))

axiom phase_comm :
  (forall k:int. forall c:circuit1. ((width1(c) = 1) ->
  infix_lseqgt(infix_mnmn(phase1(k), c), infix_mnmn(c, phase1(k)))))

axiom comm_phase :
  (forall k:int. forall c:circuit1. ((width1(c) = 1) ->
  infix_lseqgt(infix_mnmn(c, phase1(k)), infix_mnmn(phase1(k), c))))

logic rewrite_cnot : int, int, int -> circuit1

axiom rewrite_cnotqtdef :
  (forall co:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= co) and (co <  n)) -> ((not (t1 = co)) -> (rewrite_cnot(co, t1,
  n) = cont1(xx1, co, t1, n))))))

axiom rewrite_cnotqtspec :
  (forall co:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (ancillas1(rewrite_cnot(co, t1, n)) = 0)))))

axiom rewrite_cnotqtspec1 :
  (forall co:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  infix_lseqgt(rewrite_cnot(co, t1, n), cnot1(co, t1, n))))))

function rz_not(k: int) : circuit1 = infix_mnmn(infix_mnmn(xx1, rz1(k)), xx1)

axiom rz_notqtspec : (forall k:int. (ancillas1(rz_not(k)) = 0))

axiom rz_notqtspec1 : (forall k:int. infix_lseqgt(rz_not(k), rz1((-k))))

function ry_not(k: int) : circuit1 = infix_mnmn(infix_mnmn(xx1, ry1(k)), xx1)

axiom ry_notqtspec : (forall k:int. (ancillas1(ry_not(k)) = 0))

axiom ry_notqtspec1 : (forall k:int. infix_lseqgt(ry_not(k), ry1((-k))))

function rewrite_rz(k: int) : circuit1 = infix_mnmn(phase1((-incr_abs(k))),
  rzp(k))

axiom rewrite_rzqtspec : (forall k:int. (ancillas1(rewrite_rz(k)) = 0))

axiom rewrite_rzqtspec1 : (forall k:int. infix_lseqgt(rewrite_rz(k), rz1(k)))

function rewrite_rzp(k: int) : circuit1 = infix_mnmn(phase1(incr_abs(k)),
  rz1(k))

axiom rewrite_rzpqtspec : (forall k:int. (ancillas1(rewrite_rzp(k)) = 0))

axiom rewrite_rzpqtspec1 :
  (forall k:int. infix_lseqgt(rewrite_rzp(k), rzp(k)))

function rewrite_rx(k: int) : circuit1 = infix_mnmn(infix_mnmn(hadamard1,
  rz1(k)), hadamard1)

axiom rewrite_rxqtspec : (forall k:int. (ancillas1(rewrite_rx(k)) = 0))

axiom rewrite_rxqtspec1 : (forall k:int. infix_lseqgt(rewrite_rx(k), rx1(k)))

function rewrite_ry(k: int) : circuit1 = infix_mnmn(infix_mnmn(rzp((- 2)),
  rx1(k)), rzp(2))

axiom rewrite_ryqtspec : (forall k:int. (ancillas1(rewrite_ry(k)) = 0))

axiom rewrite_ryqtspec1 : (forall k:int. infix_lseqgt(rewrite_ry(k), ry1(k)))

function rewrite_ry_with_z(k: int) : circuit1 =
  infix_mnmn(infix_mnmn(rzp((- 2)), rewrite_rx(k)), rzp(2))

axiom rewrite_ry_with_zqtspec :
  (forall k:int. (ancillas1(rewrite_ry_with_z(k)) = 0))

axiom rewrite_ry_with_zqtspec1 :
  (forall k:int. infix_lseqgt(rewrite_ry_with_z(k), ry1(k)))

axiom rewrite_sqtspec : (ancillas1(rzp(2)) = 0)

axiom rewrite_sqtspec1 : infix_lseqgt(rzp(2), s)

axiom rewrite_tqtspec : (ancillas1(rzp(3)) = 0)

axiom rewrite_tqtspec1 : infix_lseqgt(rzp(3), t)

axiom rewrite_zzqtspec : (ancillas1(rzp(1)) = 0)

axiom rewrite_zzqtspec1 : infix_lseqgt(rzp(1), zz1)

axiom rewrite_xxqtspec : (ancillas1(infix_mnmn(infix_mnmn(hadamard1, zz1),
  hadamard1)) = 0)

axiom rewrite_xxqtspec1 : infix_lseqgt(infix_mnmn(infix_mnmn(hadamard1, zz1),
  hadamard1), xx1)

axiom rewrite_yyqtspec : (ancillas1(infix_mnmn(phase1(2), ry1(1))) = 0)

axiom rewrite_yyqtspec1 : infix_lseqgt(infix_mnmn(phase1(2), ry1(1)), yy1)

axiom rewrite_hadamardqtspec : (ancillas1(infix_mnmn(ry1(2), xx1)) = 0)

axiom rewrite_hadamardqtspec1 : infix_lseqgt(infix_mnmn(ry1(2), xx1),
  hadamard1)

logic place_hadamard_with_ry : int, int -> circuit1

axiom place_hadamard_with_ryqtdef :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (place_hadamard_with_ry(t1, n) = infix_mnmn(infix_mnmn(place1(ry1(3), t1,
  n), place1(xx1, t1, n)), place1(ry1((- 3)), t1, n)))))

axiom place_hadamard_with_ryqtspec :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (ancillas1(place_hadamard_with_ry(t1, n)) = 0)))

axiom place_hadamard_with_ryqtspec1 :
  (forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  infix_lseqgt(place_hadamard_with_ry(t1, n), place1(hadamard1, t1, n))))

logic cont_hadamard : int, int, int -> circuit1

axiom cont_hadamardqtdef :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (co = t1)) -> (cont_hadamard(co, t1,
  n) = infix_mnmn(infix_mnmn(place1(ry1(3), t1, n), cnot1(co, t1, n)),
  place1(ry1((- 3)), t1, n)))))))

axiom cont_hadamardqtspec :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (co = t1)) ->
  (ancillas1(cont_hadamard(co, t1, n)) = 0)))))

axiom cont_hadamardqtspec1 :
  (forall co:int. forall t1:int. forall n:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (co = t1)) ->
  infix_lseqgt(cont_hadamard(co, t1, n), cont1(hadamard1, co, t1, n))))))

logic cont_ry : int, int, int, int -> circuit1

axiom cont_ryqtdef :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (co = t1)) -> (cont_ry(k,
  co, t1, n) = infix_mnmn(infix_mnmn(infix_mnmn(place1(ry1(incr_abs(k)), t1,
  n), cnot1(co, t1, n)), place1(ry1((-incr_abs(k))), t1, n)), cnot1(co, t1,
  n)))))))

axiom cont_ryqtspec :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (co = t1)) ->
  (ancillas1(cont_ry(k, co, t1, n)) = 0)))))

axiom cont_ryqtspec1 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (co = t1)) ->
  infix_lseqgt(cont_ry(k, co, t1, n), cont1(ry1(k), co, t1, n))))))

logic cont_rz : int, int, int, int -> circuit1

axiom cont_rzqtspec : true

axiom cont_rzqtspec1 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  infix_lseqgt(cont_rz(k, co, t1, n), cont1(rz1(k), co, t1, n))))))

axiom cont_rzqtspec2 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (ancillas1(cont_rz(k, co, t1, n)) = 0)))))

axiom cont_rzqtspec3 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (width1(cont_rz(k, co, t1, n)) = n)))))

axiom cont_rzqtspec4 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (range1(cont_rz(k, co, t1, n)) = 0)))))

axiom cont_rzqtspec5 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, n) -> (((0 <= i) and (i <  n)) ->
  (basis_ket1(cont_rz(k, co, t1, n), x, y, i) = (x[i]))))))))))

axiom cont_rzqtspec6 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cont_rz(k, co, t1, n), x, y) = phase_inv_(((x[t1]) - 1),
  infix_sldtsl((x[co]), incr_abs(k))))))))))

axiom cont_rzqtspec7 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) -> (cont_rz(k,
  co, t1, n) = infix_mnmn(infix_mnmn(infix_mnmn(place1(rz1(incr_abs(k)), t1,
  n), cnot1(co, t1, n)), place1(rz1((-incr_abs(k))), t1, n)), cnot1(co, t1,
  n)))))))

logic cont_phase : int, int, int, int -> circuit1

axiom cont_phaseqtdef :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (cont_phase(k, co, t1, n) = place_diag(rzp(k), co, n))))))

axiom cont_phaseqtspec :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (ancillas1(cont_phase(k, co, t1, n)) = 0)))))

axiom cont_phaseqtspec1 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  infix_lseqgt(cont_phase(k, co, t1, n), cont1(phase1(k), co, t1, n))))))

axiom cont_phaseqtspec2 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (width1(cont_phase(k, co, t1, n)) = n)))))

axiom cont_phaseqtspec3 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (range1(cont_phase(k, co, t1, n)) = 0)))))

axiom cont_phaseqtspec4 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, n) -> (((0 <= i) and (i <  n)) ->
  (basis_ket1(cont_phase(k, co, t1, n), x, y, i) = (x[i]))))))))))

axiom cont_phaseqtspec5 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cont_phase(k, co, t1, n), x, y) = infix_sldtsl((x[co]), k))))))))

logic cont_rzp : int, int, int, int -> circuit1

axiom cont_rzpqtdef :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) -> (cont_rzp(k, co, t1,
  n) = seq_diag(cont_phase(incr_abs(k), co, t1, n), cont_rz(k, co, t1,
  n)))))))

axiom cont_rzpqtspec :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) -> (ancillas1(cont_rzp(k, co, t1, n)) = 0)))))

axiom cont_rzpqtspec1 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) -> (width1(cont_rzp(k, co, t1, n)) = n)))))

axiom cont_rzpqtspec2 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) -> (range1(cont_rzp(k, co, t1, n)) = 0)))))

axiom cont_rzpqtspec3 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, n) -> (((0 <= i) and (i <  n)) ->
  (basis_ket1(cont_rzp(k, co, t1, n), x, y, i) = (x[i]))))))))))

axiom cont_rzpqtspec4 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cont_rzp(k, co, t1, n), x, y) = infix_sldtsl(((x[co]) * (x[t1])),
  k))))))))

axiom cont_rzpqtspec5 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <  n)) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) -> infix_lseqgt(cont_rzp(k, co, t1, n), cont1(rzp(k), co,
  t1, n))))))

logic cont_xor_rz : int, int, int, int, int -> circuit1

axiom cont_xor_rzqtdef :
  (forall k:int. forall co1:int. forall co2:int. forall t1:int. forall n:int.
  (((0 <= co1) and (co1 <  n)) -> (((0 <= co2) and (co2 <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (co1 = co2)) -> ((not (co1 = t1)) ->
  ((not (t1 = co2)) -> (cont_xor_rz(k, co1, co2, t1,
  n) = seq_flat(seq_flat(cnot1(co1, co2, n), cont_rzp(k, co2, t1, n)),
  cnot1(co1, co2, n))))))))))

axiom cont_xor_rzqtspec :
  (forall k:int. forall co1:int. forall co2:int. forall t1:int. forall n:int.
  (((0 <= co1) and (co1 <  n)) -> (((0 <= co2) and (co2 <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (co1 = co2)) -> ((not (co1 = t1)) ->
  ((not (t1 = co2)) -> (ancillas1(cont_xor_rz(k, co1, co2, t1,
  n)) = 0))))))))

axiom cont_xor_rzqtspec1 :
  (forall k:int. forall co1:int. forall co2:int. forall t1:int. forall n:int.
  (((0 <= co1) and (co1 <  n)) -> (((0 <= co2) and (co2 <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (co1 = co2)) -> ((not (co1 = t1)) ->
  ((not (t1 = co2)) -> (width1(cont_xor_rz(k, co1, co2, t1, n)) = n))))))))

axiom cont_xor_rzqtspec2 :
  (forall k:int. forall co1:int. forall co2:int. forall t1:int. forall n:int.
  (((0 <= co1) and (co1 <  n)) -> (((0 <= co2) and (co2 <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (co1 = co2)) -> ((not (co1 = t1)) ->
  ((not (t1 = co2)) -> (range1(cont_xor_rz(k, co1, co2, t1, n)) = 0))))))))

axiom cont_xor_rzqtspec3 :
  (forall k:int. forall co1:int. forall co2:int. forall t1:int. forall n:int.
  (((0 <= co1) and (co1 <  n)) -> (((0 <= co2) and (co2 <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (co1 = co2)) -> ((not (co1 = t1)) ->
  ((not (t1 = co2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(cont_xor_rz(k, co1, co2, t1, n), x,
  y) = infix_sldtsl(((((x[co1]) + (x[co2])) - (2 * ((x[co1]) * (x[co2])))) * (x[t1])),
  k)))))))))))

axiom cont_xor_rzqtspec4 :
  (forall k:int. forall co1:int. forall co2:int. forall t1:int. forall n:int.
  (((0 <= co1) and (co1 <  n)) -> (((0 <= co2) and (co2 <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (co1 = co2)) -> ((not (co1 = t1)) ->
  ((not (t1 = co2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray.
  (forall i:int. (binary_l(x, n) -> (((0 <= i) and (i <  n)) ->
  (basis_ket1(cont_xor_rz(k, co1, co2, t1, n), x, y, i) = (x[i])))))))))))))

logic cont_rx : int, int, int, int -> circuit1

axiom cont_rxqtdef :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <= (n - 1))) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) -> (cont_rx(k, co, t1,
  n) = infix_mnmn(infix_mnmn(cont_hadamard(co, t1, n), cont_rz(k, co, t1,
  n)), cont_hadamard(co, t1, n)))))))

axiom cont_rxqtspec :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <= (n - 1))) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) -> (ancillas1(cont_rx(k, co, t1, n)) = 0)))))

axiom cont_rxqtspec1 :
  (forall k:int. forall co:int. forall t1:int. forall n:int. (((0 <= co) and
  (co <  n)) -> (((0 <= t1) and (t1 <= (n - 1))) -> (((t1 <= co) ->
  ((t1 + 1) <= co)) -> infix_lseqgt(cont_rx(k, co, t1, n), cont1(rx1(k), co,
  t1, n))))))

logic swap_decomp : int, int, int -> circuit1

axiom swap_decompqtdef :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (swap_decomp(t1, t2,
  n) = seq_flat_mute(seq_flat_mute(cnot1(t1, t2, n), cnot1(t2, t1, n)),
  cnot1(t1, t2, n)))))))

axiom swap_decompqtspec :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (width1(swap_decomp(t1,
  t2, n)) = n)))))

axiom swap_decompqtspec1 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  (ancillas1(swap_decomp(t1, t2, n)) = 0)))))

axiom swap_decompqtspec2 :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  infix_lseqgt(swap_decomp(t1, t2, n), swap1(t1, t2, n))))))

logic ccz1 : int, int, int, int -> circuit1

axiom cczqtdef5 :
  (forall t1:int. forall t2:int. forall t3:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= t3) and (t3 <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = t3)) -> ((not (t3 = t2)) -> (ccz1(t1, t2,
  t3, n) = seq_diag(seq_diag(cont_rzp(2, t1, t3, n), cont_rzp(2, t2, t3, n)),
  cont_xor_rz((- 2), t1, t2, t3, n))))))))))

axiom cczqtspec :
  (forall t1:int. forall t2:int. forall t3:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= t3) and (t3 <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = t3)) -> ((not (t3 = t2)) ->
  (ancillas1(ccz1(t1, t2, t3, n)) = 0))))))))

axiom cczqtspec1 :
  (forall t1:int. forall t2:int. forall t3:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= t3) and (t3 <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = t3)) -> ((not (t3 = t2)) ->
  (range1(ccz1(t1, t2, t3, n)) = 0))))))))

axiom cczqtspec2 :
  (forall t1:int. forall t2:int. forall t3:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= t3) and (t3 <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = t3)) -> ((not (t3 = t2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (binary_l(x, n) -> (((0 <= i) and (i <  n)) -> (basis_ket1(ccz1(t1, t2, t3,
  n), x, y, i) = (x[i]))))))))))))

axiom cczqtspec3 :
  (forall t1:int. forall t2:int. forall t3:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= t3) and (t3 <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = t3)) -> ((not (t3 = t2)) ->
  (width1(ccz1(t1, t2, t3, n)) = n))))))))

axiom cczqtspec4 :
  (forall t1:int. forall t2:int. forall t3:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= t3) and (t3 <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = t3)) -> ((not (t3 = t2)) ->
  (forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x, n) ->
  (ang_ind1(ccz1(t1, t2, t3, n), x,
  y) = infix_sldtsl((((x[t1]) * (x[t2])) * (x[t3])), 1)))))))))))

axiom path_sem_toffoli :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int.
  forall x:bitvec. (((0 <= c1) and (c1 <  n)) -> (((0 <= c2) and
  (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c1 = c2)) ->
  ((not (c1 = t1)) -> ((not (t1 = c2)) -> ((length(x) = n) ->
  (path_sem1(toffoli1(c1, c2, t1, n),
  bv_to_ket(x)) = (if (((value(x)[c1]) = (value(x)[c2])) and
  ((value(x)[c2]) = 1)) then path_sem1(place1(xx1, t1, n),
  bv_to_ket(x)) else bv_to_ket(x)))))))))))

axiom set_equiv_flat_mute :
  (forall d:circuit1. forall e:circuit1. ((width1(d) = width1(e)) ->
  ((range1(e) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(e, x, y) = ang_zero))) ->
  ((range1(d) = 0) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. (binary_l(x,
   width1(d)) -> (ang_ind1(d, x, y) = ang_zero))) ->
  ((forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
   (binary_l(x, width1(d)) -> (((0 <= i) and (i <  width1(d))) ->
   (basis_ket1(d, x, y, i) = basis_ket1(e, x, y, i))))) ->
  infix_lseqgt(d, e))))))))

axiom path_sem_ccz :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int.
  forall x:bitvec. (((0 <= c1) and (c1 <  n)) -> (((0 <= c2) and
  (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (c1 = c2)) ->
  ((not (c1 = t1)) -> ((not (t1 = c2)) -> ((length(x) = n) ->
  (path_sem1(ccz1(c1, c2, t1, n),
  bv_to_ket(x)) = (if (((value(x)[c1]) = (value(x)[c2])) and
  ((value(x)[c2]) = 1)) then path_sem1(place1(zz1, t1, n),
  bv_to_ket(x)) else bv_to_ket(x)))))))))))

axiom path_sem_ccz_ :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int.
  forall x:bitvec. forall y:complex matrix. (((0 <= c1) and (c1 <  n)) ->
  (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t1)) -> ((not (t1 = c2)) ->
  ((length(x) = n) -> (is_a_ket_l(y, 1) -> (path_sem1(ccz1(c1, c2, t1, n),
  kronecker(kronecker(bv_to_ket(hpart(x, t1)), y), bv_to_ket(tpart(x,
  (t1 + 1))))) = (if (((value(x)[c1]) = (value(x)[c2])) and
  ((value(x)[c2]) = 1)) then kronecker(kronecker(bv_to_ket(hpart(x, t1)),
  path_sem1(zz1, y)), bv_to_ket(tpart(x,
  (t1 + 1)))) else kronecker(kronecker(bv_to_ket(hpart(x, t1)), y),
  bv_to_ket(tpart(x, (t1 + 1)))))))))))))))

axiom basis_ket_cnot_if :
  (forall co:int. forall t1:int. forall n:int. forall x:(int,int) farray.
  forall y:(int,int) farray. forall i:int. (((0 <= co) and (co <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (t1 = co)) -> (binary_l(x, n) ->
  (((0 <= i) and (i <  n)) -> (basis_ket1(cnot1(co, t1, n), x, y,
  i) = (if ((i = t1) and
  ((x[co]) = 1)) then (if ((x[t1]) = 1) then 0 else 1) else (x[i])))))))))

axiom basis_ket_swap_if :
  (forall t1:int. forall t2:int. forall n:int. forall x:(int,int) farray.
  forall y:(int,int) farray. forall i:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (binary_l(x, n) ->
  (((0 <= i) and (i <  n)) -> (basis_ket1(swap1(t1, t2, n), x, y,
  i) = (if (i = t1) then (x[t2]) else (if (i = t2) then (x[t1]) else (x[i]))))))))))

axiom basis_ket_toffoli_if :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int.
  forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= c1) and (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and
  (t1 <  n)) -> ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  (binary_l(x, n) -> (((0 <= i) and (i <  n)) -> (basis_ket1(toffoli1(c1, c2,
  t1, n), x, y, i) = (if ((i = t1) and (((x[c1]) = 1) and
  ((x[c2]) = 1))) then (if ((x[t1]) = 1) then 0 else 1) else (x[i]))))))))))))

axiom basis_ket_fredkin_if :
  (forall c:int. forall t1:int. forall t2:int. forall n:int.
  forall x:(int,int) farray. forall y:(int,int) farray. forall i:int.
  (((0 <= t1) and (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and
  (c <  n)) -> ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  (binary_l(x, n) -> (((0 <= i) and (i <  n)) -> (basis_ket1(fredkin1(c, t1,
  t2, n), x, y, i) = (if ((i = t1) and
  ((x[c]) = 1)) then (x[t2]) else (if ((i = t2) and
  ((x[c]) = 1)) then (x[t1]) else (x[i])))))))))))))

logic toffoli_decomp : int, int, int, int -> circuit1

axiom toffoli_decompqtdef :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t1)) -> ((not (t1 = c2)) ->
  (toffoli_decomp(c1, c2, t1, n) = infix_mnmn(infix_mnmn(place1(hadamard1,
  t1, n), ccz1(c1, c2, t1, n)), place1(hadamard1, t1, n))))))))))

axiom toffoli_decompqtspec :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t1)) -> ((not (t1 = c2)) ->
  (ancillas1(toffoli_decomp(c1, c2, t1, n)) = 0))))))))

axiom toffoli_decompqtspec1 :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t1)) -> ((not (t1 = c2)) ->
  (width1(toffoli_decomp(c1, c2, t1, n)) = n))))))))

axiom toffoli_decompqtspec2 :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t1)) -> ((not (t1 = c2)) ->
  infix_lseqgt(toffoli_decomp(c1, c2, t1, n), toffoli1(c1, c2, t1, n)))))))))

logic fredkin_as_cont_swap : int, int, int, int, int, int -> circuit1

axiom fredkin_as_cont_swapqtdef :
  (forall c:int. forall ta1:int. forall ta2:int. forall k:int. forall n1:int.
  forall n2:int. (((k <= ta1) and (ta1 <  (k + n1))) -> (((k <= ta2) and
  (ta2 <  (k + n1))) -> ((not (ta1 = ta2)) -> (((k + n1) <= n2) ->
  ((0 <= k) -> (((k <= c) -> ((k + n1) <= c)) -> (((0 <= c) and (c <  n2)) ->
  (fredkin_as_cont_swap(c, ta1, ta2, k, n1,
  n2) = cont_flat_mute(swap1((ta1 - k), (ta2 - k), n1), c, k, n2))))))))))

axiom fredkin_as_cont_swapqtspec :
  (forall c:int. forall ta1:int. forall ta2:int. forall k:int. forall n1:int.
  forall n2:int. (((k <= ta1) and (ta1 <  (k + n1))) -> (((k <= ta2) and
  (ta2 <  (k + n1))) -> ((not (ta1 = ta2)) -> (((k + n1) <= n2) ->
  ((0 <= k) -> (((k <= c) -> ((k + n1) <= c)) -> (((0 <= c) and (c <  n2)) ->
  (ancillas1(fredkin_as_cont_swap(c, ta1, ta2, k, n1, n2)) = 0)))))))))

axiom fredkin_as_cont_swapqtspec1 :
  (forall c:int. forall ta1:int. forall ta2:int. forall k:int. forall n1:int.
  forall n2:int. (((k <= ta1) and (ta1 <  (k + n1))) -> (((k <= ta2) and
  (ta2 <  (k + n1))) -> ((not (ta1 = ta2)) -> (((k + n1) <= n2) ->
  ((0 <= k) -> (((k <= c) -> ((k + n1) <= c)) -> (((0 <= c) and (c <  n2)) ->
  infix_lseqgt(fredkin_as_cont_swap(c, ta1, ta2, k, n1, n2), fredkin1(c, ta1,
  ta2, n2))))))))))

logic toffoli_as_cont_cnot : int, int, int, int, int, int -> circuit1

axiom toffoli_as_cont_cnotqtdef :
  (forall c:int. forall ta1:int. forall ta2:int. forall k:int. forall n1:int.
  forall n2:int. (((k <= ta1) and (ta1 <  (k + n1))) -> (((k <= ta2) and
  (ta2 <  (k + n1))) -> ((not (ta1 = ta2)) -> (((k + n1) <= n2) ->
  ((0 <= k) -> (((k <= c) -> ((k + n1) <= c)) -> (((0 <= c) and (c <  n2)) ->
  (toffoli_as_cont_cnot(c, ta1, ta2, k, n1,
  n2) = cont_flat_mute(cnot1((ta1 - k), (ta2 - k), n1), c, k, n2))))))))))

axiom toffoli_as_cont_cnotqtspec :
  (forall c:int. forall ta1:int. forall ta2:int. forall k:int. forall n1:int.
  forall n2:int. (((k <= ta1) and (ta1 <  (k + n1))) -> (((k <= ta2) and
  (ta2 <  (k + n1))) -> ((not (ta1 = ta2)) -> (((k + n1) <= n2) ->
  ((0 <= k) -> (((k <= c) -> ((k + n1) <= c)) -> (((0 <= c) and (c <  n2)) ->
  (ancillas1(toffoli_as_cont_cnot(c, ta1, ta2, k, n1, n2)) = 0)))))))))

axiom toffoli_as_cont_cnotqtspec1 :
  (forall c:int. forall ta1:int. forall ta2:int. forall k:int. forall n1:int.
  forall n2:int. (((k <= ta1) and (ta1 <  (k + n1))) -> (((k <= ta2) and
  (ta2 <  (k + n1))) -> ((not (ta1 = ta2)) -> (((k + n1) <= n2) ->
  ((0 <= k) -> (((k <= c) -> ((k + n1) <= c)) -> (((0 <= c) and (c <  n2)) ->
  infix_lseqgt(toffoli_as_cont_cnot(c, ta1, ta2, k, n1, n2), toffoli1(c, ta1,
  ta2, n2))))))))))

logic fredkin_decomp : int, int, int, int -> circuit1

axiom fredkin_decompqtspec :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (c = t2)) ->
  (width1(fredkin_decomp(c, t1, t2, n)) = n))))))))

axiom fredkin_decompqtspec1 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (c = t2)) ->
  (ancillas1(fredkin_decomp(c, t1, t2, n)) = 0))))))))

axiom fredkin_decompqtspec2 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (c = t2)) ->
  infix_lseqgt(fredkin_decomp(c, t1, t2, n), fredkin1(c, t1, t2, n)))))))))

axiom fredkin_decompqtspec3 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (c = t2)) ->
  (fredkin_decomp(c, t1, t2, n) = infix_mnmn(infix_mnmn(cnot1(t2, t1, n),
  toffoli1(c, t1, t2, n)), cnot1(t2, t1, n))))))))))

logic fredkin_decomp_toffoli : int, int, int, int -> circuit1

axiom fredkin_decomp_toffoliqtdef :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (c = t2)) ->
  (fredkin_decomp_toffoli(c, t1, t2, n) = infix_mnmn(infix_mnmn(cnot1(t2, t1,
  n), toffoli_decomp(c, t1, t2, n)), cnot1(t2, t1, n))))))))))

axiom fredkin_decomp_toffoliqtspec :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (c = t2)) ->
  (ancillas1(fredkin_decomp_toffoli(c, t1, t2, n)) = 0))))))))

axiom fredkin_decomp_toffoliqtspec1 :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (t1 = t2)) -> ((not (t1 = c)) -> ((not (c = t2)) ->
  infix_lseqgt(fredkin_decomp_toffoli(c, t1, t2, n), fredkin1(c, t1, t2,
  n)))))))))

axiom unbricks_fredkinqtspec : infix_lseqgt(bricks_fredkin, fredkin1(0, 1, 2,
  3))

axiom unbricks_toffoliqtspec : infix_lseqgt(bricks_toffoli, toffoli1(0, 1, 2,
  3))

axiom unbricks_swapqtspec : infix_lseqgt(bricks_swap, swap1(0, 1, 2))

axiom unbricks_cnotqtspec : infix_lseqgt(bricks_cnot, cnot1(0, 1, 2))

axiom ry_twice_equiv :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) ->
  infix_lseqgt(infix_mnmn(ry1(kqt), ry1(kqt)), ry1(k))))

axiom rz_twice_equiv :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) ->
  infix_lseqgt(infix_mnmn(rz1(kqt), rz1(kqt)), rz1(k))))

axiom rzp_twice_equiv :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) ->
  infix_lseqgt(infix_mnmn(rzp(kqt), rzp(kqt)), rzp(k))))

axiom rx_twice_equiv :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) ->
  infix_lseqgt(infix_mnmn(rx1(kqt), rx1(kqt)), rx1(k))))

axiom rx_twice_ :
  (forall x:complex matrix. forall k:int. (is_a_ket_l(x, 1) ->
  (path_sem1(rx1(incr_abs(k)), path_sem1(rx1(incr_abs(k)),
  x)) = path_sem1(rx1(k), x))))

axiom phase_twice_equiv :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) ->
  infix_lseqgt(infix_mnmn(phase1(kqt), phase1(kqt)), phase1(k))))

axiom ry_twice_equiv_rev :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) -> infix_lseqgt(ry1(k),
  infix_mnmn(ry1(kqt), ry1(kqt)))))

axiom rx_twice_equiv_rev :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) -> infix_lseqgt(rx1(k),
  infix_mnmn(rx1(kqt), rx1(kqt)))))

axiom rz_twice_equiv_rev :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) -> infix_lseqgt(rz1(k),
  infix_mnmn(rz1(kqt), rz1(kqt)))))

axiom rzp_twice_equiv_rev :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) -> infix_lseqgt(rzp(k),
  infix_mnmn(rzp(kqt), rzp(kqt)))))

axiom phase_twice_equiv_rev :
  (forall k:int. forall kqt:int. ((kqt = incr_abs(k)) ->
  infix_lseqgt(phase1(k), infix_mnmn(phase1(kqt), phase1(kqt)))))

predicate neutral_circ(c: circuit1) = infix_lseqgt(c, m_skip(width1(c)))

axiom set_neutral_circ :
  (forall c:circuit1.
  ((forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
   (is_a_ket_basis_elt(x) -> (path_sem1(c, x) = x)))) ->
  neutral_circ(c)))

axiom set_neutral_circ_bv :
  (forall c:circuit1.
  ((forall x:bitvec. ((length(x) = width1(c)) -> (path_sem1(c,
   bv_to_ket(x)) = bv_to_ket(x)))) ->
  neutral_circ(c)))

axiom get_neutral_circ :
  (forall c:circuit1. forall x:complex matrix. (neutral_circ(c) ->
  (is_a_ket_l(x, width1(c)) -> (path_sem1(c, x) = x))))

axiom neutral_skip : neutral_circ(skip)

axiom neutral_m_skip : (forall n:int. ((1 <= n) -> neutral_circ(m_skip(n))))

axiom m_skip_path_sem1 :
  (forall n:int. forall x:complex matrix. ((1 <= n) -> (is_a_ket_l(x, n) ->
  (path_sem1(m_skip(n), x) = x))))

axiom neutral_equiv :
  (forall c:circuit1. forall d:circuit1. (neutral_circ(c) ->
  (neutral_circ(d) -> ((width1(c) = width1(d)) -> infix_lseqgt(c, d)))))

axiom cont_neutral :
  (forall co:int. forall k:int. forall n:int. forall c:circuit1. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (((k <= co) -> ((k + width1(c)) <= co)) ->
  (((0 <= co) and (co <  n)) -> (neutral_circ(c) -> neutral_circ(cont1(c, co,
  k, n))))))))

axiom place_neutral :
  (forall k:int. forall n:int. forall c:circuit1. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (neutral_circ(c) -> neutral_circ(place1(c, k,
  n))))))

logic cont_skip_to_place : int, int, int -> circuit1

axiom cont_skip_to_placeqtdef :
  (forall co:int. forall ta:int. forall n:int. (((0 <= ta) and (ta <  n)) ->
  (((0 <= co) and (co <  n)) -> ((not (co = ta)) -> (cont_skip_to_place(co,
  ta, n) = place1(skip, ta, n))))))

axiom cont_skip_to_placeqtspec :
  (forall co:int. forall ta:int. forall n:int. (((0 <= ta) and (ta <  n)) ->
  (((0 <= co) and (co <  n)) -> ((not (co = ta)) ->
  infix_lseqgt(cont_skip_to_place(co, ta, n), cont1(skip, co, ta, n))))))

axiom neutral_seq_left :
  (forall c:circuit1. forall d:circuit1. ((width1(c) = width1(d)) ->
  (neutral_circ(c) -> infix_lseqgt(infix_mnmn(c, d), d))))

axiom neutral_seq_right :
  (forall c:circuit1. forall d:circuit1. ((width1(c) = width1(d)) ->
  (neutral_circ(c) -> infix_lseqgt(infix_mnmn(d, c), d))))

axiom neutral_seq_had : neutral_circ(infix_mnmn(hadamard1, hadamard1))

axiom neutral_seq_swap :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) ->
  neutral_circ(infix_mnmn(swap1(t1, t2, n), swap1(t1, t2, n)))))))

axiom neutral_seq_cnot :
  (forall co:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= co) and (co <  n)) -> ((not (t1 = co)) ->
  neutral_circ(infix_mnmn(cnot1(co, t1, n), cnot1(co, t1, n)))))))

axiom neutral_seq_toffoli :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (t1 = c1)) -> ((not (t1 = c2)) -> ((not (c2 = c1)) ->
  neutral_circ(infix_mnmn(toffoli1(c1, c2, t1, n), toffoli1(c1, c2, t1,
  n))))))))))

axiom neutral_seq_fredkin :
  (forall c:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= c) and (c <  n)) ->
  ((not (c = t1)) -> ((not (c = t2)) -> ((not (t2 = t1)) ->
  neutral_circ(infix_mnmn(fredkin1(c, t1, t2, n), fredkin1(c, t1, t2,
  n))))))))))

axiom neutral_seq_ry :
  (forall k:int. neutral_circ(infix_mnmn(ry1(k), ry1((-k)))))

axiom neutral_seq_ry_minus :
  (forall k:int. neutral_circ(infix_mnmn(ry1((-k)), ry1(k))))

axiom ang_exp_comp_one :
  (forall k:int. (infix_asdt(ang_exp(infix_sldtsl(1, incr_abs(k))),
  ang_exp(infix_sldtsl(1, incr_abs((-k))))) = c_one))

axiom ang_exp_comp_one_minus :
  (forall k:int. (infix_asdt(ang_exp(infix_sldtsl((- 1), incr_abs(k))),
  ang_exp(infix_sldtsl((- 1), incr_abs((-k))))) = c_one))

axiom neutral_seq_rz :
  (forall k:int. neutral_circ(infix_mnmn(rz1(k), rz1((-k)))))

axiom neutral_seq_rz_minus :
  (forall k:int. neutral_circ(infix_mnmn(rz1((-k)), rz1(k))))

axiom neutral_seq_rzp :
  (forall k:int. neutral_circ(infix_mnmn(rzp(k), rzp((-k)))))

axiom neutral_seq_phase :
  (forall k:int. neutral_circ(infix_mnmn(phase1(k), phase1((-k)))))

axiom neutral_seq_rx :
  (forall k:int. neutral_circ(infix_mnmn(rx1(k), rx1((-k)))))

axiom neutral_seq_rx_minus :
  (forall k:int. neutral_circ(infix_mnmn(rx1((-k)), rx1(k))))

axiom neutral_seq_yy : neutral_circ(infix_mnmn(yy1, yy1))

axiom neutral_seq_xx : neutral_circ(infix_mnmn(xx1, xx1))

axiom neutral_seq_zz : neutral_circ(infix_mnmn(zz1, zz1))

axiom to_qc_place :
  (forall c:wired_circuit. forall c1:wired_circuit. forall k:int.
  forall n:int. (correct1(c) -> ((c = Place(c1, k, n)) -> ((0 <= k) ->
  (((width_pre1(c1) + k) <= n) -> (to_qc1(c) = place1(to_qc1(c1), k, n)))))))

axiom to_qc_cont :
  (forall c:wired_circuit. forall c1:wired_circuit. forall co:int.
  forall k:int. forall n:int. (correct1(c) -> ((c = Cont(c1, co, k, n)) ->
  (((0 <= co) and (co <  n)) -> (((0 <= k) and
  (k <= (n - width_pre1(c1)))) -> (((k <= co) ->
  ((k + width_pre1(c1)) <= co)) -> (to_qc1(c) = cont1(to_qc1(c1), co, k,
  n))))))))

axiom to_qc_seq :
  (forall c:wired_circuit. forall c1:wired_circuit. forall c2:wired_circuit.
  (correct1(c) -> ((c = Sequence1(c1, c2)) ->
  ((width_pre1(c1) = width_pre1(c2)) -> (to_qc1(c) = infix_mnmn(to_qc1(c1),
  to_qc1(c2)))))))

axiom to_qc_par :
  (forall c:wired_circuit. forall c1:wired_circuit. forall c2:wired_circuit.
  (correct1(c) -> ((c = Parallel1(c1, c2)) ->
  (to_qc1(c) = infix_slsl(to_qc1(c1), to_qc1(c2))))))

axiom to_qc_cnot :
  (forall c:wired_circuit. forall co:int. forall t1:int. forall n:int.
  (((0 <= t1) and (t1 <  n)) -> (((0 <= co) and (co <  n)) ->
  ((not (t1 = co)) -> ((c = Cnot1(co, t1, n)) -> (to_qc1(c) = cnot1(co, t1,
  n)))))))

axiom to_qc_swap :
  (forall c:wired_circuit. forall t1:int. forall t2:int. forall n:int.
  (((0 <= t1) and (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) ->
  ((not (t1 = t2)) -> ((c = Swap1(t1, t2, n)) -> (to_qc1(c) = swap1(t1, t2,
  n)))))))

axiom to_qc_toffoli :
  (forall c:wired_circuit. forall c1:int. forall c2:int. forall t1:int.
  forall n:int. (((0 <= c1) and (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) ->
  (((0 <= t1) and (t1 <  n)) -> ((not (c1 = c2)) -> ((not (c1 = t1)) ->
  ((not (t1 = c2)) -> ((c = Toffoli(c1, c2, t1, n)) ->
  (to_qc1(c) = toffoli1(c1, c2, t1, n))))))))))

axiom to_qc_fredkin :
  (forall c:wired_circuit. forall co:int. forall t1:int. forall t2:int.
  forall n:int. (((0 <= t1) and (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) ->
  (((0 <= co) and (co <  n)) -> ((not (co = t1)) -> ((not (co = t2)) ->
  ((not (t2 = t1)) -> ((c = Fredkin(co, t1, t2, n)) ->
  (to_qc1(c) = fredkin1(co, t1, t2, n))))))))))

axiom to_qc_place_ :
  (forall c:wired_circuit. forall k:int. forall n:int. (correct1(c) ->
  ((0 <= k) -> (((width_pre1(c) + k) <= n) -> (to_qc1(Place(c, k,
  n)) = place1(to_qc1(c), k, n))))))

axiom to_qc_cont_ :
  (forall c:wired_circuit. forall co:int. forall k:int. forall n:int.
  (correct1(c) -> (((0 <= co) and (co <  n)) -> (((0 <= k) and
  (k <= (n - width_pre1(c)))) -> (((k <= co) ->
  ((k + width_pre1(c)) <= co)) -> (to_qc1(Cont(c, co, k,
  n)) = cont1(to_qc1(c), co, k, n)))))))

axiom to_qc_seq_ :
  (forall c1:wired_circuit. forall c2:wired_circuit. (correct1(c1) ->
  (correct1(c2) -> ((width_pre1(c1) = width_pre1(c2)) ->
  (to_qc1(Sequence1(c1, c2)) = infix_mnmn(to_qc1(c1), to_qc1(c2)))))))

axiom to_qc_par_ :
  (forall c1:wired_circuit. forall c2:wired_circuit. (correct1(c1) ->
  (correct1(c2) -> (to_qc1(Parallel1(c1, c2)) = infix_slsl(to_qc1(c1),
  to_qc1(c2))))))

axiom to_qc_cnot_ :
  (forall co:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= co) and (co <  n)) -> ((not (t1 = co)) -> (to_qc1(Cnot1(co, t1,
  n)) = cnot1(co, t1, n))))))

axiom to_qc_swap_ :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (to_qc1(Swap1(t1, t2,
  n)) = swap1(t1, t2, n))))))

axiom to_qc_toffoli_ :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t1)) -> ((not (t1 = c2)) ->
  (to_qc1(Toffoli(c1, c2, t1, n)) = toffoli1(c1, c2, t1, n)))))))))

axiom to_qc_fredkin_ :
  (forall co:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= co) and (co <  n)) ->
  ((not (co = t1)) -> ((not (co = t2)) -> ((not (t2 = t1)) ->
  (to_qc1(Fredkin(co, t1, t2, n)) = fredkin1(co, t1, t2, n)))))))))

axiom to_qc_rx_ : (forall k:int. (to_qc1(Rx(k)) = rx1(k)))

axiom to_qc_ry_ : (forall k:int. (to_qc1(Ry(k)) = ry1(k)))

axiom to_qc_rz_ : (forall k:int. (to_qc1(Rz1(k)) = rz1(k)))

axiom to_qc_rzp_ : (forall k:int. (to_qc1(Rzp(k)) = rzp(k)))

axiom pre_place_ :
  (forall c:circuit1. forall k:int. forall n:int. ((0 <= k) ->
  (((width1(c) + k) <= n) -> (pre1(place1(c, k, n)) = Place(pre1(c), k,
  n)))))

axiom pre_cont_ :
  (forall c:circuit1. forall co:int. forall k:int. forall n:int.
  (((0 <= co) and (co <  n)) -> (((0 <= k) and (k <= (n - width1(c)))) ->
  (((k <= co) -> ((k + width1(c)) <= co)) -> (pre1(cont1(c, co, k,
  n)) = Cont(pre1(c), co, k, n))))))

axiom pre_seq_ :
  (forall c1:circuit1. forall c2:circuit1. ((width1(c1) = width1(c2)) ->
  (pre1(infix_mnmn(c1, c2)) = Sequence1(pre1(c1), pre1(c2)))))

axiom pre_par_ :
  (forall c1:circuit1. forall c2:circuit1. (pre1(infix_slsl(c1,
  c2)) = Parallel1(pre1(c1), pre1(c2))))

axiom pre_cnot_ :
  (forall co:int. forall t1:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= co) and (co <  n)) -> ((not (t1 = co)) -> (pre1(cnot1(co, t1,
  n)) = Cnot1(co, t1, n))))))

axiom pre_swap_ :
  (forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and (t1 <  n)) ->
  (((0 <= t2) and (t2 <  n)) -> ((not (t1 = t2)) -> (pre1(swap1(t1, t2,
  n)) = Swap1(t1, t2, n))))))

axiom pre_toffoli_ :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int. (((0 <= c1) and
  (c1 <  n)) -> (((0 <= c2) and (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) ->
  ((not (c1 = c2)) -> ((not (c1 = t1)) -> ((not (t1 = c2)) ->
  (pre1(toffoli1(c1, c2, t1, n)) = Toffoli(c1, c2, t1, n)))))))))

axiom pre_fredkin_ :
  (forall co:int. forall t1:int. forall t2:int. forall n:int. (((0 <= t1) and
  (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) -> (((0 <= co) and (co <  n)) ->
  ((not (co = t1)) -> ((not (co = t2)) -> ((not (t2 = t1)) ->
  (pre1(fredkin1(co, t1, t2, n)) = Fredkin(co, t1, t2, n)))))))))

axiom pre_rx_ : (forall k:int. (pre1(rx1(k)) = Rx(k)))

axiom pre_ry_ : (forall k:int. (pre1(ry1(k)) = Ry(k)))

axiom pre_rz_ : (forall k:int. (pre1(rz1(k)) = Rz1(k)))

axiom pre_rzp_ : (forall k:int. (pre1(rzp(k)) = Rzp(k)))

logic ancilla_free_pre : wired_circuit -> prop

axiom ancilla_free_preqtdef :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Skip) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef1 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. ((c = Phase1(x)) -> ancilla_free_pre(c)))))

axiom ancilla_free_preqtdef2 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. ((c = Rx(x)) -> ancilla_free_pre(c)))))

axiom ancilla_free_preqtdef3 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. ((c = Ry(x)) -> ancilla_free_pre(c)))))

axiom ancilla_free_preqtdef4 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. ((c = Rz1(x)) -> ancilla_free_pre(c)))))

axiom ancilla_free_preqtdef5 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. ((c = Rzp(x)) -> ancilla_free_pre(c)))))

axiom ancilla_free_preqtdef6 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Hadamard1) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef7 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = S) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef8 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = T) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef9 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = X) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef10 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Y) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef11 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Z) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef12 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Cnot) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef13 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Toffoli) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef14 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Fredkin) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef15 :
  (forall c:wired_circuit. (build_correct1(c) -> ((c = Bricks_Swap) ->
  ancilla_free_pre(c))))

axiom ancilla_free_preqtdef16 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. forall x1:int. forall x2:int. ((c = Swap1(x, x1, x2)) ->
  ancilla_free_pre(c)))))

axiom ancilla_free_preqtdef17 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. forall x1:int. forall x2:int. ((c = Cnot1(x, x1, x2)) ->
  ancilla_free_pre(c)))))

axiom ancilla_free_preqtdef18 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  ((c = Toffoli(x, x1, x2, x3)) -> ancilla_free_pre(c)))))

axiom ancilla_free_preqtdef19 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:int. forall x1:int. forall x2:int. forall x3:int.
  ((c = Fredkin(x, x1, x2, x3)) -> ancilla_free_pre(c)))))

axiom ancilla_free_preqtdef20 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((c = Place(x, x1,
  x2)) -> (ancilla_free_pre(c) -> ancilla_free_pre(x))))))

axiom ancilla_free_preqtdef21 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. ((c = Place(x, x1,
  x2)) -> (ancilla_free_pre(x) -> ancilla_free_pre(c))))))

axiom ancilla_free_preqtdef22 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((c = Cont(x, x1, x2, x3)) -> (ancilla_free_pre(c) ->
  ancilla_free_pre(x))))))

axiom ancilla_free_preqtdef23 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. forall x2:int. forall x3:int.
  ((c = Cont(x, x1, x2, x3)) -> (ancilla_free_pre(x) ->
  ancilla_free_pre(c))))))

axiom ancilla_free_preqtdef24 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Sequence1(x,
  x1)) -> (ancilla_free_pre(c) -> ancilla_free_pre(x))))))

axiom ancilla_free_preqtdef25 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Sequence1(x,
  x1)) -> (ancilla_free_pre(c) -> ancilla_free_pre(x1))))))

axiom ancilla_free_preqtdef26 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Sequence1(x,
  x1)) -> ((ancilla_free_pre(x) and ancilla_free_pre(x1)) ->
  ancilla_free_pre(c))))))

axiom ancilla_free_preqtdef27 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Parallel1(x,
  x1)) -> (ancilla_free_pre(c) -> ancilla_free_pre(x))))))

axiom ancilla_free_preqtdef28 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Parallel1(x,
  x1)) -> (ancilla_free_pre(c) -> ancilla_free_pre(x1))))))

axiom ancilla_free_preqtdef29 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:wired_circuit. ((c = Parallel1(x,
  x1)) -> ((ancilla_free_pre(x) and ancilla_free_pre(x1)) ->
  ancilla_free_pre(c))))))

axiom ancilla_free_preqtdef30 :
  (forall c:wired_circuit. (build_correct1(c) ->
  (forall x:wired_circuit. forall x1:int. ((c = Ancillas1(x, x1)) ->
  (not ancilla_free_pre(c))))))

axiom ancilla_free_preqtspec :
  (forall c:wired_circuit. (build_correct1(c) -> (ancilla_free_pre(c) ->
  (ancillas_pre(c) = 0))))

axiom ancilla_free_preqtspec1 :
  (forall c:wired_circuit. (build_correct1(c) -> ((ancillas_pre(c) = 0) ->
  ancilla_free_pre(c))))

predicate ancilla_free(c: circuit1) = ancilla_free_pre(pre1(c))

axiom ancilla_freeqtspec :
  (forall c:circuit1. (ancilla_free(c) -> (ancillas1(c) = 0)))

axiom ancilla_freeqtspec1 :
  (forall c:circuit1. ((ancillas1(c) = 0) -> ancilla_free(c)))

axiom set_ancilla_free :
  (forall c:circuit1. ((ancillas1(c) = 0) -> ancilla_free(c)))

axiom ancilla_free_seq :
  (forall c:circuit1. forall d:circuit1. ((width1(c) = width1(d)) ->
  (ancilla_free(c) -> (ancilla_free(d) -> ancilla_free(infix_mnmn(c, d))))))

axiom phase_invol :
  (forall k:int. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_basis_elt(x) ->
  ((path_sem1(to_qc1(Phase1(k)), x) = y) -> (path_sem1(to_qc1(Phase1((-k))),
  y) = x)))))

axiom rz_invol :
  (forall k:int. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_basis_elt(x) -> ((path_sem1(to_qc1(Rz1(k)),
  x) = y) -> (path_sem1(to_qc1(Rz1((-k))), y) = x)))))

axiom ry_invol :
  (forall k:int. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_basis_elt(x) -> ((path_sem1(to_qc1(Ry(k)),
  x) = y) -> (path_sem1(to_qc1(Ry((-k))), y) = x)))))

axiom rx_invol :
  (forall k:int. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_basis_elt(x) -> ((path_sem1(to_qc1(Rx(k)),
  x) = y) -> (path_sem1(to_qc1(Rx((-k))), y) = x)))))

axiom rzp_invol :
  (forall k:int. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, 1) -> (is_a_ket_basis_elt(x) -> ((path_sem1(to_qc1(Rzp(k)),
  x) = y) -> (path_sem1(to_qc1(Rzp((-k))), y) = x)))))

axiom yy_invol :
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, 1) ->
  (is_a_ket_basis_elt(x) -> ((path_sem1(to_qc1(Y), x) = y) ->
  (path_sem1(to_qc1(Y), y) = x)))))

axiom swap_invol1 :
  (forall t1:int. forall t2:int. forall n:int. forall x:complex matrix.
  forall y:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((0 <= t1) and (t1 <  n)) -> (((0 <= t2) and (t2 <  n)) ->
  ((not (t1 = t2)) -> ((path_sem1(to_qc1(Swap1(t1, t2, n)), x) = y) ->
  (path_sem1(to_qc1(Swap1(t1, t2, n)), y) = x))))))))

axiom cnot_invol1 :
  (forall co:int. forall t1:int. forall n:int. forall x:complex matrix.
  forall y:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (((0 <= t1) and (t1 <  n)) -> (((0 <= co) and (co <  n)) ->
  ((not (t1 = co)) -> ((path_sem1(to_qc1(Cnot1(co, t1, n)), x) = y) ->
  (path_sem1(to_qc1(Cnot1(co, t1, n)), y) = x))))))))

axiom toffoli_invol :
  (forall c1:int. forall c2:int. forall t1:int. forall n:int.
  forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, n) ->
  (is_a_ket_basis_elt(x) -> (((0 <= c1) and (c1 <  n)) -> (((0 <= c2) and
  (c2 <  n)) -> (((0 <= t1) and (t1 <  n)) -> ((not (t1 = c1)) ->
  ((not (t1 = c2)) -> ((not (c2 = c1)) -> ((path_sem1(to_qc1(Toffoli(c1, c2,
  t1, n)), x) = y) -> (path_sem1(to_qc1(Toffoli(c1, c2, t1, n)),
  y) = x)))))))))))

axiom fredkin_invol :
  (forall c:int. forall t1:int. forall t2:int. forall n:int.
  forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x, n) ->
  (is_a_ket_basis_elt(x) -> (((0 <= t1) and (t1 <  n)) -> (((0 <= t2) and
  (t2 <  n)) -> (((0 <= c) and (c <  n)) -> ((not (c = t1)) ->
  ((not (c = t2)) -> ((not (t2 = t1)) -> ((path_sem1(to_qc1(Fredkin(c, t1,
  t2, n)), x) = y) -> (path_sem1(to_qc1(Fredkin(c, t1, t2, n)),
  y) = x)))))))))))

logic reverse_pre : wired_circuit -> wired_circuit

axiom reverse_preqtdef :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = Skip) -> (reverse_pre(c) = Skip)))))

axiom reverse_preqtdef1 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall k:int. ((c = Phase1(k)) -> (reverse_pre(c) = Phase1((-k))))))))

axiom reverse_preqtdef2 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall k:int. ((c = Rx(k)) -> (reverse_pre(c) = Rx((-k))))))))

axiom reverse_preqtdef3 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall k:int. ((c = Ry(k)) -> (reverse_pre(c) = Ry((-k))))))))

axiom reverse_preqtdef4 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall k:int. ((c = Rz1(k)) -> (reverse_pre(c) = Rz1((-k))))))))

axiom reverse_preqtdef5 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall k:int. ((c = Rzp(k)) -> (reverse_pre(c) = Rzp((-k))))))))

axiom reverse_preqtdef6 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = Hadamard1) -> (reverse_pre(c) = Hadamard1)))))

axiom reverse_preqtdef7 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = S) -> (reverse_pre(c) = Rzp((- 2)))))))

axiom reverse_preqtdef8 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = T) -> (reverse_pre(c) = Rzp((- 3)))))))

axiom reverse_preqtdef9 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = X) -> (reverse_pre(c) = X)))))

axiom reverse_preqtdef10 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = Y) -> (reverse_pre(c) = Y)))))

axiom reverse_preqtdef11 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = Z) -> (reverse_pre(c) = Z)))))

axiom reverse_preqtdef12 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = Bricks_Cnot) -> (reverse_pre(c) = Bricks_Cnot)))))

axiom reverse_preqtdef13 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = Bricks_Toffoli) -> (reverse_pre(c) = Bricks_Toffoli)))))

axiom reverse_preqtdef14 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = Bricks_Fredkin) -> (reverse_pre(c) = Bricks_Fredkin)))))

axiom reverse_preqtdef15 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ((c = Bricks_Swap) -> (reverse_pre(c) = Bricks_Swap)))))

axiom reverse_preqtdef16 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall t1:int. forall t2:int. forall n:int. ((c = Swap1(t1, t2, n)) ->
  (reverse_pre(c) = Swap1(t1, t2, n)))))))

axiom reverse_preqtdef17 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall c1:int. forall t1:int. forall n:int. ((c = Cnot1(c1, t1, n)) ->
  (reverse_pre(c) = Cnot1(c1, t1, n)))))))

axiom reverse_preqtdef18 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall c1:int. forall c2:int. forall t1:int. forall n:int.
  ((c = Toffoli(c1, c2, t1, n)) -> (reverse_pre(c) = Toffoli(c1, c2, t1,
  n)))))))

axiom reverse_preqtdef19 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall c1:int. forall t1:int. forall t2:int. forall n:int.
  ((c = Fredkin(c1, t1, t2, n)) -> (reverse_pre(c) = Fredkin(c1, t1, t2,
  n)))))))

axiom reverse_preqtdef20 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall c1:wired_circuit. forall p:int. forall n:int. ((c = Place(c1, p,
  n)) -> (reverse_pre(c) = Place(reverse_pre(c1), p, n)))))))

axiom reverse_preqtdef21 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall c1:wired_circuit. forall co:int. forall t1:int. forall n:int.
  ((c = Cont(c1, co, t1, n)) -> (reverse_pre(c) = Cont(reverse_pre(c1), co,
  t1, n)))))))

axiom reverse_preqtdef22 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall d:wired_circuit. forall e:wired_circuit. ((c = Sequence1(d, e)) ->
  (reverse_pre(c) = Sequence1(reverse_pre(e), reverse_pre(d))))))))

axiom reverse_preqtdef23 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall d:wired_circuit. forall e:wired_circuit. ((c = Parallel1(d, e)) ->
  (reverse_pre(c) = Parallel1(reverse_pre(d), reverse_pre(e))))))))

axiom reverse_preqtdef24 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall d:wired_circuit. forall l:int. ((c = Ancillas1(d, l)) ->
  (reverse_pre(c) = Ancillas1(d, l)))))))

axiom reverse_preqtspec :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  correct1(reverse_pre(c)))))

axiom reverse_preqtspec1 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (width_pre1(reverse_pre(c)) = width_pre1(c)))))

axiom reverse_preqtspec2 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (size_pre(reverse_pre(c)) = size_pre(c)))))

axiom reverse_preqtspec3 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (ancillas_pre(reverse_pre(c)) = 0))))

axiom reverse_preqtspec4 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (width1(to_qc1(reverse_pre(c))) = width1(to_qc1(c))))))

axiom reverse_preqtspec5 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (size1(to_qc1(reverse_pre(c))) = size1(to_qc1(c))))))

axiom reverse_preqtspec6 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  ancilla_free(to_qc1(reverse_pre(c))))))

axiom reverse_preqtspec7 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  width_pre1(c)) -> (is_a_ket_basis_elt(x) -> (is_a_ket_l(y,
  width_pre1(c)) -> ((path_sem1(to_qc1(c), x) = y) ->
  (path_sem1(to_qc1(reverse_pre(c)), y) = x)))))))))

axiom reverse_preqtspec8 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  width_pre1(c)) -> (is_a_ket_basis_elt(x) -> (is_a_ket_l(y,
  width_pre1(c)) -> ((path_sem1(to_qc1(reverse_pre(c)), x) = y) ->
  (path_sem1(to_qc1(c), y) = x)))))))))

axiom reverse_preqtspec9 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  width_pre1(c)) -> (is_a_ket_l(y, width_pre1(c)) -> ((path_sem1(to_qc1(c),
  x) = y) -> (path_sem1(to_qc1(reverse_pre(c)), y) = x))))))))

axiom reverse_preqtspec10 :
  (forall c:wired_circuit. ((ancillas_pre(c) = 0) -> (correct1(c) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  width_pre1(c)) -> (is_a_ket_l(y, width_pre1(c)) ->
  ((path_sem1(to_qc1(reverse_pre(c)), y) = x) -> (path_sem1(to_qc1(c),
  x) = y))))))))

logic reverse : circuit1 -> circuit1

axiom reverseqtdef :
  (forall c:circuit1. (ancilla_free(c) ->
  (reverse(c) = to_qc1(reverse_pre(pre1(c))))))

axiom reverseqtspec :
  (forall c:circuit1. (ancilla_free(c) -> (width1(reverse(c)) = width1(c))))

axiom reverseqtspec1 :
  (forall c:circuit1. (ancilla_free(c) -> (size1(reverse(c)) = size1(c))))

axiom reverseqtspec2 :
  (forall c:circuit1. (ancilla_free(c) -> ancilla_free(reverse(c))))

axiom reverseqtspec3 :
  (forall c:circuit1. (ancilla_free(c) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  width1(c)) -> (is_a_ket_l(y, width1(c)) -> ((path_sem1(c, x) = y) ->
  (path_sem1(reverse(c), y) = x)))))))

axiom reverseqtspec4 :
  (forall c:circuit1. (ancilla_free(c) ->
  (forall x:complex matrix. forall y:complex matrix. (is_a_ket_l(x,
  width1(c)) -> (is_a_ket_l(y, width1(c)) -> ((path_sem1(reverse(c),
  y) = x) -> (path_sem1(c, x) = y)))))))

axiom reverse_invol :
  (forall c:circuit1. (ancilla_free(c) -> infix_lseqgt(reverse(reverse(c)),
  c)))

axiom path_sem_reverse_invol :
  (forall c:circuit1. forall x:complex matrix. (is_a_ket_l(x, width1(c)) ->
  (ancilla_free(c) -> (path_sem1(reverse(reverse(c)), x) = path_sem1(c,
  x)))))

axiom path_sem_reverse :
  (forall c:circuit1. forall x:complex matrix. forall y:complex matrix.
  (is_a_ket_l(x, width1(c)) -> ((path_sem1(c, x) = y) -> (ancilla_free(c) ->
  (path_sem1(reverse(c), y) = x)))))

axiom sem_reverse :
  (forall c:circuit1. forall x:complex matrix. forall y:complex matrix.
  (sem1(c, x, y) -> (ancilla_free(c) -> sem1(reverse(c), y, x))))

logic qft : int -> circuit1

axiom qftqtdef : (forall n:int. ((0 <  n) -> (qft(n) = reverse(qft_rev(n)))))

logic fc703 : int, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef706 :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((fc703(n,
  x)[y]) = infix_asdtdt(qft_rev_coeff(x, bv_inversion(y), n), bv_to_ket(y))))

axiom qftqtspec :
  (forall n:int. ((0 <  n) -> (size1(qft(n)) <= polysquare(n, cont_size1, 0,
  0))))

axiom qftqtspec1 : (forall n:int. ((0 <  n) -> (ancillas1(qft(n)) = 0)))

axiom qftqtspec2 : (forall n:int. ((0 <  n) -> (width1(qft(n)) = n)))

axiom qftqtspec3 :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem1(qft(n),
  infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc703(n, x),
  n))) = bv_to_ket(x))))))

logic int_qft_coeff : int, int, int -> complex

axiom int_qft_coeffqtdef :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (int_qft_coeff(i,
  j, n) = ang_exp(infix_sldtsl((i * j), n)))))

axiom int_qft_coeffqtspec :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) ->
  (modulus(int_qft_coeff(i, j, n)) = c_one)))

axiom int_qft_coeffqtspec1 :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (int_qft_coeff(i,
  j, n) = int_qft_rev_coeff((-i), int_bit_inversion((j % power(2, n)), n),
  n))))

axiom int_qft_coeff_rev :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (int_qft_coeff(i,
  j, n) = int_qft_coeff(j, i, n))))

axiom int_qft_coeff_minus_to_right :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) ->
  (int_qft_coeff((-i), j, n) = int_qft_coeff(i, (-j), n))))

axiom int_qft_coeff_minus_to_left :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (int_qft_coeff(i,
  (-j), n) = int_qft_coeff((-i), j, n))))

axiom int_qft_coeff_as_real :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (int_qft_coeff(i,
  j, n) = ang_exp(real_to_ang(infix_asdt(i_to_c((i * j)), pow_inv_2(n)))))))

axiom int_qft_coeff_expo :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (int_qft_coeff(i,
  j, n) = cpower(ang_exp(infix_sldtsl(i, n)), j))))

axiom int_qft_coeff_expo_ :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (int_qft_coeff(i,
  j, n) = cpower(ang_exp(infix_sldtsl(j, n)), i))))

axiom int_qft_coeff_as_mod :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (int_qft_coeff(i,
  j, n) = int_qft_coeff((i % power(2, n)), (j % power(2, n)), n))))

axiom int_qft_rev_coeff_to_qft_coeff :
  (forall i:int. forall j:int. forall n:int. ((0 <  n) -> (((0 <= i) and
  (i <  power(2, n))) -> (((0 <= j) and (j <  power(2, n))) ->
  (int_qft_rev_coeff(i, j, n) = int_qft_coeff(int_bit_inversion(j, n), (-i),
  n))))))

logic qft_rev_ : int -> circuit1

axiom qft_rev_qtdef :
  (forall n:int. ((0 <  n) -> (qft_rev_(n) = qft_rev(n))))

logic fc704 : int, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef707 :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((fc704(n,
  x)[y]) = infix_asdtdt(int_qft_coeff((-bv_to_int(y)), bv_to_int(x), n),
  bv_to_ket(y))))

axiom qft_rev_qtspec :
  (forall n:int. ((0 <  n) -> (size1(qft_rev_(n)) <= polysquare(n,
  cont_size1, 0, 0))))

axiom qft_rev_qtspec1 :
  (forall n:int. ((0 <  n) -> (ancillas1(qft_rev_(n)) = 0)))

axiom qft_rev_qtspec2 :
  (forall n:int. ((0 <  n) -> (width1(qft_rev_(n)) = n)))

axiom qft_rev_qtspec3 :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem1(qft_rev_(n),
  bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n),
  fc704(n, x), n)))))))

axiom qft_rev_qtspec4 :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec.
  (forall i:int. ((length(x) = n) -> (((0 <= i) and (i <  power(2, n))) ->
  (get(path_sem1(qft_rev_(n), bv_to_ket(x)), i,
  0) = infix_asdt(pow_inv_sqrt_2(n), int_qft_coeff((-i), bv_to_int(x),
  n)))))))))

axiom qft_rev_qtspec5 :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec.
  (forall i:int. ((length(x) = n) -> (((0 <= i) and (i <  power(2, n))) ->
  (get(path_sem1(qft_rev_(n), bv_to_ket(x)), i,
  0) = infix_asdt(pow_inv_sqrt_2(n), int_qft_coeff(i, (-bv_to_int(x)),
  n)))))))))

logic fc705 : int, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef708 :
  (forall n:int. forall x:complex matrix. forall y:bitvec. ((fc705(n,
  x)[y]) = infix_asdtdt(int_qft_coeff((-ket_to_int(x)), bv_to_int(y), n),
  bv_to_ket(y))))

axiom path_sem_rev_qft_unit :
  (forall n:int. ((0 <  n) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (path_sem1(qft_rev(n), x) = infix_asdtdt(pow_inv_sqrt_2(n),
  ket_sum_l(n_bvs(n), fc705(n, x), n))))))))

logic fc706 : int, int -> (bitvec,complex matrix) farray

axiom fcqtdef709 :
  (forall n:int. forall i:int. forall y:bitvec. ((fc706(n,
  i)[y]) = infix_asdtdt(int_qft_coeff((-i), bv_to_int(y), n), bv_to_ket(y))))

axiom path_sem_rev_qft_unit_int :
  (forall n:int. ((0 <  n) ->
  (forall i:int. (((0 <= i) and (i <  power(2, n))) -> (path_sem1(qft_rev(n),
  ket(n, i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc706(n,
  i), n)))))))

logic fc707 : int, complex matrix -> (bitvec,complex matrix) farray

axiom fcqtdef710 :
  (forall n:int. forall x:complex matrix. forall y:bitvec. ((fc707(n,
  x)[y]) = infix_asdtdt(int_qft_coeff((-ket_to_int(x)), bv_to_int(y), n),
  bv_to_ket(y))))

axiom sem_rev_qft_unit :
  (forall n:int. ((0 <  n) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  sem1(qft_rev(n), x, infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n),
  fc707(n, x), n))))))))

logic fc708 : int, int -> (bitvec,complex matrix) farray

axiom fcqtdef711 :
  (forall n:int. forall i:int. forall y:bitvec. ((fc708(n,
  i)[y]) = infix_asdtdt(int_qft_coeff((-i), bv_to_int(y), n), bv_to_ket(y))))

axiom sem_rev_qft_unit_int :
  (forall n:int. ((0 <  n) ->
  (forall i:int. (((0 <= i) and (i <  power(2, n))) -> sem1(qft_rev(n),
  ket(n, i), infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc708(n, i),
  n)))))))

axiom int_qft_coeff_eq :
  (forall i:int. forall iqt:int. forall j:int. forall jqt:int. forall n:int.
  forall nqt:int. ((n = nqt) -> ((0 <  n) -> (((i % power(2,
  n)) = (iqt % power(2, n))) -> (((j % power(2, n)) = (jqt % power(2, n))) ->
  (int_qft_coeff(i, j, n) = int_qft_coeff(iqt, jqt, n)))))))

logic fc709 : int, int -> (bitvec,complex matrix) farray

axiom fcqtdef712 :
  (forall i:int. forall n:int. forall y:bitvec. ((fc709(i,
  n)[y]) = infix_asdtdt(int_qft_coeff(i, bv_to_int(y), n), bv_to_ket(y))))

axiom rev_qft_apply_qft :
  (forall i:int. forall n:int. ((0 <  n) -> (path_sem1(qft_rev(n),
  infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc709(i, n),
  n))) = ket(n, (i % power(2, n))))))

logic apply_qft : int, int -> complex matrix

logic result86 : int, int -> (bitvec,complex matrix) farray

axiom resultqtdef93 :
  (forall n:int. forall i:int. forall y:bitvec. ((result86(n,
  i)[y]) = infix_asdtdt(int_qft_coeff(i, bv_to_int(y), n), bv_to_ket(y))))

axiom apply_qftqtdef :
  (forall n:int. forall i:int. ((0 <  n) -> (apply_qft(n,
  i) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), result86(n, i),
  n)))))

axiom apply_qftqtspec :
  (forall n:int. forall i:int. ((0 <  n) -> is_a_ket_l(apply_qft(n, i), n)))

axiom apply_qftqtspec1 :
  (forall n:int. forall i:int. ((0 <  n) -> (apply_qft(n,
  i) = path_sem1(qft(n), ket(n, (i % power(2, n)))))))

logic fc710 : (bitvec,(bitvec,bitvec) farray) farray

logic fc711 : int -> (bitvec,(bitvec,angle) farray) farray

axiom fcqtdef713 :
  (forall us:bitvec. forall y:bitvec. (((fc710[us])[y]) = y))

axiom fcqtdef714 :
  (forall n:int. forall x:bitvec. forall y:bitvec.
  (((fc711(n)[x])[y]) = infix_sldtsl((bv_to_int(x) * bv_to_int(y)), n)))

axiom qft_correct_bv :
  (forall n:int. ((0 <  n) -> correct_path_sum_bv1(qft(n), n, fc710,
  fc711(n))))

logic fc712 : int, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef715 :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((fc712(n,
  x)[y]) = infix_asdtdt(int_qft_coeff((-bv_to_int(x)), bv_to_int(y), n),
  bv_to_ket(y))))

axiom path_sem_qft_pre :
  (forall n:int. forall x:bitvec. ((0 <  n) -> ((length(x) = n) ->
  (path_sem1(qft(n), infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n),
  fc712(n, x), n))) = bv_to_ket(x)))))

logic fc713 : int, bitvec -> (bitvec,complex matrix) farray

axiom fcqtdef716 :
  (forall n:int. forall x:bitvec. forall y:bitvec. ((fc713(n,
  x)[y]) = infix_asdtdt(int_qft_coeff((-bv_to_int(x)), bv_to_int(y), n),
  bv_to_ket(y))))

axiom path_sem_qft :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem1(qft(n),
  infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(n_bvs(n), fc713(n, x),
  n))) = bv_to_ket(x))))))

axiom get_ket_apply_qft :
  (forall n:int. forall i:int. forall j:int. ((0 <  n) -> (((0 <= j) and
  (j <  power(2, n))) -> (get(apply_qft(n, i), j,
  0) = infix_asdt(pow_inv_sqrt_2(n), int_qft_coeff(i, j, n))))))

axiom apply_qft_equiv :
  (forall n:int. forall i:int. forall j:int. ((0 <  n) -> (((i % power(2,
  n)) = (j % power(2, n))) -> (apply_qft(n, i) = apply_qft(n, j)))))

axiom apply_qft_mod :
  (forall n:int. forall i:int. ((0 <  n) -> (apply_qft(n, (i % power(2,
  n))) = apply_qft(n, i))))

axiom qft_rev_qft_int :
  (forall n:int. forall i:int. ((0 <  n) -> (path_sem1(qft_rev(n),
  apply_qft(n, i)) = ket(n, (i % power(2, n))))))

axiom from_qft_basis :
  (forall n:int. forall i:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> (path_sem1(qft_rev(n), apply_qft(n, i)) = ket(n, i)))))

axiom qft_apply_basis :
  (forall n:int. forall i:int. ((0 <  n) -> (path_sem1(qft(n), ket(n,
  (i % power(2, n)))) = apply_qft(n, i))))

axiom sem_qft_rev_qft_int :
  (forall n:int. forall i:int. ((0 <  n) -> sem1(qft_rev(n), apply_qft(n, i),
  ket(n, (i % power(2, n))))))

axiom sem_from_qft_basis :
  (forall n:int. forall i:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) -> sem1(qft_rev(n), apply_qft(n, i), ket(n, i)))))

axiom sem_qft_apply_basis :
  (forall n:int. forall i:int. ((0 <  n) -> sem1(qft(n), ket(n, (i % power(2,
  n))), apply_qft(n, i))))

axiom apply_qft_eq :
  (forall n:int. forall nqt:int. forall i:int. forall iqt:int. ((0 <  n) ->
  ((n = nqt) -> (((i % power(2, n)) = (iqt % power(2, n))) -> (apply_qft(n,
  i) = apply_qft(nqt, iqt))))))

logic apply_qft_as_mod : int, int -> unit

axiom apply_qft_as_modqtdef :
  (forall n:int. forall i:int. ((0 <  n) -> (apply_qft_as_mod(n, i) = void)))

axiom apply_qft_as_modqtspec :
  (forall n:int. forall i:int. ((0 <  n) -> (apply_qft(n, i) = apply_qft(n,
  (i % power(2, n))))))

axiom int_qft_coeff_add :
  (forall i:int. forall iqt:int. forall j:int. forall n:int. ((0 <  n) ->
  (int_qft_coeff((i + iqt), j, n) = infix_asdt(int_qft_coeff(i, j, n),
  int_qft_coeff(iqt, j, n)))))

axiom path_sem_qft_unit :
  (forall n:int. ((0 <  n) ->
  (forall x:complex matrix. (is_a_ket_l(x, n) -> (is_a_ket_basis_elt(x) ->
  (path_sem1(qft(n), x) = apply_qft(n, ket_to_int(x))))))))

axiom path_sem_qft_bv :
  (forall n:int. ((0 <  n) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem1(qft(n),
  bv_to_ket(x)) = apply_qft(n, bv_to_int(x)))))))

axiom to_qft_basis :
  (forall n:int. forall i:int. ((0 <  n) -> (((0 <= i) and (i <  power(2,
  n))) ->
  (forall x:bitvec. ((length(x) = n) -> (path_sem1(qft(n), ket(n,
  i)) = apply_qft(n, i)))))))

logic place_qft_zero : int, int -> circuit1

axiom place_qft_zeroqtdef :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) -> (place_qft_zero(n,
  k) = place1(qft(n), 0, (n + k))))))

axiom place_qft_zeroqtspec :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (width1(place_qft_zero(n, k)) = (n + k)))))

axiom place_qft_zeroqtspec1 :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (size1(place_qft_zero(n, k)) <= polysquare(n, cont_size1, 0, 0)))))

axiom place_qft_zeroqtspec2 :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (ancillas1(place_qft_zero(n, k)) = 0))))

axiom place_qft_zeroqtspec3 :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (forall g:int.
  (forall y:complex matrix. (((0 <= g) and (g <  power(2, n))) ->
  (is_a_ket_l(y, k) -> sem1(place_qft_zero(n, k), kronecker(ket(n, g), y),
  kronecker(apply_qft(n, g), y)))))))))

axiom place_qft_zeroqtspec4 :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (width1(place_qft_zero(n, k)) = (n + k)))))

logic place_rev_qft_zero : int, int -> circuit1

axiom place_rev_qft_zeroqtdef :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (place_rev_qft_zero(n, k) = reverse(place_qft_zero(n, k))))))

axiom place_rev_qft_zeroqtspec :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (width1(place_rev_qft_zero(n, k)) = (n + k)))))

axiom place_rev_qft_zeroqtspec1 :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (size1(place_rev_qft_zero(n, k)) <= polysquare(n, cont_size1, 0, 0)))))

axiom place_rev_qft_zeroqtspec2 :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (ancillas1(place_rev_qft_zero(n, k)) = 0))))

axiom place_rev_qft_zeroqtspec3 :
  (forall n:int. forall k:int. ((0 <  n) -> ((0 <  k) ->
  (forall g:int.
  (forall y:complex matrix. (((0 <= g) and (g <  power(2, n))) ->
  (is_a_ket_l(y, k) -> sem1(place_rev_qft_zero(n, k), kronecker(apply_qft(n,
  g), y), kronecker(ket(n, g), y)))))))))

logic place_qft : int, int, int -> circuit1

axiom place_qftqtdef :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (place_qft(n, k, size_reg) = place1(qft(n), k,
  size_reg))))))

axiom place_qftqtspec :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (width1(place_qft(n, k,
  size_reg)) = size_reg)))))

axiom place_qftqtspec1 :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (size1(place_qft(n, k,
  size_reg)) <= polysquare(n, cont_size1, 0, 0))))))

axiom place_qftqtspec2 :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (ancillas1(place_qft(n, k, size_reg)) = 0)))))

axiom place_qftqtspec3 :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) ->
  (forall g:int.
  (forall y:complex matrix. forall z:complex matrix. (((0 <= g) and
  (g <  power(2, n))) -> (is_a_ket_l(y, k) -> (is_a_ket_l(z,
  ((size_reg - k) - n)) -> sem1(place_qft(n, k, size_reg), kronecker(y,
  kronecker(ket(n, g), z)), kronecker(y, kronecker(apply_qft(n, g), z))))))))))))

axiom place_qftqtspec4 :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (width1(place_qft(n, k,
  size_reg)) = size_reg)))))

logic place_rev_qft : int, int, int -> circuit1

axiom place_rev_qftqtdef :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (place_rev_qft(n, k,
  size_reg) = reverse(place_qft(n, k, size_reg)))))))

axiom place_rev_qftqtspec :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (width1(place_rev_qft(n, k,
  size_reg)) = size_reg)))))

axiom place_rev_qftqtspec1 :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (size1(place_rev_qft(n, k,
  size_reg)) <= polysquare(n, cont_size1, 0, 0))))))

axiom place_rev_qftqtspec2 :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (ancillas1(place_rev_qft(n, k,
  size_reg)) = 0)))))

axiom place_rev_qftqtspec3 :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) ->
  (forall g:int.
  (forall y:complex matrix. forall z:complex matrix. (((0 <= g) and
  (g <  power(2, n))) -> (is_a_ket_l(y, k) -> (is_a_ket_l(z,
  ((size_reg - k) - n)) -> sem1(place_rev_qft(n, k, size_reg), kronecker(y,
  kronecker(apply_qft(n, g), z)), kronecker(y, kronecker(ket(n, g), z))))))))))))

axiom place_rev_qftqtspec4 :
  (forall n:int. forall k:int. forall size_reg:int. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> (width1(place_rev_qft(n, k,
  size_reg)) = size_reg)))))

logic apply_function_in_qft_basis : circuit1, int, int, int,
  (int,int) farray -> circuit1

axiom apply_function_in_qft_basisqtspec :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (size1(apply_function_in_qft_basis(c, n, k, size_reg, f)) <= (polysquare(n,
  (cont_size1 * 2), 0, 0) + size1(c)))))))))

axiom apply_function_in_qft_basisqtspec1 :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (ancillas1(apply_function_in_qft_basis(c, n, k, size_reg,
  f)) = ancillas1(c))))))))

axiom apply_function_in_qft_basisqtspec2 :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (width1(apply_function_in_qft_basis(c, n, k, size_reg,
  f)) = size_reg)))))))

axiom apply_function_in_qft_basisqtspec3 :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (forall y:complex matrix. forall z:complex matrix.
  (forall i:int. (((0 <= i) and (i <  power(2, n))) -> (is_a_ket_l(y, k) ->
  (is_a_ket_l(z, ((size_reg - n) - k)) -> ((path_sem1(c, kronecker(y,
  kronecker(apply_qft(n, i), z))) = kronecker(y, kronecker(apply_qft(n,
  (f[i])), z))) -> (path_sem1(apply_function_in_qft_basis(c, n, k, size_reg,
  f), kronecker(y, kronecker(ket(n, i), z))) = kronecker(y, kronecker(ket(n,
  (f[i])), z)))))))))))))))

axiom apply_function_in_qft_basisqtspec4 :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((0 <  k) ->
  (((k + n) <  size_reg) -> ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (apply_function_in_qft_basis(c, n, k, size_reg,
  f) = infix_mnmn(infix_mnmn(place_qft(n, k, size_reg), c), place_rev_qft(n,
  k, size_reg)))))))))

logic apply_function_in_qft_basis_gen : circuit1, int, int, int -> circuit1

axiom apply_function_in_qft_basis_genqtdef :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  ((0 <  n) -> ((0 <  k) -> (((k + n) <  size_reg) ->
  ((width1(c) = size_reg) -> (apply_function_in_qft_basis_gen(c, n, k,
  size_reg) = infix_mnmn(infix_mnmn(place_qft(n, k, size_reg), c),
  place_rev_qft(n, k, size_reg))))))))

axiom apply_function_in_qft_basis_genqtspec :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  ((0 <  n) -> ((0 <  k) -> (((k + n) <  size_reg) ->
  ((width1(c) = size_reg) -> (size1(apply_function_in_qft_basis_gen(c, n, k,
  size_reg)) <= (polysquare(n, (cont_size1 * 2), 0, 0) + size1(c))))))))

axiom apply_function_in_qft_basis_genqtspec1 :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  ((0 <  n) -> ((0 <  k) -> (((k + n) <  size_reg) ->
  ((width1(c) = size_reg) -> (ancillas1(apply_function_in_qft_basis_gen(c, n,
  k, size_reg)) = ancillas1(c)))))))

axiom apply_function_in_qft_basis_genqtspec2 :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  ((0 <  n) -> ((0 <  k) -> (((k + n) <  size_reg) ->
  ((width1(c) = size_reg) -> (width1(apply_function_in_qft_basis_gen(c, n, k,
  size_reg)) = size_reg))))))

axiom apply_function_in_qft_basis_genqtspec3 :
  (forall c:circuit1. forall n:int. forall k:int. forall size_reg:int.
  ((0 <  n) -> ((0 <  k) -> (((k + n) <  size_reg) ->
  ((width1(c) = size_reg) ->
  (forall y:complex matrix. forall z:complex matrix.
  (forall i:int.
  (forall f:(int,int) farray. (((0 <= i) and (i <  power(2, n))) ->
  (is_a_ket_l(y, k) -> (is_a_ket_l(z, ((size_reg - n) - k)) ->
  ((forall iqt:int. (((0 <= iqt) and (iqt <  power(2, n))) ->
   ((0 <= (f[iqt])) and ((f[iqt]) <  power(2, n))))) ->
  ((path_sem1(c, kronecker(y, kronecker(apply_qft(n, i), z))) = kronecker(y,
  kronecker(apply_qft(n, (f[i])), z))) ->
  (path_sem1(apply_function_in_qft_basis_gen(c, n, k, size_reg), kronecker(y,
  kronecker(ket(n, i), z))) = kronecker(y, kronecker(ket(n, (f[i])),
  z))))))))))))))))

logic apply_function_in_qft_basis_zero : circuit1, int, int,
  (int,int) farray -> circuit1

axiom apply_function_in_qft_basis_zeroqtspec :
  (forall c:circuit1. forall n:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((n <  size_reg) ->
  ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (size1(apply_function_in_qft_basis_zero(c, n, size_reg,
  f)) <= (polysquare(n, (cont_size1 * 2), 0, 0) + size1(c))))))))

axiom apply_function_in_qft_basis_zeroqtspec1 :
  (forall c:circuit1. forall n:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((n <  size_reg) ->
  ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (ancillas1(apply_function_in_qft_basis_zero(c, n, size_reg,
  f)) = ancillas1(c)))))))

axiom apply_function_in_qft_basis_zeroqtspec2 :
  (forall c:circuit1. forall n:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((n <  size_reg) ->
  ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (width1(apply_function_in_qft_basis_zero(c, n, size_reg,
  f)) = size_reg))))))

axiom apply_function_in_qft_basis_zeroqtspec3 :
  (forall c:circuit1. forall n:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((n <  size_reg) ->
  ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (forall z:complex matrix.
  (forall i:int. (((0 <= i) and (i <  power(2, n))) -> (is_a_ket_l(z,
  (size_reg - n)) -> (sem1(c, kronecker(apply_qft(n, i), z),
  kronecker(apply_qft(n, (f[i])), z)) ->
  sem1(apply_function_in_qft_basis_zero(c, n, size_reg, f), kronecker(ket(n,
  i), z), kronecker(ket(n, (f[i])), z))))))))))))

axiom apply_function_in_qft_basis_zeroqtspec4 :
  (forall c:circuit1. forall n:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((n <  size_reg) ->
  ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (forall z:complex matrix.
  (forall i:int. (((0 <= i) and (i <  power(2, n))) -> (is_a_ket_l(z,
  (size_reg - n)) -> ((path_sem1(c, kronecker(apply_qft(n, i),
  z)) = kronecker(apply_qft(n, (f[i])), z)) ->
  (path_sem1(apply_function_in_qft_basis_zero(c, n, size_reg, f),
  kronecker(ket(n, i), z)) = kronecker(ket(n, (f[i])), z))))))))))))

axiom apply_function_in_qft_basis_zeroqtspec5 :
  (forall c:circuit1. forall n:int. forall size_reg:int.
  forall f:(int,int) farray. ((0 <  n) -> ((n <  size_reg) ->
  ((width1(c) = size_reg) ->
  ((forall i:int. (((0 <= i) and (i <  power(2, n))) -> ((0 <= (f[i])) and
   ((f[i]) <  power(2, n))))) ->
  (apply_function_in_qft_basis_zero(c, n, size_reg,
  f) = infix_mnmn(infix_mnmn(place_qft_zero(n, (size_reg - n)), c),
  place_rev_qft_zero(n, (size_reg - n)))))))))

logic apply_from_qft_zero : int, int, circuit1 -> circuit1

axiom apply_from_qft_zeroqtspec :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (size1(apply_from_qft_zero(n, k,
  c)) <= (polysquare(n, (cont_size1 * 2), 0, 0) + size1(c)))))))

axiom apply_from_qft_zeroqtspec1 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (ancillas1(apply_from_qft_zero(n, k,
  c)) = ancillas1(c))))))

axiom apply_from_qft_zeroqtspec2 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (width1(apply_from_qft_zero(n, k,
  c)) = (n + k))))))

axiom apply_from_qft_zeroqtspec3 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) ->
  (forall y:complex matrix. forall z:complex matrix.
  (forall i:int. (((0 <= i) and (i <  power(2, n))) -> (is_a_ket_l(y, k) ->
  (is_a_ket_l(z, k) -> (sem1(c, kronecker(ket(n, i), y), kronecker(ket(n, i),
  z)) -> sem1(apply_from_qft_zero(n, k, c), kronecker(apply_qft(n, i), y),
  kronecker(apply_qft(n, i), z))))))))))))

logic apply_in_qft_zero : int, int, circuit1 -> circuit1

axiom apply_in_qft_zeroqtspec :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (size1(apply_in_qft_zero(n, k,
  c)) <= (polysquare(n, (cont_size1 * 2), 0, 0) + size1(c)))))))

axiom apply_in_qft_zeroqtspec1 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (ancillas1(apply_in_qft_zero(n, k,
  c)) = ancillas1(c))))))

axiom apply_in_qft_zeroqtspec2 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (width1(apply_in_qft_zero(n, k,
  c)) = (n + k))))))

axiom apply_in_qft_zeroqtspec3 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) ->
  (forall y:complex matrix. forall z:complex matrix.
  (forall i:int. (((0 <= i) and (i <  power(2, n))) -> (is_a_ket_l(y, k) ->
  (is_a_ket_l(z, k) -> (sem1(c, kronecker(apply_qft(n, i), y),
  kronecker(apply_qft(n, i), z)) -> sem1(apply_in_qft_zero(n, k, c),
  kronecker(ket(n, i), y), kronecker(ket(n, i), z))))))))))))

logic apply_from_qft_zero_path : int, int, circuit1 -> circuit1

axiom apply_from_qft_zero_pathqtdef :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (apply_from_qft_zero_path(n, k,
  c) = apply_from_qft_zero(n, k, c))))))

axiom apply_from_qft_zero_pathqtspec :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (size1(apply_from_qft_zero_path(n, k,
  c)) <= (polysquare(n, (cont_size1 * 2), 0, 0) + size1(c)))))))

axiom apply_from_qft_zero_pathqtspec1 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (ancillas1(apply_from_qft_zero_path(n, k,
  c)) = ancillas1(c))))))

axiom apply_from_qft_zero_pathqtspec2 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (width1(apply_from_qft_zero_path(n, k,
  c)) = (n + k))))))

axiom apply_from_qft_zero_pathqtspec3 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) ->
  (forall y:complex matrix. forall z:complex matrix.
  (forall i:int. (is_a_ket_l(y, k) -> (is_a_ket_l(z, k) -> ((path_sem1(c,
  kronecker(ket(n, (i % power(2, n))), y)) = kronecker(ket(n, (i % power(2,
  n))), z)) -> (path_sem1(apply_from_qft_zero_path(n, k, c),
  kronecker(apply_qft(n, i), y)) = kronecker(apply_qft(n, i), z)))))))))))

logic apply_in_qft_zero_path : int, int, circuit1 -> circuit1

axiom apply_in_qft_zero_pathqtdef :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (apply_in_qft_zero_path(n, k,
  c) = apply_from_qft_zero(n, k, c))))))

axiom apply_in_qft_zero_pathqtspec :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (size1(apply_in_qft_zero_path(n, k,
  c)) <= (polysquare(n, (cont_size1 * 2), 0, 0) + size1(c)))))))

axiom apply_in_qft_zero_pathqtspec1 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (ancillas1(apply_in_qft_zero_path(n, k,
  c)) = ancillas1(c))))))

axiom apply_in_qft_zero_pathqtspec2 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) -> (width1(apply_in_qft_zero_path(n, k,
  c)) = (n + k))))))

axiom apply_in_qft_zero_pathqtspec3 :
  (forall n:int. forall k:int. forall c:circuit1. ((0 <  n) -> ((0 <  k) ->
  ((width1(c) = (n + k)) ->
  (forall y:complex matrix. forall z:complex matrix.
  (forall i:int. (((0 <= i) and (i <  power(2, n))) -> (is_a_ket_l(y, k) ->
  (is_a_ket_l(z, k) -> ((path_sem1(c, kronecker(apply_qft(n, i),
  y)) = kronecker(apply_qft(n, i), z)) ->
  (path_sem1(apply_in_qft_zero_path(n, k, c), kronecker(ket(n, i),
  y)) = kronecker(ket(n, i), z))))))))))))

logic divisors : int -> int set

logic result87 : int -> (int,bool) farray

axiom resultqtdef94 :
  (forall i:int. forall j:int. (((result87(i)[j]) = true) -> (1 <= j)))

axiom resultqtdef95 :
  (forall i:int. forall j:int. (((result87(i)[j]) = true) -> (j <= i)))

axiom resultqtdef96 :
  (forall i:int. forall j:int. (((result87(i)[j]) = true) -> ((i % j) = 0)))

axiom resultqtdef97 :
  (forall i:int. forall j:int. ((((1 <= j) and (j <= i)) and
  ((i % j) = 0)) -> ((result87(i)[j]) = true)))

axiom divisorsqtdef :
  (forall i:int. ((0 <  i) -> (divisors(i) = my_filter(to_fset(1, (i + 1)),
  result87(i)))))

axiom divisorsqtspec :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (mem(j, divisors(i)) -> (0 <  j)))))

axiom divisorsqtspec1 :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (mem(j, divisors(i)) -> (j <= i)))))

axiom divisorsqtspec2 :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (mem(j, divisors(i)) -> ((i % j) = 0)))))

axiom divisorsqtspec3 :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (mem(j, divisors(i)) ->
  (exists k:int. (((1 <= k) and (k <= i)) and (i = (k * j))))))))

axiom divisorsqtspec4 :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (((1 <= j) and (j <= i)) -> (((i % j) = 0) -> mem(j,
  divisors(i)))))))

axiom divisorsqtspec5 :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (((1 <= j) and (j <= i)) ->
  ((exists k:int. (((1 <= k) and (k <= i)) and (i = (k * j)))) -> mem(j,
  divisors(i)))))))

axiom set_mem_divisors :
  (forall j:int. forall i:int. ((0 <  i) -> (((1 <= j) and (j <= i)) ->
  (((i % j) = 0) -> mem(j, divisors(i))))))

axiom get_mem_divisors_mod :
  (forall j:int. forall i:int. ((0 <  i) -> (mem(j, divisors(i)) ->
  ((i % j) = 0))))

axiom get_mem_divisors_bounds :
  (forall j:int. forall i:int. ((0 <  i) -> (mem(j, divisors(i)) ->
  (1 <= j))))

axiom get_mem_divisors_bounds1 :
  (forall j:int. forall i:int. ((0 <  i) -> (mem(j, divisors(i)) ->
  (j <= i))))

axiom get_mem_divisors_inf :
  (forall j:int. forall i:int. ((0 <  i) -> (mem(j, divisors(i)) ->
  (j <= i))))

axiom get_mem_divisors :
  (forall j:int. forall i:int. ((0 <  i) -> (mem(j, divisors(i)) ->
  ((i % j) = 0))))

axiom get_mem_divisors1 :
  (forall j:int. forall i:int. ((0 <  i) -> (mem(j, divisors(i)) ->
  (1 <= j))))

axiom get_mem_divisors2 :
  (forall j:int. forall i:int. ((0 <  i) -> (mem(j, divisors(i)) ->
  (j <= i))))

axiom in_divisors_mult :
  (forall i:int. forall j:int. forall k:int. ((1 <= k) -> ((0 <  j) ->
  (mem(i, divisors(j)) -> mem(i, divisors((j * k)))))))

axiom in_divisors_powers :
  (forall a:int. forall b:int. forall bqt:int. forall i:int. ((1 <= a) ->
  ((1 <= i) -> (((0 <= b) and (b <= bqt)) -> (mem(i, divisors(power(a,
  b))) -> mem(i, divisors(power(a, bqt))))))))

axiom powers_in_divisors :
  (forall a:int. forall b:int. forall bqt:int. forall i:int. ((1 <= a) ->
  ((1 <= i) -> (((0 <= b) and (b <= bqt)) -> (mem(power(a, bqt),
  divisors(i)) -> mem(power(a, b), divisors(i)))))))

axiom not_powers_in_divisors :
  (forall a:int. forall b:int. forall bqt:int. forall i:int. ((1 <= a) ->
  ((1 <= i) -> (((0 <= b) and (b <= bqt)) -> ((not mem(power(a, b),
  divisors(i))) -> (not mem(power(a, bqt), divisors(i))))))))

axiom itself_divisors : (forall i:int. ((0 <  i) -> mem(i, divisors(i))))

axiom unicity_div_rev :
  (forall i:int. forall j:int. forall q:int. ((0 <  i) -> (mem(j,
  divisors(i)) -> ((q = (i / j)) -> (i = (q * j))))))

axiom mem_own_divisors : (forall i:int. ((0 <  i) -> mem(i, divisors(i))))

axiom mem_one_divisors : (forall i:int. ((0 <  i) -> mem(1, divisors(i))))

axiom trivial_divisors_left :
  (forall i:int. forall j:int. ((0 <  i) -> ((0 <  j) -> mem(i,
  divisors((i * j))))))

axiom trivial_divisors_right :
  (forall i:int. forall j:int. ((0 <  i) -> ((0 <  j) -> mem(i,
  divisors((j * i))))))

predicate prime(a: int) = ((0 <  a) and (divisors(a) = add(a, add(1,
  (empty : int set)))))

axiom get_not_prime :
  (forall a:int. ((0 <  a) -> ((not prime(a)) ->
  (exists b:int. (((1 <  b) and (b <  a)) and mem(b, divisors(a)))))))

axiom set_not_prime :
  (forall a:int. ((0 <  a) ->
  ((exists b:int. (((1 <  b) and (b <  a)) and mem(b, divisors(a)))) ->
  (not prime(a)))))

axiom card_prime_divisors :
  (forall a:int. ((1 <  a) -> (prime(a) -> (cardinal(divisors(a)) = 2))))

predicate co_prime(a: int, b: int) = ((0 <  a) and ((0 <  b) and
  (inter(divisors(a), divisors(b)) = add(1, (empty : int set)))))

axiom symetric_co_prime :
  (forall a:int. forall b:int. ((0 <  a) -> ((0 <  b) -> (co_prime(a, b) ->
  co_prime(b, a)))))

axiom prime_is_co_prime_right :
  (forall a:int. forall b:int. ((0 <  a) -> (prime(b) -> ((not mem(b,
  divisors(a))) -> co_prime(a, b)))))

axiom prime_is_co_prime :
  (forall a:int. forall b:int. ((0 <  a) -> (prime(b) -> ((not mem(b,
  divisors(a))) -> co_prime(b, a)))))

axiom prime_are_co_primes :
  (forall a:int. forall b:int. ((not (a = b)) -> (prime(b) -> (prime(a) ->
  co_prime(a, b)))))

axiom one_is_co_prime : (forall a:int. ((0 <  a) -> co_prime(a, 1)))

axiom mem_divisors_trans :
  (forall a:int. forall b:int. forall c:int. ((0 <  c) -> (mem(b,
  divisors(c)) -> (mem(a, divisors(b)) -> mem(a, divisors(c))))))

axiom subset_divisors :
  (forall a:int. forall b:int. ((0 <  b) -> (mem(a, divisors(b)) ->
  subset(divisors(a), divisors(b)))))

axiom not_prime_divisors :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (2 <  cardinal(divisors(a))))))

axiom not_prime_divisors1 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (exists i:int. (mem(i, divisors(a)) and ((not (i = 1)) and (not (i = a))))))))

axiom strict_subset_divisors :
  (forall a:int. forall b:int. ((0 <  b) -> ((not (a = b)) -> (mem(a,
  divisors(b)) -> subset(divisors(a), divisors(b))))))

axiom strict_subset_divisors1 :
  (forall a:int. forall b:int. ((0 <  b) -> ((not (a = b)) -> (mem(a,
  divisors(b)) -> (not (divisors(a) = divisors(b)))))))

axiom strict_subset_divisors2 :
  (forall a:int. forall b:int. ((0 <  b) -> ((not (a = b)) -> (mem(a,
  divisors(b)) -> (cardinal(divisors(a)) <  cardinal(divisors(b)))))))

axiom divisors_contains_prime :
  (forall i:int. ((1 <  i) ->
  (exists j:int. (prime(j) and ((1 <  j) and mem(j, divisors(i)))))))

axiom set_not_co_prime :
  (forall a:int. forall b:int. forall k:int. ((0 <  a) -> ((0 <  b) ->
  ((not (a = b)) -> (((1 <  k) and (k <= a)) -> (((1 <  k) and (k <= b)) ->
  (((a % k) = 0) -> (((b % k) = 0) -> (not co_prime(a, b))))))))))

axiom set_not_co_prime_ :
  (forall a:int. forall b:int. ((0 <  a) -> ((0 <  b) -> ((not (a = b)) ->
  ((exists k:int. (((1 <  k) and (k <= a)) and (((1 <  k) and (k <= b)) and
   (((a % k) = 0) and ((b % k) = 0))))) ->
  (not co_prime(a, b)))))))

axiom set_co_prime :
  (forall a:int. forall b:int. ((0 <  a) -> ((0 <  b) -> ((not (a = b)) ->
  ((forall c:int. (mem(c, divisors(a)) -> ((not (c = 1)) -> (not mem(c,
   divisors(b)))))) ->
  co_prime(a, b))))))

axiom co_prime_to_mod :
  (forall a:int. forall b:int. ((0 <  a) -> ((1 <  b) -> ((not (a = b)) ->
  (co_prime(a, b) -> (0 <  (a % b)))))))

axiom co_prime_to_mod_right :
  (forall a:int. forall b:int. ((1 <  a) -> ((0 <  b) -> ((not (a = b)) ->
  (co_prime(a, b) -> (0 <  (b % a)))))))

axiom inter_div_mod :
  (forall a:int. forall b:int. ((0 <  a) -> ((1 <  b) -> (co_prime(a, b) ->
  subset(inter(divisors((a % b)), divisors(b)), inter(divisors(a),
  divisors(b)))))))

axiom co_prime_mod :
  (forall a:int. forall b:int. ((0 <  a) -> ((1 <  b) -> (co_prime(a, b) ->
  co_prime((a % b), b)))))

axiom co_prime_by_primes :
  (forall a:int. forall b:int. ((0 <  a) -> ((1 <  b) -> ((not (a = b)) ->
  ((forall c:int. (prime(c) -> ((not (c = 1)) -> (mem(c, divisors(a)) ->
   (not mem(c, divisors(b))))))) ->
  co_prime(a, b))))))

axiom euclid_lemma_pre :
  (forall a:int. forall b:int. forall c:int. ((0 <  a) -> ((0 <  b) ->
  ((0 <  c) -> (prime(c) -> ((((a * b) % c) = 0) -> ((not ((b % c) = 0)) ->
  ((a % c) = 0))))))))

axiom euclid_lemma :
  (forall a:int. forall b:int. forall c:int. ((0 <  a) -> ((0 <  b) ->
  ((0 <  c) -> (prime(c) -> ((((a * b) % c) = 0) -> ((not ((b % c) = 0)) ->
  ((a % c) = 0))))))))

axiom divisors_euclid_lemma :
  (forall a:int. forall b:int. forall c:int. ((0 <  a) -> ((0 <  b) ->
  ((0 <  c) -> (prime(c) -> (mem(c, divisors((a * b))) -> ((not mem(c,
  divisors(b))) -> mem(c, divisors(a)))))))))

logic bounded_primes : int -> int set

logic prime_closure : (int,bool) farray

axiom prime_closure_def :
  (forall y:int. (((prime_closure[y]) = true) -> prime(y)))

axiom prime_closure_def1 :
  (forall y:int. (prime(y) -> ((prime_closure[y]) = true)))

axiom bounded_primesqtdef :
  (forall a:int. ((0 <= a) -> (bounded_primes(a) = my_filter(to_fset(1,
  (a + 1)), prime_closure))))

axiom bounded_primesqtspec :
  (forall a:int. ((0 <= a) ->
  (forall i:int. (mem(i, bounded_primes(a)) -> prime(i)))))

axiom bounded_primesqtspec1 :
  (forall a:int. ((0 <= a) ->
  (forall i:int. (mem(i, bounded_primes(a)) -> (1 <= i)))))

axiom bounded_primesqtspec2 :
  (forall a:int. ((0 <= a) ->
  (forall i:int. (mem(i, bounded_primes(a)) -> (i <= a)))))

axiom bounded_primesqtspec3 :
  (forall a:int. ((0 <= a) ->
  (forall i:int. (((1 <= i) and (i <= a)) -> (prime(i) -> mem(i,
  bounded_primes(a)))))))

logic prime_factors : int, int -> int

logic result88 : int, int -> (int,bool) farray

axiom resultqtdef98 :
  (forall a:int. forall b:int. forall i:int. (((result88(a, b)[i]) = true) ->
  mem(power(b, i), divisors(a))))

axiom resultqtdef99 :
  (forall a:int. forall b:int. forall i:int. (mem(power(b, i),
  divisors(a)) -> ((result88(a, b)[i]) = true)))

axiom prime_factorsqtdef :
  (forall a:int. forall b:int. ((1 <= a) -> (((1 <  b) and prime(b)) ->
  (prime_factors(a, b) = max_filter(to_fset(0, (a + 1)), result88(a, b))))))

axiom prime_factorsqtdef1 :
  (forall a:int. forall b:int. ((1 <= a) -> ((not ((1 <  b) and prime(b))) ->
  (prime_factors(a, b) = 0))))

axiom prime_factorsqtspec :
  (forall a:int. forall b:int. ((1 <= a) -> (0 <= prime_factors(a, b))))

axiom prime_factorsqtspec1 :
  (forall a:int. forall b:int. ((1 <= a) ->
  (forall j:int. (((0 <= j) and (j <= prime_factors(a, b))) -> mem(power(b,
  j), divisors(a))))))

axiom prime_factorsqtspec2 :
  (forall a:int. forall b:int. ((1 <= a) -> (((1 <  b) and prime(b)) ->
  (prime_factors(a, b) <  a))))

axiom prime_factorsqtspec3 :
  (forall a:int. forall b:int. ((1 <= a) -> (((1 <  b) and prime(b)) ->
  (forall j:int. ((prime_factors(a, b) <  j) -> (not mem(power(b, j),
  divisors(a))))))))

axiom prime_factorsqtspec4 :
  (forall a:int. forall b:int. ((1 <= a) -> (((1 <  b) and prime(b)) ->
  (forall j:int. ((prime_factors(a, b) <  j) -> (not mem(b,
  divisors((a / power(b, prime_factors(a, b)))))))))))

axiom set_prime_factors :
  (forall a:int. forall b:int. forall i:int. ((1 <= a) -> (prime(b) ->
  ((1 <  b) -> (((a % power(b, i)) = 0) -> ((not ((a % power(b,
  (i + 1))) = 0)) -> (prime_factors(a, b) = i)))))))

axiom set_prime_factors_null :
  (forall a:int. forall b:int. ((1 <= a) -> (prime(b) -> ((1 <  b) ->
  ((not ((a % b) = 0)) -> (prime_factors(a, b) = 0))))))

axiom set_prime_factors_over :
  (forall a:int. forall b:int. ((1 <= a) -> ((a <  b) -> (prime_factors(a,
  b) = 0))))

axiom set_prime_factors_not_prime :
  (forall a:int. forall b:int. ((1 <= a) -> ((not prime(b)) ->
  (prime_factors(a, b) = 0))))

axiom set_prime_factors_one :
  (forall a:int. forall b:int. ((1 <= a) -> ((b = 1) -> (prime_factors(a,
  b) = 0))))

axiom set_prime_factors_diff :
  (forall a:int. forall b:int. ((1 <= a) -> (prime(b) -> (prime(a) ->
  ((not (a = b)) -> (prime_factors(a, b) = 0))))))

axiom get_prime_factors :
  (forall a:int. forall b:int. forall i:int. ((1 <= a) -> (prime(b) ->
  ((1 <  b) -> ((prime_factors(a, b) = i) -> ((a % power(b, i)) = 0))))))

axiom get_prime_factors1 :
  (forall a:int. forall b:int. forall i:int. ((1 <= a) -> (prime(b) ->
  ((1 <  b) -> ((prime_factors(a, b) = i) -> (not ((a % power(b,
  (i + 1))) = 0)))))))

axiom prime_factors_itself :
  (forall a:int. ((1 <  a) -> (prime(a) -> (prime_factors(a, a) = 1))))

axiom prime_factors_one :
  (forall a:int. ((1 <  a) -> (prime_factors(a, 1) = 0)))

logic fc714 : int -> (int,int) farray

logic fc715 : int -> (int,int) farray

axiom fcqtdef717 :
  (forall a:int. forall i:int. ((fc714(a)[i]) = power(i, prime_factors(a,
  i))))

axiom fcqtdef718 :
  (forall a:int. forall i:int. ((fc715(a)[i]) = power(i, prime_factors(a,
  i))))

axiom prime_factors_up :
  (forall a:int. ((1 <= a) ->
  (forall b:int. ((a <  b) -> (prime_factors(a, b) = 0)))))

axiom prime_factors_up1 :
  (forall a:int. ((1 <= a) ->
  (forall b:int. ((a <  b) -> (ind_iproduct(fc714(a), 0,
  (b + 1)) = ind_iproduct(fc715(a), 0, (a + 1)))))))

logic fc716 : int -> (int,int) farray

logic fc717 : int -> (int,int) farray

axiom fcqtdef719 :
  (forall a:int. forall i:int. ((fc716(a)[i]) = power(i, prime_factors(a,
  i))))

axiom fcqtdef720 :
  (forall a:int. forall i:int. ((fc717(a)[i]) = power(i, prime_factors(a,
  i))))

axiom prime_factors_up_set :
  (forall a:int. forall b:int. (((1 <= a) and (a <= b)) ->
  (ind_iproduct(fc716(a), 0, (b + 1)) = ind_iproduct(fc717(a), 0, (a + 1)))))

axiom prime_factors_mult :
  (forall a:int. forall aqt:int. forall b:int. ((1 <= a) -> ((1 <= aqt) ->
  (prime_factors((a * aqt), b) = (prime_factors(a, b) + prime_factors(aqt,
  b))))))

logic fc718 : int, int -> (int,int) farray

logic fc719 : int -> (int,int) farray

logic fc720 : int -> (int,int) farray

axiom fcqtdef721 :
  (forall a:int. forall aqt:int. forall i:int. ((fc718(a, aqt)[i]) = power(i,
  prime_factors((a * aqt), i))))

axiom fcqtdef722 :
  (forall a:int. forall i:int. ((fc719(a)[i]) = power(i, prime_factors(a,
  i))))

axiom fcqtdef723 :
  (forall aqt:int. forall i:int. ((fc720(aqt)[i]) = power(i,
  prime_factors(aqt, i))))

axiom prime_factors_mult_gen :
  (forall a:int. forall aqt:int. ((1 <= a) -> ((1 <= aqt) ->
  (ind_iproduct(fc718(a, aqt), 0, ((a * aqt) + 1)) = (ind_iproduct(fc719(a),
  0, ((a * aqt) + 1)) * ind_iproduct(fc720(aqt), 0, ((a * aqt) + 1)))))))

logic proper_divisors : int -> int set

axiom proper_divisorsqtdef :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (proper_divisors(a) = remove(a, remove(1, divisors(a)))))))

axiom proper_divisorsqtspec :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (exists i:int. mem(i, proper_divisors(a))))))

axiom proper_divisorsqtspec1 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, proper_divisors(a)) -> mem(i, divisors(a)))))))

axiom proper_divisorsqtspec2 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, proper_divisors(a)) -> (1 <  i))))))

axiom proper_divisorsqtspec3 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, proper_divisors(a)) -> (i <  a))))))

axiom proper_divisorsqtspec4 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. ((((1 <  i) and (i <  a)) and ((a % i) = 0)) -> mem(i,
  proper_divisors(a)))))))

axiom proper_divisorsqtspec5 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, proper_divisors(a)) -> mem((a / i),
  proper_divisors(a)))))))

axiom proper_divisorsqtspec6 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, proper_divisors(a)) ->
  (cardinal(divisors(i)) <  cardinal(divisors(a))))))))

logic prime_divisors : int -> int set

axiom prime_divisorsqtdef :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (prime_divisors(a) = my_filter(proper_divisors(a), prime_closure)))))

axiom prime_divisorsqtspec :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (exists i:int. mem(i, prime_divisors(a))))))

axiom prime_divisorsqtspec1 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, prime_divisors(a)) -> mem(i, divisors(a)))))))

axiom prime_divisorsqtspec2 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, prime_divisors(a)) -> prime(i))))))

axiom prime_divisorsqtspec3 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, prime_divisors(a)) -> (1 <  i))))))

axiom prime_divisorsqtspec4 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, prime_divisors(a)) -> (i <  a))))))

axiom prime_divisorsqtspec5 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. ((((1 <  i) and (i <  a)) and (((a % i) = 0) and
  prime(i))) -> mem(i, prime_divisors(a)))))))

axiom prime_divisorsqtspec6 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, prime_divisors(a)) -> mem((a / i),
  proper_divisors(a)))))))

axiom prime_divisorsqtspec7 :
  (forall a:int. ((1 <  a) -> ((not prime(a)) ->
  (forall i:int. (mem(i, prime_divisors(a)) ->
  (cardinal(divisors(i)) <  cardinal(divisors(a))))))))

axiom unicity_div_rev_ :
  (forall i:int. forall j:int. forall q:int. ((0 <  i) -> (mem(j,
  divisors(i)) -> ((q = (i / j)) -> (i = (j * q))))))

logic fc721 : int -> (int,int) farray

axiom fcqtdef724 :
  (forall a:int. forall i:int. ((fc721(a)[i]) = power(i, prime_factors(a,
  i))))

axiom factors_prod :
  (forall a:int. ((1 <= a) ->
  (forall x:int. ((a <= x) -> (a = ind_iproduct(fc721(a), 0, (x + 1)))))))

axiom divisors_by_factor_decomp_pre :
  (forall a:int. forall b:int. ((1 <= a) -> (mem(b, divisors(a)) ->
  (forall i:int. (prime_factors(b, i) <= prime_factors(a, i))))))

axiom divisors_by_factor_decomp_pre_ :
  (forall a:int. forall b:int. forall i:int. ((1 <= a) -> (mem(b,
  divisors(a)) -> (prime_factors(b, i) <= prime_factors(a, i)))))

axiom divisors_by_factor_decomp_pre_rec :
  (forall a:int. forall b:int. ((1 <= a) -> (((1 <= b) and (b <= a)) ->
  ((forall i:int. (prime_factors(b, i) <= prime_factors(a, i))) -> mem(b,
  divisors(a))))))

axiom inf_by_prime_factors :
  (forall a:int. forall b:int. forall c:int. (((1 <= a) and (a <= c)) ->
  ((1 <= b) ->
  ((forall i:int. (prime_factors(b, i) <= prime_factors(a, i))) ->
  (b <= a)))))

axiom co_prime_to_prod :
  (forall a:int. forall b:int. forall c:int. ((1 <  b) -> ((0 <  c) ->
  (co_prime(a, c) -> (co_prime(b, c) -> co_prime((a * b), c))))))

axiom co_prime_to_prod_rev :
  (forall a:int. forall b:int. forall c:int. ((1 <  b) -> ((0 <  c) ->
  (co_prime(a, c) -> (co_prime(b, c) -> co_prime(c, (a * b)))))))

axiom co_prime_pow :
  (forall a:int. forall b:int. forall c:int. ((0 <  b) -> (co_prime(a, b) ->
  ((0 <  c) -> co_prime(power(a, c), b)))))

axiom co_prime_pows :
  (forall a:int. forall b:int. forall c:int. forall d:int. ((0 <  b) ->
  (co_prime(a, b) -> ((0 <= c) -> ((0 <= d) -> co_prime(power(a, c), power(b,
  d)))))))

logic fc722 : (int,int) farray -> (int,int) farray

logic fc723 : (int,int) farray -> (int,int) farray

axiom fcqtdef725 :
  (forall f:(int,int) farray. forall i:int. ((fc722(f)[i]) = power(i,
  (f[i]))))

axiom fcqtdef726 :
  (forall f:(int,int) farray. forall i:int. ((fc723(f)[i]) = power(i,
  (f[i]))))

axiom div_iproduct_primes :
  (forall bound:int. forall f:(int,int) farray. ((0 <= bound) ->
  ((forall i:int. ((1 <= i) -> ((not prime(i)) -> ((f[i]) = 0)))) ->
  ((forall i:int. ((1 <= i) -> (0 <= (f[i])))) -> (((f[0]) = 0) ->
  (forall j:int. ((bound <  j) -> (prime(j) -> co_prime(j,
  ind_iproduct(fc722(f), 0, (bound + 1)))))))))))

axiom div_iproduct_primes1 :
  (forall bound:int. forall f:(int,int) farray. ((0 <= bound) ->
  ((forall i:int. ((1 <= i) -> ((not prime(i)) -> ((f[i]) = 0)))) ->
  ((forall i:int. ((1 <= i) -> (0 <= (f[i])))) -> (((f[0]) = 0) ->
  (forall j:int. (((1 <= j) and (j <= bound)) -> (prime(j) ->
  (((f[j]) = 0) -> co_prime(j, ind_iproduct(fc723(f), 0, (bound + 1))))))))))))

logic fc724 : (int,int) farray -> (int,int) farray

axiom fcqtdef727 :
  (forall f:(int,int) farray. forall i:int. ((fc724(f)[i]) = power(i,
  (f[i]))))

axiom unicity_factors_prod_one :
  (forall bound:int. forall f:(int,int) farray. ((0 <= bound) ->
  ((forall i:int. ((not prime(i)) -> ((f[i]) = 0))) -> (((f[1]) = 0) ->
  ((forall i:int. ((1 <= i) -> (0 <= (f[i])))) ->
  ((1 = ind_iproduct(fc724(f), 0, (bound + 1))) ->
  ((forall i:int. (prime(i) -> ((bound <  i) -> ((f[i]) = 0)))) ->
  (forall i:int. (prime(i) -> ((f[i]) = 0))))))))))

logic fc725 : (int,int) farray -> (int,int) farray

axiom fcqtdef728 :
  (forall f:(int,int) farray. forall i:int. ((fc725(f)[i]) = power(i,
  (f[i]))))

axiom unicity_factors_prod_pre :
  (forall a:int. forall bound:int. forall f:(int,int) farray.
  ((forall i:int. (prime(i) -> ((bound <  i) -> ((f[i]) = 0)))) ->
  ((forall i:int. ((not prime(i)) -> ((f[i]) = 0))) -> (((f[1]) = 0) ->
  ((forall i:int. ((1 <= i) -> (0 <= (f[i])))) -> (((1 <= a) and
  (a <= bound)) -> ((a = ind_iproduct(fc725(f), 0, (bound + 1))) ->
  (forall i:int. (prime_factors(a, i) = (f[i]))))))))))

logic fc726 : (int,int) farray -> (int,int) farray

axiom fcqtdef729 :
  (forall f:(int,int) farray. forall i:int. ((fc726(f)[i]) = power(i,
  (f[i]))))

axiom unicity_factors_prod :
  (forall a:int. forall c:int. forall f:(int,int) farray. ((1 <= c) ->
  ((forall i:int. (0 <= (f[i]))) -> ((a = ind_iproduct(fc726(f), 0,
  (c + 1))) -> ((forall i:int. ((f[i]) <= prime_factors(c, i))) -> mem(a,
  divisors(c)))))))

logic fc727 : (int,int) farray -> (int,int) farray

axiom fcqtdef730 :
  (forall f:(int,int) farray. forall i:int. ((fc727(f)[i]) = power(i,
  (f[i]))))

axiom unicity_factors_prod_ :
  (forall c:int. forall f:(int,int) farray. ((1 <= c) ->
  ((forall i:int. (0 <= (f[i]))) ->
  ((forall i:int. ((f[i]) <= prime_factors(c, i))) ->
  mem(ind_iproduct(fc727(f), 0, (c + 1)), divisors(c))))))

logic fc728 : (int,int) farray -> (int,int) farray

axiom fcqtdef731 :
  (forall f:(int,int) farray. forall i:int. ((fc728(f)[i]) = power(i,
  (f[i]))))

axiom unicity_factors_prod_gen :
  (forall bound:int. forall c:int. forall f:(int,int) farray. (((1 <= c) and
  (c <= bound)) -> ((forall i:int. (0 <= (f[i]))) ->
  ((forall i:int. ((f[i]) <= prime_factors(c, i))) ->
  mem(ind_iproduct(fc728(f), 0, (bound + 1)), divisors(c))))))

logic gcd : int, int -> int

logic result89 : int, int -> (int,int) farray

axiom resultqtdef100 :
  (forall a:int. forall b:int. forall i:int. ((result89(a, b)[i]) = power(i,
  min(prime_factors(a, i), prime_factors(b, i)))))

axiom gcdqtdef :
  (forall a:int. forall b:int. ((1 <= a) -> ((1 <= b) -> (gcd(a,
  b) = ind_iproduct(result89(a, b), 0, ((a * b) + 1))))))

axiom gcdqtspec :
  (forall a:int. forall b:int. ((1 <= a) -> ((1 <= b) ->
  (forall i:int. (prime_factors(gcd(a, b), i) = min(prime_factors(a, i),
  prime_factors(b, i)))))))

axiom gcdqtspec1 :
  (forall a:int. forall b:int. ((1 <= a) -> ((1 <= b) -> mem(gcd(a, b),
  divisors(a)))))

axiom gcdqtspec2 :
  (forall a:int. forall b:int. ((1 <= a) -> ((1 <= b) -> mem(gcd(a, b),
  divisors(b)))))

axiom gcdqtspec3 :
  (forall a:int. forall b:int. ((1 <= a) -> ((1 <= b) ->
  (forall j:int. (mem(j, divisors(a)) -> (mem(j, divisors(b)) -> mem(j,
  divisors(gcd(a, b)))))))))

axiom gcd_prime_factors :
  (forall a:int. forall b:int. forall i:int. ((1 <= a) -> ((1 <= b) ->
  (prime_factors(gcd(a, b), i) = min(prime_factors(a, i), prime_factors(b,
  i))))))

logic scm : int, int -> int

axiom scmqtspec :
  (forall a:int. forall b:int. ((1 <= a) -> ((1 <= b) ->
  (forall i:int. (prime_factors(scm(a, b), i) = max(prime_factors(a, i),
  prime_factors(b, i)))))))

axiom scmqtspec1 :
  (forall a:int. forall b:int. ((1 <= a) -> ((1 <= b) -> mem(a,
  divisors(scm(a, b))))))

axiom scmqtspec2 :
  (forall a:int. forall b:int. ((1 <= a) -> ((1 <= b) -> mem(b,
  divisors(scm(a, b))))))

axiom scmqtspec3 :
  (forall a:int. forall b:int. ((1 <= a) -> ((1 <= b) ->
  (forall j:int. ((0 <  j) -> (mem(a, divisors(j)) -> (mem(b, divisors(j)) ->
  mem(scm(a, b), divisors(j)))))))))

axiom divisors_mult :
  (forall a:int. forall b:int. forall k:int. forall i:int. ((0 <  a) ->
  ((0 <  b) -> ((1 <= k) -> (mem((a * b), divisors(k)) -> (prime_factors(a,
  i) <= prime_factors(k, i)))))))

axiom divisors_mult1 :
  (forall a:int. forall b:int. forall k:int. forall i:int. ((0 <  a) ->
  ((0 <  b) -> ((1 <= k) -> (mem((a * b), divisors(k)) -> (prime_factors(b,
  i) <= prime_factors(k, i)))))))

axiom prime_factors_to_div :
  (forall a:int. forall i:int. ((0 <  a) -> ((0 <  prime_factors(a, i)) ->
  mem(i, divisors(a)))))

axiom prime_factors_not_prime :
  (forall a:int. forall i:int. ((0 <  a) -> ((0 <  prime_factors(a, i)) ->
  ((not (a = i)) -> (not prime(a))))))

axiom prime_factors_not_one :
  (forall a:int. forall i:int. ((0 <  a) -> ((0 <  prime_factors(a, i)) ->
  (not (a = 1)))))

axiom prime_prime_factors :
  (forall a:int. forall i:int. ((not (a = 1)) -> (prime(a) ->
  (prime_factors(a, i) = (if (a = i) then 1 else 0)))))

axiom mem_div_by_fact :
  (forall a:int. forall c:int. ((1 <= c) -> ((1 <= a) ->
  ((forall i:int. (prime_factors(a, i) <= prime_factors(c, i))) -> mem(a,
  divisors(c))))))

axiom div_prime :
  (forall a:int. forall i:int. ((0 <  a) -> ((0 <  prime_factors(a, i)) ->
  ((not (a = i)) -> mem(i, divisors(a))))))

axiom not_co_prime_itself :
  (forall a:int. ((1 <  a) -> (not co_prime(a, a))))

axiom co_prime_gcd :
  (forall a:int. forall b:int. ((0 <  a) -> ((0 <  b) -> (co_prime(a, b) ->
  (forall i:int. (prime_factors(gcd(a, b), i) = 0))))))

axiom co_prime_gcd_rev :
  (forall a:int. forall b:int. ((0 <  a) -> ((0 <  b) ->
  ((forall i:int. (prime_factors(gcd(a, b), i) = 0)) -> co_prime(a, b)))))

axiom divisors_euclid_lemma_co_prime :
  (forall a:int. forall b:int. forall c:int. ((0 <  a) -> ((0 <  b) ->
  ((0 <  c) -> (mem(c, divisors((a * b))) -> (co_prime(b, c) ->
  (forall cqt:int. (mem(cqt, divisors(c)) -> mem(cqt, divisors(a))))))))))

axiom divisors_euclid_lemma_co_prime_itself :
  (forall a:int. forall b:int. forall c:int. ((0 <  a) -> ((0 <  b) ->
  ((0 <  c) -> (mem(c, divisors((a * b))) -> (co_prime(b, c) -> mem(c,
  divisors(a))))))))

axiom euclid_lemma_co_prime :
  (forall a:int. forall b:int. forall c:int. ((0 <  a) -> ((0 <  b) ->
  ((0 <  c) -> (co_prime(b, c) -> (co_prime(a, c) -> co_prime((a * b),
  c)))))))

axiom co_prime_odd :
  (forall a:int. forall i:int. ((0 <  a) -> ((0 <  i) -> ((odd(a) = true) ->
  co_prime(power(2, i), a)))))

logic co_primes : int -> int set

logic co_prime_closure : (int,(int,bool) farray) farray

axiom co_prime_closure_def :
  (forall y:int. forall y1:int. ((((co_prime_closure[y])[y1]) = true) ->
  co_prime(y, y1)))

axiom co_prime_closure_def1 :
  (forall y:int. forall y1:int. (co_prime(y, y1) ->
  (((co_prime_closure[y])[y1]) = true)))

axiom co_primesqtdef :
  (forall i:int. ((0 <  i) -> (co_primes(i) = my_filter(to_fset(0, i),
  (co_prime_closure[i])))))

axiom co_primesqtspec :
  (forall i:int. ((0 <  i) -> ((1 <  i) -> mem(1, co_primes(i)))))

axiom co_primesqtspec1 :
  (forall i:int. ((0 <  i) -> ((1 <  i) -> mem(cardinal(co_primes(i)),
  to_fset(1, i)))))

axiom co_primesqtspec2 :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (mem(j, co_primes(i)) -> (0 <  j)))))

axiom co_primesqtspec3 :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (mem(j, co_primes(i)) -> (j <  i)))))

axiom co_primesqtspec4 :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (mem(j, co_primes(i)) -> co_prime(i, j)))))

axiom co_primesqtspec5 :
  (forall i:int. ((0 <  i) ->
  (forall j:int. (((0 <= j) and (j <  i)) -> (co_prime(i, j) -> mem(j,
  co_primes(i)))))))

axiom co_prime_iproduct :
  (forall s1:int set. forall f:(int,int) farray. forall bound:int.
  ((0 <  bound) -> ((forall e:int. (mem(e, s1) -> (0 <  (f[e])))) ->
  ((forall e:int. (mem(e, s1) -> co_prime((f[e]), bound))) ->
  co_prime(iproduct(s1, f), bound)))))

logic greatest_factor_in_n : int, int, int -> int

axiom greatest_factor_in_nqtdef :
  (forall multi:int. forall n:int. forall i:int. ((0 <  n) ->
  (((0 <  multi) and (multi <  power(2, n))) -> (((0 <= i) and
  (i <  multi)) -> ((i <  (power(2, n) % multi)) ->
  (greatest_factor_in_n(multi, n, i) = ((power(2, n) / multi) + 1)))))))

axiom greatest_factor_in_nqtdef1 :
  (forall multi:int. forall n:int. forall i:int. ((0 <  n) ->
  (((0 <  multi) and (multi <  power(2, n))) -> (((0 <= i) and
  (i <  multi)) -> ((not (i <  (power(2, n) % multi))) ->
  (greatest_factor_in_n(multi, n, i) = (power(2, n) / multi)))))))

axiom greatest_factor_in_nqtspec :
  (forall multi:int. forall n:int. forall i:int. ((0 <  n) ->
  (((0 <  multi) and (multi <  power(2, n))) -> (((0 <= i) and
  (i <  multi)) -> (1 <= greatest_factor_in_n(multi, n, i))))))

axiom greatest_factor_in_nqtspec1 :
  (forall multi:int. forall n:int. forall i:int. ((0 <  n) ->
  (((0 <  multi) and (multi <  power(2, n))) -> (((0 <= i) and
  (i <  multi)) ->
  (forall j:int. (((0 <= j) and (j <  greatest_factor_in_n(multi, n, i))) ->
  (((j * multi) + (i % multi)) <  power(2, n))))))))

axiom greatest_factor_in_nqtspec2 :
  (forall multi:int. forall n:int. forall i:int. ((0 <  n) ->
  (((0 <  multi) and (multi <  power(2, n))) -> (((0 <= i) and
  (i <  multi)) ->
  (forall j:int. (((0 <= j) and (j <  power(2, n))) -> (((j % multi) = i) ->
  (exists k:int. (((0 <= k) and (k <  greatest_factor_in_n(multi, n, i))) and
  (j = ((k * multi) + i)))))))))))

axiom greatest_factor_in_nqtspec3 :
  (forall multi:int. forall n:int. forall i:int. ((0 <  n) ->
  (((0 <  multi) and (multi <  power(2, n))) -> (((0 <= i) and
  (i <  multi)) ->
  (forall j:int. (((0 <= j) and (j <  power(2, n))) ->
  ((exists k:int. (((0 <= k) and (k <  greatest_factor_in_n(multi, n,
   i))) and (j = ((k * multi) + i)))) ->
  ((j % multi) = i))))))))

axiom greatest_factor_in_nqtspec4 :
  (forall multi:int. forall n:int. forall i:int. ((0 <  n) ->
  (((0 <  multi) and (multi <  power(2, n))) -> (((0 <= i) and
  (i <  multi)) -> infix_lseqdt(i_to_c((greatest_factor_in_n(multi, n,
  i) - 1)), infix_sldt(i_to_c((power(2, n) - i)), i_to_c(multi)))))))

logic fc729 : int, int, complex -> (int,complex) farray

logic fc730 : int, int -> (int,complex) farray

axiom fcqtdef732 :
  (forall multi:int. forall n:int. forall cst:complex. forall i:int.
  ((fc729(multi, n, cst)[i]) = infix_asdt(i_to_c(greatest_factor_in_n(multi,
  n, i)), cst)))

axiom fcqtdef733 :
  (forall multi:int. forall n:int. forall i:int. ((fc730(multi,
  n)[i]) = cpower(i_to_c(greatest_factor_in_n(multi, n, i)), 2)))

axiom greatest_factor_sum_in_n :
  (forall multi:int. forall n:int. forall cst:complex. ((0 <  n) ->
  (((0 <  multi) and (multi <  power(2, n))) -> (sum(to_fset(0, multi),
  fc729(multi, n, cst)) = infix_asdt(i_to_c(power(2, n)), cst)))))

axiom greatest_factor_sum_in_n1 :
  (forall multi:int. forall n:int. ((0 <  n) -> (((0 <  multi) and
  (multi <  power(2, n))) -> infix_lseqdt(cpower(i_to_c(power(2, n)), 2),
  infix_asdt(sum(to_fset(0, multi), fc730(multi, n)), i_to_c(multi))))))

axiom antirefl_co_prime : (forall a:int. ((1 <  a) -> (not co_prime(a, a))))

logic min_filter_b : int, int, (int,bool) farray -> int

axiom min_filter_bqtdef :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  ((exists e:int. (((i <= e) and (e <  j)) and ((p[e]) = true))) ->
  (((p[i]) = true) -> (min_filter_b(i, j, p) = i))))

axiom min_filter_bqtdef1 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  ((exists e:int. (((i <= e) and (e <  j)) and ((p[e]) = true))) ->
  ((not ((p[i]) = true)) -> (min_filter_b(i, j, p) = min_filter_b((i + 1), j,
  p)))))

axiom min_filter_bqtspec :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  ((exists e:int. (((i <= e) and (e <  j)) and ((p[e]) = true))) ->
  (min_filter_b(i, j, p) = min_filter(to_fset(i, j), p))))

axiom min_filter_bqtspec1 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  ((exists e:int. (((i <= e) and (e <  j)) and ((p[e]) = true))) ->
  ((p[min_filter_b(i, j, p)]) = true)))

axiom min_filter_bqtspec2 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  ((exists e:int. (((i <= e) and (e <  j)) and ((p[e]) = true))) ->
  (i <= min_filter_b(i, j, p))))

axiom min_filter_bqtspec3 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  ((exists e:int. (((i <= e) and (e <  j)) and ((p[e]) = true))) ->
  (min_filter_b(i, j, p) <  j)))

axiom min_filter_bqtspec4 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  ((exists e:int. (((i <= e) and (e <  j)) and ((p[e]) = true))) ->
  (forall e:int. (((i <= e) and (e <  j)) -> (((p[e]) = true) ->
  (min_filter_b(i, j, p) <= e))))))

axiom min_filter_bqtspec5 :
  (forall i:int. forall j:int. forall p:(int,bool) farray.
  ((exists e:int. (((i <= e) and (e <  j)) and ((p[e]) = true))) ->
  (forall e:int. (((i <= e) and (e <  j)) -> ((e <  min_filter_b(i, j, p)) ->
  (not ((p[e]) = true)))))))

logic euler_phi : int -> int

axiom euler_phiqtdef :
  (forall i:int. ((0 <  i) -> (euler_phi(i) = cardinal(co_primes(i)))))

axiom euler_phiqtspec :
  (forall i:int. ((0 <  i) -> ((1 <  i) -> mem(euler_phi(i), to_fset(1,
  i)))))

axiom injec_mult_mod_pre :
  (forall a:int. forall i:int. forall iqt:int. forall bound:int. (co_prime(a,
  bound) -> (((0 <= i) and ((i <  iqt) and (iqt <  bound))) ->
  (not (((i * a) % bound) = ((iqt * a) % bound))))))

axiom injec_mult_mod :
  (forall a:int. forall i:int. forall iqt:int. forall bound:int. (co_prime(a,
  bound) -> (((0 <= i) and (i <  bound)) -> (((0 <= iqt) and
  (iqt <  bound)) -> ((not (i = iqt)) ->
  (not (((i * a) % bound) = ((iqt * a) % bound))))))))

axiom co_prime_mod_mult :
  (forall a:int. forall e:int. forall bound:int. ((0 <  a) -> ((0 <  e) ->
  ((1 <  bound) -> (co_prime(a, bound) -> (co_prime(e, bound) ->
  co_prime(((a * e) % bound), bound)))))))

logic fc731 : int, int -> (int,int) farray

logic fc732 : int, int -> (int,int) farray

axiom fcqtdef734 :
  (forall a:int. forall bound:int. forall i:int. ((fc731(a,
  bound)[i]) = ((a * i) % bound)))

axiom fcqtdef735 :
  (forall a:int. forall bound:int. forall i:int. ((fc732(a,
  bound)[i]) = ((a * i) % bound)))

axiom set_injec_mult_mod :
  (forall a:int. forall bound:int. ((1 <  bound) -> (co_prime(a, bound) ->
  p_bijective(fc731(a, bound), co_primes(bound), co_primes(bound)))))

axiom set_injec_mult_mod1 :
  (forall a:int. forall bound:int. ((1 <  bound) -> (co_prime(a, bound) ->
  (map(fc732(a, bound), co_primes(bound)) = co_primes(bound)))))

axiom injec_mult_mod_rev :
  (forall a:int. forall i:int. forall iqt:int. forall bound:int.
  ((1 <  bound) -> (co_prime(a, bound) -> (((0 <= i) and (i <  bound)) ->
  (((0 <= iqt) and (iqt <  bound)) ->
  ((((i * a) % bound) = ((iqt * a) % bound)) -> (i = iqt)))))))

predicate bezout_pred(pick: int, bound: int, k: int) =
  (exists a:int. exists b:int. (k = ((a * pick) + (b * bound))))

logic bezout_set : int, int -> int set

axiom bezout_setqtspec :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  mem(min_set(bezout_set(pick, bound)), divisors(pick))))

axiom bezout_setqtspec1 :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  mem(min_set(bezout_set(pick, bound)), divisors(bound))))

axiom bezout_setqtspec2 :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (0 <  cardinal(bezout_set(pick, bound)))))

axiom bezout_setqtspec3 :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (0 <= min_set(bezout_set(pick, bound)))))

axiom bezout_setqtspec4 :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (min_set(bezout_set(pick, bound)) <= pick)))

axiom bezout_setqtspec5 :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (0 <= min_set(bezout_set(pick, bound)))))

axiom bezout_setqtspec6 :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (min_set(bezout_set(pick, bound)) <  bound)))

axiom euler_theorem :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (co_prime(pick, bound) -> ((power(pick, euler_phi(bound)) % bound) = 1))))

logic modular_inverse : int, int -> int

logic result90 : int, int -> (int,bool) farray

axiom resultqtdef101 :
  (forall pick:int. forall bound:int. forall i:int. (((result90(pick,
  bound)[i]) = true) -> (((i * pick) % bound) = 1)))

axiom resultqtdef102 :
  (forall pick:int. forall bound:int. forall i:int.
  ((((i * pick) % bound) = 1) -> ((result90(pick, bound)[i]) = true)))

axiom modular_inverseqtdef :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (co_prime(pick, bound) -> (modular_inverse(pick, bound) = min_filter_b(0,
  bound, result90(pick, bound))))))

axiom modular_inverseqtspec :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (co_prime(pick, bound) -> (0 <= modular_inverse(pick, bound)))))

axiom modular_inverseqtspec1 :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (co_prime(pick, bound) -> (modular_inverse(pick, bound) <  bound))))

axiom modular_inverseqtspec2 :
  (forall pick:int. forall bound:int. (((0 <  pick) and (pick <  bound)) ->
  (co_prime(pick, bound) -> (((modular_inverse(pick,
  bound) * pick) % bound) = 1))))

logic multi_order : int, int -> int

logic result91 : int, int -> (int,bool) farray

axiom resultqtdef103 :
  (forall pick:int. forall bound:int. forall i:int. (((result91(pick,
  bound)[i]) = true) -> ((power(pick, i) % bound) = 1)))

axiom resultqtdef104 :
  (forall pick:int. forall bound:int. forall i:int. (((power(pick,
  i) % bound) = 1) -> ((result91(pick, bound)[i]) = true)))

axiom multi_orderqtdef :
  (forall pick:int. forall bound:int. (co_prime(pick, bound) ->
  (((0 <  pick) and (pick <  bound)) -> (multi_order(pick,
  bound) = min_filter_b(1, bound, result91(pick, bound))))))

axiom multi_orderqtspec :
  (forall pick:int. forall bound:int. (co_prime(pick, bound) ->
  (((0 <  pick) and (pick <  bound)) -> (1 <= multi_order(pick, bound)))))

axiom multi_orderqtspec1 :
  (forall pick:int. forall bound:int. (co_prime(pick, bound) ->
  (((0 <  pick) and (pick <  bound)) -> (multi_order(pick,
  bound) <  bound))))

axiom multi_orderqtspec2 :
  (forall pick:int. forall bound:int. (co_prime(pick, bound) ->
  (((0 <  pick) and (pick <  bound)) -> ((power(pick, multi_order(pick,
  bound)) % bound) = 1))))

axiom modular_expo :
  (forall a:int. forall k:int. forall bound:int. forall i:int. ((0 <= i) ->
  (((0 <  a) and (a <  bound)) -> ((0 <= k) -> (co_prime(a, bound) ->
  ((2 <= bound) -> ((power(a, i) % bound) = (power(a, ((k * multi_order(a,
  bound)) + i)) % bound))))))))

axiom modular_expo_gen :
  (forall a:int. forall bound:int. (((0 <  a) and (a <  bound)) ->
  (co_prime(a, bound) ->
  (forall i:int. forall k:int. ((0 <= i) -> ((0 <= k) -> ((power(a,
  i) % bound) = (power(a, ((k * multi_order(a, bound)) + i)) % bound))))))))

axiom modular_expo_rev :
  (forall a:int. forall k:int. forall bound:int. forall i:int. (((0 <  a) and
  (a <  bound)) -> ((0 <= i) -> ((0 <= k) -> (co_prime(a, bound) ->
  ((power(a, ((k * multi_order(a, bound)) + i)) % bound) = (power(a,
  i) % bound)))))))

axiom modular_expo_gen_rev :
  (forall a:int. forall bound:int. (((0 <  a) and (a <  bound)) ->
  (co_prime(a, bound) ->
  (forall i:int. forall k:int. ((0 <= i) -> ((0 <= k) -> ((power(a,
  ((k * multi_order(a, bound)) + i)) % bound) = (power(a, i) % bound))))))))

axiom modular_expo_modulo :
  (forall pick:int. forall bound:int. forall i:int. (co_prime(pick, bound) ->
  (((0 <  pick) and (pick <  bound)) -> ((0 <= i) -> ((power(pick,
  i) % bound) = (power(pick, (i % multi_order(pick, bound))) % bound))))))

axiom modular_expo_modulo_rev :
  (forall pick:int. forall bound:int. forall i:int. (co_prime(pick, bound) ->
  (((0 <  pick) and (pick <  bound)) -> ((0 <= i) -> ((power(pick,
  (i % multi_order(pick, bound))) % bound) = (power(pick, i) % bound))))))

axiom injec_mod_prod_multi_order_pre :
  (forall pick:int. forall bound:int. forall i:int. forall iqt:int.
  (co_prime(pick, bound) -> (((0 <  pick) and (pick <  bound)) -> (mem(i,
  to_fset(0, multi_order(pick, bound))) -> (mem(iqt, to_fset(0,
  multi_order(pick, bound))) -> ((i <  iqt) -> (not ((power(pick,
  iqt) % bound) = (power(pick, i) % bound)))))))))

axiom injec_mod_prod_multi_order :
  (forall pick:int. forall bound:int. forall i:int. forall iqt:int.
  (co_prime(pick, bound) -> (((0 <  pick) and (pick <  bound)) -> (mem(i,
  to_fset(0, multi_order(pick, bound))) -> (mem(iqt, to_fset(0,
  multi_order(pick, bound))) -> ((not (i = iqt)) -> (not ((power(pick,
  iqt) % bound) = (power(pick, i) % bound)))))))))

axiom injec_mod_prod_multi_order_gen :
  (forall pick:int. forall bound:int. forall i:int. forall iqt:int.
  (co_prime(pick, bound) -> (((0 <  pick) and (pick <  bound)) ->
  ((not ((i % multi_order(pick, bound)) = (iqt % multi_order(pick,
  bound)))) -> ((0 <= i) -> ((0 <= iqt) -> (not ((power(pick,
  iqt) % bound) = (power(pick, i) % bound)))))))))

axiom mod_eq_power_to_multi_order :
  (forall pick:int. forall bound:int. forall i:int. forall iqt:int.
  (co_prime(pick, bound) -> (((0 <  pick) and (pick <  bound)) ->
  ((0 <= i) -> ((0 <= iqt) -> (((power(pick, iqt) % bound) = (power(pick,
  i) % bound)) -> ((i % multi_order(pick, bound)) = (iqt % multi_order(pick,
  bound)))))))))

axiom mod_eq_multi_order_to_power :
  (forall pick:int. forall bound:int. forall i:int. forall iqt:int.
  (co_prime(pick, bound) -> (((0 <  pick) and (pick <  bound)) ->
  ((0 <= i) -> ((0 <= iqt) -> (((i % multi_order(pick,
  bound)) = (iqt % multi_order(pick, bound))) -> ((power(pick,
  iqt) % bound) = (power(pick, i) % bound))))))))

type shor_

logic composite : shor_ -> int

logic compos_log : shor_ -> int

logic picked : shor_ -> int

axiom shor_qtinvariant :
  (forall self:shor_ [picked(self)| compos_log(self)| composite(self)].
  (0 <  compos_log(self)))

axiom shor_qtinvariant1 :
  (forall self:shor_ [picked(self)| compos_log(self)| composite(self)].
  (1 <  picked(self)))

axiom shor_qtinvariant2 :
  (forall self:shor_ [picked(self)| compos_log(self)| composite(self)].
  (picked(self) <  composite(self)))

axiom shor_qtinvariant3 :
  (forall self:shor_ [picked(self)| compos_log(self)| composite(self)].
  (power(2, (compos_log(self) - 1)) <= composite(self)))

axiom shor_qtinvariant4 :
  (forall self:shor_ [picked(self)| compos_log(self)| composite(self)].
  (composite(self) <  power(2, compos_log(self))))

axiom shor_qtinvariant5 :
  (forall self:shor_ [picked(self)| compos_log(self)| composite(self)].
  co_prime(picked(self), composite(self)))

axiom shor_qtinvariant6 :
  (forall self:shor_ [picked(self)| compos_log(self)| composite(self)].
  (0 <  compos_log(self)))

logic s1 : unit -> shor_ ref

axiom bound_inf : (0 <  composite((s1(void)).contents))

axiom bound_inf1 : (1 <  composite((s1(void)).contents))

logic pre_adder_const_ : bitvec -> circuit1

logic fc733 : bitvec, (int,int) farray, int -> (int,angle) farray

logic fc734 : bitvec, (int,int) farray -> (int,angle) farray

axiom fcqtdef736 :
  (forall y:bitvec. forall x:(int,int) farray. forall target:int.
  forall k:int. ((fc733(y, x,
  target)[k]) = infix_sldtsl((((value(y)[k]) * (x[target])) * power(2,
  ((compos_log((s1(void)).contents) - k) + (compos_log((s1(void)).contents) - target)))),
  (compos_log((s1(void)).contents) + 1))))

axiom fcqtdef737 :
  (forall y:bitvec. forall x:(int,int) farray. forall target:int. ((fc734(y,
  x)[target]) = ang_sum(fc733(y, x, target),
  (compos_log((s1(void)).contents) - target),
  (compos_log((s1(void)).contents) + 1))))

axiom pre_adder_const_qtspec :
  (forall y:bitvec. ((length(y) = (compos_log((s1(void)).contents) + 1)) ->
  (width1(pre_adder_const_(y)) = (compos_log((s1(void)).contents) + 1))))

axiom pre_adder_const_qtspec1 :
  (forall y:bitvec. ((length(y) = (compos_log((s1(void)).contents) + 1)) ->
  (forall x:(int,int) farray. forall z:(int,int) farray. (binary_l(x,
  (compos_log((s1(void)).contents) + 1)) -> (ang_ind1(pre_adder_const_(y), x,
  z) = ang_sum(fc734(y, x), 0, (compos_log((s1(void)).contents) + 1)))))))

axiom pre_adder_const_qtspec2 :
  (forall y:bitvec. ((length(y) = (compos_log((s1(void)).contents) + 1)) ->
  (forall x:bitvec. forall z:bitvec.
  ((length(x) = (compos_log((s1(void)).contents) + 1)) ->
  (ang_ind1(pre_adder_const_(y), value(x),
  value(z)) = infix_sldtsl((bv_to_int(x) * bv_to_int(y)),
  (compos_log((s1(void)).contents) + 1)))))))

axiom pre_adder_const_qtspec3 :
  (forall y:bitvec. ((length(y) = (compos_log((s1(void)).contents) + 1)) ->
  (forall x:(int,int) farray. forall z:(int,int) farray. forall i:int.
  (binary_l(x, (compos_log((s1(void)).contents) + 1)) -> (((0 <= i) and
  (i <  (compos_log((s1(void)).contents) + 1))) ->
  (basis_ket1(pre_adder_const_(y), x, z, i) = (x[i])))))))

axiom pre_adder_const_qtspec4 :
  (forall y:bitvec. ((length(y) = (compos_log((s1(void)).contents) + 1)) ->
  (range1(pre_adder_const_(y)) = 0)))

axiom pre_adder_const_qtspec5 :
  (forall y:bitvec. ((length(y) = (compos_log((s1(void)).contents) + 1)) ->
  (forall x:bitvec. ((length(x) = (compos_log((s1(void)).contents) + 1)) ->
  (path_sem1(pre_adder_const_(y),
  bv_to_ket(x)) = infix_asdtdt(int_qft_coeff(bv_to_int(y), bv_to_int(x),
  (compos_log((s1(void)).contents) + 1)), bv_to_ket(x)))))))

axiom pre_adder_const_qtspec6 :
  (forall y:bitvec. ((length(y) = (compos_log((s1(void)).contents) + 1)) ->
  (ancillas1(pre_adder_const_(y)) = 0)))

function add_in_qft(added: int) : circuit1 =
  pre_adder_const_(int_to_bv((added % power(2,
  (compos_log((s1(void)).contents) + 1))),
  (compos_log((s1(void)).contents) + 1)))

axiom add_in_qftqtspec :
  (forall added:int.
  (width1(add_in_qft(added)) = (compos_log((s1(void)).contents) + 1)))

axiom add_in_qftqtspec1 :
  (forall added:int.
  (forall b:int. (path_sem1(add_in_qft(added),
  apply_qft((compos_log((s1(void)).contents) + 1),
  b)) = apply_qft((compos_log((s1(void)).contents) + 1), (added + b)))))

axiom add_in_qftqtspec2 :
  (forall added:int.
  (width1(add_in_qft(added)) = (compos_log((s1(void)).contents) + 1)))

axiom add_in_qftqtspec3 :
  (forall added:int. (ancillas1(add_in_qft(added)) = 0))

logic place_add_in_qft : int, int -> circuit1

axiom place_add_in_qftqtdef :
  (forall added:int. forall k:int. ((0 <  k) -> (place_add_in_qft(added,
  k) = place1(add_in_qft(added), 0,
  ((compos_log((s1(void)).contents) + 1) + k)))))

axiom place_add_in_qftqtspec :
  (forall added:int. forall k:int. ((0 <  k) ->
  (width1(place_add_in_qft(added,
  k)) = ((compos_log((s1(void)).contents) + 1) + k))))

axiom place_add_in_qftqtspec1 :
  (forall added:int. forall k:int. ((0 <  k) ->
  (forall b:int.
  (forall y:complex matrix. (is_a_ket_l(y, k) ->
  (path_sem1(place_add_in_qft(added, k),
  kronecker(apply_qft((compos_log((s1(void)).contents) + 1), b),
  y)) = kronecker(apply_qft((compos_log((s1(void)).contents) + 1),
  (b + added)), y)))))))

axiom place_add_in_qftqtspec2 :
  (forall added:int. forall k:int. ((0 <  k) ->
  (width1(place_add_in_qft(added,
  k)) = ((compos_log((s1(void)).contents) + 1) + k))))

axiom place_add_in_qftqtspec3 :
  (forall added:int. forall k:int. ((0 <  k) ->
  (ancillas1(place_add_in_qft(added, k)) = 0)))

logic place_add_in_comput_basis : int, int -> circuit1

logic result92 : int -> (int,int) farray

axiom resultqtdef105 :
  (forall added:int. forall i:int.
  ((result92(added)[i]) = ((i + added) % power(2,
  (compos_log((s1(void)).contents) + 1)))))

axiom place_add_in_comput_basisqtdef :
  (forall added:int. forall size_reg:int.
  (((compos_log((s1(void)).contents) + 1) <  size_reg) ->
  (place_add_in_comput_basis(added,
  size_reg) = apply_function_in_qft_basis_zero(place_add_in_qft(added,
  ((size_reg - compos_log((s1(void)).contents)) - 1)),
  (compos_log((s1(void)).contents) + 1), size_reg, result92(added)))))

axiom place_add_in_comput_basisqtspec :
  (forall added:int. forall size_reg:int.
  (((compos_log((s1(void)).contents) + 1) <  size_reg) ->
  (width1(place_add_in_comput_basis(added, size_reg)) = size_reg)))

axiom place_add_in_comput_basisqtspec1 :
  (forall added:int. forall size_reg:int.
  (((compos_log((s1(void)).contents) + 1) <  size_reg) ->
  (forall b:int.
  (forall z:complex matrix. (((0 <= b) and (b <  power(2,
  (compos_log((s1(void)).contents) + 1)))) -> (is_a_ket_l(z,
  ((size_reg - compos_log((s1(void)).contents)) - 1)) ->
  (path_sem1(place_add_in_comput_basis(added, size_reg),
  kronecker(ket((compos_log((s1(void)).contents) + 1), b),
  z)) = kronecker(ket((compos_log((s1(void)).contents) + 1),
  ((b + added) % power(2, (compos_log((s1(void)).contents) + 1)))), z))))))))

axiom place_add_in_comput_basisqtspec2 :
  (forall added:int. forall size_reg:int.
  (((compos_log((s1(void)).contents) + 1) <  size_reg) ->
  (width1(place_add_in_comput_basis(added, size_reg)) = size_reg)))

axiom place_add_in_comput_basisqtspec3 :
  (forall added:int. forall size_reg:int.
  (((compos_log((s1(void)).contents) + 1) <  size_reg) ->
  (ancillas1(place_add_in_comput_basis(added, size_reg)) = 0)))

logic div_bound : int, int -> int

axiom div_boundqtdef :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> (div_bound(added,
  value1) = ((value1 + added) / composite((s1(void)).contents))))))

axiom div_boundqtspec :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> (0 <= div_bound(added,
  value1)))))

axiom div_boundqtspec1 :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> (div_bound(added,
  value1) <  2))))

axiom div_boundqtspec2 :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> ((div_bound(added,
  value1) = 0) ->
  ((((value1 + added) - composite((s1(void)).contents)) % power(2,
  (compos_log((s1(void)).contents) + 1))) = (power(2,
  (compos_log((s1(void)).contents) + 1)) + ((value1 + added) - composite((s1(void)).contents))))))))

axiom div_boundqtspec3 :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> ((div_bound(added,
  value1) = 0) -> (power(2,
  compos_log((s1(void)).contents)) <= (((value1 + added) - composite((s1(void)).contents)) % power(2,
  (compos_log((s1(void)).contents) + 1))))))))

axiom div_boundqtspec4 :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> ((div_bound(added,
  value1) = 0) ->
  ((((value1 + added) - composite((s1(void)).contents)) % power(2,
  (compos_log((s1(void)).contents) + 1))) <  power(2,
  (compos_log((s1(void)).contents) + 1)))))))

axiom div_boundqtspec5 :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> ((div_bound(added,
  value1) = 1) ->
  (((value1 + added) % composite((s1(void)).contents)) = ((value1 + added) - composite((s1(void)).contents)))))))

axiom div_boundqtspec6 :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> ((div_bound(added,
  value1) = 1) ->
  ((((value1 + added) - composite((s1(void)).contents)) % power(2,
  (compos_log((s1(void)).contents) + 1))) = ((value1 + added) - composite((s1(void)).contents)))))))

axiom div_boundqtspec7 :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> ((div_bound(added,
  value1) = 1) ->
  (0 <= (((value1 + added) - composite((s1(void)).contents)) % power(2,
  (compos_log((s1(void)).contents) + 1))))))))

axiom div_boundqtspec8 :
  (forall added:int. forall value1:int. (((0 <= added) and
  (added <  composite((s1(void)).contents))) -> (((0 <= value1) and
  (value1 <  composite((s1(void)).contents))) -> ((div_bound(added,
  value1) = 1) ->
  ((((value1 + added) - composite((s1(void)).contents)) % power(2,
  (compos_log((s1(void)).contents) + 1))) <  power(2,
  compos_log((s1(void)).contents)))))))

axiom cdiv_cases :
  (forall n:int. forall d:int [div(n, d)]. ((0 <= n) -> ((0 <  d) -> (div(n,
  d) = (n / d)))))

axiom cdiv_cases1 :
  (forall n:int. forall d:int [div(n, d)]. ((n <= 0) -> ((0 <  d) -> (div(n,
  d) = (-((-n) / d))))))

axiom cdiv_cases2 :
  (forall n:int. forall d:int [div(n, d)]. ((0 <= n) -> ((d <  0) -> (div(n,
  d) = (-(n / (-d)))))))

axiom cdiv_cases3 :
  (forall n:int. forall d:int [div(n, d)]. ((n <= 0) -> ((d <  0) -> (div(n,
  d) = ((-n) / (-d))))))

axiom cmod_cases :
  (forall n:int. forall d:int [mod(n, d)]. ((0 <= n) -> ((0 <  d) -> (mod(n,
  d) = (n % d)))))

axiom cmod_cases1 :
  (forall n:int. forall d:int [mod(n, d)]. ((n <= 0) -> ((0 <  d) -> (mod(n,
  d) = (-((-n) % d))))))

axiom cmod_cases2 :
  (forall n:int. forall d:int [mod(n, d)]. ((0 <= n) -> ((d <  0) -> (mod(n,
  d) = (n % (-d))))))

axiom cmod_cases3 :
  (forall n:int. forall d:int [mod(n, d)]. ((n <= 0) -> ((d <  0) -> (mod(n,
  d) = (-((-n) % (-d)))))))

goal ket_l_two_n_plus_twoqtvc :
  (forall a:complex matrix. forall b:complex matrix. forall c:complex matrix.
  ((is_a_ket_l(a, compos_log((s1(void)).contents)) and (is_a_ket_l(b,
  (compos_log((s1(void)).contents) + 1)) and is_a_ket_l(c, 1))) -> (let o =
  (compos_log((s1(void)).contents) + 1) : int in (((0 <= o) and ((0 <= 1) and
  (is_a_ket_l(b, o) and is_a_ket_l(c, 1)))) and (is_a_ket_l(kronecker(b, c),
  (o + 1)) -> (let o1 = (compos_log((s1(void)).contents) + 2) : int in
  (let o2 = compos_log((s1(void)).contents) : int in (let o3 = kronecker(b,
  c) : complex matrix in (((rows(o3) = (rows(b) * rows(c))) and
  ((columns(o3) = (columns(b) * columns(c))) and
  (forall i:int. forall j:int. (valid_index(o3, i, j) -> (get(o3, i,
  j) = infix_asdt(get(b, (i / rows(c)), (j / columns(c))), get(c,
  (i % rows(c)), (j % columns(c))))))))) -> (((0 <= o2) and ((0 <= o1) and
  (is_a_ket_l(a, o2) and is_a_ket_l(o3, o1)))) and (is_a_ket_l(kronecker(a,
  o3), (o2 + o1)) -> is_a_ket_l(kronecker(a, kronecker(b, c)),
  ((2 * compos_log((s1(void)).contents)) + 2)))))))))))))
