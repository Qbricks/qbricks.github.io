%%% this is a prelude for CVC3 
%%% this is a prelude for CVC3 real arithmetic
div_by_zero: (REAL) -> REAL;
%%% this is a prelude for CVC3 integer arithmetic
uni : TYPE;

ty : TYPE;

sort: (ty, uni) -> BOOLEAN;

witness: (ty) -> uni;

% witness_sort
  ASSERT (FORALL (a : ty): (sort(a, witness(a))));

int: ty;

real: ty;

string : TYPE;

string1: ty;

bool: ty;

match_bool: (ty, BITVECTOR(1), uni, uni) -> uni;

% match_bool_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : BITVECTOR(1), x1 : uni, x2 : uni): (sort(a, match_bool(a, x,
  x1, x2)))));

% match_bool_True
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni):
  ((sort(a, z)) => (match_bool(a, 0bin1, z, z1) = z))));

% match_bool_False
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni):
  ((sort(a, z1)) => (match_bool(a, 0bin0, z, z1) = z1))));

index_bool: (BITVECTOR(1)) -> INT;

% index_bool_True
  ASSERT (index_bool(0bin1) = 0);

% index_bool_False
  ASSERT (index_bool(0bin0) = 1);

% bool_inversion
  ASSERT (FORALL (u : BITVECTOR(1)): ((u = 0bin1) OR (u = 0bin0)));

tuple0 : TYPE;

tuple01: ty;

Tuple0: tuple0;

% tuple0_inversion
  ASSERT (FORALL (u : tuple0): (u = Tuple0));

infix_eqeq: (ty, uni, uni) -> BOOLEAN;

% infix =='spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, b : uni):
  ((sort(a, a1)) => ((sort(a, b)) => ((infix_eqeq(a, a1, b)) <=> (a1 = b))))));

% assert_equal
  ASSERT TRUE;

% goal_comm
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, b : uni):
  ((sort(a, a1)) => ((sort(a, b)) => ((a1 = b) => (b = a1))))));

complex : TYPE;

complex1: ty;

t2tb: (complex) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : complex): (sort(complex1, t2tb(x))));

tb2t: (uni) -> complex;

% BridgeL
  ASSERT (FORALL (i : complex):PATTERN (t2tb(i)):  (tb2t(t2tb(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb(tb2t(j))): 
  ((sort(complex1, j)) => (t2tb(tb2t(j)) = j)));

% teq'spec
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_eqeq(complex1, t2tb(x), t2tb(y))) <=> (x = y)));

c_zero: complex;

c_one: complex;

prefix_mndt: (complex) -> complex;

infix_pldt: (complex, complex) -> complex;

infix_asdt: (complex, complex) -> complex;

inv: (complex) -> complex;

% Assoc
  ASSERT
  (FORALL (x : complex, y : complex, z : complex): (infix_pldt(infix_pldt(x,
  y), z) = infix_pldt(x, infix_pldt(y, z))));

% Unit_def_l
  ASSERT (FORALL (x : complex): (infix_pldt(c_zero, x) = x));

% Unit_def_r
  ASSERT (FORALL (x : complex): (infix_pldt(x, c_zero) = x));

% Inv_def_l
  ASSERT (FORALL (x : complex): (infix_pldt(prefix_mndt(x), x) = c_zero));

% Inv_def_r
  ASSERT (FORALL (x : complex): (infix_pldt(x, prefix_mndt(x)) = c_zero));

% Comm
  ASSERT
  (FORALL (x : complex, y : complex): (infix_pldt(x, y) = infix_pldt(y, x)));

% Assoc
  ASSERT
  (FORALL (x : complex, y : complex, z : complex): (infix_asdt(infix_asdt(x,
  y), z) = infix_asdt(x, infix_asdt(y, z))));

% Mul_distr_l
  ASSERT
  (FORALL (x : complex, y : complex, z : complex): (infix_asdt(x, 
  infix_pldt(y, z)) = infix_pldt(infix_asdt(x, y), infix_asdt(x, z))));

% Mul_distr_r
  ASSERT
  (FORALL (x : complex, y : complex, z : complex): (infix_asdt(infix_pldt(y,
  z), x) = infix_pldt(infix_asdt(y, x), infix_asdt(z, x))));

% Comm
  ASSERT
  (FORALL (x : complex, y : complex): (infix_asdt(x, y) = infix_asdt(y, x)));

% Unitary
  ASSERT (FORALL (x : complex): (infix_asdt(c_one, x) = x));

% NonTrivialRing
  ASSERT (NOT (c_zero = c_one));

% Inverse
  ASSERT
  (FORALL (x : complex):
  ((NOT (x = c_zero)) => (infix_asdt(x, inv(x)) = c_one)));

infix_mn: (complex, complex) -> complex;

% infix -'def
  ASSERT
  (FORALL (x : complex, y : complex): (infix_mn(x, y) = infix_pldt(x, 
  prefix_mndt(y))));

infix_sl: (complex, complex) -> complex;

% infix /'def
  ASSERT
  (FORALL (x : complex, y : complex): (infix_sl(x, y) = infix_asdt(x, 
  inv(y))));

% add_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (z = c_zero)) => (infix_sl(infix_pldt(x, y), z) = infix_pldt(
  infix_sl(x, z), infix_sl(y, z)))));

% sub_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (z = c_zero)) => (infix_sl(infix_mn(x, y), z) = infix_mn(infix_sl(x,
  z), infix_sl(y, z)))));

% neg_div
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (y = c_zero)) => (infix_sl(prefix_mndt(x), y) = prefix_mndt(
  infix_sl(x, y)))));

% assoc_mul_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (z = c_zero)) => (infix_sl(infix_asdt(x, y), z) = infix_asdt(x, 
  infix_sl(y, z)))));

% assoc_div_mul
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  (((NOT (y = c_zero)) AND (NOT (z = c_zero))) => (infix_sl(infix_sl(x, y),
  z) = infix_sl(x, infix_asdt(y, z)))));

% assoc_div_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  (((NOT (y = c_zero)) AND (NOT (z = c_zero))) => (infix_sl(x, infix_sl(y,
  z)) = infix_sl(infix_asdt(x, z), y))));

infix_mndt: (complex, complex) -> complex;

% infix -.'def
  ASSERT
  (FORALL (x : complex, y : complex): (infix_mndt(x, y) = infix_pldt(x, 
  prefix_mndt(y))));

infix_sldt: (complex, complex) -> complex;

% infix /.'def
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (y = c_zero)) => (infix_sldt(x, y) = infix_asdt(x, inv(y)))));

% infix /.'spec
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (y = c_zero)) => (infix_sldt(x, y) = infix_asdt(x, inv(y)))));

% add_div
  ASSERT
  (FORALL (x : REAL, y : REAL, z : REAL):
  ((NOT (z = 0))
  => ((IF (z = 0) THEN (div_by_zero((x + y))) ELSE ((x + y) / z) ENDIF) = ((IF (z = 0) THEN (div_by_zero(x)) ELSE (x / z) ENDIF) + (IF (z = 0) THEN (div_by_zero(y)) ELSE (y / z) ENDIF)))));

% sub_div
  ASSERT
  (FORALL (x : REAL, y : REAL, z : REAL):
  ((NOT (z = 0))
  => ((IF (z = 0) THEN (div_by_zero((x - y))) ELSE ((x - y) / z) ENDIF) = ((IF (z = 0) THEN (div_by_zero(x)) ELSE (x / z) ENDIF) - (IF (z = 0) THEN (div_by_zero(y)) ELSE (y / z) ENDIF)))));

% neg_div
  ASSERT
  (FORALL (x : REAL, y : REAL):
  ((NOT (y = 0))
  => ((IF (y = 0) THEN (div_by_zero((- x))) ELSE ((- x) / y) ENDIF) = (- (IF (y = 0) THEN (div_by_zero(x)) ELSE (x / y) ENDIF)))));

% assoc_mul_div
  ASSERT
  (FORALL (x : REAL, y : REAL, z : REAL):
  ((NOT (z = 0))
  => ((IF (z = 0) THEN (div_by_zero((x * y))) ELSE ((x * y) / z) ENDIF) = (x * (IF (z = 0) THEN (div_by_zero(y)) ELSE (y / z) ENDIF)))));

% assoc_div_mul
  ASSERT
  (FORALL (x : REAL, y : REAL, z : REAL):
  (((NOT (y = 0)) AND (NOT (z = 0)))
  => ((IF (z = 0) THEN (div_by_zero((IF (y = 0) THEN (div_by_zero(x)) ELSE (x / y) ENDIF))) ELSE ((IF (y = 0) THEN (div_by_zero(x)) ELSE (x / y) ENDIF) / z) ENDIF) = (IF ((y * z) = 0) THEN (div_by_zero(x)) ELSE (x / (y * z)) ENDIF))));

% assoc_div_div
  ASSERT
  (FORALL (x : REAL, y : REAL, z : REAL):
  (((NOT (y = 0)) AND (NOT (z = 0)))
  => ((IF ((IF (z = 0) THEN (div_by_zero(y)) ELSE (y / z) ENDIF) = 0) THEN (div_by_zero(x)) ELSE (x / (IF (z = 0) THEN (div_by_zero(y)) ELSE (y / z) ENDIF)) ENDIF) = (IF (y = 0) THEN (div_by_zero((x * z))) ELSE ((x * z) / y) ENDIF))));

% CompatOrderMult
  ASSERT
  (FORALL (x : REAL, y : REAL, z : REAL):
  ((x <= y) => ((0 <= z) => ((x * z) <= (y * z)))));

infix_slas: (REAL, REAL) -> REAL;

% infix /*'def
  ASSERT
  (FORALL (x : REAL, y : REAL):
  ((NOT (y = 0)) => (infix_slas(x,
  y) = (IF (y = 0) THEN (div_by_zero(x)) ELSE (x / y) ENDIF))));

t2tb1: (REAL) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : REAL): (sort(real, t2tb1(x))));

tb2t1: (uni) -> REAL;

% BridgeL
  ASSERT (FORALL (i : REAL):PATTERN (t2tb1(i)):  (tb2t1(t2tb1(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb1(tb2t1(j))):  (t2tb1(tb2t1(j)) = j));

% infix =*'spec
  ASSERT
  (FORALL (x : REAL, y : REAL):
  ((infix_eqeq(real, t2tb1(x), t2tb1(y))) <=> (x = y)));

infix_lsgtas: (REAL, REAL) -> BOOLEAN;

% infix <>*'def
  ASSERT
  (FORALL (x : REAL, y : REAL):
  ((infix_lsgtas(x, y)) <=> (NOT (infix_eqeq(real, t2tb1(x), t2tb1(y))))));

% infix <>*'spec
  ASSERT
  (FORALL (x : REAL, y : REAL): ((infix_lsgtas(x, y)) <=> (NOT (x = y))));

infix_lsas: (REAL, REAL) -> BOOLEAN;

% infix <*'def
  ASSERT
  (FORALL (x : REAL, y : REAL):
  ((infix_lsas(x, y)) <=> ((x <= y) AND (infix_lsgtas(x, y)))));

% CompatOrderMult
  ASSERT
  (FORALL (x : INT, y : INT, z : INT):
  ((x <= y) => ((0 <= z) => ((x * z) <= (y * z)))));

% Injective
  ASSERT (FORALL (x : INT, y : INT): ((x = y) => (x = y)));

% Monotonic
  ASSERT (FORALL (x : INT, y : INT): ((x <= y) => (x <= y)));

from_int: (INT) -> REAL;

% from_int'spec
  ASSERT (FORALL (x : INT): (from_int(x) = x));

% Zero
  ASSERT (from_int(0) = 0);

% Add
  ASSERT
  (FORALL (x : INT, y : INT): (from_int((x + y)) = (from_int(x) + 
  from_int(y))));

% One
  ASSERT (from_int(1) = 1);

% Sub
  ASSERT
  (FORALL (x : INT, y : INT): (from_int((x - y)) = (from_int(x) - 
  from_int(y))));

% mul_pos
  ASSERT
  (FORALL (x : INT, y : INT):
  ((0 <= y) => (from_int((x * y)) = (from_int(x) * from_int(y)))));

% mul
  ASSERT
  (FORALL (x : INT, y : INT):
  ((0 <= y) => (from_int((x * y)) = (from_int(x) * from_int(y)))));

% mul_rev
  ASSERT
  (FORALL (x : INT, y : INT):
  ((0 <= y) => ((from_int(x) * from_int(y)) = from_int((x * y)))));

% neg
  ASSERT (FORALL (x : INT): (from_int((- x)) = (- from_int(x))));

% injective
  ASSERT
  (FORALL (x : INT, y : INT): ((from_int(x) = from_int(y)) => (x = y)));

% Monotonic
  ASSERT
  (FORALL (x : INT, y : INT): ((x <= y) => (from_int(x) <= from_int(y))));

% positive_inv
  ASSERT
  (FORALL (x : REAL):
  ((infix_lsas(0, x)) => (infix_lsas(0, infix_slas(1, x)))));

% r_zeroLessOne
  ASSERT (0 <= 1);

% r_compatOrderAdd
  ASSERT
  (FORALL (x : REAL, y : REAL, z : REAL): ((x <= y) => ((x + z) <= (y + z))));

% r_compatOrderMult
  ASSERT
  (FORALL (x : REAL, y : REAL, z : REAL):
  ((x <= y) => ((0 <= z) => ((x * z) <= (y * z)))));

% inv_order
  ASSERT
  (FORALL (a : REAL, b : REAL):
  ((infix_lsas(0, a))
  => ((infix_lsas(0, b))
     => ((a <= b)
        => ((IF (b = 0) THEN (div_by_zero(1)) ELSE (1 / b) ENDIF) <= (IF (a = 0) THEN (div_by_zero(1)) ELSE (1 / a) ENDIF))))));

% inv_strict_order
  ASSERT
  (FORALL (a : REAL, b : REAL):
  ((infix_lsas(0, a))
  => ((infix_lsas(0, b))
     => ((infix_lsas(a, b))
        => (infix_lsas((IF (b = 0) THEN (div_by_zero(1)) ELSE (1 / b) ENDIF),
        (IF (a = 0) THEN (div_by_zero(1)) ELSE (1 / a) ENDIF)))))));

% invol_neg
  ASSERT (FORALL (a : complex): (prefix_mndt(prefix_mndt(a)) = a));

% injective_neg
  ASSERT
  (FORALL (a : complex, b : complex):
  ((prefix_mndt(a) = prefix_mndt(b)) => (a = b)));

% find_opposite
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_mndt(a, b) = c_zero) => (a = b)));

% div_as_mult_inv
  ASSERT
  (FORALL (a : complex, b : complex):
  ((NOT (a = c_zero)) => (infix_sldt(b, a) = infix_asdt(b, infix_sldt(c_one,
  a)))));

% add_opposite
  ASSERT (FORALL (a : complex): (infix_pldt(a, prefix_mndt(a)) = c_zero));

% opposite
  ASSERT (FORALL (a : complex): (infix_mndt(a, a) = c_zero));

% mult_num
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (c = c_zero)) => (infix_sldt(infix_asdt(a, b), c) = infix_asdt(a, 
  infix_sldt(b, c)))));

% div_rev
  ASSERT
  (FORALL (a : complex, b : complex):
  ((NOT (b = c_zero)) => (infix_asdt(a, infix_sldt(c_one, b)) = infix_sldt(a,
  b))));

% mult_div_num
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (c = c_zero)) => (infix_asdt(infix_sldt(a, c), b) = infix_sldt(
  infix_asdt(a, b), c))));

% mult_denom
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (c = c_zero))
  => ((NOT (b = c_zero)) => (infix_sldt(a, infix_asdt(b, c)) = infix_asdt(
     infix_sldt(a, b), infix_sldt(c_one, c))))));

% mult_simpl
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (c = c_zero))
  => ((NOT (b = c_zero)) => (infix_sldt(infix_asdt(a, b), infix_asdt(c,
     b)) = infix_sldt(a, c)))));

% dic_simpl
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (c = c_zero))
  => ((NOT (b = c_zero)) => (infix_asdt(infix_sldt(a, infix_asdt(c, b)),
     b) = infix_sldt(a, c)))));

% simpl_with_c_one
  ASSERT
  (FORALL (a : complex, b : complex):
  ((NOT (a = c_zero))
  => ((NOT (b = c_zero)) => (infix_asdt(infix_sldt(a, b), infix_sldt(c_one,
     a)) = infix_sldt(c_one, b)))));

% add_op
  ASSERT
  (FORALL (a1 : complex, a2 : complex):
  ((a1 = prefix_mndt(a2)) => (infix_pldt(a1, a2) = c_zero)));

% mult_eq_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b1 : complex, b2 : complex):
  ((a1 = a2) => ((b1 = b2) => (infix_asdt(a1, b1) = infix_asdt(a2, b2)))));

% mult_eq_t_rev
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b1 : complex, b2 : complex):
  ((a1 = a2) => ((b1 = b2) => (infix_asdt(a1, b1) = infix_asdt(b2, a2)))));

% mult_comm
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(a, b) = infix_asdt(b, a)));

% mult_assoc
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(infix_asdt(a,
  b), c) = infix_asdt(a, infix_asdt(b, c))));

% mult_abc_to_acb
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(infix_asdt(a,
  b), c) = infix_asdt(infix_asdt(a, c), b)));

% zero_mult_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex):
  ((a1 = c_zero) => (infix_asdt(a1, a2) = c_zero)));

% mult_zero_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex):
  ((a1 = c_zero) => (infix_asdt(a2, a1) = c_zero)));

% mult_one_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex):
  ((a2 = c_one) => (infix_asdt(a1, a2) = a1)));

% add_eq_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b1 : complex, b2 : complex):
  ((a1 = a2) => ((b1 = b2) => (infix_pldt(a1, b1) = infix_pldt(a2, b2)))));

% add_eq_t_rev
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b1 : complex, b2 : complex):
  ((a1 = a2) => ((b1 = b2) => (infix_pldt(a1, b1) = infix_pldt(b2, a2)))));

% substr_eq_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b1 : complex, b2 : complex):
  ((a1 = a2) => ((b1 = b2) => (infix_mndt(a1, b1) = infix_mndt(a2, b2)))));

im: complex;

% im_Def
  ASSERT (infix_asdt(im, im) = prefix_mndt(c_one));

r_to_c: (REAL) -> complex;

% r_to_c_zero
  ASSERT (r_to_c(0) = c_zero);

% r_to_c_one
  ASSERT (r_to_c(1) = c_one);

% r_to_c_add
  ASSERT
  (FORALL (i : REAL, j : REAL): (infix_pldt(r_to_c(i), r_to_c(j)) = 
  r_to_c((i + j))));

% r_to_c_add_rev
  ASSERT
  (FORALL (i : REAL, j : REAL): (r_to_c((i + j)) = infix_pldt(r_to_c(i), 
  r_to_c(j))));

% r_to_c_opp
  ASSERT (FORALL (i : REAL): (r_to_c((- i)) = prefix_mndt(r_to_c(i))));

% r_to_c_div
  ASSERT
  (FORALL (i : REAL, j : REAL):
  ((NOT (j = 0)) => (r_to_c(infix_slas(i, j)) = infix_sldt(r_to_c(i), 
  r_to_c(j)))));

% r_to_c_mult
  ASSERT
  (FORALL (i : REAL, j : REAL): (infix_asdt(r_to_c(i), r_to_c(j)) = 
  r_to_c((i * j))));

% r_to_c_mult_rev
  ASSERT
  (FORALL (i : REAL, j : REAL): (r_to_c((i * j)) = infix_asdt(r_to_c(i), 
  r_to_c(j))));

% r_to_c_sub
  ASSERT
  (FORALL (i : REAL, j : REAL): (infix_mndt(r_to_c(i), r_to_c(j)) = 
  r_to_c((i - j))));

real_part: (complex) -> REAL;

im_part: (complex) -> REAL;

% Real_part_add
  ASSERT
  (FORALL (i : complex, j : complex): (real_part(infix_pldt(i, j)) = (
  real_part(i) + real_part(j))));

% Im_part_add
  ASSERT
  (FORALL (i : complex, j : complex): (im_part(infix_pldt(i, j)) = (
  im_part(i) + im_part(j))));

% Real_part_opposite
  ASSERT
  (FORALL (i : complex): (real_part(prefix_mndt(i)) = (- real_part(i))));

% Im_part_opposite
  ASSERT (FORALL (i : complex): (im_part(prefix_mndt(i)) = (- im_part(i))));

% Complex_decomp
  ASSERT
  (FORALL (i : complex): (i = infix_pldt(r_to_c(real_part(i)), infix_asdt(im, 
  r_to_c(im_part(i))))));

% Unic_decomp
  ASSERT
  (FORALL (i : complex):
  (FORALL (x : REAL, y : REAL):
  ((i = infix_pldt(r_to_c(x), infix_asdt(im, r_to_c(y))))
  => ((x = real_part(i)) AND (y = im_part(i))))));

real_: (complex) -> BOOLEAN;

% real_'def
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) <=> (infix_eqeq(real, t2tb1(im_part(x)), t2tb1(0)))));

pure_im_: (complex) -> BOOLEAN;

% pure_im_'def
  ASSERT
  (FORALL (x : complex):
  ((pure_im_(x)) <=> (infix_eqeq(real, t2tb1(real_part(x)), t2tb1(0)))));

% unic_decomp
  ASSERT
  (FORALL (i : complex, x : REAL, y : REAL):
  ((i = infix_pldt(r_to_c(x), infix_asdt(im, r_to_c(y))))
  => ((x = real_part(i)) AND (y = im_part(i)))));

% r_to_c_real
  ASSERT (FORALL (x : complex): ((real_(x)) => (x = r_to_c(real_part(x)))));

% real_r_to_c
  ASSERT (FORALL (x : REAL): (real_(r_to_c(x))));

% r_to_c_pure_im
  ASSERT
  (FORALL (x : complex):
  ((pure_im_(x)) => (x = infix_asdt(im, r_to_c(im_part(x))))));

% decomp_mult
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(a, b) = infix_pldt(
  infix_mndt(infix_asdt(r_to_c(real_part(a)), r_to_c(real_part(b))), 
  infix_asdt(r_to_c(im_part(a)), r_to_c(im_part(b)))), infix_asdt(im, 
  infix_pldt(infix_asdt(r_to_c(real_part(a)), r_to_c(im_part(b))), 
  infix_asdt(r_to_c(real_part(b)), r_to_c(im_part(a))))))));

t_real_part: (complex) -> complex;

% t_real_part'def
  ASSERT (FORALL (x : complex): (t_real_part(x) = r_to_c(real_part(x))));

% t_real_part'spec
  ASSERT (FORALL (x : complex): (real_(t_real_part(x))));

% t_real_part_inv
  ASSERT
  (FORALL (x : complex): (t_real_part(prefix_mndt(x)) = prefix_mndt(
  t_real_part(x))));

t_im_part: (complex) -> complex;

% t_im_part'def
  ASSERT (FORALL (x : complex): (t_im_part(x) = r_to_c(im_part(x))));

% t_im_part'spec
  ASSERT (FORALL (x : complex): (real_(t_im_part(x))));

% t_im_part_inv
  ASSERT
  (FORALL (x : complex): (t_im_part(prefix_mndt(x)) = prefix_mndt(
  t_im_part(x))));

% decomp_mult_as_reals
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(a, b) = infix_pldt(
  infix_mndt(infix_asdt(t_real_part(a), t_real_part(b)), infix_asdt(
  t_im_part(a), t_im_part(b))), infix_asdt(im, infix_pldt(infix_asdt(
  t_real_part(a), t_im_part(b)), infix_asdt(t_real_part(b), 
  t_im_part(a)))))));

% decomp_mult_real_part
  ASSERT
  (FORALL (a : complex, b : complex): (real_part(infix_asdt(a, b)) = ((
  real_part(a) * real_part(b)) - (im_part(a) * im_part(b)))));

% decomp_mult_im_part
  ASSERT
  (FORALL (a : complex, b : complex): (im_part(infix_asdt(a, b)) = ((
  real_part(a) * im_part(b)) + (real_part(b) * im_part(a)))));

% t_mult_real
  ASSERT
  (FORALL (a : complex, b : complex): (t_real_part(infix_asdt(a, b)) = 
  infix_mndt(infix_asdt(t_real_part(a), t_real_part(b)), infix_asdt(
  t_im_part(a), t_im_part(b)))));

% t_mult_im
  ASSERT
  (FORALL (a : complex, b : complex): (t_im_part(infix_asdt(a, b)) = 
  infix_pldt(infix_asdt(t_real_part(a), t_im_part(b)), infix_asdt(
  t_im_part(a), t_real_part(b)))));

% mult_real_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => (((infix_asdt(a, b) = infix_asdt(r_to_c(real_part(a)), r_to_c(
         real_part(b)))) AND (infix_asdt(r_to_c(real_part(a)), r_to_c(
         real_part(b))) = r_to_c((real_part(a) * real_part(b)))))
        AND ((real_part(infix_asdt(a, b)) = (real_part(a) * real_part(b)))
            AND (im_part(infix_asdt(a, b)) = 0))))));

% complex_squared
  ASSERT
  (FORALL (a : complex):
  ((infix_asdt(a, a) = infix_pldt(infix_mndt(infix_asdt(t_real_part(a), 
  t_real_part(a)), infix_asdt(t_im_part(a), t_im_part(a))), infix_asdt(
  infix_asdt(infix_asdt(im, infix_pldt(c_one, c_one)), t_real_part(a)), 
  t_im_part(a))))
  AND ((t_real_part(infix_asdt(a, a)) = infix_mndt(infix_asdt(t_real_part(a), 
      t_real_part(a)), infix_asdt(t_im_part(a), t_im_part(a)))) AND (
      t_im_part(infix_asdt(a, a)) = infix_asdt(infix_asdt(infix_pldt(c_one,
      c_one), t_real_part(a)), t_im_part(a))))));

% complex_real_squared
  ASSERT
  (FORALL (a : complex):
  ((real_(a)) => (infix_asdt(a, a) = infix_asdt(t_real_part(a), 
  t_real_part(a)))));

% decomp_div
  ASSERT
  (FORALL (a : complex, b : complex):
  ((NOT (b = c_zero)) => (infix_sldt(a, b) = infix_pldt(infix_sldt(
  t_real_part(infix_asdt(a, b)), infix_asdt(b, b)), infix_asdt(im, 
  infix_sldt(t_im_part(infix_asdt(a, b)), infix_asdt(b, b)))))));

% decomp_div_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(b))
  => ((NOT (b = c_zero)) => (infix_sldt(a, b) = infix_pldt(infix_sldt(
     infix_asdt(t_real_part(a), b), infix_asdt(b, b)), infix_asdt(im, 
     infix_sldt(infix_asdt(t_im_part(a), b), infix_asdt(b, b))))))));

% complex_prod_fact
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(a, b) = infix_pldt(
  infix_asdt(r_to_c(real_part(a)), b), infix_asdt(infix_asdt(im, r_to_c(
  im_part(a))), b))));

% non_zero_prod_pre
  ASSERT
  (FORALL (a : complex, b : complex):
  ((NOT (a = c_zero))
  => ((infix_asdt(a, b) = c_zero)
     => ((im_part(b) = real_part(b)) AND (real_part(b) = 0)))));

% non_zero_prod
  ASSERT
  (FORALL (a : complex, b : complex):
  ((NOT (a = c_zero))
  => ((NOT (b = c_zero)) => (NOT (infix_asdt(a, b) = c_zero)))));

% minus_c_one
  ASSERT
  (FORALL (a : complex): (prefix_mndt(a) = infix_asdt(prefix_mndt(c_one),
  a)));

% mult_neg_l
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(prefix_mndt(a), b) = 
  prefix_mndt(infix_asdt(a, b))));

% mult_neg_r
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(a, prefix_mndt(b)) = 
  prefix_mndt(infix_asdt(a, b))));

% neg_neg_out
  ASSERT (FORALL (a : complex): (prefix_mndt(prefix_mndt(a)) = a));

% div_neg_l
  ASSERT
  (FORALL (a : complex, b : complex):
  ((NOT (b = c_zero)) => (infix_sldt(prefix_mndt(a), b) = prefix_mndt(
  infix_sldt(a, b)))));

% eq_to_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a)) => ((real_(b)) => ((a = b) => (real_part(a) = real_part(b))))));

% eq_by_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a)) => ((real_(b)) => ((real_part(a) = real_part(b)) => (a = b)))));

% div_neg_r
  ASSERT
  (FORALL (a : complex, b : complex):
  ((NOT (b = c_zero)) => (infix_sldt(a, prefix_mndt(b)) = prefix_mndt(
  infix_sldt(a, b)))));

% invadd
  ASSERT
  (FORALL (i : complex): (prefix_mndt(i) = infix_asdt(prefix_mndt(c_one),
  i)));

% noc_zeroAdd
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (x = c_zero)) => (NOT (infix_pldt(x, y) = y))));

% Absorbing_zero
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_asdt(a, b) = c_zero) <=> ((NOT (a = c_zero)) => (b = c_zero))));

% real_part_add
  ASSERT
  (FORALL (i : complex, j : complex): (real_part(infix_pldt(i, j)) = (
  real_part(i) + real_part(j))));

% mult_im_rev
  ASSERT (FORALL (a : complex): (infix_asdt(a, im) = infix_asdt(im, a)));

% im_im_elim
  ASSERT
  (FORALL (a : complex): (infix_asdt(im, infix_asdt(im, a)) = 
  prefix_mndt(a)));

% im_im_fact
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(infix_asdt(im, a), 
  infix_asdt(im, b)) = prefix_mndt(infix_asdt(a, b))));

% minus_minus_fact
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(prefix_mndt(a), 
  prefix_mndt(b)) = infix_asdt(a, b)));

% minus_minus_add
  ASSERT
  (FORALL (a : complex, b : complex): (infix_pldt(prefix_mndt(a), 
  prefix_mndt(b)) = prefix_mndt(infix_pldt(a, b))));

% minus_minus_add_rev
  ASSERT
  (FORALL (a : complex, b : complex): (prefix_mndt(infix_pldt(a, b)) = 
  infix_pldt(prefix_mndt(a), prefix_mndt(b))));

% minus_out_left
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(prefix_mndt(a), b) = 
  prefix_mndt(infix_asdt(a, b))));

% minus_out_right
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(a, prefix_mndt(b)) = 
  prefix_mndt(infix_asdt(a, b))));

% minus_in_left
  ASSERT
  (FORALL (a : complex, b : complex): (prefix_mndt(infix_asdt(a, b)) = 
  infix_asdt(prefix_mndt(a), b)));

% minus_in_right
  ASSERT
  (FORALL (a : complex, b : complex): (prefix_mndt(infix_asdt(a, b)) = 
  infix_asdt(a, prefix_mndt(b))));

% minus_add_out_left
  ASSERT
  (FORALL (a : complex, b : complex): (infix_pldt(prefix_mndt(a), b) = 
  prefix_mndt(infix_pldt(a, prefix_mndt(b)))));

% minus_as_add_opp
  ASSERT
  (FORALL (a : complex, b : complex): (infix_mndt(a, b) = infix_pldt(a, 
  prefix_mndt(b))));

% minus_add_out_right
  ASSERT
  (FORALL (a : complex, b : complex): (infix_pldt(a, prefix_mndt(b)) = 
  prefix_mndt(infix_pldt(prefix_mndt(a), b))));

% minus_add_in
  ASSERT
  (FORALL (a : complex, b : complex): (prefix_mndt(infix_pldt(a, b)) = 
  infix_pldt(prefix_mndt(a), prefix_mndt(b))));

% minus_add_out
  ASSERT
  (FORALL (a : complex, b : complex): (infix_pldt(prefix_mndt(a), 
  prefix_mndt(b)) = prefix_mndt(infix_pldt(a, b))));

% minus_eq
  ASSERT
  (FORALL (a : complex, b : complex):
  ((a = b) => (prefix_mndt(a) = prefix_mndt(b))));

% im_out_right
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(infix_asdt(im, a), b) = 
  infix_asdt(im, infix_asdt(a, b))));

% im_out_left
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(a, infix_asdt(im, b)) = 
  infix_asdt(im, infix_asdt(a, b))));

% im_part_add
  ASSERT
  (FORALL (i : complex, j : complex): (im_part(infix_pldt(i, j)) = (
  im_part(i) + im_part(j))));

% injective_real_part
  ASSERT
  (FORALL (i : complex, j : complex):
  ((NOT (real_part(i) = real_part(j))) => (NOT (i = j))));

% injective_im_part
  ASSERT
  (FORALL (i : complex, j : complex):
  ((NOT (im_part(i) = im_part(j))) => (NOT (i = j))));

% minus_distr_four
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_asdt(a, b), infix_asdt(infix_asdt(prefix_mndt(b), c), d)) = 
  infix_asdt(infix_mndt(a, infix_asdt(c, d)), b)));

% complex_decomp
  ASSERT
  (FORALL (i : complex): (i = infix_pldt(r_to_c(real_part(i)), infix_asdt(im, 
  r_to_c(im_part(i))))));

% simpl_frac
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (y = c_zero)) => (infix_sldt(infix_asdt(x, y), y) = x)));

% simpl_frac_
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (y = c_zero))
  => ((NOT (z = c_zero)) => (infix_sldt(infix_asdt(x, y), infix_asdt(z,
     y)) = infix_sldt(x, z)))));

% fact_frac
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (z = c_zero)) => (infix_sldt(infix_asdt(x, y), z) = infix_asdt(x, 
  infix_sldt(y, z)))));

% fact_frac_rev
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (z = c_zero)) => (infix_asdt(x, infix_sldt(y, z)) = infix_sldt(
  infix_asdt(x, y), z))));

% mult_sym
  ASSERT
  (FORALL (x : complex, y : complex): (infix_asdt(x, y) = infix_asdt(y, x)));

% inv_mult
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (x = c_zero))
  => ((NOT (y = c_zero)) => (infix_asdt(infix_sldt(c_one, x), 
     infix_sldt(c_one, y)) = infix_sldt(c_one, infix_asdt(x, y))))));

% div_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (y = c_zero))
  => ((NOT (z = c_zero)) => (infix_sldt(infix_sldt(x, y), z) = infix_sldt(x, 
     infix_asdt(y, z))))));

% div_div_rev
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (y = c_zero))
  => ((NOT (z = c_zero)) => (infix_sldt(x, infix_asdt(y, z)) = infix_sldt(
     infix_sldt(x, y), z)))));

% involutive_inv
  ASSERT
  (FORALL (a : complex):
  ((NOT (a = c_zero)) => (infix_sldt(c_one, infix_sldt(c_one, a)) = a)));

% twice
  ASSERT
  (FORALL (i : complex): (infix_asdt(infix_pldt(c_one, c_one), i) = 
  infix_pldt(i, i)));

% twice_half
  ASSERT (infix_asdt(infix_pldt(c_one, c_one), infix_sldt(c_one, 
  infix_pldt(c_one, c_one))) = c_one);

% half_plus_half
  ASSERT
  (FORALL (i : complex): (infix_pldt(infix_sldt(i, infix_pldt(c_one, c_one)), 
  infix_sldt(i, infix_pldt(c_one, c_one))) = i));

% decomp_inv_real
  ASSERT
  (FORALL (a : complex):
  ((real_(a))
  => ((NOT (a = c_zero))
     => ((infix_sldt(c_one, a) = infix_sldt(c_one, t_real_part(a)))
        AND ((real_(infix_sldt(c_one, a)))
            AND ((t_real_part(infix_sldt(c_one, a)) = infix_sldt(c_one, 
                t_real_part(a))) AND (real_part(infix_sldt(c_one, a)) = 
                infix_slas(1, real_part(a)))))))));

% mult_div_comm
  ASSERT
  (FORALL (x : complex, y : complex, z : complex, t1 : complex):
  ((NOT (z = c_zero))
  => ((NOT (t1 = c_zero)) => (infix_sldt(infix_asdt(x, y), infix_asdt(z,
     t1)) = infix_asdt(infix_sldt(x, z), infix_sldt(y, t1))))));

% mult_div_comm_rev
  ASSERT
  (FORALL (x : complex, y : complex, z : complex, t1 : complex):
  ((NOT (z = c_zero))
  => ((NOT (t1 = c_zero)) => (infix_asdt(infix_sldt(x, z), infix_sldt(y,
     t1)) = infix_sldt(infix_asdt(x, y), infix_asdt(z, t1))))));

infix_lseqdt: (complex, complex) -> BOOLEAN;

% infix <=.'def
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(x, y))
  <=> (((real_(x)) AND ((real_(y)) AND (real_part(x) <= real_part(y))))
      OR (infix_eqeq(complex1, t2tb(x), t2tb(y))))));

infix_lsdt: (complex, complex) -> BOOLEAN;

% infix <.'def
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(x, y))
  <=> ((infix_lseqdt(x, y))
      AND (NOT (infix_eqeq(complex1, t2tb(x), t2tb(y)))))));

infix_gtdt: (complex, complex) -> BOOLEAN;

% infix >.'def
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_gtdt(x, y))
  <=> ((infix_lseqdt(y, x))
      AND (NOT (infix_eqeq(complex1, t2tb(x), t2tb(y)))))));

% leq_left_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(a, b)) => ((real_(a)) => (real_(b)))));

% leq_right_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(a, b)) => ((real_(b)) => (real_(a)))));

% inf_left_real
  ASSERT
  (FORALL (a : complex, b : complex): ((infix_lsdt(a, b)) => (real_(a))));

% inf_right_real
  ASSERT
  (FORALL (a : complex, b : complex): ((infix_lsdt(a, b)) => (real_(b))));

% inf_from_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((infix_lsas(real_part(a), real_part(b))) => (infix_lsdt(a, b))))));

% inf_to_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lsdt(a, b)) => (infix_lsas(real_part(a), real_part(b)))));

% leq_left_not_real_a
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(a, b)) => ((NOT (real_(a))) => (a = b))));

% leq_left_not_real_b
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(a, b)) => ((NOT (real_(b))) => (a = b))));

% Refl
  ASSERT (FORALL (x : complex): (infix_lseqdt(x, x)));

% Trans
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(x, y)) => ((infix_lseqdt(y, z)) => (infix_lseqdt(x, z)))));

% Antisymm
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(x, y)) => ((infix_lseqdt(y, x)) => (x = y))));

% Refl
  ASSERT (FORALL (x : complex): (infix_lseqdt(x, x)));

% Trans
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(y, x)) => ((infix_lseqdt(z, y)) => (infix_lseqdt(z, x)))));

% Antisymm
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(y, x)) => ((infix_lseqdt(x, y)) => (x = y))));

% Trans
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lsdt(x, y)) => ((infix_lsdt(y, z)) => (infix_lsdt(x, z)))));

% Asymm
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(x, y)) => (NOT (infix_lsdt(y, x)))));

% Trans
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_gtdt(x, y)) => ((infix_gtdt(y, z)) => (infix_gtdt(x, z)))));

% Asymm
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_gtdt(x, y)) => (NOT (infix_gtdt(y, x)))));

% r_to_c_inf
  ASSERT
  (FORALL (i : REAL, j : REAL):
  ((infix_lseqdt(r_to_c(i), r_to_c(j))) <=> (i <= j)));

% reali_is_its_real_part
  ASSERT (FORALL (a : complex): ((real_(a)) => (a = r_to_c(real_part(a)))));

% inf_from_r
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((real_(b)) => ((real_part(a) <= real_part(b)) => (infix_lseqdt(a, b))))));

% strict_inf_from_r
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((infix_lsas(real_part(a), real_part(b))) => (infix_lsdt(a, b))))));

% positive_inv_t
  ASSERT
  (FORALL (x : complex):
  ((infix_lsdt(c_zero, x)) => (infix_lsdt(c_zero, infix_sldt(c_one, x)))));

pi: complex;

% pi'def
  ASSERT (infix_lsdt(r_to_c(3), pi));

% real_pi
  ASSERT (real_(pi));

% pi_sup_one
  ASSERT (infix_lsdt(c_one, pi));

% pi_sup_zero
  ASSERT (infix_lsdt(c_zero, pi));

% compat_order_mult
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lseqdt(c_zero, z)) => (infix_lseqdt(infix_asdt(x, z), 
              infix_asdt(y, z)))))))));

% compat_order_add
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z)) => (infix_lseqdt(infix_pldt(x, z), infix_pldt(y, z))))))));

% compat_order_add_left
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z)) => (infix_lseqdt(infix_pldt(z, x), infix_pldt(z, y))))))));

% compat_order_add_both
  ASSERT
  (FORALL (x : complex, y : complex, z : complex, t1 : complex):
  ((infix_lseqdt(x, y))
  => ((infix_lseqdt(z, t1))
     => ((real_(x))
        => ((real_(y))
           => ((real_(z))
              => ((real_(t1)) => (infix_lseqdt(infix_pldt(z, x), 
                 infix_pldt(t1, y))))))))));

% compat_order_substr
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z)) => (infix_lseqdt(infix_mndt(x, z), infix_mndt(y, z))))))));

% compat_inf_mult
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lsdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_lsdt(infix_asdt(x, z), 
              infix_asdt(y, z)))))))));

% transitive_infeq
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(a, b)) => ((infix_lseqdt(b, c)) => (infix_lseqdt(a, c)))));

% transitive_infeq_inf
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(a, b)) => ((infix_lsdt(b, c)) => (infix_lsdt(a, c)))));

% transitive_inf_infeq
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(a, b)) => ((infix_lseqdt(b, c)) => (infix_lsdt(a, c)))));

% transitive_inf
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(a, b)) => ((infix_lsdt(b, c)) => (infix_lsdt(a, c)))));

% pi_sup_ttwo
  ASSERT (infix_lsdt(infix_pldt(c_one, c_one), pi));

% transitive_leq_inv_r
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((real_(b))
     => ((real_(c))
        => ((infix_lseqdt(a, b))
           => ((infix_lseqdt(b, infix_sldt(c_one, c)))
              => ((infix_lseqdt(c_one, c))
                 => ((infix_lseqdt(a, b)) AND (infix_lseqdt(b, c_one))))))))));

% compat_inf_mult_left
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lsdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_lsdt(infix_asdt(z, x), 
              infix_asdt(z, y)))))))));

% compat_inf_mult_both
  ASSERT
  (FORALL (x : complex, y : complex, z : complex, t1 : complex):
  ((infix_lsdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => (((infix_lsdt(c_zero, z)) AND (infix_lsdt(z, t1)))
              => ((infix_lsdt(c_zero, y)) => (infix_lsdt(infix_asdt(z, x), 
                 infix_asdt(t1, y))))))))));

% compat_inf_add
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lsdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z)) => (infix_lsdt(infix_pldt(x, z), infix_pldt(y, z))))))));

% compat_inf_add_left
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lsdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z)) => (infix_lsdt(infix_pldt(z, x), infix_pldt(z, y))))))));

% compat_inf_add_both
  ASSERT
  (FORALL (x : complex, y : complex, z : complex, t1 : complex):
  ((infix_lsdt(x, y))
  => ((infix_lsdt(z, t1)) => (infix_lsdt(infix_pldt(x, z), infix_pldt(y,
     t1))))));

% compat_inf_substr
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lsdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z)) => (infix_lsdt(infix_mndt(x, z), infix_mndt(y, z))))))));

% real_inv
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => ((NOT (x = c_zero)) => (real_(infix_sldt(c_one, x))))));

% compat_order_mult_rev
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((real_(x))
  => ((real_(y))
     => ((real_(z))
        => ((infix_lsdt(c_zero, z))
           => ((infix_lseqdt(infix_asdt(x, z), infix_asdt(y, z)))
              => (infix_lseqdt(x, y))))))));

% compat_order_mult_left
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lseqdt(c_zero, z)) => (infix_lseqdt(infix_asdt(z, x), 
              infix_asdt(z, y)))))))));

% strict_compat_order_mult
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lsdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_lsdt(infix_asdt(x, z), 
              infix_asdt(y, z)))))))));

% strict_compat_order_mult_left
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lsdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_lsdt(infix_asdt(z, x), 
              infix_asdt(z, y)))))))));

% complete_order_real
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y))
     => ((NOT (x = y)) => ((NOT (infix_lsdt(x, y))) => (infix_lsdt(y, x)))))));

% complete_order_real_
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y))
     => ((NOT (infix_lsdt(x, y))) => ((NOT (infix_lsdt(y, x))) => (y = x))))));

% compat_order_mult_both
  ASSERT
  (FORALL (x : complex, y : complex, z : complex, t1 : complex):
  (((infix_lseqdt(c_zero, x)) AND (infix_lseqdt(x, y)))
  => (((infix_lseqdt(c_zero, z)) AND (infix_lseqdt(z, t1))) => (infix_lseqdt(
     infix_asdt(z, x), infix_asdt(t1, y))))));

% inf_to_non_sup_eq
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y)) => ((infix_lsdt(x, y)) => (NOT (infix_lseqdt(y, x)))))));

% sup_eq_to_non_inf
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y)) => ((infix_lseqdt(y, x)) => (NOT (infix_lsdt(x, y)))))));

% sup_to_inf
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x)) => ((real_(y)) => ((infix_gtdt(x, y)) => (infix_lsdt(y, x))))));

% inf_to_sup
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x)) => ((real_(y)) => ((infix_lsdt(x, y)) => (infix_gtdt(y, x))))));

% sup_to_non_inf_eq
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y)) => ((infix_gtdt(x, y)) => (NOT (infix_lseqdt(x, y)))))));

% inf_eq_to_non_sup
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y)) => ((infix_lseqdt(x, y)) => (NOT (infix_gtdt(x, y)))))));

% non_inf_eq_to_sup
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y)) => ((NOT (infix_lseqdt(x, y))) => (infix_gtdt(x, y))))));

% non_sup_toinf_eq
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y)) => ((NOT (infix_gtdt(x, y))) => (infix_lseqdt(x, y))))));

% real_mult
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x)) => ((real_(y)) => (real_(infix_asdt(x, y))))));

% real_add
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x)) => ((real_(y)) => (real_(infix_pldt(x, y))))));

% real_substr
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x)) => ((real_(y)) => (real_(infix_mndt(x, y))))));

% inv_pos
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((infix_lsdt(c_zero, x)) => (infix_lsdt(c_zero, infix_sldt(c_one, x))))));

% lower_over_cons
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(c_zero, c))
  => ((infix_lseqdt(c_zero, a))
     => ((infix_lseqdt(a, b)) => (infix_lseqdt(infix_sldt(a, c), 
        infix_sldt(b, c)))))));

% eq_to_leq_t
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a)) => ((a = b) => (infix_lseqdt(a, b)))));

% real_minus
  ASSERT (FORALL (a : complex): ((real_(a)) => (real_(prefix_mndt(a)))));

% compat_r_to_c_infeq
  ASSERT
  (FORALL (a : REAL, b : REAL):
  ((a <= b) => (infix_lseqdt(r_to_c(a), r_to_c(b)))));

% compat_r_to_c_inf
  ASSERT
  (FORALL (a : REAL, b : REAL):
  ((infix_lsas(a, b)) => (infix_lsdt(r_to_c(a), r_to_c(b)))));

% compat_r_to_c_supeq
  ASSERT
  (FORALL (a : REAL, b : REAL):
  ((b <= a) => (infix_lseqdt(r_to_c(b), r_to_c(a)))));

% compat_r_to_c_sup
  ASSERT
  (FORALL (a : REAL, b : REAL):
  ((infix_lsas(b, a)) => (infix_gtdt(r_to_c(a), r_to_c(b)))));

% unic_inv
  ASSERT
  (FORALL (i : complex, j : complex):
  ((NOT (i = c_zero)) => ((infix_asdt(i, j) = c_one) => (j = inv(i)))));

% inf_eq_def
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(x, y))
  <=> (((real_(x)) AND ((real_(y)) AND (real_part(x) <= real_part(y))))
      OR (x = y))));

% inf_minus
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(x, y)) => (infix_lsdt(prefix_mndt(y), prefix_mndt(x)))));

% absorbing_zero
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_asdt(a, b) = c_zero)
  => (((NOT (a = c_zero)) => (b = c_zero))
     AND ((NOT (b = c_zero)) => (a = c_zero)))));

% inf_zero_inv
  ASSERT
  (FORALL (z : complex):
  ((infix_lsdt(c_zero, z))
  => ((infix_lsdt(c_zero, infix_sldt(c_one, z))) AND (infix_lseqdt(c_zero, 
     infix_sldt(c_one, z))))));

% mult_pos
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(c_zero, x))
  => ((infix_lseqdt(c_zero, y)) => (infix_lseqdt(c_zero, infix_asdt(x, y))))));

% simpl_leq_mult_div
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((infix_lsdt(c_zero, b))
     => ((infix_lseqdt(infix_asdt(a, b), c)) => (infix_lseqdt(a, infix_asdt(
        infix_sldt(c_one, b), c)))))));

% mult_leq_c_one_leq
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(c_zero, a))
  => (((infix_lseqdt(c_zero, b)) AND (infix_lseqdt(b, c_one)))
     => (infix_lseqdt(infix_asdt(a, b), a)))));

% mult_leq_c_one_leq_gen
  ASSERT
  (FORALL (a : complex, aqt : complex, b : complex):
  ((infix_lseqdt(c_zero, a))
  => (((infix_lseqdt(c_zero, b)) AND (infix_lseqdt(b, c_one)))
     => ((a = aqt) => (infix_lseqdt(infix_asdt(a, b), aqt))))));

% mult_leq_c_one
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(c_zero, a))
  => ((EXISTS (c : complex):
      ((infix_lseqdt(a, c)) AND (b = infix_sldt(c_one, c))))
     => ((infix_lsdt(c_zero, b)) => (infix_lseqdt(infix_asdt(a, b), c_one))))));

% mult_leq_c_one_expl
  ASSERT
  (FORALL (a : complex, b : complex, d : complex):
  ((infix_lseqdt(c_zero, a))
  => ((infix_lseqdt(a, d))
     => ((infix_lsdt(c_zero, d))
        => ((infix_lseqdt(b, infix_sldt(c_one, d))) => (infix_lseqdt(
           infix_asdt(a, b), c_one)))))));

% mult_leq_c_one_rev
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(c_zero, a))
  => ((infix_lsdt(c_zero, b))
     => ((infix_lseqdt(infix_asdt(a, b), c_one)) => (infix_lseqdt(a, 
        infix_sldt(c_one, b)))))));

% simpl_leq_mult
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(c_zero, b))
  => ((infix_lseqdt(a, c)) => (infix_lseqdt(infix_asdt(a, b), infix_asdt(c,
     b))))));

% simpl_leq_mult_inv
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(c_zero, a))
  => ((infix_lsdt(c_zero, b))
     => ((infix_lsdt(c_zero, c))
        => ((infix_lseqdt(a, infix_sldt(c_one, infix_asdt(b, c))))
           => (infix_lseqdt(infix_asdt(a, b), infix_sldt(c_one, c))))))));

% mult_to_div_leq
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((infix_lsdt(c_zero, b))
     => ((infix_lseqdt(infix_asdt(a, b), c)) => (infix_lseqdt(a, infix_asdt(
        infix_sldt(c_one, b), c)))))));

% mult_div
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(c_zero, x))
  => ((infix_lsdt(c_zero, y)) => (infix_lseqdt(c_zero, infix_sldt(x, y))))));

% strict_mult_pos
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(c_zero, x))
  => ((infix_lsdt(c_zero, y)) => (infix_lsdt(c_zero, infix_asdt(x, y))))));

% rewrite_supeq
  ASSERT TRUE;

% rewrite_sup
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(x, y)) => (infix_gtdt(y, x))));

% inv_order_complex
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lsdt(c_zero, a))
  => ((infix_lsdt(c_zero, b))
     => ((infix_lseqdt(a, b)) => (infix_lseqdt(infix_sldt(c_one, b), 
        infix_sldt(c_one, a)))))));

% compat_inv_order
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  (((infix_lsdt(c_zero, a)) AND (infix_lseqdt(a, b)))
  => ((infix_lseqdt(c, infix_sldt(c_one, b))) => (infix_lseqdt(c, 
     infix_sldt(c_one, a))))));

% leq_by_div_simpl
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(c_zero, a))
  => (((infix_lsdt(c_zero, b)) AND (infix_lseqdt(b, c))) => (infix_lseqdt(
     infix_sldt(a, c), infix_sldt(a, b))))));

% leq_by_div
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(c_zero, a))
  => (((infix_lsdt(c_zero, b)) AND (infix_lseqdt(b, c))) => (infix_lseqdt(
     infix_sldt(a, c), infix_sldt(a, b))))));

% strict_pos_div
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(c_zero, x))
  => ((infix_lsdt(c_zero, y)) => (infix_lsdt(c_zero, infix_sldt(x, y))))));

% inf_def
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(x, y))
  <=> ((real_(x))
      AND ((real_(y)) AND (infix_lsas(real_part(x), real_part(y)))))));

% sup_eq_def
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(y, x))
  <=> (((real_(x)) AND ((real_(y)) AND (real_part(y) <= real_part(x))))
      OR (x = y))));

% sup_def
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_gtdt(x, y))
  <=> ((real_(x))
      AND ((real_(y)) AND (infix_lsas(real_part(y), real_part(x)))))));

% assoc_mult_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (z = c_zero)) => (infix_asdt(x, infix_sldt(y, z)) = infix_sldt(
  infix_asdt(x, y), z))));

% assoc_mult_div_rev
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (z = c_zero)) => (infix_sldt(infix_asdt(x, y), z) = infix_asdt(x, 
  infix_sldt(y, z)))));

% subst_zero
  ASSERT (FORALL (a : complex): (infix_mndt(a, c_zero) = a));

% subst_zero_gen
  ASSERT
  (FORALL (a : complex, b : complex):
  ((b = c_zero) => (infix_mndt(a, b) = a)));

% transitive_inf_inv_r
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(a, b))
  => ((infix_lseqdt(b, infix_sldt(c_one, c)))
     => ((infix_lsdt(c_one, c))
        => ((infix_lseqdt(a, b)) AND (infix_lsdt(b, c_one)))))));

% infeq_scal_r
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(a, c))
  => ((infix_lseqdt(c_zero, b)) => (infix_lseqdt(infix_asdt(a, b), 
     infix_asdt(c, b))))));

% infeq_scal_l
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(a, c))
  => ((infix_lseqdt(c_zero, b)) => (infix_lseqdt(infix_asdt(b, a), 
     infix_asdt(b, c))))));

% transitive_supeq
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(b, a)) => ((infix_lseqdt(c, b)) => (infix_lseqdt(c, a)))));

% transitive_inf_l
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(a, b)) => ((infix_lseqdt(b, c)) => (infix_lsdt(a, c)))));

% transitive_sup_l
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_gtdt(a, b)) => ((infix_lseqdt(c, b)) => (infix_gtdt(a, c)))));

% transitive_inf_r
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(a, b)) => ((infix_lsdt(b, c)) => (infix_lsdt(a, c)))));

% transitive_sup_r
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(b, a)) => ((infix_gtdt(b, c)) => (infix_gtdt(a, c)))));

% simpl_frac_r
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (x = c_zero)) => (infix_asdt(x, infix_sldt(y, x)) = y)));

% compat_mult_sup_eq_right
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(c_zero, a))
  => ((infix_lseqdt(c, b)) => (infix_lseqdt(infix_asdt(a, c), infix_asdt(a,
     b))))));

% compat_mult_sup_right
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(c_zero, a))
  => ((infix_gtdt(b, c)) => (infix_gtdt(infix_asdt(a, b), infix_asdt(a, c))))));

% compat_mult_inf_right
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(c_zero, a))
  => ((infix_lsdt(b, c)) => (infix_lsdt(infix_asdt(a, b), infix_asdt(a, c))))));

% infeq_to_supeq
  ASSERT TRUE;

% infeq_inv
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(a, b)) => (infix_lseqdt(prefix_mndt(b), prefix_mndt(a)))));

% infeq_inv_add_l
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lseqdt(infix_pldt(a, c), b))
  => ((real_(a)) => ((real_(c)) => (infix_lseqdt(a, infix_mndt(b, c)))))));

% infeq_inv_add_r
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((real_(c))
     => ((infix_lseqdt(a, infix_pldt(b, c))) => (infix_lseqdt(infix_mndt(a,
        c), b))))));

% r_to_c_surj
  ASSERT
  (FORALL (x : REAL, y : REAL):
  ((NOT (x = y)) => (NOT (r_to_c(x) = r_to_c(y)))));

% r_to_c_inf_rev
  ASSERT
  (FORALL (x : REAL, y : REAL):
  ((infix_lsas(x, y)) => (infix_lsdt(r_to_c(x), r_to_c(y)))));

% div_simpl
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lsdt(c_zero, a))
  => ((infix_lsdt(c_zero, b)) => (infix_sldt(c_one, b) = infix_sldt(a, 
     infix_asdt(a, b))))));

% infeq_inv_subs_l
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((real_(b))
     => ((real_(c))
        => ((infix_lseqdt(infix_mndt(a, c), b)) => (infix_lseqdt(a, 
           infix_pldt(b, c))))))));

% infeq_inv_subs_r
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((real_(b))
     => ((real_(c))
        => ((infix_lseqdt(a, infix_mndt(b, c))) => (infix_lseqdt(
           infix_pldt(a, c), b)))))));

% infeq_pos_elim
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((infix_lseqdt(c_zero, b)) => (infix_lseqdt(a, infix_pldt(a, b))))));

% infeq_pos_elim_add
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((real_(b))
     => ((real_(c))
        => ((infix_lseqdt(c_zero, b))
           => ((infix_lseqdt(c, a)) => (infix_lseqdt(c, infix_pldt(a, b)))))))));

% supeq_elim_left
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((infix_lseqdt(b, a)) => (infix_lseqdt(infix_mndt(b, a), c_zero))))));

% sup_elim_left
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_gtdt(a, b)) => (infix_gtdt(c_zero, infix_mndt(b, a)))));

% infeq_elim_left
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((infix_lseqdt(a, b)) => (infix_lseqdt(c_zero, infix_mndt(b, a)))))));

% inf_elim_left
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lsdt(a, b)) => (infix_lsdt(c_zero, infix_mndt(b, a)))));

% t_im_real
  ASSERT
  (FORALL (a : complex, b : complex): (t_im_part(infix_asdt(a, b)) = 
  infix_pldt(infix_asdt(t_real_part(a), t_im_part(b)), infix_asdt(
  t_im_part(a), t_real_part(b)))));

% t_decomp_mult
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(a, b) = infix_pldt(
  infix_mndt(infix_asdt(t_real_part(a), t_real_part(b)), infix_asdt(
  t_im_part(a), t_im_part(b))), infix_asdt(im, infix_pldt(infix_asdt(
  t_real_part(a), t_im_part(b)), infix_asdt(t_im_part(a), 
  t_real_part(b)))))));

% t_complex_decomp
  ASSERT
  (FORALL (i : complex): (i = infix_pldt(t_real_part(i), infix_asdt(im, 
  t_im_part(i)))));

% t_unic_decomp
  ASSERT
  (FORALL (i : complex, a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((i = infix_pldt(a, infix_asdt(im, b)))
        => ((a = t_real_part(i)) AND (b = t_im_part(i)))))));

% t_decomp_minus
  ASSERT
  (FORALL (i : complex, a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((i = infix_mndt(a, infix_asdt(im, b)))
        => ((a = t_real_part(i)) AND (prefix_mndt(b) = t_im_part(i)))))));

% real_sum
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x)) => ((real_(y)) => (real_(infix_pldt(x, y))))));

% real_diff
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x)) => ((real_(y)) => (real_(infix_mndt(x, y))))));

% pure_im_sum
  ASSERT
  (FORALL (x : complex, y : complex):
  ((pure_im_(x)) => ((pure_im_(y)) => (pure_im_(infix_pldt(x, y))))));

% equal_decomp
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_part(x) = real_part(y)) => ((im_part(x) = im_part(y)) => (x = y))));

% t_equal_decomp
  ASSERT
  (FORALL (x : complex, y : complex):
  ((t_real_part(x) = t_real_part(y))
  => ((t_im_part(x) = t_im_part(y)) => (x = y))));

% pure_im_diff
  ASSERT
  (FORALL (x : complex, y : complex):
  ((pure_im_(x)) => ((pure_im_(y)) => (pure_im_(infix_mndt(x, y))))));

% real_div
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((NOT (y = c_zero)) => ((real_(y)) => (real_(infix_sldt(x, y)))))));

% mult_im_im
  ASSERT
  (FORALL (a : complex, b : complex):
  ((pure_im_(a))
  => ((pure_im_(b))
     => ((infix_asdt(a, b) = infix_asdt(infix_asdt(im, im), infix_asdt(
        r_to_c(im_part(a)), r_to_c(im_part(b)))))
        AND ((infix_asdt(a, b) = prefix_mndt(r_to_c((im_part(a) * 
            im_part(b)))))
            AND ((real_part(infix_asdt(a, b)) = (- (im_part(a) * 
                im_part(b)))) AND (im_part(infix_asdt(a, b)) = 0)))))));

% mult_real_im
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((pure_im_(b))
     => ((infix_asdt(a, b) = infix_asdt(im, infix_asdt(r_to_c(real_part(a)), 
        r_to_c(im_part(b)))))
        AND ((infix_asdt(a, b) = infix_asdt(im, r_to_c((real_part(a) * 
            im_part(b)))))
            AND ((real_part(infix_asdt(a, b)) = 0) AND (im_part(infix_asdt(a,
                b)) = (real_part(a) * im_part(b)))))))));

% mult_im_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((pure_im_(a))
  => ((real_(b))
     => ((infix_asdt(a, b) = infix_asdt(im, infix_asdt(r_to_c(im_part(a)), 
        r_to_c(real_part(b)))))
        AND ((infix_asdt(a, b) = infix_asdt(im, r_to_c((im_part(a) * 
            real_part(b)))))
            AND ((real_part(infix_asdt(a, b)) = 0) AND (im_part(infix_asdt(a,
                b)) = (im_part(a) * real_part(b)))))))));

% decomp_mult_gen
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_part(infix_asdt(a, b)) = ((real_part(a) * real_part(b)) - (
  im_part(a) * im_part(b)))) AND (im_part(infix_asdt(a, b)) = ((
  real_part(a) * im_part(b)) + (im_part(a) * real_part(b))))));

% inv_real
  ASSERT
  (FORALL (a : complex):
  ((NOT (a = c_zero))
  => ((real_(a))
     => ((real_part(infix_sldt(c_one, a)) = infix_slas(1, real_part(a)))
        AND (real_(infix_sldt(c_one, a)))))));

% div_real_real
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((NOT (b = c_zero)) => (real_part(infix_sldt(a, b)) = infix_slas(
        real_part(a), real_part(b)))))));

% zeroLessOne
  ASSERT (infix_lseqdt(c_zero, c_one));

% compatOrderAdd
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z)) => (infix_lseqdt(infix_pldt(x, z), infix_pldt(y, z))))))));

% positive_add
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(c_zero, x))
  => ((infix_lseqdt(c_zero, y)) => (infix_lseqdt(c_zero, infix_pldt(x, y))))));

% strict_positive_add_l
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(c_zero, x))
  => ((infix_lseqdt(c_zero, y)) => (infix_lsdt(c_zero, infix_pldt(x, y))))));

% strict_compatOrderAdd
  ASSERT
  (FORALL (x : complex, y : complex, z : complex, t1 : complex):
  ((infix_lsdt(x, y))
  => ((infix_lsdt(z, t1))
     => ((real_(x))
        => ((real_(y))
           => ((real_(z))
              => ((real_(t1)) => (infix_lsdt(infix_pldt(x, z), infix_pldt(y,
                 t1))))))))));

% compat_sup_add
  ASSERT
  (FORALL (x : complex, y : complex, z : complex, t1 : complex):
  ((infix_gtdt(x, y))
  => ((infix_gtdt(z, t1))
     => ((real_(x))
        => ((real_(y))
           => ((real_(z))
              => ((real_(t1)) => (infix_gtdt(infix_pldt(x, z), infix_pldt(y,
                 t1))))))))));

% compat_supeq_mult
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(y, x))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lseqdt(c_zero, z)) => (infix_lseqdt(infix_asdt(y, z), 
              infix_asdt(x, z)))))))));

% compat_supeq_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(y, x))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_lseqdt(infix_sldt(y, z), 
              infix_sldt(x, z)))))))));

% compat_infeq_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_lseqdt(infix_sldt(x, z), 
              infix_sldt(y, z)))))))));

% compat_sup_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_gtdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_gtdt(infix_sldt(x, z), 
              infix_sldt(y, z)))))))));

% compat_inf_div
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lsdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_lsdt(infix_sldt(x, z), 
              infix_sldt(y, z)))))))));

% positive_prod_itself
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (infix_lseqdt(c_zero, infix_asdt(x, x)))));

% strict_positive_prod_itself
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((NOT (x = c_zero)) => (infix_lsdt(c_zero, infix_asdt(x, x))))));

% compat_sup_mult
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(y, x))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lseqdt(c_zero, z)) => (infix_lseqdt(infix_asdt(y, z), 
              infix_asdt(x, z)))))))));

% strict_compat_sup_mult
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_gtdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_gtdt(infix_asdt(x, z), 
              infix_asdt(y, z)))))))));

% compat_sup_mult_left
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_lseqdt(y, x))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lseqdt(c_zero, z)) => (infix_lseqdt(infix_asdt(z, y), 
              infix_asdt(z, x)))))))));

% strict_compat_sup_mult_left
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((infix_gtdt(x, y))
  => ((real_(x))
     => ((real_(y))
        => ((real_(z))
           => ((infix_lsdt(c_zero, z)) => (infix_gtdt(infix_asdt(z, x), 
              infix_asdt(z, y)))))))));

% inv_inf_eq
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lsdt(c_zero, a))
  => ((infix_lsdt(c_zero, b))
     => ((infix_lseqdt(a, b)) => (infix_lseqdt(infix_sldt(c_one, b), 
        infix_sldt(c_one, a)))))));

% inv_sup_eq
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lsdt(c_zero, a))
  => ((infix_lsdt(c_zero, b))
     => ((infix_lseqdt(b, a)) => (infix_lseqdt(infix_sldt(c_one, a), 
        infix_sldt(c_one, b)))))));

% inv_sup
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y))
     => (((infix_lsdt(c_zero, x)) AND (infix_lsdt(x, y))) => (infix_gtdt(
        infix_sldt(c_one, x), infix_sldt(c_one, y)))))));

% inv_eqinf
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y))
     => (((infix_lsdt(c_zero, x)) AND (infix_lseqdt(x, y))) => (infix_lseqdt(
        infix_sldt(c_one, y), infix_sldt(c_one, x)))))));

% inv_eqsup
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y))
     => (((infix_lseqdt(y, x)) AND (infix_gtdt(y, c_zero))) => (infix_lseqdt(
        infix_sldt(c_one, x), infix_sldt(c_one, y)))))));

% inv_inf
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y))
     => (((infix_gtdt(x, y)) AND (infix_gtdt(y, c_zero))) => (infix_lsdt(
        infix_sldt(c_one, x), infix_sldt(c_one, y)))))));

% inv_neg
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((infix_lsdt(x, c_zero)) => (infix_lsdt(infix_sldt(c_one, x), c_zero)))));

% lower_inv
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(c_zero, b))
  => ((infix_lseqdt(c_zero, a))
     => ((infix_lseqdt(b, c)) => (infix_lseqdt(infix_sldt(a, c), 
        infix_sldt(a, b)))))));

% lower_inv_
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(c_zero, b))
  => ((infix_lseqdt(c_zero, a))
     => ((infix_lseqdt(b, c)) => (infix_lseqdt(infix_sldt(a, c), 
        infix_sldt(a, b)))))));

% zero_add_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex):
  ((a1 = c_zero) => (infix_pldt(a1, a2) = a2)));

% add_zero_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex):
  ((a2 = c_zero) => (infix_pldt(a1, a2) = a1)));

% one_mult_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex):
  ((a1 = c_one) => (infix_asdt(a1, a2) = a2)));

% one_mult_t_const
  ASSERT (FORALL (a : complex): (infix_asdt(c_one, a) = a));

% zero_mult_t_const
  ASSERT (FORALL (a : complex): (infix_asdt(c_zero, a) = c_zero));

% mult_zero_t_const
  ASSERT (FORALL (a : complex): (infix_asdt(a, c_zero) = c_zero));

% subs_eq
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b1 : complex, b2 : complex):
  ((a1 = a2) => ((b1 = b2) => (infix_mndt(a1, b1) = infix_mndt(a2, b2)))));

% subst_itself
  ASSERT
  (FORALL (a1 : complex, a2 : complex):
  ((a1 = a2) => (infix_mndt(a1, a2) = c_zero)));

% mult_assoc_four
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_asdt(
  infix_asdt(a, infix_asdt(b, c)), d) = infix_asdt(infix_asdt(a, b), 
  infix_asdt(c, d))));

% mult_assoc_rev
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(a, 
  infix_asdt(b, c)) = infix_asdt(infix_asdt(a, b), c)));

% add_assoc
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_pldt(infix_pldt(a,
  b), c) = infix_pldt(a, infix_pldt(b, c))));

% add_assoc_rev
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_pldt(a, 
  infix_pldt(b, c)) = infix_pldt(infix_pldt(a, b), c)));

% div_mult
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (c = c_zero)) => (infix_asdt(a, infix_sldt(b, c)) = infix_sldt(
  infix_asdt(a, b), c))));

% div_mult_rev
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (c = c_zero)) => (infix_sldt(infix_asdt(a, b), c) = infix_asdt(a, 
  infix_sldt(b, c)))));

% triang_p
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(infix_pldt(a, b), 
  infix_pldt(a, b)) = infix_pldt(infix_pldt(infix_asdt(a, a), infix_asdt(b,
  b)), infix_asdt(infix_asdt(infix_pldt(c_one, c_one), a), b))));

% triang_n
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(infix_mndt(a, b), 
  infix_mndt(a, b)) = infix_mndt(infix_pldt(infix_asdt(a, a), infix_asdt(b,
  b)), infix_asdt(infix_asdt(infix_pldt(c_one, c_one), a), b))));

% triang_s
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex, e : complex):
  (infix_pldt(infix_pldt(infix_pldt(a, b), c), infix_pldt(infix_mndt(d, b),
  e)) = infix_pldt(infix_pldt(a, c), infix_pldt(d, e))));

% triang_t
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(infix_pldt(a, b), 
  infix_mndt(a, b)) = infix_mndt(infix_asdt(a, a), infix_asdt(b, b))));

% triang_sr
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex, e : complex):
  (infix_pldt(infix_pldt(infix_mndt(a, b), c), infix_pldt(infix_pldt(d, b),
  e)) = infix_pldt(infix_pldt(a, c), infix_pldt(d, e))));

% add_pos
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(c_zero, x))
  => ((infix_lseqdt(c_zero, y)) => (infix_lseqdt(c_zero, infix_pldt(x, y))))));

% add_pos_strit_l
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(c_zero, x))
  => ((infix_lseqdt(c_zero, y)) => (infix_lsdt(c_zero, infix_pldt(x, y))))));

% add_pos_strit_r
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(c_zero, x))
  => ((infix_lsdt(c_zero, y)) => (infix_lsdt(c_zero, infix_pldt(x, y))))));

% modulus_pre_pre
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex):
  ((infix_pldt(infix_pldt(infix_asdt(a, b), infix_asdt(c, d)), infix_pldt(
  infix_asdt(a, d), infix_asdt(c, b))) = infix_pldt(infix_asdt(a, 
  infix_pldt(b, d)), infix_asdt(c, infix_pldt(b, d)))) AND (infix_pldt(
  infix_pldt(infix_asdt(a, b), infix_asdt(c, d)), infix_pldt(infix_asdt(a,
  d), infix_asdt(c, b))) = infix_asdt(infix_pldt(a, c), infix_pldt(b, d)))));

% modulus_pre
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_asdt(infix_asdt(a, b), infix_asdt(a, b)), infix_asdt(
  infix_asdt(c, d), infix_asdt(c, d))), infix_pldt(infix_asdt(infix_asdt(a,
  d), infix_asdt(a, d)), infix_asdt(infix_asdt(c, b), infix_asdt(c, b)))) = 
  infix_asdt(infix_pldt(infix_asdt(a, a), infix_asdt(c, c)), infix_pldt(
  infix_asdt(b, b), infix_asdt(d, d)))));

sqr: (REAL) -> REAL;

% sqr'def
  ASSERT (FORALL (x : REAL): (sqr(x) = (x * x)));

sqrt: (REAL) -> REAL;

% Sqrt_positive
  ASSERT (FORALL (x : REAL): ((0 <= x) => (0 <= sqrt(x))));

% Sqrt_square
  ASSERT (FORALL (x : REAL): ((0 <= x) => (sqr(sqrt(x)) = x)));

% Square_sqrt
  ASSERT (FORALL (x : REAL): ((0 <= x) => (sqrt((x * x)) = x)));

% Sqrt_mul
  ASSERT
  (FORALL (x : REAL, y : REAL):
  (((0 <= x) AND (0 <= y)) => (sqrt((x * y)) = (sqrt(x) * sqrt(y)))));

% Sqrt_le
  ASSERT
  (FORALL (x : REAL, y : REAL):
  (((0 <= x) AND (x <= y)) => (sqrt(x) <= sqrt(y))));

real_sqrt: (REAL) -> REAL;

% real_sqrt'spec
  ASSERT
  (FORALL (x : REAL):
  ((0 <= x)
  => (((real_sqrt(x) * real_sqrt(x)) = x) AND (real_sqrt(x) = sqrt(x)))));

square_rt: (complex) -> complex;

% square_rt'def
  ASSERT
  (FORALL (x : complex):
  ((infix_lseqdt(c_zero, x)) => (square_rt(x) = r_to_c(real_sqrt(
  real_part(x))))));

% square_rt'spec
  ASSERT
  (FORALL (x : complex):
  ((infix_lseqdt(c_zero, x))
  => ((real_(square_rt(x)))
     AND ((infix_asdt(square_rt(x), square_rt(x)) = x)
         AND (infix_lseqdt(c_zero, square_rt(x)))))));

% square_rt_eq
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(c_zero, a))
  => ((infix_lseqdt(c_zero, b))
     => ((a = b) => (square_rt(a) = square_rt(b))))));

% real_square_rt
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => ((infix_lseqdt(c_zero, x)) => (real_(square_rt(x))))));

% pos_square_rt
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((infix_lseqdt(c_zero, x)) => (infix_lseqdt(c_zero, square_rt(x))))));

% square_rt_square
  ASSERT
  (FORALL (x : complex):
  ((infix_lseqdt(c_zero, x)) => (infix_asdt(square_rt(x), square_rt(x)) = x)));

% square_rt_infeq
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y))
     => (((infix_lseqdt(c_zero, x)) AND (infix_lseqdt(x, y)))
        => (infix_lseqdt(square_rt(x), square_rt(y)))))));

% square_rt_inf
  ASSERT
  (FORALL (x : complex, y : complex):
  (((infix_lseqdt(c_zero, x)) AND (infix_lsdt(x, y))) => (infix_lsdt(
  square_rt(x), square_rt(y)))));

% injective_square_rt
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y))
     => ((infix_lseqdt(c_zero, x))
        => ((infix_lseqdt(c_zero, y))
           => ((square_rt(x) = square_rt(y)) => (x = y)))))));

% injective_square
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((real_(y))
     => ((infix_lseqdt(c_zero, x))
        => ((infix_lseqdt(c_zero, y))
           => ((infix_asdt(x, x) = infix_asdt(y, y)) => (x = y)))))));

% square_rt_c_one
  ASSERT (square_rt(c_one) = c_one);

% square_rt_mult
  ASSERT
  (FORALL (t1 : complex, tqt : complex):
  ((real_(t1))
  => ((infix_lseqdt(c_zero, t1))
     => ((real_(tqt))
        => ((infix_lseqdt(c_zero, tqt)) => (infix_asdt(square_rt(t1), 
           square_rt(tqt)) = square_rt(infix_asdt(t1, tqt))))))));

% square_rt_mult_rev
  ASSERT
  (FORALL (t1 : complex, tqt : complex):
  ((real_(t1))
  => ((infix_lseqdt(c_zero, t1))
     => ((real_(tqt))
        => ((infix_lseqdt(c_zero, tqt)) => (square_rt(infix_asdt(t1, tqt)) = 
           infix_asdt(square_rt(t1), square_rt(tqt))))))));

modulus: (complex) -> complex;

% modulus'def
  ASSERT
  (FORALL (x : complex): (modulus(x) = square_rt(infix_pldt(infix_asdt(
  t_real_part(x), t_real_part(x)), infix_asdt(t_im_part(x), t_im_part(x))))));

% modulus'spec
  ASSERT (FORALL (x : complex): (infix_lseqdt(c_zero, modulus(x))));

c_one_modulus: (complex) -> BOOLEAN;

% c_one_modulus'def
  ASSERT
  (FORALL (x : complex): ((c_one_modulus(x)) <=> (modulus(x) = c_one)));

% modulus_eq
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_asdt(t_real_part(x), t_real_part(x)) = infix_asdt(t_real_part(y), 
  t_real_part(y)))
  => ((infix_asdt(t_im_part(x), t_im_part(x)) = infix_asdt(t_im_part(y), 
     t_im_part(y))) => (modulus(x) = modulus(y)))));

% modulus_minus
  ASSERT (FORALL (x : complex): (modulus(prefix_mndt(x)) = modulus(x)));

% square_rt_simpl
  ASSERT
  (FORALL (x : complex):
  ((infix_lsdt(c_zero, x)) => (infix_asdt(x, infix_sldt(c_one, 
  square_rt(x))) = square_rt(x))));

% square_rt_simpl_fact
  ASSERT
  (FORALL (x : complex, a : complex):
  ((infix_lsdt(c_zero, x)) => (infix_asdt(infix_asdt(a, infix_sldt(c_one, 
  square_rt(x))), x) = infix_asdt(a, square_rt(x)))));

% square_rt_simpl_mult
  ASSERT
  (FORALL (x : complex, a : complex):
  ((infix_lsdt(c_zero, x)) => (infix_asdt(infix_asdt(square_rt(x), a), 
  infix_sldt(c_one, square_rt(x))) = a)));

% square_rt_simpl_fact_assoc
  ASSERT
  (FORALL (x : complex, a : complex):
  ((infix_lsdt(c_zero, x)) => (infix_asdt(x, infix_asdt(a, infix_sldt(c_one, 
  square_rt(x)))) = infix_asdt(a, square_rt(x)))));

% modulus_itself
  ASSERT
  (FORALL (x : complex, y : complex): ((x = y) => (modulus(x) = modulus(y))));

% modulus_real_pos
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => ((infix_lseqdt(c_zero, x)) => (modulus(x) = x))));

% modulus_real_pos_inv
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((infix_lseqdt(c_zero, x)) => (modulus(prefix_mndt(x)) = x))));

% modulus_real_neg
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((infix_lseqdt(x, c_zero)) => (modulus(x) = prefix_mndt(x)))));

% strict_positive_modulus
  ASSERT
  (FORALL (x : complex):
  ((NOT (x = c_zero)) => (infix_lsdt(c_zero, modulus(x)))));

% not_modulus_zero
  ASSERT
  (FORALL (x : complex): ((NOT (x = c_zero)) => (NOT (modulus(x) = c_zero))));

% modulus_real
  ASSERT (FORALL (x : complex): (real_(modulus(x))));

% t_mult_real_square
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(t_real_part(infix_asdt(a,
  b)), t_real_part(infix_asdt(a, b))) = infix_mndt(infix_pldt(infix_asdt(
  infix_asdt(t_real_part(a), t_real_part(a)), infix_asdt(t_real_part(b), 
  t_real_part(b))), infix_asdt(infix_asdt(t_im_part(a), t_im_part(a)), 
  infix_asdt(t_im_part(b), t_im_part(b)))), infix_asdt(infix_pldt(c_one,
  c_one), infix_asdt(infix_asdt(infix_asdt(t_real_part(a), t_real_part(b)), 
  t_im_part(a)), t_im_part(b))))));

% t_mult_im_square
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(t_im_part(infix_asdt(a,
  b)), t_im_part(infix_asdt(a, b))) = infix_pldt(infix_pldt(infix_asdt(
  infix_asdt(t_real_part(a), t_real_part(a)), infix_asdt(t_im_part(b), 
  t_im_part(b))), infix_asdt(infix_asdt(t_im_part(a), t_im_part(a)), 
  infix_asdt(t_real_part(b), t_real_part(b)))), infix_asdt(infix_pldt(c_one,
  c_one), infix_asdt(infix_asdt(infix_asdt(t_real_part(a), t_real_part(b)), 
  t_im_part(a)), t_im_part(b))))));

% mult_modulus_pre
  ASSERT
  (FORALL (a : complex, b : complex): (infix_pldt(infix_asdt(t_real_part(
  infix_asdt(a, b)), t_real_part(infix_asdt(a, b))), infix_asdt(t_im_part(
  infix_asdt(a, b)), t_im_part(infix_asdt(a, b)))) = infix_asdt(infix_pldt(
  infix_asdt(t_real_part(a), t_real_part(a)), infix_asdt(t_im_part(a), 
  t_im_part(a))), infix_pldt(infix_asdt(t_real_part(b), t_real_part(b)), 
  infix_asdt(t_im_part(b), t_im_part(b))))));

% mult_modulus
  ASSERT
  (FORALL (x : complex, y : complex): (modulus(infix_asdt(x, y)) = 
  infix_asdt(modulus(x), modulus(y))));

% mult_modulus_rev
  ASSERT
  (FORALL (x : complex, y : complex): (infix_asdt(modulus(x), modulus(y)) = 
  modulus(infix_asdt(x, y))));

% modulus_real_minus_bound
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((real_(b))
     => ((real_(c))
        => ((infix_lseqdt(c_zero, a))
           => ((infix_lseqdt(c_zero, b))
              => ((infix_lseqdt(c_zero, c))
                 => ((infix_lseqdt(modulus(infix_mn(a, b)), c))
                    => ((infix_lseqdt(infix_mndt(a, c), b))
                       AND (infix_lseqdt(b, infix_pldt(a, c))))))))))));

% mult_real_modulus
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((infix_lseqdt(c_zero, x)) => (modulus(infix_asdt(x, y)) = infix_asdt(x, 
     modulus(y))))));

% mult_real_modulus_rev
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((infix_lseqdt(c_zero, x)) => (infix_asdt(x, modulus(y)) = modulus(
     infix_asdt(x, y))))));

% modulus_real_div
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(x))
  => ((infix_lsdt(c_zero, x)) => (infix_sldt(modulus(y), x) = modulus(
     infix_sldt(y, x))))));

% mult_modulus_real
  ASSERT
  (FORALL (x : complex, y : complex):
  ((real_(y))
  => ((infix_lseqdt(c_zero, y)) => (modulus(infix_asdt(x, y)) = infix_asdt(
     modulus(x), y)))));

% mult_modulus_non_null
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (x = c_zero))
  => ((NOT (y = c_zero)) => (NOT (modulus(infix_asdt(x, y)) = c_zero)))));

% modulus_to_non_null
  ASSERT
  (FORALL (x : complex):
  ((infix_lsdt(c_zero, modulus(x))) => (NOT (x = c_zero))));

% mult_c_one_modulus
  ASSERT
  (FORALL (x : complex, y : complex):
  ((c_one_modulus(x))
  => ((c_one_modulus(y)) => (c_one_modulus(infix_asdt(x, y))))));

% modulus_pos
  ASSERT
  (FORALL (x : complex):
  ((NOT (x = c_zero)) => (infix_lseqdt(c_zero, modulus(x)))));

% modulus_infeq
  ASSERT
  (FORALL (x : complex, b : complex, c : complex):
  ((real_(x))
  => ((infix_lseqdt(b, c))
     => ((infix_lseqdt(modulus(x), b)) => (infix_lseqdt(x, c))))));

% modulus_inf
  ASSERT
  (FORALL (x : complex, b : complex, c : complex):
  ((real_(x))
  => ((infix_lsdt(b, c))
     => ((infix_lseqdt(modulus(x), b)) => (infix_lsdt(x, c))))));

% modulus_diff_rev
  ASSERT
  (FORALL (a : complex, b : complex): (modulus(infix_mndt(a, b)) = modulus(
  infix_mndt(b, a))));

% modulus_simpl_leq
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((real_(b))
     => ((real_(c))
        => ((infix_lsdt(c_zero, c))
           => ((infix_lseqdt(modulus(infix_asdt(a, c)), infix_asdt(b, c)))
              => (infix_lseqdt(modulus(a), b))))))));

% modulus_simpl_leq_rev
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((real_(a))
  => ((real_(b))
     => ((real_(c))
        => ((infix_lseqdt(c_zero, c))
           => ((infix_lseqdt(modulus(a), b)) => (infix_lseqdt(modulus(
              infix_asdt(a, c)), infix_asdt(b, c)))))))));

% div_eq
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b1 : complex, b2 : complex):
  ((a1 = a2)
  => ((b1 = b2)
     => ((NOT (b1 = c_zero)) => (infix_sldt(a1, b1) = infix_sldt(a2, b2))))));

% add_eq_inv_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b1 : complex, b2 : complex):
  ((a1 = a2) => ((b1 = b2) => (infix_pldt(a1, b1) = infix_pldt(b2, a2)))));

% mult_eq_inv_t
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b1 : complex, b2 : complex):
  ((a1 = a2) => ((b1 = b2) => (infix_asdt(a1, b1) = infix_asdt(b2, a2)))));

% sum_frac
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b : complex):
  ((NOT (b = c_zero)) => (infix_pldt(infix_sldt(a1, b), infix_sldt(a2, b)) = 
  infix_sldt(infix_pldt(a1, a2), b))));

% sum_frac_rev
  ASSERT
  (FORALL (a1 : complex, a2 : complex, b : complex):
  ((NOT (b = c_zero)) => (infix_sldt(infix_pldt(a1, a2), b) = infix_pldt(
  infix_sldt(a1, b), infix_sldt(a2, b)))));

% div_pos
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(c_zero, x))
  => ((infix_lsdt(c_zero, y)) => (infix_lseqdt(c_zero, infix_sldt(x, y))))));

infix_mngt: (ty, ty) -> ty;

angle : TYPE;

angle1: ty;

infix_at: (ty, ty, uni, uni) -> uni;

% infix @_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(b, infix_at(b, a, x, x1)))));

constant_f: (ty, ty, uni) -> BOOLEAN;

fc733: (ty, ty) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty): (sort(infix_mngt(b, infix_mngt(a, b)), fc733(b,
  a))));

t2tb35: ((ARRAY INT OF angle)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF angle)): (sort(infix_mngt(int, angle1), 
  t2tb35(x))));

tb2t35: (uni) -> (ARRAY INT OF angle);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF angle)):PATTERN (t2tb35(i)):  (tb2t35(
  t2tb35(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb35(tb2t35(j))): 
  ((sort(infix_mngt(int, angle1), j)) => (t2tb35(tb2t35(j)) = j)));

t2tb33: (angle) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : angle): (sort(angle1, t2tb33(x))));

tb2t33: (uni) -> angle;

% BridgeL
  ASSERT (FORALL (i : angle):PATTERN (t2tb33(i)):  (tb2t33(t2tb33(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb33(tb2t33(j))): 
  ((sort(angle1, j)) => (t2tb33(tb2t33(j)) = j)));

t2tb70: ((ARRAY angle OF (ARRAY INT OF angle))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY angle OF (ARRAY INT OF angle))): (sort(
  infix_mngt(angle1, infix_mngt(int, angle1)), t2tb70(x))));

tb2t70: (uni) -> (ARRAY angle OF (ARRAY INT OF angle));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY angle OF (ARRAY INT OF angle))):PATTERN (t2tb70(i)):  (
  tb2t70(t2tb70(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb70(tb2t70(j))): 
  ((sort(infix_mngt(angle1, infix_mngt(int, angle1)), j)) => (t2tb70(
  tb2t70(j)) = j)));

% fc'def
  ASSERT
  (FORALL (y0 : angle, y1 : INT): ((tb2t35(infix_at(infix_mngt(int, angle1),
  angle1, fc733(angle1, int), t2tb33(y0)))[y1]) = y0));

t2tb7: ((ARRAY INT OF INT)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF INT)): (sort(infix_mngt(int, int), t2tb7(x))));

tb2t7: (uni) -> (ARRAY INT OF INT);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF INT)):PATTERN (t2tb7(i)):  (tb2t7(
  t2tb7(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb7(tb2t7(j))):  (t2tb7(tb2t7(j)) = j));

t2tb5: (INT) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : INT): (sort(int, t2tb5(x))));

tb2t5: (uni) -> INT;

% BridgeL
  ASSERT (FORALL (i : INT):PATTERN (t2tb5(i)):  (tb2t5(t2tb5(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb5(tb2t5(j))):  (t2tb5(tb2t5(j)) = j));

t2tb8: ((ARRAY INT OF (ARRAY INT OF INT))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF (ARRAY INT OF INT))): (sort(infix_mngt(int, 
  infix_mngt(int, int)), t2tb8(x))));

tb2t8: (uni) -> (ARRAY INT OF (ARRAY INT OF INT));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF (ARRAY INT OF INT))):PATTERN (t2tb8(i)):  (
  tb2t8(t2tb8(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb8(tb2t8(j))):  (t2tb8(tb2t8(j)) = j));

% fc'def
  ASSERT
  (FORALL (y0 : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  fc733(int, int), t2tb5(y0)))[y1]) = y0));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (y0 : uni, y1 : uni):
  ((sort(b, y0)) => (infix_at(b, a, infix_at(infix_mngt(a, b), b, fc733(b,
  a), y0), y1) = y0))));

% constant_f'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni):
  ((sort(infix_mngt(a, b), f))
  => (((constant_f(b, a, f))
      => (EXISTS (a1 : uni):
         ((sort(b, a1)) AND (f = infix_at(infix_mngt(a, b), b, fc733(b, a),
         a1)))))
     AND ((EXISTS (a1 : uni): (f = infix_at(infix_mngt(a, b), b, fc733(b, a),
          a1)))
         => (constant_f(b, a, f)))))));

op: (ty, uni, uni) -> uni;

% op_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : uni): (sort(im1, op(im1, x, x1)))));

po: (ty, uni, uni) -> uni;

% po_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : uni): (sort(im1, po(im1, x, x1)))));

inver: (ty, uni) -> uni;

% inver_sort
  ASSERT (FORALL (im1 : ty): (FORALL (x : uni): (sort(im1, inver(im1, x)))));

set: (ty) -> ty;

mem: (ty, uni, uni) -> BOOLEAN;

add: (ty, uni, uni) -> uni;

% add_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), add(a, x, x1)))));

empty: (ty) -> uni;

% empty_sort
  ASSERT (FORALL (a : ty): (sort(set(a), empty(a))));

cardinal: (ty, uni) -> INT;

choose: (ty, uni) -> uni;

% choose_sort
  ASSERT (FORALL (a : ty): (FORALL (x : uni): (sort(a, choose(a, x)))));

remove: (ty, uni, uni) -> uni;

% remove_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), remove(a, x, x1)))));

filter_: (ty, uni, uni) -> uni;

% filter__sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), filter_(a, x, x1)))));

union: (ty, uni, uni) -> uni;

% union_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), union(a, x, x1)))));

infix_eqeq1: (ty, uni, uni) -> BOOLEAN;

% infix =='def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni):
  (((infix_eqeq1(a, s11, s2))
   => (FORALL (x : uni): ((mem(a, x, s11)) <=> (mem(a, x, s2)))))
  AND ((FORALL (x : uni):
       ((sort(a, x)) => ((mem(a, x, s11)) <=> (mem(a, x, s2)))))
      => (infix_eqeq1(a, s11, s2))))));

% extensionality
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni):
  ((sort(set(a), s11))
  => ((sort(set(a), s2)) => ((infix_eqeq1(a, s11, s2)) => (s11 = s2))))));

subset: (ty, uni, uni) -> BOOLEAN;

% subset'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni):
  (((subset(a, s11, s2))
   => (FORALL (x : uni): ((mem(a, x, s11)) => (mem(a, x, s2)))))
  AND ((FORALL (x : uni):
       ((sort(a, x)) => ((mem(a, x, s11)) => (mem(a, x, s2)))))
      => (subset(a, s11, s2))))));

% subset_refl
  ASSERT (FORALL (a : ty): (FORALL (s2 : uni): (subset(a, s2, s2))));

% subset_trans
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni, s3 : uni):
  ((subset(a, s11, s2)) => ((subset(a, s2, s3)) => (subset(a, s11, s3))))));

is_empty: (ty, uni) -> BOOLEAN;

% is_empty'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  (((is_empty(a, s2)) => (FORALL (x : uni): (NOT (mem(a, x, s2)))))
  AND ((FORALL (x : uni): ((sort(a, x)) => (NOT (mem(a, x, s2)))))
      => (is_empty(a, s2))))));

% is_empty_empty
  ASSERT (FORALL (a : ty): (is_empty(a, empty(a))));

% empty_is_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((sort(set(a), s2)) => ((is_empty(a, s2)) => (s2 = empty(a))))));

% add_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, s2 : uni, y : uni):
  ((sort(a, x))
  => ((sort(a, y))
     => ((mem(a, y, add(a, x, s2))) <=> ((mem(a, y, s2)) OR (y = x)))))));

% mem_singleton
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, y : uni):
  ((sort(a, x))
  => ((sort(a, y)) => ((mem(a, y, add(a, x, empty(a)))) => (y = x))))));

% remove_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, s2 : uni, y : uni):
  ((sort(a, x))
  => ((sort(a, y))
     => ((mem(a, y, remove(a, x, s2)))
        <=> ((mem(a, y, s2)) AND (NOT (y = x))))))));

% add_remove
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, s2 : uni):
  ((sort(set(a), s2))
  => ((mem(a, x, s2)) => (add(a, x, remove(a, x, s2)) = s2)))));

% remove_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, s2 : uni): (remove(a, x, add(a, x, s2)) = remove(a, x,
  s2))));

% subset_remove
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, s2 : uni): (subset(a, remove(a, x, s2), s2))));

% union_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni, x : uni):
  ((mem(a, x, union(a, s11, s2))) <=> ((mem(a, x, s11)) OR (mem(a, x, s2))))));

% subset_union_1
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni): (subset(a, s11, union(a, s11, s2)))));

% subset_union_2
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni): (subset(a, s2, union(a, s11, s2)))));

inter: (ty, uni, uni) -> uni;

% inter_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), inter(a, x, x1)))));

% inter_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni, x : uni):
  ((mem(a, x, inter(a, s11, s2))) <=> ((mem(a, x, s11)) AND (mem(a, x, s2))))));

% subset_inter_1
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni): (subset(a, inter(a, s11, s2), s11))));

% subset_inter_2
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni): (subset(a, inter(a, s11, s2), s2))));

diff: (ty, uni, uni) -> uni;

% diff_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), diff(a, x, x1)))));

% diff_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni, x : uni):
  ((mem(a, x, diff(a, s11, s2)))
  <=> ((mem(a, x, s11)) AND (NOT (mem(a, x, s2)))))));

% subset_diff
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni): (subset(a, diff(a, s11, s2), s11))));

% pick_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((NOT (is_empty(a, s2))) => (mem(a, choose(a, s2), s2)))));

disjoint: (ty, uni, uni) -> BOOLEAN;

% disjoint'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni):
  (((disjoint(a, s11, s2))
   => (FORALL (x : uni): ((NOT (mem(a, x, s11))) OR (NOT (mem(a, x, s2))))))
  AND ((FORALL (x : uni):
       ((sort(a, x)) => ((NOT (mem(a, x, s11))) OR (NOT (mem(a, x, s2))))))
      => (disjoint(a, s11, s2))))));

% disjoint_inter_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni):
  ((disjoint(a, s11, s2)) <=> (is_empty(a, inter(a, s11, s2))))));

% disjoint_diff_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni):
  ((sort(set(a), s11))
  => ((disjoint(a, s11, s2)) <=> (diff(a, s11, s2) = s11)))));

% disjoint_diff_s2
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni): (disjoint(a, diff(a, s11, s2), s2))));

t2tb2: (BITVECTOR(1)) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : BITVECTOR(1)): (sort(bool, t2tb2(x))));

tb2t2: (uni) -> BITVECTOR(1);

% BridgeL
  ASSERT
  (FORALL (i : BITVECTOR(1)):PATTERN (t2tb2(i)):  (tb2t2(t2tb2(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb2(tb2t2(j))): 
  ((sort(bool, j)) => (t2tb2(tb2t2(j)) = j)));

% filter_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni, x : uni):
  ((mem(a, x, filter_(a, s2, p)))
  <=> ((mem(a, x, s2)) AND (tb2t2(infix_at(bool, a, p, x)) = 0bin1)))));

% subset_filter
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni): (subset(a, filter_(a, s2, p), s2))));

map: (ty, ty, uni, uni) -> uni;

% map_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(b), map(b, a, x, x1)))));

set_angle: TYPE;

t2tb71: (set_angle) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : set_angle): (sort(set(angle1), t2tb71(x))));

tb2t71: (uni) -> set_angle;

% BridgeL
  ASSERT
  (FORALL (i : set_angle):PATTERN (t2tb71(i)):  (tb2t71(t2tb71(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb71(tb2t71(j))): 
  ((sort(set(angle1), j)) => (t2tb71(tb2t71(j)) = j)));

set_int: TYPE;

t2tb6: (set_int) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : set_int): (sort(set(int), t2tb6(x))));

tb2t6: (uni) -> set_int;

% BridgeL
  ASSERT (FORALL (i : set_int):PATTERN (t2tb6(i)):  (tb2t6(t2tb6(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb6(tb2t6(j))):  (t2tb6(tb2t6(j)) = j));

% map_def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), u : set_int, y : angle):
  ((mem(angle1, t2tb33(y), map(angle1, int, t2tb35(f), t2tb6(u))))
  <=> (EXISTS (x : INT): ((mem(int, t2tb5(x), t2tb6(u))) AND (y = (f[x]))))));

% map_def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), u : set_int, y : INT):
  ((mem(int, t2tb5(y), map(int, int, t2tb7(f), t2tb6(u))))
  <=> (EXISTS (x : INT): ((mem(int, t2tb5(x), t2tb6(u))) AND (y = (f[x]))))));

% map_def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, u : uni, y : uni):
  ((sort(b, y))
  => (((mem(b, y, map(b, a, f, u)))
      => (EXISTS (x : uni):
         ((sort(a, x)) AND ((mem(a, x, u)) AND (y = infix_at(b, a, f, x))))))
     AND ((EXISTS (x : uni): ((mem(a, x, u)) AND (y = infix_at(b, a, f, x))))
         => (mem(b, y, map(b, a, f, u))))))));

% mem_map
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), u : set_int):
  (FORALL (x : INT):
  ((mem(int, t2tb5(x), t2tb6(u))) => (mem(angle1, t2tb33((f[x])), map(angle1,
  int, t2tb35(f), t2tb6(u)))))));

% mem_map
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), u : set_int):
  (FORALL (x : INT):
  ((mem(int, t2tb5(x), t2tb6(u))) => (mem(int, t2tb5((f[x])), map(int, int, 
  t2tb7(f), t2tb6(u)))))));

% mem_map
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, u : uni):
  (FORALL (x : uni):
  ((mem(a, x, u)) => (mem(b, infix_at(b, a, f, x), map(b, a, f, u)))))));

% cardinal_nonneg
  ASSERT (FORALL (a : ty): (FORALL (s2 : uni): (0 <= cardinal(a, s2))));

% cardinal_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni): ((is_empty(a, s2)) <=> (cardinal(a, s2) = 0))));

% cardinal_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni):
  (FORALL (s2 : uni):
  (IF (mem(a, x, s2)) THEN (cardinal(a, add(a, x, s2)) = cardinal(a, s2))
  ELSE (cardinal(a, add(a, x, s2)) = (cardinal(a, s2) + 1)) ENDIF))));

% cardinal_remove
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni):
  (FORALL (s2 : uni):
  (IF (mem(a, x, s2)) THEN (cardinal(a, remove(a, x, s2)) = (cardinal(a,
  s2) - 1)) ELSE (cardinal(a, remove(a, x, s2)) = cardinal(a, s2)) ENDIF))));

% cardinal_subset
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni):
  ((subset(a, s11, s2)) => (cardinal(a, s11) <= cardinal(a, s2)))));

% subset_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni):
  ((sort(set(a), s11))
  => ((sort(set(a), s2))
     => ((subset(a, s11, s2))
        => ((cardinal(a, s11) = cardinal(a, s2)) => (s11 = s2)))))));

% cardinal1
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((cardinal(a, s2) = 1)
  => (FORALL (x : uni):
     ((sort(a, x)) => ((mem(a, x, s2)) => (x = choose(a, s2))))))));

% cardinal_union
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni): (cardinal(a, union(a, s11, s2)) = ((
  cardinal(a, s11) + cardinal(a, s2)) - cardinal(a, inter(a, s11, s2))))));

% cardinal_inter_disjoint
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni):
  ((disjoint(a, s11, s2)) => (cardinal(a, inter(a, s11, s2)) = 0))));

% cardinal_diff
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni): (cardinal(a, diff(a, s11, s2)) = (
  cardinal(a, s11) - cardinal(a, inter(a, s11, s2))))));

% cardinal_filter
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni): (cardinal(a, filter_(a, s2, p)) <= cardinal(a,
  s2))));

% cardinal_map
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni): (cardinal(b, map(b, a, f, s2)) <= cardinal(a,
  s2))));

tuple2: (ty, ty) -> ty;

Tuple2: (ty, ty, uni, uni) -> uni;

% Tuple2_sort
  ASSERT
  (FORALL (a : ty, a1 : ty):
  (FORALL (x : uni, x1 : uni): (sort(tuple2(a1, a), Tuple2(a1, a, x, x1)))));

Tuple2_proj_11: (ty, ty, uni) -> uni;

% Tuple2_proj_1_sort
  ASSERT
  (FORALL (a : ty, a1 : ty):
  (FORALL (x : uni): (sort(a1, Tuple2_proj_11(a1, a, x)))));

% Tuple2_proj_1'def
  ASSERT
  (FORALL (a : ty, a1 : ty):
  (FORALL (u : uni, u1 : uni):
  ((sort(a1, u)) => (Tuple2_proj_11(a1, a, Tuple2(a1, a, u, u1)) = u))));

Tuple2_proj_21: (ty, ty, uni) -> uni;

% Tuple2_proj_2_sort
  ASSERT
  (FORALL (a : ty, a1 : ty):
  (FORALL (x : uni): (sort(a, Tuple2_proj_21(a1, a, x)))));

% Tuple2_proj_2'def
  ASSERT
  (FORALL (a : ty, a1 : ty):
  (FORALL (u : uni, u1 : uni):
  ((sort(a, u1)) => (Tuple2_proj_21(a1, a, Tuple2(a1, a, u, u1)) = u1))));

% tuple2_inversion
  ASSERT
  (FORALL (a : ty, a1 : ty):
  (FORALL (u : uni):
  ((sort(tuple2(a1, a), u)) => (u = Tuple2(a1, a, Tuple2_proj_11(a1, a, u), 
  Tuple2_proj_21(a1, a, u))))));

fir: (ty, ty, uni) -> uni;

% fir_sort
  ASSERT
  (FORALL (a : ty, b : ty): (FORALL (x : uni): (sort(a, fir(b, a, x)))));

% fir'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni):
  ((sort(a, x)) => (fir(b, a, Tuple2(a, b, x, x1)) = x))));

sec: (ty, ty, uni) -> uni;

% sec_sort
  ASSERT
  (FORALL (a : ty, b : ty): (FORALL (x : uni): (sort(b, sec(b, a, x)))));

% sec'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni):
  ((sort(b, x1)) => (sec(b, a, Tuple2(a, b, x, x1)) = x1))));

% get_fir
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, b1 : uni):
  ((sort(a, a1)) => (fir(b, a, Tuple2(a, b, a1, b1)) = a1))));

% get_sec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, b1 : uni):
  ((sort(b, b1)) => (sec(b, a, Tuple2(a, b, a1, b1)) = b1))));

% set_pair
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (o : uni):
  ((sort(tuple2(a, b), o)) => (o = Tuple2(a, b, fir(b, a, o), sec(b, a, o))))));

ref: (ty) -> ty;

refqtmk: (ty, uni) -> uni;

% ref'mk_sort
  ASSERT
  (FORALL (a : ty): (FORALL (x : uni): (sort(ref(a), refqtmk(a, x)))));

shor_ : TYPE;

shor_1: ty;

contents: (ty, uni) -> uni;

% contents_sort
  ASSERT (FORALL (a : ty): (FORALL (x : uni): (sort(a, contents(a, x)))));

ref_shor_: TYPE;

contents1: (ref_shor_) -> shor_;

t2tb3: (ref_shor_) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : ref_shor_): (sort(ref(shor_1), t2tb3(x))));

tb2t3: (uni) -> ref_shor_;

% BridgeL
  ASSERT (FORALL (i : ref_shor_):PATTERN (t2tb3(i)):  (tb2t3(t2tb3(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb3(tb2t3(j))): 
  ((sort(ref(shor_1), j)) => (t2tb3(tb2t3(j)) = j)));

t2tb4: (shor_) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : shor_): (sort(shor_1, t2tb4(x))));

tb2t4: (uni) -> shor_;

% BridgeL
  ASSERT (FORALL (i : shor_):PATTERN (t2tb4(i)):  (tb2t4(t2tb4(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb4(tb2t4(j))): 
  ((sort(shor_1, j)) => (t2tb4(tb2t4(j)) = j)));

% contents'def
  ASSERT
  (FORALL (u : shor_): (contents1(tb2t3(refqtmk(shor_1, t2tb4(u)))) = u));

% contents'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (u : uni): ((sort(a, u)) => (contents(a, refqtmk(a, u)) = u))));

% ref_inversion
  ASSERT
  (FORALL (u : ref_shor_): (u = tb2t3(refqtmk(shor_1, t2tb4(contents1(u))))));

% ref_inversion
  ASSERT
  (FORALL (a : ty):
  (FORALL (u : uni): ((sort(ref(a), u)) => (u = refqtmk(a, contents(a, u))))));

% set_equal
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((sort(set(a), s2))
  => ((sort(set(a), sqt))
     => ((FORALL (e : uni):
         ((sort(a, e)) => ((mem(a, e, s2)) => (mem(a, e, sqt)))))
        => ((FORALL (e : uni):
            ((sort(a, e)) => ((mem(a, e, sqt)) => (mem(a, e, s2)))))
           => (s2 = sqt)))))));

% set_equal_eqq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((FORALL (e : uni):
   ((sort(a, e)) => ((mem(a, e, s2)) => (mem(a, e, sqt)))))
  => ((FORALL (e : uni):
      ((sort(a, e)) => ((mem(a, e, sqt)) => (mem(a, e, s2)))))
     => (infix_eqeq(set(a), s2, sqt))))));

% union_exchange
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((NOT (is_empty(a, sqt))) => (union(a, add(a, choose(a, sqt), s2), 
  remove(a, choose(a, sqt), sqt)) = union(a, s2, sqt)))));

% get_filter
  ASSERT
  (FORALL (a : ty):
  (FORALL (p : uni, s2 : uni, x : uni):
  ((mem(a, x, filter_(a, s2, p)))
  => ((tb2t2(infix_at(bool, a, p, x)) = 0bin1) AND (mem(a, x, s2))))));

% set_filter
  ASSERT
  (FORALL (a : ty):
  (FORALL (p : uni, s2 : uni, x : uni):
  ((tb2t2(infix_at(bool, a, p, x)) = 0bin1)
  => ((mem(a, x, s2)) => (mem(a, x, filter_(a, s2, p)))))));

% inter_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((is_empty(a, s2)) => (is_empty(a, inter(a, s2, sqt))))));

% inter_empty_comm
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((is_empty(a, sqt)) => (is_empty(a, inter(a, s2, sqt))))));

% inter_empty_elts
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((FORALL (e : uni):
   ((sort(a, e)) => ((mem(a, e, s2)) => (NOT (mem(a, e, sqt))))))
  => (is_empty(a, inter(a, s2, sqt))))));

% inter_sym
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni): (inter(a, s2, sqt) = inter(a, sqt, s2))));

% union_sym
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni): (union(a, s2, sqt) = union(a, sqt, s2))));

% union_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((sort(set(a), sqt)) => ((is_empty(a, s2)) => (union(a, s2, sqt) = sqt)))));

% union_comm
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((sort(set(a), s2)) => ((is_empty(a, sqt)) => (union(a, s2, sqt) = s2)))));

% union_members
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((FORALL (a1 : uni):
   ((mem(a, a1, union(a, s2, sqt)))
   => ((NOT (mem(a, a1, s2))) => (mem(a, a1, sqt)))))
  AND (FORALL (a1 : uni):
      ((mem(a, a1, union(a, s2, sqt)))
      => ((NOT (mem(a, a1, sqt))) => (mem(a, a1, s2))))))));

% union_alt
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, e : uni):
  ((mem(a, e, union(a, s2, sqt)))
  => ((NOT (mem(a, e, s2))) => (mem(a, e, sqt))))));

% union_empty_comm
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((sort(set(a), s2)) => ((is_empty(a, sqt)) => (union(a, s2, sqt) = s2)))));

% set_subset
  ASSERT
  (FORALL (a : ty):
  (FORALL (sqt : uni, s2 : uni):
  ((FORALL (e : uni):
   ((sort(a, e)) => ((mem(a, e, sqt)) => (mem(a, e, s2)))))
  => (subset(a, sqt, s2)))));

% set_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((sort(set(a), s2))
  => ((FORALL (e : uni): ((sort(a, e)) => (NOT (mem(a, e, s2)))))
     => ((s2 = empty(a)) AND (is_empty(a, s2)))))));

% get_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((s2 = empty(a))
  => ((FORALL (e : uni): (NOT (mem(a, e, s2)))) AND (is_empty(a, s2))))));

% get_non_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((NOT (is_empty(a, s2)))
  => (EXISTS (e : uni): ((sort(a, e)) AND (mem(a, e, s2)))))));

% set_non_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((EXISTS (e : uni): (mem(a, e, s2)))
  => ((NOT (is_empty(a, s2))) AND (0 < cardinal(a, s2))))));

% set_pos_card_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, a1 : uni): ((mem(a, a1, s2)) => (0 < cardinal(a, s2)))));

% union_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, x : uni):
  ((NOT (mem(a, x, sqt))) => (union(a, s2, add(a, x, sqt)) = add(a, x, 
  union(a, s2, sqt))))));

% union_add_mem
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, x : uni, y : uni):
  ((sort(a, x))
  => ((sort(a, y))
     => ((mem(a, x, add(a, y, union(a, s2, sqt))))
        => ((NOT (mem(a, x, sqt))) => ((NOT (mem(a, x, s2))) => (x = y))))))));

% union_add_comm
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, x : uni):
  ((NOT (mem(a, x, sqt))) => (add(a, x, union(a, s2, sqt)) = union(a, s2, 
  add(a, x, sqt))))));

p_injective: (ty, ty, uni, uni) -> BOOLEAN;

% p_injective'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int):
  ((p_injective(angle1, int, t2tb35(f), t2tb6(s2)))
  <=> (FORALL (e : INT, eqt : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(int, t2tb5(eqt), t2tb6(s2)))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))));

% p_injective'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  ((p_injective(int, int, t2tb7(f), t2tb6(s2)))
  <=> (FORALL (e : INT, eqt : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(int, t2tb5(eqt), t2tb6(s2)))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))));

% p_injective'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  ((p_injective(b, a, f, s2))
  <=> (FORALL (e : uni, eqt : uni):
      ((sort(a, e))
      => ((sort(a, eqt))
         => ((mem(a, e, s2))
            => ((mem(a, eqt, s2))
               => ((NOT (e = eqt))
                  => (NOT (infix_at(b, a, f, e) = infix_at(b, a, f, eqt))))))))))));

% set_map_mem
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, b : angle):
  ((EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND (b = (f[a]))))
  => (mem(angle1, t2tb33(b), map(angle1, int, t2tb35(f), t2tb6(s2))))));

% set_map_mem
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, b : INT):
  ((EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND (b = (f[a]))))
  => (mem(int, t2tb5(b), map(int, int, t2tb7(f), t2tb6(s2))))));

% set_map_mem
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, b1 : uni):
  ((EXISTS (a1 : uni): ((mem(a, a1, s2)) AND (b1 = infix_at(b, a, f, a1))))
  => (mem(b, b1, map(b, a, f, s2))))));

% map_add
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, x : INT):
  ((NOT (mem(int, t2tb5(x), t2tb6(s2)))) => (tb2t71(map(angle1, int, 
  t2tb35(f), add(int, t2tb5(x), t2tb6(s2)))) = tb2t71(add(angle1, 
  t2tb33((f[x])), map(angle1, int, t2tb35(f), t2tb6(s2)))))));

% map_add
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, x : INT):
  ((NOT (mem(int, t2tb5(x), t2tb6(s2)))) => (tb2t6(map(int, int, t2tb7(f), 
  add(int, t2tb5(x), t2tb6(s2)))) = tb2t6(add(int, t2tb5((f[x])), map(int,
  int, t2tb7(f), t2tb6(s2)))))));

% map_add
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, x : uni):
  ((NOT (mem(a, x, s2))) => (map(b, a, f, add(a, x, s2)) = add(b, infix_at(b,
  a, f, x), map(b, a, f, s2))))));

% map_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), s2 : set_int):
  ((FORALL (e : INT): ((mem(int, t2tb5(e), t2tb6(s2))) => ((f[e]) = (g[e]))))
  => (tb2t71(map(angle1, int, t2tb35(f), t2tb6(s2))) = tb2t71(map(angle1,
  int, t2tb35(g), t2tb6(s2))))));

% map_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), s2 : set_int):
  ((FORALL (e : INT): ((mem(int, t2tb5(e), t2tb6(s2))) => ((f[e]) = (g[e]))))
  => (tb2t6(map(int, int, t2tb7(f), t2tb6(s2))) = tb2t6(map(int, int, 
  t2tb7(g), t2tb6(s2))))));

% map_eq
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, g : uni, s2 : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (infix_at(b, a, f, e) = infix_at(b, a, g, e)))))
  => (map(b, a, f, s2) = map(b, a, g, s2)))));

% remove_mem
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, e : uni, f : uni):
  ((mem(a, e, remove(a, f, s2))) => (mem(a, e, s2)))));

% injective_map_cardinal
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  ((p_injective(b, a, f, s2)) => (cardinal(b, map(b, a, f, s2)) = cardinal(a,
  s2)))));

% set_map_mem_el
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, b : angle, a : INT):
  ((mem(int, t2tb5(a), t2tb6(s2)))
  => ((b = (f[a])) => (mem(angle1, t2tb33(b), map(angle1, int, t2tb35(f), 
     t2tb6(s2)))))));

% set_map_mem_el
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, b : INT, a : INT):
  ((mem(int, t2tb5(a), t2tb6(s2)))
  => ((b = (f[a])) => (mem(int, t2tb5(b), map(int, int, t2tb7(f), 
     t2tb6(s2)))))));

% set_map_mem_el
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, b1 : uni, a1 : uni):
  ((mem(a, a1, s2))
  => ((b1 = infix_at(b, a, f, a1)) => (mem(b, b1, map(b, a, f, s2)))))));

% set_map_mem_el_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, b : angle):
  ((EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND (b = (f[a]))))
  => (mem(angle1, t2tb33(b), map(angle1, int, t2tb35(f), t2tb6(s2))))));

% set_map_mem_el_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, b : INT):
  ((EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND (b = (f[a]))))
  => (mem(int, t2tb5(b), map(int, int, t2tb7(f), t2tb6(s2))))));

% set_map_mem_el_gen
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, b1 : uni):
  ((EXISTS (a1 : uni): ((mem(a, a1, s2)) AND (b1 = infix_at(b, a, f, a1))))
  => (mem(b, b1, map(b, a, f, s2))))));

% map_antec
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, b : angle):
  ((mem(angle1, t2tb33(b), map(angle1, int, t2tb35(f), t2tb6(s2))))
  => (EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND (b = (f[a]))))));

% map_antec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, b : INT):
  ((mem(int, t2tb5(b), map(int, int, t2tb7(f), t2tb6(s2))))
  => (EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND (b = (f[a]))))));

% map_antec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, b1 : uni):
  ((sort(b, b1))
  => ((mem(b, b1, map(b, a, f, s2)))
     => (EXISTS (a1 : uni):
        ((sort(a, a1))
        AND ((mem(a, a1, s2)) AND (b1 = infix_at(b, a, f, a1)))))))));

% map_antec_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int):
  (FORALL (b : angle):
  ((mem(angle1, t2tb33(b), map(angle1, int, t2tb35(f), t2tb6(s2))))
  => (EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND (b = (f[a])))))));

% map_antec_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  (FORALL (b : INT):
  ((mem(int, t2tb5(b), map(int, int, t2tb7(f), t2tb6(s2))))
  => (EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND (b = (f[a])))))));

% map_antec_gen
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  (FORALL (b1 : uni):
  ((sort(b, b1))
  => ((mem(b, b1, map(b, a, f, s2)))
     => (EXISTS (a1 : uni):
        ((sort(a, a1))
        AND ((mem(a, a1, s2)) AND (b1 = infix_at(b, a, f, a1))))))))));

% map_remove_choose
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF angle)):
  ((p_injective(angle1, int, t2tb35(f), t2tb6(s2))) => (tb2t71(map(angle1,
  int, t2tb35(f), remove(int, choose(int, t2tb6(s2)), t2tb6(s2)))) = tb2t71(
  remove(angle1, t2tb33((f[tb2t5(choose(int, t2tb6(s2)))])), map(angle1, int, 
  t2tb35(f), t2tb6(s2)))))));

% map_remove_choose
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT)):
  ((p_injective(int, int, t2tb7(f), t2tb6(s2))) => (tb2t6(map(int, int, 
  t2tb7(f), remove(int, choose(int, t2tb6(s2)), t2tb6(s2)))) = tb2t6(
  remove(int, t2tb5((f[tb2t5(choose(int, t2tb6(s2)))])), map(int, int, 
  t2tb7(f), t2tb6(s2)))))));

% map_remove_choose
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni):
  ((p_injective(b, a, f, s2)) => (map(b, a, f, remove(a, choose(a, s2),
  s2)) = remove(b, infix_at(b, a, f, choose(a, s2)), map(b, a, f, s2))))));

antec_set: (ty, ty, uni, uni, uni) -> uni;

% antec_set_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(set(a), antec_set(b, a, x, x1,
  x2)))));

result92: (ty, ty, uni, uni) -> uni;

% result_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, bool), result92(b, a, x,
  x1)))));

t2tb9: ((ARRAY INT OF BITVECTOR(1))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF BITVECTOR(1))): (sort(infix_mngt(int, bool), 
  t2tb9(x))));

tb2t9: (uni) -> (ARRAY INT OF BITVECTOR(1));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF BITVECTOR(1))):PATTERN (t2tb9(i)):  (tb2t9(
  t2tb9(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb9(tb2t9(j))): 
  ((sort(infix_mngt(int, bool), j)) => (t2tb9(tb2t9(j)) = j)));

% result'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), b : angle, e : INT):
  ((tb2t2(infix_at(bool, int, result92(angle1, int, t2tb35(f), t2tb33(b)), 
  t2tb5(e))) = 0bin1) <=> ((f[e]) = b)));

% result'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), b : INT, e : INT):
  ((tb2t2(infix_at(bool, int, result92(int, int, t2tb7(f), t2tb5(b)), 
  t2tb5(e))) = 0bin1) <=> ((f[e]) = b)));

% result'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, b1 : uni, e : uni):
  ((sort(b, b1))
  => ((tb2t2(infix_at(bool, a, result92(b, a, f, b1), e)) = 0bin1) <=> (
     infix_at(b, a, f, e) = b1)))));

% antec_set'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni, b1 : uni):
  ((mem(b, b1, map(b, a, f, s2))) => (antec_set(b, a, s2, f, b1) = filter_(a,
  s2, result92(b, a, f, b1))))));

remove_s: (ty, uni, uni) -> uni;

% remove_s_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), remove_s(a, x, x1)))));

result93: (ty, uni) -> uni;

% result_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni): (sort(infix_mngt(a, bool), result93(a, x)))));

% result'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (sqt : uni, e : uni):
  ((tb2t2(infix_at(bool, a, result93(a, sqt), e)) = 0bin1)
  <=> (NOT (mem(a, e, sqt))))));

% remove_s'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((subset(a, sqt, s2)) => (remove_s(a, s2, sqt) = filter_(a, s2, result93(a,
  sqt))))));

% remove_s'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((subset(a, sqt, s2))
  => (FORALL (e : uni):
     ((mem(a, e, remove_s(a, s2, sqt)))
     <=> ((mem(a, e, s2)) AND (NOT (mem(a, e, sqt)))))))));

remove_antecs: (ty, ty, uni, uni, uni) -> uni;

% remove_antecs_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(set(a), remove_antecs(b, a, x,
  x1, x2)))));

% remove_antecs'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni, b1 : uni):
  ((mem(b, b1, map(b, a, f, s2))) => (remove_antecs(b, a, s2, f, b1) = 
  remove_s(a, s2, antec_set(b, a, s2, f, b1))))));

% remove_antecs'spec
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF angle), b : angle):
  ((mem(angle1, t2tb33(b), map(angle1, int, t2tb35(f), t2tb6(s2))))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), remove_antecs(angle1, int, t2tb6(s2), t2tb35(f), 
      t2tb33(b))))
      <=> ((mem(int, t2tb5(e), t2tb6(s2))) AND (NOT ((f[e]) = b)))))
     AND (cardinal(int, remove_antecs(angle1, int, t2tb6(s2), t2tb35(f), 
     t2tb33(b))) < cardinal(int, t2tb6(s2))))));

% remove_antecs'spec
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT), b : INT):
  ((mem(int, t2tb5(b), map(int, int, t2tb7(f), t2tb6(s2))))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), remove_antecs(int, int, t2tb6(s2), t2tb7(f), 
      t2tb5(b))))
      <=> ((mem(int, t2tb5(e), t2tb6(s2))) AND (NOT ((f[e]) = b)))))
     AND (cardinal(int, remove_antecs(int, int, t2tb6(s2), t2tb7(f), 
     t2tb5(b))) < cardinal(int, t2tb6(s2))))));

% remove_antecs'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni, b1 : uni):
  ((sort(b, b1))
  => ((mem(b, b1, map(b, a, f, s2)))
     => ((FORALL (e : uni):
         ((mem(a, e, remove_antecs(b, a, s2, f, b1)))
         <=> ((mem(a, e, s2)) AND (NOT (infix_at(b, a, f, e) = b1)))))
        AND (cardinal(a, remove_antecs(b, a, s2, f, b1)) < cardinal(a, s2)))))));

% map_remove_antec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni, b1 : uni):
  ((mem(b, b1, map(b, a, f, s2))) => (map(b, a, f, remove_antecs(b, a, s2, f,
  b1)) = remove(b, b1, map(b, a, f, s2))))));

% map_non_empty
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  ((0 < cardinal(a, s2)) => (0 < cardinal(b, map(b, a, f, s2))))));

% non_empty_map
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  ((0 < cardinal(b, map(b, a, f, s2))) => (0 < cardinal(a, s2)))));

right_injections: (ty, ty, uni, uni) -> uni;

% right_injections_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(tuple2(a, b)), right_injections(b,
  a, x, x1)))));

% right_injections'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, s2 : uni):
  (IF (infix_eqeq(set(b), s2, empty(b))) THEN (right_injections(b, a, a1,
  s2) = empty(tuple2(a, b))) ELSE (right_injections(b, a, a1, s2) = add(
  tuple2(a, b), Tuple2(a, b, a1, choose(b, s2)), right_injections(b, a, a1, 
  remove(b, choose(b, s2), s2)))) ENDIF)));

Tuple2_closure: (ty, ty) -> uni;

% Tuple2_closure_sort
  ASSERT
  (FORALL (a : ty, a1 : ty): (sort(infix_mngt(a1, infix_mngt(a, tuple2(a1,
  a))), Tuple2_closure(a1, a))));

% Tuple2_closure_def
  ASSERT
  (FORALL (a : ty, a1 : ty):
  (FORALL (y : uni, y1 : uni): (infix_at(tuple2(a1, a), a, infix_at(
  infix_mngt(a, tuple2(a1, a)), a1, Tuple2_closure(a1, a), y), y1) = 
  Tuple2(a1, a, y, y1))));

% right_injections'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, s2 : uni):
  ((sort(a, a1))
  => ((cardinal(tuple2(a, b), right_injections(b, a, a1, s2)) = cardinal(b,
     s2))
     AND ((FORALL (aqt : uni):
          ((sort(a, aqt))
          => (FORALL (b1 : uni):
             ((mem(tuple2(a, b), Tuple2(a, b, aqt, b1), right_injections(b,
             a, a1, s2))) <=> ((aqt = a1) AND (mem(b, b1, s2)))))))
         AND (right_injections(b, a, a1, s2) = map(tuple2(a, b), b, infix_at(
         infix_mngt(b, tuple2(a, b)), a, Tuple2_closure(a, b), a1), s2)))))));

left_injections: (ty, ty, uni, uni) -> uni;

% left_injections_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(tuple2(a, b)), left_injections(b, a,
  x, x1)))));

% left_injections'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, b1 : uni):
  (IF (infix_eqeq(set(a), s2, empty(a))) THEN (left_injections(b, a, s2,
  b1) = empty(tuple2(a, b))) ELSE (left_injections(b, a, s2, b1) = add(
  tuple2(a, b), Tuple2(a, b, choose(a, s2), b1), left_injections(b, a, 
  remove(a, choose(a, s2), s2), b1))) ENDIF)));

fc1: (ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni): (sort(infix_mngt(a, tuple2(a, b)), fc1(b, a, x)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (b1 : uni, a1 : uni): (infix_at(tuple2(a, b), a, fc1(b, a, b1),
  a1) = Tuple2(a, b, a1, b1))));

% left_injections'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, b1 : uni):
  ((sort(b, b1))
  => ((FORALL (a1 : uni):
      (FORALL (bqt : uni):
      ((sort(b, bqt))
      => ((mem(tuple2(a, b), Tuple2(a, b, a1, bqt), left_injections(b, a, s2,
         b1))) <=> ((mem(a, a1, s2)) AND (bqt = b1))))))
     AND ((cardinal(tuple2(a, b), left_injections(b, a, s2, b1)) = 
         cardinal(a, s2)) AND (left_injections(b, a, s2, b1) = map(tuple2(a,
         b), a, fc1(b, a, b1), s2)))))));

% set_map_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((FORALL (b : angle):
   ((mem(angle1, t2tb33(b), t2tb71(sqt)))
   => (EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND ((f[a]) = b)))))
  => ((FORALL (a : INT):
      ((mem(int, t2tb5(a), t2tb6(s2))) => (mem(angle1, t2tb33((f[a])), 
      t2tb71(sqt)))))
     => (tb2t71(map(angle1, int, t2tb35(f), t2tb6(s2))) = sqt))));

% set_map_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((FORALL (b : INT):
   ((mem(int, t2tb5(b), t2tb6(sqt)))
   => (EXISTS (a : INT): ((mem(int, t2tb5(a), t2tb6(s2))) AND ((f[a]) = b)))))
  => ((FORALL (a : INT):
      ((mem(int, t2tb5(a), t2tb6(s2))) => (mem(int, t2tb5((f[a])), 
      t2tb6(sqt)))))
     => (tb2t6(map(int, int, t2tb7(f), t2tb6(s2))) = sqt))));

% set_map_eq
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((sort(set(b), sqt))
  => ((FORALL (b1 : uni):
      ((sort(b, b1))
      => ((mem(b, b1, sqt))
         => (EXISTS (a1 : uni):
            ((mem(a, a1, s2)) AND (infix_at(b, a, f, a1) = b1))))))
     => ((FORALL (a1 : uni):
         ((sort(a, a1))
         => ((mem(a, a1, s2)) => (mem(b, infix_at(b, a, f, a1), sqt)))))
        => (map(b, a, f, s2) = sqt))))));

% right_injections_l
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, s2 : uni):
  ((sort(a, a1))
  => ((cardinal(tuple2(a, b), right_injections(b, a, a1, s2)) = cardinal(b,
     s2))
     AND ((FORALL (aqt : uni):
          ((sort(a, aqt))
          => (FORALL (b1 : uni):
             ((mem(tuple2(a, b), Tuple2(a, b, aqt, b1), right_injections(b,
             a, a1, s2))) <=> ((aqt = a1) AND (mem(b, b1, s2)))))))
         AND (right_injections(b, a, a1, s2) = map(tuple2(a, b), b, infix_at(
         infix_mngt(b, tuple2(a, b)), a, Tuple2_closure(a, b), a1), s2)))))));

fc2: (ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni): (sort(infix_mngt(a, tuple2(a, b)), fc2(b, a, x)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (b1 : uni, a1 : uni): (infix_at(tuple2(a, b), a, fc2(b, a, b1),
  a1) = Tuple2(a, b, a1, b1))));

% left_injections_l
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, b1 : uni):
  ((sort(b, b1))
  => ((FORALL (a1 : uni):
      (FORALL (bqt : uni):
      ((sort(b, bqt))
      => ((mem(tuple2(a, b), Tuple2(a, b, a1, bqt), left_injections(b, a, s2,
         b1))) <=> ((mem(a, a1, s2)) AND (bqt = b1))))))
     AND ((cardinal(tuple2(a, b), left_injections(b, a, s2, b1)) = 
         cardinal(a, s2)) AND (left_injections(b, a, s2, b1) = map(tuple2(a,
         b), a, fc2(b, a, b1), s2)))))));

% disjoint_injections
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, b1 : uni, c : uni):
  ((sort(b, b1))
  => ((sort(b, c))
     => ((NOT (b1 = c))
        => ((is_empty(tuple2(b, a), inter(tuple2(b, a), right_injections(a,
           b, b1, s2), right_injections(a, b, c, s2)))) AND (is_empty(
           tuple2(a, b), inter(tuple2(a, b), left_injections(b, a, s2, b1), 
           left_injections(b, a, s2, c))))))))));

% induction
  ASSERT
  (FORALL (a : ty):
  (FORALL (p : uni, t1 : uni):
  ((FORALL (s2 : uni):
   ((sort(set(a), s2))
   => ((is_empty(a, s2)) => (tb2t2(infix_at(bool, set(a), p, s2)) = 0bin1))))
  => ((FORALL (s2 : uni):
      ((sort(set(a), s2))
      => ((tb2t2(infix_at(bool, set(a), p, s2)) = 0bin1)
         => (FORALL (t2 : uni):
            ((sort(a, t2))
            => ((NOT (mem(a, t2, s2))) => (tb2t2(infix_at(bool, set(a), p, 
               add(a, t2, s2))) = 0bin1)))))))
     => (tb2t2(infix_at(bool, set(a), p, t1)) = 0bin1)))));

% cardinal_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni): (cardinal(a, union(a, s2, sqt)) = ((
  cardinal(a, s2) + cardinal(a, sqt)) - cardinal(a, inter(a, s2, sqt))))));

% cardinal_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((FORALL (e : uni):
   ((sort(a, e)) => ((mem(a, e, s2)) => (mem(a, e, sqt)))))
  => ((FORALL (e : uni):
      ((sort(a, e)) => ((mem(a, e, sqt)) => (mem(a, e, s2)))))
     => (cardinal(a, s2) = cardinal(a, sqt))))));

% cardinal_sum_empty_inter
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni):
  ((inter(a, s2, sqt) = empty(a)) => (cardinal(a, union(a, s2, sqt)) = (
  cardinal(a, s2) + cardinal(a, sqt))))));

cartesian_product: (ty, ty, uni, uni) -> uni;

% cartesian_product_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(tuple2(a, b)), cartesian_product(b,
  a, x, x1)))));

% cartesian_product'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni):
  ((cardinal(tuple2(a, b), cartesian_product(b, a, s11, s2)) = (cardinal(a,
  s11) * cardinal(b, s2)))
  AND ((FORALL (a1 : uni):
       (FORALL (b1 : uni):
       ((mem(tuple2(a, b), Tuple2(a, b, a1, b1), cartesian_product(b, a, s11,
       s2))) <=> ((mem(a, a1, s11)) AND (mem(b, b1, s2))))))
      AND (FORALL (o : uni):
          ((mem(tuple2(a, b), o, cartesian_product(b, a, s11, s2)))
          <=> ((mem(a, fir(b, a, o), s11)) AND (mem(b, sec(b, a, o), s2)))))))));

commute: (ty, ty, uni) -> uni;

% commute_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni): (sort(tuple2(b, a), commute(b, a, x)))));

% commute'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, b1 : uni): (commute(b, a, Tuple2(a, b, a1, b1)) = 
  Tuple2(b, a, b1, a1))));

% commute_inj
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, aqt : uni, b1 : uni, bqt : uni):
  ((sort(a, a1))
  => ((sort(a, aqt))
     => ((sort(b, b1))
        => ((sort(b, bqt))
           => (((a1 = aqt) => (NOT (b1 = bqt)))
              => (NOT (commute(b, a, Tuple2(a, b, a1, b1)) = commute(b, a, 
                 Tuple2(a, b, aqt, bqt)))))))))));

% mem_cartesian_product
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni, a1 : uni, b1 : uni):
  ((mem(a, a1, s11))
  => ((mem(b, b1, s2)) => (mem(tuple2(a, b), Tuple2(a, b, a1, b1), 
     cartesian_product(b, a, s11, s2)))))));

commute_closure: (ty, ty) -> uni;

% commute_closure_sort
  ASSERT
  (FORALL (a : ty, b : ty): (sort(infix_mngt(tuple2(a, b), tuple2(b, a)), 
  commute_closure(b, a))));

% commute_closure_def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (y : uni): (infix_at(tuple2(b, a), tuple2(a, b), commute_closure(b,
  a), y) = commute(b, a, y))));

% commute_inj_gen
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni): (p_injective(tuple2(b, a), tuple2(a, b), 
  commute_closure(b, a), cartesian_product(b, a, s11, s2)))));

commute_product: (ty, ty, uni, uni) -> uni;

% commute_product_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(tuple2(b, a)), commute_product(b, a,
  x, x1)))));

% commute_product'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni): (commute_product(b, a, s11, s2) = map(
  tuple2(b, a), tuple2(a, b), commute_closure(b, a), cartesian_product(b, a,
  s11, s2)))));

% commute_product'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni): (commute_product(b, a, s11, s2) = 
  cartesian_product(a, b, s2, s11))));

commute_product_el: (ty, ty, uni, uni) -> uni;

% commute_product_el_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(tuple2(b, a)), commute_product_el(b,
  a, x, x1)))));

% commute_product_el'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni): (commute_product_el(b, a, s11, s2) = map(
  tuple2(b, a), tuple2(a, b), commute_closure(b, a), cartesian_product(b, a,
  s11, s2)))));

% commute_product_el'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni):
  (FORALL (a1 : uni, b1 : uni):
  (((mem(tuple2(a, b), Tuple2(a, b, a1, b1), cartesian_product(b, a, s11,
   s2))) <=> ((mem(a, a1, s11)) AND (mem(b, b1, s2))))
  AND (((mem(a, a1, s11)) AND (mem(b, b1, s2))) <=> (mem(tuple2(b, a), 
      Tuple2(b, a, b1, a1), commute_product_el(b, a, s11, s2))))))));

% cartesian_product_union
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni, s3 : uni): (cartesian_product(b, a, s11, 
  union(b, s2, s3)) = union(tuple2(a, b), cartesian_product(b, a, s11, s2), 
  cartesian_product(b, a, s11, s3)))));

% cartesian_union_product
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni, s3 : uni): (cartesian_product(b, a, union(a,
  s11, s2), s3) = union(tuple2(a, b), cartesian_product(b, a, s11, s3), 
  cartesian_product(b, a, s2, s3)))));

% cartesian_product_cardone_r
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni):
  ((cardinal(a, s11) = 1)
  => ((infix_eqeq(set(tuple2(a, b)), cartesian_product(b, a, s11, s2), 
     right_injections(b, a, choose(a, s11), s2))) AND (infix_eqeq(set(
     tuple2(a, b)), cartesian_product(b, a, s11, s2), map(tuple2(a, b), b, 
     infix_at(infix_mngt(b, tuple2(a, b)), a, Tuple2_closure(a, b), choose(a,
     s11)), s2)))))));

fc3: (ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni): (sort(infix_mngt(a, tuple2(a, b)), fc3(b, a, x)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (e : uni, e1 : uni): (infix_at(tuple2(a, b), a, fc3(b, a, e),
  e1) = Tuple2(a, b, e1, e))));

% cartesian_product_cardone_l
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni):
  ((cardinal(b, s2) = 1)
  => ((infix_eqeq(set(tuple2(a, b)), cartesian_product(b, a, s11, s2), 
     left_injections(b, a, s11, choose(b, s2)))) AND (infix_eqeq(set(
     tuple2(a, b)), cartesian_product(b, a, s11, s2), map(tuple2(a, b), a, 
     fc3(b, a, choose(b, s2)), s11)))))));

% disjoint_cartesian_product_l
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni, s3 : uni):
  ((inter(a, s11, s2) = empty(a)) => (inter(tuple2(a, b), 
  cartesian_product(b, a, s11, s3), cartesian_product(b, a, s2, s3)) = empty(
  tuple2(a, b))))));

% disjoint_cartesian_product_r
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni, s3 : uni):
  ((inter(b, s2, s3) = empty(b)) => (inter(tuple2(a, b), cartesian_product(b,
  a, s11, s2), cartesian_product(b, a, s11, s3)) = empty(tuple2(a, b))))));

iter_union: (ty, uni) -> uni;

% iter_union_sort
  ASSERT
  (FORALL (a : ty): (FORALL (x : uni): (sort(set(a), iter_union(a, x)))));

% iter_union'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  (IF (infix_eqeq(set(set(a)), s2, empty(set(a)))) THEN (iter_union(a, s2) = 
  empty(a)) ELSE (iter_union(a, s2) = union(a, choose(set(a), s2), 
  iter_union(a, remove(set(a), choose(set(a), s2), s2)))) ENDIF)));

% get_mem_union
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, e : uni):
  ((mem(a, e, union(a, s2, sqt)))
  => ((NOT (mem(a, e, sqt))) => (mem(a, e, s2))))));

% get_mem_union'
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, e : uni):
  ((mem(a, e, union(a, s2, sqt)))
  => ((NOT (mem(a, e, s2))) => (mem(a, e, sqt))))));

% set_mem_union
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, e : uni):
  ((mem(a, e, s2)) => (mem(a, e, union(a, s2, sqt))))));

% set_mem_union'
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, e : uni):
  ((mem(a, e, sqt)) => (mem(a, e, union(a, s2, sqt))))));

op_neutral_left: (ty, uni, uni) -> BOOLEAN;

% op_neutral_left'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), neutral1 : INT):
  ((op_neutral_left(int, t2tb8(op1), t2tb5(neutral1)))
  <=> (FORALL (e : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5(neutral1)))[e]) = e))));

% op_neutral_left'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, neutral1 : uni):
  ((op_neutral_left(im1, op1, neutral1))
  <=> (FORALL (e : uni):
      ((sort(im1, e)) => (infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
      im1, op1, neutral1), e) = e))))));

op_neutral_right: (ty, uni, uni) -> BOOLEAN;

% op_neutral_right'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), neutral1 : INT):
  ((op_neutral_right(int, t2tb8(op1), t2tb5(neutral1)))
  <=> (FORALL (e : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5(e)))[neutral1]) = e))));

% op_neutral_right'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, neutral1 : uni):
  ((op_neutral_right(im1, op1, neutral1))
  <=> (FORALL (e : uni):
      ((sort(im1, e)) => (infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
      im1, op1, e), neutral1) = e))))));

op_assoc: (ty, uni) -> BOOLEAN;

% op_assoc'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT))):
  ((op_assoc(int, t2tb8(op1)))
  <=> (FORALL (a : INT, b : INT, c : INT): ((tb2t7(infix_at(infix_mngt(int,
      int), int, t2tb8(op1), t2tb5((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5(a)))[b]))))[c]) = (tb2t7(infix_at(infix_mngt(int,
      int), int, t2tb8(op1), t2tb5(a)))[(tb2t7(infix_at(infix_mngt(int, int),
      int, t2tb8(op1), t2tb5(b)))[c])])))));

% op_assoc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni):
  (((op_assoc(im1, op1))
   => (FORALL (a : uni, b : uni, c : uni): (infix_at(im1, im1, infix_at(
      infix_mngt(im1, im1), im1, op1, infix_at(im1, im1, infix_at(
      infix_mngt(im1, im1), im1, op1, a), b)), c) = infix_at(im1, im1, 
      infix_at(infix_mngt(im1, im1), im1, op1, a), infix_at(im1, im1, 
      infix_at(infix_mngt(im1, im1), im1, op1, b), c)))))
  AND ((FORALL (a : uni, b : uni, c : uni):
       ((sort(im1, a))
       => ((sort(im1, b))
          => ((sort(im1, c)) => (infix_at(im1, im1, infix_at(infix_mngt(im1,
             im1), im1, op1, infix_at(im1, im1, infix_at(infix_mngt(im1,
             im1), im1, op1, a), b)), c) = infix_at(im1, im1, infix_at(
             infix_mngt(im1, im1), im1, op1, a), infix_at(im1, im1, infix_at(
             infix_mngt(im1, im1), im1, op1, b), c)))))))
      => (op_assoc(im1, op1))))));

op_neutral_left_comm: (ty, uni, uni) -> BOOLEAN;

% op_neutral_left_comm'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), neutral1 : INT):
  ((op_neutral_left_comm(int, t2tb8(op1), t2tb5(neutral1)))
  <=> (FORALL (a : INT):
      ((FORALL (b : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
       t2tb8(op1), t2tb5(a)))[b]) = b))
      => (a = neutral1)))));

% op_neutral_left_comm'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, neutral1 : uni):
  ((sort(im1, neutral1))
  => ((op_neutral_left_comm(im1, op1, neutral1))
     <=> (FORALL (a : uni):
         ((sort(im1, a))
         => ((FORALL (b : uni):
             ((sort(im1, b)) => (infix_at(im1, im1, infix_at(infix_mngt(im1,
             im1), im1, op1, a), b) = b)))
            => (a = neutral1))))))));

commut: (ty, uni) -> BOOLEAN;

% commut'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT))):
  ((commut(int, t2tb8(op1)))
  <=> (FORALL (a : INT, b : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5(a)))[b]) = (tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5(b)))[a])))));

% commut'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni):
  (((commut(im1, op1))
   => (FORALL (a : uni, b : uni): (infix_at(im1, im1, infix_at(
      infix_mngt(im1, im1), im1, op1, a), b) = infix_at(im1, im1, infix_at(
      infix_mngt(im1, im1), im1, op1, b), a))))
  AND ((FORALL (a : uni, b : uni):
       ((sort(im1, a))
       => ((sort(im1, b)) => (infix_at(im1, im1, infix_at(infix_mngt(im1,
          im1), im1, op1, a), b) = infix_at(im1, im1, infix_at(
          infix_mngt(im1, im1), im1, op1, b), a)))))
      => (commut(im1, op1))))));

assoc: (ty, uni) -> BOOLEAN;

% assoc'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT))):
  ((assoc(int, t2tb8(op1)))
  <=> (FORALL (a : INT, b : INT, c : INT): ((tb2t7(infix_at(infix_mngt(int,
      int), int, t2tb8(op1), t2tb5((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5(a)))[b]))))[c]) = (tb2t7(infix_at(infix_mngt(int,
      int), int, t2tb8(op1), t2tb5(a)))[(tb2t7(infix_at(infix_mngt(int, int),
      int, t2tb8(op1), t2tb5(b)))[c])])))));

% assoc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni):
  (((assoc(im1, op1))
   => (FORALL (a : uni, b : uni, c : uni): (infix_at(im1, im1, infix_at(
      infix_mngt(im1, im1), im1, op1, infix_at(im1, im1, infix_at(
      infix_mngt(im1, im1), im1, op1, a), b)), c) = infix_at(im1, im1, 
      infix_at(infix_mngt(im1, im1), im1, op1, a), infix_at(im1, im1, 
      infix_at(infix_mngt(im1, im1), im1, op1, b), c)))))
  AND ((FORALL (a : uni, b : uni, c : uni):
       ((sort(im1, a))
       => ((sort(im1, b))
          => ((sort(im1, c)) => (infix_at(im1, im1, infix_at(infix_mngt(im1,
             im1), im1, op1, infix_at(im1, im1, infix_at(infix_mngt(im1,
             im1), im1, op1, a), b)), c) = infix_at(im1, im1, infix_at(
             infix_mngt(im1, im1), im1, op1, a), infix_at(im1, im1, infix_at(
             infix_mngt(im1, im1), im1, op1, b), c)))))))
      => (assoc(im1, op1))))));

opposite_n: (ty, uni, uni, uni) -> BOOLEAN;

% opposite_n'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  po1 : (ARRAY INT OF (ARRAY INT OF INT)), neutral1 : INT):
  ((opposite_n(int, t2tb8(op1), t2tb8(po1), t2tb5(neutral1)))
  <=> (FORALL (a : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(po1), t2tb5(a)))[(tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5(neutral1)))[a])]) = neutral1))));

% opposite_n'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, po1 : uni, neutral1 : uni):
  ((sort(im1, neutral1))
  => (((opposite_n(im1, op1, po1, neutral1))
      => (FORALL (a : uni): (infix_at(im1, im1, infix_at(infix_mngt(im1,
         im1), im1, po1, a), infix_at(im1, im1, infix_at(infix_mngt(im1,
         im1), im1, op1, neutral1), a)) = neutral1)))
     AND ((FORALL (a : uni):
          ((sort(im1, a)) => (infix_at(im1, im1, infix_at(infix_mngt(im1,
          im1), im1, po1, a), infix_at(im1, im1, infix_at(infix_mngt(im1,
          im1), im1, op1, neutral1), a)) = neutral1)))
         => (opposite_n(im1, op1, po1, neutral1)))))));

inverse: (ty, uni, uni, uni) -> BOOLEAN;

% inverse'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  po1 : (ARRAY INT OF (ARRAY INT OF INT)), inver1 : (ARRAY INT OF INT)):
  ((inverse(int, t2tb8(op1), t2tb8(po1), t2tb7(inver1)))
  <=> (FORALL (a : INT, b : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(po1), t2tb5(a)))[b]) = (tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5(a)))[(inver1[b])])))));

% inverse'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, po1 : uni, inver1 : uni):
  (((inverse(im1, op1, po1, inver1))
   => (FORALL (a : uni, b : uni): (infix_at(im1, im1, infix_at(
      infix_mngt(im1, im1), im1, po1, a), b) = infix_at(im1, im1, infix_at(
      infix_mngt(im1, im1), im1, op1, a), infix_at(im1, im1, inver1, b)))))
  AND ((FORALL (a : uni, b : uni):
       ((sort(im1, a))
       => ((sort(im1, b)) => (infix_at(im1, im1, infix_at(infix_mngt(im1,
          im1), im1, po1, a), b) = infix_at(im1, im1, infix_at(
          infix_mngt(im1, im1), im1, op1, a), infix_at(im1, im1, inver1,
          b))))))
      => (inverse(im1, op1, po1, inver1))))));

opposite: (ty, uni, uni) -> BOOLEAN;

% opposite'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  po1 : (ARRAY INT OF (ARRAY INT OF INT))):
  ((opposite(int, t2tb8(op1), t2tb8(po1)))
  <=> (FORALL (a : INT, b : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(po1), t2tb5(a)))[b]))))[b]) = a))));

% opposite'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, po1 : uni):
  (((opposite(im1, op1, po1))
   => (FORALL (a : uni, b : uni):
      ((sort(im1, a)) => (infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
      im1, op1, infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, po1,
      a), b)), b) = a))))
  AND ((FORALL (a : uni, b : uni):
       ((sort(im1, a))
       => ((sort(im1, b)) => (infix_at(im1, im1, infix_at(infix_mngt(im1,
          im1), im1, op1, infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
          im1, po1, a), b)), b) = a))))
      => (opposite(im1, op1, po1))))));

opposite_com: (ty, uni, uni) -> BOOLEAN;

% opposite_com'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  po1 : (ARRAY INT OF (ARRAY INT OF INT))):
  ((opposite_com(int, t2tb8(op1), t2tb8(po1)))
  <=> (FORALL (a : INT, b : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(po1), t2tb5((tb2t7(infix_at(infix_mngt(int, int), int, 
      t2tb8(op1), t2tb5(a)))[b]))))[b]) = a))));

% opposite_com'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, po1 : uni):
  (((opposite_com(im1, op1, po1))
   => (FORALL (a : uni, b : uni):
      ((sort(im1, a)) => (infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
      im1, po1, infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1,
      a), b)), b) = a))))
  AND ((FORALL (a : uni, b : uni):
       ((sort(im1, a))
       => ((sort(im1, b)) => (infix_at(im1, im1, infix_at(infix_mngt(im1,
          im1), im1, po1, infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
          im1, op1, a), b)), b) = a))))
      => (opposite_com(im1, op1, po1))))));

% refl
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), a : INT, b : INT):
  ((commut(int, t2tb8(op1))) => ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(op1), t2tb5(a)))[b]) = (tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(op1), t2tb5(b)))[a]))));

% refl
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, a : uni, b : uni):
  ((commut(im1, op1)) => (infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
  im1, op1, a), b) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1,
  op1, b), a)))));

neutral: (ty, uni, uni) -> BOOLEAN;

% neutral'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, neut : uni):
  ((neutral(im1, op1, neut))
  <=> ((op_neutral_left(im1, op1, neut))
      AND ((op_neutral_right(im1, op1, neut)) AND (op_assoc(im1, op1)))))));

% set_neutral
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, neut : uni):
  ((op_neutral_left(im1, op1, neut))
  => ((op_neutral_right(im1, op1, neut))
     => ((op_assoc(im1, op1)) => (neutral(im1, op1, neut)))))));

has_neutral: (ty, uni) -> BOOLEAN;

% has_neutral'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni):
  (((has_neutral(im1, op1))
   => (EXISTS (e : uni): ((sort(im1, e)) AND (neutral(im1, op1, e)))))
  AND ((EXISTS (e : uni): (neutral(im1, op1, e))) => (has_neutral(im1, op1))))));

iterates: (ty, uni, uni) -> BOOLEAN;

% iterates'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, neutral1 : uni):
  ((iterates(im1, op1, neutral1))
  <=> ((op_neutral_left(im1, op1, neutral1))
      AND ((op_neutral_right(im1, op1, neutral1)) AND (op_assoc(im1, op1)))))));

iterable: (ty, uni) -> BOOLEAN;

% iterable'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni):
  (((iterable(im1, op1))
   => (EXISTS (e : uni): ((sort(im1, e)) AND (iterates(im1, op1, e)))))
  AND ((EXISTS (e : uni): (iterates(im1, op1, e))) => (iterable(im1, op1))))));

% iterates_
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, neutral1 : uni):
  ((op_neutral_left(im1, op1, neutral1))
  => ((op_neutral_right(im1, op1, neutral1))
     => ((op_assoc(im1, op1))
        => ((iterates(im1, op1, neutral1)) AND (iterable(im1, op1))))))));

neutral_elt: (ty, uni) -> uni;

% neutral_elt_sort
  ASSERT
  (FORALL (im1 : ty): (FORALL (x : uni): (sort(im1, neutral_elt(im1, x)))));

% neutral_elt'spec
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni):
  (FORALL (e : uni):
  ((sort(im1, e))
  => ((neutral(im1, op1, e)) <=> (neutral_elt(im1, op1) = e))))));

inverse_tuple: (ty, uni, uni, uni) -> BOOLEAN;

% inverse_tuple'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, po1 : uni, neutral1 : uni):
  ((inverse_tuple(im1, op1, po1, neutral1))
  <=> ((opposite_n(im1, op1, po1, neutral1))
      AND ((opposite(im1, op1, po1)) AND (opposite_com(im1, op1, po1)))))));

iterate: (ty, ty, uni, uni, uni) -> uni;

% iterate_sort
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(im1, iterate(im1, a, x, x1,
  x2)))));

% iterate'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : uni, f : uni):
  ((commut(int, t2tb8(op1)))
  => (((is_empty(a, s2)) => (iterable(int, t2tb8(op1))))
     => (IF (cardinal(a, s2) = 0) THEN (tb2t5(iterate(int, a, t2tb8(op1), s2,
        f)) = tb2t5(neutral_elt(int, t2tb8(op1)))) ELSE (tb2t5(iterate(int,
        a, t2tb8(op1), s2, f)) = (tb2t7(infix_at(infix_mngt(int, int), int, 
        t2tb8(op1), iterate(int, a, t2tb8(op1), remove(a, choose(a, s2), s2),
        f)))[tb2t5(infix_at(int, a, f, choose(a, s2)))])) ENDIF)))));

t2tb32: ((ARRAY angle OF angle)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY angle OF angle)): (sort(infix_mngt(angle1, angle1), 
  t2tb32(x))));

tb2t32: (uni) -> (ARRAY angle OF angle);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY angle OF angle)):PATTERN (t2tb32(i)):  (tb2t32(
  t2tb32(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb32(tb2t32(j))): 
  ((sort(infix_mngt(angle1, angle1), j)) => (t2tb32(tb2t32(j)) = j)));

t2tb34: ((ARRAY angle OF (ARRAY angle OF angle))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY angle OF (ARRAY angle OF angle))): (sort(
  infix_mngt(angle1, infix_mngt(angle1, angle1)), t2tb34(x))));

tb2t34: (uni) -> (ARRAY angle OF (ARRAY angle OF angle));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY angle OF (ARRAY angle OF angle))):PATTERN (t2tb34(i)): 
  (tb2t34(t2tb34(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb34(tb2t34(j))): 
  ((sort(infix_mngt(angle1, infix_mngt(angle1, angle1)), j)) => (t2tb34(
  tb2t34(j)) = j)));

% iterate'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  f : (ARRAY INT OF angle)):
  ((commut(angle1, t2tb34(op1)))
  => (((is_empty(int, t2tb6(s2))) => (iterable(angle1, t2tb34(op1))))
     => (IF (cardinal(int, t2tb6(s2)) = 0) THEN (tb2t33(iterate(angle1, int, 
        t2tb34(op1), t2tb6(s2), t2tb35(f))) = tb2t33(neutral_elt(angle1, 
        t2tb34(op1)))) ELSE (tb2t33(iterate(angle1, int, t2tb34(op1), 
        t2tb6(s2), t2tb35(f))) = tb2t33(infix_at(angle1, angle1, infix_at(
        infix_mngt(angle1, angle1), angle1, t2tb34(op1), iterate(angle1, int, 
        t2tb34(op1), remove(int, choose(int, t2tb6(s2)), t2tb6(s2)), 
        t2tb35(f))), t2tb33((f[tb2t5(choose(int, t2tb6(s2)))]))))) ENDIF))));

% iterate'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  f : (ARRAY INT OF INT)):
  ((commut(int, t2tb8(op1)))
  => (((is_empty(int, t2tb6(s2))) => (iterable(int, t2tb8(op1))))
     => (IF (cardinal(int, t2tb6(s2)) = 0) THEN (tb2t5(iterate(int, int, 
        t2tb8(op1), t2tb6(s2), t2tb7(f))) = tb2t5(neutral_elt(int, 
        t2tb8(op1)))) ELSE (tb2t5(iterate(int, int, t2tb8(op1), t2tb6(s2), 
        t2tb7(f))) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
        iterate(int, int, t2tb8(op1), remove(int, choose(int, t2tb6(s2)), 
        t2tb6(s2)), t2tb7(f))))[(f[tb2t5(choose(int, t2tb6(s2)))])])) ENDIF))));

% iterate'def
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni):
  ((commut(im1, op1))
  => (((is_empty(a, s2)) => (iterable(im1, op1)))
     => (IF (cardinal(a, s2) = 0) THEN (iterate(im1, a, op1, s2, f) = 
        neutral_elt(im1, op1)) ELSE (iterate(im1, a, op1, s2, f) = 
        infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
        iterate(im1, a, op1, remove(a, choose(a, s2), s2), f)), infix_at(im1,
        a, f, choose(a, s2)))) ENDIF)))));

% Iterate_def_empty
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni):
  (FORALL (s2 : uni):
  (FORALL (f : uni):
  ((commut(im1, op1))
  => ((iterable(im1, op1))
     => ((is_empty(a, s2)) => (iterate(im1, a, op1, empty(a), f) = 
        neutral_elt(im1, op1)))))))));

% Iterate_one
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle))):
  (FORALL (s2 : set_int):
  (FORALL (f : (ARRAY INT OF angle)):
  (FORALL (x : INT):
  ((is_empty(int, t2tb6(s2)))
  => ((commut(angle1, t2tb34(op1))) => (tb2t33(iterate(angle1, int, 
     t2tb34(op1), add(int, t2tb5(x), t2tb6(s2)), t2tb35(f))) = (f[x]))))))));

% Iterate_one
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT))):
  (FORALL (s2 : set_int):
  (FORALL (f : (ARRAY INT OF INT)):
  (FORALL (x : INT):
  ((is_empty(int, t2tb6(s2)))
  => ((commut(int, t2tb8(op1))) => (tb2t5(iterate(int, int, t2tb8(op1), 
     add(int, t2tb5(x), t2tb6(s2)), t2tb7(f))) = (f[x]))))))));

% Iterate_one
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni):
  (FORALL (s2 : uni):
  (FORALL (f : uni):
  (FORALL (x : uni):
  ((is_empty(a, s2))
  => ((commut(im1, op1)) => (iterate(im1, a, op1, add(a, x, s2), f) = 
     infix_at(im1, a, f, x)))))))));

% Iterate_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT))):
  (FORALL (s2 : uni):
  (FORALL (f : uni):
  (FORALL (x : uni):
  ((0 < cardinal(a, s2))
  => ((commut(int, t2tb8(op1)))
     => ((NOT (mem(a, x, s2))) => (tb2t5(iterate(int, a, t2tb8(op1), add(a,
        x, s2), f)) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
        infix_at(int, a, f, x)))[tb2t5(iterate(int, a, t2tb8(op1), s2,
        f))]))))))))));

% Iterate_add
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle))):
  (FORALL (s2 : set_int):
  (FORALL (f : (ARRAY INT OF angle)):
  (FORALL (x : INT):
  ((0 < cardinal(int, t2tb6(s2)))
  => ((commut(angle1, t2tb34(op1)))
     => ((NOT (mem(int, t2tb5(x), t2tb6(s2)))) => (tb2t33(iterate(angle1,
        int, t2tb34(op1), add(int, t2tb5(x), t2tb6(s2)), t2tb35(f))) = 
        tb2t33(infix_at(angle1, angle1, infix_at(infix_mngt(angle1, angle1),
        angle1, t2tb34(op1), t2tb33((f[x]))), iterate(angle1, int, 
        t2tb34(op1), t2tb6(s2), t2tb35(f))))))))))));

% Iterate_add
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT))):
  (FORALL (s2 : set_int):
  (FORALL (f : (ARRAY INT OF INT)):
  (FORALL (x : INT):
  ((0 < cardinal(int, t2tb6(s2)))
  => ((commut(int, t2tb8(op1)))
     => ((NOT (mem(int, t2tb5(x), t2tb6(s2)))) => (tb2t5(iterate(int, int, 
        t2tb8(op1), add(int, t2tb5(x), t2tb6(s2)), t2tb7(f))) = (tb2t7(
        infix_at(infix_mngt(int, int), int, t2tb8(op1), t2tb5((f[x]))))[
        tb2t5(iterate(int, int, t2tb8(op1), t2tb6(s2), t2tb7(f)))])))))))));

% Iterate_add
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni):
  (FORALL (s2 : uni):
  (FORALL (f : uni):
  (FORALL (x : uni):
  ((0 < cardinal(a, s2))
  => ((commut(im1, op1))
     => ((NOT (mem(a, x, s2))) => (iterate(im1, a, op1, add(a, x, s2), f) = 
        infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
        infix_at(im1, a, f, x)), iterate(im1, a, op1, s2, f)))))))))));

% minus_zero
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  po1 : (ARRAY INT OF (ARRAY INT OF INT)), a : INT):
  ((iterable(int, t2tb8(op1)))
  => ((inverse_tuple(int, t2tb8(op1), t2tb8(po1), neutral_elt(int, 
     t2tb8(op1)))) => ((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(po1), 
     t2tb5(a)))[tb2t5(neutral_elt(int, t2tb8(op1)))]) = a))));

% minus_zero
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, po1 : uni, a : uni):
  ((sort(im1, a))
  => ((iterable(im1, op1))
     => ((inverse_tuple(im1, op1, po1, neutral_elt(im1, op1))) => (
        infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, po1, a), 
        neutral_elt(im1, op1)) = a))))));

% unic
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  po1 : (ARRAY INT OF (ARRAY INT OF INT)), a : INT, b : INT, c : INT):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1)))
     => (((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
        t2tb5(a)))[b]) = (tb2t7(infix_at(infix_mngt(int, int), int, 
        t2tb8(op1), t2tb5(a)))[c]))
        => ((inverse_tuple(int, t2tb8(op1), t2tb8(po1), neutral_elt(int, 
           t2tb8(op1)))) => (b = c))))));

% unic
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, po1 : uni, a : uni, b : uni, c : uni):
  ((sort(im1, b))
  => ((sort(im1, c))
     => ((iterable(im1, op1))
        => ((commut(im1, op1))
           => ((infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1,
              a), b) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1,
              op1, a), c))
              => ((inverse_tuple(im1, op1, po1, neutral_elt(im1, op1)))
                 => (b = c)))))))));

% substract_comm
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  po1 : (ARRAY INT OF (ARRAY INT OF INT)), a : INT, b : INT, c : INT):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1)))
     => ((inverse_tuple(int, t2tb8(op1), t2tb8(po1), neutral_elt(int, 
        t2tb8(op1))))
        => (((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(po1), t2tb5((
           tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
           t2tb5(a)))[b]))))[a]) = b)
           AND (((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(po1), 
               t2tb5((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
               t2tb5(b)))[a]))))[a]) = b)
               AND (((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(po1), 
                   t2tb5(a)))[(tb2t7(infix_at(infix_mngt(int, int), int, 
                   t2tb8(po1), t2tb5(b)))[c])]) = (tb2t7(infix_at(
                   infix_mngt(int, int), int, t2tb8(op1), t2tb5((tb2t7(
                   infix_at(infix_mngt(int, int), int, t2tb8(po1), 
                   t2tb5(a)))[b]))))[c])) AND ((tb2t7(infix_at(
                   infix_mngt(int, int), int, t2tb8(po1), t2tb5((tb2t7(
                   infix_at(infix_mngt(int, int), int, t2tb8(op1), 
                   t2tb5(a)))[b]))))[c]) = (tb2t7(infix_at(infix_mngt(int,
                   int), int, t2tb8(op1), t2tb5(a)))[(tb2t7(infix_at(
                   infix_mngt(int, int), int, t2tb8(po1), t2tb5(b)))[c])])))))))));

% substract_comm
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, po1 : uni, a : uni, b : uni, c : uni):
  ((sort(im1, b))
  => ((iterable(im1, op1))
     => ((commut(im1, op1))
        => ((inverse_tuple(im1, op1, po1, neutral_elt(im1, op1)))
           => ((infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, po1, 
              infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, a),
              b)), a) = b)
              AND ((infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1,
                  po1, infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1,
                  op1, b), a)), a) = b)
                  AND ((infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
                      im1, po1, a), infix_at(im1, im1, infix_at(
                      infix_mngt(im1, im1), im1, po1, b), c)) = infix_at(im1,
                      im1, infix_at(infix_mngt(im1, im1), im1, op1, 
                      infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1,
                      po1, a), b)), c)) AND (infix_at(im1, im1, infix_at(
                      infix_mngt(im1, im1), im1, po1, infix_at(im1, im1, 
                      infix_at(infix_mngt(im1, im1), im1, op1, a), b)), c) = 
                      infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1,
                      op1, a), infix_at(im1, im1, infix_at(infix_mngt(im1,
                      im1), im1, po1, b), c))))))))))));

int_iterate: (ty, uni, uni, INT, INT) -> uni;

% int_iterate_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT): (sort(im1, 
  int_iterate(im1, x, x1, x2, x3)))));

% int_iterate'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), i : INT, j : INT):
  (((j <= i) => (iterable(angle1, t2tb34(op1))))
  => (IF (j <= i) THEN (tb2t33(int_iterate(angle1, t2tb34(op1), t2tb35(f), i,
     j)) = tb2t33(neutral_elt(angle1, t2tb34(op1))))
     ELSE (IF (j = (i + 1)) THEN (tb2t33(int_iterate(angle1, t2tb34(op1), 
          t2tb35(f), i, j)) = (f[i])) ELSE (tb2t33(int_iterate(angle1, 
          t2tb34(op1), t2tb35(f), i, j)) = tb2t33(infix_at(angle1, angle1, 
          infix_at(infix_mngt(angle1, angle1), angle1, t2tb34(op1), 
          t2tb33((f[i]))), int_iterate(angle1, t2tb34(op1), t2tb35(f),
          (i + 1), j)))) ENDIF) ENDIF)));

% int_iterate'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  i : INT, j : INT):
  (((j <= i) => (iterable(int, t2tb8(op1))))
  => (IF (j <= i) THEN (tb2t5(int_iterate(int, t2tb8(op1), t2tb7(f), i,
     j)) = tb2t5(neutral_elt(int, t2tb8(op1))))
     ELSE (IF (j = (i + 1)) THEN (tb2t5(int_iterate(int, t2tb8(op1), 
          t2tb7(f), i, j)) = (f[i])) ELSE (tb2t5(int_iterate(int, t2tb8(op1), 
          t2tb7(f), i, j)) = (tb2t7(infix_at(infix_mngt(int, int), int, 
          t2tb8(op1), t2tb5((f[i]))))[tb2t5(int_iterate(int, t2tb8(op1), 
          t2tb7(f), (i + 1), j))])) ENDIF) ENDIF)));

% int_iterate'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT):
  (((j <= i) => (iterable(im1, op1)))
  => (IF (j <= i) THEN (int_iterate(im1, op1, f, i, j) = neutral_elt(im1,
     op1))
     ELSE (IF (j = (i + 1)) THEN (int_iterate(im1, op1, f, i, j) = 
          infix_at(im1, int, f, t2tb5(i))) ELSE (int_iterate(im1, op1, f, i,
          j) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
          infix_at(im1, int, f, t2tb5(i))), int_iterate(im1, op1, f, (i + 1),
          j))) ENDIF) ENDIF))));

% int_iterate'spec
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), i : INT, j : INT):
  (((j <= i) => (iterable(angle1, t2tb34(op1))))
  => (((j <= i) => (tb2t33(int_iterate(angle1, t2tb34(op1), t2tb35(f), i,
      j)) = tb2t33(neutral_elt(angle1, t2tb34(op1)))))
     AND ((j = (i + 1)) => (tb2t33(int_iterate(angle1, t2tb34(op1), 
         t2tb35(f), i, j)) = tb2t33(infix_at(angle1, angle1, infix_at(
         infix_mngt(angle1, angle1), angle1, t2tb34(op1), t2tb33((f[i]))), 
         neutral_elt(angle1, t2tb34(op1)))))))));

% int_iterate'spec
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  i : INT, j : INT):
  (((j <= i) => (iterable(int, t2tb8(op1))))
  => (((j <= i) => (tb2t5(int_iterate(int, t2tb8(op1), t2tb7(f), i, j)) = 
      tb2t5(neutral_elt(int, t2tb8(op1)))))
     AND ((j = (i + 1)) => (tb2t5(int_iterate(int, t2tb8(op1), t2tb7(f), i,
         j)) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
         t2tb5((f[i]))))[tb2t5(neutral_elt(int, t2tb8(op1)))]))))));

% int_iterate'spec
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT):
  (((j <= i) => (iterable(im1, op1)))
  => (((j <= i) => (int_iterate(im1, op1, f, i, j) = neutral_elt(im1, op1)))
     AND ((j = (i + 1)) => (int_iterate(im1, op1, f, i, j) = infix_at(im1,
         im1, infix_at(infix_mngt(im1, im1), im1, op1, infix_at(im1, int, f, 
         t2tb5(i))), neutral_elt(im1, op1))))))));

int_int_iterate: (ty, uni, uni, INT, INT, INT, INT) -> uni;

% int_int_iterate_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT, x4 : INT, x5 : INT):
  (sort(im1, int_int_iterate(im1, x, x1, x2, x3, x4, x5)))));

% int_int_iterate'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  f : (ARRAY INT OF (ARRAY INT OF INT)), i : INT, j : INT, k : INT, l : INT):
  ((iterable(int, t2tb8(op1)))
  => (IF (j <= i) THEN (tb2t5(int_int_iterate(int, t2tb8(op1), t2tb8(f), i,
     j, k, l)) = tb2t5(neutral_elt(int, t2tb8(op1)))) ELSE (tb2t5(
     int_int_iterate(int, t2tb8(op1), t2tb8(f), i, j, k, l)) = (tb2t7(
     infix_at(infix_mngt(int, int), int, t2tb8(op1), int_iterate(int, 
     t2tb8(op1), infix_at(infix_mngt(int, int), int, t2tb8(f), t2tb5(i)), k,
     l)))[tb2t5(int_int_iterate(int, t2tb8(op1), t2tb8(f), (i + 1), j, k,
     l))])) ENDIF)));

% int_int_iterate'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, k : INT, l : INT):
  ((iterable(im1, op1))
  => (IF (j <= i) THEN (int_int_iterate(im1, op1, f, i, j, k, l) = 
     neutral_elt(im1, op1)) ELSE (int_int_iterate(im1, op1, f, i, j, k, l) = 
     infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
     int_iterate(im1, op1, infix_at(infix_mngt(int, im1), int, f, t2tb5(i)),
     k, l)), int_int_iterate(im1, op1, f, (i + 1), j, k, l))) ENDIF))));

% to_set'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (e : uni):
  ((sort(a, e))
  => ((FORALL (b : uni): ((b = e) => (mem(a, b, add(a, e, empty(a))))))
     AND ((cardinal(a, add(a, e, empty(a))) = 1)
         AND (FORALL (b : uni):
             ((sort(a, b)) => ((mem(a, b, add(a, e, empty(a)))) => (b = e)))))))));

to_fset: (INT, INT) -> set_int;

% to_fset'spec
  ASSERT
  (FORALL (i : INT, j : INT):
  (((i < j) => (cardinal(int, t2tb6(to_fset(i, j))) = (j - i)))
  AND (((j <= i) => (is_empty(int, t2tb6(to_fset(i, j)))))
      AND (FORALL (k : INT):
          ((mem(int, t2tb5(k), t2tb6(to_fset(i, j))))
          <=> ((i <= k) AND (k < j)))))));

% to_fset_bounds
  ASSERT
  (FORALL (i : INT, k : INT, j : INT):
  ((i < j)
  => ((mem(int, t2tb5(k), t2tb6(to_fset(i, j)))) => ((i <= k) AND (k < j)))));

% to_fset_unit_ext
  ASSERT
  (FORALL (i : INT, j : INT):
  ((i < j) => (to_fset(i, j) = tb2t6(add(int, t2tb5(i), t2tb6(
  to_fset((i + 1), j)))))));

% to_fset_ext
  ASSERT
  (FORALL (i : INT, iqt : INT, j : INT):
  (((i <= iqt) AND (iqt <= j)) => (to_fset(i, j) = tb2t6(union(int, t2tb6(
  to_fset(i, iqt)), t2tb6(to_fset(iqt, j)))))));

% card_fset
  ASSERT
  (FORALL (n : INT): ((0 <= n) => (cardinal(int, t2tb6(to_fset(0, n))) = n)));

% card_fset_gen
  ASSERT
  (FORALL (i : INT, j : INT):
  ((i <= j) => (cardinal(int, t2tb6(to_fset(i, j))) = (j - i))));

% set_mem_to_fset
  ASSERT
  (FORALL (i : INT, k : INT, j : INT):
  (((i <= k) AND (k < j)) => (mem(int, t2tb5(k), t2tb6(to_fset(i, j))))));

element: (ty, uni) -> uni;

% element_sort
  ASSERT (FORALL (a : ty): (FORALL (x : uni): (sort(a, element(a, x)))));

% element'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((cardinal(a, s2) = 1) => (element(a, s2) = choose(a, s2)))));

% cardone
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, a1 : uni):
  ((sort(a, a1))
  => ((FORALL (b : uni): ((sort(a, b)) => ((mem(a, b, s2)) <=> (b = a1))))
     => ((0 < cardinal(a, s2))
        => ((cardinal(a, s2) = 1) AND (element(a, s2) = a1)))))));

% set_cardone
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((0 < cardinal(a, s2))
  => ((EXISTS (a1 : uni):
      ((sort(a, a1))
      AND (FORALL (b : uni):
          ((sort(a, b)) => ((mem(a, b, s2)) <=> (b = a1))))))
     => (cardinal(a, s2) = 1)))));

% get_cardone
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((cardinal(a, s2) = 1)
  => (EXISTS (a1 : uni):
     ((sort(a, a1))
     AND (FORALL (b : uni): ((sort(a, b)) => ((mem(a, b, s2)) <=> (b = a1)))))))));

% get_cardone_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, e : uni):
  ((sort(a, e))
  => ((cardinal(a, s2) = 1) => ((mem(a, e, s2)) => (e = element(a, s2)))))));

% set_cardone_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, a1 : uni):
  ((sort(a, a1))
  => ((FORALL (b : uni): ((sort(a, b)) => ((mem(a, b, s2)) <=> (b = a1))))
     => ((cardinal(a, s2) = 1) AND (element(a, s2) = a1))))));

% set_cardone_elt_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, a1 : uni):
  ((sort(a, a1))
  => ((FORALL (b : uni): ((sort(a, b)) => ((mem(a, b, s2)) <=> (b = a1))))
     => (cardinal(a, s2) = 1)))));

% cardzero
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni):
  ((FORALL (b : uni): ((sort(a, b)) => (NOT (mem(a, b, s2))))) => (
  cardinal(a, s2) = 0))));

% get_choose_cardone
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, e : uni):
  ((sort(a, e))
  => ((cardinal(a, s2) = 1) => ((mem(a, e, s2)) => (choose(a, s2) = e))))));

% iterate_empty
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni):
  ((is_empty(a, s2))
  => ((commut(im1, op1))
     => ((iterable(im1, op1)) => (iterate(im1, a, op1, s2, t1) = 
        neutral_elt(im1, op1)))))));

% iterate_one
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  t1 : (ARRAY INT OF angle)):
  ((cardinal(int, t2tb6(s2)) = 1)
  => ((commut(angle1, t2tb34(op1))) => (tb2t33(iterate(angle1, int, 
     t2tb34(op1), t2tb6(s2), t2tb35(t1))) = (t1[tb2t5(choose(int, 
     t2tb6(s2)))])))));

% iterate_one
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  t1 : (ARRAY INT OF INT)):
  ((cardinal(int, t2tb6(s2)) = 1)
  => ((commut(int, t2tb8(op1))) => (tb2t5(iterate(int, int, t2tb8(op1), 
     t2tb6(s2), t2tb7(t1))) = (t1[tb2t5(choose(int, t2tb6(s2)))])))));

% iterate_one
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni):
  ((cardinal(a, s2) = 1)
  => ((commut(im1, op1)) => (iterate(im1, a, op1, s2, t1) = infix_at(im1, a,
     t1, choose(a, s2)))))));

% iterate_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : uni, f : uni,
  x : uni):
  ((commut(int, t2tb8(op1)))
  => ((iterable(int, t2tb8(op1)))
     => ((NOT (mem(a, x, s2))) => (tb2t5(iterate(int, a, t2tb8(op1), add(a,
        x, s2), f)) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
        infix_at(int, a, f, x)))[tb2t5(iterate(int, a, t2tb8(op1), s2,
        f))])))))));

% iterate_add
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  f : (ARRAY INT OF angle), x : INT):
  ((commut(angle1, t2tb34(op1)))
  => ((iterable(angle1, t2tb34(op1)))
     => ((NOT (mem(int, t2tb5(x), t2tb6(s2)))) => (tb2t33(iterate(angle1,
        int, t2tb34(op1), add(int, t2tb5(x), t2tb6(s2)), t2tb35(f))) = 
        tb2t33(infix_at(angle1, angle1, infix_at(infix_mngt(angle1, angle1),
        angle1, t2tb34(op1), t2tb33((f[x]))), iterate(angle1, int, 
        t2tb34(op1), t2tb6(s2), t2tb35(f)))))))));

% iterate_add
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  f : (ARRAY INT OF INT), x : INT):
  ((commut(int, t2tb8(op1)))
  => ((iterable(int, t2tb8(op1)))
     => ((NOT (mem(int, t2tb5(x), t2tb6(s2)))) => (tb2t5(iterate(int, int, 
        t2tb8(op1), add(int, t2tb5(x), t2tb6(s2)), t2tb7(f))) = (tb2t7(
        infix_at(infix_mngt(int, int), int, t2tb8(op1), t2tb5((f[x]))))[
        tb2t5(iterate(int, int, t2tb8(op1), t2tb6(s2), t2tb7(f)))]))))));

% iterate_add
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni, x : uni):
  ((commut(im1, op1))
  => ((iterable(im1, op1))
     => ((NOT (mem(a, x, s2))) => (iterate(im1, a, op1, add(a, x, s2), f) = 
        infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
        infix_at(im1, a, f, x)), iterate(im1, a, op1, s2, f))))))));

% iterate_add_
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : uni, f : uni,
  x : uni):
  ((commut(int, t2tb8(op1)))
  => ((NOT (mem(a, x, s2)))
     => ((NOT (is_empty(a, s2))) => (tb2t5(iterate(int, a, t2tb8(op1), add(a,
        x, s2), f)) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
        infix_at(int, a, f, x)))[tb2t5(iterate(int, a, t2tb8(op1), s2,
        f))])))))));

% iterate_add_
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  f : (ARRAY INT OF angle), x : INT):
  ((commut(angle1, t2tb34(op1)))
  => ((NOT (mem(int, t2tb5(x), t2tb6(s2))))
     => ((NOT (is_empty(int, t2tb6(s2)))) => (tb2t33(iterate(angle1, int, 
        t2tb34(op1), add(int, t2tb5(x), t2tb6(s2)), t2tb35(f))) = tb2t33(
        infix_at(angle1, angle1, infix_at(infix_mngt(angle1, angle1), angle1, 
        t2tb34(op1), t2tb33((f[x]))), iterate(angle1, int, t2tb34(op1), 
        t2tb6(s2), t2tb35(f)))))))));

% iterate_add_
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  f : (ARRAY INT OF INT), x : INT):
  ((commut(int, t2tb8(op1)))
  => ((NOT (mem(int, t2tb5(x), t2tb6(s2))))
     => ((NOT (is_empty(int, t2tb6(s2)))) => (tb2t5(iterate(int, int, 
        t2tb8(op1), add(int, t2tb5(x), t2tb6(s2)), t2tb7(f))) = (tb2t7(
        infix_at(infix_mngt(int, int), int, t2tb8(op1), t2tb5((f[x]))))[
        tb2t5(iterate(int, int, t2tb8(op1), t2tb6(s2), t2tb7(f)))]))))));

% iterate_add_
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni, x : uni):
  ((commut(im1, op1))
  => ((NOT (mem(a, x, s2)))
     => ((NOT (is_empty(a, s2))) => (iterate(im1, a, op1, add(a, x, s2),
        f) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
        infix_at(im1, a, f, x)), iterate(im1, a, op1, s2, f))))))));

po_closure: (ty) -> uni;

% po_closure_sort
  ASSERT
  (FORALL (im1 : ty): (sort(infix_mngt(im1, infix_mngt(im1, im1)), 
  po_closure(im1))));

% po_closure_def
  ASSERT
  (FORALL (y : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  po_closure(int), t2tb5(y)))[y1]) = tb2t5(po(int, t2tb5(y), t2tb5(y1)))));

% po_closure_def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (y : uni, y1 : uni): (infix_at(im1, im1, infix_at(infix_mngt(im1,
  im1), im1, po_closure(im1), y), y1) = po(im1, y, y1))));

% iterate_remove
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  f : (ARRAY INT OF angle), x : INT):
  ((commut(angle1, t2tb34(op1)))
  => ((iterable(angle1, t2tb34(op1)))
     => ((inverse_tuple(angle1, t2tb34(op1), po_closure(angle1), 
        neutral_elt(angle1, t2tb34(op1))))
        => ((mem(int, t2tb5(x), t2tb6(s2))) => (tb2t33(iterate(angle1, int, 
           t2tb34(op1), remove(int, t2tb5(x), t2tb6(s2)), t2tb35(f))) = 
           tb2t33(po(angle1, iterate(angle1, int, t2tb34(op1), t2tb6(s2), 
           t2tb35(f)), t2tb33((f[x]))))))))));

% iterate_remove
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  f : (ARRAY INT OF INT), x : INT):
  ((commut(int, t2tb8(op1)))
  => ((iterable(int, t2tb8(op1)))
     => ((inverse_tuple(int, t2tb8(op1), po_closure(int), neutral_elt(int, 
        t2tb8(op1))))
        => ((mem(int, t2tb5(x), t2tb6(s2))) => (tb2t5(iterate(int, int, 
           t2tb8(op1), remove(int, t2tb5(x), t2tb6(s2)), t2tb7(f))) = tb2t5(
           po(int, iterate(int, int, t2tb8(op1), t2tb6(s2), t2tb7(f)), 
           t2tb5((f[x]))))))))));

% iterate_remove
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni, x : uni):
  ((commut(im1, op1))
  => ((iterable(im1, op1))
     => ((inverse_tuple(im1, op1, po_closure(im1), neutral_elt(im1, op1)))
        => ((mem(a, x, s2)) => (iterate(im1, a, op1, remove(a, x, s2), f) = 
           po(im1, iterate(im1, a, op1, s2, f), infix_at(im1, a, f, x)))))))));

% iterate_def_choose
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : uni, f : uni):
  (((cardinal(a, s2) = 1) => (iterable(int, t2tb8(op1))))
  => ((commut(int, t2tb8(op1)))
     => ((NOT (is_empty(a, s2))) => (tb2t5(iterate(int, a, t2tb8(op1), s2,
        f)) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
        infix_at(int, a, f, choose(a, s2))))[tb2t5(iterate(int, a, 
        t2tb8(op1), remove(a, choose(a, s2), s2), f))])))))));

% iterate_def_choose
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  f : (ARRAY INT OF angle)):
  (((cardinal(int, t2tb6(s2)) = 1) => (iterable(angle1, t2tb34(op1))))
  => ((commut(angle1, t2tb34(op1)))
     => ((NOT (is_empty(int, t2tb6(s2)))) => (tb2t33(iterate(angle1, int, 
        t2tb34(op1), t2tb6(s2), t2tb35(f))) = tb2t33(infix_at(angle1, angle1, 
        infix_at(infix_mngt(angle1, angle1), angle1, t2tb34(op1), t2tb33((f[
        tb2t5(choose(int, t2tb6(s2)))]))), iterate(angle1, int, t2tb34(op1), 
        remove(int, choose(int, t2tb6(s2)), t2tb6(s2)), t2tb35(f)))))))));

% iterate_def_choose
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  f : (ARRAY INT OF INT)):
  (((cardinal(int, t2tb6(s2)) = 1) => (iterable(int, t2tb8(op1))))
  => ((commut(int, t2tb8(op1)))
     => ((NOT (is_empty(int, t2tb6(s2)))) => (tb2t5(iterate(int, int, 
        t2tb8(op1), t2tb6(s2), t2tb7(f))) = (tb2t7(infix_at(infix_mngt(int,
        int), int, t2tb8(op1), t2tb5((f[tb2t5(choose(int, t2tb6(s2)))]))))[
        tb2t5(iterate(int, int, t2tb8(op1), remove(int, choose(int, 
        t2tb6(s2)), t2tb6(s2)), t2tb7(f)))]))))));

% iterate_def_choose
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni):
  (((cardinal(a, s2) = 1) => (iterable(im1, op1)))
  => ((commut(im1, op1))
     => ((NOT (is_empty(a, s2))) => (iterate(im1, a, op1, s2, f) = 
        infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
        infix_at(im1, a, f, choose(a, s2))), iterate(im1, a, op1, remove(a, 
        choose(a, s2), s2), f))))))));

% choose_any
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : uni, f : uni,
  t1 : uni):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1)))
     => ((mem(a, t1, s2)) => (tb2t5(iterate(int, a, t2tb8(op1), s2, f)) = (
        tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), infix_at(int,
        a, f, t1)))[tb2t5(iterate(int, a, t2tb8(op1), remove(a, t1, s2),
        f))])))))));

% choose_any
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  f : (ARRAY INT OF angle), t1 : INT):
  ((iterable(angle1, t2tb34(op1)))
  => ((commut(angle1, t2tb34(op1)))
     => ((mem(int, t2tb5(t1), t2tb6(s2))) => (tb2t33(iterate(angle1, int, 
        t2tb34(op1), t2tb6(s2), t2tb35(f))) = tb2t33(infix_at(angle1, angle1, 
        infix_at(infix_mngt(angle1, angle1), angle1, t2tb34(op1), 
        t2tb33((f[t1]))), iterate(angle1, int, t2tb34(op1), remove(int, 
        t2tb5(t1), t2tb6(s2)), t2tb35(f)))))))));

% choose_any
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  f : (ARRAY INT OF INT), t1 : INT):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1)))
     => ((mem(int, t2tb5(t1), t2tb6(s2))) => (tb2t5(iterate(int, int, 
        t2tb8(op1), t2tb6(s2), t2tb7(f))) = (tb2t7(infix_at(infix_mngt(int,
        int), int, t2tb8(op1), t2tb5((f[t1]))))[tb2t5(iterate(int, int, 
        t2tb8(op1), remove(int, t2tb5(t1), t2tb6(s2)), t2tb7(f)))]))))));

% choose_any
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni, t1 : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => ((mem(a, t1, s2)) => (iterate(im1, a, op1, s2, f) = infix_at(im1,
        im1, infix_at(infix_mngt(im1, im1), im1, op1, infix_at(im1, a, f,
        t1)), iterate(im1, a, op1, remove(a, t1, s2), f))))))));

fc4: (ty, ty, uni, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(a, im1), fc4(im1,
  a, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : uni, g : uni,
  k : uni): (tb2t5(infix_at(int, a, fc4(int, a, t2tb8(op1), f, g), k)) = (
  tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), infix_at(int, a, f,
  k)))[tb2t5(infix_at(int, a, g, k))]))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), k : INT): ((tb2t35(
  fc4(angle1, int, t2tb34(op1), t2tb35(f), t2tb35(g)))[k]) = tb2t33(
  infix_at(angle1, angle1, infix_at(infix_mngt(angle1, angle1), angle1, 
  t2tb34(op1), t2tb33((f[k]))), t2tb33((g[k]))))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  g : (ARRAY INT OF INT), k : INT): ((tb2t7(fc4(int, int, t2tb8(op1), 
  t2tb7(f), t2tb7(g)))[k]) = (tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(op1), t2tb5((f[k]))))[(g[k])])));

% fc'def
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, f : uni, g : uni, k : uni): (infix_at(im1, a, fc4(im1,
  a, op1, f, g), k) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1,
  op1, infix_at(im1, a, f, k)), infix_at(im1, a, g, k)))));

% iterate_comp_iterate
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s11 : uni, f : uni,
  g : uni):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1)))
     => ((assoc(int, t2tb8(op1))) => (tb2t5(iterate(int, a, t2tb8(op1), s11, 
        fc4(int, a, t2tb8(op1), f, g))) = (tb2t7(infix_at(infix_mngt(int,
        int), int, t2tb8(op1), iterate(int, a, t2tb8(op1), s11, f)))[tb2t5(
        iterate(int, a, t2tb8(op1), s11, g))])))))));

% iterate_comp_iterate
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s11 : uni, f : uni, g : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => ((assoc(im1, op1)) => (iterate(im1, a, op1, s11, fc4(im1, a, op1, f,
        g)) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
        iterate(im1, a, op1, s11, f)), iterate(im1, a, op1, s11, g))))))));

fc5: (ty, ty, uni, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(a, im1), fc5(im1,
  a, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : uni, g : uni,
  k : uni): (tb2t5(infix_at(int, a, fc5(int, a, t2tb8(op1), f, g), k)) = (
  tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), infix_at(int, a, f,
  k)))[tb2t5(infix_at(int, a, g, k))]))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), k : INT): ((tb2t35(
  fc5(angle1, int, t2tb34(op1), t2tb35(f), t2tb35(g)))[k]) = tb2t33(
  infix_at(angle1, angle1, infix_at(infix_mngt(angle1, angle1), angle1, 
  t2tb34(op1), t2tb33((f[k]))), t2tb33((g[k]))))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  g : (ARRAY INT OF INT), k : INT): ((tb2t7(fc5(int, int, t2tb8(op1), 
  t2tb7(f), t2tb7(g)))[k]) = (tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(op1), t2tb5((f[k]))))[(g[k])])));

% fc'def
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, f : uni, g : uni, k : uni): (infix_at(im1, a, fc5(im1,
  a, op1, f, g), k) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1,
  op1, infix_at(im1, a, f, k)), infix_at(im1, a, g, k)))));

% iterate_comp_iterate_com
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s11 : uni, f : uni,
  g : uni):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1))) => ((tb2t7(infix_at(infix_mngt(int, int),
     int, t2tb8(op1), iterate(int, a, t2tb8(op1), s11, f)))[tb2t5(
     iterate(int, a, t2tb8(op1), s11, g))]) = tb2t5(iterate(int, a, 
     t2tb8(op1), s11, fc5(int, a, t2tb8(op1), f, g))))))));

% iterate_comp_iterate_com
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s11 : uni, f : uni, g : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1)) => (infix_at(im1, im1, infix_at(infix_mngt(im1,
     im1), im1, op1, iterate(im1, a, op1, s11, f)), iterate(im1, a, op1, s11,
     g)) = iterate(im1, a, op1, s11, fc5(im1, a, op1, f, g)))))));

% iterate_transitivity
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  po1 : (ARRAY INT OF (ARRAY INT OF INT)), s11 : uni, s2 : uni, f : uni):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1)))
     => ((inverse_tuple(int, t2tb8(op1), t2tb8(po1), neutral_elt(int, 
        t2tb8(op1)))) => (tb2t5(iterate(int, a, t2tb8(op1), union(a, s11,
        s2), f)) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(po1), 
        t2tb5((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
        iterate(int, a, t2tb8(op1), s11, f)))[tb2t5(iterate(int, a, 
        t2tb8(op1), s2, f))]))))[tb2t5(iterate(int, a, t2tb8(op1), inter(a,
        s11, s2), f))])))))));

% iterate_transitivity
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, po1 : uni, s11 : uni, s2 : uni, f : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => ((inverse_tuple(im1, op1, po1, neutral_elt(im1, op1))) => (
        iterate(im1, a, op1, union(a, s11, s2), f) = infix_at(im1, im1, 
        infix_at(infix_mngt(im1, im1), im1, po1, infix_at(im1, im1, infix_at(
        infix_mngt(im1, im1), im1, op1, iterate(im1, a, op1, s11, f)), 
        iterate(im1, a, op1, s2, f))), iterate(im1, a, op1, inter(a, s11,
        s2), f))))))));

% iterate_disjoint_transitivity
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s11 : uni, s2 : uni,
  t1 : uni):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1)))
     => ((inter(a, s11, s2) = empty(a)) => (tb2t5(iterate(int, a, t2tb8(op1), 
        union(a, s11, s2), t1)) = (tb2t7(infix_at(infix_mngt(int, int), int, 
        t2tb8(op1), iterate(int, a, t2tb8(op1), s11, t1)))[tb2t5(iterate(int,
        a, t2tb8(op1), s2, t1))])))))));

% iterate_disjoint_transitivity
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s11 : uni, s2 : uni, t1 : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => ((inter(a, s11, s2) = empty(a)) => (iterate(im1, a, op1, union(a,
        s11, s2), t1) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
        im1, op1, iterate(im1, a, op1, s11, t1)), iterate(im1, a, op1, s2,
        t1))))))));

% iterate_eq
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  f : (ARRAY INT OF angle), g : (ARRAY INT OF angle)):
  ((FORALL (x : INT): ((mem(int, t2tb5(x), t2tb6(s2))) => ((f[x]) = (g[x]))))
  => ((commut(angle1, t2tb34(op1)))
     => (((is_empty(int, t2tb6(s2))) => (iterable(angle1, t2tb34(op1)))) => (
        tb2t33(iterate(angle1, int, t2tb34(op1), t2tb6(s2), t2tb35(f))) = 
        tb2t33(iterate(angle1, int, t2tb34(op1), t2tb6(s2), t2tb35(g))))))));

% iterate_eq
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  f : (ARRAY INT OF INT), g : (ARRAY INT OF INT)):
  ((FORALL (x : INT): ((mem(int, t2tb5(x), t2tb6(s2))) => ((f[x]) = (g[x]))))
  => ((commut(int, t2tb8(op1)))
     => (((is_empty(int, t2tb6(s2))) => (iterable(int, t2tb8(op1)))) => (
        tb2t5(iterate(int, int, t2tb8(op1), t2tb6(s2), t2tb7(f))) = tb2t5(
        iterate(int, int, t2tb8(op1), t2tb6(s2), t2tb7(g))))))));

% iterate_eq
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni, g : uni):
  ((FORALL (x : uni):
   ((sort(a, x))
   => ((mem(a, x, s2)) => (infix_at(im1, a, f, x) = infix_at(im1, a, g, x)))))
  => ((commut(im1, op1))
     => (((is_empty(a, s2)) => (iterable(im1, op1))) => (iterate(im1, a, op1,
        s2, f) = iterate(im1, a, op1, s2, g)))))));

fc6: (ty, ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, im1), fc6(im1, b, a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, t1 : uni, b : INT): ((tb2t35(fc6(angle1, int, a, f,
  t1))[b]) = tb2t33(infix_at(angle1, a, t1, infix_at(a, int, f, t2tb5(b)))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, t1 : uni, b : INT): ((tb2t7(fc6(int, int, a, f,
  t1))[b]) = tb2t5(infix_at(int, a, t1, infix_at(a, int, f, t2tb5(b)))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), t1 : (ARRAY angle OF angle), b : INT):
  ((tb2t35(fc6(angle1, int, angle1, t2tb35(f), t2tb32(t1)))[b]) = tb2t33(
  infix_at(angle1, angle1, t2tb32(t1), t2tb33((f[b]))))));

t2tb72: ((ARRAY angle OF INT)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY angle OF INT)): (sort(infix_mngt(angle1, int), 
  t2tb72(x))));

tb2t72: (uni) -> (ARRAY angle OF INT);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY angle OF INT)):PATTERN (t2tb72(i)):  (tb2t72(
  t2tb72(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb72(tb2t72(j))):  (t2tb72(tb2t72(j)) = j));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), t1 : (ARRAY angle OF INT), b : INT): ((
  tb2t7(fc6(int, int, angle1, t2tb35(f), t2tb72(t1)))[b]) = tb2t5(
  infix_at(int, angle1, t2tb72(t1), t2tb33((f[b]))))));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (f : (ARRAY INT OF angle), t1 : uni, b : INT): (infix_at(im1, int, 
  fc6(im1, int, angle1, t2tb35(f), t1), t2tb5(b)) = infix_at(im1, angle1, t1, 
  t2tb33((f[b]))))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, t1 : (ARRAY INT OF angle), b1 : uni): (tb2t33(
  infix_at(angle1, b, fc6(angle1, b, int, f, t2tb35(t1)), b1)) = (t1[tb2t5(
  infix_at(int, b, f, b1))]))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, t1 : (ARRAY INT OF INT), b1 : uni): (tb2t5(infix_at(int,
  b, fc6(int, b, int, f, t2tb7(t1)), b1)) = (t1[tb2t5(infix_at(int, b, f,
  b1))]))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF angle), b : INT): ((
  tb2t35(fc6(angle1, int, int, t2tb7(f), t2tb35(t1)))[b]) = (t1[(f[b])])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  tb2t7(fc6(int, int, int, t2tb7(f), t2tb7(t1)))[b]) = (t1[(f[b])])));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (f : (ARRAY INT OF INT), t1 : uni, b : INT): (infix_at(im1, int, 
  fc6(im1, int, int, t2tb7(f), t1), t2tb5(b)) = infix_at(im1, int, t1, 
  t2tb5((f[b]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (f : uni, t1 : uni, b1 : uni): (infix_at(im1, b, fc6(im1, b, a, f,
  t1), b1) = infix_at(im1, a, t1, infix_at(a, b, f, b1)))));

% iterate_map
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni, t1 : uni):
  (((is_empty(b, s2)) => (iterable(im1, op1)))
  => ((commut(im1, op1))
     => ((p_injective(a, b, f, s2)) => (iterate(im1, a, op1, map(a, b, f,
        s2), t1) = iterate(im1, b, op1, s2, fc6(im1, b, a, f, t1))))))));

% iterate_cardone
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  t1 : (ARRAY INT OF angle)):
  ((iterable(angle1, t2tb34(op1)))
  => ((commut(angle1, t2tb34(op1)))
     => ((cardinal(int, t2tb6(s2)) = 1) => (tb2t33(iterate(angle1, int, 
        t2tb34(op1), t2tb6(s2), t2tb35(t1))) = (t1[tb2t5(element(int, 
        t2tb6(s2)))]))))));

% iterate_cardone
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  t1 : (ARRAY INT OF INT)):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1)))
     => ((cardinal(int, t2tb6(s2)) = 1) => (tb2t5(iterate(int, int, 
        t2tb8(op1), t2tb6(s2), t2tb7(t1))) = (t1[tb2t5(element(int, 
        t2tb6(s2)))]))))));

% iterate_cardone
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => ((cardinal(a, s2) = 1) => (iterate(im1, a, op1, s2, t1) = 
        infix_at(im1, a, t1, element(a, s2))))))));

% iterate_cardzero
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni):
  ((commut(im1, op1))
  => ((iterable(im1, op1))
     => ((cardinal(a, s2) = 0) => (iterate(im1, a, op1, s2, t1) = 
        neutral_elt(im1, op1)))))));

fc734: (ty, ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni): (sort(infix_mngt(tuple2(a, b), im1), fc734(im1, b, a,
  x)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t33(infix_at(angle1, tuple2(a, int), 
  fc734(angle1, int, a, f), o)) = (tb2t35(infix_at(infix_mngt(int, angle1),
  a, f, fir(int, a, o)))[tb2t5(sec(int, a, o))]))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t5(infix_at(int, tuple2(a, int), fc734(int,
  int, a, f), o)) = (tb2t7(infix_at(infix_mngt(int, int), a, f, fir(int, a,
  o)))[tb2t5(sec(int, a, o))]))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (f : uni, o : uni): (infix_at(im1, tuple2(a, b), fc734(im1, b, a,
  f), o) = infix_at(im1, b, infix_at(infix_mngt(b, im1), a, f, fir(b, a, o)), 
  sec(b, a, o)))));

% injec_iterate
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (op1 : uni, a1 : uni, s2 : uni, f : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1)) => (iterate(im1, b, op1, s2, infix_at(infix_mngt(b,
     im1), a, f, a1)) = iterate(im1, tuple2(a, b), op1, cartesian_product(b,
     a, add(a, a1, empty(a)), s2), fc734(im1, b, a, f)))))));

fc8: (ty, ty, ty, uni, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(a, im1), fc8(im1,
  b, a, x, x1, x2)))));

fc9: (ty, ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni): (sort(infix_mngt(tuple2(a, b), im1), fc9(im1, b, a,
  x)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : uni, f : uni,
  a : INT): ((tb2t35(fc8(angle1, b, int, t2tb34(op1), s2, f))[a]) = tb2t33(
  iterate(angle1, b, t2tb34(op1), s2, infix_at(infix_mngt(b, angle1), int, f, 
  t2tb5(a)))))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : uni, f : uni,
  a : INT): ((tb2t7(fc8(int, b, int, t2tb8(op1), s2, f))[a]) = tb2t5(
  iterate(int, b, t2tb8(op1), s2, infix_at(infix_mngt(b, int), int, f, 
  t2tb5(a)))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni, a1 : uni): (infix_at(im1, a, 
  fc8(im1, b, a, op1, s2, f), a1) = iterate(im1, b, op1, s2, infix_at(
  infix_mngt(b, im1), a, f, a1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t33(infix_at(angle1, tuple2(a, int), 
  fc9(angle1, int, a, f), o)) = (tb2t35(infix_at(infix_mngt(int, angle1), a,
  f, fir(int, a, o)))[tb2t5(sec(int, a, o))]))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t5(infix_at(int, tuple2(a, int), fc9(int,
  int, a, f), o)) = (tb2t7(infix_at(infix_mngt(int, int), a, f, fir(int, a,
  o)))[tb2t5(sec(int, a, o))]))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (f : uni, o : uni): (infix_at(im1, tuple2(a, b), fc9(im1, b, a, f),
  o) = infix_at(im1, b, infix_at(infix_mngt(b, im1), a, f, fir(b, a, o)), 
  sec(b, a, o)))));

% iterate_cartesian_product
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (op1 : uni, s11 : uni, s2 : uni, f : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1)) => (iterate(im1, a, op1, s11, fc8(im1, b, a, op1,
     s2, f)) = iterate(im1, tuple2(a, b), op1, cartesian_product(b, a, s11,
     s2), fc9(im1, b, a, f)))))));

% iterate_eq_func
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f1 : uni, f2 : uni):
  ((commut(im1, op1))
  => ((iterable(im1, op1))
     => ((p_injective(im1, a, f1, s2))
        => ((p_injective(im1, a, f2, s2))
           => ((map(im1, a, f1, s2) = map(im1, a, f2, s2)) => (iterate(im1,
              a, op1, s2, f1) = iterate(im1, a, op1, s2, f2)))))))));

p_injective_in: (ty, ty, uni, uni, uni) -> BOOLEAN;

% p_injective_in'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((p_injective_in(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  <=> (FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(angle1, t2tb33((f[e])), t2tb71(sqt)))
         AND (FORALL (e1 : INT, eqt : INT):
             ((mem(int, t2tb5(e1), t2tb6(s2)))
             => ((mem(int, t2tb5(eqt), t2tb6(s2)))
                => ((NOT (e1 = eqt)) => (NOT ((f[e1]) = (f[eqt]))))))))))));

% p_injective_in'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((p_injective_in(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  <=> (FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(int, t2tb5((f[e])), t2tb6(sqt)))
         AND (FORALL (e1 : INT, eqt : INT):
             ((mem(int, t2tb5(e1), t2tb6(s2)))
             => ((mem(int, t2tb5(eqt), t2tb6(s2)))
                => ((NOT (e1 = eqt)) => (NOT ((f[e1]) = (f[eqt]))))))))))));

% p_injective_in'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  (((p_injective_in(b, a, f, s2, sqt))
   => (FORALL (e : uni):
      ((mem(a, e, s2))
      => ((mem(b, infix_at(b, a, f, e), sqt))
         AND (FORALL (e1 : uni, eqt : uni):
             ((sort(a, e1))
             => ((sort(a, eqt))
                => ((mem(a, e1, s2))
                   => ((mem(a, eqt, s2))
                      => ((NOT (e1 = eqt))
                         => (NOT (infix_at(b, a, f, e1) = infix_at(b, a, f,
                            eqt)))))))))))))
  AND ((FORALL (e : uni):
       ((sort(a, e))
       => ((mem(a, e, s2))
          => ((mem(b, infix_at(b, a, f, e), sqt))
             AND (FORALL (e1 : uni, eqt : uni):
                 ((sort(a, e1))
                 => ((sort(a, eqt))
                    => ((mem(a, e1, s2))
                       => ((mem(a, eqt, s2))
                          => ((NOT (e1 = eqt))
                             => (NOT (infix_at(b, a, f, e1) = infix_at(b, a,
                                f, eqt)))))))))))))
      => (p_injective_in(b, a, f, s2, sqt))))));

equal_func: (ty, ty, uni, uni) -> BOOLEAN;

% equal_func'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle)):
  ((equal_func(angle1, int, t2tb35(f), t2tb35(g)))
  <=> (FORALL (e : INT): ((f[e]) = (g[e])))));

% equal_func'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT)):
  ((equal_func(int, int, t2tb7(f), t2tb7(g)))
  <=> (FORALL (e : INT): ((f[e]) = (g[e])))));

% equal_func'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, g : uni):
  (((equal_func(b, a, f, g))
   => (FORALL (e : uni): (infix_at(b, a, f, e) = infix_at(b, a, g, e))))
  AND ((FORALL (e : uni):
       ((sort(a, e)) => (infix_at(b, a, f, e) = infix_at(b, a, g, e))))
      => (equal_func(b, a, f, g))))));

% set_equal_func
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle)):
  ((FORALL (e : INT): ((f[e]) = (g[e]))) => (f = g)));

% set_equal_func
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT)):
  ((FORALL (e : INT): ((f[e]) = (g[e]))) => (f = g)));

% set_equal_func
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, g : uni):
  ((sort(infix_mngt(a, b), f))
  => ((sort(infix_mngt(a, b), g))
     => ((FORALL (e : uni):
         ((sort(a, e)) => (infix_at(b, a, f, e) = infix_at(b, a, g, e))))
        => (f = g))))));

% get_equal_func
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle)):
  ((equal_func(angle1, int, t2tb35(f), t2tb35(g)))
  => (FORALL (e : INT): ((f[e]) = (g[e])))));

% get_equal_func
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT)):
  ((equal_func(int, int, t2tb7(f), t2tb7(g)))
  => (FORALL (e : INT): ((f[e]) = (g[e])))));

% get_equal_func
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, g : uni):
  ((equal_func(b, a, f, g))
  => (FORALL (e : uni): (infix_at(b, a, f, e) = infix_at(b, a, g, e))))));

% set_injective
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int):
  ((FORALL (e : INT, eqt : INT):
   ((mem(int, t2tb5(e), t2tb6(s2)))
   => ((mem(int, t2tb5(eqt), t2tb6(s2)))
      => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
  => (p_injective(angle1, int, t2tb35(f), t2tb6(s2)))));

% set_injective
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  ((FORALL (e : INT, eqt : INT):
   ((mem(int, t2tb5(e), t2tb6(s2)))
   => ((mem(int, t2tb5(eqt), t2tb6(s2)))
      => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
  => (p_injective(int, int, t2tb7(f), t2tb6(s2)))));

% set_injective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  ((FORALL (e : uni, eqt : uni):
   ((sort(a, e))
   => ((sort(a, eqt))
      => ((mem(a, e, s2))
         => ((mem(a, eqt, s2))
            => ((NOT (e = eqt))
               => (NOT (infix_at(b, a, f, e) = infix_at(b, a, f, eqt)))))))))
  => (p_injective(b, a, f, s2)))));

% image'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int):
  (FORALL (a : angle):
  ((mem(angle1, t2tb33(a), map(angle1, int, t2tb35(f), t2tb6(s2))))
  <=> (EXISTS (antec_a : INT):
      ((mem(int, t2tb5(antec_a), t2tb6(s2))) AND (a = (f[antec_a])))))));

% image'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  (FORALL (a : INT):
  ((mem(int, t2tb5(a), map(int, int, t2tb7(f), t2tb6(s2))))
  <=> (EXISTS (antec_a : INT):
      ((mem(int, t2tb5(antec_a), t2tb6(s2))) AND (a = (f[antec_a])))))));

% image'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  (FORALL (a1 : uni):
  ((sort(b, a1))
  => (((mem(b, a1, map(b, a, f, s2)))
      => (EXISTS (antec_a : uni):
         ((sort(a, antec_a))
         AND ((mem(a, antec_a, s2)) AND (a1 = infix_at(b, a, f, antec_a))))))
     AND ((EXISTS (antec_a : uni):
          ((mem(a, antec_a, s2)) AND (a1 = infix_at(b, a, f, antec_a))))
         => (mem(b, a1, map(b, a, f, s2)))))))));

% card_image
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni): (cardinal(b, map(b, a, f, s2)) <= cardinal(a,
  s2))));

% card_image_injective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  ((p_injective(b, a, f, s2)) => (cardinal(b, map(b, a, f, s2)) = cardinal(a,
  s2)))));

% get_injective
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int):
  ((p_injective(angle1, int, t2tb35(f), t2tb6(s2)))
  => (FORALL (e : INT, eqt : INT):
     ((mem(int, t2tb5(e), t2tb6(s2)))
     => ((mem(int, t2tb5(eqt), t2tb6(s2)))
        => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))));

% get_injective
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  ((p_injective(int, int, t2tb7(f), t2tb6(s2)))
  => (FORALL (e : INT, eqt : INT):
     ((mem(int, t2tb5(e), t2tb6(s2)))
     => ((mem(int, t2tb5(eqt), t2tb6(s2)))
        => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))));

% get_injective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  ((p_injective(b, a, f, s2))
  => (FORALL (e : uni, eqt : uni):
     ((sort(a, e))
     => ((sort(a, eqt))
        => ((mem(a, e, s2))
           => ((mem(a, eqt, s2))
              => ((NOT (e = eqt))
                 => (NOT (infix_at(b, a, f, e) = infix_at(b, a, f, eqt))))))))))));

% get_not_injective
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int):
  ((NOT (p_injective(angle1, int, t2tb35(f), t2tb6(s2))))
  => (EXISTS (e : INT, eqt : INT):
     ((mem(int, t2tb5(e), t2tb6(s2)))
     AND ((mem(int, t2tb5(eqt), t2tb6(s2)))
         AND ((NOT (e = eqt)) AND ((f[e]) = (f[eqt]))))))));

% get_not_injective
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  ((NOT (p_injective(int, int, t2tb7(f), t2tb6(s2))))
  => (EXISTS (e : INT, eqt : INT):
     ((mem(int, t2tb5(e), t2tb6(s2)))
     AND ((mem(int, t2tb5(eqt), t2tb6(s2)))
         AND ((NOT (e = eqt)) AND ((f[e]) = (f[eqt]))))))));

% get_not_injective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  ((NOT (p_injective(b, a, f, s2)))
  => (EXISTS (e : uni, eqt : uni):
     ((sort(a, e))
     AND ((sort(a, eqt))
         AND ((mem(a, e, s2))
             AND ((mem(a, eqt, s2))
                 AND ((NOT (e = eqt)) AND (infix_at(b, a, f, e) = infix_at(b,
                     a, f, eqt)))))))))));

% set_injective_in
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(angle1, t2tb33((f[e])), 
   t2tb71(sqt)))))
  => ((FORALL (e : INT, eqt : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(int, t2tb5(eqt), t2tb6(s2)))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
     => (p_injective(angle1, int, t2tb35(f), t2tb6(s2))))));

% set_injective_in
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), t2tb6(sqt)))))
  => ((FORALL (e : INT, eqt : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(int, t2tb5(eqt), t2tb6(s2)))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
     => (p_injective(int, int, t2tb7(f), t2tb6(s2))))));

% set_injective_in
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((FORALL (e : uni):
   ((sort(a, e)) => ((mem(a, e, s2)) => (mem(b, infix_at(b, a, f, e), sqt)))))
  => ((FORALL (e : uni, eqt : uni):
      ((sort(a, e))
      => ((sort(a, eqt))
         => ((mem(a, e, s2))
            => ((mem(a, eqt, s2))
               => ((NOT (e = eqt))
                  => (NOT (infix_at(b, a, f, e) = infix_at(b, a, f, eqt)))))))))
     => (p_injective(b, a, f, s2))))));

% get_injective_in
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((p_injective_in(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(angle1, t2tb33((f[e])), 
      t2tb71(sqt)))))
     AND (FORALL (e : INT, eqt : INT):
         ((mem(int, t2tb5(e), t2tb6(s2)))
         => ((mem(int, t2tb5(eqt), t2tb6(s2)))
            => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt]))))))))));

% get_injective_in
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((p_injective_in(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), 
      t2tb6(sqt)))))
     AND (FORALL (e : INT, eqt : INT):
         ((mem(int, t2tb5(e), t2tb6(s2)))
         => ((mem(int, t2tb5(eqt), t2tb6(s2)))
            => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt]))))))))));

% get_injective_in
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_injective_in(b, a, f, s2, sqt))
  => ((FORALL (e : uni):
      ((mem(a, e, s2)) => (mem(b, infix_at(b, a, f, e), sqt))))
     AND (FORALL (e : uni, eqt : uni):
         ((sort(a, e))
         => ((sort(a, eqt))
            => ((mem(a, e, s2))
               => ((mem(a, eqt, s2))
                  => ((NOT (e = eqt))
                     => (NOT (infix_at(b, a, f, e) = infix_at(b, a, f, eqt)))))))))))));

p_surjective: (ty, ty, uni, uni, uni) -> BOOLEAN;

% p_surjective'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((p_surjective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  <=> ((FORALL (e : INT):
       ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(angle1, t2tb33((f[e])), 
       t2tb71(sqt)))))
      AND (FORALL (eqt : angle):
          ((mem(angle1, t2tb33(eqt), t2tb71(sqt)))
          => (EXISTS (e : INT):
             ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt))))))));

% p_surjective'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((p_surjective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  <=> ((FORALL (e : INT):
       ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), 
       t2tb6(sqt)))))
      AND (FORALL (eqt : INT):
          ((mem(int, t2tb5(eqt), t2tb6(sqt)))
          => (EXISTS (e : INT):
             ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt))))))));

% p_surjective'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  (((p_surjective(b, a, f, s2, sqt))
   => ((FORALL (e : uni):
       ((mem(a, e, s2)) => (mem(b, infix_at(b, a, f, e), sqt))))
      AND (FORALL (eqt : uni):
          ((sort(b, eqt))
          => ((mem(b, eqt, sqt))
             => (EXISTS (e : uni):
                ((sort(a, e))
                AND ((mem(a, e, s2)) AND (infix_at(b, a, f, e) = eqt)))))))))
  AND (((FORALL (e : uni):
        ((sort(a, e))
        => ((mem(a, e, s2)) => (mem(b, infix_at(b, a, f, e), sqt)))))
       AND (FORALL (eqt : uni):
           ((sort(b, eqt))
           => ((mem(b, eqt, sqt))
              => (EXISTS (e : uni):
                 ((mem(a, e, s2)) AND (infix_at(b, a, f, e) = eqt)))))))
      => (p_surjective(b, a, f, s2, sqt))))));

% set_surjective
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(angle1, t2tb33((f[e])), 
   t2tb71(sqt)))))
  => ((FORALL (eqt : angle):
      ((mem(angle1, t2tb33(eqt), t2tb71(sqt)))
      => (EXISTS (e : INT):
         ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt)))))
     => (p_surjective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt))))));

% set_surjective
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), t2tb6(sqt)))))
  => ((FORALL (eqt : INT):
      ((mem(int, t2tb5(eqt), t2tb6(sqt)))
      => (EXISTS (e : INT):
         ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt)))))
     => (p_surjective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt))))));

% set_surjective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((FORALL (e : uni):
   ((sort(a, e)) => ((mem(a, e, s2)) => (mem(b, infix_at(b, a, f, e), sqt)))))
  => ((FORALL (eqt : uni):
      ((sort(b, eqt))
      => ((mem(b, eqt, sqt))
         => (EXISTS (e : uni):
            ((mem(a, e, s2)) AND (infix_at(b, a, f, e) = eqt))))))
     => (p_surjective(b, a, f, s2, sqt))))));

% get_surjective
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((p_surjective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(angle1, t2tb33((f[e])), 
      t2tb71(sqt)))))
     AND (FORALL (eqt : angle):
         ((mem(angle1, t2tb33(eqt), t2tb71(sqt)))
         => (EXISTS (e : INT):
            ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt))))))));

% get_surjective
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((p_surjective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), 
      t2tb6(sqt)))))
     AND (FORALL (eqt : INT):
         ((mem(int, t2tb5(eqt), t2tb6(sqt)))
         => (EXISTS (e : INT):
            ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt))))))));

% get_surjective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_surjective(b, a, f, s2, sqt))
  => ((FORALL (e : uni):
      ((mem(a, e, s2)) => (mem(b, infix_at(b, a, f, e), sqt))))
     AND (FORALL (eqt : uni):
         ((sort(b, eqt))
         => ((mem(b, eqt, sqt))
            => (EXISTS (e : uni):
               ((sort(a, e))
               AND ((mem(a, e, s2)) AND (infix_at(b, a, f, e) = eqt)))))))))));

% image_surjective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((sort(set(b), sqt))
  => ((p_surjective(b, a, f, s2, sqt)) => (map(b, a, f, s2) = sqt)))));

p_bijective: (ty, ty, uni, uni, uni) -> BOOLEAN;

% p_bijective'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_bijective(b, a, f, s2, sqt))
  <=> ((p_injective_in(b, a, f, s2, sqt)) AND (p_surjective(b, a, f, s2,
      sqt))))));

% bijective_is_injective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_bijective(b, a, f, s2, sqt)) => (p_injective(b, a, f, s2)))));

% p_bijective_in
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle, a : INT):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => ((mem(int, t2tb5(a), t2tb6(s2))) => (mem(angle1, t2tb33((f[a])), 
     t2tb71(sqt))))));

% p_bijective_in
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int, a : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => ((mem(int, t2tb5(a), t2tb6(s2))) => (mem(int, t2tb5((f[a])), 
     t2tb6(sqt))))));

% p_bijective_in
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni, a1 : uni):
  ((p_bijective(b, a, f, s2, sqt))
  => ((mem(a, a1, s2)) => (mem(b, infix_at(b, a, f, a1), sqt))))));

% bijective_is_surjective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_bijective(b, a, f, s2, sqt)) => (p_surjective(b, a, f, s2, sqt)))));

% auto_bijective_in
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, a : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(s2)))
  => ((mem(int, t2tb5(a), t2tb6(s2))) => (mem(int, t2tb5((f[a])), 
     t2tb6(s2))))));

% auto_bijective_in
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, a1 : uni):
  ((p_bijective(a, a, f, s2, s2))
  => ((mem(a, a1, s2)) => (mem(a, infix_at(a, a, f, a1), s2))))));

% set_bijective
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(angle1, t2tb33((f[e])), 
   t2tb71(sqt)))))
  => ((FORALL (e : INT, eqt : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(int, t2tb5(eqt), t2tb6(s2)))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
     => ((FORALL (eqt : angle):
         ((mem(angle1, t2tb33(eqt), t2tb71(sqt)))
         => (EXISTS (e : INT):
            ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt)))))
        => ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
           AND (tb2t71(map(angle1, int, t2tb35(f), t2tb6(s2))) = sqt))))));

% set_bijective
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), t2tb6(sqt)))))
  => ((FORALL (e : INT, eqt : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(int, t2tb5(eqt), t2tb6(s2)))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
     => ((FORALL (eqt : INT):
         ((mem(int, t2tb5(eqt), t2tb6(sqt)))
         => (EXISTS (e : INT):
            ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt)))))
        => ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt))) AND (
           tb2t6(map(int, int, t2tb7(f), t2tb6(s2))) = sqt))))));

% set_bijective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((sort(set(b), sqt))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (mem(b, infix_at(b, a, f, e), sqt)))))
     => ((FORALL (e : uni, eqt : uni):
         ((sort(a, e))
         => ((sort(a, eqt))
            => ((mem(a, e, s2))
               => ((mem(a, eqt, s2))
                  => ((NOT (e = eqt))
                     => (NOT (infix_at(b, a, f, e) = infix_at(b, a, f, eqt)))))))))
        => ((FORALL (eqt : uni):
            ((sort(b, eqt))
            => ((mem(b, eqt, sqt))
               => (EXISTS (e : uni):
                  ((mem(a, e, s2)) AND (infix_at(b, a, f, e) = eqt))))))
           => ((p_bijective(b, a, f, s2, sqt)) AND (map(b, a, f, s2) = sqt))))))));

fc10: (ty, ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, c : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, c), fc10(c, b, a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, g : (ARRAY INT OF angle), k : uni): (tb2t33(
  infix_at(angle1, a, fc10(angle1, int, a, f, t2tb35(g)), k)) = (g[tb2t5(
  infix_at(int, a, f, k))]))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, g : (ARRAY INT OF INT), k : uni): (tb2t5(infix_at(int, a, 
  fc10(int, int, a, f, t2tb7(g)), k)) = (g[tb2t5(infix_at(int, a, f, k))]))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, g : uni, k : INT): ((tb2t35(fc10(angle1, b, int, f,
  g))[k]) = tb2t33(infix_at(angle1, b, g, infix_at(b, int, f, t2tb5(k)))))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, g : uni, k : INT): ((tb2t7(fc10(int, b, int, f,
  g))[k]) = tb2t5(infix_at(int, b, g, infix_at(b, int, f, t2tb5(k)))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY angle OF angle), k : INT): ((
  tb2t35(fc10(angle1, angle1, int, t2tb35(f), t2tb32(g)))[k]) = tb2t33(
  infix_at(angle1, angle1, t2tb32(g), t2tb33((f[k]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY angle OF INT), k : INT): ((
  tb2t7(fc10(int, angle1, int, t2tb35(f), t2tb72(g)))[k]) = tb2t5(
  infix_at(int, angle1, t2tb72(g), t2tb33((f[k]))))));

% fc'def
  ASSERT
  (FORALL (c : ty):
  (FORALL (f : (ARRAY INT OF angle), g : uni, k : INT): (infix_at(c, int, 
  fc10(c, angle1, int, t2tb35(f), g), t2tb5(k)) = infix_at(c, angle1, g, 
  t2tb33((f[k]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF angle), k : INT): ((
  tb2t35(fc10(angle1, int, int, t2tb7(f), t2tb35(g)))[k]) = (g[(f[k])])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), k : INT): ((tb2t7(
  fc10(int, int, int, t2tb7(f), t2tb7(g)))[k]) = (g[(f[k])])));

% fc'def
  ASSERT
  (FORALL (c : ty):
  (FORALL (f : (ARRAY INT OF INT), g : uni, k : INT): (infix_at(c, int, 
  fc10(c, int, int, t2tb7(f), g), t2tb5(k)) = infix_at(c, int, g, 
  t2tb5((f[k]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, c : ty):
  (FORALL (f : uni, g : uni, k : uni): (infix_at(c, a, fc10(c, b, a, f, g),
  k) = infix_at(c, b, g, infix_at(b, a, f, k)))));

% bijectivity_is_transitive
  ASSERT
  (FORALL (a : ty, b : ty, c : ty):
  (FORALL (f : uni, g : uni, s2 : uni, sqt : uni, sqtqt : uni):
  ((p_bijective(b, a, f, s2, sqt))
  => ((p_bijective(c, b, g, sqt, sqtqt)) => (p_bijective(c, a, fc10(c, b, a,
     f, g), s2, sqtqt))))));

% bijective_image
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((sort(set(b), sqt))
  => ((p_bijective(b, a, f, s2, sqt))
     => ((cardinal(a, s2) = cardinal(b, sqt)) AND (sqt = map(b, a, f, s2)))))));

% get_bijective
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(angle1, t2tb33((f[e])), 
      t2tb71(sqt)))))
     AND ((FORALL (e : INT, eqt : INT):
          ((mem(int, t2tb5(e), t2tb6(s2)))
          => ((mem(int, t2tb5(eqt), t2tb6(s2)))
             => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
         AND ((FORALL (eqt : angle):
              ((mem(angle1, t2tb33(eqt), t2tb71(sqt)))
              => (EXISTS (e : INT):
                 ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt)))))
             AND (cardinal(int, t2tb6(s2)) = cardinal(angle1, t2tb71(sqt))))))));

% get_bijective
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), 
      t2tb6(sqt)))))
     AND ((FORALL (e : INT, eqt : INT):
          ((mem(int, t2tb5(e), t2tb6(s2)))
          => ((mem(int, t2tb5(eqt), t2tb6(s2)))
             => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
         AND ((FORALL (eqt : INT):
              ((mem(int, t2tb5(eqt), t2tb6(sqt)))
              => (EXISTS (e : INT):
                 ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt)))))
             AND (cardinal(int, t2tb6(s2)) = cardinal(int, t2tb6(sqt))))))));

% get_bijective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_bijective(b, a, f, s2, sqt))
  => ((FORALL (e : uni):
      ((mem(a, e, s2)) => (mem(b, infix_at(b, a, f, e), sqt))))
     AND ((FORALL (e : uni, eqt : uni):
          ((sort(a, e))
          => ((sort(a, eqt))
             => ((mem(a, e, s2))
                => ((mem(a, eqt, s2))
                   => ((NOT (e = eqt))
                      => (NOT (infix_at(b, a, f, e) = infix_at(b, a, f,
                         eqt)))))))))
         AND ((FORALL (eqt : uni):
              ((sort(b, eqt))
              => ((mem(b, eqt, sqt))
                 => (EXISTS (e : uni):
                    ((sort(a, e))
                    AND ((mem(a, e, s2)) AND (infix_at(b, a, f, e) = eqt)))))))
             AND (cardinal(a, s2) = cardinal(b, sqt))))))));

% bijective_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), s2 : set_int,
  sqt : set_angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => ((f[e]) = (g[e]))))
     => (p_bijective(angle1, int, t2tb35(g), t2tb6(s2), t2tb71(sqt))))));

% bijective_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), s2 : set_int,
  sqt : set_int):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => ((f[e]) = (g[e]))))
     => (p_bijective(int, int, t2tb7(g), t2tb6(s2), t2tb6(sqt))))));

% bijective_eq
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, g : uni, s2 : uni, sqt : uni):
  ((p_bijective(b, a, f, s2, sqt))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (infix_at(b, a, f, e) = infix_at(b, a, g, e)))))
     => (p_bijective(b, a, g, s2, sqt))))));

% bijective_eq_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => (FORALL (g : (ARRAY INT OF angle)):
     ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => ((f[e]) = (g[e]))))
     => (p_bijective(angle1, int, t2tb35(g), t2tb6(s2), t2tb71(sqt)))))));

% bijective_eq_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => (FORALL (g : (ARRAY INT OF INT)):
     ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => ((f[e]) = (g[e]))))
     => (p_bijective(int, int, t2tb7(g), t2tb6(s2), t2tb6(sqt)))))));

% bijective_eq_gen
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_bijective(b, a, f, s2, sqt))
  => (FORALL (g : uni):
     ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (infix_at(b, a, f, e) = infix_at(b, a, g, e)))))
     => (p_bijective(b, a, g, s2, sqt)))))));

% bij_equal_card
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni):
  ((cardinal(a, s2) = cardinal(b, map(b, a, f, s2))) => (p_bijective(b, a, f,
  s2, map(b, a, f, s2))))));

% set_bijective_auto
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), t2tb6(s2)))))
  => ((FORALL (eqt : INT):
      ((mem(int, t2tb5(eqt), t2tb6(s2)))
      => (EXISTS (e : INT):
         ((mem(int, t2tb5(e), t2tb6(s2))) AND ((f[e]) = eqt)))))
     => (p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(s2))))));

% set_bijective_auto
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((FORALL (e : uni):
   ((sort(a, e)) => ((mem(a, e, s2)) => (mem(a, infix_at(a, a, f, e), s2)))))
  => ((FORALL (eqt : uni):
      ((sort(a, eqt))
      => ((mem(a, eqt, s2))
         => (EXISTS (e : uni):
            ((mem(a, e, s2)) AND (infix_at(a, a, f, e) = eqt))))))
     => (p_bijective(a, a, f, s2, s2))))));

inverse_pre: (ty, ty, uni, uni, uni, uni) -> uni;

% inverse_pre_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni, x3 : uni): (sort(a, inverse_pre(b, a,
  x, x1, x2, x3)))));

% inverse_pre'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), sa : set_int, sb : set_angle,
  b : angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)))
  => ((mem(angle1, t2tb33(b), t2tb71(sb)))
     => ((mem(int, inverse_pre(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb), 
        t2tb33(b)), t2tb6(sa))) AND ((f[tb2t5(inverse_pre(angle1, int, 
        t2tb35(f), t2tb6(sa), t2tb71(sb), t2tb33(b)))]) = b)))));

% inverse_pre'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), sa : set_int, sb : set_int, b : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)))
  => ((mem(int, t2tb5(b), t2tb6(sb)))
     => ((mem(int, inverse_pre(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb), 
        t2tb5(b)), t2tb6(sa))) AND ((f[tb2t5(inverse_pre(int, int, t2tb7(f), 
        t2tb6(sa), t2tb6(sb), t2tb5(b)))]) = b)))));

% inverse_pre'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sa : uni, sb : uni, b1 : uni):
  ((sort(b, b1))
  => ((p_bijective(b, a, f, sa, sb))
     => ((mem(b, b1, sb))
        => ((mem(a, inverse_pre(b, a, f, sa, sb, b1), sa)) AND (infix_at(b,
           a, f, inverse_pre(b, a, f, sa, sb, b1)) = b1)))))));

inverse1: (ty, ty, uni, uni, uni) -> uni;

% inverse_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(b, a), inverse1(b,
  a, x, x1, x2)))));

% inverse'def
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), sa : set_angle, sb : set_int):
  ((p_bijective(int, angle1, t2tb72(f), t2tb71(sa), t2tb6(sb)))
  => (FORALL (x : INT): ((tb2t35(inverse1(int, angle1, t2tb72(f), t2tb71(sa), 
     t2tb6(sb)))[x]) = (IF (mem(int, t2tb5(x), t2tb6(sb))) THEN tb2t33(
                       inverse_pre(int, angle1, t2tb72(f), t2tb71(sa), 
                       t2tb6(sb), t2tb5(x))) ELSE tb2t33(choose(angle1, 
                       t2tb71(sa))) ENDIF)))));

% inverse'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), sa : set_int, sb : set_int):
  ((p_bijective(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)))
  => (FORALL (x : INT): ((tb2t7(inverse1(int, int, t2tb7(f), t2tb6(sa), 
     t2tb6(sb)))[x]) = (IF (mem(int, t2tb5(x), t2tb6(sb))) THEN tb2t5(
                       inverse_pre(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb), 
                       t2tb5(x))) ELSE tb2t5(choose(int, t2tb6(sa))) ENDIF)))));

% inverse'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sa : uni, sb : uni):
  ((p_bijective(b, a, f, sa, sb))
  => (FORALL (x : uni): (infix_at(a, b, inverse1(b, a, f, sa, sb),
     x) = (IF (mem(b, x, sb)) THEN inverse_pre(b, a, f, sa, sb, x) ELSE 
          choose(a, sa) ENDIF))))));

% inverse'spec
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), sa : set_angle, sb : set_int):
  ((p_bijective(int, angle1, t2tb72(f), t2tb71(sa), t2tb6(sb)))
  => ((FORALL (b : INT):
      ((mem(int, t2tb5(b), t2tb6(sb))) => (mem(angle1, t2tb33((tb2t35(
      inverse1(int, angle1, t2tb72(f), t2tb71(sa), t2tb6(sb)))[b])), 
      t2tb71(sa)))))
     AND ((FORALL (b : INT):
          ((mem(int, t2tb5(b), t2tb6(sb))) => (tb2t5(infix_at(int, angle1, 
          t2tb72(f), t2tb33((tb2t35(inverse1(int, angle1, t2tb72(f), 
          t2tb71(sa), t2tb6(sb)))[b])))) = b)))
         AND (p_bijective(angle1, int, inverse1(int, angle1, t2tb72(f), 
         t2tb71(sa), t2tb6(sb)), t2tb6(sb), t2tb71(sa)))))));

% inverse'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), sa : set_int, sb : set_angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)))
  => ((FORALL (b : angle):
      ((mem(angle1, t2tb33(b), t2tb71(sb))) => (mem(int, infix_at(int,
      angle1, inverse1(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)), 
      t2tb33(b)), t2tb6(sa)))))
     AND ((FORALL (b : angle):
          ((mem(angle1, t2tb33(b), t2tb71(sb))) => ((f[tb2t5(infix_at(int,
          angle1, inverse1(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)), 
          t2tb33(b)))]) = b)))
         AND (p_bijective(int, angle1, inverse1(angle1, int, t2tb35(f), 
         t2tb6(sa), t2tb71(sb)), t2tb71(sb), t2tb6(sa)))))));

% inverse'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), sa : set_int, sb : set_int):
  ((p_bijective(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)))
  => ((FORALL (b : INT):
      ((mem(int, t2tb5(b), t2tb6(sb))) => (mem(int, t2tb5((tb2t7(
      inverse1(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)))[b])), t2tb6(sa)))))
     AND ((FORALL (b : INT):
          ((mem(int, t2tb5(b), t2tb6(sb))) => ((f[(tb2t7(inverse1(int, int, 
          t2tb7(f), t2tb6(sa), t2tb6(sb)))[b])]) = b)))
         AND (p_bijective(int, int, inverse1(int, int, t2tb7(f), t2tb6(sa), 
         t2tb6(sb)), t2tb6(sb), t2tb6(sa)))))));

% inverse'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sa : uni, sb : uni):
  ((p_bijective(b, a, f, sa, sb))
  => ((FORALL (b1 : uni):
      ((mem(b, b1, sb)) => (mem(a, infix_at(a, b, inverse1(b, a, f, sa, sb),
      b1), sa))))
     AND ((FORALL (b1 : uni):
          ((sort(b, b1))
          => ((mem(b, b1, sb)) => (infix_at(b, a, f, infix_at(a, b, 
             inverse1(b, a, f, sa, sb), b1)) = b1))))
         AND (p_bijective(a, b, inverse1(b, a, f, sa, sb), sb, sa)))))));

% unic_inverse
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), fqt : (ARRAY INT OF angle),
  sa : set_angle, sb : set_int):
  ((p_bijective(int, angle1, t2tb72(f), t2tb71(sa), t2tb6(sb)))
  => ((FORALL (a : angle):
      ((mem(angle1, t2tb33(a), t2tb71(sa))) => ((fqt[tb2t5(infix_at(int,
      angle1, t2tb72(f), t2tb33(a)))]) = a)))
     => (FORALL (b : INT):
        ((mem(int, t2tb5(b), t2tb6(sb))) => ((fqt[b]) = (tb2t35(inverse1(int,
        angle1, t2tb72(f), t2tb71(sa), t2tb6(sb)))[b])))))));

% unic_inverse
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), fqt : (ARRAY angle OF INT),
  sa : set_int, sb : set_angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)))
  => ((FORALL (a : INT):
      ((mem(int, t2tb5(a), t2tb6(sa))) => (tb2t5(infix_at(int, angle1, 
      t2tb72(fqt), t2tb33((f[a])))) = a)))
     => (FORALL (b : angle):
        ((mem(angle1, t2tb33(b), t2tb71(sb))) => (tb2t5(infix_at(int, angle1, 
        t2tb72(fqt), t2tb33(b))) = tb2t5(infix_at(int, angle1, 
        inverse1(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)), 
        t2tb33(b)))))))));

% unic_inverse
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), fqt : (ARRAY INT OF INT), sa : set_int,
  sb : set_int):
  ((p_bijective(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)))
  => ((FORALL (a : INT):
      ((mem(int, t2tb5(a), t2tb6(sa))) => ((fqt[(f[a])]) = a)))
     => (FORALL (b : INT):
        ((mem(int, t2tb5(b), t2tb6(sb))) => ((fqt[b]) = (tb2t7(inverse1(int,
        int, t2tb7(f), t2tb6(sa), t2tb6(sb)))[b])))))));

% unic_inverse
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, fqt : uni, sa : uni, sb : uni):
  ((p_bijective(b, a, f, sa, sb))
  => ((FORALL (a1 : uni):
      ((sort(a, a1))
      => ((mem(a, a1, sa)) => (infix_at(a, b, fqt, infix_at(b, a, f,
         a1)) = a1))))
     => (FORALL (b1 : uni):
        ((mem(b, b1, sb)) => (infix_at(a, b, fqt, b1) = infix_at(a, b, 
        inverse1(b, a, f, sa, sb), b1))))))));

% unic_inverse_apply
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), sa : set_angle, sb : set_int, b : INT,
  a : angle):
  ((p_bijective(int, angle1, t2tb72(f), t2tb71(sa), t2tb6(sb)))
  => ((mem(int, t2tb5(b), t2tb6(sb)))
     => ((mem(angle1, t2tb33(a), t2tb71(sa)))
        => ((tb2t5(infix_at(int, angle1, t2tb72(f), t2tb33(a))) = b) => ((
           tb2t35(inverse1(int, angle1, t2tb72(f), t2tb71(sa), 
           t2tb6(sb)))[b]) = a))))));

% unic_inverse_apply
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), sa : set_int, sb : set_angle, b : angle,
  a : INT):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)))
  => ((mem(angle1, t2tb33(b), t2tb71(sb)))
     => ((mem(int, t2tb5(a), t2tb6(sa)))
        => (((f[a]) = b) => (tb2t5(infix_at(int, angle1, inverse1(angle1,
           int, t2tb35(f), t2tb6(sa), t2tb71(sb)), t2tb33(b))) = a))))));

% unic_inverse_apply
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), sa : set_int, sb : set_int, b : INT,
  a : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)))
  => ((mem(int, t2tb5(b), t2tb6(sb)))
     => ((mem(int, t2tb5(a), t2tb6(sa)))
        => (((f[a]) = b) => ((tb2t7(inverse1(int, int, t2tb7(f), t2tb6(sa), 
           t2tb6(sb)))[b]) = a))))));

% unic_inverse_apply
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sa : uni, sb : uni, b1 : uni, a1 : uni):
  ((sort(a, a1))
  => ((p_bijective(b, a, f, sa, sb))
     => ((mem(b, b1, sb))
        => ((mem(a, a1, sa))
           => ((infix_at(b, a, f, a1) = b1) => (infix_at(a, b, inverse1(b, a,
              f, sa, sb), b1) = a1))))))));

% inverse_invol
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), sa : set_int, sb : set_angle, a : INT):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)))
  => ((mem(int, t2tb5(a), t2tb6(sa))) => ((tb2t35(inverse1(int, angle1, 
     inverse1(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)), t2tb71(sb), 
     t2tb6(sa)))[a]) = (f[a])))));

% inverse_invol
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), sa : set_int, sb : set_int, a : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)))
  => ((mem(int, t2tb5(a), t2tb6(sa))) => ((tb2t7(inverse1(int, int, 
     inverse1(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)), t2tb6(sb), 
     t2tb6(sa)))[a]) = (f[a])))));

% inverse_invol
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sa : uni, sb : uni, a1 : uni):
  ((p_bijective(b, a, f, sa, sb))
  => ((mem(a, a1, sa)) => (infix_at(b, a, inverse1(a, b, inverse1(b, a, f,
     sa, sb), sb, sa), a1) = infix_at(b, a, f, a1))))));

% compose_inverse
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), sa : set_angle, sb : set_int, b : INT):
  ((p_bijective(int, angle1, t2tb72(f), t2tb71(sa), t2tb6(sb)))
  => ((mem(int, t2tb5(b), t2tb6(sb))) => (tb2t5(infix_at(int, angle1, 
     t2tb72(f), t2tb33((tb2t35(inverse1(int, angle1, t2tb72(f), t2tb71(sa), 
     t2tb6(sb)))[b])))) = b))));

% compose_inverse
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), sa : set_int, sb : set_angle,
  b : angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)))
  => ((mem(angle1, t2tb33(b), t2tb71(sb))) => ((f[tb2t5(infix_at(int, angle1, 
     inverse1(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)), 
     t2tb33(b)))]) = b))));

% compose_inverse
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), sa : set_int, sb : set_int, b : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)))
  => ((mem(int, t2tb5(b), t2tb6(sb))) => ((f[(tb2t7(inverse1(int, int, 
     t2tb7(f), t2tb6(sa), t2tb6(sb)))[b])]) = b))));

% compose_inverse
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sa : uni, sb : uni, b1 : uni):
  ((sort(b, b1))
  => ((p_bijective(b, a, f, sa, sb))
     => ((mem(b, b1, sb)) => (infix_at(b, a, f, infix_at(a, b, inverse1(b, a,
        f, sa, sb), b1)) = b1))))));

% inverse_compose
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), sa : set_angle, sb : set_int,
  a : angle):
  ((p_bijective(int, angle1, t2tb72(f), t2tb71(sa), t2tb6(sb)))
  => ((mem(angle1, t2tb33(a), t2tb71(sa))) => ((tb2t35(inverse1(int, angle1, 
     t2tb72(f), t2tb71(sa), t2tb6(sb)))[tb2t5(infix_at(int, angle1, 
     t2tb72(f), t2tb33(a)))]) = a))));

% inverse_compose
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), sa : set_int, sb : set_angle, a : INT):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)))
  => ((mem(int, t2tb5(a), t2tb6(sa))) => (tb2t5(infix_at(int, angle1, 
     inverse1(angle1, int, t2tb35(f), t2tb6(sa), t2tb71(sb)), 
     t2tb33((f[a])))) = a))));

% inverse_compose
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), sa : set_int, sb : set_int, a : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(sa), t2tb6(sb)))
  => ((mem(int, t2tb5(a), t2tb6(sa))) => ((tb2t7(inverse1(int, int, t2tb7(f), 
     t2tb6(sa), t2tb6(sb)))[(f[a])]) = a))));

% inverse_compose
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sa : uni, sb : uni, a1 : uni):
  ((sort(a, a1))
  => ((p_bijective(b, a, f, sa, sb))
     => ((mem(a, a1, sa)) => (infix_at(a, b, inverse1(b, a, f, sa, sb), 
        infix_at(b, a, f, a1)) = a1))))));

% int_iterate_def_empty
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT):
  ((j <= i)
  => ((iterable(im1, op1)) => (int_iterate(im1, op1, f, i, j) = 
     neutral_elt(im1, op1))))));

% int_iterate_def_plus_one
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), i : INT, j : INT):
  ((i < j)
  => ((((i + 1) = j) => (iterable(angle1, t2tb34(op1)))) => (tb2t33(
     int_iterate(angle1, t2tb34(op1), t2tb35(f), i, j)) = tb2t33(
     infix_at(angle1, angle1, infix_at(infix_mngt(angle1, angle1), angle1, 
     t2tb34(op1), t2tb33((f[i]))), int_iterate(angle1, t2tb34(op1), 
     t2tb35(f), (i + 1), j)))))));

% int_iterate_def_plus_one
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  i : INT, j : INT):
  ((i < j)
  => ((((i + 1) = j) => (iterable(int, t2tb8(op1)))) => (tb2t5(
     int_iterate(int, t2tb8(op1), t2tb7(f), i, j)) = (tb2t7(infix_at(
     infix_mngt(int, int), int, t2tb8(op1), t2tb5((f[i]))))[tb2t5(
     int_iterate(int, t2tb8(op1), t2tb7(f), (i + 1), j))])))));

% int_iterate_def_plus_one
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT):
  ((i < j)
  => ((((i + 1) = j) => (iterable(im1, op1))) => (int_iterate(im1, op1, f, i,
     j) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
     infix_at(im1, int, f, t2tb5(i))), int_iterate(im1, op1, f, (i + 1),
     j)))))));

% int_iterate_cardone
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), i : INT, j : INT):
  ((j = (i + 1)) => (tb2t33(int_iterate(angle1, t2tb34(op1), t2tb35(f), i,
  j)) = (f[i]))));

% int_iterate_cardone
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  i : INT, j : INT):
  ((j = (i + 1)) => (tb2t5(int_iterate(int, t2tb8(op1), t2tb7(f), i,
  j)) = (f[i]))));

% int_iterate_cardone
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT):
  ((j = (i + 1)) => (int_iterate(im1, op1, f, i, j) = infix_at(im1, int, f, 
  t2tb5(i))))));

% int_iterate_def_plus_one_com
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), i : INT, j : INT):
  ((i < j)
  => (((j = (i + 1)) => (iterable(angle1, t2tb34(op1)))) => (tb2t33(
     infix_at(angle1, angle1, infix_at(infix_mngt(angle1, angle1), angle1, 
     t2tb34(op1), t2tb33((f[i]))), int_iterate(angle1, t2tb34(op1), 
     t2tb35(f), (i + 1), j))) = tb2t33(int_iterate(angle1, t2tb34(op1), 
     t2tb35(f), i, j))))));

% int_iterate_def_plus_one_com
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  i : INT, j : INT):
  ((i < j)
  => (((j = (i + 1)) => (iterable(int, t2tb8(op1)))) => ((tb2t7(infix_at(
     infix_mngt(int, int), int, t2tb8(op1), t2tb5((f[i]))))[tb2t5(
     int_iterate(int, t2tb8(op1), t2tb7(f), (i + 1), j))]) = tb2t5(
     int_iterate(int, t2tb8(op1), t2tb7(f), i, j))))));

% int_iterate_def_plus_one_com
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT):
  ((i < j)
  => (((j = (i + 1)) => (iterable(im1, op1))) => (infix_at(im1, im1, 
     infix_at(infix_mngt(im1, im1), im1, op1, infix_at(im1, int, f, 
     t2tb5(i))), int_iterate(im1, op1, f, (i + 1), j)) = int_iterate(im1,
     op1, f, i, j))))));

% int_iterate_to_iterate
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT):
  (((j <= i) => (iterable(im1, op1)))
  => ((commut(im1, op1)) => (int_iterate(im1, op1, f, i, j) = iterate(im1,
     int, op1, t2tb6(to_fset(i, j)), f))))));

% int_iterate_right_extension
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), i : INT, j : INT):
  ((iterable(angle1, t2tb34(op1)))
  => ((i < j) => (tb2t33(int_iterate(angle1, t2tb34(op1), t2tb35(f), i,
     j)) = tb2t33(infix_at(angle1, angle1, infix_at(infix_mngt(angle1,
     angle1), angle1, t2tb34(op1), int_iterate(angle1, t2tb34(op1), 
     t2tb35(f), i, (j - 1))), t2tb33((f[(j - 1)]))))))));

% int_iterate_right_extension
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  i : INT, j : INT):
  ((iterable(int, t2tb8(op1)))
  => ((i < j) => (tb2t5(int_iterate(int, t2tb8(op1), t2tb7(f), i, j)) = (
     tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), int_iterate(int, 
     t2tb8(op1), t2tb7(f), i, (j - 1))))[(f[(j - 1)])])))));

% int_iterate_right_extension
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT):
  ((iterable(im1, op1))
  => ((i < j) => (int_iterate(im1, op1, f, i, j) = infix_at(im1, im1, 
     infix_at(infix_mngt(im1, im1), im1, op1, int_iterate(im1, op1, f, i,
     (j - 1))), infix_at(im1, int, f, t2tb5((j - 1)))))))));

% int_iterate_right_extension_
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), i : INT, j : INT):
  ((assoc(angle1, t2tb34(op1)))
  => (((i + 1) < j) => (tb2t33(int_iterate(angle1, t2tb34(op1), t2tb35(f), i,
     j)) = tb2t33(infix_at(angle1, angle1, infix_at(infix_mngt(angle1,
     angle1), angle1, t2tb34(op1), int_iterate(angle1, t2tb34(op1), 
     t2tb35(f), i, (j - 1))), t2tb33((f[(j - 1)]))))))));

% int_iterate_right_extension_
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  i : INT, j : INT):
  ((assoc(int, t2tb8(op1)))
  => (((i + 1) < j) => (tb2t5(int_iterate(int, t2tb8(op1), t2tb7(f), i,
     j)) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
     int_iterate(int, t2tb8(op1), t2tb7(f), i, (j - 1))))[(f[(j - 1)])])))));

% int_iterate_right_extension_
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT):
  ((assoc(im1, op1))
  => (((i + 1) < j) => (int_iterate(im1, op1, f, i, j) = infix_at(im1, im1, 
     infix_at(infix_mngt(im1, im1), im1, op1, int_iterate(im1, op1, f, i,
     (j - 1))), infix_at(im1, int, f, t2tb5((j - 1)))))))));

% int_iterate_transitivity
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  i : INT, k : INT, j : INT):
  ((iterable(int, t2tb8(op1)))
  => ((iterable(int, t2tb8(op1)))
     => ((op_neutral_left(int, t2tb8(op1), neutral_elt(int, t2tb8(op1))))
        => (((i <= k) AND (k <= j)) => (tb2t5(int_iterate(int, t2tb8(op1), 
           t2tb7(f), i, j)) = (tb2t7(infix_at(infix_mngt(int, int), int, 
           t2tb8(op1), int_iterate(int, t2tb8(op1), t2tb7(f), i, k)))[tb2t5(
           int_iterate(int, t2tb8(op1), t2tb7(f), k, j))])))))));

% int_iterate_transitivity
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, k : INT, j : INT):
  ((iterable(im1, op1))
  => ((iterable(im1, op1))
     => ((op_neutral_left(im1, op1, neutral_elt(im1, op1)))
        => (((i <= k) AND (k <= j)) => (int_iterate(im1, op1, f, i, j) = 
           infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
           int_iterate(im1, op1, f, i, k)), int_iterate(im1, op1, f, k, j)))))))));

% int_iterate_transitivity_
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  i : INT, k : INT, j : INT):
  ((op_neutral_left(int, t2tb8(op1), neutral_elt(int, t2tb8(op1))))
  => (((i < k) AND (k < j)) => (tb2t5(int_iterate(int, t2tb8(op1), t2tb7(f),
     i, j)) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
     int_iterate(int, t2tb8(op1), t2tb7(f), i, k)))[tb2t5(int_iterate(int, 
     t2tb8(op1), t2tb7(f), k, j))])))));

% int_iterate_transitivity_
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, k : INT, j : INT):
  ((op_neutral_left(im1, op1, neutral_elt(im1, op1)))
  => (((i < k) AND (k < j)) => (int_iterate(im1, op1, f, i, j) = 
     infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
     int_iterate(im1, op1, f, i, k)), int_iterate(im1, op1, f, k, j)))))));

fc11: (ty, uni, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(int, im1), 
  fc11(im1, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), k : INT): ((tb2t35(
  fc11(angle1, t2tb34(op1), t2tb35(f), t2tb35(g)))[k]) = tb2t33(
  infix_at(angle1, angle1, infix_at(infix_mngt(angle1, angle1), angle1, 
  t2tb34(op1), t2tb33((f[k]))), t2tb33((g[k]))))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  g : (ARRAY INT OF INT), k : INT): ((tb2t7(fc11(int, t2tb8(op1), t2tb7(f), 
  t2tb7(g)))[k]) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op1), 
  t2tb5((f[k]))))[(g[k])])));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, g : uni, k : INT): (infix_at(im1, int, 
  fc11(im1, op1, f, g), t2tb5(k)) = infix_at(im1, im1, infix_at(
  infix_mngt(im1, im1), im1, op1, infix_at(im1, int, f, t2tb5(k))), 
  infix_at(im1, int, g, t2tb5(k))))));

% int_iterate_comp_iterate
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  g : (ARRAY INT OF INT), i : INT, j : INT):
  ((iterable(int, t2tb8(op1)))
  => ((op_neutral_right(int, t2tb8(op1), neutral_elt(int, t2tb8(op1))))
     => ((commut(int, t2tb8(op1))) => (tb2t5(int_iterate(int, t2tb8(op1), 
        fc11(int, t2tb8(op1), t2tb7(f), t2tb7(g)), i, j)) = (tb2t7(infix_at(
        infix_mngt(int, int), int, t2tb8(op1), int_iterate(int, t2tb8(op1), 
        t2tb7(f), i, j)))[tb2t5(int_iterate(int, t2tb8(op1), t2tb7(g), i,
        j))]))))));

% int_iterate_comp_iterate
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, g : uni, i : INT, j : INT):
  ((iterable(im1, op1))
  => ((op_neutral_right(im1, op1, neutral_elt(im1, op1)))
     => ((commut(im1, op1)) => (int_iterate(im1, op1, fc11(im1, op1, f, g),
        i, j) = infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
        int_iterate(im1, op1, f, i, j)), int_iterate(im1, op1, g, i, j))))))));

% int_iterate_attr_no_f
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, op2 : (ARRAY angle OF (ARRAY angle OF angle)),
  t1 : uni, t2 : (ARRAY INT OF angle), f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : uni):
   ((sort(im1, y)) => (tb2t33(infix_at(angle1, angle1, infix_at(
   infix_mngt(angle1, angle1), angle1, t2tb34(op2), t2tb33((t2[x]))), 
   infix_at(angle1, im1, f, y))) = tb2t33(infix_at(angle1, im1, f, 
   infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, infix_at(im1,
   int, t1, t2tb5(x))), y)))))))
  => ((tb2t33(infix_at(angle1, im1, f, neutral_elt(im1, op1))) = tb2t33(
     neutral_elt(angle1, t2tb34(op2))))
     => ((iterable(im1, op1))
        => ((iterable(angle1, t2tb34(op2)))
           => ((FORALL (i1 : INT): (tb2t33(infix_at(angle1, im1, f, 
               infix_at(im1, int, t1, t2tb5(i1)))) = (t2[i1])))
              => (tb2t33(int_iterate(angle1, t2tb34(op2), t2tb35(t2), i,
              j)) = tb2t33(infix_at(angle1, im1, f, int_iterate(im1, op1, t1,
              i, j)))))))))));

% int_iterate_attr_no_f
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, op2 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : uni,
  t2 : (ARRAY INT OF INT), f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : uni):
   ((sort(im1, y)) => ((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op2), 
   t2tb5((t2[x]))))[tb2t5(infix_at(int, im1, f, y))]) = tb2t5(infix_at(int,
   im1, f, infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
   infix_at(im1, int, t1, t2tb5(x))), y)))))))
  => ((tb2t5(infix_at(int, im1, f, neutral_elt(im1, op1))) = tb2t5(
     neutral_elt(int, t2tb8(op2))))
     => ((iterable(im1, op1))
        => ((iterable(int, t2tb8(op2)))
           => ((FORALL (i1 : INT): (tb2t5(infix_at(int, im1, f, infix_at(im1,
               int, t1, t2tb5(i1)))) = (t2[i1])))
              => (tb2t5(int_iterate(int, t2tb8(op2), t2tb7(t2), i, j)) = 
              tb2t5(infix_at(int, im1, f, int_iterate(im1, op1, t1, i, j)))))))))));

% int_iterate_attr_no_f
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  op2 : (ARRAY angle OF (ARRAY angle OF angle)), t1 : (ARRAY INT OF angle),
  t2 : (ARRAY INT OF angle), f : (ARRAY angle OF angle), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : angle): (tb2t33(infix_at(angle1, angle1, infix_at(
   infix_mngt(angle1, angle1), angle1, t2tb34(op2), t2tb33((t2[x]))), 
   infix_at(angle1, angle1, t2tb32(f), t2tb33(y)))) = tb2t33(infix_at(angle1,
   angle1, t2tb32(f), infix_at(angle1, angle1, infix_at(infix_mngt(angle1,
   angle1), angle1, t2tb34(op1), t2tb33((t1[x]))), t2tb33(y)))))))
  => ((tb2t33(infix_at(angle1, angle1, t2tb32(f), neutral_elt(angle1, 
     t2tb34(op1)))) = tb2t33(neutral_elt(angle1, t2tb34(op2))))
     => ((iterable(angle1, t2tb34(op1)))
        => ((iterable(angle1, t2tb34(op2)))
           => ((FORALL (i1 : INT): (tb2t33(infix_at(angle1, angle1, 
               t2tb32(f), t2tb33((t1[i1])))) = (t2[i1])))
              => (tb2t33(int_iterate(angle1, t2tb34(op2), t2tb35(t2), i,
              j)) = tb2t33(infix_at(angle1, angle1, t2tb32(f), 
              int_iterate(angle1, t2tb34(op1), t2tb35(t1), i, j))))))))));

% int_iterate_attr_no_f
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  op2 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : (ARRAY INT OF angle),
  t2 : (ARRAY INT OF INT), f : (ARRAY angle OF INT), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : angle): ((tb2t7(infix_at(infix_mngt(int, int), int, 
   t2tb8(op2), t2tb5((t2[x]))))[tb2t5(infix_at(int, angle1, t2tb72(f), 
   t2tb33(y)))]) = tb2t5(infix_at(int, angle1, t2tb72(f), infix_at(angle1,
   angle1, infix_at(infix_mngt(angle1, angle1), angle1, t2tb34(op1), 
   t2tb33((t1[x]))), t2tb33(y)))))))
  => ((tb2t5(infix_at(int, angle1, t2tb72(f), neutral_elt(angle1, 
     t2tb34(op1)))) = tb2t5(neutral_elt(int, t2tb8(op2))))
     => ((iterable(angle1, t2tb34(op1)))
        => ((iterable(int, t2tb8(op2)))
           => ((FORALL (i1 : INT): (tb2t5(infix_at(int, angle1, t2tb72(f), 
               t2tb33((t1[i1])))) = (t2[i1])))
              => (tb2t5(int_iterate(int, t2tb8(op2), t2tb7(t2), i, j)) = 
              tb2t5(infix_at(int, angle1, t2tb72(f), int_iterate(angle1, 
              t2tb34(op1), t2tb35(t1), i, j))))))))));

% int_iterate_attr_no_f
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), op2 : uni,
  t1 : (ARRAY INT OF angle), t2 : uni, f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : angle): (infix_at(im2, im2, infix_at(infix_mngt(im2, im2),
   im2, op2, infix_at(im2, int, t2, t2tb5(x))), infix_at(im2, angle1, f, 
   t2tb33(y))) = infix_at(im2, angle1, f, infix_at(angle1, angle1, infix_at(
   infix_mngt(angle1, angle1), angle1, t2tb34(op1), t2tb33((t1[x]))), 
   t2tb33(y))))))
  => ((infix_at(im2, angle1, f, neutral_elt(angle1, t2tb34(op1))) = 
     neutral_elt(im2, op2))
     => ((iterable(angle1, t2tb34(op1)))
        => ((iterable(im2, op2))
           => ((FORALL (i1 : INT): (infix_at(im2, angle1, f, 
               t2tb33((t1[i1]))) = infix_at(im2, int, t2, t2tb5(i1))))
              => (int_iterate(im2, op2, t2, i, j) = infix_at(im2, angle1, f, 
              int_iterate(angle1, t2tb34(op1), t2tb35(t1), i, j))))))))));

% int_iterate_attr_no_f
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  op2 : (ARRAY angle OF (ARRAY angle OF angle)), t1 : (ARRAY INT OF INT),
  t2 : (ARRAY INT OF angle), f : (ARRAY INT OF angle), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : INT): (tb2t33(infix_at(angle1, angle1, infix_at(
   infix_mngt(angle1, angle1), angle1, t2tb34(op2), t2tb33((t2[x]))), 
   t2tb33((f[y])))) = (f[(tb2t7(infix_at(infix_mngt(int, int), int, 
   t2tb8(op1), t2tb5((t1[x]))))[y])]))))
  => (((f[tb2t5(neutral_elt(int, t2tb8(op1)))]) = tb2t33(neutral_elt(angle1, 
     t2tb34(op2))))
     => ((iterable(int, t2tb8(op1)))
        => ((iterable(angle1, t2tb34(op2)))
           => ((FORALL (i1 : INT): ((f[(t1[i1])]) = (t2[i1]))) => (tb2t33(
              int_iterate(angle1, t2tb34(op2), t2tb35(t2), i, j)) = (f[tb2t5(
              int_iterate(int, t2tb8(op1), t2tb7(t1), i, j))]))))))));

% int_iterate_attr_no_f
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  op2 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : (ARRAY INT OF INT),
  t2 : (ARRAY INT OF INT), f : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op2), 
   t2tb5((t2[x]))))[(f[y])]) = (f[(tb2t7(infix_at(infix_mngt(int, int), int, 
   t2tb8(op1), t2tb5((t1[x]))))[y])]))))
  => (((f[tb2t5(neutral_elt(int, t2tb8(op1)))]) = tb2t5(neutral_elt(int, 
     t2tb8(op2))))
     => ((iterable(int, t2tb8(op1)))
        => ((iterable(int, t2tb8(op2)))
           => ((FORALL (i1 : INT): ((f[(t1[i1])]) = (t2[i1]))) => (tb2t5(
              int_iterate(int, t2tb8(op2), t2tb7(t2), i, j)) = (f[tb2t5(
              int_iterate(int, t2tb8(op1), t2tb7(t1), i, j))]))))))));

% int_iterate_attr_no_f
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), op2 : uni,
  t1 : (ARRAY INT OF INT), t2 : uni, f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : INT): (infix_at(im2, im2, infix_at(infix_mngt(im2, im2), im2,
   op2, infix_at(im2, int, t2, t2tb5(x))), infix_at(im2, int, f, 
   t2tb5(y))) = infix_at(im2, int, f, t2tb5((tb2t7(infix_at(infix_mngt(int,
   int), int, t2tb8(op1), t2tb5((t1[x]))))[y]))))))
  => ((infix_at(im2, int, f, neutral_elt(int, t2tb8(op1))) = neutral_elt(im2,
     op2))
     => ((iterable(int, t2tb8(op1)))
        => ((iterable(im2, op2))
           => ((FORALL (i1 : INT): (infix_at(im2, int, f, t2tb5((t1[i1]))) = 
               infix_at(im2, int, t2, t2tb5(i1))))
              => (int_iterate(im2, op2, t2, i, j) = infix_at(im2, int, f, 
              int_iterate(int, t2tb8(op1), t2tb7(t1), i, j))))))))));

% int_iterate_attr_no_f
  ASSERT
  (FORALL (im1 : ty, im2 : ty):
  (FORALL (op1 : uni, op2 : uni, t1 : uni, t2 : uni, f : uni, i : INT,
  j : INT):
  ((FORALL (x : INT):
   (FORALL (y : uni):
   ((sort(im1, y)) => (infix_at(im2, im2, infix_at(infix_mngt(im2, im2), im2,
   op2, infix_at(im2, int, t2, t2tb5(x))), infix_at(im2, im1, f, y)) = 
   infix_at(im2, im1, f, infix_at(im1, im1, infix_at(infix_mngt(im1, im1),
   im1, op1, infix_at(im1, int, t1, t2tb5(x))), y))))))
  => ((infix_at(im2, im1, f, neutral_elt(im1, op1)) = neutral_elt(im2, op2))
     => ((iterable(im1, op1))
        => ((iterable(im2, op2))
           => ((FORALL (i1 : INT): (infix_at(im2, im1, f, infix_at(im1, int,
               t1, t2tb5(i1))) = infix_at(im2, int, t2, t2tb5(i1))))
              => (int_iterate(im2, op2, t2, i, j) = infix_at(im2, im1, f, 
              int_iterate(im1, op1, t1, i, j))))))))));

fc12: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty, im2 : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(int, im2), fc12(im2, im1, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (t1 : uni, f : uni, e : INT): ((tb2t35(fc12(angle1, im1, t1,
  f))[e]) = tb2t33(infix_at(angle1, im1, f, infix_at(im1, int, t1, 
  t2tb5(e)))))));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (t1 : uni, f : uni, e : INT): ((tb2t7(fc12(int, im1, t1, f))[e]) = 
  tb2t5(infix_at(int, im1, f, infix_at(im1, int, t1, t2tb5(e)))))));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF angle), f : (ARRAY angle OF angle), e : INT):
  ((tb2t35(fc12(angle1, angle1, t2tb35(t1), t2tb32(f)))[e]) = tb2t33(
  infix_at(angle1, angle1, t2tb32(f), t2tb33((t1[e]))))));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF angle), f : (ARRAY angle OF INT), e : INT): ((
  tb2t7(fc12(int, angle1, t2tb35(t1), t2tb72(f)))[e]) = tb2t5(infix_at(int,
  angle1, t2tb72(f), t2tb33((t1[e]))))));

% fc'def
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (t1 : (ARRAY INT OF angle), f : uni, e : INT): (infix_at(im2, int, 
  fc12(im2, angle1, t2tb35(t1), f), t2tb5(e)) = infix_at(im2, angle1, f, 
  t2tb33((t1[e]))))));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), f : (ARRAY INT OF angle), e : INT): ((
  tb2t35(fc12(angle1, int, t2tb7(t1), t2tb35(f)))[e]) = (f[(t1[e])])));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), f : (ARRAY INT OF INT), e : INT): ((
  tb2t7(fc12(int, int, t2tb7(t1), t2tb7(f)))[e]) = (f[(t1[e])])));

% fc'def
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (t1 : (ARRAY INT OF INT), f : uni, e : INT): (infix_at(im2, int, 
  fc12(im2, int, t2tb7(t1), f), t2tb5(e)) = infix_at(im2, int, f, 
  t2tb5((t1[e]))))));

% fc'def
  ASSERT
  (FORALL (im1 : ty, im2 : ty):
  (FORALL (t1 : uni, f : uni, e : INT): (infix_at(im2, int, fc12(im2, im1,
  t1, f), t2tb5(e)) = infix_at(im2, im1, f, infix_at(im1, int, t1, 
  t2tb5(e))))));

% int_iterate_attr
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, op2 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : uni,
  f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : uni):
   ((sort(im1, y)) => ((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op2), 
   infix_at(int, im1, f, infix_at(im1, int, t1, t2tb5(x)))))[tb2t5(
   infix_at(int, im1, f, y))]) = tb2t5(infix_at(int, im1, f, infix_at(im1,
   im1, infix_at(infix_mngt(im1, im1), im1, op1, infix_at(im1, int, t1, 
   t2tb5(x))), y)))))))
  => ((tb2t5(infix_at(int, im1, f, neutral_elt(im1, op1))) = tb2t5(
     neutral_elt(int, t2tb8(op2))))
     => ((iterable(im1, op1))
        => ((iterable(int, t2tb8(op2))) => (tb2t5(int_iterate(int, 
           t2tb8(op2), fc12(int, im1, t1, f), i, j)) = tb2t5(infix_at(int,
           im1, f, int_iterate(im1, op1, t1, i, j))))))))));

% int_iterate_attr
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  op2 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : (ARRAY INT OF angle),
  f : (ARRAY angle OF INT), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : angle): ((tb2t7(infix_at(infix_mngt(int, int), int, 
   t2tb8(op2), infix_at(int, angle1, t2tb72(f), t2tb33((t1[x])))))[tb2t5(
   infix_at(int, angle1, t2tb72(f), t2tb33(y)))]) = tb2t5(infix_at(int,
   angle1, t2tb72(f), infix_at(angle1, angle1, infix_at(infix_mngt(angle1,
   angle1), angle1, t2tb34(op1), t2tb33((t1[x]))), t2tb33(y)))))))
  => ((tb2t5(infix_at(int, angle1, t2tb72(f), neutral_elt(angle1, 
     t2tb34(op1)))) = tb2t5(neutral_elt(int, t2tb8(op2))))
     => ((iterable(angle1, t2tb34(op1)))
        => ((iterable(int, t2tb8(op2))) => (tb2t5(int_iterate(int, 
           t2tb8(op2), fc12(int, angle1, t2tb35(t1), t2tb72(f)), i, j)) = 
           tb2t5(infix_at(int, angle1, t2tb72(f), int_iterate(angle1, 
           t2tb34(op1), t2tb35(t1), i, j)))))))));

% int_iterate_attr
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), op2 : uni,
  t1 : (ARRAY INT OF angle), f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : angle): (infix_at(im2, im2, infix_at(infix_mngt(im2, im2),
   im2, op2, infix_at(im2, angle1, f, t2tb33((t1[x])))), infix_at(im2,
   angle1, f, t2tb33(y))) = infix_at(im2, angle1, f, infix_at(angle1, angle1, 
   infix_at(infix_mngt(angle1, angle1), angle1, t2tb34(op1), 
   t2tb33((t1[x]))), t2tb33(y))))))
  => ((infix_at(im2, angle1, f, neutral_elt(angle1, t2tb34(op1))) = 
     neutral_elt(im2, op2))
     => ((iterable(angle1, t2tb34(op1)))
        => ((iterable(im2, op2)) => (int_iterate(im2, op2, fc12(im2, angle1, 
           t2tb35(t1), f), i, j) = infix_at(im2, angle1, f, 
           int_iterate(angle1, t2tb34(op1), t2tb35(t1), i, j)))))))));

% int_iterate_attr
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  op2 : (ARRAY angle OF (ARRAY angle OF angle)), t1 : (ARRAY INT OF INT),
  f : (ARRAY INT OF angle), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : INT): (tb2t33(infix_at(angle1, angle1, infix_at(
   infix_mngt(angle1, angle1), angle1, t2tb34(op2), t2tb33((f[(t1[x])]))), 
   t2tb33((f[y])))) = (f[(tb2t7(infix_at(infix_mngt(int, int), int, 
   t2tb8(op1), t2tb5((t1[x]))))[y])]))))
  => (((f[tb2t5(neutral_elt(int, t2tb8(op1)))]) = tb2t33(neutral_elt(angle1, 
     t2tb34(op2))))
     => ((iterable(int, t2tb8(op1)))
        => ((iterable(angle1, t2tb34(op2))) => (tb2t33(int_iterate(angle1, 
           t2tb34(op2), fc12(angle1, int, t2tb7(t1), t2tb35(f)), i, j)) = (f[
           tb2t5(int_iterate(int, t2tb8(op1), t2tb7(t1), i, j))])))))));

% int_iterate_attr
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  op2 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : (ARRAY INT OF INT),
  f : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op2), 
   t2tb5((f[(t1[x])]))))[(f[y])]) = (f[(tb2t7(infix_at(infix_mngt(int, int),
   int, t2tb8(op1), t2tb5((t1[x]))))[y])]))))
  => (((f[tb2t5(neutral_elt(int, t2tb8(op1)))]) = tb2t5(neutral_elt(int, 
     t2tb8(op2))))
     => ((iterable(int, t2tb8(op1)))
        => ((iterable(int, t2tb8(op2))) => (tb2t5(int_iterate(int, 
           t2tb8(op2), fc12(int, int, t2tb7(t1), t2tb7(f)), i, j)) = (f[
           tb2t5(int_iterate(int, t2tb8(op1), t2tb7(t1), i, j))])))))));

% int_iterate_attr
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), op2 : uni,
  t1 : (ARRAY INT OF INT), f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : INT): (infix_at(im2, im2, infix_at(infix_mngt(im2, im2), im2,
   op2, infix_at(im2, int, f, t2tb5((t1[x])))), infix_at(im2, int, f, 
   t2tb5(y))) = infix_at(im2, int, f, t2tb5((tb2t7(infix_at(infix_mngt(int,
   int), int, t2tb8(op1), t2tb5((t1[x]))))[y]))))))
  => ((infix_at(im2, int, f, neutral_elt(int, t2tb8(op1))) = neutral_elt(im2,
     op2))
     => ((iterable(int, t2tb8(op1)))
        => ((iterable(im2, op2)) => (int_iterate(im2, op2, fc12(im2, int, 
           t2tb7(t1), f), i, j) = infix_at(im2, int, f, int_iterate(int, 
           t2tb8(op1), t2tb7(t1), i, j)))))))));

% int_iterate_attr
  ASSERT
  (FORALL (im1 : ty, im2 : ty):
  (FORALL (op1 : uni, op2 : uni, t1 : uni, f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : uni):
   ((sort(im1, y)) => (infix_at(im2, im2, infix_at(infix_mngt(im2, im2), im2,
   op2, infix_at(im2, im1, f, infix_at(im1, int, t1, t2tb5(x)))), 
   infix_at(im2, im1, f, y)) = infix_at(im2, im1, f, infix_at(im1, im1, 
   infix_at(infix_mngt(im1, im1), im1, op1, infix_at(im1, int, t1, 
   t2tb5(x))), y))))))
  => ((infix_at(im2, im1, f, neutral_elt(im1, op1)) = neutral_elt(im2, op2))
     => ((iterable(im1, op1))
        => ((iterable(im2, op2)) => (int_iterate(im2, op2, fc12(im2, im1, t1,
           f), i, j) = infix_at(im2, im1, f, int_iterate(im1, op1, t1, i,
           j)))))))));

fc13: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty, im2 : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(int, im2), fc13(im2, im1, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (t1 : uni, f : uni, e : INT): ((tb2t35(fc13(angle1, im1, t1,
  f))[e]) = tb2t33(infix_at(angle1, im1, f, infix_at(im1, int, t1, 
  t2tb5(e)))))));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (t1 : uni, f : uni, e : INT): ((tb2t7(fc13(int, im1, t1, f))[e]) = 
  tb2t5(infix_at(int, im1, f, infix_at(im1, int, t1, t2tb5(e)))))));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF angle), f : (ARRAY angle OF angle), e : INT):
  ((tb2t35(fc13(angle1, angle1, t2tb35(t1), t2tb32(f)))[e]) = tb2t33(
  infix_at(angle1, angle1, t2tb32(f), t2tb33((t1[e]))))));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF angle), f : (ARRAY angle OF INT), e : INT): ((
  tb2t7(fc13(int, angle1, t2tb35(t1), t2tb72(f)))[e]) = tb2t5(infix_at(int,
  angle1, t2tb72(f), t2tb33((t1[e]))))));

% fc'def
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (t1 : (ARRAY INT OF angle), f : uni, e : INT): (infix_at(im2, int, 
  fc13(im2, angle1, t2tb35(t1), f), t2tb5(e)) = infix_at(im2, angle1, f, 
  t2tb33((t1[e]))))));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), f : (ARRAY INT OF angle), e : INT): ((
  tb2t35(fc13(angle1, int, t2tb7(t1), t2tb35(f)))[e]) = (f[(t1[e])])));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), f : (ARRAY INT OF INT), e : INT): ((
  tb2t7(fc13(int, int, t2tb7(t1), t2tb7(f)))[e]) = (f[(t1[e])])));

% fc'def
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (t1 : (ARRAY INT OF INT), f : uni, e : INT): (infix_at(im2, int, 
  fc13(im2, int, t2tb7(t1), f), t2tb5(e)) = infix_at(im2, int, f, 
  t2tb5((t1[e]))))));

% fc'def
  ASSERT
  (FORALL (im1 : ty, im2 : ty):
  (FORALL (t1 : uni, f : uni, e : INT): (infix_at(im2, int, fc13(im2, im1,
  t1, f), t2tb5(e)) = infix_at(im2, im1, f, infix_at(im1, int, t1, 
  t2tb5(e))))));

% int_iterate_attr_comm
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, op2 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : uni,
  f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : uni):
   ((sort(im1, y)) => ((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op2), 
   infix_at(int, im1, f, infix_at(im1, int, t1, t2tb5(x)))))[tb2t5(
   infix_at(int, im1, f, y))]) = tb2t5(infix_at(int, im1, f, infix_at(im1,
   im1, infix_at(infix_mngt(im1, im1), im1, op1, infix_at(im1, int, t1, 
   t2tb5(x))), y)))))))
  => ((tb2t5(infix_at(int, im1, f, neutral_elt(im1, op1))) = tb2t5(
     neutral_elt(int, t2tb8(op2))))
     => ((iterable(im1, op1))
        => ((iterable(int, t2tb8(op2))) => (tb2t5(infix_at(int, im1, f, 
           int_iterate(im1, op1, t1, i, j))) = tb2t5(int_iterate(int, 
           t2tb8(op2), fc13(int, im1, t1, f), i, j)))))))));

% int_iterate_attr_comm
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  op2 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : (ARRAY INT OF angle),
  f : (ARRAY angle OF INT), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : angle): ((tb2t7(infix_at(infix_mngt(int, int), int, 
   t2tb8(op2), infix_at(int, angle1, t2tb72(f), t2tb33((t1[x])))))[tb2t5(
   infix_at(int, angle1, t2tb72(f), t2tb33(y)))]) = tb2t5(infix_at(int,
   angle1, t2tb72(f), infix_at(angle1, angle1, infix_at(infix_mngt(angle1,
   angle1), angle1, t2tb34(op1), t2tb33((t1[x]))), t2tb33(y)))))))
  => ((tb2t5(infix_at(int, angle1, t2tb72(f), neutral_elt(angle1, 
     t2tb34(op1)))) = tb2t5(neutral_elt(int, t2tb8(op2))))
     => ((iterable(angle1, t2tb34(op1)))
        => ((iterable(int, t2tb8(op2))) => (tb2t5(infix_at(int, angle1, 
           t2tb72(f), int_iterate(angle1, t2tb34(op1), t2tb35(t1), i, j))) = 
           tb2t5(int_iterate(int, t2tb8(op2), fc13(int, angle1, t2tb35(t1), 
           t2tb72(f)), i, j))))))));

% int_iterate_attr_comm
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), op2 : uni,
  t1 : (ARRAY INT OF angle), f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : angle): (infix_at(im2, im2, infix_at(infix_mngt(im2, im2),
   im2, op2, infix_at(im2, angle1, f, t2tb33((t1[x])))), infix_at(im2,
   angle1, f, t2tb33(y))) = infix_at(im2, angle1, f, infix_at(angle1, angle1, 
   infix_at(infix_mngt(angle1, angle1), angle1, t2tb34(op1), 
   t2tb33((t1[x]))), t2tb33(y))))))
  => ((infix_at(im2, angle1, f, neutral_elt(angle1, t2tb34(op1))) = 
     neutral_elt(im2, op2))
     => ((iterable(angle1, t2tb34(op1)))
        => ((iterable(im2, op2)) => (infix_at(im2, angle1, f, 
           int_iterate(angle1, t2tb34(op1), t2tb35(t1), i, j)) = 
           int_iterate(im2, op2, fc13(im2, angle1, t2tb35(t1), f), i, j))))))));

% int_iterate_attr_comm
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  op2 : (ARRAY angle OF (ARRAY angle OF angle)), t1 : (ARRAY INT OF INT),
  f : (ARRAY INT OF angle), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : INT): (tb2t33(infix_at(angle1, angle1, infix_at(
   infix_mngt(angle1, angle1), angle1, t2tb34(op2), t2tb33((f[(t1[x])]))), 
   t2tb33((f[y])))) = (f[(tb2t7(infix_at(infix_mngt(int, int), int, 
   t2tb8(op1), t2tb5((t1[x]))))[y])]))))
  => (((f[tb2t5(neutral_elt(int, t2tb8(op1)))]) = tb2t33(neutral_elt(angle1, 
     t2tb34(op2))))
     => ((iterable(int, t2tb8(op1)))
        => ((iterable(angle1, t2tb34(op2))) => ((f[tb2t5(int_iterate(int, 
           t2tb8(op1), t2tb7(t1), i, j))]) = tb2t33(int_iterate(angle1, 
           t2tb34(op2), fc13(angle1, int, t2tb7(t1), t2tb35(f)), i, j))))))));

% int_iterate_attr_comm
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  op2 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : (ARRAY INT OF INT),
  f : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(op2), 
   t2tb5((f[(t1[x])]))))[(f[y])]) = (f[(tb2t7(infix_at(infix_mngt(int, int),
   int, t2tb8(op1), t2tb5((t1[x]))))[y])]))))
  => (((f[tb2t5(neutral_elt(int, t2tb8(op1)))]) = tb2t5(neutral_elt(int, 
     t2tb8(op2))))
     => ((iterable(int, t2tb8(op1)))
        => ((iterable(int, t2tb8(op2))) => ((f[tb2t5(int_iterate(int, 
           t2tb8(op1), t2tb7(t1), i, j))]) = tb2t5(int_iterate(int, 
           t2tb8(op2), fc13(int, int, t2tb7(t1), t2tb7(f)), i, j))))))));

% int_iterate_attr_comm
  ASSERT
  (FORALL (im2 : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), op2 : uni,
  t1 : (ARRAY INT OF INT), f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : INT): (infix_at(im2, im2, infix_at(infix_mngt(im2, im2), im2,
   op2, infix_at(im2, int, f, t2tb5((t1[x])))), infix_at(im2, int, f, 
   t2tb5(y))) = infix_at(im2, int, f, t2tb5((tb2t7(infix_at(infix_mngt(int,
   int), int, t2tb8(op1), t2tb5((t1[x]))))[y]))))))
  => ((infix_at(im2, int, f, neutral_elt(int, t2tb8(op1))) = neutral_elt(im2,
     op2))
     => ((iterable(int, t2tb8(op1)))
        => ((iterable(im2, op2)) => (infix_at(im2, int, f, int_iterate(int, 
           t2tb8(op1), t2tb7(t1), i, j)) = int_iterate(im2, op2, fc13(im2,
           int, t2tb7(t1), f), i, j))))))));

% int_iterate_attr_comm
  ASSERT
  (FORALL (im1 : ty, im2 : ty):
  (FORALL (op1 : uni, op2 : uni, t1 : uni, f : uni, i : INT, j : INT):
  ((FORALL (x : INT):
   (FORALL (y : uni):
   ((sort(im1, y)) => (infix_at(im2, im2, infix_at(infix_mngt(im2, im2), im2,
   op2, infix_at(im2, im1, f, infix_at(im1, int, t1, t2tb5(x)))), 
   infix_at(im2, im1, f, y)) = infix_at(im2, im1, f, infix_at(im1, im1, 
   infix_at(infix_mngt(im1, im1), im1, op1, infix_at(im1, int, t1, 
   t2tb5(x))), y))))))
  => ((infix_at(im2, im1, f, neutral_elt(im1, op1)) = neutral_elt(im2, op2))
     => ((iterable(im1, op1))
        => ((iterable(im2, op2)) => (infix_at(im2, im1, f, int_iterate(im1,
           op1, t1, i, j)) = int_iterate(im2, op2, fc13(im2, im1, t1, f), i,
           j))))))));

% int_iterate_eq
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT, j : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k]))))
  => (((j <= i) => (iterable(angle1, t2tb34(op1)))) => (tb2t33(
     int_iterate(angle1, t2tb34(op1), t2tb35(f), i, j)) = tb2t33(
     int_iterate(angle1, t2tb34(op1), t2tb35(g), i, j))))));

% int_iterate_eq
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), f : (ARRAY INT OF INT),
  g : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k]))))
  => (((j <= i) => (iterable(int, t2tb8(op1)))) => (tb2t5(int_iterate(int, 
     t2tb8(op1), t2tb7(f), i, j)) = tb2t5(int_iterate(int, t2tb8(op1), 
     t2tb7(g), i, j))))));

% int_iterate_eq
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, g : uni, i : INT, j : INT):
  ((FORALL (k : INT):
   (((i <= k) AND (k < j)) => (infix_at(im1, int, f, t2tb5(k)) = 
   infix_at(im1, int, g, t2tb5(k)))))
  => (((j <= i) => (iterable(im1, op1))) => (int_iterate(im1, op1, f, i,
     j) = int_iterate(im1, op1, g, i, j))))));

fc14: (ty, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT): (sort(infix_mngt(int, im1), 
  fc14(im1, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), l : INT, h : INT, a : INT): ((tb2t35(
  fc14(angle1, t2tb35(f), l, h))[a]) = (f[((h - (a + 1)) + l)])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, h : INT, a : INT): ((tb2t7(
  fc14(int, t2tb7(f), l, h))[a]) = (f[((h - (a + 1)) + l)])));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (f : uni, l : INT, h : INT, a : INT): (infix_at(im1, int, fc14(im1,
  f, l, h), t2tb5(a)) = infix_at(im1, int, f, t2tb5(((h - (a + 1)) + l))))));

% int_iterate_left_right
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, l : INT, k : INT, h : INT):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => (((l <= k) AND (k <= h)) => (int_iterate(im1, op1, f, l, k) = 
        int_iterate(im1, op1, fc14(im1, f, l, h), ((h - k) + l), h)))))));

% int_iterate_eq_func
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, i : INT, j : INT, f : uni, g : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => ((p_injective(im1, int, f, t2tb6(to_fset(i, j))))
        => ((p_injective(im1, int, g, t2tb6(to_fset(i, j))))
           => ((map(im1, int, f, t2tb6(to_fset(i, j))) = map(im1, int, g, 
              t2tb6(to_fset(i, j)))) => (int_iterate(im1, op1, f, i, j) = 
              int_iterate(im1, op1, g, i, j)))))))));

fc15: (ty, (ARRAY INT OF INT), uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : (ARRAY INT OF INT), x1 : uni): (sort(infix_mngt(int, im1), 
  fc15(im1, x, x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF angle), b : INT): ((
  tb2t35(fc15(angle1, f, t2tb35(t1)))[b]) = (t1[(f[b])])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  tb2t7(fc15(int, f, t2tb7(t1)))[b]) = (t1[(f[b])])));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (f : (ARRAY INT OF INT), t1 : uni, b : INT): (infix_at(im1, int, 
  fc15(im1, f, t1), t2tb5(b)) = infix_at(im1, int, t1, t2tb5((f[b]))))));

% int_iterate_map
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, i : INT, j : INT, k : INT, l : INT,
  f : (ARRAY INT OF INT), t1 : uni):
  (((j <= i) => (iterable(im1, op1)))
  => ((commut(im1, op1))
     => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(i, j)), t2tb6(
        to_fset(k, l)))) => (int_iterate(im1, op1, t1, k, l) = 
        int_iterate(im1, op1, fc15(im1, f, t1), i, j)))))));

fc16: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(int, im1), fc16(im1, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), k : INT, b : INT): ((tb2t35(fc16(angle1, 
  t2tb35(f), k))[b]) = (f[(b + k)])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), k : INT, b : INT): ((tb2t7(fc16(int, 
  t2tb7(f), k))[b]) = (f[(b + k)])));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (f : uni, k : INT, b : INT): (infix_at(im1, int, fc16(im1, f, k), 
  t2tb5(b)) = infix_at(im1, int, f, t2tb5((b + k))))));

% int_iterate_transl
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, k : INT):
  ((iterable(im1, op1)) => (int_iterate(im1, op1, f, i, j) = int_iterate(im1,
  op1, fc16(im1, f, k), (i - k), (j - k))))));

fc17: (ty, (ARRAY INT OF INT), uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : (ARRAY INT OF INT), x1 : uni): (sort(infix_mngt(int, im1), 
  fc17(im1, x, x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF angle), b : INT): ((
  tb2t35(fc17(angle1, f, t2tb35(t1)))[b]) = (t1[(f[b])])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  tb2t7(fc17(int, f, t2tb7(t1)))[b]) = (t1[(f[b])])));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (f : (ARRAY INT OF INT), t1 : uni, b : INT): (infix_at(im1, int, 
  fc17(im1, f, t1), t2tb5(b)) = infix_at(im1, int, t1, t2tb5((f[b]))))));

% int_iterate_map_auto
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, i : INT, j : INT, f : (ARRAY INT OF INT), t1 : uni):
  (((j <= i) => (iterable(im1, op1)))
  => ((commut(im1, op1))
     => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(i, j)), t2tb6(
        to_fset(i, j)))) => (int_iterate(im1, op1, t1, i, j) = 
        int_iterate(im1, op1, fc17(im1, f, t1), i, j)))))));

% leq_trans
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a <= b) => ((b <= c) => (a <= c))));

% inf_trans
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a < b) => ((b < c) => (a < c))));

% leq_trans_add
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, d : INT):
  ((a <= c) => ((b <= d) => ((a + b) <= (c + d)))));

% leq_trans_mult
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 <= c) => ((a <= b) => ((a * c) <= (b * c)))));

% leq_trans_mult_right
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 <= c) => ((a <= b) => ((c * a) <= (c * b)))));

% compat_int_order_mult
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, d : INT):
  (((0 <= c) AND (c <= d))
  => (((0 <= a) AND (a <= b)) => ((c * a) <= (d * b)))));

% leq_trans_fact
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, n : INT):
  ((0 <= n)
  => (((0 <= a) AND (a <= c))
     => (((0 <= b) AND (b <= (c * n))) => ((a + b) <= (c * (n + 1)))))));

% leq_trans_facrev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, n : INT):
  ((0 <= n)
  => (((0 <= a) AND (a <= c))
     => (((0 <= b) AND (b <= (c * n))) => ((b + a) <= (c * (n + 1)))))));

infix_pl_closure: (ARRAY INT OF (ARRAY INT OF INT));

infix_as_closure: (ARRAY INT OF (ARRAY INT OF INT));

% infix +_closure_def
  ASSERT
  (FORALL (y : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(infix_pl_closure), t2tb5(y)))[y1]) = (y + y1)));

% infix *_closure_def
  ASSERT
  (FORALL (y : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(infix_as_closure), t2tb5(y)))[y1]) = (y * y1)));

% neutrals
  ASSERT
  ((0 = tb2t5(neutral_elt(int, t2tb8(infix_pl_closure))))
  AND ((1 = tb2t5(neutral_elt(int, t2tb8(infix_as_closure))))
      AND ((iterable(int, t2tb8(infix_pl_closure))) AND (iterable(int, 
          t2tb8(infix_as_closure))))));

isum: (ty, uni, uni) -> INT;

% isum'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni): (isum(a, s2, t1) = tb2t5(iterate(int, a, 
  t2tb8(infix_pl_closure), s2, t1)))));

iproduct: (ty, uni, uni) -> INT;

% iproduct'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni): (iproduct(a, s2, t1) = tb2t5(iterate(int, a, 
  t2tb8(infix_as_closure), s2, t1)))));

% isum_iter
  ASSERT (iterates(int, t2tb8(infix_pl_closure), t2tb5(0)));

% isum_iter__
  ASSERT (iterable(int, t2tb8(infix_pl_closure)));

% isum_eq
  ASSERT
  (FORALL (s2 : set_int, t1 : (ARRAY INT OF INT), tqt : (ARRAY INT OF INT)):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => ((t1[e]) = (tqt[e]))))
  => (isum(int, t2tb6(s2), t2tb7(t1)) = isum(int, t2tb6(s2), t2tb7(tqt)))));

% isum_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, tqt : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (tb2t5(infix_at(int, a, t1, e)) = tb2t5(
      infix_at(int, a, tqt, e))))))
  => (isum(a, s2, t1) = isum(a, s2, tqt)))));

% isum_eq_gen
  ASSERT
  (FORALL (s2 : set_int, sqt : set_int, t1 : (ARRAY INT OF INT),
  tqt : (ARRAY INT OF INT)):
  ((s2 = sqt)
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => ((t1[e]) = (tqt[e]))))
     => (isum(int, t2tb6(s2), t2tb7(t1)) = isum(int, t2tb6(s2), t2tb7(tqt))))));

% isum_eq_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, t1 : uni, tqt : uni):
  ((s2 = sqt)
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (tb2t5(infix_at(int, a, t1, e)) = tb2t5(
         infix_at(int, a, tqt, e))))))
     => (isum(a, s2, t1) = isum(a, s2, tqt))))));

% isum_add
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT), x : INT):
  ((NOT (mem(int, t2tb5(x), t2tb6(s2)))) => (isum(int, add(int, t2tb5(x), 
  t2tb6(s2)), t2tb7(f)) = ((f[x]) + isum(int, t2tb6(s2), t2tb7(f))))));

% isum_add
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, x : uni):
  ((NOT (mem(b, x, s2))) => (isum(b, add(b, x, s2), f) = (tb2t5(infix_at(int,
  b, f, x)) + isum(b, s2, f))))));

% iproduct_eq
  ASSERT
  (FORALL (s2 : set_int, t1 : (ARRAY INT OF INT), tqt : (ARRAY INT OF INT)):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => ((t1[e]) = (tqt[e]))))
  => (iproduct(int, t2tb6(s2), t2tb7(t1)) = iproduct(int, t2tb6(s2), 
  t2tb7(tqt)))));

% iproduct_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, tqt : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (tb2t5(infix_at(int, a, t1, e)) = tb2t5(
      infix_at(int, a, tqt, e))))))
  => (iproduct(a, s2, t1) = iproduct(a, s2, tqt)))));

% iproduct_eq_gen
  ASSERT
  (FORALL (s2 : set_int, sqt : set_int, t1 : (ARRAY INT OF INT),
  tqt : (ARRAY INT OF INT)):
  ((s2 = sqt)
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => ((t1[e]) = (tqt[e]))))
     => (iproduct(int, t2tb6(s2), t2tb7(t1)) = iproduct(int, t2tb6(s2), 
     t2tb7(tqt))))));

% iproduct_eq_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, t1 : uni, tqt : uni):
  ((s2 = sqt)
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (tb2t5(infix_at(int, a, t1, e)) = tb2t5(
         infix_at(int, a, tqt, e))))))
     => (iproduct(a, s2, t1) = iproduct(a, s2, tqt))))));

% iproduct_add
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT), x : INT):
  ((NOT (mem(int, t2tb5(x), t2tb6(s2)))) => (iproduct(int, add(int, t2tb5(x), 
  t2tb6(s2)), t2tb7(f)) = ((f[x]) * iproduct(int, t2tb6(s2), t2tb7(f))))));

% iproduct_add
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, x : uni):
  ((NOT (mem(b, x, s2))) => (iproduct(b, add(b, x, s2), f) = (tb2t5(
  infix_at(int, b, f, x)) * iproduct(b, s2, f))))));

% iproduct_from_choose
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT)):
  ((0 < cardinal(int, t2tb6(s2))) => (iproduct(int, t2tb6(s2), 
  t2tb7(f)) = ((f[tb2t5(choose(int, t2tb6(s2)))]) * iproduct(int, remove(int, 
  choose(int, t2tb6(s2)), t2tb6(s2)), t2tb7(f))))));

% iproduct_from_choose
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni):
  ((0 < cardinal(b, s2)) => (iproduct(b, s2, f) = (tb2t5(infix_at(int, b, f, 
  choose(b, s2))) * iproduct(b, remove(b, choose(b, s2), s2), f))))));

fc18: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  fc18(f, t1)[b]) = (t1[(f[b])])));

% iproduct_map
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT)):
  ((p_injective(int, int, t2tb7(f), t2tb6(s2))) => (iproduct(int, map(int,
  int, t2tb7(f), t2tb6(s2)), t2tb7(t1)) = iproduct(int, t2tb6(s2), t2tb7(
  fc18(f, t1))))));

fc19: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  fc19(f, t1)[b]) = (t1[(f[b])])));

% iproduct_map_auto
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(s2))) => (iproduct(int, 
  t2tb6(s2), t2tb7(t1)) = iproduct(int, t2tb6(s2), t2tb7(fc19(f, t1))))));

% iproduct_one
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT)):
  ((FORALL (e : INT): ((mem(int, t2tb5(e), t2tb6(s2))) => ((f[e]) = 1))) => (
  iproduct(int, t2tb6(s2), t2tb7(f)) = 1)));

% iproduct_one
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((FORALL (e : uni):
   ((sort(a, e)) => ((mem(a, e, s2)) => (tb2t5(infix_at(int, a, f, e)) = 1))))
  => (iproduct(a, s2, f) = 1))));

% iproduct_one_but_maybe_one_elt
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT), e : INT):
  ((mem(int, t2tb5(e), t2tb6(s2)))
  => ((FORALL (eqt : INT):
      ((mem(int, t2tb5(eqt), t2tb6(s2)))
      => ((NOT (eqt = e)) => ((f[eqt]) = 1))))
     => ((iproduct(int, t2tb6(s2), t2tb7(f)) = (f[e])) AND (iproduct(int, 
        t2tb6(s2), t2tb7(f)) = ((f[tb2t5(choose(int, t2tb6(s2)))]) * 
        iproduct(int, remove(int, choose(int, t2tb6(s2)), t2tb6(s2)), 
        t2tb7(f))))))));

% iproduct_one_but_maybe_one_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, e : uni):
  ((mem(a, e, s2))
  => ((FORALL (eqt : uni):
      ((sort(a, eqt))
      => ((mem(a, eqt, s2))
         => ((NOT (eqt = e)) => (tb2t5(infix_at(int, a, f, eqt)) = 1)))))
     => ((iproduct(a, s2, f) = tb2t5(infix_at(int, a, f, e))) AND (
        iproduct(a, s2, f) = (tb2t5(infix_at(int, a, f, choose(a, s2))) * 
        iproduct(a, remove(a, choose(a, s2), s2), f))))))));

% mul_assoc
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): (((a * b) * c) = (a * (b * c))));

% ad_assoc
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): (((a + b) + c) = (a + (b + c))));

% ad_assoc_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a + (b + c)) = ((a + b) + c)));

% ad_seq_switch
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, aqt : INT, bqt : INT, cqt : INT):
  ((a = aqt)
  => ((b = bqt) => ((c = cqt) => ((aqt + (bqt + cqt)) = (b + (c + a)))))));

% mul_comm
  ASSERT (FORALL (a : INT, b : INT): ((a * b) = (b * a)));

% add_eq_i
  ASSERT
  (FORALL (a : INT, aqt : INT, b : INT, bqt : INT):
  ((a = aqt) => ((b = bqt) => ((a + b) = (aqt + bqt)))));

% mult_eq_i
  ASSERT
  (FORALL (a : INT, aqt : INT, b : INT, bqt : INT):
  ((a = aqt) => ((b = bqt) => ((a * b) = (aqt * bqt)))));

% mul_assoc_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a * (b * c)) = ((a * b) * c)));

% mult_add_distr
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, d : INT):
  (((a + b) * (c + d)) = ((((a * c) + (a * d)) + (b * c)) + (b * d))));

% mult_add_right
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): (((a + b) * c) = ((a * c) + (b * c))));

% mult_add_right_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): (((a * c) + (b * c)) = ((a + b) * c)));

% mult_add_left
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a * (b + c)) = ((a * b) + (a * c))));

% mult_add_left_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): (((a * b) + (a * c)) = (a * (b + c))));

% mult_add_distr_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, d : INT):
  (((((a * c) + (a * d)) + (b * c)) + (b * d)) = ((a + b) * (c + d))));

% mul_assoc_comm
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): (((a * b) * c) = (b * (a * c))));

% mul_assoc_rev_comm
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a * (b * c)) = ((a * c) * b)));

% add_assoc
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): (((a + b) + c) = (a + (b + c))));

% add_assoc_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a + (b + c)) = ((a + b) + c)));

% isum_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni): ((is_empty(a, s2)) => (isum(a, s2, f) = 0))));

% iproduct_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((is_empty(a, s2)) => (iproduct(a, s2, f) = 1))));

infix_mn_closure: (ARRAY INT OF (ARRAY INT OF INT));

% infix -_closure_def
  ASSERT
  (FORALL (y : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(infix_mn_closure), t2tb5(y)))[y1]) = (y - y1)));

% isum_iter_
  ASSERT
  ((opposite_n(int, t2tb8(infix_pl_closure), t2tb8(infix_mn_closure), 
  t2tb5(0)))
  AND ((opposite(int, t2tb8(infix_pl_closure), t2tb8(infix_mn_closure)))
      AND ((opposite_com(int, t2tb8(infix_pl_closure), 
          t2tb8(infix_mn_closure))) AND (inverse_tuple(int, 
          t2tb8(infix_pl_closure), t2tb8(infix_mn_closure), t2tb5(0))))));

% pos_to_strict
  ASSERT (FORALL (a : INT): ((1 <= a) => (0 < a)));

% pos_by_strict
  ASSERT (FORALL (a : INT): ((0 < a) => (1 <= a)));

ind_iproduct: ((ARRAY INT OF INT), INT, INT) -> INT;

% ind_iproduct'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT): (ind_iproduct(f, i,
  j) = tb2t5(int_iterate(int, t2tb8(infix_as_closure), t2tb7(f), i, j))));

% ind_iproduct_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k])))) => (
  ind_iproduct(f, i, j) = ind_iproduct(g, i, j))));

% ind_iproduct_eq_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i1 : INT,
  j1 : INT, i2 : INT, j2 : INT):
  ((FORALL (k : INT): (((i1 <= k) AND (k < j1)) => ((f[k]) = (g[k]))))
  => ((i1 = i2)
     => ((j1 = j2) => (ind_iproduct(f, i1, j1) = ind_iproduct(g, i2, j2))))));

% ind_iproduct_to_iproduct
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT): (ind_iproduct(f, i,
  j) = iproduct(int, t2tb6(to_fset(i, j)), t2tb7(f))));

% ind_iproduct_one_but_maybe_one_elt
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, e : INT):
  (((i <= e) AND (e < j))
  => ((FORALL (eqt : INT):
      (((i <= eqt) AND (eqt <= j)) => ((NOT (e = eqt)) => ((f[eqt]) = 1))))
     => (ind_iproduct(f, i, j) = (f[e])))));

% mult_one_int
  ASSERT (FORALL (a : INT, b : INT): ((b = 1) => ((a * b) = a)));

% one_mult_int
  ASSERT (FORALL (a : INT, b : INT): ((a = 1) => ((a * b) = b)));

% mult_zero_int
  ASSERT (FORALL (a : INT, b : INT): ((b = 0) => ((a * b) = 0)));

% zero_mult_int
  ASSERT (FORALL (a : INT, b : INT): ((a = 0) => ((a * b) = 0)));

% iproduct_to_iterate
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT): (ind_iproduct(f, i,
  j) = tb2t5(int_iterate(int, t2tb8(infix_as_closure), t2tb7(f), i, j))));

% ind_iproduct_empty
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((j <= i) => (ind_iproduct(f, i, j) = 1)));

% ind_iproduct_plus_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j) => (ind_iproduct(f, i, j) = ((f[i]) * ind_iproduct(f, (i + 1),
  j)))));

% ind_iproduct_right_extension
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j) => (ind_iproduct(f, i, j) = (ind_iproduct(f, i,
  (j - 1)) * (f[(j - 1)])))));

% ind_iproduct_right_extension_comm
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j) => ((ind_iproduct(f, i, (j - 1)) * (f[(j - 1)])) = ind_iproduct(f,
  i, j))));

% ind_iproduct_comp
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT),
  h : (ARRAY INT OF INT), i : INT, j : INT):
  ((i <= j)
  => ((FORALL (k : INT):
      (((i <= k) AND (k < j)) => (((f[k]) * (g[k])) = (h[k]))))
     => (ind_iproduct(h, i, j) = (ind_iproduct(f, i, j) * ind_iproduct(g, i,
     j))))));

% ind_iproduct_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = 1))) => (
  ind_iproduct(f, i, j) = 1)));

% positive_iproduct
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => (0 < (f[k])))) => (0 < 
  ind_iproduct(f, i, j))));

% ind_iproduct_pos
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => (0 <= (f[k])))) => (0 <= 
  ind_iproduct(f, i, j))));

% ind_iproduct_strict_pos
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => (0 < (f[k])))) => (0 < 
  ind_iproduct(f, i, j))));

% iproduct_strict_pos
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT)):
  ((FORALL (k : INT): ((mem(int, t2tb5(k), t2tb6(s2))) => (0 < (f[k]))))
  => (0 < iproduct(int, t2tb6(s2), t2tb7(f)))));

% iproduct_strict_pos
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((FORALL (k : uni):
   ((sort(a, k)) => ((mem(a, k, s2)) => (0 < tb2t5(infix_at(int, a, f, k))))))
  => (0 < iproduct(a, s2, f)))));

% ind_iproduct_strict_pos_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => (0 < (f[k])))) => (1 <= 
  ind_iproduct(f, i, j))));

fc20: ((ARRAY INT OF INT), INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, h : INT, a : INT): ((fc20(f, l,
  h)[a]) = (f[((h - (a + 1)) + l)])));

% ind_iproduct_left_right
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, k : INT, h : INT):
  (((l <= k) AND (k <= h)) => (ind_iproduct(f, l, k) = ind_iproduct(fc20(f,
  l, h), ((h - k) + l), h))));

% iterable_imult
  ASSERT (iterable(int, t2tb8(infix_as_closure)));

% int_minus_distr
  ASSERT (FORALL (a : INT, b : INT): ((- (a + b)) = ((- a) + (- b))));

% int_minus_eq
  ASSERT (FORALL (a : INT, b : INT): ((a = b) => ((- a) = (- b))));

fc21: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  fc21(f, t1)[b]) = (t1[(f[b])])));

% ind_iproduct_map_auto
  ASSERT
  (FORALL (i : INT, j : INT, f : (ARRAY INT OF INT),
  t1 : (ARRAY INT OF INT)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(i, j)), t2tb6(to_fset(i,
  j)))) => (ind_iproduct(t1, i, j) = ind_iproduct(fc21(f, t1), i, j))));

fc22: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  fc22(f, t1)[b]) = (t1[(f[b])])));

% ind_iproduct_map
  ASSERT
  (FORALL (i : INT, j : INT, k : INT, l : INT, f : (ARRAY INT OF INT),
  t1 : (ARRAY INT OF INT)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(i, j)), t2tb6(to_fset(k,
  l)))) => (ind_iproduct(t1, k, l) = ind_iproduct(fc22(f, t1), i, j))));

% ind_iproduct_trans
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, k : INT, j : INT):
  (((i <= k) AND (k <= j)) => (ind_iproduct(f, i, j) = (ind_iproduct(f, i,
  k) * ind_iproduct(f, k, j)))));

% ind_iproduct_inf
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT):
   (((i <= k) AND (k < j)) => ((0 <= (f[k])) AND ((f[k]) <= (g[k])))))
  => (ind_iproduct(f, i, j) <= ind_iproduct(g, i, j))));

choose_filter: (ty, uni, uni) -> uni;

% choose_filter_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(a, choose_filter(a, x, x1)))));

% choose_filter'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni):
  ((EXISTS (e : uni):
   ((mem(a, e, s2)) AND (tb2t2(infix_at(bool, a, p, e)) = 0bin1)))
  => (IF (tb2t2(infix_at(bool, a, p, choose(a, s2))) = 0bin1) THEN (
     choose_filter(a, s2, p) = choose(a, s2)) ELSE (choose_filter(a, s2,
     p) = choose_filter(a, remove(a, choose(a, s2), s2), p)) ENDIF))));

% choose_filter'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni):
  ((EXISTS (e : uni):
   ((mem(a, e, s2)) AND (tb2t2(infix_at(bool, a, p, e)) = 0bin1)))
  => ((tb2t2(infix_at(bool, a, p, choose_filter(a, s2, p))) = 0bin1)
     AND (mem(a, choose_filter(a, s2, p), s2))))));

my_filter: (ty, uni, uni) -> uni;

% my_filter_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), my_filter(a, x, x1)))));

% my_filter'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni):
  (IF (cardinal(a, s2) = 0) THEN (my_filter(a, s2, p) = empty(a))
  ELSE (IF (tb2t2(infix_at(bool, a, p, choose(a, s2))) = 0bin1) THEN (
       my_filter(a, s2, p) = add(a, choose(a, s2), my_filter(a, remove(a, 
       choose(a, s2), s2), p))) ELSE (my_filter(a, s2, p) = my_filter(a, 
       remove(a, choose(a, s2), s2), p)) ENDIF) ENDIF)));

% my_filter'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni):
  ((FORALL (e : uni):
   ((mem(a, e, s2))
   => ((tb2t2(infix_at(bool, a, p, e)) = 0bin1) <=> (mem(a, e, my_filter(a,
      s2, p))))))
  AND ((FORALL (e : uni):
       ((mem(a, e, my_filter(a, s2, p))) => (mem(a, e, s2))))
      AND ((0 <= cardinal(a, my_filter(a, s2, p))) AND (cardinal(a, 
          my_filter(a, s2, p)) <= cardinal(a, s2)))))));

my_filter_int: (INT, INT, (ARRAY INT OF BITVECTOR(1))) -> set_int;

% my_filter_int'def
  ASSERT
  (FORALL (i : INT, j : INT, p : (ARRAY INT OF BITVECTOR(1))):
  (IF (j <= i) THEN (my_filter_int(i, j, p) = tb2t6(empty(int)))
  ELSE (IF (tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(i))) = 0bin1) THEN (
       my_filter_int(i, j, p) = tb2t6(add(int, t2tb5(i), t2tb6(
       my_filter_int((i + 1), j, p))))) ELSE (my_filter_int(i, j, p) = 
       my_filter_int((i + 1), j, p)) ENDIF) ENDIF));

% my_filter_int'spec
  ASSERT
  (FORALL (i : INT, j : INT, p : (ARRAY INT OF BITVECTOR(1))):
  ((my_filter_int(i, j, p) = tb2t6(my_filter(int, t2tb6(to_fset(i, j)), 
  t2tb9(p))))
  AND ((FORALL (e : INT):
       (((i <= e) AND (e < j))
       => ((tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(e))) = 0bin1)
          <=> (mem(int, t2tb5(e), t2tb6(my_filter_int(i, j, p)))))))
      AND ((FORALL (e : INT):
           ((mem(int, t2tb5(e), t2tb6(my_filter_int(i, j, p))))
           => ((i <= e) AND (e < j))))
          AND ((i <= j)
              => ((0 <= cardinal(int, t2tb6(my_filter_int(i, j, p)))) AND (
                 cardinal(int, t2tb6(my_filter_int(i, j, p))) <= (j - i))))))));

% in_my_filter
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni, e : uni):
  ((mem(a, e, s2))
  => ((tb2t2(infix_at(bool, a, p, e)) = 0bin1) => (mem(a, e, my_filter(a, s2,
     p)))))));

% not_in_my_filter_set
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni, e : uni):
  ((NOT (mem(a, e, s2))) => (NOT (mem(a, e, my_filter(a, s2, p)))))));

% not_in_my_filter_filter
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni, e : uni):
  ((NOT (tb2t2(infix_at(bool, a, p, e)) = 0bin1))
  => (NOT (mem(a, e, my_filter(a, s2, p)))))));

% in_my_filter_set
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni, e : uni):
  ((mem(a, e, my_filter(a, s2, p))) => (mem(a, e, s2)))));

% in_my_filter_filter
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p : uni, e : uni):
  ((mem(a, e, my_filter(a, s2, p))) => (tb2t2(infix_at(bool, a, p,
  e)) = 0bin1))));

% my_filter_inter
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p1 : uni, p2 : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2))
      => ((tb2t2(infix_at(bool, a, p1, e)) = 0bin1)
         => (NOT (tb2t2(infix_at(bool, a, p2, e)) = 0bin1))))))
  => (inter(a, my_filter(a, s2, p1), my_filter(a, s2, p2)) = empty(a)))));

% my_filter_union
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, p1 : uni, p2 : uni):
  ((sort(set(a), s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2))
         => ((NOT (tb2t2(infix_at(bool, a, p1, e)) = 0bin1)) => (tb2t2(
            infix_at(bool, a, p2, e)) = 0bin1)))))
     => (union(a, my_filter(a, s2, p1), my_filter(a, s2, p2)) = s2)))));

% ind_iproduct_sup_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j)
  => ((FORALL (k : INT): (((i <= k) AND (k < j)) => (1 <= (f[k]))))
     => ((EXISTS (k : INT): (((i <= k) AND (k < j)) AND (NOT ((f[k]) = 1))))
        => (1 < ind_iproduct(f, i, j))))));

% comp_trans_equal_strict
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a <= b) => ((b < c) => (a < c))));

% transitive_inf_leq_int
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a < b) => ((b <= c) => (a < c))));

% transitive_inf_int
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((a < b) => ((b < c) => (a < c))));

% compeq_trans_sum
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((b <= c) => ((a + b) <= (a + c))));

% compeq_trans_sum_zero
  ASSERT (FORALL (a : INT, b : INT): ((0 <= b) => (a <= (a + b))));

% comp_trans_sum
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): ((b < c) => ((a + b) < (a + c))));

% comp_trans_mult
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  (((0 <= a) AND (a < b)) => ((0 < c) => ((a * c) < (b * c)))));

% minus_out_int
  ASSERT (FORALL (a : INT, b : INT): (((- a) * b) = (- (a * b))));

ind_isum: ((ARRAY INT OF INT), INT, INT) -> INT;

% ind_isum'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  (IF (j <= i) THEN (ind_isum(f, i, j) = 0)
  ELSE (IF (j = (i + 1)) THEN (ind_isum(f, i, j) = (f[i])) ELSE (ind_isum(f,
       i, j) = ((f[i]) + ind_isum(f, (i + 1), j))) ENDIF) ENDIF));

% ind_isum'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT): (ind_isum(f, i, j) = 
  tb2t5(int_iterate(int, t2tb8(infix_pl_closure), t2tb7(f), i, j))));

% ind_isum_empty
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((j <= i) => (ind_isum(f, i, j) = 0)));

% ind_isum_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((j = (i + 1)) => (ind_isum(f, i, j) = (f[i]))));

% ind_isum_plus_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j) => (ind_isum(f, i, j) = ((f[i]) + ind_isum(f, (i + 1), j)))));

% ind_isum_to_isum
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j) => (ind_isum(f, i, j) = isum(int, t2tb6(to_fset(i, j)), 
  t2tb7(f)))));

fc735: (ARRAY INT OF (ARRAY INT OF INT));

% fc'def
  ASSERT
  (FORALL (y0 : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(fc735), t2tb5(y0)))[y1]) = y0));

% ind_isum_const
  ASSERT
  (FORALL (k : INT, i : INT, j : INT):
  ((i < j) => (ind_isum(tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(fc735), t2tb5(k))), i, j) = (k * (j - i)))));

% ind_isum_null
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j)
  => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = 0))) => (
     ind_isum(f, i, j) = 0))));

% ind_isum_right_extension
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i <= j) => (ind_isum(f, i, (j + 1)) = (ind_isum(f, i, j) + (f[j])))));

% ind_isum_re
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j) => (ind_isum(f, i, j) = (ind_isum(f, i, (j - 1)) + (f[(j - 1)])))));

% ind_isum_re_null
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j)
  => (((f[j]) = 0) => (ind_isum(f, i, (j + 1)) = ind_isum(f, i, j)))));

% ind_isum_null_but_maybe_one_elt
  ASSERT
  (FORALL (l : INT, h : INT, t1 : (ARRAY INT OF INT), e : INT):
  (((l <= e) AND (e < h))
  => ((FORALL (a : INT):
      (((l <= a) AND (a < h)) => ((NOT (a = e)) => ((t1[a]) = 0))))
     => (ind_isum(t1, l, h) = (t1[e])))));

% ind_isum_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k])))) => (
  ind_isum(f, i, j) = ind_isum(g, i, j))));

fc24: ((ARRAY INT OF INT), (ARRAY INT OF INT),
  (ARRAY INT OF BITVECTOR(1))) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT),
  p : (ARRAY INT OF BITVECTOR(1)), k : INT): ((fc24(f, g,
  p)[k]) = (IF (tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(k))) = 0bin1)
           THEN (f[k]) ELSE (g[k]) ENDIF)));

% ind_isum_to_guard
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT),
  p : (ARRAY INT OF BITVECTOR(1)), i : INT, j : INT):
  ((FORALL (k : INT):
   (((i <= k) AND (k < j)) => (tb2t2(infix_at(bool, int, t2tb9(p), 
   t2tb5(k))) = 0bin1)))
  => (ind_isum(fc24(f, g, p), i, j) = ind_isum(f, i, j))));

fc25: ((ARRAY INT OF INT), (ARRAY INT OF INT),
  (ARRAY INT OF BITVECTOR(1))) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT),
  p : (ARRAY INT OF BITVECTOR(1)), k : INT): ((fc25(f, g,
  p)[k]) = (IF (tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(k))) = 0bin1)
           THEN (g[k]) ELSE (f[k]) ENDIF)));

% ind_isum_no_guard
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT),
  p : (ARRAY INT OF BITVECTOR(1)), i : INT, j : INT):
  ((FORALL (k : INT):
   (((i <= k) AND (k < j))
   => (NOT (tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(k))) = 0bin1))))
  => (ind_isum(fc25(f, g, p), i, j) = ind_isum(f, i, j))));

% ind_isum_eq_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, i1 : INT,
  j : INT, j1 : INT):
  ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k]))))
  => ((i = i1) => ((j = j1) => (ind_isum(f, i, j) = ind_isum(g, i1, j1))))));

% ind_isum_func_const
  ASSERT
  (FORALL (k : INT, f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i <= j)
  => ((FORALL (l : INT): (((i <= l) AND (l < j)) => ((f[l]) = k))) => (
     ind_isum(f, i, j) = (k * (j - i))))));

% ind_isum_pos
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i <= j)
  => ((FORALL (k : INT): (((i <= k) AND (k < j)) => (0 <= (f[k])))) => (0 <= 
     ind_isum(f, i, j)))));

fc26: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  fc26(f, t1)[b]) = (t1[(f[b])])));

% ind_isum_map_auto
  ASSERT
  (FORALL (i : INT, j : INT, f : (ARRAY INT OF INT),
  t1 : (ARRAY INT OF INT)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(i, j)), t2tb6(to_fset(i,
  j)))) => (ind_isum(t1, i, j) = ind_isum(fc26(f, t1), i, j))));

fc27: (INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, j : INT, f : (ARRAY INT OF INT), k : INT): ((fc27(i, j,
  f)[k]) = (f[(((j - k) - 1) + i)])));

% ind_isum_rev
  ASSERT
  (FORALL (i : INT, j : INT, f : (ARRAY INT OF INT)): (ind_isum(f, i, j) = 
  ind_isum(fc27(i, j, f), i, j)));

fc28: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  fc28(f, t1)[b]) = (t1[(f[b])])));

% ind_isum_map
  ASSERT
  (FORALL (i : INT, j : INT, k : INT, l : INT, f : (ARRAY INT OF INT),
  t1 : (ARRAY INT OF INT)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(i, j)), t2tb6(to_fset(k,
  l)))) => (ind_isum(t1, k, l) = ind_isum(fc28(f, t1), i, j))));

fc29: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  fc29(f, t1)[b]) = (t1[(f[b])])));

% ind_isum_map_auto_bij
  ASSERT
  (FORALL (i : INT, j : INT, f : (ARRAY INT OF INT),
  t1 : (ARRAY INT OF INT)):
  ((FORALL (e : INT):
   (((i <= e) AND (e < j)) => ((i <= (f[e])) AND ((f[e]) < j))))
  => ((FORALL (e : INT, eqt : INT):
      (((i <= e) AND (e < j))
      => (((i <= eqt) AND (eqt < j))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
     => ((FORALL (eqt : INT):
         (((i <= eqt) AND (eqt < j))
         => (EXISTS (e : INT): (((i <= e) AND (e < j)) AND ((f[e]) = eqt)))))
        => (ind_isum(t1, i, j) = ind_isum(fc29(f, t1), i, j))))));

fc30: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF INT), b : INT): ((
  fc30(f, t1)[b]) = (t1[(f[b])])));

% ind_isum_map_bij
  ASSERT
  (FORALL (i : INT, j : INT, k : INT, l : INT, f : (ARRAY INT OF INT),
  t1 : (ARRAY INT OF INT)):
  ((FORALL (e : INT):
   (((i <= e) AND (e < j)) => ((k <= (f[e])) AND ((f[e]) < l))))
  => ((FORALL (e : INT, eqt : INT):
      (((i <= e) AND (e < j))
      => (((i <= eqt) AND (eqt < j))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
     => ((FORALL (eqt : INT):
         (((k <= eqt) AND (eqt < l))
         => (EXISTS (e : INT): (((i <= e) AND (e < j)) AND ((f[e]) = eqt)))))
        => (ind_isum(t1, k, l) = ind_isum(fc30(f, t1), i, j))))));

fc31: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), k : INT, b : INT): ((fc31(f,
  k)[b]) = (f[(b + k)])));

% ind_isum_transl
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, k : INT): (ind_isum(f,
  i, j) = ind_isum(fc31(f, k), (i - k), (j - k))));

fc32: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), b : INT): ((fc32(f)[b]) = (f[(b - 1)])));

% ind_isum_transl_plus_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT): (ind_isum(f, i, j) = 
  ind_isum(fc32(f), (i + 1), (j + 1))));

fc33: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), b : INT): ((fc33(f)[b]) = (f[(b + 1)])));

% ind_isum_transl_minus_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT): (ind_isum(f, i, j) = 
  ind_isum(fc33(f), (i - 1), (j - 1))));

fc34: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : INT, i : INT): ((fc34(f,
  a)[i]) = (a * (f[i]))));

% ind_isum_scal
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, a : INT):
  ((i <= j) => (ind_isum(fc34(f, a), i, j) = (a * ind_isum(f, i, j)))));

fc35: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((fc35(f)[i]) = (- (f[i]))));

% minus_ind_isum
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i <= j) => ((- ind_isum(f, i, j)) = ind_isum(fc35(f), i, j))));

fc36: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((fc36(f)[i]) = (- (f[i]))));

% minus_ind_isum_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  ((i <= j) => (ind_isum(fc36(f), i, j) = (- ind_isum(f, i, j)))));

fc37: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : INT, i : INT): ((fc37(f,
  a)[i]) = (a * (f[i]))));

% ind_isum_scal_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, a : INT):
  ((i <= j) => ((a * ind_isum(f, i, j)) = ind_isum(fc37(f, a), i, j))));

fc38: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : INT, i : INT): ((fc38(f,
  a)[i]) = ((f[i]) * a)));

% ind_isum_scal_rev_right
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, a : INT):
  ((i <= j) => ((ind_isum(f, i, j) * a) = ind_isum(fc38(f, a), i, j))));

fc39: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : INT, i : INT): ((fc39(f,
  a)[i]) = ((f[i]) * a)));

% ind_isum_scal_right
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, a : INT):
  ((i <= j) => (ind_isum(fc39(f, a), i, j) = (ind_isum(f, i, j) * a))));

% ind_isum_bound
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, j : INT):
  ((i < j)
  => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) < (g[k])))) => (
     ind_isum(f, i, j) < ind_isum(g, i, j)))));

% ind_isum_bound_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, j : INT):
  ((i <= j)
  => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) <= (g[k])))) => (
     ind_isum(f, i, j) <= ind_isum(g, i, j)))));

fc40: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : INT, i : INT): ((fc40(f,
  a)[i]) = (a * (f[i]))));

% ind_isum_scal_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT):
  (FORALL (a : INT):
  (((i <= a) AND (a < j)) => (ind_isum(fc40(f, a), i, j) = (a * ind_isum(f,
  i, j))))));

% ind_isum_trans
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, k : INT, j : INT):
  (((i <= k) AND (k <= j)) => (ind_isum(f, i, j) = (ind_isum(f, i, k) + 
  ind_isum(f, k, j)))));

power_pre: (INT, INT) -> INT;

% power_pre'def
  ASSERT
  (FORALL (e : INT, i : INT):
  ((0 <= i)
  => (IF (i = 0) THEN (power_pre(e, i) = 1) ELSE (power_pre(e, i) = (e * 
     power_pre(e, (i - 1)))) ENDIF)));

power: (INT, INT) -> INT;

% power'def
  ASSERT
  (FORALL (e : INT, i : INT):
  (IF (i < 0) THEN (power(e, i) = 0) ELSE (power(e, i) = power_pre(e,
  i)) ENDIF));

% Power_zero
  ASSERT (FORALL (i : INT): (power(i, 0) = 1));

% Power_one
  ASSERT (FORALL (i : INT): (power(i, 1) = i));

% power_plus_one
  ASSERT
  (FORALL (i : INT, x : INT):
  ((0 <= x) => (power(i, (x + 1)) = (power(i, x) * i))));

% power_sum
  ASSERT
  (FORALL (i : INT, x : INT, y : INT):
  ((0 <= x)
  => ((0 <= y) => (power(i, (x + y)) = (power(i, x) * power(i, y))))));

% power_mult
  ASSERT
  (FORALL (i : INT, x : INT, y : INT):
  ((0 <= x) => ((0 <= y) => (power(i, (x * y)) = power(power(i, x), y)))));

% Power_sum
  ASSERT
  (FORALL (x : INT, y : INT, i : INT):
  ((0 <= x)
  => ((0 <= y) => (power(i, (x + y)) = (power(i, x) * power(i, y))))));

% Power_mult
  ASSERT
  (FORALL (x : INT, y : INT, i : INT):
  ((0 <= x) => ((0 <= y) => (power(i, (x * y)) = power(power(i, x), y)))));

fc736: (ARRAY INT OF (ARRAY INT OF INT));

% fc'def
  ASSERT
  (FORALL (y0 : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(fc736), t2tb5(y0)))[y1]) = y0));

% power_to_ind_iproduct
  ASSERT
  (FORALL (e : INT, i : INT):
  ((0 <= i) => (power(e, i) = ind_iproduct(tb2t7(infix_at(infix_mngt(int,
  int), int, t2tb8(fc736), t2tb5(e))), 0, i))));

fc737: (ARRAY INT OF (ARRAY INT OF INT));

% fc'def
  ASSERT
  (FORALL (y0 : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(fc737), t2tb5(y0)))[y1]) = y0));

% power_transl
  ASSERT
  (FORALL (e : INT, k : INT, i : INT):
  ((0 <= i) => (power(e, i) = ind_iproduct(tb2t7(infix_at(infix_mngt(int,
  int), int, t2tb8(fc737), t2tb5(e))), k, (k + i)))));

fc738: (ARRAY INT OF (ARRAY INT OF INT));

% fc'def
  ASSERT
  (FORALL (y0 : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(fc738), t2tb5(y0)))[y1]) = y0));

% ind_iproduct_to_power
  ASSERT
  (FORALL (e : INT, i : INT, j : INT):
  (((0 <= i) AND (i <= j)) => (ind_iproduct(tb2t7(infix_at(infix_mngt(int,
  int), int, t2tb8(fc738), t2tb5(e))), i, j) = power(e, (j - i)))));

fc739: (ARRAY INT OF (ARRAY INT OF INT));

% fc'def
  ASSERT
  (FORALL (y0 : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(fc739), t2tb5(y0)))[y1]) = y0));

% ind_iproduct_to_power_gen
  ASSERT
  (FORALL (e : INT):
  (FORALL (i : INT, j : INT):
  (((0 <= i) AND (i <= j)) => (ind_iproduct(tb2t7(infix_at(infix_mngt(int,
  int), int, t2tb8(fc739), t2tb5(e))), i, j) = power(e, (j - i))))));

% power_sum_rev
  ASSERT
  (FORALL (x : INT, n : INT, m : INT):
  ((0 <= n)
  => ((0 <= m) => ((power(x, n) * power(x, m)) = power(x, (n + m))))));

% power_eq
  ASSERT
  (FORALL (x : INT, n : INT, m : INT):
  ((n = m) => (power(x, n) = power(x, m))));

% power_eq_gen
  ASSERT
  (FORALL (x : INT, y : INT, n : INT, m : INT):
  ((n = m) => ((x = y) => (power(x, n) = power(y, m)))));

fc740: (ARRAY INT OF INT);

% fc'def
  ASSERT (FORALL (k : INT): ((fc740[k]) = power(2, (k + 1))));

% power_2_sum
  ASSERT
  (FORALL (i : INT):
  ((1 <= i) => (ind_isum(fc740, 0, i) = (power(2, (i + 1)) - 2))));

fc741: (ARRAY INT OF INT);

% fc'def
  ASSERT (FORALL (k : INT): ((fc741[k]) = power(2, (k + 1))));

% power_decomp
  ASSERT
  (FORALL (i : INT):
  ((1 <= i) => (ind_isum(fc741, 0, i) < power(2, (i + 1)))));

fc742: (INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, k : INT): ((
  fc742(i)[k]) = (IF ((1 <= k) AND (k < (i + 1))) THEN power(2, (k - 1))
                 ELSE 0 ENDIF)));

% power_decomp_minus_one
  ASSERT
  (FORALL (i : INT):
  ((1 <= i) => (ind_isum(fc742(i), 1, i) < power(2, (i - 1)))));

power_closure: (ARRAY INT OF (ARRAY INT OF INT));

% power_closure_def
  ASSERT
  (FORALL (y : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(power_closure), t2tb5(y)))[y1]) = power(y, y1)));

% power_decomp_
  ASSERT
  (FORALL (i : INT):
  ((1 <= i) => (ind_isum(tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(power_closure), t2tb5(2))), 0, i) < power(2, i))));

fc743: (ARRAY INT OF INT);

% fc'def
  ASSERT (FORALL (k : INT): ((fc743[k]) = power(2, (k + 1))));

% power_decomp_one
  ASSERT
  (FORALL (i : INT):
  ((1 <= i) => (ind_isum(fc743, 1, i) < power(2, (i + 1)))));

% power_decomp_one_
  ASSERT
  (FORALL (i : INT):
  ((1 <= i) => (ind_isum(tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(power_closure), t2tb5(2))), 1, i) < power(2, i))));

% growing_mult
  ASSERT
  (FORALL (n : INT, m : INT): ((0 <= n) => ((1 <= m) => (n <= (n * m)))));

% strict_growing_mult
  ASSERT
  (FORALL (n : INT, m : INT): ((1 < n) => ((1 < m) => (n < (n * m)))));

% init_exp
  ASSERT
  (FORALL (k : INT):
  ((power(k, 0) = 1) AND ((power(k, 1) = k) AND (power(k, 2) = (k * k)))));

% positive_int_exp
  ASSERT
  (FORALL (k : INT, n : INT):
  ((1 <= k)
  => ((0 <= n)
     => ((1 <= power(k, n))
        AND ((0 < power(k, n)) AND (power(k, n) <= power(k, (n + 1))))))));

% strict_positive_int_exp
  ASSERT
  (FORALL (k : INT, n : INT):
  ((1 < k)
  => ((0 < n)
     => ((1 < power(k, n))
        AND ((power(k, (n - 1)) < power(k, n)) AND (power(k, n) < power(k,
            (n + 1))))))));

abs: (INT) -> INT;

% abs'def
  ASSERT
  (FORALL (x : INT):
  (IF (0 <= x) THEN (abs(x) = x) ELSE (abs(x) = (- x)) ENDIF));

% Abs_le
  ASSERT
  (FORALL (x : INT, y : INT):
  ((abs(x) <= y) <=> (((- y) <= x) AND (x <= y))));

% Abs_pos
  ASSERT (FORALL (x : INT): (0 <= abs(x)));

div: (INT, INT) -> INT;

mod: (INT, INT) -> INT;

% Div_mod
  ASSERT
  (FORALL (x : INT, y : INT):
  ((NOT (y = 0)) => (x = ((y * div(x, y)) + mod(x, y)))));

% Mod_bound
  ASSERT
  (FORALL (x : INT, y : INT):
  ((NOT (y = 0)) => ((0 <= mod(x, y)) AND (mod(x, y) < abs(y)))));

% Div_unique
  ASSERT
  (FORALL (x : INT, y : INT, q : INT):
  ((0 < y) => ((((q * y) <= x) AND (x < ((q * y) + y))) => (div(x, y) = q))));

% Div_bound
  ASSERT
  (FORALL (x : INT, y : INT):
  (((0 <= x) AND (0 < y)) => ((0 <= div(x, y)) AND (div(x, y) <= x))));

% Mod_1
  ASSERT (FORALL (x : INT): (mod(x, 1) = 0));

% Div_1
  ASSERT (FORALL (x : INT): (div(x, 1) = x));

% Div_inf
  ASSERT
  (FORALL (x : INT, y : INT): (((0 <= x) AND (x < y)) => (div(x, y) = 0)));

% Div_inf_neg
  ASSERT
  (FORALL (x : INT, y : INT):
  (((0 < x) AND (x <= y)) => (div((- x), y) = (- 1))));

% Mod_0
  ASSERT (FORALL (y : INT): ((NOT (y = 0)) => (mod(0, y) = 0)));

% Div_1_left
  ASSERT (FORALL (y : INT): ((1 < y) => (div(1, y) = 0)));

% Div_minus1_left
  ASSERT (FORALL (y : INT): ((1 < y) => (div((- 1), y) = (- 1))));

% Mod_1_left
  ASSERT (FORALL (y : INT): ((1 < y) => (mod(1, y) = 1)));

% Mod_minus1_left
  ASSERT (FORALL (y : INT): ((1 < y) => (mod((- 1), y) = (y - 1))));

% Div_mult
  ASSERT
  (FORALL (x : INT, y : INT, z : INT):PATTERN (div(((x * y) + z), x)): 
  ((0 < x) => (div(((x * y) + z), x) = (y + div(z, x)))));

% Mod_mult
  ASSERT
  (FORALL (x : INT, y : INT, z : INT):PATTERN (mod(((x * y) + z), x)): 
  ((0 < x) => (mod(((x * y) + z), x) = mod(z, x))));

% power_minus_one
  ASSERT
  (FORALL (i : INT):
  ((0 <= i)
  => (((mod(i, 2) = 0) => (power((- 1), i) = 1))
     AND ((mod(i, 2) = 1) => (power((- 1), i) = (- 1))))));

% growing_exp
  ASSERT
  (FORALL (k : INT, m : INT, n : INT):
  ((1 <= k) => (((0 <= m) AND (m <= n)) => (power(k, m) <= power(k, n)))));

% strict_growing_exp
  ASSERT
  (FORALL (k : INT, m : INT, n : INT):
  ((1 < k) => (((0 <= m) AND (m < n)) => (power(k, m) < power(k, n)))));

% unicity_exp
  ASSERT
  (FORALL (k : INT, m : INT, n : INT):
  ((1 < k)
  => ((0 <= m) => ((0 <= n) => ((power(k, m) = power(k, n)) <=> (m = n))))));

% bounded_sum_exp
  ASSERT
  (FORALL (i : INT, j : INT, m : INT, n : INT):
  ((0 <= m)
  => ((0 <= n)
     => (((0 <= i) AND (i < power(2, m)))
        => (((0 <= j) AND (j < power(2, n))) => (((i * power(2, n)) + j) < 
           power(2, (m + n))))))));

% Power_pos
  ASSERT (FORALL (i : INT): ((0 <= i) => (0 < power(i, 0))));

% Power_pos_gen
  ASSERT
  (FORALL (i : INT, j : INT): ((0 < i) => ((0 <= j) => (0 < power(i, j)))));

% power_two
  ASSERT (FORALL (x : INT): ((0 <= x) => (power(x, 2) = (x * x))));

% power_plus_one_two
  ASSERT
  (FORALL (x : INT):
  ((0 <= x) => (power(2, (x + 1)) = (power(2, x) + power(2, x)))));

% growing_right_power
  ASSERT
  (FORALL (a : INT, b : INT, i : INT):
  ((0 <= i) => (((0 <= a) AND (a <= b)) => (power(a, i) <= power(b, i)))));

% power_of_one
  ASSERT
  (FORALL (a : INT, b : INT): ((0 <= b) => ((a = 1) => (power(a, b) = 1))));

% bound_power
  ASSERT
  (FORALL (i : INT, a : INT, k : INT, n : INT):
  ((0 < a)
  => (((0 < k) AND (k <= n))
     => (((0 <= i) AND (i < power(a, n))) => (div(i, power(a, (n - k))) < 
        power(a, k))))));

% power_inf
  ASSERT
  (FORALL (a : INT, n : INT, nqt : INT):
  ((1 < a) => (((0 < n) AND (n < nqt)) => (power(a, n) < power(a, nqt)))));

% power_leq
  ASSERT
  (FORALL (a : INT, n : INT, nqt : INT):
  ((0 <= a) => (((0 < n) AND (n <= nqt)) => (power(a, n) <= power(a, nqt)))));

% power_rises
  ASSERT
  (FORALL (a : INT, n : INT): ((1 < a) => ((1 < n) => (a < power(a, n)))));

% int_expo_rises
  ASSERT
  (FORALL (a : INT, n : INT): ((1 < a) => ((1 <= n) => (n < power(a, n)))));

% bound_power_2
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, (n + 1)))) => (div(i, power(2, n)) < 2))));

polysquare: (INT, INT, INT, INT) -> INT;

% polysquare'def
  ASSERT
  (FORALL (n : INT, a2 : INT, a1 : INT, a0 : INT):
  ((0 < n)
  => ((0 <= a2)
     => ((0 <= a1)
        => ((0 <= a0) => (polysquare(n, a2, a1, a0) = (((a2 * power(n,
           2)) + (a1 * n)) + a0)))))));

% polysquare'spec
  ASSERT
  (FORALL (n : INT, a2 : INT, a1 : INT, a0 : INT):
  ((0 < n)
  => ((0 <= a2)
     => ((0 <= a1) => ((0 <= a0) => (0 <= polysquare(n, a2, a1, a0)))))));

% polysquare_leq_trans
  ASSERT
  (FORALL (n : INT, a2 : INT, a1 : INT, a0 : INT, b2 : INT, b1 : INT,
  b0 : INT, pa : INT, pb : INT, ps : INT):
  ((0 < n)
  => ((0 <= a2)
     => ((0 <= a1)
        => ((0 <= a0)
           => ((0 <= b2)
              => ((0 <= b1)
                 => ((0 <= b0)
                    => ((pa <= polysquare(n, a2, a1, a0))
                       => ((pb <= polysquare(n, b2, b1, b0))
                          => ((ps <= (pa + pb)) => (ps <= polysquare(n,
                             (a2 + b2), (a1 + b1), (a0 + b0))))))))))))));

% polysquare_leq_trans_sc
  ASSERT
  (FORALL (n : INT, a2 : INT, a1 : INT, a0 : INT, b2 : INT, b1 : INT,
  b0 : INT, pa : INT, sc : INT, ps : INT):
  ((0 < n)
  => ((0 <= a2)
     => ((0 <= a1)
        => ((0 <= a0)
           => ((0 <= sc)
              => (((sc * a2) <= b2)
                 => (((sc * a1) <= b1)
                    => (((sc * a0) <= b0)
                       => ((pa <= polysquare(n, a2, a1, a0))
                          => ((ps <= (sc * pa)) => (ps <= polysquare(n, b2,
                             b1, b0)))))))))))));

% polysquare_update
  ASSERT
  (FORALL (na : INT, nb : INT, a2 : INT, a1 : INT, a0 : INT, pa : INT):
  (((0 < na) AND (na <= nb))
  => ((0 <= a2)
     => ((0 <= a1)
        => ((0 <= a0)
           => ((pa <= polysquare(na, a2, a1, a0)) => (pa <= polysquare(nb,
              a2, a1, a0))))))));

% add_im_re
  ASSERT
  (FORALL (i : complex, j : complex):
  ((infix_pldt(i, j) = infix_pldt(infix_pldt(t_real_part(i), t_real_part(j)), 
  infix_asdt(im, infix_pldt(t_im_part(i), t_im_part(j)))))
  AND ((t_real_part(infix_pldt(i, j)) = infix_pldt(t_real_part(i), 
      t_real_part(j))) AND (t_im_part(infix_pldt(i, j)) = infix_pldt(
      t_im_part(i), t_im_part(j))))));

% add_real_part
  ASSERT
  (FORALL (i : complex, j : complex): (infix_pldt(t_real_part(i), 
  t_real_part(j)) = t_real_part(infix_pldt(i, j))));

% add_im_part
  ASSERT
  (FORALL (i : complex, j : complex): (infix_pldt(t_im_part(i), 
  t_im_part(j)) = t_im_part(infix_pldt(i, j))));

% add_real_part_rev
  ASSERT
  (FORALL (i : complex, j : complex): (t_real_part(infix_pldt(i, j)) = 
  infix_pldt(t_real_part(i), t_real_part(j))));

% add_im_part_rev
  ASSERT
  (FORALL (i : complex, j : complex): (t_im_part(infix_pldt(i, j)) = 
  infix_pldt(t_im_part(i), t_im_part(j))));

% mult_distr_add_r
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(a, 
  infix_pldt(b, c)) = infix_pldt(infix_asdt(a, b), infix_asdt(a, c))));

% add_add_minus
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_pldt(a, 
  infix_mndt(b, c)) = infix_mndt(infix_pldt(a, b), c)));

% mult_distr_minus
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(a, 
  infix_mndt(b, c)) = infix_mndt(infix_asdt(a, b), infix_asdt(a, c))));

% minus_out
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(prefix_mndt(a), b) = 
  prefix_mndt(infix_asdt(a, b))));

% mult_distr_add_r_rev
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_pldt(infix_asdt(a,
  b), infix_asdt(a, c)) = infix_asdt(a, infix_pldt(b, c))));

% mult_distr_minus_rev
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_mndt(infix_asdt(a,
  b), infix_asdt(a, c)) = infix_asdt(a, infix_mndt(b, c))));

% div_distr_add
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (a = c_zero)) => (infix_sldt(infix_pldt(b, c), a) = infix_pldt(
  infix_sldt(b, a), infix_sldt(c, a)))));

% div_distr_minus
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (a = c_zero)) => (infix_sldt(infix_mndt(b, c), a) = infix_mndt(
  infix_sldt(b, a), infix_sldt(c, a)))));

% div_distr_add_rev
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (a = c_zero)) => (infix_pldt(infix_sldt(b, a), infix_sldt(c, a)) = 
  infix_sldt(infix_pldt(b, c), a))));

% div_distr_minus_rev
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((NOT (a = c_zero)) => (infix_mndt(infix_sldt(b, a), infix_sldt(c, a)) = 
  infix_sldt(infix_mndt(b, c), a))));

% mult_distr_add_l
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(infix_pldt(b,
  c), a) = infix_pldt(infix_asdt(a, b), infix_asdt(a, c))));

% mult_distr_add_l_rev
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_pldt(infix_asdt(b,
  a), infix_asdt(c, a)) = infix_asdt(infix_pldt(b, c), a)));

% mult_distr_minus_r
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(a, 
  infix_mndt(b, c)) = infix_mndt(infix_asdt(a, b), infix_asdt(a, c))));

% mult_distr_minus_ll
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(infix_pldt(
  prefix_mndt(b), c), a) = infix_pldt(infix_asdt(prefix_mndt(a), b), 
  infix_asdt(a, c))));

% mult_distr_minus_ri
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(infix_mndt(b,
  c), a) = infix_mndt(infix_asdt(a, b), infix_asdt(a, c))));

% minus_distr_op
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_mndt(a, 
  infix_pldt(b, c)) = infix_mndt(infix_mndt(a, b), c)));

% mult_distr_minus_l
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(infix_mndt(b,
  c), a) = infix_mndt(infix_asdt(a, b), infix_asdt(a, c))));

% assoc_right
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_pldt(a, 
  infix_pldt(b, c)) = infix_pldt(infix_pldt(a, b), c)));

% assoc_right_mult
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_asdt(a, 
  infix_asdt(b, c)) = infix_asdt(infix_asdt(a, b), c)));

% minus_elim
  ASSERT
  (FORALL (a : complex, b : complex): (infix_mndt(a, b) = infix_pldt(a, 
  prefix_mndt(b))));

% minus_eq_t
  ASSERT
  (FORALL (a : complex, b : complex, aqt : complex, bqt : complex):
  ((a = aqt) => ((b = bqt) => (infix_mndt(a, b) = infix_mndt(aqt, bqt)))));

% minus_distr_elim
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_mndt(a, 
  infix_pldt(b, c)) = infix_pldt(infix_pldt(a, prefix_mndt(b)), 
  prefix_mndt(c))));

% plus_minus_distr_elim
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_pldt(a, 
  prefix_mndt(infix_pldt(b, c))) = infix_pldt(infix_pldt(a, prefix_mndt(b)), 
  prefix_mndt(c))));

% def_by_minus
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((x = infix_mndt(y, z)) => (y = infix_pldt(x, z))));

% switch
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_pldt(infix_pldt(a,
  b), c) = infix_pldt(infix_pldt(a, c), b)));

% meet_a_c
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(a,
  c), b), d)));

% meet_a_d
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(a,
  d), b), c)));

% meet_b_c
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(b,
  c), a), d)));

% meet_b_d
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(b,
  d), a), c)));

% meet_c_d
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(c,
  d), a), b)));

% inv_add
  ASSERT
  (FORALL (a : complex, b : complex): (infix_pldt(infix_pldt(a, 
  prefix_mndt(a)), b) = b));

% switch_m
  ASSERT
  (FORALL (a : complex, b : complex, c : complex): (infix_pldt(infix_pldt(a,
  b), c) = infix_pldt(infix_pldt(a, c), b)));

% meet_a_c_m
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(a,
  c), b), d)));

% meet_a_d_m
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(a,
  d), b), c)));

% meet_b_c_m
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(b,
  c), a), d)));

% meet_b_d_m
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(b,
  d), a), c)));

% meet_c_d_m
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex): (infix_pldt(
  infix_pldt(infix_pldt(a, b), c), d) = infix_pldt(infix_pldt(infix_pldt(c,
  d), a), b)));

% t_real_part_add
  ASSERT
  (FORALL (a : complex, b : complex): (t_real_part(infix_pldt(a, b)) = 
  infix_pldt(t_real_part(a), t_real_part(b))));

% t_real_part_subs
  ASSERT
  (FORALL (a : complex, b : complex): (t_real_part(infix_mndt(a, b)) = 
  infix_mndt(t_real_part(a), t_real_part(b))));

% t_im_part_add
  ASSERT
  (FORALL (a : complex, b : complex): (t_im_part(infix_pldt(a, b)) = 
  infix_pldt(t_im_part(a), t_im_part(b))));

% t_im_part_subs
  ASSERT
  (FORALL (a : complex, b : complex): (t_im_part(infix_mndt(a, b)) = 
  infix_mndt(t_im_part(a), t_im_part(b))));

% t_real_part_real
  ASSERT (FORALL (a : complex): ((real_(a)) => (t_real_part(a) = a)));

% t_real_part_im
  ASSERT
  (FORALL (a : complex): ((pure_im_(a)) => (t_real_part(a) = c_zero)));

% im_t_im_part_im
  ASSERT
  (FORALL (a : complex):
  ((pure_im_(a)) => (infix_asdt(im, t_im_part(a)) = a)));

% t_im_part_im
  ASSERT
  (FORALL (a : complex):
  ((pure_im_(a)) => (t_im_part(a) = infix_asdt(prefix_mndt(im), a))));

% t_im_part_real
  ASSERT (FORALL (a : complex): ((real_(a)) => (t_im_part(a) = c_zero)));

% a_div_b_mult_a
  ASSERT
  (FORALL (a : complex, b : complex, c : complex, d : complex):
  ((NOT (b = c_zero))
  => ((NOT (c = c_zero))
     => ((d = infix_sldt(c_one, b))
        => ((a = c) => (infix_asdt(infix_sldt(a, b), infix_sldt(c_one,
           c)) = d))))));

i_to_c: (INT) -> complex;

% i_to_c'def
  ASSERT (FORALL (i : INT): (i_to_c(i) = r_to_c(from_int(i))));

% i_to_c'spec
  ASSERT (FORALL (i : INT): (real_(i_to_c(i))));

% i_to_c_zero
  ASSERT (i_to_c(0) = c_zero);

% i_to_c_surj
  ASSERT
  (FORALL (i : INT, j : INT):
  ((NOT (i = j)) => (NOT (i_to_c(i) = i_to_c(j)))));

% i_to_c_eq
  ASSERT (FORALL (i : INT, j : INT): ((i = j) => (i_to_c(i) = i_to_c(j))));

% i_to_c_inf
  ASSERT
  (FORALL (i : INT, j : INT):
  ((i < j) => (infix_lsdt(i_to_c(i), i_to_c(j)))));

% i_to_c_nzero
  ASSERT (FORALL (i : INT): ((NOT (i = 0)) => (NOT (i_to_c(i) = c_zero))));

% i_to_c_one
  ASSERT (i_to_c(1) = c_one);

% i_to_c_add
  ASSERT
  (FORALL (i : INT, j : INT): (infix_pldt(i_to_c(i), i_to_c(j)) = 
  i_to_c((i + j))));

% i_to_c_add_rev
  ASSERT
  (FORALL (i : INT, j : INT): (i_to_c((i + j)) = infix_pldt(i_to_c(i), 
  i_to_c(j))));

% i_to_c_ttwo
  ASSERT (i_to_c(2) = infix_pldt(c_one, c_one));

% i_to_c_pos
  ASSERT (FORALL (a : INT): ((0 <= a) => (infix_lseqdt(c_zero, i_to_c(a)))));

% i_to_c_minus
  ASSERT (FORALL (a : INT): (i_to_c((- a)) = prefix_mndt(i_to_c(a))));

% i_to_c_strict_pos
  ASSERT (FORALL (a : INT): ((0 < a) => (infix_lsdt(c_zero, i_to_c(a)))));

% i_to_c_mult_pos
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= j) => (infix_asdt(i_to_c(i), i_to_c(j)) = i_to_c((i * j)))));

% i_to_c_mult
  ASSERT
  (FORALL (i : INT, j : INT): (infix_asdt(i_to_c(i), i_to_c(j)) = 
  i_to_c((i * j))));

% i_to_c_mult_rev
  ASSERT
  (FORALL (i : INT, j : INT): (i_to_c((i * j)) = infix_asdt(i_to_c(i), 
  i_to_c(j))));

% i_to_c_mult_assoc
  ASSERT
  (FORALL (x : complex, i : INT, j : INT): (infix_asdt(x, i_to_c((i * j))) = 
  infix_asdt(infix_asdt(x, i_to_c(i)), i_to_c(j))));

% i_to_c_mult_assoc_rev
  ASSERT
  (FORALL (x : complex, i : INT, j : INT): (infix_asdt(infix_asdt(x, 
  i_to_c(i)), i_to_c(j)) = infix_asdt(x, i_to_c((i * j)))));

% i_to_c_sub
  ASSERT
  (FORALL (i : INT, j : INT): (infix_mndt(i_to_c(i), i_to_c(j)) = 
  i_to_c((i - j))));

% i_to_c_sub_rev
  ASSERT
  (FORALL (i : INT, j : INT): (i_to_c((i - j)) = infix_mndt(i_to_c(i), 
  i_to_c(j))));

% i_to_c_opp
  ASSERT (FORALL (i : INT): (i_to_c((- i)) = prefix_mndt(i_to_c(i))));

% i_to_c_div
  ASSERT
  (FORALL (i : INT, j : INT):
  ((NOT (j = 0)) => (infix_sldt(i_to_c((i * j)), i_to_c(j)) = i_to_c(i))));

% i_to_c_minus_mult
  ASSERT
  (FORALL (i : INT, j : INT): (infix_asdt(i_to_c((- i)), i_to_c(j)) = 
  infix_asdt(i_to_c(i), i_to_c((- j)))));

% i_to_c_div_leq_c_one
  ASSERT
  (FORALL (a : INT, b : INT):
  (((0 <= a) AND (a < b)) => (infix_lseqdt(infix_sldt(i_to_c(a), i_to_c(b)),
  c_one))));

% compat_i_to_c_infeq
  ASSERT
  (FORALL (a : INT, b : INT):
  ((a <= b) => (infix_lseqdt(i_to_c(a), i_to_c(b)))));

% compat_i_to_c_inf
  ASSERT
  (FORALL (a : INT, b : INT):
  ((a < b) => (infix_lsdt(i_to_c(a), i_to_c(b)))));

% compat_i_to_c_inf_rev
  ASSERT
  (FORALL (a : INT, b : INT):
  ((infix_lsdt(i_to_c(a), i_to_c(b))) => (a < b)));

% compat_i_to_c_sup
  ASSERT
  (FORALL (a : INT, b : INT):
  ((b < a) => (infix_gtdt(i_to_c(a), i_to_c(b)))));

% positive_int_squrt
  ASSERT
  (FORALL (i : INT): ((0 < i) => (infix_gtdt(square_rt(i_to_c(i)), c_zero))));

% non_null_int_squrt
  ASSERT
  (FORALL (i : INT): ((0 < i) => (NOT (square_rt(i_to_c(i)) = c_zero))));

nonn_part: (ty, ty, uni, uni, uni) -> uni;

% nonn_part_sort
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(set(a), nonn_part(im1, a, x,
  x1, x2)))));

result94: (ty, ty, uni, uni) -> uni;

% result_sort
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, bool), result94(im1, a, x,
  x1)))));

% result'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  t1 : (ARRAY INT OF angle), e : INT):
  ((tb2t2(infix_at(bool, int, result94(angle1, int, t2tb34(op1), t2tb35(t1)), 
  t2tb5(e))) = 0bin1)
  <=> (NOT (neutral(angle1, t2tb34(op1), t2tb33((t1[e])))))));

% result'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : (ARRAY INT OF INT),
  e : INT):
  ((tb2t2(infix_at(bool, int, result94(int, int, t2tb8(op1), t2tb7(t1)), 
  t2tb5(e))) = 0bin1) <=> (NOT (neutral(int, t2tb8(op1), t2tb5((t1[e])))))));

% result'def
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, t1 : uni, e : uni):
  ((tb2t2(infix_at(bool, a, result94(im1, a, op1, t1), e)) = 0bin1)
  <=> (NOT (neutral(im1, op1, infix_at(im1, a, t1, e)))))));

% nonn_part'def
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni): (nonn_part(im1, a, op1, s2, t1) = 
  filter_(a, s2, result94(im1, a, op1, t1)))));

% nonn_part'spec
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  t1 : (ARRAY INT OF angle)):
  (FORALL (e : INT):
  ((mem(int, t2tb5(e), nonn_part(angle1, int, t2tb34(op1), t2tb6(s2), 
  t2tb35(t1))))
  <=> ((mem(int, t2tb5(e), t2tb6(s2)))
      AND (NOT (neutral(angle1, t2tb34(op1), t2tb33((t1[e])))))))));

% nonn_part'spec
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  t1 : (ARRAY INT OF INT)):
  (FORALL (e : INT):
  ((mem(int, t2tb5(e), nonn_part(int, int, t2tb8(op1), t2tb6(s2), 
  t2tb7(t1))))
  <=> ((mem(int, t2tb5(e), t2tb6(s2)))
      AND (NOT (neutral(int, t2tb8(op1), t2tb5((t1[e])))))))));

% nonn_part'spec
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni):
  (FORALL (e : uni):
  ((mem(a, e, nonn_part(im1, a, op1, s2, t1)))
  <=> ((mem(a, e, s2))
      AND (NOT (neutral(im1, op1, infix_at(im1, a, t1, e)))))))));

n_part: (ty, ty, uni, uni, uni) -> uni;

% n_part_sort
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(set(a), n_part(im1, a, x, x1,
  x2)))));

result95: (ty, ty, uni, uni) -> uni;

% result_sort
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, bool), result95(im1, a, x,
  x1)))));

% result'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  t1 : (ARRAY INT OF angle), e : INT):
  ((tb2t2(infix_at(bool, int, result95(angle1, int, t2tb34(op1), t2tb35(t1)), 
  t2tb5(e))) = 0bin1) <=> (neutral(angle1, t2tb34(op1), t2tb33((t1[e]))))));

% result'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), t1 : (ARRAY INT OF INT),
  e : INT):
  ((tb2t2(infix_at(bool, int, result95(int, int, t2tb8(op1), t2tb7(t1)), 
  t2tb5(e))) = 0bin1) <=> (neutral(int, t2tb8(op1), t2tb5((t1[e]))))));

% result'def
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, t1 : uni, e : uni):
  ((tb2t2(infix_at(bool, a, result95(im1, a, op1, t1), e)) = 0bin1)
  <=> (neutral(im1, op1, infix_at(im1, a, t1, e))))));

% n_part'def
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni): (n_part(im1, a, op1, s2, t1) = 
  filter_(a, s2, result95(im1, a, op1, t1)))));

% n_part'spec
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  t1 : (ARRAY INT OF angle)):
  (FORALL (e : INT):
  ((mem(int, t2tb5(e), n_part(angle1, int, t2tb34(op1), t2tb6(s2), 
  t2tb35(t1))))
  <=> ((mem(int, t2tb5(e), t2tb6(s2))) AND (neutral(angle1, t2tb34(op1), 
      t2tb33((t1[e]))))))));

% n_part'spec
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  t1 : (ARRAY INT OF INT)):
  (FORALL (e : INT):
  ((mem(int, t2tb5(e), n_part(int, int, t2tb8(op1), t2tb6(s2), t2tb7(t1))))
  <=> ((mem(int, t2tb5(e), t2tb6(s2))) AND (neutral(int, t2tb8(op1), 
      t2tb5((t1[e]))))))));

% n_part'spec
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni):
  (FORALL (e : uni):
  ((mem(a, e, n_part(im1, a, op1, s2, t1)))
  <=> ((mem(a, e, s2)) AND (neutral(im1, op1, infix_at(im1, a, t1, e))))))));

% nullity_partition
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni):
  ((sort(set(a), s2))
  => ((commut(im1, op1))
     => ((s2 = union(a, nonn_part(im1, a, op1, s2, t1), n_part(im1, a, op1,
        s2, t1))) AND (inter(a, nonn_part(im1, a, op1, s2, t1), n_part(im1,
        a, op1, s2, t1)) = empty(a)))))));

% iterate_neutral
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : set_int,
  t1 : (ARRAY INT OF angle)):
  ((iterable(angle1, t2tb34(op1)))
  => ((commut(angle1, t2tb34(op1)))
     => ((FORALL (a : INT):
         ((mem(int, t2tb5(a), t2tb6(s2))) => ((t1[a]) = tb2t33(
         neutral_elt(angle1, t2tb34(op1))))))
        => (tb2t33(iterate(angle1, int, t2tb34(op1), t2tb6(s2), 
        t2tb35(t1))) = tb2t33(neutral_elt(angle1, t2tb34(op1))))))));

% iterate_neutral
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : set_int,
  t1 : (ARRAY INT OF INT)):
  ((iterable(int, t2tb8(op1)))
  => ((commut(int, t2tb8(op1)))
     => ((FORALL (a : INT):
         ((mem(int, t2tb5(a), t2tb6(s2))) => ((t1[a]) = tb2t5(
         neutral_elt(int, t2tb8(op1))))))
        => (tb2t5(iterate(int, int, t2tb8(op1), t2tb6(s2), t2tb7(t1))) = 
        tb2t5(neutral_elt(int, t2tb8(op1))))))));

% iterate_neutral
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => ((FORALL (a1 : uni):
         ((sort(a, a1))
         => ((mem(a, a1, s2)) => (infix_at(im1, a, t1, a1) = neutral_elt(im1,
            op1)))))
        => (iterate(im1, a, op1, s2, t1) = neutral_elt(im1, op1)))))));

% iterate_nullity_partition
  ASSERT
  (FORALL (a : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, t1 : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1)) => (iterate(im1, a, op1, s2, t1) = iterate(im1, a,
     op1, nonn_part(im1, a, op1, s2, t1), t1))))));

couple: (ty, ty, ty, uni, uni) -> uni;

% couple_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni): (sort(im1, couple(im1, b, a, x, x1)))));

% couple'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni):
  (FORALL (a1 : uni, b : INT): (tb2t33(couple(angle1, int, a, f, Tuple2(a,
  int, a1, t2tb5(b)))) = (tb2t35(infix_at(infix_mngt(int, angle1), a, f,
  a1))[b])))));

% couple'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni):
  (FORALL (a1 : uni, b : INT): (tb2t5(couple(int, int, a, f, Tuple2(a, int,
  a1, t2tb5(b)))) = (tb2t7(infix_at(infix_mngt(int, int), a, f, a1))[b])))));

% couple'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (f : uni):
  (FORALL (a1 : uni, b1 : uni): (couple(im1, b, a, f, Tuple2(a, b, a1,
  b1)) = infix_at(im1, b, infix_at(infix_mngt(b, im1), a, f, a1), b1)))));

% null_product
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_asdt(a, b) = c_zero) => ((a = c_zero) OR (b = c_zero))));

% couple_value
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t33(couple(angle1, int, a, f, o)) = (
  tb2t35(infix_at(infix_mngt(int, angle1), a, f, fir(int, a, o)))[tb2t5(
  sec(int, a, o))]))));

% couple_value
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t5(couple(int, int, a, f, o)) = (tb2t7(
  infix_at(infix_mngt(int, int), a, f, fir(int, a, o)))[tb2t5(sec(int, a,
  o))]))));

% couple_value
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (f : uni, o : uni): (couple(im1, b, a, f, o) = infix_at(im1, b, 
  infix_at(infix_mngt(b, im1), a, f, fir(b, a, o)), sec(b, a, o)))));

% couple_value_dev
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni, a1 : uni, b : INT):
  ((o = Tuple2(a, int, a1, t2tb5(b))) => (tb2t33(couple(angle1, int, a, f,
  o)) = (tb2t35(infix_at(infix_mngt(int, angle1), a, f, a1))[b])))));

% couple_value_dev
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni, a1 : uni, b : INT):
  ((o = Tuple2(a, int, a1, t2tb5(b))) => (tb2t5(couple(int, int, a, f,
  o)) = (tb2t7(infix_at(infix_mngt(int, int), a, f, a1))[b])))));

% couple_value_dev
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (f : uni, o : uni, a1 : uni, b1 : uni):
  ((o = Tuple2(a, b, a1, b1)) => (couple(im1, b, a, f, o) = infix_at(im1, b, 
  infix_at(infix_mngt(b, im1), a, f, a1), b1)))));

infix_pldt_closure: (ARRAY complex OF (ARRAY complex OF complex));

t2tb10: ((ARRAY complex OF complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY complex OF complex)): (sort(infix_mngt(complex1,
  complex1), t2tb10(x))));

tb2t10: (uni) -> (ARRAY complex OF complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY complex OF complex)):PATTERN (t2tb10(i)):  (tb2t10(
  t2tb10(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb10(tb2t10(j))): 
  ((sort(infix_mngt(complex1, complex1), j)) => (t2tb10(tb2t10(j)) = j)));

t2tb11: ((ARRAY complex OF (ARRAY complex OF complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY complex OF (ARRAY complex OF complex))): (sort(
  infix_mngt(complex1, infix_mngt(complex1, complex1)), t2tb11(x))));

tb2t11: (uni) -> (ARRAY complex OF (ARRAY complex OF complex));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY complex OF (ARRAY complex OF complex))):PATTERN (
  t2tb11(i)):  (tb2t11(t2tb11(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb11(tb2t11(j))): 
  ((sort(infix_mngt(complex1, infix_mngt(complex1, complex1)), j)) => (
  t2tb11(tb2t11(j)) = j)));

% infix +._closure_def
  ASSERT
  (FORALL (y : complex, y1 : complex): (tb2t(infix_at(complex1, complex1, 
  infix_at(infix_mngt(complex1, complex1), complex1, 
  t2tb11(infix_pldt_closure), t2tb(y)), t2tb(y1))) = infix_pldt(y, y1)));

% neutral_c_zero
  ASSERT
  ((neutral(complex1, t2tb11(infix_pldt_closure), t2tb(c_zero)))
  AND (iterable(complex1, t2tb11(infix_pldt_closure))));

sum: (ty, uni, uni) -> complex;

% sum'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni): (sum(a, s2, t1) = tb2t(iterate(complex1, a, 
  t2tb11(infix_pldt_closure), s2, t1)))));

% sum_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  ((is_empty(a, s2)) => (sum(a, s2, t1) = c_zero))));

% sum_one
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  ((cardinal(a, s2) = 1) => (sum(a, s2, t1) = tb2t(infix_at(complex1, a, t1, 
  choose(a, s2)))))));

% sum_add
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, x : uni):
  ((NOT (mem(b, x, s2))) => (sum(b, add(b, x, s2), f) = infix_pldt(tb2t(
  infix_at(complex1, b, f, x)), sum(b, s2, f))))));

% sum_plus_one
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni):
  ((1 < cardinal(b, s2)) => (sum(b, s2, f) = infix_pldt(tb2t(
  infix_at(complex1, b, f, choose(b, s2))), sum(b, remove(b, choose(b, s2),
  s2), f))))));

% sum_partition
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni):
  ((FORALL (e : uni):
   ((sort(b, e)) => ((mem(b, e, s2)) => (NOT (mem(b, e, sqt))))))
  => (sum(b, union(b, s2, sqt), f) = infix_pldt(sum(b, s2, f), sum(b, sqt,
  f))))));

% sum_real
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((FORALL (a1 : uni):
   ((sort(a, a1))
   => ((mem(a, a1, s2)) => (real_(tb2t(infix_at(complex1, a, f, a1)))))))
  => ((0 < cardinal(a, s2)) => (real_(sum(a, s2, f)))))));

fc49: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, complex1), fc49(b, a, x,
  x1)))));

t2tb12: ((ARRAY INT OF complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF complex)): (sort(infix_mngt(int, complex1), 
  t2tb12(x))));

tb2t12: (uni) -> (ARRAY INT OF complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF complex)):PATTERN (t2tb12(i)):  (tb2t12(
  t2tb12(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb12(tb2t12(j))): 
  ((sort(infix_mngt(int, complex1), j)) => (t2tb12(tb2t12(j)) = j)));

t2tb73: ((ARRAY angle OF complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY angle OF complex)): (sort(infix_mngt(angle1, complex1), 
  t2tb73(x))));

tb2t73: (uni) -> (ARRAY angle OF complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY angle OF complex)):PATTERN (t2tb73(i)):  (tb2t73(
  t2tb73(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb73(tb2t73(j))): 
  ((sort(infix_mngt(angle1, complex1), j)) => (t2tb73(tb2t73(j)) = j)));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), t1 : (ARRAY angle OF complex), b : INT):
  (tb2t(infix_at(complex1, int, fc49(int, angle1, t2tb35(f), t2tb73(t1)), 
  t2tb5(b))) = tb2t(infix_at(complex1, angle1, t2tb73(t1), t2tb33((f[b]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF complex), b : INT): (
  tb2t(infix_at(complex1, int, fc49(int, int, t2tb7(f), t2tb12(t1)), 
  t2tb5(b))) = tb2t(infix_at(complex1, int, t2tb12(t1), t2tb5((f[b]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, t1 : uni, b1 : uni): (tb2t(infix_at(complex1, b, fc49(b,
  a, f, t1), b1)) = tb2t(infix_at(complex1, a, t1, infix_at(a, b, f, b1))))));

% map_sum_eq
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni, t1 : uni):
  ((p_injective(a, b, f, s2)) => (sum(a, map(a, b, f, s2), t1) = sum(b, s2, 
  fc49(b, a, f, t1))))));

fc50: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, complex1), fc50(b, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, g : uni, k : uni): (tb2t(infix_at(complex1, b, fc50(b, f,
  g), k)) = infix_pldt(tb2t(infix_at(complex1, b, f, k)), tb2t(
  infix_at(complex1, b, g, k))))));

% sum_comp
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, g : uni): (sum(b, s2, fc50(b, f, g)) = 
  infix_pldt(sum(b, s2, f), sum(b, s2, g)))));

fc51: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, complex1), fc51(b, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, g : uni, k : uni): (tb2t(infix_at(complex1, b, fc51(b, f,
  g), k)) = infix_pldt(tb2t(infix_at(complex1, b, f, k)), tb2t(
  infix_at(complex1, b, g, k))))));

% sum_comp_rev
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, g : uni): (infix_pldt(sum(b, s2, f), sum(b, s2,
  g)) = sum(b, s2, fc51(b, f, g)))));

infix_mndt_closure: (ARRAY complex OF (ARRAY complex OF complex));

% infix -._closure_def
  ASSERT
  (FORALL (y : complex, y1 : complex): (tb2t(infix_at(complex1, complex1, 
  infix_at(infix_mngt(complex1, complex1), complex1, 
  t2tb11(infix_mndt_closure), t2tb(y)), t2tb(y1))) = infix_mndt(y, y1)));

% sum_iter_
  ASSERT
  ((opposite_n(complex1, t2tb11(infix_pldt_closure), 
  t2tb11(infix_mndt_closure), t2tb(c_zero)))
  AND ((opposite(complex1, t2tb11(infix_pldt_closure), 
      t2tb11(infix_mndt_closure)))
      AND ((opposite_com(complex1, t2tb11(infix_pldt_closure), 
          t2tb11(infix_mndt_closure))) AND (inverse_tuple(complex1, 
          t2tb11(infix_pldt_closure), t2tb11(infix_mndt_closure), 
          t2tb(c_zero))))));

% neutral_zero
  ASSERT (tb2t(neutral_elt(complex1, t2tb11(infix_pldt_closure))) = c_zero);

% sum_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, g : uni):
  ((FORALL (x : uni):
   ((sort(a, x))
   => ((mem(a, x, s2)) => (tb2t(infix_at(complex1, a, f, x)) = tb2t(
      infix_at(complex1, a, g, x))))))
  => (sum(a, s2, f) = sum(a, s2, g)))));

% sum_eq_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni, g : uni):
  ((s2 = sqt)
  => ((FORALL (x : uni):
      ((sort(a, x))
      => ((mem(a, x, s2)) => (tb2t(infix_at(complex1, a, f, x)) = tb2t(
         infix_at(complex1, a, g, x))))))
     => (sum(a, s2, f) = sum(a, sqt, g))))));

% sum_disjoint_transitivity
  ASSERT
  (FORALL (a : ty):
  (FORALL (s11 : uni, s2 : uni, t1 : uni):
  ((inter(a, s11, s2) = empty(a)) => (sum(a, union(a, s11, s2), t1) = 
  infix_pldt(sum(a, s11, t1), sum(a, s2, t1))))));

fc52: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), fc52(b, a, x,
  x1)))));

fc53: (ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni): (sort(infix_mngt(tuple2(a, b), complex1), fc53(b, a,
  x)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni, a1 : uni): (tb2t(infix_at(complex1, a, fc52(b,
  a, s2, f), a1)) = sum(b, s2, infix_at(infix_mngt(b, complex1), a, f, a1)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, o : uni): (tb2t(infix_at(complex1, tuple2(a, b), fc53(b,
  a, f), o)) = tb2t(infix_at(complex1, b, infix_at(infix_mngt(b, complex1),
  a, f, fir(b, a, o)), sec(b, a, o))))));

% sum_to_cartesian_product
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni, f : uni): (sum(a, s11, fc52(b, a, s2, f)) = 
  sum(tuple2(a, b), cartesian_product(b, a, s11, s2), fc53(b, a, f)))));

fc54: (ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni): (sort(infix_mngt(tuple2(a, b), complex1), fc54(b, a,
  x)))));

fc55: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), fc55(b, a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, o : uni): (tb2t(infix_at(complex1, tuple2(a, b), fc54(b,
  a, f), o)) = tb2t(infix_at(complex1, b, infix_at(infix_mngt(b, complex1),
  a, f, fir(b, a, o)), sec(b, a, o))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni, a1 : uni): (tb2t(infix_at(complex1, a, fc55(b,
  a, s2, f), a1)) = sum(b, s2, infix_at(infix_mngt(b, complex1), a, f, a1)))));

% sum_from_cartesian_product
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni, f : uni): (sum(tuple2(a, b), 
  cartesian_product(b, a, s11, s2), fc54(b, a, f)) = sum(a, s11, fc55(b, a,
  s2, f)))));

ind_sum: ((ARRAY INT OF complex), INT, INT) -> complex;

% ind_sum'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT): (ind_sum(f, i,
  j) = tb2t(int_iterate(complex1, t2tb11(infix_pldt_closure), t2tb12(f), i,
  j))));

% ind_sum_to_int_iterate
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT): (ind_sum(f, i,
  j) = tb2t(int_iterate(complex1, t2tb11(infix_pldt_closure), t2tb12(f), i,
  j))));

% ind_sum_cardone
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((j = (i + 1)) => (ind_sum(f, i, j) = tb2t(infix_at(complex1, int, 
  t2tb12(f), t2tb5(i))))));

% ind_sum_right_extension
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((i < j) => (ind_sum(f, i, j) = infix_pldt(ind_sum(f, i, (j - 1)), tb2t(
  infix_at(complex1, int, t2tb12(f), t2tb5((j - 1))))))));

% ind_sum_trans
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, k : INT, j : INT):
  (((i <= k) AND (k <= j)) => (ind_sum(f, i, j) = infix_pldt(ind_sum(f, i,
  k), ind_sum(f, k, j)))));

% ind_sum_plus_one
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((i < j) => (ind_sum(f, i, j) = infix_pldt(tb2t(infix_at(complex1, int, 
  t2tb12(f), t2tb5(i))), ind_sum(f, (i + 1), j)))));

% real_ind_sum
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((i < j)
  => ((FORALL (k : INT):
      (((i <= k) AND (k < j)) => (real_(tb2t(infix_at(complex1, int, 
      t2tb12(f), t2tb5(k)))))))
     => (real_(ind_sum(f, i, j))))));

% positive_ind_sum
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((i < j)
  => ((FORALL (k : INT):
      (((i <= k) AND (k < j)) => (infix_lseqdt(c_zero, tb2t(
      infix_at(complex1, int, t2tb12(f), t2tb5(k)))))))
     => (infix_lseqdt(c_zero, ind_sum(f, i, j))))));

% positive_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((FORALL (k : uni):
   ((sort(a, k))
   => ((mem(a, k, s2)) => (infix_lseqdt(c_zero, tb2t(infix_at(complex1, a, f,
      k)))))))
  => (infix_lseqdt(c_zero, sum(a, s2, f))))));

% ind_sum_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : (ARRAY INT OF complex), i : INT,
  j : INT):
  ((FORALL (k : INT):
   (((i <= k) AND (k < j)) => (tb2t(infix_at(complex1, int, t2tb12(f), 
   t2tb5(k))) = tb2t(infix_at(complex1, int, t2tb12(g), t2tb5(k))))))
  => (ind_sum(f, i, j) = ind_sum(g, i, j))));

fc56: ((ARRAY INT OF complex), complex, INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc56(f, g, i, j)), 
  t2tb5(k))) = (IF ((i <= k) AND (k < j)) THEN tb2t(infix_at(complex1, int, 
               t2tb12(f), t2tb5(k))) ELSE g ENDIF)));

% ind_sum_eq_del_bound
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : complex, i : INT, j : INT): (
  ind_sum(fc56(f, g, i, j), i, j) = ind_sum(f, i, j)));

fc57: ((ARRAY INT OF complex), complex, INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc57(f, g, i, j)), 
  t2tb5(k))) = (IF ((i <= k) AND (k < j)) THEN tb2t(infix_at(complex1, int, 
               t2tb12(f), t2tb5(k))) ELSE g ENDIF)));

% ind_sum_eq_del_bound_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : complex, i : INT, j : INT): (
  ind_sum(f, i, j) = ind_sum(fc57(f, g, i, j), i, j)));

% ind_sum_eq_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : (ARRAY INT OF complex), i1 : INT,
  j1 : INT, i2 : INT, j2 : INT):
  ((i1 = i2)
  => ((j1 = j2)
     => ((FORALL (k : INT):
         (((i1 <= k) AND (k < j1)) => (tb2t(infix_at(complex1, int, 
         t2tb12(f), t2tb5(k))) = tb2t(infix_at(complex1, int, t2tb12(g), 
         t2tb5(k))))))
        => (ind_sum(f, i1, j1) = ind_sum(g, i2, j2))))));

% ind_sum_eq_bound
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : (ARRAY INT OF complex), i : INT,
  j : INT):
  ((i = j)
  => ((FORALL (k : INT):
      (((0 <= k) AND (k < j)) => (tb2t(infix_at(complex1, int, t2tb12(f), 
      t2tb5(k))) = tb2t(infix_at(complex1, int, t2tb12(g), t2tb5(k))))))
     => (ind_sum(f, 0, i) = ind_sum(g, 0, j)))));

fc58: ((ARRAY INT OF complex),
  (ARRAY INT OF complex)) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : (ARRAY INT OF complex), k : INT):
  (tb2t(infix_at(complex1, int, t2tb12(fc58(f, g)), t2tb5(k))) = infix_pldt(
  tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(k))), tb2t(infix_at(complex1,
  int, t2tb12(g), t2tb5(k))))));

% ind_sum_comp
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : (ARRAY INT OF complex), i : INT,
  j : INT): (ind_sum(fc58(f, g), i, j) = infix_pldt(ind_sum(f, i, j), 
  ind_sum(g, i, j))));

fc59: ((ARRAY INT OF complex),
  (ARRAY INT OF complex)) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : (ARRAY INT OF complex), k : INT):
  (tb2t(infix_at(complex1, int, t2tb12(fc59(f, g)), t2tb5(k))) = infix_pldt(
  tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(k))), tb2t(infix_at(complex1,
  int, t2tb12(g), t2tb5(k))))));

% ind_sum_comp_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : (ARRAY INT OF complex), i : INT,
  iqt : INT, j : INT, jqt : INT):
  ((i = iqt)
  => ((j = jqt) => (infix_pldt(ind_sum(f, i, j), ind_sum(g, iqt, jqt)) = 
     ind_sum(fc59(f, g), i, j)))));

% ind_sum_to_iterate
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT): (ind_sum(f, i,
  j) = tb2t(iterate(complex1, int, t2tb11(infix_pldt_closure), t2tb6(
  to_fset(i, j)), t2tb12(f)))));

% ind_sum_to_sum
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT): (ind_sum(f, i,
  j) = sum(int, t2tb6(to_fset(i, j)), t2tb12(f))));

fc60: ((ARRAY INT OF INT), (ARRAY INT OF complex)) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF complex), b : INT): (
  tb2t(infix_at(complex1, int, t2tb12(fc60(f, t1)), t2tb5(b))) = tb2t(
  infix_at(complex1, int, t2tb12(t1), t2tb5((f[b]))))));

% map_ind_sum_eq
  ASSERT
  (FORALL (i : INT, j : INT, k : INT, l : INT, f : (ARRAY INT OF INT),
  t1 : (ARRAY INT OF complex)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(i, j)), t2tb6(to_fset(k,
  l)))) => (ind_sum(t1, k, l) = ind_sum(fc60(f, t1), i, j))));

fc61: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, complex1), fc61(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, c : complex, x : uni): (tb2t(infix_at(complex1, a, 
  fc61(a, f, c), x)) = infix_asdt(c, tb2t(infix_at(complex1, a, f, x))))));

% sum_scal
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, c : complex): (sum(a, s2, fc61(a, f, c)) = 
  infix_asdt(c, sum(a, s2, f)))));

fc62: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, complex1), fc62(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, c : complex, x : uni): (tb2t(infix_at(complex1, a, 
  fc62(a, f, c), x)) = infix_asdt(tb2t(infix_at(complex1, a, f, x)), c))));

% sum_scal_right
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, c : complex): (sum(a, s2, fc62(a, f, c)) = 
  infix_asdt(sum(a, s2, f), c))));

fc63: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, complex1), fc63(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, c : complex, x : uni): (tb2t(infix_at(complex1, a, 
  fc63(a, f, c), x)) = infix_asdt(tb2t(infix_at(complex1, a, f, x)), c))));

% sum_scal_rev_right
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, c : complex): (infix_asdt(sum(a, s2, f), c) = 
  sum(a, s2, fc63(a, f, c)))));

fc64: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, complex1), fc64(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, c : complex, x : uni): (tb2t(infix_at(complex1, a, 
  fc64(a, f, c), x)) = infix_asdt(c, tb2t(infix_at(complex1, a, f, x))))));

% sum_scal_rev
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, c : complex): (infix_asdt(c, sum(a, s2, f)) = 
  sum(a, s2, fc64(a, f, c)))));

fc65: ((ARRAY INT OF complex), complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), a : complex, i : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc65(f, a)), t2tb5(i))) = infix_asdt(a, 
  tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(i))))));

% ind_sum_scal
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT, a : complex): (
  ind_sum(fc65(f, a), i, j) = infix_asdt(a, ind_sum(f, i, j))));

fc66: ((ARRAY INT OF complex), complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), a : complex, i : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc66(f, a)), t2tb5(i))) = infix_asdt(a, 
  tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(i))))));

% ind_sum_scal_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT, a : complex): (
  infix_asdt(a, ind_sum(f, i, j)) = ind_sum(fc66(f, a), i, j)));

fc67: ((ARRAY INT OF complex), complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), a : complex, i : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc67(f, a)), t2tb5(i))) = infix_asdt(tb2t(
  infix_at(complex1, int, t2tb12(f), t2tb5(i))), a)));

% scal_ind_sum
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT, a : complex): (
  ind_sum(fc67(f, a), i, j) = infix_asdt(ind_sum(f, i, j), a)));

fc68: ((ARRAY INT OF complex), complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), a : complex, i : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc68(f, a)), t2tb5(i))) = infix_asdt(tb2t(
  infix_at(complex1, int, t2tb12(f), t2tb5(i))), a)));

% scal_ind_sum_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT, a : complex): (
  infix_asdt(ind_sum(f, i, j), a) = ind_sum(fc68(f, a), i, j)));

fc69: ((ARRAY INT OF complex), complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), a : complex, i : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc69(f, a)), t2tb5(i))) = infix_asdt(a, 
  tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(i))))));

% sum_scal_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), s2 : set_int):
  (FORALL (a : complex): (sum(int, t2tb6(s2), t2tb12(fc69(f, a))) = 
  infix_asdt(a, sum(int, t2tb6(s2), t2tb12(f))))));

fc70: ((ARRAY INT OF complex), complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), a : complex, i : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc70(f, a)), t2tb5(i))) = infix_asdt(a, 
  tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(i))))));

% ind_sum_scal_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  (FORALL (a : complex): (ind_sum(fc70(f, a), i, j) = infix_asdt(a, 
  ind_sum(f, i, j)))));

% int_int_iterate_def_empty
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, k : INT, l : INT):
  ((j <= i)
  => ((iterable(im1, op1)) => (int_int_iterate(im1, op1, f, i, j, k, l) = 
     neutral_elt(im1, op1))))));

% int_int_iterate_def_plus_one
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  f : (ARRAY INT OF (ARRAY INT OF INT)), i : INT, j : INT, k : INT, l : INT):
  ((i < j)
  => ((iterable(int, t2tb8(op1))) => (tb2t5(int_int_iterate(int, t2tb8(op1), 
     t2tb8(f), i, j, k, l)) = (tb2t7(infix_at(infix_mngt(int, int), int, 
     t2tb8(op1), int_iterate(int, t2tb8(op1), infix_at(infix_mngt(int, int),
     int, t2tb8(f), t2tb5(i)), k, l)))[tb2t5(int_int_iterate(int, t2tb8(op1), 
     t2tb8(f), (i + 1), j, k, l))])))));

% int_int_iterate_def_plus_one
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, k : INT, l : INT):
  ((i < j)
  => ((iterable(im1, op1)) => (int_int_iterate(im1, op1, f, i, j, k, l) = 
     infix_at(im1, im1, infix_at(infix_mngt(im1, im1), im1, op1, 
     int_iterate(im1, op1, infix_at(infix_mngt(int, im1), int, f, t2tb5(i)),
     k, l)), int_int_iterate(im1, op1, f, (i + 1), j, k, l)))))));

fc71: (ty, uni, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT): (sort(infix_mngt(int,
  im1), fc71(im1, x, x1, x2, x3)))));

t2tb36: ((ARRAY INT OF (ARRAY INT OF angle))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF (ARRAY INT OF angle))): (sort(infix_mngt(int, 
  infix_mngt(int, angle1)), t2tb36(x))));

tb2t36: (uni) -> (ARRAY INT OF (ARRAY INT OF angle));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF (ARRAY INT OF angle))):PATTERN (t2tb36(i)):  (
  tb2t36(t2tb36(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb36(tb2t36(j))): 
  ((sort(infix_mngt(int, infix_mngt(int, angle1)), j)) => (t2tb36(
  tb2t36(j)) = j)));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF (ARRAY INT OF angle)), k : INT, l : INT, a : INT): ((
  tb2t35(fc71(angle1, t2tb34(op1), t2tb36(f), k, l))[a]) = tb2t33(
  int_iterate(angle1, t2tb34(op1), infix_at(infix_mngt(int, angle1), int, 
  t2tb36(f), t2tb5(a)), k, l))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  f : (ARRAY INT OF (ARRAY INT OF INT)), k : INT, l : INT, a : INT): ((tb2t7(
  fc71(int, t2tb8(op1), t2tb8(f), k, l))[a]) = tb2t5(int_iterate(int, 
  t2tb8(op1), infix_at(infix_mngt(int, int), int, t2tb8(f), t2tb5(a)), k,
  l))));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, k : INT, l : INT, a : INT): (infix_at(im1,
  int, fc71(im1, op1, f, k, l), t2tb5(a)) = int_iterate(im1, op1, infix_at(
  infix_mngt(int, im1), int, f, t2tb5(a)), k, l))));

% int_int_iterate_to_int_iterate
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, k : INT, l : INT):
  ((i <= j)
  => ((iterable(im1, op1)) => (int_int_iterate(im1, op1, f, i, j, k, l) = 
     int_iterate(im1, op1, fc71(im1, op1, f, k, l), i, j))))));

fc72: (ty, uni, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT): (sort(infix_mngt(int,
  im1), fc72(im1, x, x1, x2, x3)))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF (ARRAY INT OF angle)), k : INT, l : INT, a : INT): ((
  tb2t35(fc72(angle1, t2tb34(op1), t2tb36(f), k, l))[a]) = tb2t33(
  int_iterate(angle1, t2tb34(op1), infix_at(infix_mngt(int, angle1), int, 
  t2tb36(f), t2tb5(a)), k, l))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  f : (ARRAY INT OF (ARRAY INT OF INT)), k : INT, l : INT, a : INT): ((tb2t7(
  fc72(int, t2tb8(op1), t2tb8(f), k, l))[a]) = tb2t5(int_iterate(int, 
  t2tb8(op1), infix_at(infix_mngt(int, int), int, t2tb8(f), t2tb5(a)), k,
  l))));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, k : INT, l : INT, a : INT): (infix_at(im1,
  int, fc72(im1, op1, f, k, l), t2tb5(a)) = int_iterate(im1, op1, infix_at(
  infix_mngt(int, im1), int, f, t2tb5(a)), k, l))));

% int_iterate_to_int_int_iterate
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, k : INT, l : INT):
  ((i <= j)
  => ((iterable(im1, op1)) => (int_iterate(im1, op1, fc72(im1, op1, f, k, l),
     i, j) = int_int_iterate(im1, op1, f, i, j, k, l))))));

fc73: (ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni): (sort(infix_mngt(tuple2(int, int), im1), fc73(im1, x)))));

lpintcm_intrp: TYPE;

t2tb74: ((ARRAY lpintcm_intrp OF angle)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY lpintcm_intrp OF angle)): (sort(infix_mngt(tuple2(int,
  int), angle1), t2tb74(x))));

tb2t74: (uni) -> (ARRAY lpintcm_intrp OF angle);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY lpintcm_intrp OF angle)):PATTERN (t2tb74(i)):  (tb2t74(
  t2tb74(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb74(tb2t74(j))): 
  ((sort(infix_mngt(tuple2(int, int), angle1), j)) => (t2tb74(
  tb2t74(j)) = j)));

t2tb13: (lpintcm_intrp) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : lpintcm_intrp): (sort(tuple2(int, int), t2tb13(x))));

tb2t13: (uni) -> lpintcm_intrp;

% BridgeL
  ASSERT
  (FORALL (i : lpintcm_intrp):PATTERN (t2tb13(i)):  (tb2t13(t2tb13(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb13(tb2t13(j))):  (t2tb13(tb2t13(j)) = j));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)), o : lpintcm_intrp): (
  tb2t33(infix_at(angle1, tuple2(int, int), fc73(angle1, t2tb36(f)), 
  t2tb13(o))) = (tb2t35(infix_at(infix_mngt(int, angle1), int, t2tb36(f), 
  fir(int, int, t2tb13(o))))[tb2t5(sec(int, int, t2tb13(o)))])));

t2tb75: ((ARRAY lpintcm_intrp OF INT)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY lpintcm_intrp OF INT)): (sort(infix_mngt(tuple2(int,
  int), int), t2tb75(x))));

tb2t75: (uni) -> (ARRAY lpintcm_intrp OF INT);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY lpintcm_intrp OF INT)):PATTERN (t2tb75(i)):  (tb2t75(
  t2tb75(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb75(tb2t75(j))):  (t2tb75(tb2t75(j)) = j));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF INT)), o : lpintcm_intrp): (tb2t5(
  infix_at(int, tuple2(int, int), fc73(int, t2tb8(f)), t2tb13(o))) = (tb2t7(
  infix_at(infix_mngt(int, int), int, t2tb8(f), fir(int, int, t2tb13(o))))[
  tb2t5(sec(int, int, t2tb13(o)))])));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (f : uni, o : lpintcm_intrp): (infix_at(im1, tuple2(int, int), 
  fc73(im1, f), t2tb13(o)) = infix_at(im1, int, infix_at(infix_mngt(int,
  im1), int, f, fir(int, int, t2tb13(o))), sec(int, int, t2tb13(o))))));

set_lpintcm_intrp: TYPE;

t2tb14: (set_lpintcm_intrp) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : set_lpintcm_intrp): (sort(set(tuple2(int, int)), t2tb14(x))));

tb2t14: (uni) -> set_lpintcm_intrp;

% BridgeL
  ASSERT
  (FORALL (i : set_lpintcm_intrp):PATTERN (t2tb14(i)):  (tb2t14(
  t2tb14(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb14(tb2t14(j))):  (t2tb14(tb2t14(j)) = j));

% int_int_iterate_to_iterate
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, k : INT, l : INT):
  ((i <= j)
  => ((iterable(im1, op1))
     => ((commut(im1, op1)) => (int_int_iterate(im1, op1, f, i, j, k, l) = 
        iterate(im1, tuple2(int, int), op1, cartesian_product(int, int, 
        t2tb6(to_fset(i, j)), t2tb6(to_fset(k, l))), fc73(im1, f))))))));

fc74: (ty, ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni): (sort(infix_mngt(tuple2(a, b), im1), fc74(im1, b, a,
  x)))));

fc75: (ty, ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni): (sort(infix_mngt(tuple2(b, a), im1), fc75(im1, b, a,
  x)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t33(infix_at(angle1, tuple2(a, int), 
  fc74(angle1, int, a, f), o)) = (tb2t35(infix_at(infix_mngt(int, angle1), a,
  f, fir(int, a, o)))[tb2t5(sec(int, a, o))]))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t5(infix_at(int, tuple2(a, int), fc74(int,
  int, a, f), o)) = (tb2t7(infix_at(infix_mngt(int, int), a, f, fir(int, a,
  o)))[tb2t5(sec(int, a, o))]))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (f : uni, o : uni): (infix_at(im1, tuple2(a, b), fc74(im1, b, a,
  f), o) = infix_at(im1, b, infix_at(infix_mngt(b, im1), a, f, fir(b, a, o)), 
  sec(b, a, o)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t33(infix_at(angle1, tuple2(int, a), 
  fc75(angle1, int, a, f), o)) = (tb2t35(infix_at(infix_mngt(int, angle1), a,
  f, sec(a, int, o)))[tb2t5(fir(a, int, o))]))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, o : uni): (tb2t5(infix_at(int, tuple2(int, a), fc75(int,
  int, a, f), o)) = (tb2t7(infix_at(infix_mngt(int, int), a, f, sec(a, int,
  o)))[tb2t5(fir(a, int, o))]))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (f : uni, o : uni): (infix_at(im1, tuple2(b, a), fc75(im1, b, a,
  f), o) = infix_at(im1, b, infix_at(infix_mngt(b, im1), a, f, sec(a, b, o)), 
  fir(a, b, o)))));

% iterate_commute
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (op1 : uni, s11 : uni, s2 : uni, f : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1)) => (iterate(im1, tuple2(a, b), op1, 
     cartesian_product(b, a, s11, s2), fc74(im1, b, a, f)) = iterate(im1, 
     tuple2(b, a), op1, cartesian_product(a, b, s2, s11), fc75(im1, b, a,
     f)))))));

fc76: (ty, ty, ty, uni, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(a, im1), fc76(im1,
  b, a, x, x1, x2)))));

fc77: (ty, ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, im1), fc77(im1, b, a, x,
  x1)))));

fc78: (ty, ty, ty, uni, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(b, im1), fc78(im1,
  b, a, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s2 : uni, f : uni,
  a1 : INT): ((tb2t35(fc76(angle1, b, int, t2tb34(op1), s2, f))[a1]) = 
  tb2t33(iterate(angle1, b, t2tb34(op1), s2, infix_at(infix_mngt(b, angle1),
  int, f, t2tb5(a1)))))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s2 : uni, f : uni,
  a1 : INT): ((tb2t7(fc76(int, b, int, t2tb8(op1), s2, f))[a1]) = tb2t5(
  iterate(int, b, t2tb8(op1), s2, infix_at(infix_mngt(b, int), int, f, 
  t2tb5(a1)))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (op1 : uni, s2 : uni, f : uni, a1 : uni): (infix_at(im1, a, 
  fc76(im1, b, a, op1, s2, f), a1) = iterate(im1, b, op1, s2, infix_at(
  infix_mngt(b, im1), a, f, a1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, a2 : INT, a1 : uni): (tb2t33(infix_at(angle1, a, 
  fc77(angle1, int, a, f, t2tb5(a2)), a1)) = (tb2t35(infix_at(infix_mngt(int,
  angle1), a, f, a1))[a2]))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, a2 : INT, a1 : uni): (tb2t5(infix_at(int, a, fc77(int,
  int, a, f, t2tb5(a2)), a1)) = (tb2t7(infix_at(infix_mngt(int, int), a, f,
  a1))[a2]))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, a2 : uni, a1 : INT): ((tb2t35(fc77(angle1, b, int, f,
  a2))[a1]) = tb2t33(infix_at(angle1, b, infix_at(infix_mngt(b, angle1), int,
  f, t2tb5(a1)), a2)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, a2 : uni, a1 : INT): ((tb2t7(fc77(int, b, int, f,
  a2))[a1]) = tb2t5(infix_at(int, b, infix_at(infix_mngt(b, int), int, f, 
  t2tb5(a1)), a2)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)), a2 : INT, a1 : INT): ((
  tb2t35(fc77(angle1, int, int, t2tb36(f), t2tb5(a2)))[a1]) = (tb2t35(
  infix_at(infix_mngt(int, angle1), int, t2tb36(f), t2tb5(a1)))[a2])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF INT)), a2 : INT, a1 : INT): ((
  tb2t7(fc77(int, int, int, t2tb8(f), t2tb5(a2)))[a1]) = (tb2t7(infix_at(
  infix_mngt(int, int), int, t2tb8(f), t2tb5(a1)))[a2])));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (f : uni, a2 : uni, a1 : uni): (infix_at(im1, a, fc77(im1, b, a, f,
  a2), a1) = infix_at(im1, b, infix_at(infix_mngt(b, im1), a, f, a1), a2))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)), s11 : uni, f : uni,
  a2 : INT): ((tb2t35(fc78(angle1, int, a, t2tb34(op1), s11, f))[a2]) = 
  tb2t33(iterate(angle1, a, t2tb34(op1), s11, fc77(angle1, int, a, f, 
  t2tb5(a2)))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)), s11 : uni, f : uni,
  a2 : INT): ((tb2t7(fc78(int, int, a, t2tb8(op1), s11, f))[a2]) = tb2t5(
  iterate(int, a, t2tb8(op1), s11, fc77(int, int, a, f, t2tb5(a2)))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (op1 : uni, s11 : uni, f : uni, a2 : uni): (infix_at(im1, b, 
  fc78(im1, b, a, op1, s11, f), a2) = iterate(im1, a, op1, s11, fc77(im1, b,
  a, f, a2)))));

% iterate_commute_
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (op1 : uni, s11 : uni, s2 : uni, f : uni):
  ((iterable(im1, op1))
  => ((commut(im1, op1)) => (iterate(im1, a, op1, s11, fc76(im1, b, a, op1,
     s2, f)) = iterate(im1, b, op1, s2, fc78(im1, b, a, op1, s11, f)))))));

fc79: (ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni): (sort(infix_mngt(int, infix_mngt(int, im1)), fc79(im1,
  x)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)), a : INT, b : INT): ((
  tb2t35(infix_at(infix_mngt(int, angle1), int, fc79(angle1, t2tb36(f)), 
  t2tb5(a)))[b]) = (tb2t35(infix_at(infix_mngt(int, angle1), int, t2tb36(f), 
  t2tb5(b)))[a])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF INT)), a : INT, b : INT): ((tb2t7(
  infix_at(infix_mngt(int, int), int, fc79(int, t2tb8(f)), t2tb5(a)))[b]) = (
  tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(f), t2tb5(b)))[a])));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (f : uni, a : INT, b : INT): (infix_at(im1, int, infix_at(
  infix_mngt(int, im1), int, fc79(im1, f), t2tb5(a)), t2tb5(b)) = 
  infix_at(im1, int, infix_at(infix_mngt(int, im1), int, f, t2tb5(b)), 
  t2tb5(a)))));

% int_int_iterate_commute
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, k : INT, l : INT):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => ((i <= j)
        => ((k <= l) => (int_int_iterate(im1, op1, f, i, j, k, l) = 
           int_int_iterate(im1, op1, fc79(im1, f), k, l, i, j))))))));

fc80: (ty, uni, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT): (sort(infix_mngt(int,
  im1), fc80(im1, x, x1, x2, x3)))));

fc81: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(int, im1), fc81(im1, x,
  x1)))));

fc82: (ty, uni, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT): (sort(infix_mngt(int,
  im1), fc82(im1, x, x1, x2, x3)))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF (ARRAY INT OF angle)), k : INT, l : INT, a : INT): ((
  tb2t35(fc80(angle1, t2tb34(op1), t2tb36(f), k, l))[a]) = tb2t33(
  int_iterate(angle1, t2tb34(op1), infix_at(infix_mngt(int, angle1), int, 
  t2tb36(f), t2tb5(a)), k, l))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  f : (ARRAY INT OF (ARRAY INT OF INT)), k : INT, l : INT, a : INT): ((tb2t7(
  fc80(int, t2tb8(op1), t2tb8(f), k, l))[a]) = tb2t5(int_iterate(int, 
  t2tb8(op1), infix_at(infix_mngt(int, int), int, t2tb8(f), t2tb5(a)), k,
  l))));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, k : INT, l : INT, a : INT): (infix_at(im1,
  int, fc80(im1, op1, f, k, l), t2tb5(a)) = int_iterate(im1, op1, infix_at(
  infix_mngt(int, im1), int, f, t2tb5(a)), k, l))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)), a : INT, b : INT): ((
  tb2t35(fc81(angle1, t2tb36(f), a))[b]) = (tb2t35(infix_at(infix_mngt(int,
  angle1), int, t2tb36(f), t2tb5(b)))[a])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF INT)), a : INT, b : INT): ((tb2t7(
  fc81(int, t2tb8(f), a))[b]) = (tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(f), t2tb5(b)))[a])));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (f : uni, a : INT, b : INT): (infix_at(im1, int, fc81(im1, f, a), 
  t2tb5(b)) = infix_at(im1, int, infix_at(infix_mngt(int, im1), int, f, 
  t2tb5(b)), t2tb5(a)))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY angle OF (ARRAY angle OF angle)),
  f : (ARRAY INT OF (ARRAY INT OF angle)), i : INT, j : INT, a : INT): ((
  tb2t35(fc82(angle1, t2tb34(op1), t2tb36(f), i, j))[a]) = tb2t33(
  int_iterate(angle1, t2tb34(op1), fc81(angle1, t2tb36(f), a), i, j))));

% fc'def
  ASSERT
  (FORALL (op1 : (ARRAY INT OF (ARRAY INT OF INT)),
  f : (ARRAY INT OF (ARRAY INT OF INT)), i : INT, j : INT, a : INT): ((tb2t7(
  fc82(int, t2tb8(op1), t2tb8(f), i, j))[a]) = tb2t5(int_iterate(int, 
  t2tb8(op1), fc81(int, t2tb8(f), a), i, j))));

% fc'def
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, a : INT): (infix_at(im1,
  int, fc82(im1, op1, f, i, j), t2tb5(a)) = int_iterate(im1, op1, fc81(im1,
  f, a), i, j))));

% int_iterate_commute
  ASSERT
  (FORALL (im1 : ty):
  (FORALL (op1 : uni, f : uni, i : INT, j : INT, k : INT, l : INT):
  ((iterable(im1, op1))
  => ((commut(im1, op1))
     => ((i <= j)
        => ((k <= l) => (int_iterate(im1, op1, fc80(im1, op1, f, k, l), i,
           j) = int_iterate(im1, op1, fc82(im1, op1, f, i, j), k, l))))))));

fc83: ((ARRAY INT OF (ARRAY INT OF complex)), INT,
  INT) -> (ARRAY INT OF complex);

fc84: ((ARRAY INT OF (ARRAY INT OF complex)), INT) -> (ARRAY INT OF complex);

fc85: ((ARRAY INT OF (ARRAY INT OF complex)), INT,
  INT) -> (ARRAY INT OF complex);

t2tb15: ((ARRAY INT OF (ARRAY INT OF complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF (ARRAY INT OF complex))): (sort(infix_mngt(int, 
  infix_mngt(int, complex1)), t2tb15(x))));

tb2t15: (uni) -> (ARRAY INT OF (ARRAY INT OF complex));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF (ARRAY INT OF complex))):PATTERN (t2tb15(i)):  (
  tb2t15(t2tb15(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb15(tb2t15(j))): 
  ((sort(infix_mngt(int, infix_mngt(int, complex1)), j)) => (t2tb15(
  tb2t15(j)) = j)));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF complex)), k : INT, l : INT,
  k1 : INT): (tb2t(infix_at(complex1, int, t2tb12(fc83(f, k, l)), 
  t2tb5(k1))) = ind_sum(tb2t12(infix_at(infix_mngt(int, complex1), int, 
  t2tb15(f), t2tb5(k1))), k, l)));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF complex)), k1 : INT, k2 : INT): (
  tb2t(infix_at(complex1, int, t2tb12(fc84(f, k1)), t2tb5(k2))) = tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(f), 
  t2tb5(k2)), t2tb5(k1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF complex)), i : INT, j : INT,
  k1 : INT): (tb2t(infix_at(complex1, int, t2tb12(fc85(f, i, j)), 
  t2tb5(k1))) = ind_sum(fc84(f, k1), i, j)));

% ind_sum_commute
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF complex)), i : INT, j : INT,
  k : INT, l : INT):
  ((i <= j)
  => ((k <= l) => (ind_sum(fc83(f, k, l), i, j) = ind_sum(fc85(f, i, j), k,
     l)))));

fc86: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), fc86(b, a, x,
  x1)))));

fc87: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), fc87(b, a, x,
  x1)))));

fc88: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, complex1), fc88(b, a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sb : uni, a1 : uni): (tb2t(infix_at(complex1, a, fc86(b,
  a, f, sb), a1)) = sum(b, sb, infix_at(infix_mngt(b, complex1), a, f, a1)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, b1 : uni, a1 : uni): (tb2t(infix_at(complex1, a, fc87(b,
  a, f, b1), a1)) = tb2t(infix_at(complex1, b, infix_at(infix_mngt(b,
  complex1), a, f, a1), b1)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sa : uni, b1 : uni): (tb2t(infix_at(complex1, b, fc88(b,
  a, f, sa), b1)) = sum(a, sa, fc87(b, a, f, b1)))));

% sum_commute
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, sa : uni, sb : uni): (sum(a, sa, fc86(b, a, f, sb)) = 
  sum(b, sb, fc88(b, a, f, sa)))));

non_c_zero: (ty, uni, uni) -> uni;

% non_c_zero_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), non_c_zero(a, x, x1)))));

% non_c_zero'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni): (non_c_zero(a, s2, t1) = nonn_part(complex1,
  a, t2tb11(infix_pldt_closure), s2, t1))));

% non_c_zero'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  (FORALL (e : uni):
  ((mem(a, e, non_c_zero(a, s2, t1)))
  <=> ((mem(a, e, s2))
      AND (NOT (tb2t(infix_at(complex1, a, t1, e)) = c_zero)))))));

% get_non_c_zero_member
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, e : uni):
  ((mem(a, e, non_c_zero(a, s2, t1)))
  => ((mem(a, e, s2))
     AND (NOT (tb2t(infix_at(complex1, a, t1, e)) = c_zero))))));

% set_non_c_zero_member
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, e : uni):
  ((mem(a, e, s2))
  => ((NOT (tb2t(infix_at(complex1, a, t1, e)) = c_zero)) => (mem(a, e, 
     non_c_zero(a, s2, t1)))))));

% set_non_c_zero_member_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  (FORALL (e : uni):
  (((mem(a, e, s2)) AND (NOT (tb2t(infix_at(complex1, a, t1, e)) = c_zero)))
  => (mem(a, e, non_c_zero(a, s2, t1)))))));

% set_non_c_zero_member_gen_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  (FORALL (e : uni):
  (((mem(a, e, s2)) AND (NOT (tb2t(infix_at(complex1, a, t1, e)) = c_zero)))
  => (mem(a, e, non_c_zero(a, s2, t1)))))));

% sum_nullity_partition
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni): (sum(a, s2, t1) = sum(a, non_c_zero(a, s2,
  t1), t1))));

fc89: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), fc89(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF complex), b : INT): (
  tb2t(infix_at(complex1, int, fc89(int, t2tb7(f), t2tb12(t1)), t2tb5(b))) = 
  tb2t(infix_at(complex1, int, t2tb12(t1), t2tb5((f[b]))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, t1 : uni, b : uni): (tb2t(infix_at(complex1, a, fc89(a,
  f, t1), b)) = tb2t(infix_at(complex1, a, t1, infix_at(a, a, f, b))))));

% non_null_map
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, t1 : uni): (non_c_zero(a, map(a, a, f, s2),
  t1) = map(a, a, f, non_c_zero(a, s2, fc89(a, f, t1))))));

fc90: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), fc90(a, x,
  x1)))));

fc91: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), fc91(a, x,
  x1)))));

fc92: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), fc92(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF complex), b : INT): (
  tb2t(infix_at(complex1, int, fc90(int, t2tb7(f), t2tb12(t1)), t2tb5(b))) = 
  tb2t(infix_at(complex1, int, t2tb12(t1), t2tb5((f[b]))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, t1 : uni, b : uni): (tb2t(infix_at(complex1, a, fc90(a,
  f, t1), b)) = tb2t(infix_at(complex1, a, t1, infix_at(a, a, f, b))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF complex), b : INT): (
  tb2t(infix_at(complex1, int, fc91(int, t2tb7(f), t2tb12(t1)), t2tb5(b))) = 
  tb2t(infix_at(complex1, int, t2tb12(t1), t2tb5((f[b]))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, t1 : uni, b : uni): (tb2t(infix_at(complex1, a, fc91(a,
  f, t1), b)) = tb2t(infix_at(complex1, a, t1, infix_at(a, a, f, b))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF complex), b : INT): (
  tb2t(infix_at(complex1, int, fc92(int, t2tb7(f), t2tb12(t1)), t2tb5(b))) = 
  tb2t(infix_at(complex1, int, t2tb12(t1), t2tb5((f[b]))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, t1 : uni, b : uni): (tb2t(infix_at(complex1, a, fc92(a,
  f, t1), b)) = tb2t(infix_at(complex1, a, t1, infix_at(a, a, f, b))))));

% map_sum_eq_nonnull
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, t1 : uni):
  ((p_bijective(a, a, f, non_c_zero(a, s2, fc90(a, f, t1)), non_c_zero(a, 
  map(a, a, f, s2), t1))) => (sum(a, non_c_zero(a, map(a, a, f, s2), t1),
  t1) = sum(a, non_c_zero(a, s2, fc91(a, f, t1)), fc92(a, f, t1))))));

% sum_null_but_one
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  ((cardinal(a, non_c_zero(a, s2, t1)) = 1) => (sum(a, s2, t1) = tb2t(
  infix_at(complex1, a, t1, element(a, non_c_zero(a, s2, t1))))))));

% sum_null
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  ((cardinal(a, non_c_zero(a, s2, t1)) = 0) => (sum(a, s2, t1) = c_zero))));

% sum_null_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (tb2t(infix_at(complex1, a, t1, e)) = c_zero))))
  => (sum(a, s2, t1) = c_zero))));

% sum_null_forall
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (tb2t(infix_at(complex1, a, t1, e)) = c_zero))))
  => (sum(a, s2, t1) = c_zero))));

% ind_sum_null
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), i : INT, j : INT):
  ((FORALL (k : INT):
   (((i <= k) AND (k < j)) => (tb2t(infix_at(complex1, int, t2tb12(t1), 
   t2tb5(k))) = c_zero)))
  => (ind_sum(t1, i, j) = c_zero)));

% sum_null_but_one_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, elt : uni):
  (((mem(a, elt, s2))
   AND (NOT (tb2t(infix_at(complex1, a, t1, elt)) = c_zero)))
  => ((FORALL (a1 : uni):
      ((sort(a, a1))
      => ((mem(a, a1, s2))
         => ((NOT (a1 = elt)) => (tb2t(infix_at(complex1, a, t1,
            a1)) = c_zero)))))
     => (sum(a, s2, t1) = tb2t(infix_at(complex1, a, t1, elt)))))));

% sum_null_but_maybe_one_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (t1 : uni, s2 : uni, elt : uni):
  ((mem(a, elt, s2))
  => ((FORALL (k : uni):
      ((sort(a, k))
      => ((mem(a, k, s2))
         => ((NOT (k = elt)) => (tb2t(infix_at(complex1, a, t1,
            k)) = c_zero)))))
     => (sum(a, s2, t1) = tb2t(infix_at(complex1, a, t1, elt)))))));

% sum_null_but_maybe_two_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (t1 : uni, s2 : uni, elt : uni, eltqt : uni):
  ((sort(a, elt))
  => ((sort(a, eltqt))
     => ((mem(a, elt, s2))
        => ((mem(a, eltqt, s2))
           => ((NOT (elt = eltqt))
              => ((FORALL (k : uni):
                  ((sort(a, k))
                  => ((mem(a, k, s2))
                     => ((NOT (k = elt))
                        => ((NOT (k = eltqt)) => (tb2t(infix_at(complex1, a,
                           t1, k)) = c_zero))))))
                 => (sum(a, s2, t1) = infix_pldt(tb2t(infix_at(complex1, a,
                 t1, elt)), tb2t(infix_at(complex1, a, t1, eltqt))))))))))));

% ind_sum_null_but_maybe_one_elt
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), i : INT, j : INT, ind : INT):
  (((i <= ind) AND (ind < j))
  => ((FORALL (k : INT):
      (((i <= k) AND (k < j))
      => ((NOT (k = ind)) => (tb2t(infix_at(complex1, int, t2tb12(t1), 
         t2tb5(k))) = c_zero))))
     => (ind_sum(t1, i, j) = tb2t(infix_at(complex1, int, t2tb12(t1), 
     t2tb5(ind)))))));

% ind_sum_null_but_maybe_two_elt
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), i : INT, j : INT, ind : INT,
  indqt : INT):
  (((i <= ind) AND (ind < j))
  => (((i <= indqt) AND (indqt < j))
     => ((NOT (ind = indqt))
        => ((FORALL (k : INT):
            (((i <= k) AND (k < j))
            => ((NOT (k = ind))
               => ((NOT (k = indqt)) => (tb2t(infix_at(complex1, int, 
                  t2tb12(t1), t2tb5(k))) = c_zero)))))
           => (ind_sum(t1, i, j) = infix_pldt(tb2t(infix_at(complex1, int, 
           t2tb12(t1), t2tb5(ind))), tb2t(infix_at(complex1, int, t2tb12(t1), 
           t2tb5(indqt))))))))));

fc93: ((ARRAY INT OF INT), (ARRAY INT OF complex)) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (g : (ARRAY INT OF INT), f : (ARRAY INT OF complex), k : INT): (
  tb2t(infix_at(complex1, int, t2tb12(fc93(g, f)), t2tb5(k))) = tb2t(
  infix_at(complex1, int, t2tb12(f), t2tb5((g[k]))))));

% ind_sum_map_filter
  ASSERT
  (FORALL (n : INT, nqt : INT, g : (ARRAY INT OF INT),
  f : (ARRAY INT OF complex), p : (ARRAY INT OF BITVECTOR(1))):
  (((0 <= nqt) AND (nqt <= n))
  => ((p_injective(int, int, t2tb7(g), t2tb6(to_fset(0, nqt))))
     => ((FORALL (k : INT):
         (((0 <= k) AND (k < n))
         => ((NOT (tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(k))) = 0bin1))
            => (tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(k))) = c_zero))))
        => ((FORALL (k : INT):
            (((0 <= k) AND (k < nqt)) => ((0 <= (g[k])) AND ((g[k]) < n))))
           => ((FORALL (k : INT):
               (((0 <= k) AND (k < n))
               => ((tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(k))) = 0bin1)
                  <=> (EXISTS (ant : INT):
                      (((0 <= ant) AND (ant < nqt)) AND (k = (g[ant])))))))
              => (ind_sum(f, 0, n) = ind_sum(fc93(g, f), 0, nqt))))))));

infix_asdt_closure: (ARRAY complex OF (ARRAY complex OF complex));

% infix *._closure_def
  ASSERT
  (FORALL (y : complex, y1 : complex): (tb2t(infix_at(complex1, complex1, 
  infix_at(infix_mngt(complex1, complex1), complex1, 
  t2tb11(infix_asdt_closure), t2tb(y)), t2tb(y1))) = infix_asdt(y, y1)));

% neutral_c_one
  ASSERT
  ((neutral(complex1, t2tb11(infix_asdt_closure), t2tb(c_one)))
  AND (iterable(complex1, t2tb11(infix_asdt_closure))));

% product_iter
  ASSERT
  ((op_neutral_left(complex1, t2tb11(infix_asdt_closure), t2tb(c_one)))
  AND (((op_neutral_right(complex1, t2tb11(infix_asdt_closure), t2tb(c_one)))
       AND (op_assoc(complex1, t2tb11(infix_asdt_closure))))
      AND ((commut(complex1, t2tb11(infix_asdt_closure)))
          AND (iterates(complex1, t2tb11(infix_asdt_closure), t2tb(c_one))))));

product: (ty, uni, uni) -> complex;

% product'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni): (product(a, s2, t1) = tb2t(iterate(complex1,
  a, t2tb11(infix_asdt_closure), s2, t1)))));

% product_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, tqt : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (tb2t(infix_at(complex1, a, t1, e)) = tb2t(
      infix_at(complex1, a, tqt, e))))))
  => (product(a, s2, t1) = product(a, s2, tqt)))));

% product_eq_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, t1 : uni, tqt : uni):
  ((s2 = sqt)
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (tb2t(infix_at(complex1, a, t1, e)) = tb2t(
         infix_at(complex1, a, tqt, e))))))
     => (product(a, s2, t1) = product(a, sqt, tqt))))));

% product_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((is_empty(a, s2)) => (product(a, s2, f) = c_one))));

% product_iter_
  ASSERT (iterable(complex1, t2tb11(infix_asdt_closure)));

% add_product
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, x : uni):
  ((NOT (mem(a, x, s2))) => (product(a, add(a, x, s2), f) = infix_asdt(tb2t(
  infix_at(complex1, a, f, x)), product(a, s2, f))))));

% product_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, x : uni):
  ((NOT (mem(a, x, s2))) => (product(a, add(a, x, s2), f) = infix_asdt(
  product(a, s2, f), tb2t(infix_at(complex1, a, f, x)))))));

% neutral_one
  ASSERT (tb2t(neutral_elt(complex1, t2tb11(infix_asdt_closure))) = c_one);

ind_product: ((ARRAY INT OF complex), INT, INT) -> complex;

% ind_product'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT): (ind_product(f, i,
  j) = tb2t(int_iterate(complex1, t2tb11(infix_asdt_closure), t2tb12(f), i,
  j))));

% ind_product_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : (ARRAY INT OF complex), i : INT,
  j : INT):
  ((FORALL (k : INT):
   (((i <= k) AND (k < j)) => (tb2t(infix_at(complex1, int, t2tb12(f), 
   t2tb5(k))) = tb2t(infix_at(complex1, int, t2tb12(g), t2tb5(k))))))
  => (ind_product(f, i, j) = ind_product(g, i, j))));

% ind_product_cardone
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((j = (i + 1)) => (ind_product(f, i, j) = tb2t(infix_at(complex1, int, 
  t2tb12(f), t2tb5(i))))));

% ind_product_eq_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), g : (ARRAY INT OF complex), i1 : INT,
  j1 : INT, i2 : INT, j2 : INT):
  ((FORALL (k : INT):
   (((i1 <= k) AND (k < j1)) => (tb2t(infix_at(complex1, int, t2tb12(f), 
   t2tb5(k))) = tb2t(infix_at(complex1, int, t2tb12(g), t2tb5(k))))))
  => ((i1 = i2)
     => ((j1 = j2) => (ind_product(f, i1, j1) = ind_product(g, i2, j2))))));

% ind_product_right_extension
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((i < j) => (ind_product(f, i, j) = infix_asdt(ind_product(f, i, (j - 1)), 
  tb2t(infix_at(complex1, int, t2tb12(f), t2tb5((j - 1))))))));

% ind_product_left_extension
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((i < j) => (ind_product(f, i, j) = infix_asdt(tb2t(infix_at(complex1, int, 
  t2tb12(f), t2tb5(i))), ind_product(f, (i + 1), j)))));

% ind_product_to_product
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT): (ind_product(f, i,
  j) = product(int, t2tb6(to_fset(i, j)), t2tb12(f))));

fc94: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, complex1), fc94(b, a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), t1 : (ARRAY angle OF complex), b : INT):
  (tb2t(infix_at(complex1, int, fc94(int, angle1, t2tb35(f), t2tb73(t1)), 
  t2tb5(b))) = tb2t(infix_at(complex1, angle1, t2tb73(t1), t2tb33((f[b]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF complex), b : INT): (
  tb2t(infix_at(complex1, int, fc94(int, int, t2tb7(f), t2tb12(t1)), 
  t2tb5(b))) = tb2t(infix_at(complex1, int, t2tb12(t1), t2tb5((f[b]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, t1 : uni, b1 : uni): (tb2t(infix_at(complex1, b, fc94(b,
  a, f, t1), b1)) = tb2t(infix_at(complex1, a, t1, infix_at(a, b, f, b1))))));

% map_product_eq
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni, t1 : uni):
  ((p_injective(a, b, f, s2)) => (product(a, map(a, b, f, s2), t1) = 
  product(b, s2, fc94(b, a, f, t1))))));

fc95: ((ARRAY INT OF INT), (ARRAY INT OF complex)) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF complex), b : INT): (
  tb2t(infix_at(complex1, int, t2tb12(fc95(f, t1)), t2tb5(b))) = tb2t(
  infix_at(complex1, int, t2tb12(t1), t2tb5((f[b]))))));

% map_ind_product_eq
  ASSERT
  (FORALL (i : INT, j : INT, k : INT, l : INT, f : (ARRAY INT OF INT),
  t1 : (ARRAY INT OF complex)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(i, j)), t2tb6(to_fset(k,
  l)))) => (ind_product(t1, k, l) = ind_product(fc95(f, t1), i, j))));

% ind_product_right_extension_comm
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((i < j) => (infix_asdt(ind_product(f, i, (j - 1)), tb2t(infix_at(complex1,
  int, t2tb12(f), t2tb5((j - 1))))) = ind_product(f, i, j))));

set_complex: TYPE;

t2tb16: (set_complex) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : set_complex): (sort(set(complex1), t2tb16(x))));

tb2t16: (uni) -> set_complex;

% BridgeL
  ASSERT
  (FORALL (i : set_complex):PATTERN (t2tb16(i)):  (tb2t16(t2tb16(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb16(tb2t16(j))): 
  ((sort(set(complex1), j)) => (t2tb16(tb2t16(j)) = j)));

% ind_product_eq_func
  ASSERT
  (FORALL (i : INT, j : INT, f1 : (ARRAY INT OF complex),
  f2 : (ARRAY INT OF complex)):
  ((p_injective(complex1, int, t2tb12(f1), t2tb6(to_fset(i, j))))
  => ((p_injective(complex1, int, t2tb12(f2), t2tb6(to_fset(i, j))))
     => ((tb2t16(map(complex1, int, t2tb12(f1), t2tb6(to_fset(i, j)))) = 
        tb2t16(map(complex1, int, t2tb12(f2), t2tb6(to_fset(i, j))))) => (
        ind_product(f1, i, j) = ind_product(f2, i, j))))));

% ind_product_trans
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, k : INT, j : INT):
  (((i <= k) AND (k <= j)) => (ind_product(f, i, j) = infix_asdt(
  ind_product(f, i, k), ind_product(f, k, j)))));

% ind_product_zero_pre
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, t1 : INT, j : INT):
  (((i <= t1) AND (t1 < j))
  => ((tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(t1))) = c_zero) => (
     ind_product(f, i, j) = c_zero))));

% ind_product_zero
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((i <= j)
  => ((EXISTS (t1 : INT):
      (((i <= t1) AND (t1 < j)) AND (tb2t(infix_at(complex1, int, t2tb12(f), 
      t2tb5(t1))) = c_zero)))
     => (ind_product(f, i, j) = c_zero))));

% ind_product_zero_elt
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT, t1 : INT):
  ((i <= j)
  => (((i <= t1) AND (t1 < j))
     => ((tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(t1))) = c_zero) => (
        ind_product(f, i, j) = c_zero)))));

% ind_product_const_c_one
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), i : INT, j : INT):
  ((i <= j)
  => ((FORALL (t1 : INT):
      (((i <= t1) AND (t1 < j)) => (tb2t(infix_at(complex1, int, t2tb12(f), 
      t2tb5(t1))) = c_one)))
     => (ind_product(f, i, j) = c_one))));

fc96: (ty, ty, uni, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(a, complex1), 
  fc96(b, a, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, p : uni, f : uni, l : uni): (tb2t(infix_at(complex1, a, 
  fc96(b, a, s2, p, f), l)) = sum(b, my_filter(b, s2, infix_at(infix_mngt(b,
  bool), a, p, l)), f))));

% sum_filter_decomp
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, s21 : uni, p : uni, p1 : uni, f : uni):
  ((FORALL (e : uni):
   ((sort(b, e))
   => ((mem(b, e, s21))
      => (((tb2t2(infix_at(bool, b, p1, e)) = 0bin1)
          OR (EXISTS (eqt : uni):
             ((sort(a, eqt))
             AND ((mem(a, eqt, s2)) AND (tb2t2(infix_at(bool, b, infix_at(
                 infix_mngt(b, bool), a, p, eqt), e)) = 0bin1)))))
         => ((tb2t2(infix_at(bool, b, p1, e)) = 0bin1)
            AND (EXISTS (eqt : uni):
                ((mem(a, eqt, s2)) AND (tb2t2(infix_at(bool, b, infix_at(
                infix_mngt(b, bool), a, p, eqt), e)) = 0bin1))))))))
  => ((FORALL (e : uni):
      ((sort(b, e))
      => (FORALL (eqt : uni, eqtqt : uni):
         ((sort(a, eqt))
         => ((sort(a, eqtqt))
            => ((mem(b, e, s21))
               => ((tb2t2(infix_at(bool, b, p1, e)) = 0bin1)
                  => ((mem(a, eqt, s2))
                     => ((mem(a, eqtqt, s2))
                        => ((tb2t2(infix_at(bool, b, infix_at(infix_mngt(b,
                           bool), a, p, eqt), e)) = 0bin1)
                           => ((tb2t2(infix_at(bool, b, infix_at(
                              infix_mngt(b, bool), a, p, eqtqt), e)) = 0bin1)
                              => (eqt = eqtqt))))))))))))
     => (sum(a, s2, fc96(b, a, s21, p, f)) = sum(b, my_filter(b, s21, p1),
     f))))));

% ind_sum_constant
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), valu : complex, i : INT, j : INT):
  ((i <= j)
  => ((FORALL (k : INT):
      (((i <= k) AND (k < j)) => (tb2t(infix_at(complex1, int, t2tb12(f), 
      t2tb5(k))) = valu)))
     => (ind_sum(f, i, j) = infix_asdt(valu, i_to_c((j - i)))))));

% ind_sum_constant_from_z
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), valu : complex, j : INT):
  ((0 <= j)
  => ((FORALL (k : INT):
      (((0 <= k) AND (k < j)) => (tb2t(infix_at(complex1, int, t2tb12(f), 
      t2tb5(k))) = valu)))
     => (ind_sum(f, 0, j) = infix_asdt(valu, i_to_c(j))))));

% sum_constant_lower_bound
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, x : complex):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (real_(tb2t(infix_at(complex1, a, t1, e)))))))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (infix_lseqdt(tb2t(infix_at(complex1, a, t1,
         e)), x)))))
     => ((real_(x)) => (infix_lseqdt(sum(a, s2, t1), infix_asdt(i_to_c(
        cardinal(a, s2)), x))))))));

% sum_inf
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, tqt : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (real_(tb2t(infix_at(complex1, a, t1, e)))))))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (real_(tb2t(infix_at(complex1, a, tqt, e)))))))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (infix_lseqdt(tb2t(infix_at(complex1, a, t1,
            e)), tb2t(infix_at(complex1, a, tqt, e)))))))
        => (infix_lseqdt(sum(a, s2, t1), sum(a, s2, tqt))))))));

% sum_constant
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, x : complex):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (tb2t(infix_at(complex1, a, t1, e)) = x))))
  => (sum(a, s2, t1) = infix_asdt(i_to_c(cardinal(a, s2)), x)))));

% ind_sum_constant_case
  ASSERT
  (FORALL (n : INT, t1 : (ARRAY INT OF complex),
  p : (ARRAY INT OF BITVECTOR(1)), x : complex, y : complex, k1 : INT):
  ((0 <= n)
  => ((cardinal(int, my_filter(int, t2tb6(to_fset(0, n)), t2tb9(p))) = k1)
     => ((FORALL (e : INT):
         (((0 <= e) AND (e < n))
         => ((tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(e))) = 0bin1) => (
            tb2t(infix_at(complex1, int, t2tb12(t1), t2tb5(e))) = x))))
        => ((FORALL (e : INT):
            (((0 <= e) AND (e < n))
            => ((NOT (tb2t2(infix_at(bool, int, t2tb9(p), 
                t2tb5(e))) = 0bin1))
               => (tb2t(infix_at(complex1, int, t2tb12(t1), t2tb5(e))) = y))))
           => (ind_sum(t1, 0, n) = infix_pldt(infix_asdt(i_to_c(k1), x), 
           infix_asdt(i_to_c((n - k1)), y))))))));

% sum_const_one
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (tb2t(infix_at(complex1, a, t1, e)) = c_one))))
  => (sum(a, s2, t1) = i_to_c(cardinal(a, s2))))));

% abs_eqinf
  ASSERT
  (FORALL (x : INT, y : INT):
  (((x <= y) AND (y <= 0)) => (abs(y) <= abs(x))));

% abs_inf
  ASSERT
  (FORALL (x : INT, y : INT):
  (((0 < x) AND ((x < y) AND (y <= 0))) => (abs(y) < abs(x))));

% abs_eqsup
  ASSERT
  (FORALL (x : INT, y : INT):
  (((x <= 0) AND (y <= x)) => (abs(x) <= abs(y))));

% abs_sup
  ASSERT
  (FORALL (x : INT, y : INT): (((x <= 0) AND (y < x)) => (abs(x) < abs(y))));

% inv_negeq
  ASSERT (FORALL (x : INT): ((x <= 0) => (0 <= abs(x))));

% inv_neg
  ASSERT (FORALL (x : INT): ((x < 0) => (0 < abs(x))));

cpower: (complex, INT) -> complex;

% Cpower_zero
  ASSERT (FORALL (i : complex): (cpower(i, 0) = c_one));

% Cpower_one
  ASSERT (FORALL (i : complex): (cpower(i, 1) = i));

% Cpower_sum
  ASSERT
  (FORALL (i : complex):
  (FORALL (n : INT, m : INT):
  (((i = c_zero) => (NOT (n = (- m)))) => (cpower(i, (n + m)) = infix_asdt(
  cpower(i, n), cpower(i, m))))));

% zero_poower
  ASSERT (FORALL (e : INT): ((NOT (e = 0)) => (cpower(c_zero, e) = c_zero)));

% cpower_ttwo_two
  ASSERT (cpower(infix_pldt(c_one, c_one), 2) = i_to_c(4));

% real_squarert_two
  ASSERT (real_(square_rt(infix_pldt(c_one, c_one))));

% squarertTwo
  ASSERT (cpower(square_rt(infix_pldt(c_one, c_one)), 2) = infix_pldt(c_one,
  c_one));

% complete_rt_two
  ASSERT
  (FORALL (a : complex):
  ((a = infix_sldt(square_rt(infix_pldt(c_one, c_one)), infix_pldt(c_one,
  c_one))) => (infix_asdt(square_rt(infix_pldt(c_one, c_one)), a) = c_one)));

% cpower_sum
  ASSERT
  (FORALL (x : complex, n : INT, m : INT):
  (((x = c_zero) => (NOT (n = (- m)))) => (cpower(x, (n + m)) = infix_asdt(
  cpower(x, n), cpower(x, m)))));

% cpower_one
  ASSERT (FORALL (x : complex, n : INT): ((n = 1) => (cpower(x, n) = x)));

% cpower_two
  ASSERT
  (FORALL (x : complex, n : INT):
  ((n = 2) => (cpower(x, n) = infix_asdt(x, x))));

% cpower_two_rev
  ASSERT (FORALL (x : complex): (infix_asdt(x, x) = cpower(x, 2)));

% cpower_sum_rev
  ASSERT
  (FORALL (x : complex, n : INT, m : INT):
  (((x = c_zero) => (NOT (n = (- m)))) => (infix_asdt(cpower(x, n), cpower(x,
  m)) = cpower(x, (n + m)))));

% cpower_plus_one
  ASSERT
  (FORALL (e : complex, i : INT):
  (((e = c_zero) => (NOT (i = (- 1)))) => (cpower(e, (i + 1)) = infix_asdt(
  cpower(e, i), e))));

% cpower_zero
  ASSERT (FORALL (e : complex): (cpower(e, 0) = c_one));

% cpower_eq
  ASSERT
  (FORALL (e : complex, eqt : complex, i : INT, iqt : INT):
  ((e = eqt) => ((i = iqt) => (cpower(e, i) = cpower(eqt, iqt)))));

% cpower_inv
  ASSERT
  (FORALL (e : complex, i : INT):
  ((NOT (e = c_zero)) => (infix_asdt(cpower(e, i), cpower(e,
  (- i))) = c_one)));

% compat_cpower_leq
  ASSERT
  (FORALL (a : complex, b : complex, i : INT):
  (((infix_lseqdt(c_zero, a)) AND (infix_lseqdt(a, b)))
  => ((0 <= i)
     => ((infix_lseqdt(c_zero, cpower(a, i))) AND (infix_lseqdt(cpower(a, i), 
        cpower(b, i)))))));

% cpower_inv_rew
  ASSERT
  (FORALL (e : complex, i : INT):
  ((NOT (e = c_zero)) => (cpower(e, i) = infix_sldt(c_one, cpower(e,
  (- i))))));

% inv_cpower
  ASSERT
  (FORALL (e : complex, i : INT):
  ((NOT (cpower(e, i) = c_zero)) => (infix_sldt(c_one, cpower(e, i)) = 
  cpower(e, (- i)))));

% cpower_div
  ASSERT
  (FORALL (x : complex, y : complex, n : INT):
  ((0 <= n)
  => ((NOT (y = c_zero)) => (cpower(infix_sldt(x, y), n) = infix_sldt(
     cpower(x, n), cpower(y, n))))));

% cpower_div_rev
  ASSERT
  (FORALL (x : complex, y : complex, n : INT):
  ((0 <= n)
  => ((NOT (y = c_zero)) => (infix_sldt(cpower(x, n), cpower(y, n)) = cpower(
     infix_sldt(x, y), n)))));

% cpower_pi_bound_square_inv
  ASSERT (infix_lseqdt(infix_sldt(i_to_c(4), cpower(pi, 2)), c_one));

% cpower_mult_split
  ASSERT
  (FORALL (x : complex, y : complex, m : INT):
  ((0 <= m) => (cpower(infix_asdt(x, y), m) = infix_asdt(cpower(x, m), 
  cpower(y, m)))));

% not_cpower_zero
  ASSERT
  (FORALL (e : complex, i : INT):
  ((NOT (e = c_zero)) => (NOT (cpower(e, i) = c_zero))));

% cpower_inv_out
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(c_zero, y)) => (infix_asdt(cpower(infix_asdt(infix_sldt(c_one, 
  square_rt(y)), x), 2), y) = cpower(x, 2))));

% squarert_inv
  ASSERT
  (FORALL (x : complex):
  ((infix_lsdt(c_zero, x)) => (infix_sldt(c_one, square_rt(x)) = square_rt(
  infix_sldt(c_one, x)))));

% squarert_inv_rev
  ASSERT
  (FORALL (x : complex):
  ((infix_lsdt(c_zero, x)) => (square_rt(infix_sldt(c_one, x)) = 
  infix_sldt(c_one, square_rt(x)))));

% squarert_div
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lseqdt(c_zero, x))
  => ((infix_lsdt(c_zero, y)) => (infix_sldt(square_rt(x), square_rt(y)) = 
     square_rt(infix_sldt(x, y))))));

% cpower_squarert_two
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (cpower(square_rt(infix_pldt(c_one, c_one)), i) = square_rt(
  i_to_c(power(2, i))))));

% cpower_square_rt_raise
  ASSERT
  (FORALL (x : complex, y : complex):
  ((infix_lsdt(c_zero, y)) => (cpower(infix_sldt(x, square_rt(y)), 2) = 
  infix_sldt(infix_asdt(cpower(x, 2), c_one), y))));

% cpower_subst
  ASSERT
  (FORALL (x : complex, n : INT, m : INT):
  ((NOT (x = c_zero)) => (infix_asdt(infix_sldt(c_one, cpower(x, n)), 
  cpower(x, m)) = cpower(x, (m - n)))));

% cpower_c_one_pos
  ASSERT (FORALL (m : INT): ((0 <= m) => (cpower(c_one, m) = c_one)));

% mult_cpower
  ASSERT
  (FORALL (x : complex, xqt : complex, i : INT):
  ((0 <= i) => (infix_asdt(cpower(x, i), cpower(xqt, i)) = cpower(
  infix_asdt(x, xqt), i))));

% mult_cpower_rev
  ASSERT
  (FORALL (x : complex, xqt : complex, i : INT):
  ((0 <= i) => (cpower(infix_asdt(x, xqt), i) = infix_asdt(cpower(x, i), 
  cpower(xqt, i)))));

fc744: (ARRAY complex OF (ARRAY INT OF complex));

t2tb17: ((ARRAY complex OF (ARRAY INT OF complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY complex OF (ARRAY INT OF complex))): (sort(
  infix_mngt(complex1, infix_mngt(int, complex1)), t2tb17(x))));

tb2t17: (uni) -> (ARRAY complex OF (ARRAY INT OF complex));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY complex OF (ARRAY INT OF complex))):PATTERN (
  t2tb17(i)):  (tb2t17(t2tb17(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb17(tb2t17(j))): 
  ((sort(infix_mngt(complex1, infix_mngt(int, complex1)), j)) => (t2tb17(
  tb2t17(j)) = j)));

% fc'def
  ASSERT
  (FORALL (y0 : complex, y1 : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), complex1, t2tb17(fc744), t2tb(y0)), 
  t2tb5(y1))) = y0));

% cpower_iterate
  ASSERT
  (FORALL (e : complex, i : INT):
  ((0 <= i) => (cpower(e, i) = tb2t(int_iterate(complex1, 
  t2tb11(infix_asdt_closure), infix_at(infix_mngt(int, complex1), complex1, 
  t2tb17(fc744), t2tb(e)), 0, i)))));

% cpower_modulus
  ASSERT
  (FORALL (x : complex, n : INT):
  ((0 <= n)
  => ((modulus(cpower(x, n)) = cpower(modulus(x), n))
     AND (((0 < n)
          => ((infix_lsdt(modulus(x), c_one)) => (infix_lsdt(modulus(
             cpower(x, n)), c_one))))
         AND (((0 < n)
              => ((modulus(x) = c_one) => (modulus(cpower(x, n)) = c_one)))
             AND (((0 < n)
                  => ((infix_gtdt(modulus(x), c_one)) => (infix_gtdt(modulus(
                     cpower(x, n)), c_one))))
                 AND (((0 < n)
                      => ((infix_lsdt(modulus(cpower(x, n)), c_one))
                         => (infix_lsdt(modulus(x), c_one))))
                     AND (((0 < n)
                          => ((modulus(cpower(x, n)) = c_one) => (
                             modulus(x) = c_one)))
                         AND ((0 < n)
                             => ((infix_gtdt(modulus(cpower(x, n)), c_one))
                                => (infix_gtdt(modulus(x), c_one))))))))))));

% cpower_mult_pre
  ASSERT
  (FORALL (x : complex, n : INT, m : INT):
  ((0 <= m) => (cpower(x, (n * m)) = cpower(cpower(x, n), m))));

% cpower_mult
  ASSERT
  (FORALL (x : complex, n : INT, m : INT): (cpower(x, (n * m)) = cpower(
  cpower(x, n), m)));

% cpower_mult_rev
  ASSERT
  (FORALL (x : complex, n : INT, m : INT): (cpower(cpower(x, n), m) = 
  cpower(x, (n * m))));

% non_zero_cpower_pos
  ASSERT
  (FORALL (i : complex, n : INT):
  ((NOT (i = c_zero)) => ((0 <= n) => (NOT (cpower(i, n) = c_zero)))));

% inv_cpower_
  ASSERT
  (FORALL (e : complex, i : INT):
  ((NOT (e = c_zero)) => (infix_sldt(c_one, cpower(e, i)) = cpower(e,
  (- i)))));

% zero_cpower_pos
  ASSERT (FORALL (n : INT): ((0 < n) => (cpower(c_zero, n) = c_zero)));

% zero_cpower
  ASSERT (FORALL (n : INT): ((NOT (n = 0)) => (cpower(c_zero, n) = c_zero)));

% non_zero_cpower
  ASSERT
  (FORALL (i : complex, n : INT):
  ((NOT (i = c_zero)) => (NOT (cpower(i, n) = c_zero))));

% real_cpower_pos
  ASSERT
  (FORALL (elt : complex, i : INT):
  ((real_(elt)) => ((0 <= i) => (real_(cpower(elt, i))))));

% real_cpower
  ASSERT
  (FORALL (elt : complex, i : INT):
  ((real_(elt)) => (real_(cpower(elt, i)))));

% real_cpower_is_pos
  ASSERT
  (FORALL (elt : complex, i : INT):
  ((real_(elt))
  => ((infix_lseqdt(c_zero, elt))
     => ((0 <= i) => (infix_lseqdt(c_zero, cpower(elt, i)))))));

% real_cpower_is_strict_pos
  ASSERT
  (FORALL (elt : complex, i : INT):
  ((real_(elt))
  => ((infix_lsdt(c_zero, elt))
     => ((0 <= i) => (infix_lsdt(c_zero, cpower(elt, i)))))));

% real_modulus_square
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (cpower(modulus(x), 2) = cpower(x, 2))));

% real_modulus_pos
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => ((infix_lseqdt(c_zero, x)) => (modulus(x) = x))));

conjugate: (complex) -> complex;

% conjugate'def
  ASSERT
  (FORALL (i : complex): (conjugate(i) = infix_mndt(t_real_part(i), 
  infix_asdt(im, t_im_part(i)))));

% real_part_conjugate
  ASSERT
  (FORALL (i : complex): (t_real_part(conjugate(i)) = t_real_part(i)));

% im_part_conjugate
  ASSERT
  (FORALL (i : complex): (t_im_part(conjugate(i)) = prefix_mndt(
  t_im_part(i))));

% invol_conjugate
  ASSERT (FORALL (i : complex): (conjugate(conjugate(i)) = i));

% add_conjugate
  ASSERT
  (FORALL (i : complex, j : complex): (conjugate(infix_pldt(i, j)) = 
  infix_pldt(conjugate(i), conjugate(j))));

% add_own_conjugate
  ASSERT
  (FORALL (i : complex): (infix_pldt(i, conjugate(i)) = infix_asdt(
  infix_pldt(c_one, c_one), t_real_part(i))));

% itself_times_conjugate
  ASSERT
  (FORALL (i : complex):
  ((real_(infix_asdt(i, conjugate(i)))) AND (infix_asdt(i, conjugate(i)) = 
  infix_pldt(infix_asdt(t_real_part(i), t_real_part(i)), infix_asdt(
  t_im_part(i), t_im_part(i))))));

% conjugate_to_modulus
  ASSERT
  (FORALL (i : complex): (modulus(i) = square_rt(infix_asdt(i, 
  conjugate(i)))));

% conjugate_times_itself_pos
  ASSERT
  (FORALL (i : complex): (infix_lseqdt(c_zero, infix_asdt(i, conjugate(i)))));

fc98: (ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni): (sort(infix_mngt(a, complex1), fc98(a, x)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, x : uni): (tb2t(infix_at(complex1, a, fc98(a, f), x)) = 
  conjugate(tb2t(infix_at(complex1, a, f, x))))));

% sum_conjugate
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni): (conjugate(sum(a, s2, f)) = sum(a, s2, fc98(a,
  f)))));

% conjugate_module_one
  ASSERT
  (FORALL (i : complex): ((modulus(i) = c_one) => (conjugate(i) = inv(i))));

% conjugate_module_one_rev
  ASSERT
  (FORALL (i : complex):
  ((NOT (i = c_zero)) => ((conjugate(i) = inv(i)) => (modulus(i) = c_one))));

% conjugate_real
  ASSERT (FORALL (i : complex): ((real_(i)) => (conjugate(i) = i)));

% conjugate_real_gen
  ASSERT (FORALL (i : complex): ((real_(i)) => (conjugate(i) = i)));

% conjugate_one
  ASSERT (FORALL (x : complex): ((x = c_one) => (conjugate(x) = c_one)));

% conjugate_c_zero
  ASSERT (FORALL (x : complex): ((x = c_zero) => (conjugate(x) = c_zero)));

indic: (ty, uni, uni) -> complex;

% indic'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, aqt : uni):
  (IF (infix_eqeq(a, a1, aqt)) THEN (indic(a, a1, aqt) = c_one) ELSE (
  indic(a, a1, aqt) = c_zero) ENDIF)));

% indic'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, aqt : uni):
  ((sort(a, a1))
  => ((sort(a, aqt)) => (indic(a, a1,
     aqt) = (IF (a1 = aqt) THEN c_one ELSE c_zero ENDIF))))));

% get_indic
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, aqt : uni):
  ((sort(a, a1))
  => ((sort(a, aqt)) => (indic(a, a1,
     aqt) = (IF (a1 = aqt) THEN c_one ELSE c_zero ENDIF))))));

indic_bool: (ty, uni, uni) -> BITVECTOR(1);

% indic_bool'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, aqt : uni):
  (IF (infix_eqeq(a, a1, aqt)) THEN (indic_bool(a, a1, aqt) = 0bin1) ELSE (
  indic_bool(a, a1, aqt) = 0bin0) ENDIF)));

% indic_bool'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, aqt : uni):
  ((sort(a, a1))
  => ((sort(a, aqt)) => (indic_bool(a, a1,
     aqt) = (IF (a1 = aqt) THEN 0bin1 ELSE 0bin0 ENDIF))))));

% indic_comm
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, aqt : uni): (indic(a, a1, aqt) = indic(a, aqt, a1))));

% indic_transl_r
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, b : uni, c : uni):
  ((b = c) => (indic(a, a1, b) = indic(a, a1, c)))));

% indic_transl_l
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, b : uni, c : uni):
  ((b = c) => (indic(a, b, a1) = indic(a, c, a1)))));

indic_2: (ty, ty, uni, uni, uni, uni) -> complex;

% indic_2'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, aqt : uni, b1 : uni, bqt : uni):
  (IF ((indic_bool(a, a1, aqt) = 0bin1) AND (indic_bool(b, b1, bqt) = 0bin1))
  THEN (indic_2(b, a, a1, aqt, b1, bqt) = c_one) ELSE (indic_2(b, a, a1, aqt,
  b1, bqt) = c_zero) ENDIF)));

% indic_2'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, aqt : uni, b1 : uni, bqt : uni):
  ((indic_2(b, a, a1, aqt, b1, bqt) = infix_asdt(indic(a, a1, aqt), indic(b,
  b1, bqt))) AND (indic_2(b, a, a1, aqt, b1, bqt) = indic(tuple2(a, b), 
  Tuple2(a, b, a1, b1), Tuple2(a, b, aqt, bqt))))));

% indic_2_if
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (i : uni, k : uni, j : uni, l : uni):
  ((sort(a, i))
  => ((sort(a, k))
     => ((sort(b, j))
        => ((sort(b, l)) => (indic_2(b, a, i, k, j,
           l) = (IF ((i = k) AND (j = l)) THEN c_one ELSE c_zero ENDIF))))))));

% indic_2_comm
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (a1 : uni, aqt : uni, b1 : uni, bqt : uni):
  ((indic_2(b, a, a1, aqt, b1, bqt) = indic_2(b, a, aqt, a1, b1, bqt))
  AND ((indic_2(b, a, a1, aqt, b1, bqt) = indic_2(b, a, a1, aqt, bqt, b1))
      AND (indic_2(b, a, a1, aqt, b1, bqt) = indic_2(b, a, aqt, a1, bqt,
      b1))))));

sum_indic: (ty, uni, uni, uni) -> complex;

result4: (ty, uni, uni) -> uni;

% result_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), result4(a, x,
  x1)))));

% result'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (t1 : uni, i : uni, e : uni): (tb2t(infix_at(complex1, a, 
  result4(a, t1, i), e)) = infix_asdt(tb2t(infix_at(complex1, a, t1, e)), 
  indic(a, i, e)))));

% sum_indic'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, i : uni): (sum_indic(a, s2, t1, i) = sum(a,
  s2, result4(a, t1, i)))));

bool_to_c: (BITVECTOR(1)) -> complex;

% bool_to_c'def
  ASSERT
  (FORALL (a : BITVECTOR(1)):
  (IF (a = 0bin1) THEN (bool_to_c(a) = c_one) ELSE (
  bool_to_c(a) = c_zero) ENDIF));

ind_sum_indic: ((ARRAY INT OF complex), INT, INT, INT) -> complex;

result5: ((ARRAY INT OF complex), INT) -> (ARRAY INT OF complex);

% result'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), i : INT, e : INT): (tb2t(
  infix_at(complex1, int, t2tb12(result5(t1, i)), t2tb5(e))) = infix_asdt(
  tb2t(infix_at(complex1, int, t2tb12(t1), t2tb5(e))), indic(int, t2tb5(i), 
  t2tb5(e)))));

% ind_sum_indic'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), l : INT, h : INT, i : INT):
  ((l < h) => (ind_sum_indic(t1, l, h, i) = ind_sum(result5(t1, i), l, h))));

% ind_sum_indic'spec
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), l : INT, h : INT, i : INT):
  ((l < h) => (ind_sum_indic(t1, l, h, i) = sum_indic(int, t2tb6(to_fset(l,
  h)), t2tb12(t1), t2tb5(i)))));

% sum_indic_t
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, i : uni):
  ((mem(a, i, s2)) => (sum_indic(a, s2, t1, i) = tb2t(infix_at(complex1, a,
  t1, i))))));

fc99: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, complex1), fc99(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (t1 : uni, i : uni, e : uni): (tb2t(infix_at(complex1, a, fc99(a,
  t1, i), e)) = infix_asdt(tb2t(infix_at(complex1, a, t1, e)), indic(a, i,
  e)))));

% sum_indic_ts
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, t1 : uni, i : uni):
  ((mem(a, i, s2)) => (sum(a, s2, fc99(a, t1, i)) = tb2t(infix_at(complex1,
  a, t1, i))))));

fc100: ((ARRAY INT OF complex), INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), i : INT, e : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc100(t1, i)), t2tb5(e))) = infix_asdt(tb2t(
  infix_at(complex1, int, t2tb12(t1), t2tb5(e))), indic(int, t2tb5(i), 
  t2tb5(e)))));

% ind_sum_indic_t
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), l : INT, h : INT, i : INT):
  (((l <= i) AND (i < h))
  => ((ind_sum_indic(t1, l, h, i) = tb2t(infix_at(complex1, int, t2tb12(t1), 
     t2tb5(i)))) AND (ind_sum(fc100(t1, i), l, h) = tb2t(infix_at(complex1,
     int, t2tb12(t1), t2tb5(i)))))));

fc101: ((ARRAY INT OF complex), INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), i : INT, e : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc101(t1, i)), t2tb5(e))) = infix_asdt(tb2t(
  infix_at(complex1, int, t2tb12(t1), t2tb5(e))), indic(int, t2tb5(i), 
  t2tb5(e)))));

% ind_sum_indic_t_quant
  ASSERT
  (FORALL (t1 : (ARRAY INT OF complex), l : INT, h : INT):
  (FORALL (i : INT):
  (((l <= i) AND (i < h)) => (ind_sum(fc101(t1, i), l, h) = tb2t(
  infix_at(complex1, int, t2tb12(t1), t2tb5(i)))))));

% conjugate_indic
  ASSERT
  (FORALL (a : ty):
  (FORALL (i : uni, j : uni): (conjugate(indic(a, i, j)) = indic(a, i, j))));

% conjugate_indic_rev
  ASSERT
  (FORALL (a : ty):
  (FORALL (i : uni, j : uni): (indic(a, i, j) = conjugate(indic(a, i, j)))));

% conjugate_indic_gen_int
  ASSERT
  (FORALL (i : INT, j : INT): (conjugate(indic(int, t2tb5(i), t2tb5(j))) = 
  indic(int, t2tb5(i), t2tb5(j))));

% conjugate_pure_im
  ASSERT
  (FORALL (i : complex): ((pure_im_(i)) => (conjugate(i) = prefix_mndt(i))));

% conjugate_im
  ASSERT (conjugate(im) = prefix_mndt(im));

% conjugate_value
  ASSERT
  (FORALL (c : complex, a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((c = infix_pldt(a, infix_asdt(im, b))) => (conjugate(c) = 
        infix_mndt(a, infix_asdt(im, b)))))));

% conjugate_minus_value
  ASSERT
  (FORALL (c : complex, a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((c = infix_mndt(a, infix_asdt(im, b))) => (conjugate(c) = 
        infix_pldt(a, infix_asdt(im, b)))))));

% prod_conjugate
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(a, conjugate(b)) = 
  infix_pldt(infix_pldt(infix_asdt(t_real_part(a), t_real_part(b)), 
  infix_asdt(t_im_part(a), t_im_part(b))), infix_asdt(im, infix_mndt(
  infix_asdt(t_real_part(b), t_im_part(a)), infix_asdt(t_im_part(b), 
  t_real_part(a)))))));

% mult_conjugate
  ASSERT
  (FORALL (a : complex, b : complex): (conjugate(infix_asdt(a, b)) = 
  infix_asdt(conjugate(a), conjugate(b))));

% conjugate_prod
  ASSERT
  (FORALL (a : complex, b : complex): (infix_asdt(conjugate(a), b) = 
  infix_pldt(infix_pldt(infix_asdt(t_real_part(a), t_real_part(b)), 
  infix_asdt(t_im_part(a), t_im_part(b))), infix_asdt(im, infix_mndt(
  infix_asdt(t_real_part(a), t_im_part(b)), infix_asdt(t_real_part(b), 
  t_im_part(a)))))));

% conj_conj_prod
  ASSERT
  (FORALL (a : complex, b : complex): (conjugate(infix_asdt(conjugate(a),
  b)) = infix_asdt(a, conjugate(b))));

% conj_prod_conj
  ASSERT
  (FORALL (a : complex, b : complex): (conjugate(infix_asdt(a, 
  conjugate(b))) = infix_asdt(conjugate(a), b)));

% itself_prod_conjugate_modulus_one
  ASSERT
  (FORALL (a : complex):
  ((modulus(a) = c_one) => (infix_asdt(a, conjugate(a)) = c_one)));

% conjugate_prod_itself_modulus_one
  ASSERT
  (FORALL (a : complex):
  ((modulus(a) = c_one) => (infix_asdt(a, conjugate(a)) = c_one)));

% modulus_opposite
  ASSERT
  (FORALL (a : complex):
  ((real_(a))
  => ((infix_lseqdt(c_zero, a)) => (modulus(a) = modulus(prefix_mndt(a))))));

% modulus_conjugate
  ASSERT (FORALL (a : complex): (modulus(a) = modulus(conjugate(a))));

% modulus_pos
  ASSERT
  (FORALL (a : complex):
  ((real_(a)) => ((infix_lseqdt(c_zero, a)) => (modulus(a) = a))));

% modulus_neg
  ASSERT
  (FORALL (a : complex):
  ((real_(a))
  => ((infix_lseqdt(a, c_zero)) => (modulus(a) = prefix_mndt(a)))));

% inv_rewrite
  ASSERT
  (FORALL (x : complex):
  ((NOT (x = c_zero))
  => ((infix_sldt(c_one, x) = infix_sldt(conjugate(x), cpower(modulus(x),
     2))) AND (infix_sldt(c_one, x) = infix_asdt(conjugate(x), 
     infix_sldt(c_one, cpower(modulus(x), 2)))))));

% inv_modulus
  ASSERT
  (FORALL (x : complex):
  ((NOT (x = c_zero)) => (modulus(infix_sldt(c_one, x)) = infix_sldt(c_one, 
  modulus(x)))));

% div_modulus
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (x = c_zero)) => (modulus(infix_sldt(y, x)) = infix_sldt(modulus(y), 
  modulus(x)))));

% square_frac_modulus
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (y = c_zero)) => (cpower(modulus(infix_sldt(x, y)), 2) = infix_sldt(
  cpower(modulus(x), 2), cpower(modulus(y), 2)))));

% modulus_one_gen
  ASSERT
  (FORALL (a : complex, b : complex):
  ((infix_lseqdt(c_zero, a))
  => ((infix_lseqdt(c_zero, b))
     => ((infix_pldt(cpower(a, 2), cpower(b, 2)) = c_one) => (modulus(
        infix_pldt(a, infix_asdt(im, b))) = c_one)))));

% modulus_one_decomp
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < power(2, n))) => (modulus(infix_pldt(infix_sldt(
  square_rt(i_to_c((power(2, n) - k))), square_rt(i_to_c(power(2, n)))), 
  infix_asdt(im, infix_sldt(square_rt(i_to_c(k)), square_rt(i_to_c(power(2,
  n))))))) = c_one)));

% extract_2_sq_modulus
  ASSERT
  (FORALL (x : complex, y : complex, a : complex):
  ((NOT (a = c_zero))
  => ((NOT (y = c_zero)) => (infix_sldt(cpower(modulus(x), 2), cpower(
     modulus(y), 2)) = infix_sldt(infix_asdt(a, cpower(modulus(x), 2)), 
     infix_asdt(a, cpower(modulus(y), 2)))))));

% cpower_2_modulus_simpl
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((NOT (x = c_zero))
  => ((NOT (y = c_zero))
     => ((NOT (z = c_zero)) => (infix_sldt(cpower(modulus(infix_asdt(x, y)),
        2), cpower(modulus(infix_asdt(z, y)), 2)) = infix_sldt(cpower(
        modulus(x), 2), cpower(modulus(z), 2)))))));

% cpower_div_leq_one
  ASSERT
  (FORALL (a : complex, b : complex, i : INT):
  (((infix_lseqdt(c_zero, a)) AND (infix_lseqdt(a, b)))
  => ((infix_lsdt(c_zero, b))
     => ((0 <= i)
        => ((infix_lseqdt(c_zero, infix_sldt(cpower(a, i), cpower(b, i))))
           AND (infix_lseqdt(infix_sldt(cpower(a, i), cpower(b, i)), c_one)))))));

% cpower_cpower
  ASSERT
  (FORALL (x : complex, a : INT, b : INT): (cpower(cpower(x, a), b) = 
  cpower(x, (a * b))));

% pre_cond_int_
  ASSERT
  (FORALL (a : complex, b : complex, c : complex):
  ((infix_lsdt(a, b))
  => ((infix_lsdt(c_zero, c)) => (infix_lsdt(infix_asdt(a, c), infix_asdt(b,
     c))))));

% growing_mult
  ASSERT
  (FORALL (n : complex, m : complex):
  ((infix_lseqdt(c_zero, n))
  => ((infix_lseqdt(c_one, m)) => (infix_lseqdt(n, infix_asdt(n, m))))));

% strict_growing_mult_pos
  ASSERT
  (FORALL (n : complex, m : complex):
  ((infix_lsdt(c_one, n))
  => ((infix_lsdt(c_one, m)) => (infix_lsdt(n, infix_asdt(n, m))))));

% init_exp
  ASSERT
  (FORALL (k : complex):
  ((cpower(k, 0) = c_one)
  AND ((cpower(k, 1) = k) AND (cpower(k, 2) = infix_asdt(k, k)))));

% int_exp_pos
  ASSERT
  (FORALL (k : complex, n : INT):
  ((infix_lseqdt(c_one, k))
  => ((0 <= n)
     => ((infix_lseqdt(c_one, cpower(k, n)))
        AND ((infix_gtdt(cpower(k, n), c_zero)) AND (infix_lseqdt(cpower(k,
            n), cpower(k, (n + 1)))))))));

% strict_int_exp_pos
  ASSERT
  (FORALL (k : complex, n : INT):
  ((infix_lsdt(c_one, k))
  => ((0 < n)
     => ((infix_gtdt(cpower(k, n), c_one))
        AND ((infix_lsdt(cpower(k, (n - 1)), cpower(k, n))) AND (infix_lsdt(
            cpower(k, n), cpower(k, (n + 1)))))))));

% strict_int_exp_neg
  ASSERT
  (FORALL (k : complex, n : INT):
  ((infix_lsdt(c_one, k))
  => ((n < 0)
     => ((infix_lsdt(cpower(k, n), c_one))
        AND ((infix_lsdt(cpower(k, (n - 1)), cpower(k, n))) AND (infix_lsdt(
            cpower(k, n), cpower(k, (n + 1)))))))));

% int_exp_neg
  ASSERT
  (FORALL (k : complex, n : INT):
  ((infix_lseqdt(c_one, k))
  => ((n < 0)
     => ((infix_lseqdt(cpower(k, n), c_one))
        AND ((infix_gtdt(cpower(k, n), c_zero)) AND (infix_lseqdt(cpower(k,
            n), cpower(k, (n + 1)))))))));

% positive_exp
  ASSERT
  (FORALL (k : complex, m : INT):
  ((infix_lseqdt(c_one, k)) => (infix_lsdt(c_zero, cpower(k, m)))));

% growing_exp_pos
  ASSERT
  (FORALL (k : complex, m : INT, n : INT):
  ((infix_lseqdt(c_one, k))
  => (((0 <= m) AND (m <= n)) => (infix_lseqdt(cpower(k, m), cpower(k, n))))));

% growing_exp
  ASSERT
  (FORALL (k : complex, m : INT, n : INT):
  ((infix_lseqdt(c_one, k))
  => ((m <= n) => (infix_lseqdt(cpower(k, m), cpower(k, n))))));

% growing_exp_arg
  ASSERT
  (FORALL (k : complex, kqt : complex, n : INT):
  (((infix_lseqdt(c_zero, k)) AND (infix_lseqdt(k, kqt)))
  => ((0 <= n) => (infix_lseqdt(cpower(k, n), cpower(kqt, n))))));

% strict_growing_exp
  ASSERT
  (FORALL (k : complex, m : INT, n : INT):
  ((infix_lsdt(c_one, k))
  => ((m < n) => (infix_lsdt(cpower(k, m), cpower(k, n))))));

% cpower_comm_pos
  ASSERT
  (FORALL (x : complex, y : complex, n : INT):
  ((infix_lseqdt(c_one, x))
  => ((infix_lseqdt(c_one, y))
     => ((0 <= n) => (cpower(infix_asdt(x, y), n) = infix_asdt(cpower(x, n), 
        cpower(y, n)))))));

% cpower_comm
  ASSERT
  (FORALL (x : complex, y : complex, n : INT):
  ((infix_lseqdt(c_one, x))
  => ((infix_lseqdt(c_one, y)) => (cpower(infix_asdt(x, y), n) = infix_asdt(
     cpower(x, n), cpower(y, n))))));

% unicity_exp
  ASSERT
  (FORALL (k : complex, m : INT, n : INT):
  ((infix_lsdt(c_one, k)) => ((cpower(k, m) = cpower(k, n)) <=> (m = n))));

% cpower_i_to_c
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 <= b) => (i_to_c(power(a, b)) = cpower(i_to_c(a), b))));

% cpower_i_to_c_rev
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 <= b) => (cpower(i_to_c(a), b) = i_to_c(power(a, b)))));

fc102: (complex, complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (a : complex, q : complex, i : INT): (tb2t(infix_at(complex1, int, 
  t2tb12(fc102(a, q)), t2tb5(i))) = infix_asdt(a, cpower(q, i))));

% geometric_series
  ASSERT
  (FORALL (a : complex, q : complex, n : INT):
  ((1 <= n)
  => ((NOT (c_one = q)) => (sum(int, t2tb6(to_fset(0, n)), t2tb12(fc102(a,
     q))) = infix_sldt(infix_asdt(a, infix_mndt(c_one, cpower(q, n))), 
     infix_mndt(c_one, q))))));

fc745: (complex, complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (a : complex, q : complex, i : INT): (tb2t(infix_at(complex1, int, 
  t2tb12(fc745(a, q)), t2tb5(i))) = infix_asdt(a, cpower(q, i))));

% ind_geometric_series_r
  ASSERT
  (FORALL (a : complex, q : complex, n : INT):
  ((1 <= n)
  => ((NOT (c_one = q)) => (ind_sum(fc745(a, q), 0, n) = infix_sldt(
     infix_asdt(a, infix_mndt(c_one, cpower(q, n))), infix_mndt(c_one, q))))));

cpower_closure: (ARRAY complex OF (ARRAY INT OF complex));

% cpower_closure_def
  ASSERT
  (FORALL (y : complex, y1 : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), complex1, t2tb17(cpower_closure), t2tb(y)), 
  t2tb5(y1))) = cpower(y, y1)));

% ind_geometric_series
  ASSERT
  (FORALL (q : complex, n : INT):
  ((1 <= n)
  => ((NOT (c_one = q)) => (ind_sum(tb2t12(infix_at(infix_mngt(int,
     complex1), complex1, t2tb17(cpower_closure), t2tb(q))), 0, n) = 
     infix_sldt(infix_mndt(c_one, cpower(q, n)), infix_mndt(c_one, q))))));

% geometric_series_init_one
  ASSERT
  (FORALL (q : complex, n : INT):
  ((1 <= n)
  => ((NOT (c_one = q)) => (sum(int, t2tb6(to_fset(0, n)), infix_at(
     infix_mngt(int, complex1), complex1, t2tb17(cpower_closure), 
     t2tb(q))) = infix_sldt(infix_mndt(c_one, cpower(q, n)), 
     infix_mndt(c_one, q))))));

fc104: (complex, complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (a : complex, q : complex, i : INT): (tb2t(infix_at(complex1, int, 
  t2tb12(fc104(a, q)), t2tb5(i))) = infix_asdt(a, cpower(q, i))));

% geometric_series_c_one
  ASSERT
  (FORALL (a : complex, q : complex, n : INT):
  ((1 <= n)
  => ((q = c_one) => (sum(int, t2tb6(to_fset(0, n)), t2tb12(fc104(a, q))) = 
     infix_asdt(a, i_to_c(n))))));

% geometric_series_c_one_init_one
  ASSERT
  (FORALL (q : complex, n : INT):
  ((1 <= n)
  => ((q = c_one) => (sum(int, t2tb6(to_fset(0, n)), infix_at(infix_mngt(int,
     complex1), complex1, t2tb17(cpower_closure), t2tb(q))) = i_to_c(n)))));

% positive_cpower_2
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => ((NOT (c_zero = x)) => (infix_lsdt(c_zero, cpower(x, 2))))));

% positive_cpower_2_mod
  ASSERT
  (FORALL (x : complex): (infix_lseqdt(c_zero, cpower(modulus(x), 2))));

% cpower_2_mod_non_null
  ASSERT
  (FORALL (x : complex):
  ((NOT (x = c_zero)) => (infix_lsdt(c_zero, cpower(modulus(x), 2)))));

% cpower_2_mod_mult_non_null
  ASSERT
  (FORALL (x : complex, y : complex):
  ((NOT (x = c_zero))
  => ((NOT (y = c_zero)) => (infix_lsdt(c_zero, cpower(modulus(x), 2))))));

% growing_cpower_2
  ASSERT
  (FORALL (x : complex, y : complex):
  (((infix_lseqdt(c_zero, x)) AND (infix_lseqdt(x, y))) => (infix_lseqdt(
  cpower(x, 2), cpower(y, 2)))));

% cpower_incr_power_2
  ASSERT
  (FORALL (k : INT):
  ((0 <= k) => (cpower(i_to_c(power(2, k)), 2) = i_to_c(power(2, (2 * k))))));

% cpower_modulus_incr_power_2
  ASSERT
  (FORALL (k : INT):
  ((0 <= k) => (cpower(modulus(i_to_c(power(2, k))), 2) = i_to_c(power(2,
  (2 * k))))));

% cpower_modulus_supeq
  ASSERT
  (FORALL (x : complex, y : complex, i : INT):
  ((1 <= i)
  => ((infix_lseqdt(modulus(y), modulus(x))) => (infix_lseqdt(cpower(
     modulus(y), i), cpower(modulus(x), i))))));

% cpower_modulus_div_simpl
  ASSERT
  (FORALL (x : complex, y : complex, z : complex, i : INT):
  ((1 <= i)
  => ((infix_lseqdt(c_zero, x))
     => ((infix_lsdt(c_zero, y))
        => ((infix_lsdt(c_zero, z)) => (infix_sldt(cpower(x, i), cpower(y,
           i)) = infix_sldt(cpower(modulus(infix_asdt(x, z)), i), cpower(
           modulus(infix_asdt(y, z)), i))))))));

% cpower_two_modulus_div_simpl
  ASSERT
  (FORALL (x : complex, y : complex, z : complex):
  ((real_(x))
  => ((real_(y))
     => ((real_(z))
        => ((NOT (c_zero = y))
           => ((NOT (c_zero = z)) => (infix_sldt(cpower(x, 2), cpower(y,
              2)) = infix_sldt(cpower(modulus(infix_asdt(x, z)), 2), cpower(
              modulus(infix_asdt(y, z)), 2)))))))));

exp: (complex) -> complex;

% e_mod
  ASSERT (FORALL (x : complex): (modulus(exp(x)) = c_one));

% e_diff_c_zero
  ASSERT (FORALL (x : complex): (NOT (exp(x) = c_zero)));

% Exp_one
  ASSERT (real_(exp(c_one)));

% Exp_zero
  ASSERT (exp(c_zero) = c_one);

% Exp_sum
  ASSERT
  (FORALL (x : complex, y : complex): (exp(infix_pldt(x, y)) = infix_asdt(
  exp(x), exp(y))));

% exp_one
  ASSERT (real_(exp(c_one)));

% Exp_quarter_pi
  ASSERT (exp(infix_sldt(infix_asdt(im, pi), i_to_c(4))) = infix_pldt(
  infix_sldt(square_rt(infix_pldt(c_one, c_one)), infix_pldt(c_one, c_one)), 
  infix_asdt(im, infix_sldt(square_rt(infix_pldt(c_one, c_one)), 
  infix_pldt(c_one, c_one)))));

% exp_sum
  ASSERT
  (FORALL (x : complex, y : complex): (exp(infix_pldt(x, y)) = infix_asdt(
  exp(x), exp(y))));

% exp_eq
  ASSERT
  (FORALL (t1 : complex, t2 : complex): ((t1 = t2) => (exp(t1) = exp(t2))));

% exp_sum_rev
  ASSERT
  (FORALL (x : complex, y : complex): (infix_asdt(exp(x), exp(y)) = exp(
  infix_pldt(x, y))));

% exp_inv
  ASSERT
  (FORALL (i : complex):
  ((NOT (exp(i) = c_zero)) => (exp(prefix_mndt(i)) = infix_sldt(c_one, 
  exp(i)))));

% exp_inv_rev
  ASSERT
  (FORALL (i : complex):
  ((NOT (exp(i) = c_zero)) => (infix_sldt(c_one, exp(i)) = exp(
  prefix_mndt(i)))));

% exp_mult_pre
  ASSERT
  (FORALL (x : complex, y : INT):
  ((0 <= y) => (exp(infix_asdt(x, i_to_c(y))) = cpower(exp(x), y))));

% exp_mult
  ASSERT
  (FORALL (x : complex, y : INT): (exp(infix_asdt(x, i_to_c(y))) = cpower(
  exp(x), y)));

% cpower_to_exp
  ASSERT
  (FORALL (x : complex, y : INT): (cpower(exp(x), y) = exp(infix_asdt(x, 
  i_to_c(y)))));

% exp_h_pi
  ASSERT (exp(infix_sldt(infix_asdt(im, pi), infix_pldt(c_one,
  c_one))) = im);

% exp_pi
  ASSERT (exp(infix_asdt(im, pi)) = prefix_mndt(c_one));

% exp_two_pi
  ASSERT (exp(infix_asdt(infix_asdt(im, pi), infix_pldt(c_one,
  c_one))) = c_one);

% exp_two_pi_mul
  ASSERT
  (FORALL (k : INT): (exp(infix_asdt(i_to_c(k), infix_asdt(infix_asdt(im,
  pi), infix_pldt(c_one, c_one)))) = c_one));

% exp_two_pi_mul_den
  ASSERT
  (FORALL (k : INT, l : INT):
  ((NOT (k = 0)) => (exp(infix_sldt(infix_asdt(i_to_c((k * l)), infix_asdt(
  infix_asdt(im, pi), infix_pldt(c_one, c_one))), i_to_c(k))) = c_one)));

% exp_two_pi_mul_den_add
  ASSERT
  (FORALL (k : INT, l : INT, m : INT): (exp(infix_asdt(i_to_c(((k * m) + l)), 
  infix_asdt(infix_asdt(im, pi), infix_pldt(c_one, c_one)))) = exp(
  infix_asdt(i_to_c(l), infix_asdt(infix_asdt(im, pi), infix_pldt(c_one,
  c_one))))));

ang_inv: (angle) -> angle;

ang_add: (angle, angle) -> angle;

ang_meas: (angle) -> complex;

% ang_meas'spec
  ASSERT
  (FORALL (us : angle):
  ((infix_lseqdt(c_zero, ang_meas(us))) AND (infix_lsdt(ang_meas(us),
  c_one))));

% real_ang_meas
  ASSERT (FORALL (o : angle): (real_(ang_meas(o))));

real_to_ang: (complex) -> angle;

ang_zero: angle;

% Assoc
  ASSERT
  (FORALL (x : angle, y : angle, z : angle): (ang_add(ang_add(x, y), z) = 
  ang_add(x, ang_add(y, z))));

% Unit_def_l
  ASSERT (FORALL (x : angle): (ang_add(ang_zero, x) = x));

% Unit_def_r
  ASSERT (FORALL (x : angle): (ang_add(x, ang_zero) = x));

% Inv_def_l
  ASSERT (FORALL (x : angle): (ang_add(ang_inv(x), x) = ang_zero));

% Inv_def_r
  ASSERT (FORALL (x : angle): (ang_add(x, ang_inv(x)) = ang_zero));

% Comm
  ASSERT (FORALL (x : angle, y : angle): (ang_add(x, y) = ang_add(y, x)));

% Real_To_Ang_one
  ASSERT
  (FORALL (phi : complex): ((real_(phi)) => (real_to_ang(c_one) = ang_zero)));

% Real_To_Ang_inv
  ASSERT
  (FORALL (phi : complex):
  ((real_(phi)) => (ang_inv(real_to_ang(phi)) = real_to_ang(
  prefix_mndt(phi)))));

% Real_To_Ang_add
  ASSERT
  (FORALL (phi : complex, phiqt : complex):
  ((real_(phi))
  => ((real_(phiqt)) => (ang_add(real_to_ang(phi), real_to_ang(phiqt)) = 
     real_to_ang(infix_pldt(phi, phiqt))))));

% meas_value
  ASSERT
  (FORALL (phi : complex):
  ((real_(phi))
  => (((infix_lseqdt(c_zero, phi)) AND (infix_lsdt(phi, c_one))) => (
     ang_meas(real_to_ang(phi)) = phi))));

% Equal_angle
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((exp(infix_asdt(infix_asdt(infix_asdt(im, pi), infix_pldt(c_one, c_one)), 
  ang_meas(o))) = exp(infix_asdt(infix_asdt(infix_asdt(im, pi), 
  infix_pldt(c_one, c_one)), ang_meas(oqt)))) <=> (o = oqt)));

% set_equal_angle_meas
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((o = oqt) => (ang_meas(o) = ang_meas(oqt))));

% get_equal_angle_meas
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((ang_meas(o) = ang_meas(oqt)) => (o = oqt)));

% meas_real_to_ang
  ASSERT (FORALL (o : angle): (real_to_ang(ang_meas(o)) = o));

% meas_real_to_ang_rev
  ASSERT (FORALL (o : angle): (o = real_to_ang(ang_meas(o))));

% ang_add_rev
  ASSERT
  (FORALL (o : angle, oqt : angle): (ang_add(o, oqt) = ang_add(oqt, o)));

% real_to_ang_zero
  ASSERT (real_to_ang(c_zero) = ang_zero);

ang_exp: (angle) -> complex;

% ang_exp'def
  ASSERT
  (FORALL (o : angle): (ang_exp(o) = exp(infix_asdt(infix_asdt(infix_asdt(im,
  pi), infix_pldt(c_one, c_one)), ang_meas(o)))));

% ang_exp'spec
  ASSERT (FORALL (o : angle): (NOT (ang_exp(o) = c_zero)));

% set_equal_angle_exp
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((o = oqt) => (ang_exp(o) = ang_exp(oqt))));

% get_equal_angle_exp
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((ang_exp(o) = ang_exp(oqt)) => (o = oqt)));

% meas_value_plus_one
  ASSERT
  (FORALL (phi : complex):
  ((real_(phi)) => (exp(infix_asdt(infix_asdt(infix_asdt(im, pi), 
  infix_pldt(c_one, c_one)), ang_meas(real_to_ang(phi)))) = exp(infix_asdt(
  infix_asdt(infix_asdt(im, pi), infix_pldt(c_one, c_one)), infix_pldt(
  ang_meas(real_to_ang(phi)), c_one))))));

% ang_exp_pi_over_four
  ASSERT (ang_exp(real_to_ang(infix_sldt(c_one, i_to_c(8)))) = infix_pldt(
  infix_sldt(square_rt(infix_pldt(c_one, c_one)), infix_pldt(c_one, c_one)), 
  infix_asdt(im, infix_sldt(square_rt(infix_pldt(c_one, c_one)), 
  infix_pldt(c_one, c_one)))));

% ang_exp_pi_over_two
  ASSERT (ang_exp(real_to_ang(infix_sldt(c_one, i_to_c(4)))) = im);

% ang_exp_pi
  ASSERT (ang_exp(real_to_ang(infix_sldt(c_one, i_to_c(2)))) = 
  prefix_mndt(c_one));

% real_to_ang_c_one
  ASSERT (real_to_ang(c_one) = ang_zero);

% set_ang_meas_eq
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((o = oqt) => (ang_meas(o) = ang_meas(oqt))));

% get_ang_meas_eq
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((ang_meas(o) = ang_meas(oqt)) => (o = oqt)));

% ang_exp_zero
  ASSERT (ang_exp(ang_zero) = c_one);

% ang_exp_two_pi
  ASSERT (ang_exp(real_to_ang(i_to_c(1))) = c_one);

% ang_exp_c_one
  ASSERT (ang_exp(real_to_ang(c_one)) = c_one);

% ang_meas_add_inf_c_one
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((infix_lsdt(infix_pldt(ang_meas(o), ang_meas(oqt)), c_one)) => (ang_meas(
  ang_add(o, oqt)) = infix_pldt(ang_meas(o), ang_meas(oqt)))));

% set_ang_exp_eq
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((o = oqt) => (ang_exp(o) = ang_exp(oqt))));

% get_ang_exp_meas_eq
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((ang_exp(o) = ang_exp(oqt)) => (ang_meas(o) = ang_meas(oqt))));

% get_ang_exp_eq
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((ang_exp(o) = ang_exp(oqt)) => (o = oqt)));

% ang_meas_zero
  ASSERT (ang_meas(ang_zero) = c_zero);

% real_to_ang_add_one
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (real_to_ang(infix_pldt(x, c_one)) = real_to_ang(x))));

truncate: (REAL) -> INT;

% Truncate_int
  ASSERT (FORALL (i : INT): (truncate(i) = i));

% Truncate_down_pos
  ASSERT
  (FORALL (x : REAL):
  ((0 <= x) => ((truncate(x) <= x) AND (x < (truncate(x) + 1)))));

% Truncate_up_neg
  ASSERT
  (FORALL (x : REAL):
  ((x <= 0) => (((truncate(x) - 1) < x) AND (x <= truncate(x)))));

% Real_of_truncate
  ASSERT
  (FORALL (x : REAL):
  (((x - 1) <= truncate(x)) AND (truncate(x) <= (x + 1))));

% Truncate_monotonic
  ASSERT
  (FORALL (x : REAL, y : REAL): ((x <= y) => (truncate(x) <= truncate(y))));

% Truncate_monotonic_int1
  ASSERT (FORALL (x : REAL, i : INT): ((x <= i) => (truncate(x) <= i)));

% Truncate_monotonic_int2
  ASSERT (FORALL (x : REAL, i : INT): ((i <= x) => (i <= truncate(x))));

floor: (REAL) -> INT;

ceil: (REAL) -> INT;

% Floor_int
  ASSERT (FORALL (i : INT): (floor(i) = i));

% Ceil_int
  ASSERT (FORALL (i : INT): (ceil(i) = i));

% Floor_down
  ASSERT (FORALL (x : REAL): ((floor(x) <= x) AND (x < (floor(x) + 1))));

% Ceil_up
  ASSERT (FORALL (x : REAL): (((ceil(x) - 1) < x) AND (x <= ceil(x))));

% Floor_monotonic
  ASSERT (FORALL (x : REAL, y : REAL): ((x <= y) => (floor(x) <= floor(y))));

% Ceil_monotonic
  ASSERT (FORALL (x : REAL, y : REAL): ((x <= y) => (ceil(x) <= ceil(y))));

int_part: (complex) -> complex;

% int_part'def
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (int_part(x) = i_to_c(floor(real_part(x))))));

% int_part'spec
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((real_(int_part(x)))
     AND ((EXISTS (i : INT): (int_part(x) = i_to_c(i)))
         AND ((infix_lseqdt(int_part(x), x)) AND (infix_lsdt(x, infix_pldt(
             int_part(x), c_one))))))));

int_part_int: (complex) -> INT;

% int_part_int'def
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (int_part_int(x) = floor(real_part(x)))));

% int_part_int'spec
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((i_to_c(int_part_int(x)) = int_part(x))
     AND ((infix_lseqdt(i_to_c(int_part_int(x)), x)) AND (infix_lsdt(x, 
         infix_pldt(i_to_c(int_part_int(x)), c_one)))))));

dec_part: (complex) -> complex;

% dec_part'def
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (dec_part(x) = infix_mndt(x, int_part(x)))));

% dec_part'spec
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((real_(dec_part(x)))
     AND ((EXISTS (i : INT): (dec_part(x) = infix_mndt(x, i_to_c(i))))
         AND ((infix_lseqdt(c_zero, dec_part(x))) AND (infix_lsdt(
             dec_part(x), c_one)))))));

% dec_part_decomp
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (x = infix_pldt(dec_part(x), int_part(x)))));

% dec_part_decomp_rev
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (infix_pldt(dec_part(x), int_part(x)) = x)));

% dec_part_decomp_int
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (x = infix_pldt(dec_part(x), i_to_c(int_part_int(x))))));

% dec_part_decomp_int_rev
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (infix_pldt(dec_part(x), i_to_c(int_part_int(x))) = x)));

% ang_exp_add_b
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((infix_lsdt(infix_pldt(ang_meas(o), ang_meas(oqt)), c_one)) => (ang_exp(
  ang_add(o, oqt)) = infix_asdt(ang_exp(o), ang_exp(oqt)))));

% ang_exp_add_b_rev
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((infix_lsdt(infix_pldt(ang_meas(o), ang_meas(oqt)), c_one)) => (
  infix_asdt(ang_exp(o), ang_exp(oqt)) = ang_exp(ang_add(o, oqt)))));

% real_to_ang_add
  ASSERT
  (FORALL (x : complex, xqt : complex):
  ((real_(x))
  => ((real_(xqt)) => (real_to_ang(infix_pldt(x, xqt)) = ang_add(
     real_to_ang(x), real_to_ang(xqt))))));

% real_to_ang_add_rev
  ASSERT
  (FORALL (x : complex, xqt : complex):
  ((real_(x))
  => ((real_(xqt)) => (ang_add(real_to_ang(x), real_to_ang(xqt)) = 
     real_to_ang(infix_pldt(x, xqt))))));

% ang_inv_add
  ASSERT
  (FORALL (o : angle, oqt : angle): (ang_inv(ang_add(o, oqt)) = ang_add(
  ang_inv(o), ang_inv(oqt))));

% ang_inv_add_rev
  ASSERT
  (FORALL (o : angle, oqt : angle): (ang_add(ang_inv(o), ang_inv(oqt)) = 
  ang_inv(ang_add(o, oqt))));

% ang_exp_add_pre
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((infix_lseqdt(c_one, infix_pldt(ang_meas(o), ang_meas(oqt))))
  => ((infix_lseqdt(ang_meas(o), ang_meas(oqt))) => (ang_exp(ang_add(o,
     oqt)) = infix_asdt(ang_exp(o), ang_exp(oqt))))));

% ang_exp_add
  ASSERT
  (FORALL (o : angle, oqt : angle): (ang_exp(ang_add(o, oqt)) = infix_asdt(
  ang_exp(o), ang_exp(oqt))));

% ang_meas_add
  ASSERT
  (FORALL (o : angle, oqt : angle): (real_to_ang(ang_meas(ang_add(o,
  oqt))) = ang_add(o, oqt)));

% ang_exp_add_rev
  ASSERT
  (FORALL (o : angle, oqt : angle): (infix_asdt(ang_exp(o), ang_exp(oqt)) = 
  ang_exp(ang_add(o, oqt))));

% real_to_ang_int_pre
  ASSERT
  (FORALL (k : INT): ((0 <= k) => (ang_exp(real_to_ang(i_to_c(k))) = c_one)));

% real_to_ang_int
  ASSERT (FORALL (k : INT): (ang_exp(real_to_ang(i_to_c(k))) = c_one));

% real_to_ang_int_
  ASSERT (FORALL (k : INT): (real_to_ang(i_to_c(k)) = ang_zero));

% real_to_ang_value_add
  ASSERT
  (FORALL (phi : complex, k : INT):
  (((infix_lseqdt(c_zero, phi)) AND (infix_lsdt(phi, c_one))) => (ang_exp(
  real_to_ang(infix_pldt(phi, i_to_c(k)))) = exp(infix_asdt(infix_asdt(
  infix_asdt(im, pi), infix_pldt(c_one, c_one)), phi)))));

% real_to_ang_value
  ASSERT
  (FORALL (phi : complex):
  ((real_(phi)) => (ang_exp(real_to_ang(phi)) = exp(infix_asdt(infix_asdt(
  infix_asdt(im, pi), infix_pldt(c_one, c_one)), phi)))));

% ang_exp_zero_
  ASSERT (ang_exp(ang_zero) = c_one);

ang_mult_int_: (angle, INT) -> angle;

% ang_mult_int_'def
  ASSERT
  (FORALL (theta : angle, i : INT):
  ((0 <= i)
  => (IF (i = 0) THEN (ang_mult_int_(theta, i) = ang_zero) ELSE (
     ang_mult_int_(theta, i) = ang_add(ang_mult_int_(theta, (i - 1)),
     theta)) ENDIF)));

% ang_mult_int_'spec
  ASSERT
  (FORALL (theta : angle, i : INT):
  ((0 <= i) => (ang_mult_int_(theta, i) = real_to_ang(infix_asdt(
  ang_meas(theta), i_to_c(i))))));

ang_mult_int: (angle, INT) -> angle;

% ang_mult_int'def
  ASSERT
  (FORALL (theta : angle, i : INT):
  (IF (0 <= i) THEN (ang_mult_int(theta, i) = ang_mult_int_(theta, i)) ELSE (
  ang_mult_int(theta, i) = ang_inv(ang_mult_int_(theta, (- i)))) ENDIF));

% ang_mult_int_to_real_to_ang
  ASSERT
  (FORALL (theta : angle, i : INT): (ang_mult_int(theta, i) = real_to_ang(
  infix_asdt(ang_meas(theta), i_to_c(i)))));

% ang_mult_int_eq
  ASSERT
  (FORALL (i : INT, iqt : INT, theta : angle, thetaqt : angle):
  ((i = iqt)
  => ((theta = thetaqt) => (ang_mult_int(theta, i) = ang_mult_int(thetaqt,
     iqt)))));

% ang_mult_int_plus_one_pos
  ASSERT
  (FORALL (theta : angle, i : INT):
  ((0 < i) => (ang_mult_int(theta, i) = ang_add(ang_mult_int(theta, (i - 1)),
  theta))));

% ang_mult_int_inv
  ASSERT
  (FORALL (theta : angle, i : INT):
  ((i < 0) => (ang_mult_int(theta, i) = ang_inv(ang_mult_int(theta, (- i))))));

% real_to_ang_eq
  ASSERT
  (FORALL (phi : complex, phiqt : complex):
  ((real_(phi))
  => ((phi = phiqt) => (real_to_ang(phi) = real_to_ang(phiqt)))));

% set_equal_angle_by_exp
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((ang_exp(o) = ang_exp(oqt)) => (o = oqt)));

% real_to_ang_int_dec_part
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (real_to_ang(x) = real_to_ang(dec_part(x)))));

% set_equal_exp_by_ang
  ASSERT
  (FORALL (o : angle, oqt : angle):
  ((o = oqt) => (ang_exp(o) = ang_exp(oqt))));

% div_plus_one
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i)
  => ((0 < j) => (((div(i, j) * j) <= i) AND (i < ((div(i, j) + 1) * j))))));

% mod_is_inf
  ASSERT (FORALL (i : INT, j : INT): ((0 < j) => (mod(i, j) < j)));

% zero_add
  ASSERT (FORALL (a1 : INT, a2 : INT): ((a1 = 0) => ((a1 + a2) = a2)));

% add_zero
  ASSERT (FORALL (a1 : INT, a2 : INT): ((a2 = 0) => ((a1 + a2) = a1)));

% one_mult
  ASSERT (FORALL (a1 : INT, a2 : INT): ((a1 = 1) => ((a1 * a2) = a2)));

% mult_one
  ASSERT (FORALL (a1 : INT, a2 : INT): ((a2 = 1) => ((a1 * a2) = a1)));

% add_eq
  ASSERT
  (FORALL (a1 : INT, a2 : INT, b1 : INT, b2 : INT):
  ((a1 = a2) => ((b1 = b2) => ((a1 + b1) = (a2 + b2)))));

% mult_eq
  ASSERT
  (FORALL (a1 : INT, a2 : INT, b1 : INT, b2 : INT):
  ((a1 = a2) => ((b1 = b2) => ((a1 * b1) = (a2 * b2)))));

% add_eq_inv
  ASSERT
  (FORALL (a1 : INT, a2 : INT, b1 : INT, b2 : INT):
  ((a1 = a2) => ((b1 = b2) => ((a1 + b1) = (b2 + a2)))));

% mult_eq_inv
  ASSERT
  (FORALL (a1 : INT, a2 : INT, b1 : INT, b2 : INT):
  ((a1 = a2) => ((b1 = b2) => ((a1 * b1) = (b2 * a2)))));

% bound_eq
  ASSERT
  (FORALL (i : INT, j : INT): (((0 <= i) AND (i < j)) => (i = mod(i, j))));

% bound_eq_rev
  ASSERT
  (FORALL (i : INT, j : INT): (((0 <= i) AND (i < j)) => (mod(i, j) = i)));

% unicity_div_mod
  ASSERT
  (FORALL (i : INT, j : INT, q : INT, r : INT):
  ((0 < j)
  => ((i = ((q * j) + r))
     => (((0 <= r) AND (r < j)) => ((q = div(i, j)) AND (r = mod(i, j)))))));

% get_div
  ASSERT
  (FORALL (j : INT, q : INT, r : INT):
  ((0 < j) => (((0 <= r) AND (r < j)) => (div(((q * j) + r), j) = q))));

% get_mod
  ASSERT
  (FORALL (j : INT, q : INT, r : INT):
  ((0 < j) => (((0 <= r) AND (r < j)) => (mod(((q * j) + r), j) = r))));

% positive_div
  ASSERT
  (FORALL (i : INT, j : INT): (((0 < j) AND (j < i)) => (0 < div(i, j))));

% div_mod_sim_bound
  ASSERT
  (FORALL (d : INT, m : INT, q : INT, r : INT):
  (((0 <= d) AND (d < r))
  => (((0 <= m) AND (m < q))
     => ((0 <= ((d * q) + m)) AND (((d * q) + m) < (r * q))))));

% div_mod_sim_bound_gen_r
  ASSERT
  (FORALL (d : INT, q : INT, r : INT):
  (((0 <= d) AND (d < r))
  => (FORALL (m : INT):
     (((0 <= m) AND (m < q))
     => ((0 <= ((d * q) + m)) AND (((d * q) + m) < (r * q)))))));

% unicity_div_gen
  ASSERT
  (FORALL (j : INT, q : INT):
  ((0 <= q)
  => ((0 < j)
     => ((FORALL (i : INT):
         ((0 <= i)
         => (((0 <= (i - (q * j))) AND ((i - (q * j)) < j)) => (q = div(i,
            j)))))
        AND (FORALL (i : INT):
            ((0 <= i)
            => (((0 <= (i - (q * j))) AND ((i - (q * j)) < j))
               => ((i - (j * q)) = mod(i, j)))))))));

% bound_mod
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 < j) => ((0 <= mod(i, j)) AND (mod(i, j) < j))));

% mod_eq
  ASSERT
  (FORALL (a : INT, b : INT, d : INT): ((a = b) => (mod(a, d) = mod(b, d))));

% e_div_eq
  ASSERT
  (FORALL (a : INT, b : INT, d : INT): ((a = b) => (div(a, d) = div(b, d))));

% decomp
  ASSERT
  (FORALL (i : INT, j : INT):
  ((NOT (0 = j)) => (i = ((j * div(i, j)) + mod(i, j)))));

% div_mod_eq
  ASSERT
  (FORALL (i : INT, j : INT, q : INT):
  ((0 <= i)
  => ((0 <= j)
     => ((0 < q)
        => ((div(i, q) = div(j, q)) => ((mod(i, q) = mod(j, q)) => (i = j)))))));

% mod_zero
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i) => ((0 < j) => ((mod(i, j) = 0) => (i = (j * div(i, j)))))));

% div_plus_quotient
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i) => ((0 < j) => (div((i + j), j) = (div(i, j) + 1)))));

% div_plus_fact_gen_div
  ASSERT
  (FORALL (i : INT, j : INT, k : INT):
  ((0 < j) => (div((i + (k * j)), j) = (div(i, j) + k))));

% mod_plus_fact_gen_mod
  ASSERT
  (FORALL (i : INT, j : INT, k : INT):
  ((0 < j) => (mod(((k * j) + i), j) = mod(i, j))));

% mod_plus_fact_gen_mod_left
  ASSERT
  (FORALL (i : INT, j : INT, k : INT):
  ((0 < j) => (mod(((j * k) + i), j) = mod(i, j))));

% bound_div
  ASSERT
  (FORALL (i : INT, q : INT, f : INT):
  ((0 <= i)
  => ((0 <= q)
     => ((0 <= f)
        => ((i < (f * q))
           => ((0 <= div(i, q))
              AND (((0 <= (div(i, q) * q))
                   AND (((div(i, q) * q) <= i) AND (i < (q * (div(i,
                       q) + 1)))))
                  AND (div(i, q) < f))))))));

% mod_upper_bound
  ASSERT
  (FORALL (i : INT, q : INT): ((0 < i) => ((i = q) => (mod(i, q) = 0))));

% bound_div_gen
  ASSERT
  (FORALL (q : INT, f : INT):
  ((0 < q)
  => ((0 <= f)
     => (FORALL (i : INT): (((0 <= i) AND (i < (q * f))) => (div(i, q) < f))))));

% mod_invariant
  ASSERT
  (FORALL (i : INT, q : INT, f : INT):
  ((0 <= i)
  => ((0 < q)
     => ((0 < f) => (mod(((q * (f * div(i, (q * f)))) + mod(i, (q * f))),
        q) = mod(mod(i, (q * f)), q))))));

% mod_inf
  ASSERT
  (FORALL (i : INT, q : INT): (((0 <= i) AND (i < q)) => (mod(i, q) = i)));

% add_mod
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((mod(a, c) + mod(b, c)), c) = mod((a + b), c))));

% add_mod_eq
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, d : INT, n : INT):
  ((0 < n)
  => ((mod(a, n) = mod(c, n))
     => ((mod(b, n) = mod(d, n)) => (mod((a + b), n) = mod((c + d), n))))));

% add_mod_left
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((mod(a, c) + b), c) = mod((a + b), c))));

% simpl_add_mod_left
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => ((mod(a, c) = 0) => (mod((a + b), c) = mod(b, c)))));

% add_mod_right
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((a + mod(b, c)), c) = mod((a + b), c))));

% mod_mod_left
  ASSERT
  (FORALL (i : INT, j : INT, f : INT):
  ((0 < j) => ((0 < f) => (mod(mod(i, (f * j)), j) = mod(i, j)))));

% mult_mod
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((mod(a, c) * mod(b, c)), c) = mod((a * b), c))));

% mod_mod_mult
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < b) => (mod((mod(a, b) * mod(c, b)), b) = mod((a * c), b))));

% mod_mod_mult_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < b) => (mod((a * c), b) = mod((mod(a, b) * mod(c, b)), b))));

% mod_mod_i
  ASSERT
  (FORALL (i : INT, j : INT): ((0 < j) => (mod(mod(i, j), j) = mod(i, j))));

% binary_prod
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i)
  => ((0 < j) => (mod((mod(i, 2) * mod(j, 2)), 2) = mod((i * j), 2)))));

% mod_minus
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < b) => ((mod(a, b) = c) => (mod((- a), b) = mod((- c), b)))));

% mult_mod_left
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((mod(a, c) * b), c) = mod((a * b), c))));

% mult_mod_right
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((a * mod(b, c)), c) = mod((a * b), c))));

% mod_mod_right
  ASSERT
  (FORALL (i : INT, j : INT, f : INT):
  ((0 <= i)
  => ((0 < j) => ((0 < f) => (mod(mod(i, (j * f)), j) = mod(i, j))))));

% mod_mod_rev
  ASSERT
  (FORALL (i : INT, j : INT, f : INT):
  ((0 <= i)
  => ((0 < j)
     => ((0 < f)
        => ((mod(i, j) = mod(mod(i, (j * f)), j)) AND (mod(i, j) = mod(mod(i,
           (f * j)), j)))))));

% mod_mod_plus
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i) => ((0 < j) => (mod(i, j) = mod(mod(i, (j + j)), j)))));

% mod_mod_add_left
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((mod(a, c) + b), c) = mod((a + b), c))));

% mod_mod_add_right
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((a + mod(b, c)), c) = mod((a + b), c))));

% mod_mod_add_left_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((a + b), c) = mod((mod(a, c) + b), c))));

% mod_mod_add_right_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c) => (mod((a + b), c) = mod((a + mod(b, c)), c))));

% mult_assoc
  ASSERT
  (FORALL (i : INT, q : INT, f : INT):
  ((0 <= i)
  => ((0 < q)
     => ((0 < f) => ((q * (f * div(i, (q * f)))) = ((q * f) * div(i,
        (q * f))))))));

% div_div
  ASSERT
  (FORALL (i : INT, j : INT, k : INT):
  ((0 <= i)
  => ((0 < j)
     => ((0 < k)
        => ((div(div(i, k), j) = div(i, (k * j))) AND (div(div(i, k), j) = 
           div(i, (j * k))))))));

% compat_order_div
  ASSERT
  (FORALL (i : INT, iqt : INT, j : INT):
  (((0 <= i) AND (i <= iqt)) => ((0 < j) => (div(i, j) <= div(iqt, j)))));

% mod_div
  ASSERT
  (FORALL (i : INT, j : INT, k : INT):
  ((0 <= i)
  => ((0 < j) => ((0 < k) => (div(mod(i, (j * k)), j) = mod(div(i, j), k))))));

% inf_mul
  ASSERT
  (FORALL (ia : INT, ib : INT, a : INT, b : INT):
  (((0 <= ia) AND (ia < a))
  => (((0 <= ib) AND (ib < b))
     => ((((a * ib) + ia) < (a * b)) AND (((ib * a) + ia) < (b * a))))));

% inf_mul_gen
  ASSERT
  (FORALL (n : INT, v : INT, p : INT):
  (((0 <= p) AND (p < v))
  => (FORALL (k : INT):
     (((0 <= k) AND (k < n)) => (((k * v) + p) < (n * v))))));

% inf_mul_gen_b
  ASSERT
  (FORALL (n : INT, v : INT, p : INT):
  (((0 <= p) AND (p < n))
  => (FORALL (k : INT):
     (((0 <= k) AND (k < v)) => (((p * v) + k) < (n * v))))));

% inf_mul_comm
  ASSERT
  (FORALL (i : INT, bi : INT, quot : INT, rest : INT):
  (((0 <= i) AND (i < bi))
  => ((0 < rest)
     => ((0 < quot) => ((bi = (quot * rest)) => (mod(i, rest) < rest))))));

% indic_div_mod
  ASSERT
  (FORALL (i : INT, j : INT, q : INT):
  ((0 <= i)
  => ((0 <= j)
     => ((0 < q) => (indic(int, t2tb5(i), t2tb5(j)) = infix_asdt(indic(int, 
        t2tb5(mod(i, q)), t2tb5(mod(j, q))), indic(int, t2tb5(div(i, q)), 
        t2tb5(div(j, q)))))))));

% indic_div_mod_gen
  ASSERT
  (FORALL (q : INT):
  ((0 < q)
  => (FORALL (i : INT, j : INT):
     (((0 <= i) AND (0 <= j)) => (indic(int, t2tb5(i), t2tb5(j)) = 
     infix_asdt(indic(int, t2tb5(mod(i, q)), t2tb5(mod(j, q))), indic(int, 
     t2tb5(div(i, q)), t2tb5(div(j, q)))))))));

% set_inf
  ASSERT TRUE;

% set_infeq
  ASSERT TRUE;

% bounded_cycle
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, d : INT):
  ((0 <= a)
  => ((0 < b)
     => (((0 <= d) AND (d < b))
        => ((0 < c) => (div(((a * b) + d), (b * c)) = div(a, c)))))));

% div_mod_minus
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < b)
  => ((0 < a)
     => ((NOT (mod(a, b) = 0)) => (mod((- a), b) = (b - mod(a, b)))))));

fc105: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(a, int), fc105(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), b : INT, i : INT): ((tb2t7(fc105(int, 
  t2tb7(f), b))[i]) = mod((f[i]), b)));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, b : INT, i : uni): (tb2t5(infix_at(int, a, fc105(a, f,
  b), i)) = mod(tb2t5(infix_at(int, a, f, i)), b))));

% mod_mod_iproduct
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, b : INT):
  ((0 < b) => (mod(iproduct(a, s2, fc105(a, f, b)), b) = mod(iproduct(a, s2,
  f), b)))));

% ind_isum_mod_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, j : INT,
  n : INT):
  ((0 < n)
  => ((FORALL (k : INT):
      (((i <= k) AND (k < j)) => (mod((f[k]), n) = mod((g[k]), n))))
     => (mod(ind_isum(f, i, j), n) = mod(ind_isum(g, i, j), n)))));

int_to_ang: (INT, INT) -> angle;

% int_to_ang'def
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n) => (int_to_ang(k, n) = real_to_ang(infix_sldt(i_to_c(k), i_to_c(
  power(2, n)))))));

% int_to_ang'spec
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n)
  => ((int_to_ang(k, n) = real_to_ang(infix_sldt(i_to_c(mod(k, power(2, n))), 
     i_to_c(power(2, n)))))
     AND (((0 <= k) AND (k < power(2, n))) => (ang_meas(int_to_ang(k, n)) = 
         infix_sldt(i_to_c(k), i_to_c(power(2, n))))))));

infix_sldtsl: (INT, INT) -> angle;

% infix /./'def
  ASSERT
  (FORALL (k : INT, n : INT):
  (IF (0 <= n) THEN (infix_sldtsl(k, n) = int_to_ang(k, n)) ELSE (
  infix_sldtsl(k, n) = int_to_ang((- k), (- n))) ENDIF));

% infix /./'spec
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= n) => (infix_sldtsl(k, n) = real_to_ang(infix_sldt(i_to_c(mod(k, 
   power(2, n))), i_to_c(power(2, n))))))
  AND (((0 <= n)
       => (((0 <= k) AND (k < power(2, n))) => (ang_meas(infix_sldtsl(k,
          n)) = infix_sldt(i_to_c(k), i_to_c(power(2, n))))))
      AND (((n < 0) => (infix_sldtsl(k, n) = real_to_ang(infix_sldt(i_to_c(
           mod((- k), power(2, (- n)))), i_to_c(power(2, (- n)))))))
          AND ((n < 0)
              => (((0 <= k) AND (k < power(2, n))) => (ang_meas(
                 infix_sldtsl(k, n)) = infix_sldt(i_to_c((- k)), i_to_c(
                 power(2, (- n)))))))))));

% int_to_ang_pos
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n) => (infix_sldtsl(k, n) = real_to_ang(infix_sldt(i_to_c(k), 
  i_to_c(power(2, n)))))));

% int_to_ang_real_mod
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n) => (infix_sldtsl(k, n) = real_to_ang(infix_sldt(i_to_c(mod(k, 
  power(2, n))), i_to_c(power(2, n)))))));

% real_to_ang_inv
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (real_to_ang(prefix_mndt(x)) = ang_inv(real_to_ang(x)))));

% real_to_ang_inv_rev
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (ang_inv(real_to_ang(x)) = real_to_ang(prefix_mndt(x)))));

% involutive_ang_inv
  ASSERT (FORALL (o : angle): (ang_inv(ang_inv(o)) = o));

% Real_To_Ang_inv_add
  ASSERT
  (FORALL (phi : complex):
  ((real_(phi)) => (ang_add(real_to_ang(phi), real_to_ang(
  prefix_mndt(phi))) = ang_zero)));

% Real_To_Ang_up
  ASSERT
  (FORALL (phi : complex):
  ((real_(phi)) => (real_to_ang(phi) = real_to_ang(infix_pldt(c_one, phi)))));

% real_To_Ang_cyclic_pos
  ASSERT
  (FORALL (phi : complex, k : INT):
  ((real_(phi))
  => ((0 <= k) => (real_to_ang(phi) = real_to_ang(infix_pldt(i_to_c(k),
     phi))))));

% real_To_Ang_cyclic_neg
  ASSERT
  (FORALL (phi : complex, k : INT):
  ((real_(phi))
  => ((0 <= k) => (real_to_ang(infix_mndt(i_to_c(k), phi)) = real_to_ang(
     prefix_mndt(phi))))));

% real_to_ang_equiv
  ASSERT
  (FORALL (x : complex, xqt : complex):
  ((real_(x))
  => ((EXISTS (k : INT): (xqt = infix_pldt(x, i_to_c(k)))) => (
     real_to_ang(x) = real_to_ang(xqt)))));

% Real_zero_n
  ASSERT (real_to_ang(c_zero) = ang_zero);

% real_ang_mult_pos
  ASSERT
  (FORALL (phi : complex, i : INT):
  ((real_(phi))
  => ((0 <= i) => (ang_mult_int(real_to_ang(phi), i) = real_to_ang(
     infix_asdt(phi, i_to_c(i)))))));

% real_ang_mult
  ASSERT
  (FORALL (phi : complex, i : INT):
  ((real_(phi)) => (ang_mult_int(real_to_ang(phi), i) = real_to_ang(
  infix_asdt(phi, i_to_c(i))))));

% real_to_ang_down_cucles
  ASSERT
  (FORALL (phi : complex, x : complex):
  ((real_(phi))
  => ((x = c_one) => (real_to_ang(infix_mndt(phi, x)) = real_to_ang(phi)))));

odd: (INT) -> BITVECTOR(1);

% odd'def
  ASSERT
  (FORALL (n : INT):
  (IF (mod(n, 2) = 1) THEN (odd(n) = 0bin1) ELSE (odd(n) = 0bin0) ENDIF));

% odd'spec
  ASSERT
  (FORALL (n : INT):
  (((odd(n) = 0bin1) => (n = ((2 * div(n, 2)) + 1)))
  AND ((odd(n) = 0bin0) => (n = (2 * div(n, 2))))));

even: (INT) -> BITVECTOR(1);

% even'def
  ASSERT
  (FORALL (n : INT):
  (IF (mod(n, 2) = 0) THEN (even(n) = 0bin1) ELSE (even(n) = 0bin0) ENDIF));

% even'spec
  ASSERT (FORALL (n : INT): ((even(n) = 0bin1) <=> (NOT (odd(n) = 0bin1))));

% even_to_mod
  ASSERT (FORALL (n : INT): ((even(n) = 0bin1) => (mod(n, 2) = 0)));

% even_minus_one
  ASSERT
  (FORALL (n : INT):
  ((0 < n) => ((even(n) = 0bin1) => (odd((n - 1)) = 0bin1))));

% odd_minus_one
  ASSERT
  (FORALL (n : INT):
  ((0 < n) => ((odd(n) = 0bin1) => (even((n - 1)) = 0bin1))));

% even_opp
  ASSERT (FORALL (n : INT): ((even(n) = 0bin1) => (even((- n)) = 0bin1)));

% odd_opp
  ASSERT (FORALL (n : INT): ((odd(n) = 0bin1) => (odd((- n)) = 0bin1)));

% odd_to_mod
  ASSERT (FORALL (n : INT): ((odd(n) = 0bin1) => (mod(n, 2) = 1)));

% even_or_odd
  ASSERT (FORALL (n : INT): ((even(n) = 0bin1) OR (odd(n) = 0bin1)));

% cpower_minus_c_one
  ASSERT
  (FORALL (n : INT):
  ((0 <= n)
  => (((even(n) = 0bin1) => (cpower(prefix_mndt(c_one), n) = c_one))
     AND ((odd(n) = 0bin1) => (cpower(prefix_mndt(c_one), n) = 
         prefix_mndt(c_one))))));

% cpower_minus_c_one_even
  ASSERT
  (FORALL (n : INT):
  ((0 <= n)
  => ((even(n) = 0bin1) => (cpower(prefix_mndt(c_one), n) = c_one))));

% cpower_minus_c_one_odd
  ASSERT
  (FORALL (n : INT):
  ((0 <= n)
  => ((odd(n) = 0bin1) => (cpower(prefix_mndt(c_one), n) = 
     prefix_mndt(c_one)))));

fc106: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : INT, i : INT): ((fc106(f,
  a)[i]) = (a * (f[i]))));

% iproduct_extract_const
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT), a : INT): (iproduct(int, 
  t2tb6(s2), t2tb7(fc106(f, a))) = (power(a, cardinal(int, t2tb6(s2))) * 
  iproduct(int, t2tb6(s2), t2tb7(f)))));

% not_null_powers_squarert_two
  ASSERT
  (FORALL (i : INT):
  ((0 <= i)
  => (NOT (cpower(square_rt(infix_pldt(c_one, c_one)), i) = c_zero))));

% real_pos_coeff
  ASSERT (real_(infix_sldt(c_one, square_rt(infix_pldt(c_one, c_one)))));

% coeffs
  ASSERT (infix_sldt(prefix_mndt(c_one), square_rt(infix_pldt(c_one,
  c_one))) = prefix_mndt(infix_sldt(c_one, square_rt(infix_pldt(c_one,
  c_one)))));

mop: (INT) -> complex;

% mop'def
  ASSERT
  (FORALL (i : INT): ((0 <= i) => (mop(i) = cpower(prefix_mndt(c_one), i))));

% minus_one_power_values
  ASSERT
  (FORALL (i : INT):
  ((0 <= i)
  => (((even(i) = 0bin1) => (mop(i) = c_one))
     AND ((odd(i) = 0bin1) => (mop(i) = prefix_mndt(c_one))))));

% factors_mop
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i) => ((0 <= j) => (mop((i + j)) = infix_asdt(mop(i), mop(j))))));

% factors_mop_rev
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i) => ((0 <= j) => (infix_asdt(mop(i), mop(j)) = mop((i + j))))));

pow_inv_sqrt_2: (INT) -> complex;

% pow_inv_sqrt_2'def
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (pow_inv_sqrt_2(i) = cpower(infix_sldt(c_one, square_rt(
  infix_pldt(c_one, c_one))), i))));

% pow_inv_sqrt_2'spec
  ASSERT
  (FORALL (i : INT):
  ((0 <= i)
  => ((real_(pow_inv_sqrt_2(i))) AND (pow_inv_sqrt_2(i) = infix_sldt(c_one, 
     square_rt(i_to_c(power(2, i))))))));

% pow_inv_sqrt_2_add
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i)
  => ((0 <= j) => (pow_inv_sqrt_2((i + j)) = infix_asdt(pow_inv_sqrt_2(i), 
     pow_inv_sqrt_2(j))))));

pow_inv_2: (INT) -> complex;

% pow_inv_2'def
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (pow_inv_2(i) = infix_sldt(c_one, i_to_c(power(2, i))))));

% pow_inv_2'spec
  ASSERT
  (FORALL (i : INT):
  ((0 <= i)
  => ((real_(pow_inv_2(i)))
     AND ((infix_gtdt(pow_inv_2(i), c_zero))
         AND ((pow_inv_2(i) = pow_inv_sqrt_2((2 * i))) AND (pow_inv_2(i) = 
             infix_asdt(pow_inv_sqrt_2(i), pow_inv_sqrt_2(i))))))));

% pow_inv_2_leq_c_one
  ASSERT
  (FORALL (i : INT): ((0 <= i) => (infix_lseqdt(pow_inv_2(i), c_one))));

% pow_inv_2_inf_c_one
  ASSERT (FORALL (i : INT): ((1 <= i) => (infix_lsdt(pow_inv_2(i), c_one))));

% pow_inv_sqrt_2_leq_c_one
  ASSERT
  (FORALL (i : INT): ((0 <= i) => (infix_lseqdt(pow_inv_sqrt_2(i), c_one))));

% pow_inv_2_sqrt_inf_c_one
  ASSERT
  (FORALL (i : INT): ((1 <= i) => (infix_lsdt(pow_inv_sqrt_2(i), c_one))));

% cpower_pow_inv_2
  ASSERT
  (FORALL (i : INT, k : INT):
  ((1 <= i) => ((1 <= k) => (cpower(pow_inv_2(i), k) = pow_inv_2((i * k))))));

% cpower_pow_inv_sqrt_2
  ASSERT
  (FORALL (i : INT, k : INT):
  ((1 <= i)
  => ((1 <= k) => (cpower(pow_inv_sqrt_2(i), k) = pow_inv_sqrt_2((i * k))))));

% cpower_2_pow_inv_sqrt_2
  ASSERT
  (FORALL (i : INT):
  ((1 <= i) => (cpower(pow_inv_sqrt_2(i), 2) = pow_inv_2(i))));

% pow_inv_2_subst
  ASSERT
  (FORALL (i : INT, j : INT):
  (((0 <= i) AND (i <= j)) => (infix_asdt(pow_inv_2(i), cpower(
  infix_pldt(c_one, c_one), j)) = cpower(infix_pldt(c_one, c_one), (j - i)))));

% pow_inv_2_
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (pow_inv_2(i) = infix_sldt(c_one, i_to_c(power(2, i))))));

% pow_inv_sqrt_2_2_add
  ASSERT (infix_pldt(pow_inv_sqrt_2(1), pow_inv_sqrt_2(1)) = square_rt(
  infix_pldt(c_one, c_one)));

% pow_inv_2_cpower
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (pow_inv_2(i) = infix_sldt(c_one, cpower(infix_pldt(c_one,
  c_one), i)))));

matrix: (ty) -> ty;

elts: (ty, uni) -> uni;

% elts_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni): (sort(infix_mngt(int, infix_mngt(int, a)), elts(a, x)))));

rows: (ty, uni) -> INT;

columns: (ty, uni) -> INT;

% matrix'invariant
  ASSERT
  (FORALL (a : ty):
  (FORALL (self : uni):PATTERN (columns(a, self)): PATTERN (rows(a, self)): 
  ((0 < rows(a, self)) AND (0 < columns(a, self)))));

valid_index: (ty, uni, INT, INT) -> BOOLEAN;

% valid_index'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, r : INT, c : INT):
  ((valid_index(a, a1, r, c))
  <=> (((0 <= r) AND (r < rows(a, a1)))
      AND ((0 <= c) AND (c < columns(a, a1)))))));

equal_size: (ty, uni, uni) -> BOOLEAN;

% equal_size'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, b : uni):
  ((equal_size(a, a1, b))
  <=> ((rows(a, a1) = rows(a, b)) AND (columns(a, a1) = columns(a, b))))));

get: (ty, uni, INT, INT) -> uni;

% get_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT): (sort(a, get(a, x, x1, x2)))));

matrix_angle: TYPE;

t2tb76: (matrix_angle) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : matrix_angle): (sort(matrix(angle1), t2tb76(x))));

tb2t76: (uni) -> matrix_angle;

% BridgeL
  ASSERT
  (FORALL (i : matrix_angle):PATTERN (t2tb76(i)):  (tb2t76(t2tb76(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb76(tb2t76(j))): 
  ((sort(matrix(angle1), j)) => (t2tb76(tb2t76(j)) = j)));

% get'def
  ASSERT
  (FORALL (a : matrix_angle, r : INT, c : INT): (tb2t33(get(angle1, 
  t2tb76(a), r, c)) = (tb2t35(infix_at(infix_mngt(int, angle1), int, 
  elts(angle1, t2tb76(a)), t2tb5(r)))[c])));

matrix_int: TYPE;

t2tb77: (matrix_int) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : matrix_int): (sort(matrix(int), t2tb77(x))));

tb2t77: (uni) -> matrix_int;

% BridgeL
  ASSERT
  (FORALL (i : matrix_int):PATTERN (t2tb77(i)):  (tb2t77(t2tb77(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb77(tb2t77(j))): 
  ((sort(matrix(int), j)) => (t2tb77(tb2t77(j)) = j)));

% get'def
  ASSERT
  (FORALL (a : matrix_int, r : INT, c : INT): (tb2t5(get(int, t2tb77(a), r,
  c)) = (tb2t7(infix_at(infix_mngt(int, int), int, elts(int, t2tb77(a)), 
  t2tb5(r)))[c])));

% get'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, r : INT, c : INT): (get(a, a1, r, c) = infix_at(a, int, 
  infix_at(infix_mngt(int, a), int, elts(a, a1), t2tb5(r)), t2tb5(c)))));

% get'spec
  ASSERT
  (FORALL (a : matrix_angle, r : INT, c : INT): (tb2t33(get(angle1, 
  t2tb76(a), r, c)) = (tb2t35(infix_at(infix_mngt(int, angle1), int, 
  elts(angle1, t2tb76(a)), t2tb5(r)))[c])));

% get'spec
  ASSERT
  (FORALL (a : matrix_int, r : INT, c : INT): (tb2t5(get(int, t2tb77(a), r,
  c)) = (tb2t7(infix_at(infix_mngt(int, int), int, elts(int, t2tb77(a)), 
  t2tb5(r)))[c])));

% get'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, r : INT, c : INT): (get(a, a1, r, c) = infix_at(a, int, 
  infix_at(infix_mngt(int, a), int, elts(a, a1), t2tb5(r)), t2tb5(c)))));

% elts_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, b : uni): ((a1 = b) => (elts(a, a1) = elts(a, b)))));

% elts_inst_eq
  ASSERT
  (FORALL (a : matrix_angle, b : matrix_angle, i : INT, j : INT):
  ((a = b)
  => (((0 <= i) AND (i < rows(angle1, t2tb76(a))))
     => (((0 <= j) AND (j < columns(angle1, t2tb76(a)))) => ((tb2t35(
        infix_at(infix_mngt(int, angle1), int, elts(angle1, t2tb76(a)), 
        t2tb5(i)))[j]) = (tb2t35(infix_at(infix_mngt(int, angle1), int, 
        elts(angle1, t2tb76(b)), t2tb5(i)))[j]))))));

% elts_inst_eq
  ASSERT
  (FORALL (a : matrix_int, b : matrix_int, i : INT, j : INT):
  ((a = b)
  => (((0 <= i) AND (i < rows(int, t2tb77(a))))
     => (((0 <= j) AND (j < columns(int, t2tb77(a)))) => ((tb2t7(infix_at(
        infix_mngt(int, int), int, elts(int, t2tb77(a)), t2tb5(i)))[j]) = (
        tb2t7(infix_at(infix_mngt(int, int), int, elts(int, t2tb77(b)), 
        t2tb5(i)))[j]))))));

% elts_inst_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, b : uni, i : INT, j : INT):
  ((a1 = b)
  => (((0 <= i) AND (i < rows(a, a1)))
     => (((0 <= j) AND (j < columns(a, a1))) => (infix_at(a, int, infix_at(
        infix_mngt(int, a), int, elts(a, a1), t2tb5(i)), t2tb5(j)) = 
        infix_at(a, int, infix_at(infix_mngt(int, a), int, elts(a, b), 
        t2tb5(i)), t2tb5(j))))))));

make: (ty, INT, INT, uni) -> uni;

% make_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : INT, x1 : INT, x2 : uni): (sort(matrix(a), make(a, x, x1,
  x2)))));

% make'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, v : uni):
  ((sort(a, v))
  => (((0 < r) AND (0 < c))
     => ((rows(a, make(a, r, c, v)) = r)
        AND ((columns(a, make(a, r, c, v)) = c)
            AND (FORALL (i : INT, j : INT):
                ((((0 <= i) AND (i < r)) AND ((0 <= j) AND (j < c))) => (
                get(a, make(a, r, c, v), i, j) = v)))))))));

% equality
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni, n : uni):
  ((sort(matrix(a), m))
  => ((sort(matrix(a), n))
     => ((m = n)
        <=> (((rows(a, m) = rows(a, n)) AND (columns(a, m) = columns(a, n)))
            AND (FORALL (i : INT, j : INT):
                ((valid_index(a, m, i, j)) => (get(a, m, i, j) = get(a, n, i,
                j))))))))));

% make_value
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, i : INT, j : INT, v : uni):
  ((sort(a, v))
  => (((0 < r) AND (0 < c))
     => (((0 <= i) AND (i < r))
        => (((0 <= j) AND (j < c)) => (get(a, make(a, r, c, v), i, j) = v)))))));

mat_indices: (ty, uni) -> set_lpintcm_intrp;

% mat_indices'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni): (mat_indices(a, m) = tb2t14(cartesian_product(int, int, 
  t2tb6(to_fset(0, rows(a, m))), t2tb6(to_fset(0, columns(a, m))))))));

% mat_indices'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni):
  ((FORALL (o : lpintcm_intrp):
   ((mem(tuple2(int, int), t2tb13(o), t2tb14(mat_indices(a, m))))
   => ((0 <= tb2t5(fir(int, int, t2tb13(o)))) AND (tb2t5(fir(int, int, 
      t2tb13(o))) < rows(a, m)))))
  AND ((FORALL (o : lpintcm_intrp):
       ((mem(tuple2(int, int), t2tb13(o), t2tb14(mat_indices(a, m))))
       => ((0 <= tb2t5(sec(int, int, t2tb13(o)))) AND (tb2t5(sec(int, int, 
          t2tb13(o))) < columns(a, m)))))
      AND ((FORALL (o : lpintcm_intrp):
           (((0 <= tb2t5(fir(int, int, t2tb13(o)))) AND (tb2t5(fir(int, int, 
            t2tb13(o))) < rows(a, m)))
           => (((0 <= tb2t5(sec(int, int, t2tb13(o)))) AND (tb2t5(sec(int,
               int, t2tb13(o))) < columns(a, m)))
              => (mem(tuple2(int, int), t2tb13(o), t2tb14(mat_indices(a,
              m)))))))
          AND (FORALL (i : INT, j : INT):
              ((valid_index(a, m, i, j)) <=> (mem(tuple2(int, int), 
              Tuple2(int, int, t2tb5(i), t2tb5(j)), t2tb14(mat_indices(a,
              m)))))))))));

set1: (ty, uni, INT, INT, uni) -> uni;

% set_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT, x3 : uni): (sort(matrix(a), set1(a,
  x, x1, x2, x3)))));

% set'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, r : INT, c : INT, v : uni):
  ((sort(a, v))
  => ((valid_index(a, a1, r, c))
     => ((rows(a, set1(a, a1, r, c, v)) = rows(a, a1))
        AND ((columns(a, set1(a, a1, r, c, v)) = columns(a, a1))
            AND ((FORALL (i : INT, j : INT):
                 ((valid_index(a, a1, i, j)) => (get(a, set1(a, a1, r, c, v),
                 i,
                 j) = (IF ((i = r) AND (j = c)) THEN v ELSE get(a, a1, i,
                      j) ENDIF))))
                AND ((get(a, set1(a, a1, r, c, v), r, c) = v)
                    AND ((FORALL (i : INT, j : INT):
                         ((valid_index(a, set1(a, a1, r, c, v), i, j))
                         => ((NOT (i = r)) => (get(a, set1(a, a1, r, c, v),
                            i, j) = get(a, a1, i, j)))))
                        AND (FORALL (i : INT, j : INT):
                            ((valid_index(a, set1(a, a1, r, c, v), i, j))
                            => ((NOT (j = c)) => (get(a, set1(a, a1, r, c,
                               v), i, j) = get(a, a1, i, j))))))))))))));

% set_valid_index
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, i : INT, j : INT):
  (((0 <= i) AND (i < rows(a, a1)))
  => (((0 <= j) AND (j < columns(a, a1))) => (valid_index(a, a1, i, j))))));

% get_valid_index
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, r : INT, c : INT):
  ((rows(a, a1) = r)
  => ((columns(a, a1) = c)
     => ((FORALL (i : INT, j : INT):
         ((valid_index(a, a1, i, j)) => ((0 <= i) AND (i < r))))
        AND (FORALL (i : INT, j : INT):
            ((valid_index(a, a1, i, j)) => ((0 <= j) AND (j < c)))))))));

% get_valid_index_params
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, r : INT, c : INT, i : INT, j : INT):
  ((rows(a, a1) = r)
  => ((columns(a, a1) = c)
     => ((valid_index(a, a1, i, j))
        => (((0 <= i) AND (i < r)) AND ((0 <= j) AND (j < c))))))));

% set_values
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, r : INT, c : INT, v : uni):
  ((sort(a, v))
  => ((valid_index(a, a1, r, c))
     => (FORALL (i : INT, j : INT):
        ((valid_index(a, a1, i, j)) => (get(a, set1(a, a1, r, c, v), i,
        j) = (IF ((i = r) AND (j = c)) THEN v ELSE get(a, a1, i, j) ENDIF))))))));

% set_rows
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, r : INT, c : INT, v : uni):
  ((valid_index(a, a1, r, c)) => (rows(a, set1(a, a1, r, c, v)) = rows(a,
  a1)))));

% set_columns
  ASSERT
  (FORALL (a : ty):
  (FORALL (a1 : uni, r : INT, c : INT, v : uni):
  ((valid_index(a, a1, r, c)) => (columns(a, set1(a, a1, r, c, v)) = 
  columns(a, a1)))));

make_func: (ty, INT, INT, uni) -> uni;

% make_func_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : INT, x1 : INT, x2 : uni): (sort(matrix(a), make_func(a, x, x1,
  x2)))));

% make_func'spec
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF angle))):
  ((0 < r)
  => ((0 < c)
     => ((tb2t36(elts(angle1, make_func(angle1, r, c, t2tb36(f)))) = f)
        AND ((rows(angle1, make_func(angle1, r, c, t2tb36(f))) = r)
            AND ((columns(angle1, make_func(angle1, r, c, t2tb36(f))) = c)
                AND (FORALL (i : INT, j : INT): (tb2t33(get(angle1, 
                    make_func(angle1, r, c, t2tb36(f)), i, j)) = (tb2t35(
                    infix_at(infix_mngt(int, angle1), int, t2tb36(f), 
                    t2tb5(i)))[j])))))))));

% make_func'spec
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF INT))):
  ((0 < r)
  => ((0 < c)
     => ((tb2t8(elts(int, make_func(int, r, c, t2tb8(f)))) = f)
        AND ((rows(int, make_func(int, r, c, t2tb8(f))) = r)
            AND ((columns(int, make_func(int, r, c, t2tb8(f))) = c)
                AND (FORALL (i : INT, j : INT): (tb2t5(get(int, 
                    make_func(int, r, c, t2tb8(f)), i, j)) = (tb2t7(infix_at(
                    infix_mngt(int, int), int, t2tb8(f), t2tb5(i)))[j])))))))));

% make_func'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, f : uni):
  ((sort(infix_mngt(int, infix_mngt(int, a)), f))
  => ((0 < r)
     => ((0 < c)
        => ((elts(a, make_func(a, r, c, f)) = f)
           AND ((rows(a, make_func(a, r, c, f)) = r)
               AND ((columns(a, make_func(a, r, c, f)) = c)
                   AND (FORALL (i : INT, j : INT): (get(a, make_func(a, r, c,
                       f), i, j) = infix_at(a, int, infix_at(infix_mngt(int,
                       a), int, f, t2tb5(i)), t2tb5(j))))))))))));

make_f: (ty, INT, INT, uni) -> uni;

% make_f_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : INT, x1 : INT, x2 : uni): (sort(matrix(a), make_f(a, x, x1,
  x2)))));

% make_f'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, f : uni):
  ((0 < r) => ((0 < c) => (make_f(a, r, c, f) = make_func(a, r, c, f))))));

% make_f'spec
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF angle))):
  ((0 < r)
  => ((0 < c)
     => ((rows(angle1, make_f(angle1, r, c, t2tb36(f))) = r)
        AND ((columns(angle1, make_f(angle1, r, c, t2tb36(f))) = c)
            AND (FORALL (i : INT, j : INT): (tb2t33(get(angle1, 
                make_f(angle1, r, c, t2tb36(f)), i, j)) = (tb2t35(infix_at(
                infix_mngt(int, angle1), int, t2tb36(f), t2tb5(i)))[j]))))))));

% make_f'spec
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF INT))):
  ((0 < r)
  => ((0 < c)
     => ((rows(int, make_f(int, r, c, t2tb8(f))) = r)
        AND ((columns(int, make_f(int, r, c, t2tb8(f))) = c)
            AND (FORALL (i : INT, j : INT): (tb2t5(get(int, make_f(int, r, c, 
                t2tb8(f)), i, j)) = (tb2t7(infix_at(infix_mngt(int, int),
                int, t2tb8(f), t2tb5(i)))[j]))))))));

% make_f'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, f : uni):
  ((0 < r)
  => ((0 < c)
     => ((rows(a, make_f(a, r, c, f)) = r)
        AND ((columns(a, make_f(a, r, c, f)) = c)
            AND (FORALL (i : INT, j : INT): (get(a, make_f(a, r, c, f), i,
                j) = infix_at(a, int, infix_at(infix_mngt(int, a), int, f, 
                t2tb5(i)), t2tb5(j))))))))));

% assert_make
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF angle)),
  i : INT, j : INT):
  (((0 <= i) AND (i < r))
  => (((0 <= j) AND (j < c)) => (tb2t33(get(angle1, make_f(angle1, r, c, 
     t2tb36(f)), i, j)) = (tb2t35(infix_at(infix_mngt(int, angle1), int, 
     t2tb36(f), t2tb5(i)))[j])))));

% assert_make
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF INT)), i : INT,
  j : INT):
  (((0 <= i) AND (i < r))
  => (((0 <= j) AND (j < c)) => (tb2t5(get(int, make_f(int, r, c, t2tb8(f)),
     i, j)) = (tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(f), 
     t2tb5(i)))[j])))));

% assert_make
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, f : uni, i : INT, j : INT):
  (((0 <= i) AND (i < r))
  => (((0 <= j) AND (j < c)) => (get(a, make_f(a, r, c, f), i, j) = 
     infix_at(a, int, infix_at(infix_mngt(int, a), int, f, t2tb5(i)), 
     t2tb5(j)))))));

% assert_make_r
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, f : uni):
  ((0 < r) => ((0 < c) => (rows(a, make_f(a, r, c, f)) = r)))));

% assert_make_c
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, f : uni):
  ((0 < r) => ((0 < c) => (columns(a, make_f(a, r, c, f)) = c)))));

to_indexes: (ty, uni) -> set_lpintcm_intrp;

% to_indexes'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni): (to_indexes(a, m) = tb2t14(cartesian_product(int, int, 
  t2tb6(to_fset(0, rows(a, m))), t2tb6(to_fset(0, columns(a, m))))))));

% to_indexes'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni): (cardinal(tuple2(int, int), t2tb14(to_indexes(a,
  m))) = (rows(a, m) * columns(a, m)))));

% set_to_indexes_mem
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni, i : INT, j : INT):
  (((0 <= i) AND (i < rows(a, m)))
  => (((0 <= j) AND (j < columns(a, m))) => (mem(tuple2(int, int), 
     Tuple2(int, int, t2tb5(i), t2tb5(j)), t2tb14(to_indexes(a, m))))))));

% get_to_indexes_mem
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni, o : lpintcm_intrp):
  ((mem(tuple2(int, int), t2tb13(o), t2tb14(to_indexes(a, m))))
  => (((0 <= tb2t5(fir(int, int, t2tb13(o)))) AND (tb2t5(fir(int, int, 
      t2tb13(o))) < rows(a, m)))
     AND ((0 <= tb2t5(sec(int, int, t2tb13(o)))) AND (tb2t5(sec(int, int, 
         t2tb13(o))) < columns(a, m)))))));

% mat_equality
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni, n : uni):
  ((rows(a, m) = rows(a, n))
  => ((columns(a, m) = columns(a, n))
     => ((FORALL (i : INT, j : INT):
         ((valid_index(a, m, i, j)) => (get(a, m, i, j) = get(a, n, i, j))))
        => (infix_eqeq(matrix(a), m, n)))))));

square: (ty, uni) -> BOOLEAN;

% square'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni): ((square(a, m)) <=> (rows(a, m) = columns(a, m)))));

% equal_sym
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni, n : uni):
  ((infix_eqeq(matrix(a), m, n)) <=> (infix_eqeq(matrix(a), n, m)))));

% equal_rex
  ASSERT
  (FORALL (a : ty): (FORALL (m : uni): (infix_eqeq(matrix(a), m, m))));

% equal_trans
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni, n : uni, o : uni):
  ((infix_eqeq(matrix(a), m, n))
  => ((infix_eqeq(matrix(a), n, o)) => (infix_eqeq(matrix(a), m, o))))));

% set_equal_mat
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni, n : uni):
  ((sort(matrix(a), m))
  => ((sort(matrix(a), n))
     => ((rows(a, m) = rows(a, n))
        => ((columns(a, m) = columns(a, n))
           => ((FORALL (i : INT, j : INT):
               ((valid_index(a, m, i, j)) => (get(a, m, i, j) = get(a, n, i,
               j))))
              => (m = n))))))));

% set_equal_mat_make
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF angle)),
  g : (ARRAY INT OF (ARRAY INT OF angle))):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (i : INT, j : INT):
         (((0 <= i) AND (i < r))
         => (((0 <= j) AND (j < c)) => ((tb2t35(infix_at(infix_mngt(int,
            angle1), int, t2tb36(f), t2tb5(i)))[j]) = (tb2t35(infix_at(
            infix_mngt(int, angle1), int, t2tb36(g), t2tb5(i)))[j])))))
        => (tb2t76(make_f(angle1, r, c, t2tb36(f))) = tb2t76(make_f(angle1,
        r, c, t2tb36(g))))))));

% set_equal_mat_make
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF INT)),
  g : (ARRAY INT OF (ARRAY INT OF INT))):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (i : INT, j : INT):
         (((0 <= i) AND (i < r))
         => (((0 <= j) AND (j < c)) => ((tb2t7(infix_at(infix_mngt(int, int),
            int, t2tb8(f), t2tb5(i)))[j]) = (tb2t7(infix_at(infix_mngt(int,
            int), int, t2tb8(g), t2tb5(i)))[j])))))
        => (tb2t77(make_f(int, r, c, t2tb8(f))) = tb2t77(make_f(int, r, c, 
        t2tb8(g))))))));

% set_equal_mat_make
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, f : uni, g : uni):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (i : INT, j : INT):
         (((0 <= i) AND (i < r))
         => (((0 <= j) AND (j < c)) => (infix_at(a, int, infix_at(
            infix_mngt(int, a), int, f, t2tb5(i)), t2tb5(j)) = infix_at(a,
            int, infix_at(infix_mngt(int, a), int, g, t2tb5(i)), t2tb5(j))))))
        => (make_f(a, r, c, f) = make_f(a, r, c, g)))))));

% set_equal_mat_make_t
  ASSERT
  (FORALL (r : INT, rqt : INT, c : INT, cqt : INT,
  f : (ARRAY INT OF (ARRAY INT OF angle)),
  g : (ARRAY INT OF (ARRAY INT OF angle))):
  ((0 < r)
  => ((0 < c)
     => ((r = rqt)
        => ((c = cqt)
           => ((FORALL (i : INT, j : INT):
               (((0 <= i) AND (i < r))
               => (((0 <= j) AND (j < c)) => ((tb2t35(infix_at(
                  infix_mngt(int, angle1), int, t2tb36(f), t2tb5(i)))[j]) = (
                  tb2t35(infix_at(infix_mngt(int, angle1), int, t2tb36(g), 
                  t2tb5(i)))[j])))))
              => (tb2t76(make_f(angle1, r, c, t2tb36(f))) = tb2t76(
              make_f(angle1, rqt, cqt, t2tb36(g))))))))));

% set_equal_mat_make_t
  ASSERT
  (FORALL (r : INT, rqt : INT, c : INT, cqt : INT,
  f : (ARRAY INT OF (ARRAY INT OF INT)),
  g : (ARRAY INT OF (ARRAY INT OF INT))):
  ((0 < r)
  => ((0 < c)
     => ((r = rqt)
        => ((c = cqt)
           => ((FORALL (i : INT, j : INT):
               (((0 <= i) AND (i < r))
               => (((0 <= j) AND (j < c)) => ((tb2t7(infix_at(infix_mngt(int,
                  int), int, t2tb8(f), t2tb5(i)))[j]) = (tb2t7(infix_at(
                  infix_mngt(int, int), int, t2tb8(g), t2tb5(i)))[j])))))
              => (tb2t77(make_f(int, r, c, t2tb8(f))) = tb2t77(make_f(int,
              rqt, cqt, t2tb8(g))))))))));

% set_equal_mat_make_t
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, rqt : INT, c : INT, cqt : INT, f : uni, g : uni):
  ((0 < r)
  => ((0 < c)
     => ((r = rqt)
        => ((c = cqt)
           => ((FORALL (i : INT, j : INT):
               (((0 <= i) AND (i < r))
               => (((0 <= j) AND (j < c)) => (infix_at(a, int, infix_at(
                  infix_mngt(int, a), int, f, t2tb5(i)), t2tb5(j)) = 
                  infix_at(a, int, infix_at(infix_mngt(int, a), int, g, 
                  t2tb5(i)), t2tb5(j))))))
              => (make_f(a, r, c, f) = make_f(a, rqt, cqt, g)))))))));

% get_equal_mat
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : uni, n : uni):
  ((m = n)
  => ((rows(a, m) = rows(a, n))
     AND ((columns(a, m) = columns(a, n))
         AND (FORALL (i : INT, j : INT):
             ((valid_index(a, m, i, j)) => (get(a, m, i, j) = get(a, n, i,
             j)))))))));

% equal_functions
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF angle)),
  g : (ARRAY INT OF (ARRAY INT OF angle))):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (i : INT, j : INT):
         ((((0 <= i) AND (i < r)) AND ((0 <= j) AND (j < c))) => ((tb2t35(
         infix_at(infix_mngt(int, angle1), int, t2tb36(f), t2tb5(i)))[j]) = (
         tb2t35(infix_at(infix_mngt(int, angle1), int, t2tb36(g), 
         t2tb5(i)))[j]))))
        => (tb2t76(make_f(angle1, r, c, t2tb36(f))) = tb2t76(make_f(angle1,
        r, c, t2tb36(g))))))));

% equal_functions
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF (ARRAY INT OF INT)),
  g : (ARRAY INT OF (ARRAY INT OF INT))):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (i : INT, j : INT):
         ((((0 <= i) AND (i < r)) AND ((0 <= j) AND (j < c))) => ((tb2t7(
         infix_at(infix_mngt(int, int), int, t2tb8(f), t2tb5(i)))[j]) = (
         tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(g), t2tb5(i)))[j]))))
        => (tb2t77(make_f(int, r, c, t2tb8(f))) = tb2t77(make_f(int, r, c, 
        t2tb8(g))))))));

% equal_functions
  ASSERT
  (FORALL (a : ty):
  (FORALL (r : INT, c : INT, f : uni, g : uni):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (i : INT, j : INT):
         ((((0 <= i) AND (i < r)) AND ((0 <= j) AND (j < c))) => (infix_at(a,
         int, infix_at(infix_mngt(int, a), int, f, t2tb5(i)), t2tb5(j)) = 
         infix_at(a, int, infix_at(infix_mngt(int, a), int, g, t2tb5(i)), 
         t2tb5(j)))))
        => (make_f(a, r, c, f) = make_f(a, r, c, g)))))));

% equal_functions_mat
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)), m : matrix_angle):
  ((FORALL (i : INT, j : INT):
   ((((0 <= i) AND (i < rows(angle1, t2tb76(m))))
    AND ((0 <= j) AND (j < columns(angle1, t2tb76(m)))))
   => ((tb2t35(infix_at(infix_mngt(int, angle1), int, t2tb36(f), 
   t2tb5(i)))[j]) = tb2t33(get(angle1, t2tb76(m), i, j)))))
  => (m = tb2t76(make_f(angle1, rows(angle1, t2tb76(m)), columns(angle1, 
  t2tb76(m)), t2tb36(f))))));

% equal_functions_mat
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF INT)), m : matrix_int):
  ((FORALL (i : INT, j : INT):
   ((((0 <= i) AND (i < rows(int, t2tb77(m))))
    AND ((0 <= j) AND (j < columns(int, t2tb77(m)))))
   => ((tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(f), t2tb5(i)))[j]) = 
   tb2t5(get(int, t2tb77(m), i, j)))))
  => (m = tb2t77(make_f(int, rows(int, t2tb77(m)), columns(int, t2tb77(m)), 
  t2tb8(f))))));

% equal_functions_mat
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : uni):
  ((sort(matrix(a), m))
  => ((FORALL (i : INT, j : INT):
      ((((0 <= i) AND (i < rows(a, m)))
       AND ((0 <= j) AND (j < columns(a, m))))
      => (infix_at(a, int, infix_at(infix_mngt(int, a), int, f, t2tb5(i)), 
      t2tb5(j)) = get(a, m, i, j))))
     => (m = make_f(a, rows(a, m), columns(a, m), f))))));

matrix_complex: TYPE;

null_mat: (matrix_complex) -> BOOLEAN;

t2tb18: (matrix_complex) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : matrix_complex): (sort(matrix(complex1), t2tb18(x))));

tb2t18: (uni) -> matrix_complex;

% BridgeL
  ASSERT
  (FORALL (i : matrix_complex):PATTERN (t2tb18(i)):  (tb2t18(t2tb18(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb18(tb2t18(j))): 
  ((sort(matrix(complex1), j)) => (t2tb18(tb2t18(j)) = j)));

% null_mat'def
  ASSERT
  (FORALL (a : matrix_complex):
  ((null_mat(a))
  <=> (FORALL (i : INT, j : INT):
      ((valid_index(complex1, t2tb18(a), i, j)) => (tb2t(get(complex1, 
      t2tb18(a), i, j)) = c_zero)))));

% set_null_mat
  ASSERT
  (FORALL (a : matrix_complex):
  ((FORALL (i : INT, j : INT):
   ((valid_index(complex1, t2tb18(a), i, j)) => (tb2t(get(complex1, 
   t2tb18(a), i, j)) = c_zero)))
  => (null_mat(a))));

% get_null_mat
  ASSERT
  (FORALL (a : matrix_complex):
  ((null_mat(a))
  => (FORALL (i : INT, j : INT):
     ((valid_index(complex1, t2tb18(a), i, j)) => (tb2t(get(complex1, 
     t2tb18(a), i, j)) = c_zero)))));

identity: (INT) -> matrix_complex;

result6: (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (i : INT, j : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), int, t2tb15(result6), t2tb5(i)), 
  t2tb5(j))) = (IF (i = j) THEN c_one ELSE c_zero ENDIF)));

% identity'def
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (identity(n) = tb2t18(make_f(complex1, power(2, n), power(2,
  n), t2tb15(result6))))));

% identity'spec
  ASSERT
  (FORALL (n : INT):
  ((0 <= n)
  => ((rows(complex1, t2tb18(identity(n))) = power(2, n))
     AND ((columns(complex1, t2tb18(identity(n))) = power(2, n))
         AND (FORALL (i : INT, j : INT):
             ((valid_index(complex1, t2tb18(identity(n)), i, j)) => (tb2t(
             get(complex1, t2tb18(identity(n)), i,
             j)) = (IF (i = j) THEN c_one ELSE c_zero ENDIF))))))));

% identity_rows
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (rows(complex1, t2tb18(identity(n))) = power(2, n))));

% identity_columns
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (columns(complex1, t2tb18(identity(n))) = power(2, n))));

% identity_values
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < power(2, n))) => (tb2t(get(complex1, t2tb18(
        identity(n)), i, j)) = (IF (i = j) THEN c_one ELSE c_zero ENDIF))))));

kronecker: (matrix_complex, matrix_complex) -> matrix_complex;

result7: (matrix_complex,
  matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  result7(m, n)), t2tb5(i)), t2tb5(j))) = infix_asdt(tb2t(get(complex1, 
  t2tb18(m), div(i, rows(complex1, t2tb18(n))), div(j, columns(complex1, 
  t2tb18(n))))), tb2t(get(complex1, t2tb18(n), mod(i, rows(complex1, 
  t2tb18(n))), mod(j, columns(complex1, t2tb18(n))))))));

% kronecker'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex): (kronecker(m, n) = 
  tb2t18(make_f(complex1, (rows(complex1, t2tb18(m)) * rows(complex1, 
  t2tb18(n))), (columns(complex1, t2tb18(m)) * columns(complex1, t2tb18(n))), 
  t2tb15(result7(m, n))))));

% kronecker'spec
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((rows(complex1, t2tb18(kronecker(m, n))) = (rows(complex1, t2tb18(m)) * 
  rows(complex1, t2tb18(n))))
  AND ((columns(complex1, t2tb18(kronecker(m, n))) = (columns(complex1, 
      t2tb18(m)) * columns(complex1, t2tb18(n))))
      AND (FORALL (i : INT, j : INT):
          ((valid_index(complex1, t2tb18(kronecker(m, n)), i, j)) => (tb2t(
          get(complex1, t2tb18(kronecker(m, n)), i, j)) = infix_asdt(tb2t(
          get(complex1, t2tb18(m), div(i, rows(complex1, t2tb18(n))), div(j, 
          columns(complex1, t2tb18(n))))), tb2t(get(complex1, t2tb18(n), 
          mod(i, rows(complex1, t2tb18(n))), mod(j, columns(complex1, 
          t2tb18(n))))))))))));

% kronecker_eq
  ASSERT
  (FORALL (m1 : matrix_complex, n1 : matrix_complex, m2 : matrix_complex,
  n2 : matrix_complex):
  ((m1 = m2) => ((n1 = n2) => (kronecker(m1, n1) = kronecker(m2, n2)))));

fc107: (matrix_complex,
  matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc107(m, n)), t2tb5(i)), t2tb5(j))) = infix_asdt(tb2t(get(complex1, 
  t2tb18(m), div(i, rows(complex1, t2tb18(n))), div(j, columns(complex1, 
  t2tb18(n))))), tb2t(get(complex1, t2tb18(n), mod(i, rows(complex1, 
  t2tb18(n))), mod(j, columns(complex1, t2tb18(n))))))));

% get_kronecker
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex): (kronecker(m, n) = 
  tb2t18(make_f(complex1, (rows(complex1, t2tb18(m)) * rows(complex1, 
  t2tb18(n))), (columns(complex1, t2tb18(m)) * columns(complex1, t2tb18(n))), 
  t2tb15(fc107(m, n))))));

% kronecker_values
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT):
  ((valid_index(complex1, t2tb18(kronecker(m, n)), i, j)) => (tb2t(
  get(complex1, t2tb18(kronecker(m, n)), i, j)) = infix_asdt(tb2t(
  get(complex1, t2tb18(m), div(i, rows(complex1, t2tb18(n))), div(j, 
  columns(complex1, t2tb18(n))))), tb2t(get(complex1, t2tb18(n), mod(i, 
  rows(complex1, t2tb18(n))), mod(j, columns(complex1, t2tb18(n)))))))));

% kronecker_rows
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex): (rows(complex1, t2tb18(
  kronecker(m, n))) = (rows(complex1, t2tb18(m)) * rows(complex1, 
  t2tb18(n)))));

% kronecker_columns
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex): (columns(complex1, 
  t2tb18(kronecker(m, n))) = (columns(complex1, t2tb18(m)) * 
  columns(complex1, t2tb18(n)))));

% kronecker_values_gen
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  (FORALL (i : INT, j : INT):
  ((valid_index(complex1, t2tb18(kronecker(m, n)), i, j)) => (tb2t(
  get(complex1, t2tb18(kronecker(m, n)), i, j)) = infix_asdt(tb2t(
  get(complex1, t2tb18(m), div(i, rows(complex1, t2tb18(n))), div(j, 
  columns(complex1, t2tb18(n))))), tb2t(get(complex1, t2tb18(n), mod(i, 
  rows(complex1, t2tb18(n))), mod(j, columns(complex1, t2tb18(n))))))))));

% kronecker_mod_values
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT):
  ((valid_index(complex1, t2tb18(kronecker(m, n)), i, j)) => (tb2t(
  get(complex1, t2tb18(kronecker(m, n)), i, j)) = infix_asdt(tb2t(
  get(complex1, t2tb18(m), div(mod(i, rows(complex1, t2tb18(kronecker(m,
  n)))), rows(complex1, t2tb18(n))), div(mod(j, columns(complex1, t2tb18(
  kronecker(m, n)))), columns(complex1, t2tb18(n))))), tb2t(get(complex1, 
  t2tb18(n), mod(mod(i, rows(complex1, t2tb18(kronecker(m, n)))), 
  rows(complex1, t2tb18(n))), mod(mod(j, columns(complex1, t2tb18(
  kronecker(m, n)))), columns(complex1, t2tb18(n)))))))));

% kronecker_indexes
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT, k : INT,
  l : INT):
  ((valid_index(complex1, t2tb18(m), i, j))
  => ((valid_index(complex1, t2tb18(n), k, l)) => (valid_index(complex1, 
     t2tb18(kronecker(m, n)), ((i * rows(complex1, t2tb18(n))) + k), ((j * 
     columns(complex1, t2tb18(n))) + l))))));

% kronecker_indexes_com
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT):
  ((valid_index(complex1, t2tb18(kronecker(m, n)), i, j))
  => ((valid_index(complex1, t2tb18(m), div(i, rows(complex1, t2tb18(n))), 
     div(j, columns(complex1, t2tb18(n))))) AND (valid_index(complex1, 
     t2tb18(n), mod(i, rows(complex1, t2tb18(n))), mod(j, columns(complex1, 
     t2tb18(n))))))));

% kronecker_assoc_pre
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex,
  i : INT, j : INT):
  (((0 <= i) AND (i < ((rows(complex1, t2tb18(m)) * rows(complex1, 
   t2tb18(n))) * rows(complex1, t2tb18(o)))))
  => (((0 <= j) AND (j < ((columns(complex1, t2tb18(m)) * columns(complex1, 
      t2tb18(n))) * columns(complex1, t2tb18(o)))))
     => (tb2t(get(complex1, t2tb18(kronecker(kronecker(m, n), o)), i, j)) = 
     tb2t(get(complex1, t2tb18(kronecker(m, kronecker(n, o))), i, j))))));

kronecker_closure: (ARRAY matrix_complex OF (ARRAY matrix_complex OF matrix_complex));

t2tb19: ((ARRAY matrix_complex OF matrix_complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY matrix_complex OF matrix_complex)): (sort(infix_mngt(
  matrix(complex1), matrix(complex1)), t2tb19(x))));

tb2t19: (uni) -> (ARRAY matrix_complex OF matrix_complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY matrix_complex OF matrix_complex)):PATTERN (t2tb19(i)):
   (tb2t19(t2tb19(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb19(tb2t19(j))): 
  ((sort(infix_mngt(matrix(complex1), matrix(complex1)), j)) => (t2tb19(
  tb2t19(j)) = j)));

t2tb20: ((ARRAY matrix_complex OF (ARRAY matrix_complex OF matrix_complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY matrix_complex OF (ARRAY matrix_complex OF matrix_complex))):
  (sort(infix_mngt(matrix(complex1), infix_mngt(matrix(complex1), 
  matrix(complex1))), t2tb20(x))));

tb2t20: (uni) -> (ARRAY matrix_complex OF (ARRAY matrix_complex OF matrix_complex));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY matrix_complex OF (ARRAY matrix_complex OF matrix_complex))):PATTERN (
  t2tb20(i)):  (tb2t20(t2tb20(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb20(tb2t20(j))): 
  ((sort(infix_mngt(matrix(complex1), infix_mngt(matrix(complex1), 
  matrix(complex1))), j)) => (t2tb20(tb2t20(j)) = j)));

% kronecker_closure_def
  ASSERT
  (FORALL (y : matrix_complex, y1 : matrix_complex): (tb2t18(infix_at(
  matrix(complex1), matrix(complex1), infix_at(infix_mngt(matrix(complex1), 
  matrix(complex1)), matrix(complex1), t2tb20(kronecker_closure), t2tb18(y)), 
  t2tb18(y1))) = kronecker(y, y1)));

% kronecker_assoc
  ASSERT (op_assoc(matrix(complex1), t2tb20(kronecker_closure)));

% kronecker_assoc_use
  ASSERT
  (FORALL (a : matrix_complex, b : matrix_complex, c : matrix_complex): (
  kronecker(a, kronecker(b, c)) = kronecker(kronecker(a, b), c)));

% kronecker_assoc_use_rev
  ASSERT
  (FORALL (a : matrix_complex, b : matrix_complex, c : matrix_complex): (
  kronecker(kronecker(a, b), c) = kronecker(a, kronecker(b, c))));

% neutral_
  ASSERT
  (FORALL (m : matrix_complex):
  ((kronecker(m, tb2t18(make(complex1, 1, 1, t2tb(c_one)))) = m) AND (
  kronecker(tb2t18(make(complex1, 1, 1, t2tb(c_one))), m) = m)));

% neutral
  ASSERT
  ((tb2t18(make(complex1, 1, 1, t2tb(c_one))) = tb2t18(neutral_elt(
  matrix(complex1), t2tb20(kronecker_closure))))
  AND ((has_neutral(matrix(complex1), t2tb20(kronecker_closure)))
      AND (iterable(matrix(complex1), t2tb20(kronecker_closure)))));

% kronecker_equal
  ASSERT
  (FORALL (m : matrix_complex, ml : matrix_complex, n : matrix_complex,
  nl : matrix_complex):
  ((infix_eqeq(matrix(complex1), t2tb18(m), t2tb18(ml)))
  => ((infix_eqeq(matrix(complex1), t2tb18(n), t2tb18(nl))) => (infix_eqeq(
     matrix(complex1), t2tb18(kronecker(m, n)), t2tb18(kronecker(ml, nl)))))));

% kron_id
  ASSERT
  (FORALL (m : INT, n : INT):
  ((0 <= m)
  => ((0 <= n) => (kronecker(identity(m), identity(n)) = identity((m + n))))));

frows: ((ARRAY INT OF matrix_complex), INT) -> INT;

t2tb21: ((ARRAY INT OF matrix_complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF matrix_complex)): (sort(infix_mngt(int, 
  matrix(complex1)), t2tb21(x))));

tb2t21: (uni) -> (ARRAY INT OF matrix_complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF matrix_complex)):PATTERN (t2tb21(i)):  (tb2t21(
  t2tb21(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb21(tb2t21(j))): 
  ((sort(infix_mngt(int, matrix(complex1)), j)) => (t2tb21(tb2t21(j)) = j)));

% frows'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), k : INT): (frows(f, k) = 
  rows(complex1, infix_at(matrix(complex1), int, t2tb21(f), t2tb5(k)))));

% frows'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), k : INT): (0 < frows(f, k)));

fcolumns: ((ARRAY INT OF matrix_complex), INT) -> INT;

% fcolumns'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), k : INT): (fcolumns(f, k) = 
  columns(complex1, infix_at(matrix(complex1), int, t2tb21(f), t2tb5(k)))));

% fcolumns'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), k : INT): (0 < fcolumns(f, k)));

fc746: (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex));

t2tb22: ((ARRAY matrix_complex OF (ARRAY INT OF matrix_complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex))):
  (sort(infix_mngt(matrix(complex1), infix_mngt(int, matrix(complex1))), 
  t2tb22(x))));

tb2t22: (uni) -> (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex))):PATTERN (
  t2tb22(i)):  (tb2t22(t2tb22(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb22(tb2t22(j))): 
  ((sort(infix_mngt(matrix(complex1), infix_mngt(int, matrix(complex1))), j))
  => (t2tb22(tb2t22(j)) = j)));

% fc'def
  ASSERT
  (FORALL (y0 : matrix_complex, y1 : INT): (tb2t18(infix_at(matrix(complex1),
  int, infix_at(infix_mngt(int, matrix(complex1)), matrix(complex1), 
  t2tb22(fc746), t2tb18(y0)), t2tb5(y1))) = y0));

% const_fcol
  ASSERT
  (FORALL (m : matrix_complex, k : INT): (fcolumns(tb2t21(infix_at(
  infix_mngt(int, matrix(complex1)), matrix(complex1), t2tb22(fc746), 
  t2tb18(m))), k) = columns(complex1, t2tb18(m))));

fc747: (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex));

% fc'def
  ASSERT
  (FORALL (y0 : matrix_complex, y1 : INT): (tb2t18(infix_at(matrix(complex1),
  int, infix_at(infix_mngt(int, matrix(complex1)), matrix(complex1), 
  t2tb22(fc747), t2tb18(y0)), t2tb5(y1))) = y0));

% const_frows
  ASSERT
  (FORALL (m : matrix_complex, k : INT): (frows(tb2t21(infix_at(
  infix_mngt(int, matrix(complex1)), matrix(complex1), t2tb22(fc747), 
  t2tb18(m))), k) = rows(complex1, t2tb18(m))));

mat_mult_no_bound: (matrix_complex, matrix_complex) -> matrix_complex;

result8: (matrix_complex, matrix_complex, INT,
  INT) -> (ARRAY INT OF complex);

result9: (matrix_complex,
  matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

result10: (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(result8(m, n, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), i, k)), tb2t(
  get(complex1, t2tb18(n), k, j)))));

% result'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  result9(m, n)), t2tb5(i)), t2tb5(j))) = ind_sum(result8(m, n, i, j), 0, 
  columns(complex1, t2tb18(m)))));

% result'def
  ASSERT
  (FORALL (us : INT, us1 : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), int, t2tb15(result10), t2tb5(us)), 
  t2tb5(us1))) = c_zero));

% mat_mult_no_bound'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  (IF (columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) THEN (
  mat_mult_no_bound(m, n) = tb2t18(make_f(complex1, rows(complex1, 
  t2tb18(m)), columns(complex1, t2tb18(n)), t2tb15(result9(m, n))))) ELSE (
  mat_mult_no_bound(m, n) = tb2t18(make_f(complex1, 1, 1, 
  t2tb15(result10)))) ENDIF));

fc110: (matrix_complex, matrix_complex, INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc110(m, n, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), i, k)), tb2t(
  get(complex1, t2tb18(n), k, j)))));

% mat_mult_no_bound'spec
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (
   rows(complex1, t2tb18(mat_mult_no_bound(m, n))) = rows(complex1, 
   t2tb18(m))))
  AND (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (
       columns(complex1, t2tb18(mat_mult_no_bound(m, n))) = columns(complex1, 
       t2tb18(n))))
      AND ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
          => (FORALL (i : INT, j : INT):
             ((valid_index(complex1, t2tb18(mat_mult_no_bound(m, n)), i, j))
             => (tb2t(get(complex1, t2tb18(mat_mult_no_bound(m, n)), i,
             j)) = ind_sum(fc110(m, n, i, j), 0, columns(complex1, 
             t2tb18(m))))))))));

mat_mult: (matrix_complex, matrix_complex) -> matrix_complex;

% mat_mult'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (mat_mult(m,
  n) = mat_mult_no_bound(m, n))));

fc111: (matrix_complex, matrix_complex, INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc111(m, n, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), i, k)), tb2t(
  get(complex1, t2tb18(n), k, j)))));

% mat_mult'spec
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((rows(complex1, t2tb18(mat_mult(m, n))) = rows(complex1, t2tb18(m)))
     AND ((columns(complex1, t2tb18(mat_mult(m, n))) = columns(complex1, 
         t2tb18(n)))
         AND (FORALL (i : INT, j : INT):
             ((valid_index(complex1, t2tb18(mat_mult(m, n)), i, j)) => (tb2t(
             get(complex1, t2tb18(mat_mult(m, n)), i, j)) = ind_sum(fc111(m,
             n, i, j), 0, columns(complex1, t2tb18(m))))))))));

fc112: (matrix_complex, matrix_complex, INT, INT) -> (ARRAY INT OF complex);

fc113: (matrix_complex,
  matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc112(m, n, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), i, k)), tb2t(
  get(complex1, t2tb18(n), k, j)))));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc113(m, n)), t2tb5(i)), t2tb5(j))) = ind_sum(fc112(m, n, i, j), 0, 
  columns(complex1, t2tb18(m)))));

% correct_mat_mult
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (mat_mult(m,
  n) = tb2t18(make_f(complex1, rows(complex1, t2tb18(m)), columns(complex1, 
  t2tb18(n)), t2tb15(fc113(m, n)))))));

fc114: (matrix_complex, matrix_complex, INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc114(m, n, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), i, k)), tb2t(
  get(complex1, t2tb18(n), k, j)))));

% mat_mult_values
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((valid_index(complex1, t2tb18(mat_mult(m, n)), i, j)) => (tb2t(
     get(complex1, t2tb18(mat_mult(m, n)), i, j)) = ind_sum(fc114(m, n, i,
     j), 0, columns(complex1, t2tb18(m)))))));

% mat_mult_columns
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (
  columns(complex1, t2tb18(mat_mult(m, n))) = columns(complex1, t2tb18(n)))));

% mat_mult_rows
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (
  rows(complex1, t2tb18(mat_mult(m, n))) = rows(complex1, t2tb18(m)))));

fc115: (matrix_complex, matrix_complex, INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc115(m, n, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), i, k)), tb2t(
  get(complex1, t2tb18(n), k, j)))));

% mat_mult_values_quant
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => (FORALL (i : INT, j : INT):
     ((valid_index(complex1, t2tb18(mat_mult(m, n)), i, j)) => (tb2t(
     get(complex1, t2tb18(mat_mult(m, n)), i, j)) = ind_sum(fc115(m, n, i,
     j), 0, columns(complex1, t2tb18(m))))))));

int_mat_prod: ((ARRAY INT OF matrix_complex), INT, INT) -> matrix_complex;

% int_mat_prod'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), i : INT, j : INT):
  ((i <= j)
  => ((FORALL (k : INT, kqt : INT):
      ((((i <= k) AND (k <= j)) AND ((i <= kqt) AND (kqt <= j)))
      => ((rows(complex1, infix_at(matrix(complex1), int, t2tb21(f), 
         t2tb5(k))) = rows(complex1, infix_at(matrix(complex1), int, 
         t2tb21(f), t2tb5(kqt)))) AND (rows(complex1, infix_at(
         matrix(complex1), int, t2tb21(f), t2tb5(kqt))) = columns(complex1, 
         infix_at(matrix(complex1), int, t2tb21(f), t2tb5(kqt)))))))
     => (IF ((j - i) = 0) THEN (int_mat_prod(f, i, j) = tb2t18(infix_at(
        matrix(complex1), int, t2tb21(f), t2tb5(i)))) ELSE (int_mat_prod(f,
        i, j) = mat_mult_no_bound(int_mat_prod(f, i, (j - 1)), tb2t18(
        infix_at(matrix(complex1), int, t2tb21(f), t2tb5(j))))) ENDIF))));

% int_mat_prod'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), i : INT, j : INT):
  ((i <= j)
  => ((FORALL (k : INT, kqt : INT):
      ((((i <= k) AND (k <= j)) AND ((i <= kqt) AND (kqt <= j)))
      => ((rows(complex1, infix_at(matrix(complex1), int, t2tb21(f), 
         t2tb5(k))) = rows(complex1, infix_at(matrix(complex1), int, 
         t2tb21(f), t2tb5(kqt)))) AND (rows(complex1, infix_at(
         matrix(complex1), int, t2tb21(f), t2tb5(kqt))) = columns(complex1, 
         infix_at(matrix(complex1), int, t2tb21(f), t2tb5(kqt)))))))
     => ((rows(complex1, t2tb18(int_mat_prod(f, i, j))) = rows(complex1, 
        infix_at(matrix(complex1), int, t2tb21(f), t2tb5(i))))
        AND ((columns(complex1, t2tb18(int_mat_prod(f, i, j))) = 
            columns(complex1, infix_at(matrix(complex1), int, t2tb21(f), 
            t2tb5(i)))) AND (columns(complex1, t2tb18(int_mat_prod(f, i,
            j))) = rows(complex1, infix_at(matrix(complex1), int, t2tb21(f), 
            t2tb5(i)))))))));

% int_mat_prod_zero
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), i : INT, j : INT):
  ((rows(complex1, infix_at(matrix(complex1), int, t2tb21(f), t2tb5(i))) = 
  columns(complex1, infix_at(matrix(complex1), int, t2tb21(f), t2tb5(i))))
  => ((i = j) => (int_mat_prod(f, i, j) = tb2t18(infix_at(matrix(complex1),
     int, t2tb21(f), t2tb5(i)))))));

int_mat_prod_plus_one: ((ARRAY INT OF matrix_complex), INT, INT) -> tuple0;

% int_mat_prod_plus_one'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), i : INT, j : INT):
  ((i < j)
  => ((FORALL (k : INT, kqt : INT):
      ((((i <= k) AND (k <= j)) AND ((i <= kqt) AND (kqt <= j)))
      => ((rows(complex1, infix_at(matrix(complex1), int, t2tb21(f), 
         t2tb5(k))) = rows(complex1, infix_at(matrix(complex1), int, 
         t2tb21(f), t2tb5(kqt)))) AND (rows(complex1, infix_at(
         matrix(complex1), int, t2tb21(f), t2tb5(kqt))) = columns(complex1, 
         infix_at(matrix(complex1), int, t2tb21(f), t2tb5(kqt)))))))
     => (int_mat_prod_plus_one(f, i, j) = Tuple0))));

% int_mat_prod_plus_one'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), i : INT, j : INT):
  ((i < j)
  => ((FORALL (k : INT, kqt : INT):
      ((((i <= k) AND (k <= j)) AND ((i <= kqt) AND (kqt <= j)))
      => ((rows(complex1, infix_at(matrix(complex1), int, t2tb21(f), 
         t2tb5(k))) = rows(complex1, infix_at(matrix(complex1), int, 
         t2tb21(f), t2tb5(kqt)))) AND (rows(complex1, infix_at(
         matrix(complex1), int, t2tb21(f), t2tb5(kqt))) = columns(complex1, 
         infix_at(matrix(complex1), int, t2tb21(f), t2tb5(kqt)))))))
     => (int_mat_prod(f, i, j) = mat_mult(int_mat_prod(f, i, (j - 1)), 
     tb2t18(infix_at(matrix(complex1), int, t2tb21(f), t2tb5(j))))))));

% int_mat_prod_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex),
  g : (ARRAY INT OF matrix_complex), i : INT, j : INT):
  ((i <= j)
  => ((FORALL (k : INT, kqt : INT):
      (((i <= k) AND (k <= j))
      => (((i <= kqt) AND (kqt <= j))
         => ((rows(complex1, infix_at(matrix(complex1), int, t2tb21(f), 
            t2tb5(k))) = rows(complex1, infix_at(matrix(complex1), int, 
            t2tb21(f), t2tb5(kqt)))) AND (rows(complex1, infix_at(
            matrix(complex1), int, t2tb21(f), t2tb5(kqt))) = 
            columns(complex1, infix_at(matrix(complex1), int, t2tb21(f), 
            t2tb5(kqt))))))))
     => ((FORALL (k : INT):
         (((i <= k) AND (k <= j)) => (tb2t18(infix_at(matrix(complex1), int, 
         t2tb21(f), t2tb5(k))) = tb2t18(infix_at(matrix(complex1), int, 
         t2tb21(g), t2tb5(k))))))
        => (int_mat_prod(f, i, j) = int_mat_prod(g, i, j))))));

% mat_mult_id
  ASSERT
  (FORALL (n : INT, m : matrix_complex):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = power(2, n)) => (mat_mult(m, 
     identity(n)) = m))));

% id_mat_mult
  ASSERT
  (FORALL (n : INT, m : matrix_complex):
  ((0 <= n)
  => ((rows(complex1, t2tb18(m)) = power(2, n)) => (mat_mult(identity(n),
     m) = m))));

% mat_mult_eq
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, mqt : matrix_complex,
  nqt : matrix_complex):
  ((m = mqt)
  => ((n = nqt)
     => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (
        mat_mult(m, n) = mat_mult(mqt, nqt))))));

add_mat: (matrix_complex, matrix_complex) -> matrix_complex;

result11: (matrix_complex,
  matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  result11(m, n)), t2tb5(i)), t2tb5(j))) = infix_pldt(tb2t(get(complex1, 
  t2tb18(m), i, j)), tb2t(get(complex1, t2tb18(n), i, j)))));

% add_mat'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) => (
     add_mat(m, n) = tb2t18(make_f(complex1, rows(complex1, t2tb18(m)), 
     columns(complex1, t2tb18(m)), t2tb15(result11(m, n))))))));

% add_mat'spec
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => (((columns(complex1, t2tb18(add_mat(m, n))) = columns(complex1, 
         t2tb18(m))) AND (columns(complex1, t2tb18(m)) = columns(complex1, 
         t2tb18(n))))
        AND (((rows(complex1, t2tb18(add_mat(m, n))) = rows(complex1, 
             t2tb18(m))) AND (rows(complex1, t2tb18(m)) = rows(complex1, 
             t2tb18(n))))
            AND (FORALL (i : INT, j : INT): (tb2t(get(complex1, t2tb18(
                add_mat(m, n)), i, j)) = infix_pldt(tb2t(get(complex1, 
                t2tb18(m), i, j)), tb2t(get(complex1, t2tb18(n), i, j))))))))));

% add_mat_equal
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, mqt : matrix_complex,
  nqt : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((m = mqt) => ((n = nqt) => (add_mat(m, n) = add_mat(mqt, nqt)))))));

% add_value
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
  => ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
     => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
        => (FORALL (i : INT, j : INT):
           (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
           => (((0 <= j) AND (j < columns(complex1, t2tb18(m)))) => (tb2t(
              get(complex1, t2tb18(add_mat(m, n)), i, j)) = infix_pldt(tb2t(
              get(complex1, t2tb18(m), i, j)), tb2t(get(complex1, t2tb18(n),
              i, j)))))))))));

% add_values
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT):
  ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
  => ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (tb2t(
     get(complex1, t2tb18(add_mat(m, n)), i, j)) = infix_pldt(tb2t(
     get(complex1, t2tb18(m), i, j)), tb2t(get(complex1, t2tb18(n), i, j)))))));

% add_mat_null_left
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
  => ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
     => ((null_mat(m)) => (add_mat(m, n) = n)))));

% add_mat_null_right
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
  => ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
     => ((null_mat(n)) => (add_mat(m, n) = m)))));

% set_equal_columns_elt
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT):
  (((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) AND (
   columns(complex1, t2tb18(n)) = i))
  => (columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))));

% set_equal_rows_elt
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT):
  (((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) AND (
   rows(complex1, t2tb18(n)) = i))
  => (rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))));

% add_columns
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
  => ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (
     columns(complex1, t2tb18(add_mat(m, n))) = columns(complex1, 
     t2tb18(m))))));

% add_rows
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
  => ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (
     rows(complex1, t2tb18(add_mat(m, n))) = rows(complex1, t2tb18(m))))));

% set_equal_dim_elt
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT):
  (((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) AND (
   rows(complex1, t2tb18(n)) = i))
  => (((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) AND (
      columns(complex1, t2tb18(n)) = j))
     => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) AND (
        rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))))));

% set_dim_add
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT):
  (((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) AND (
   rows(complex1, t2tb18(n)) = i))
  => (((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) AND (
      columns(complex1, t2tb18(n)) = j))
     => ((rows(complex1, t2tb18(add_mat(m, n))) = i) AND (columns(complex1, 
        t2tb18(add_mat(m, n))) = j)))));

% add_mat_eq
  ASSERT
  (FORALL (m : matrix_complex, m1 : matrix_complex, n : matrix_complex,
  n1 : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((m = m1) => ((n = n1) => (add_mat(m, n) = add_mat(m1, n1)))))));

% add_mat_comm
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) => (
     add_mat(m, n) = add_mat(n, m)))));

% add_mat_eq_rev
  ASSERT
  (FORALL (m : matrix_complex, m1 : matrix_complex, n : matrix_complex,
  n1 : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((m = m1) => ((n = n1) => (add_mat(n, m) = add_mat(m1, n1)))))));

add_neutral: (tuple0) -> matrix_complex;

% add_neutral'spec
  ASSERT
  (FORALL (us : tuple0):
  ((FORALL (i : INT, j : INT):
   ((valid_index(complex1, t2tb18(add_neutral(us)), i, j)) => (tb2t(
   get(complex1, t2tb18(add_neutral(us)), i, j)) = c_zero)))
  AND ((0 < rows(complex1, t2tb18(add_neutral(us)))) AND (0 < 
      columns(complex1, t2tb18(add_neutral(us)))))));

% distr_1_pre
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex,
  i : INT, j : INT):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o)))
        => (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
           => (((0 <= j) AND (j < columns(complex1, t2tb18(o)))) => (tb2t(
              get(complex1, t2tb18(mat_mult(add_mat(m, n), o)), i, j)) = 
              tb2t(get(complex1, t2tb18(add_mat(mat_mult(m, o), mat_mult(n,
              o))), i, j)))))))));

% distr_l
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
        mat_mult(add_mat(m, n), o) = add_mat(mat_mult(m, o), mat_mult(n,
        o)))))));

% distr_2_pre
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex,
  i : INT, j : INT):
  ((rows(complex1, t2tb18(n)) = rows(complex1, t2tb18(o)))
  => ((columns(complex1, t2tb18(n)) = columns(complex1, t2tb18(o)))
     => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
        => (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
           => (((0 <= j) AND (j < columns(complex1, t2tb18(n))))
              => ((valid_index(complex1, t2tb18(mat_mult(m, add_mat(n, o))),
                 i, j)) AND (tb2t(get(complex1, t2tb18(mat_mult(m, add_mat(n,
                 o))), i, j)) = tb2t(get(complex1, t2tb18(add_mat(mat_mult(m,
                 n), mat_mult(m, o))), i, j))))))))));

% distr_r
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex):
  ((rows(complex1, t2tb18(n)) = rows(complex1, t2tb18(o)))
  => ((columns(complex1, t2tb18(n)) = columns(complex1, t2tb18(o)))
     => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) => (
        mat_mult(m, add_mat(n, o)) = add_mat(mat_mult(m, n), mat_mult(m,
        o)))))));

infix_asdtdt: (complex, matrix_complex) -> matrix_complex;

result12: (complex, matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (s2 : complex, m : matrix_complex, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  result12(s2, m)), t2tb5(i)), t2tb5(j))) = infix_asdt(s2, tb2t(get(complex1, 
  t2tb18(m), i, j)))));

% infix *..'def
  ASSERT
  (FORALL (s2 : complex, m : matrix_complex): (infix_asdtdt(s2, m) = tb2t18(
  make_f(complex1, rows(complex1, t2tb18(m)), columns(complex1, t2tb18(m)), 
  t2tb15(result12(s2, m))))));

% infix *..'spec
  ASSERT
  (FORALL (s2 : complex, m : matrix_complex):
  ((columns(complex1, t2tb18(infix_asdtdt(s2, m))) = columns(complex1, 
  t2tb18(m)))
  AND ((rows(complex1, t2tb18(infix_asdtdt(s2, m))) = rows(complex1, 
      t2tb18(m)))
      AND ((FORALL (i : INT, j : INT):
           ((valid_index(complex1, t2tb18(infix_asdtdt(s2, m)), i, j)) => (
           tb2t(get(complex1, t2tb18(infix_asdtdt(s2, m)), i, j)) = 
           infix_asdt(s2, tb2t(get(complex1, t2tb18(m), i, j))))))
          AND (FORALL (i : INT, j : INT):
              ((valid_index(complex1, t2tb18(infix_asdtdt(s2, m)), i, j))
              <=> (valid_index(complex1, t2tb18(m), i, j))))))));

% scalar_columns
  ASSERT
  (FORALL (m : matrix_complex, a : complex): (columns(complex1, t2tb18(
  infix_asdtdt(a, m))) = columns(complex1, t2tb18(m))));

% scalar_values
  ASSERT
  (FORALL (m : matrix_complex, a : complex, i : INT, j : INT): (tb2t(
  get(complex1, t2tb18(infix_asdtdt(a, m)), i, j)) = infix_asdt(a, tb2t(
  get(complex1, t2tb18(m), i, j)))));

% scalar_rows
  ASSERT
  (FORALL (m : matrix_complex, a : complex): (rows(complex1, t2tb18(
  infix_asdtdt(a, m))) = rows(complex1, t2tb18(m))));

% scalar_null
  ASSERT (FORALL (m : matrix_complex): (null_mat(infix_asdtdt(c_zero, m))));

% scalar_c_one
  ASSERT (FORALL (m : matrix_complex): (infix_asdtdt(c_one, m) = m));

% scalar_c_one_gen
  ASSERT
  (FORALL (m : matrix_complex, a : complex):
  ((a = c_one) => (infix_asdtdt(a, m) = m)));

% scalar_null_gen
  ASSERT
  (FORALL (m : matrix_complex, a : complex):
  ((a = c_zero) => (null_mat(infix_asdtdt(a, m)))));

% scalar_plus
  ASSERT
  (FORALL (m : matrix_complex, a : complex, b : complex): (infix_asdtdt(
  infix_pldt(a, b), m) = add_mat(infix_asdtdt(a, m), infix_asdtdt(b, m))));

% scalar_plus_rev
  ASSERT
  (FORALL (m : matrix_complex, a : complex, b : complex): (add_mat(
  infix_asdtdt(a, m), infix_asdtdt(b, m)) = infix_asdtdt(infix_pldt(a, b),
  m)));

% add_scal
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) => (
     infix_asdtdt(a, add_mat(m, n)) = add_mat(infix_asdtdt(a, m), 
     infix_asdtdt(a, n))))));

% add_scal_rev
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) => (
     add_mat(infix_asdtdt(a, m), infix_asdtdt(a, n)) = infix_asdtdt(a, 
     add_mat(m, n))))));

fc116: (matrix_complex, matrix_complex, complex, INT,
  INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex, i : INT,
  j : INT, k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc116(m, n, a, i,
  j)), t2tb5(k))) = infix_asdt(infix_asdt(a, tb2t(get(complex1, t2tb18(m), i,
  k))), tb2t(get(complex1, t2tb18(n), k, j)))));

% mat_mult_scal_values_l
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex, i : INT,
  j : INT):
  ((rows(complex1, t2tb18(n)) = columns(complex1, t2tb18(m)))
  => (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
     => (((0 <= j) AND (j < columns(complex1, t2tb18(n)))) => (infix_asdt(a, 
        tb2t(get(complex1, t2tb18(mat_mult(m, n)), i, j))) = ind_sum(fc116(m,
        n, a, i, j), 0, columns(complex1, t2tb18(m))))))));

fc117: (matrix_complex, matrix_complex, complex, INT,
  INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex, i : INT,
  j : INT, k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc117(m, n, a, i,
  j)), t2tb5(k))) = infix_asdt(infix_asdt(a, tb2t(get(complex1, t2tb18(m), i,
  k))), tb2t(get(complex1, t2tb18(n), k, j)))));

% mat_mult_scal_values_r
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex, i : INT,
  j : INT):
  ((rows(complex1, t2tb18(n)) = columns(complex1, t2tb18(m)))
  => ((rows(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
        => (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
           => (((0 <= j) AND (j < columns(complex1, t2tb18(n)))) => (
              infix_asdt(tb2t(get(complex1, t2tb18(mat_mult(m, n)), i, j)),
              a) = ind_sum(fc117(m, n, a, i, j), 0, columns(complex1, 
              t2tb18(m))))))))));

% mat_mut_scal
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex):
  ((rows(complex1, t2tb18(n)) = columns(complex1, t2tb18(m))) => (mat_mult(m, 
  infix_asdtdt(a, n)) = infix_asdtdt(a, mat_mult(m, n)))));

% scal_mat_mut
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex):
  ((rows(complex1, t2tb18(n)) = columns(complex1, t2tb18(m))) => (mat_mult(
  infix_asdtdt(a, m), n) = infix_asdtdt(a, mat_mult(m, n)))));

% mat_mut_scal_rev
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex):
  ((rows(complex1, t2tb18(n)) = columns(complex1, t2tb18(m))) => (
  infix_asdtdt(a, mat_mult(m, n)) = mat_mult(m, infix_asdtdt(a, n)))));

% scal_mat_mut_rev
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex):
  ((rows(complex1, t2tb18(n)) = columns(complex1, t2tb18(m))) => (
  infix_asdtdt(a, mat_mult(m, n)) = mat_mult(infix_asdtdt(a, m), n))));

fc118: ((ARRAY INT OF (ARRAY INT OF complex)), (ARRAY INT OF complex), INT,
  INT) -> (ARRAY INT OF complex);

fc119: ((ARRAY INT OF (ARRAY INT OF complex)), (ARRAY INT OF complex),
  INT) -> (ARRAY INT OF complex);

fc120: ((ARRAY INT OF (ARRAY INT OF complex)), (ARRAY INT OF complex), INT,
  INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF complex)),
  g : (ARRAY INT OF complex), k : INT, l : INT, k1 : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc118(f, g, k, l)), t2tb5(k1))) = 
  infix_asdt(ind_sum(tb2t12(infix_at(infix_mngt(int, complex1), int, 
  t2tb15(f), t2tb5(k1))), k, l), tb2t(infix_at(complex1, int, t2tb12(g), 
  t2tb5(k1))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF complex)),
  g : (ARRAY INT OF complex), k1 : INT, k2 : INT): (tb2t(infix_at(complex1,
  int, t2tb12(fc119(f, g, k1)), t2tb5(k2))) = infix_asdt(tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(f), 
  t2tb5(k2)), t2tb5(k1))), tb2t(infix_at(complex1, int, t2tb12(g), 
  t2tb5(k2))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF complex)),
  g : (ARRAY INT OF complex), i : INT, j : INT, k1 : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc120(f, g, i, j)), t2tb5(k1))) = ind_sum(
  fc119(f, g, k1), i, j)));

% ind_sum_commute_scal_r
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF complex)),
  g : (ARRAY INT OF complex), i : INT, j : INT, k : INT, l : INT):
  ((i <= j)
  => ((k <= l) => (ind_sum(fc118(f, g, k, l), i, j) = ind_sum(fc120(f, g, i,
     j), k, l)))));

% mat_mult_assoc_pre
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex,
  i : INT, j : INT):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(n)) = rows(complex1, t2tb18(o)))
     => (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
        => (((0 <= j) AND (j < columns(complex1, t2tb18(o)))) => (tb2t(
           get(complex1, t2tb18(mat_mult(mat_mult(m, n), o)), i, j)) = tb2t(
           get(complex1, t2tb18(mat_mult(m, mat_mult(n, o))), i, j))))))));

% mat_mult_assoc
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(n)) = rows(complex1, t2tb18(o))) => (
     mat_mult(mat_mult(m, n), o) = mat_mult(m, mat_mult(n, o))))));

% mat_mult_assoc_quant
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => (FORALL (o : matrix_complex):
     ((columns(complex1, t2tb18(n)) = rows(complex1, t2tb18(o))) => (
     mat_mult(mat_mult(m, n), o) = mat_mult(m, mat_mult(n, o)))))));

% mat_mult_assoc_comm
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex):
  ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(n)) = rows(complex1, t2tb18(o))) => (
     mat_mult(m, mat_mult(n, o)) = mat_mult(mat_mult(m, n), o)))));

% scalar_eq
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex):
  ((m = n) => (infix_asdtdt(a, m) = infix_asdtdt(a, n))));

% scalar_eq_gen
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex, b : complex):
  ((m = n) => ((a = b) => (infix_asdtdt(a, m) = infix_asdtdt(b, n)))));

% scalar_add
  ASSERT
  (FORALL (m : matrix_complex, a : complex, b : complex): (infix_asdtdt(
  infix_pldt(a, b), m) = add_mat(infix_asdtdt(a, m), infix_asdtdt(b, m))));

% scalar_assoc
  ASSERT
  (FORALL (m : matrix_complex, a : complex, b : complex): (infix_asdtdt(a, 
  infix_asdtdt(b, m)) = infix_asdtdt(infix_asdt(a, b), m)));

% scalar_assoc_rev
  ASSERT
  (FORALL (m : matrix_complex, a : complex, b : complex): (infix_asdtdt(
  infix_asdt(a, b), m) = infix_asdtdt(a, infix_asdtdt(b, m))));

% scalars_inv
  ASSERT
  (FORALL (m : matrix_complex, a : complex, b : complex, aqt : complex,
  bqt : complex):
  ((a = aqt)
  => ((b = bqt) => (infix_asdtdt(aqt, infix_asdtdt(bqt, m)) = infix_asdtdt(b, 
     infix_asdtdt(a, m))))));

% eq_scalar
  ASSERT
  (FORALL (m : matrix_complex, a : complex, b : complex):
  ((EXISTS (i : INT, j : INT):
   ((valid_index(complex1, t2tb18(m), i, j))
   AND (NOT (tb2t(get(complex1, t2tb18(m), i, j)) = c_zero))))
  => ((infix_asdtdt(a, m) = infix_asdtdt(b, m)) => (a = b))));

mat_substr: (matrix_complex, matrix_complex) -> matrix_complex;

% mat_substr'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) => (
     mat_substr(m, n) = add_mat(m, infix_asdtdt(prefix_mndt(c_one), n))))));

% mat_substr'spec
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((rows(complex1, t2tb18(mat_substr(m, n))) = rows(complex1, 
        t2tb18(m)))
        AND ((columns(complex1, t2tb18(mat_substr(m, n))) = columns(complex1, 
            t2tb18(m)))
            AND (FORALL (i : INT, j : INT):
                (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
                => (((0 <= j) AND (j < columns(complex1, t2tb18(m)))) => (
                   tb2t(get(complex1, t2tb18(mat_substr(m, n)), i, j)) = 
                   infix_mndt(tb2t(get(complex1, t2tb18(m), i, j)), tb2t(
                   get(complex1, t2tb18(n), i, j))))))))))));

% substr_rows
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, r : INT):
  (((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n))) AND (
   rows(complex1, t2tb18(n)) = r))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) => (
     rows(complex1, t2tb18(mat_substr(m, n))) = r))));

% substr_columns
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, c : INT):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => (((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) AND (
      columns(complex1, t2tb18(n)) = c))
     => (columns(complex1, t2tb18(mat_substr(m, n))) = c))));

% substr_value
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT, j : INT):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
        => (((0 <= j) AND (j < columns(complex1, t2tb18(m)))) => (tb2t(
           get(complex1, t2tb18(mat_substr(m, n)), i, j)) = infix_mndt(tb2t(
           get(complex1, t2tb18(m), i, j)), tb2t(get(complex1, t2tb18(n), i,
           j)))))))));

% distr_l_substr
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
        mat_mult(mat_substr(m, n), o) = mat_substr(mat_mult(m, o), 
        mat_mult(n, o)))))));

% distr_r_substr
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex):
  ((rows(complex1, t2tb18(n)) = rows(complex1, t2tb18(o)))
  => ((columns(complex1, t2tb18(n)) = columns(complex1, t2tb18(o)))
     => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
        mat_mult(m, mat_substr(n, o)) = mat_substr(mat_mult(m, n), 
        mat_mult(m, o)))))));

% mat_substr_eq
  ASSERT
  (FORALL (m : matrix_complex, mqt : matrix_complex, n : matrix_complex,
  nqt : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((m = mqt)
        => ((n = nqt) => (mat_substr(m, n) = mat_substr(mqt, nqt)))))));

% substr_decomp
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) => (m = 
     add_mat(n, mat_substr(m, n))))));

% subtr_scal
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) => (
     infix_asdtdt(a, mat_substr(m, n)) = mat_substr(infix_asdtdt(a, m), 
     infix_asdtdt(a, n))))));

% subtr_scal_rev
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n))) => (
     mat_substr(infix_asdtdt(a, m), infix_asdtdt(a, n)) = infix_asdtdt(a, 
     mat_substr(m, n))))));

% get_equal_mat_to_substr
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((m = n) => (mat_substr(m, n) = tb2t18(make(complex1, rows(complex1, 
        t2tb18(m)), columns(complex1, t2tb18(m)), t2tb(c_zero))))))));

% set_inequal_mat_by_substr
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((NOT (m = n))
        <=> (NOT (mat_substr(m, n) = tb2t18(make(complex1, rows(complex1, 
            t2tb18(m)), columns(complex1, t2tb18(m)), t2tb(c_zero)))))))));

% pow_inv_2_scal
  ASSERT
  (FORALL (i : INT, x : matrix_complex):
  ((0 <= i) => (infix_asdtdt(pow_inv_2(i), x) = infix_asdtdt(
  pow_inv_sqrt_2(i), infix_asdtdt(pow_inv_sqrt_2(i), x)))));

% pow_inv_2_from_int
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (pow_inv_2(n) = infix_sldt(c_one, i_to_c(power(2, n))))));

% pow_inv_2_sq_rt
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (square_rt(pow_inv_2(n)) = pow_inv_sqrt_2(n))));

% pow_inv_sqrt_2_double
  ASSERT
  (FORALL (n : INT): ((0 <= n) => (pow_inv_sqrt_2((2 * n)) = pow_inv_2(n))));

% pos_pow_inv_2
  ASSERT
  (FORALL (i : INT): ((0 <= i) => (infix_lseqdt(c_zero, pow_inv_2(i)))));

% pos_pow_inv_sqrt_2
  ASSERT
  (FORALL (i : INT): ((0 <= i) => (infix_lseqdt(c_zero, pow_inv_sqrt_2(i)))));

% strict_pos_pow_inv_2
  ASSERT
  (FORALL (i : INT): ((0 <= i) => (infix_lsdt(c_zero, pow_inv_2(i)))));

% pow_inv_2_add
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i)
  => ((0 <= j) => (pow_inv_2((i + j)) = infix_asdt(pow_inv_2(i), 
     pow_inv_2(j))))));

% pow_inv_2_plus_one
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (pow_inv_2((i + 1)) = infix_asdt(infix_sldt(c_one, 
  infix_pldt(c_one, c_one)), pow_inv_2(i)))));

% pow_inv_2_plus_one_rev
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (infix_asdt(infix_sldt(c_one, infix_pldt(c_one, c_one)), 
  pow_inv_2(i)) = pow_inv_2((i + 1)))));

% pow_inv_2_with_
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (pow_inv_2(i) = infix_sldt(c_one, i_to_c(power(2, i))))));

% pow_inv_2_to_one
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (infix_asdt(i_to_c(power(2, i)), pow_inv_2(i)) = c_one)));

% pow_inv_2_one
  ASSERT
  (FORALL (i : INT):
  ((i = 1) => (i_to_c(power(2, i)) = infix_pldt(c_one, c_one))));

% pow_inv_2_to_one_gen
  ASSERT
  (FORALL (i : INT, x : complex):
  ((0 <= i)
  => ((x = i_to_c(power(2, i))) => (infix_asdt(pow_inv_2(i), x) = c_one))));

% pow_inv_to_pow_2
  ASSERT
  (FORALL (k : INT, l : INT):
  ((0 <= l)
  => ((l <= k) => (infix_asdt(pow_inv_2(k), i_to_c(power(2, l))) = 
     pow_inv_2((k - l))))));

neg_pow_inv_sqrt_2: (INT) -> complex;

% neg_pow_inv_sqrt_2'def
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (neg_pow_inv_sqrt_2(i) = cpower(infix_sldt(prefix_mndt(c_one), 
  square_rt(infix_pldt(c_one, c_one))), i))));

% inv_pow_inv_sqrt_2
  ASSERT (infix_asdt(pow_inv_sqrt_2(1), square_rt(infix_pldt(c_one,
  c_one))) = c_one);

% pow_inv_sqrt_2_values
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (pow_inv_sqrt_2(i) = infix_sldt(c_one, cpower(square_rt(
  infix_pldt(c_one, c_one)), i)))));

% neg_pow_inv_sqrt_2_values
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (neg_pow_inv_sqrt_2(i) = infix_asdt(mop(i), infix_sldt(c_one, 
  cpower(square_rt(infix_pldt(c_one, c_one)), i))))));

% ppos_neg_coeff_values
  ASSERT
  (FORALL (i : INT):
  ((0 <= i)
  => (((even(i) = 0bin1) => (pow_inv_sqrt_2(i) = neg_pow_inv_sqrt_2(i)))
     AND (((odd(i) = 0bin1) => (pow_inv_sqrt_2(i) = prefix_mndt(
          neg_pow_inv_sqrt_2(i))))
         AND (neg_pow_inv_sqrt_2(i) = infix_asdt(mop(i), pow_inv_sqrt_2(i)))))));

pow_inv_sqrt_2_neg: (INT) -> complex;

% pow_inv_sqrt_2_neg'def
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (pow_inv_sqrt_2_neg(i) = prefix_mndt(pow_inv_sqrt_2(i)))));

% int_to_ang_to_real_to_ang
  ASSERT
  (FORALL (theta : angle, k : INT, n : INT):
  ((0 <= n)
  => ((theta = infix_sldtsl(k, n)) => (theta = real_to_ang(infix_asdt(
     i_to_c(k), pow_inv_2(n)))))));

% real_to_ang_to_int_to_ang
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n) => (real_to_ang(infix_asdt(i_to_c(k), pow_inv_2(n))) = 
  infix_sldtsl(k, n))));

% real_to_ang_to_int_to_ang_add
  ASSERT
  (FORALL (k : INT, kqt : INT, n : INT):
  ((0 <= n) => (real_to_ang(infix_asdt(infix_pldt(i_to_c(k), i_to_c(kqt)), 
  pow_inv_2(n))) = infix_sldtsl((k + kqt), n))));

% int_to_ang_to_real_to_ang_gen
  ASSERT
  (FORALL (k : INT, n : INT, kx : complex):
  ((0 <= n)
  => ((kx = i_to_c(k)) => (infix_sldtsl(k, n) = real_to_ang(infix_asdt(kx, 
     pow_inv_2(n)))))));

% Int_To_Ang_inv
  ASSERT
  (FORALL (k : INT, n : INT): (ang_inv(infix_sldtsl(k, n)) = 
  infix_sldtsl((- k), n)));

% Int_To_Ang_inv_add
  ASSERT
  (FORALL (k : INT, n : INT): (ang_add(infix_sldtsl(k, n), 
  infix_sldtsl((- k), n)) = ang_zero));

% Int_To_Ang_add
  ASSERT
  (FORALL (k : INT, kqt : INT, n : INT): (ang_add(infix_sldtsl(k, n), 
  infix_sldtsl(kqt, n)) = infix_sldtsl((k + kqt), n)));

% Int_To_Ang_up
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n) => (infix_sldtsl(k, n) = infix_sldtsl((2 * k), (n + 1)))));

% Int_To_Ang_cyclic
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n) => (infix_sldtsl(k, n) = infix_sldtsl((k + power(2, n)), n))));

% Zero_n
  ASSERT (FORALL (n : INT): (infix_sldtsl(0, n) = ang_zero));

% set_ang_minus_one_by_int
  ASSERT
  (FORALL (a : INT, b : INT):
  ((a = 1) => ((b = 1) => (infix_sldtsl(a, b) = infix_sldtsl(1, 1)))));

% ang_minus_one_from_real
  ASSERT (infix_sldtsl(1, 1) = real_to_ang(infix_sldt(c_one, 
  infix_pldt(c_one, c_one))));

% ang_exp_minus_one
  ASSERT (ang_exp(infix_sldtsl(1, 1)) = prefix_mndt(c_one));

% set_ang_zero_by_int
  ASSERT
  (FORALL (a : INT, b : INT):
  ((a = 0) => ((0 <= b) => (infix_sldtsl(a, b) = ang_zero))));

% ang_minus_one_twice
  ASSERT
  (FORALL (a1 : angle, a2 : angle):
  ((a1 = infix_sldtsl(1, 1))
  => ((a2 = infix_sldtsl(1, 1)) => (ang_add(a1, a2) = ang_zero))));

div_two: (angle) -> angle;

% div_two'def
  ASSERT
  (FORALL (d : angle): (div_two(d) = real_to_ang(infix_sldt(ang_meas(d), 
  infix_pldt(c_one, c_one)))));

% div_two'spec
  ASSERT
  (FORALL (d : angle):
  ((ang_meas(div_two(d)) = infix_sldt(ang_meas(d), infix_pldt(c_one, c_one)))
  AND (ang_add(div_two(d), div_two(d)) = d)));

% Div_two
  ASSERT (FORALL (d : angle): (ang_add(div_two(d), div_two(d)) = d));

% div_two_int_to_ang
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n)
  => (((0 <= k) AND (k < power(2, n))) => (div_two(infix_sldtsl(k, n)) = 
     infix_sldtsl(k, (n + 1))))));

% ang_exp_mult
  ASSERT
  (FORALL (x : angle, xqt : angle): (infix_asdt(ang_exp(x), ang_exp(xqt)) = 
  ang_exp(ang_add(x, xqt))));

% ang_exp_modulus
  ASSERT (FORALL (x : angle): (modulus(ang_exp(x)) = c_one));

% ang_exp_not_one
  ASSERT
  (FORALL (i : complex):
  (((infix_lsdt(c_zero, i)) AND (infix_lsdt(i, c_one)))
  => (NOT (ang_exp(real_to_ang(i)) = c_one))));

% ang_exp_not_by_modulus
  ASSERT
  (FORALL (i : complex):
  (((infix_lsdt(c_zero, i)) AND (infix_lsdt(i, c_one)))
  => (NOT (ang_exp(real_to_ang(modulus(i))) = c_one))));

k_int_to_ang: (INT) -> angle;

% k_int_to_ang'def
  ASSERT
  (FORALL (k : INT): ((0 <= k) => (k_int_to_ang(k) = infix_sldtsl(1, k))));

% K_int_to_angplus_one
  ASSERT
  (FORALL (k : INT):
  ((0 < k) => (ang_add(k_int_to_ang(k), k_int_to_ang(k)) = 
  k_int_to_ang((k - 1)))));

phase_inv_pre: (INT, angle) -> angle;

% phase_inv_pre'def
  ASSERT
  (FORALL (i : INT, d : angle):
  ((0 <= i)
  => (IF (i = 0) THEN (phase_inv_pre(i, d) = d) ELSE (phase_inv_pre(i, d) = 
     ang_inv(phase_inv_pre((i - 1), d))) ENDIF)));

% phase_inv_pre'spec
  ASSERT
  (FORALL (i : INT, d : angle):
  ((0 <= i)
  => (((mod(i, 2) = 0) => (phase_inv_pre(i, d) = d))
     AND ((mod(i, 2) = 1) => (phase_inv_pre(i, d) = ang_inv(d))))));

phase_inv_: (INT, angle) -> angle;

% phase_inv_'def
  ASSERT
  (FORALL (i : INT, d : angle):
  (IF (0 <= i) THEN (phase_inv_(i, d) = phase_inv_pre(i, d)) ELSE (
  phase_inv_(i, d) = phase_inv_pre((- i), d)) ENDIF));

% phase_inv_'spec
  ASSERT
  (FORALL (i : INT, d : angle):
  (((mod(i, 2) = 0) => (phase_inv_(i, d) = d))
  AND ((mod(i, 2) = 1) => (phase_inv_(i, d) = ang_inv(d)))));

% infix -^'spec
  ASSERT
  (FORALL (d : angle, i : INT):
  (((mod(i, 2) = 0) => (phase_inv_(i, d) = d))
  AND ((mod(i, 2) = 1) => (phase_inv_(i, d) = ang_inv(d)))));

% Even_phase_inv
  ASSERT
  (FORALL (d : angle):
  (FORALL (i : INT): ((mod(i, 2) = 0) => (phase_inv_(i, d) = d))));

% Odd_phase_inv
  ASSERT
  (FORALL (d : angle):
  (FORALL (i : INT): ((mod(i, 2) = 1) => (phase_inv_(i, d) = ang_inv(d)))));

% Gen_phase_inv
  ASSERT
  (FORALL (k : INT, n : INT, i : INT):
  ((0 <= n)
  => ((0 <= i) => (phase_inv_(i, infix_sldtsl(k, n)) = infix_sldtsl((
     power((- 1), i) * k), n)))));

% Gen_phase_inv_neg
  ASSERT
  (FORALL (k : INT, n : INT, i : INT):
  ((0 <= n)
  => ((i < 0) => (phase_inv_(i, infix_sldtsl(k, n)) = infix_sldtsl((
     power((- 1), (- i)) * k), n)))));

% Ang_exp_inv
  ASSERT
  (FORALL (o : angle): (ang_exp(ang_inv(o)) = infix_sldt(c_one, ang_exp(o))));

% ang_inv_to_conjugate
  ASSERT (FORALL (o : angle): (ang_exp(ang_inv(o)) = conjugate(ang_exp(o))));

% exp_minus
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (exp(infix_asdt(im, prefix_mndt(x))) = conjugate(exp(
  infix_asdt(im, x))))));

% conjugate_to_ang_inv
  ASSERT (FORALL (o : angle): (conjugate(ang_exp(o)) = ang_exp(ang_inv(o))));

% conjugate_inv_elim
  ASSERT (FORALL (o : angle): (conjugate(ang_exp(ang_inv(o))) = ang_exp(o)));

% ang_exp_neg_conjugate
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (ang_exp(real_to_ang(prefix_mndt(x))) = conjugate(ang_exp(
  real_to_ang(x))))));

% ang_exp_neg_conjugate_rev
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (conjugate(ang_exp(real_to_ang(x))) = ang_exp(real_to_ang(
  prefix_mndt(x))))));

% ang_mult_int_in
  ASSERT
  (FORALL (i : INT, k : INT, n : INT): (ang_mult_int(infix_sldtsl(k, n),
  i) = infix_sldtsl((i * k), n)));

% ang_mult_int_out
  ASSERT
  (FORALL (i : INT, k : INT, n : INT):
  ((0 <= n) => (infix_sldtsl((i * k), n) = ang_mult_int(infix_sldtsl(k, n),
  i))));

% int_to_ang_cycles
  ASSERT
  (FORALL (k : INT, n : INT, i : INT):
  ((0 <= n)
  => ((0 <= i) => (infix_sldtsl((k + (i * power(2, n))), n) = infix_sldtsl(k,
     n)))));

% int_to_ang_eq
  ASSERT
  (FORALL (k1 : INT, k2 : INT, n1 : INT, n2 : INT):
  ((k1 = k2) => ((n1 = n2) => (infix_sldtsl(k1, n1) = infix_sldtsl(k2, n2)))));

% int_to_ang_cycles_neg
  ASSERT
  (FORALL (k : INT, n : INT, i : INT):
  ((0 <= n)
  => ((i <= 0) => (infix_sldtsl((k + (i * power(2, n))), n) = infix_sldtsl(k,
     n)))));

% int_to_ang_cycles_gen
  ASSERT
  (FORALL (k : INT, n : INT, i : INT):
  ((0 <= n) => (infix_sldtsl((k + (i * power(2, n))), n) = infix_sldtsl(k,
  n))));

% int_to_ang_cycles_zero
  ASSERT
  (FORALL (nqt : INT, n : INT):
  (((0 <= n) AND (n <= nqt)) => (infix_sldtsl(power(2, nqt), n) = ang_zero)));

% int_to_ang_cycles_zero_mult
  ASSERT
  (FORALL (k : INT, nqt : INT, n : INT):
  (((0 <= n) AND (n <= nqt)) => (infix_sldtsl((k * power(2, nqt)),
  n) = ang_zero)));

% int_to_ang_cycles_zero_mult_
  ASSERT
  (FORALL (k : INT, nqt : INT, n : INT):
  (((0 <= n) AND (n <= nqt)) => (infix_sldtsl((k * power(2, nqt)),
  n) = ang_zero)));

% int_to_ang_up
  ASSERT
  (FORALL (k : INT, n : INT, nqt : INT):
  ((0 <= n)
  => ((0 <= nqt) => (infix_sldtsl((k * power(2, nqt)), (n + nqt)) = 
     infix_sldtsl(k, n)))));

% int_to_ang_mod
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n) => (infix_sldtsl(k, n) = infix_sldtsl(mod(k, power(2, n)), n))));

% int_to_ang_equiv
  ASSERT
  (FORALL (k1 : INT, k2 : INT, n1 : INT, n2 : INT):
  ((0 <= n1)
  => ((mod(k1, power(2, n1)) = mod(k2, power(2, n1)))
     => ((n1 = n2) => (infix_sldtsl(k1, n1) = infix_sldtsl(k2, n2))))));

% int_to_ang_red
  ASSERT
  (FORALL (k : INT, n : INT):
  ((1 <= n)
  => ((NOT (0 = k))
     => ((mod(k, 2) = 0) => (infix_sldtsl(k, n) = infix_sldtsl(div(k, 2),
        (n - 1)))))));

% int_to_ang_bin_rev
  ASSERT
  (FORALL (n : INT, i : INT, j : INT):
  ((0 <= n)
  => ((0 <= i)
     => ((j = (n - 1)) => (infix_sldtsl((- (i * power(2, j))), n) = 
        infix_sldtsl((i * power(2, (n - 1))), n))))));

% int_to_ang_bin_rev_
  ASSERT
  (FORALL (n : INT, i : INT, j : INT):
  ((0 <= n)
  => ((0 <= i)
     => ((j = (n - 1)) => (infix_sldtsl((- (i * power(2, j))), n) = 
        infix_sldtsl((i * power(2, (n - 1))), n))))));

% int_to_ang_add_rev
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 <= n) => (infix_sldtsl((i + j), n) = ang_add(infix_sldtsl(i, n), 
  infix_sldtsl(j, n)))));

% int_to_ang_ind_isum_plus_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, n : INT):
  ((i < j)
  => ((0 <= n) => (infix_sldtsl(ind_isum(f, i, j), n) = ang_add(
     infix_sldtsl((f[i]), n), infix_sldtsl(ind_isum(f, (i + 1), j), n))))));

% int_to_ang_ind_isum_plus_one_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, n : INT):
  ((i < j)
  => ((0 <= n) => (infix_sldtsl(ind_isum(f, i, j), n) = ang_add(infix_sldtsl(
     ind_isum(f, (i + 1), j), n), infix_sldtsl((f[i]), n))))));

% int_to_ang_ind_isum_right_extension
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, n : INT):
  ((i < j)
  => ((0 <= n) => (infix_sldtsl(ind_isum(f, i, j), n) = ang_add(infix_sldtsl(
     ind_isum(f, i, (j - 1)), n), infix_sldtsl((f[(j - 1)]), n))))));

% int_to_ang_ind_isum_right_extension_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, n : INT):
  ((i < j)
  => ((0 <= n) => (infix_sldtsl(ind_isum(f, i, j), n) = ang_add(
     infix_sldtsl((f[(j - 1)]), n), infix_sldtsl(ind_isum(f, i, (j - 1)),
     n))))));

% minus_int_to_ang_ind_isum_plus_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, n : INT):
  ((i < j)
  => ((0 <= n) => (infix_sldtsl((- ind_isum(f, i, j)), n) = ang_add(
     infix_sldtsl((- (f[i])), n), infix_sldtsl((- ind_isum(f, (i + 1), j)),
     n))))));

% minus_int_to_ang_ind_isum_plus_one_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, n : INT):
  ((i < j)
  => ((0 <= n) => (infix_sldtsl((- ind_isum(f, i, j)), n) = ang_add(
     infix_sldtsl((- ind_isum(f, (i + 1), j)), n), infix_sldtsl((- (f[i])),
     n))))));

% minus_int_to_ang_ind_isum_right_extension
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, n : INT):
  ((i < j)
  => ((0 <= n) => (infix_sldtsl((- ind_isum(f, i, j)), n) = ang_add(
     infix_sldtsl((- ind_isum(f, i, (j - 1))), n), 
     infix_sldtsl((- (f[(j - 1)])), n))))));

% minus_int_to_ang_ind_isum_right_extension_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, n : INT):
  ((i < j)
  => ((0 <= n) => (infix_sldtsl((- ind_isum(f, i, j)), n) = ang_add(
     infix_sldtsl((- (f[(j - 1)])), n), infix_sldtsl((- ind_isum(f, i,
     (j - 1))), n))))));

% int_to_ang_simpl
  ASSERT
  (FORALL (k : INT, n1 : INT, n2 : INT):
  ((0 <= n1)
  => ((0 <= n2) => (infix_sldtsl((k * power(2, n1)), (n2 + n1)) = 
     infix_sldtsl(k, n2)))));

% ang_add_eq
  ASSERT
  (FORALL (d1 : angle, d2 : angle, e1 : angle, e2 : angle):
  ((d1 = e1) => ((d2 = e2) => (ang_add(d1, d2) = ang_add(e1, e2)))));

% ang_add_comm
  ASSERT
  (FORALL (d1 : angle, d2 : angle): (ang_add(d1, d2) = ang_add(d2, d1)));

% ang_add_eq_comm
  ASSERT
  (FORALL (d1 : angle, d2 : angle, d3 : angle, d4 : angle):
  ((d1 = d3) => ((d2 = d4) => (ang_add(d1, d2) = ang_add(d4, d3)))));

% ang_add_switch
  ASSERT
  (FORALL (a : angle, b : angle, c : angle, d : angle): (ang_add(ang_add(a,
  b), ang_add(c, d)) = ang_add(ang_add(a, c), ang_add(b, d))));

% ang_mult_int_zero
  ASSERT (FORALL (theta : angle): (ang_mult_int(theta, 0) = ang_zero));

% ang_div
  ASSERT
  (FORALL (k : INT, n : INT, i : INT):
  ((0 <= n)
  => ((0 <= i) => (infix_sldtsl(k, n) = ang_mult_int(infix_sldtsl(k,
     (n + i)), power(2, i))))));

% ang_zero_add
  ASSERT
  (FORALL (dqt : angle, d : angle):
  ((dqt = ang_zero) => (ang_add(dqt, d) = d)));

% int_to_ang_rev
  ASSERT
  (FORALL (k : INT, l : INT, n : INT, m : INT):
  ((0 < n)
  => ((0 <= k)
     => ((n = (m + 1)) => (infix_sldtsl((((- k) * l) * power(2, m)), n) = 
        infix_sldtsl(((k * l) * power(2, m)), n))))));

% int_to_ang_rev_
  ASSERT
  (FORALL (k : INT, l : INT, n : INT, m : INT):
  ((0 < n)
  => ((0 <= k)
     => ((0 <= l)
        => ((n = (m + 1)) => (infix_sldtsl((((- k) * l) * power(2, m)), n) = 
           infix_sldtsl(((k * l) * power(2, m)), n)))))));

% ang_add_zero_d
  ASSERT
  (FORALL (dqt : angle, d : angle):
  ((dqt = ang_zero) => (ang_add(d, dqt) = d)));

% real_to_ang_distr_minus
  ASSERT
  (FORALL (x : complex, z : complex, t1 : complex):
  (FORALL (y : INT):
  ((real_(x))
  => ((real_(z))
     => ((real_(t1)) => (ang_add(real_to_ang(infix_asdt(x, i_to_c(y))), 
        real_to_ang(infix_asdt(infix_asdt(i_to_c(y), prefix_mndt(z)),
        t1))) = ang_mult_int(real_to_ang(infix_mndt(x, infix_asdt(z, t1))),
        y)))))));

% ang_mult_int_exp_pos
  ASSERT
  (FORALL (o : angle, i : INT):
  ((0 <= i) => (ang_exp(ang_mult_int(o, i)) = cpower(ang_exp(o), i))));

% ang_mult_int_exp
  ASSERT
  (FORALL (o : angle, i : INT): (ang_exp(ang_mult_int(o, i)) = cpower(
  ang_exp(o), i)));

% ang_mult_int_exp_rev
  ASSERT
  (FORALL (o : angle, i : INT): (cpower(ang_exp(o), i) = ang_exp(
  ang_mult_int(o, i))));

% cpower_ang_exp_real
  ASSERT
  (FORALL (x : complex, i : INT):
  ((real_(x)) => (cpower(ang_exp(real_to_ang(x)), i) = ang_exp(real_to_ang(
  infix_asdt(x, i_to_c(i)))))));

% ang_mult_int_add
  ASSERT
  (FORALL (o : angle, i : INT, iqt : INT): (ang_mult_int(o, (i + iqt)) = 
  ang_add(ang_mult_int(o, i), ang_mult_int(o, iqt))));

% ang_mult_int_plus_one
  ASSERT
  (FORALL (o : angle, i : INT): (ang_add(o, ang_mult_int(o, i)) = 
  ang_mult_int(o, (i + 1))));

% ang_mult_int_plus_one_rev
  ASSERT
  (FORALL (o : angle, i : INT): (ang_mult_int(o, (1 + i)) = ang_add(o, 
  ang_mult_int(o, i))));

% ang_mult_int_double
  ASSERT
  (FORALL (o : angle, i : INT): (ang_mult_int(o, (2 * i)) = ang_add(
  ang_mult_int(o, i), ang_mult_int(o, i))));

% ang_mult_int_inv_one
  ASSERT (FORALL (o : angle): (ang_mult_int(o, (- 1)) = ang_inv(o)));

% ang_mult_int_one
  ASSERT
  (FORALL (o : angle, n : INT): ((n = 1) => (ang_mult_int(o, n) = o)));

% ang_mult_int_inv_rev
  ASSERT (FORALL (o : angle): (ang_inv(o) = ang_mult_int(o, (- 1))));

% ang_mult_int_comp
  ASSERT
  (FORALL (o : angle, i : INT, j : INT): (ang_mult_int(ang_mult_int(o, i),
  j) = ang_mult_int(o, (i * j))));

% ang_mult_int_comp_rev
  ASSERT
  (FORALL (o : angle, i : INT, j : INT): (ang_mult_int(o, (i * j)) = 
  ang_mult_int(ang_mult_int(o, i), j)));

% add_ang_mult_int_pos
  ASSERT
  (FORALL (o : angle, oqt : angle, i : INT):
  ((0 <= i) => (ang_add(ang_mult_int(o, i), ang_mult_int(oqt, i)) = 
  ang_mult_int(ang_add(o, oqt), i))));

% add_ang_mult_int
  ASSERT
  (FORALL (o : angle, oqt : angle, i : INT): (ang_add(ang_mult_int(o, i), 
  ang_mult_int(oqt, i)) = ang_mult_int(ang_add(o, oqt), i)));

ang_substr: (angle, angle) -> angle;

% ang_substr'def
  ASSERT
  (FORALL (o : angle, oqt : angle): (ang_substr(o, oqt) = ang_add(o, 
  ang_inv(oqt))));

% ang_substr_inv
  ASSERT
  (FORALL (o : angle, oqt : angle): (ang_substr(o, ang_mult_int(oqt,
  (- 1))) = ang_add(o, oqt)));

% ang_mult_int_distr
  ASSERT
  (FORALL (o : angle, oqt : angle, n : INT): (ang_mult_int(ang_add(o, oqt),
  n) = ang_add(ang_mult_int(o, n), ang_mult_int(oqt, n))));

% ang_mult_int_distr_rev
  ASSERT
  (FORALL (o : angle, n1 : INT, n2 : INT): (ang_add(ang_mult_int(o, n1), 
  ang_mult_int(o, n2)) = ang_mult_int(o, (n1 + n2))));

% ang_add_assoc
  ASSERT
  (FORALL (o : angle, oqt : angle, oqtqt : angle): (ang_add(o, ang_add(oqt,
  oqtqt)) = ang_add(ang_add(o, oqt), oqtqt)));

% ang_add_assoc_rev
  ASSERT
  (FORALL (o : angle, oqt : angle, oqtqt : angle): (ang_add(ang_add(o, oqt),
  oqtqt) = ang_add(o, ang_add(oqt, oqtqt))));

% ang_add_own_inv
  ASSERT
  (FORALL (o : angle): (ang_add(ang_mult_int(o, (- 1)), o) = ang_zero));

% ang_exp_inv
  ASSERT (FORALL (o : angle): (ang_exp(ang_inv(o)) = conjugate(ang_exp(o))));

% ang_exp_one_one
  ASSERT (ang_exp(infix_sldtsl(1, 1)) = prefix_mndt(c_one));

% int_to_ang_one_even
  ASSERT
  (FORALL (k : INT): ((even(k) = 0bin1) => (infix_sldtsl(k, 1) = ang_zero)));

% int_to_ang_one_odd
  ASSERT
  (FORALL (k : INT):
  ((odd(k) = 0bin1) => (infix_sldtsl(k, 1) = infix_sldtsl(1, 1))));

% ang_exp_one_one_expo
  ASSERT
  (FORALL (i : INT):
  ((0 <= i) => (ang_exp(ang_mult_int(infix_sldtsl(1, 1),
  i)) = (IF (even(i) = 0bin1) THEN c_one ELSE prefix_mndt(c_one) ENDIF))));

% int_to_ang_zero_den
  ASSERT
  (FORALL (k : INT, n : INT): ((n = 0) => (infix_sldtsl(k, n) = ang_zero)));

% int_to_ang_minus_up
  ASSERT
  (FORALL (k : INT, n : INT): (infix_sldtsl(k, (- n)) = infix_sldtsl((- k),
  n)));

% int_to_ang_minus_down
  ASSERT
  (FORALL (k : INT, n : INT): (infix_sldtsl((- k), (- n)) = infix_sldtsl(k,
  n)));

% int_to_ang_inv
  ASSERT
  (FORALL (k : INT, n : INT): (ang_inv(infix_sldtsl(k, n)) = infix_sldtsl(k,
  (- n))));

% int_to_ang_inv_rev
  ASSERT
  (FORALL (k : INT, n : INT): (infix_sldtsl(k, (- n)) = ang_inv(
  infix_sldtsl(k, n))));

% int_to_ang_inv_add
  ASSERT
  (FORALL (k : INT, n : INT): (ang_add(infix_sldtsl(k, n), infix_sldtsl(k,
  (- n))) = ang_zero));

% ang_mult_int_neutral
  ASSERT
  (FORALL (theta : angle, n : INT):
  ((theta = ang_zero) => (ang_mult_int(theta, n) = ang_zero)));

% phase_inv_neutral
  ASSERT
  (FORALL (theta : angle, n : INT):
  ((theta = ang_zero) => (phase_inv_(n, theta) = ang_zero)));

binary: ((ARRAY INT OF INT)) -> BOOLEAN;

% binary'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT)):
  ((binary(t1)) <=> (FORALL (k : INT): ((0 <= (t1[k])) AND ((t1[k]) < 2)))));

binary_l: ((ARRAY INT OF INT), INT) -> BOOLEAN;

% binary_l'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), l : INT):
  ((binary_l(t1, l))
  <=> (FORALL (k : INT):
      (((0 <= k) AND (k < l)) => ((0 <= (t1[k])) AND ((t1[k]) < 2))))));

% set_binary_l
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), l : INT):
  ((FORALL (k : INT):
   (((0 <= k) AND (k < l)) => ((0 <= (t1[k])) AND ((t1[k]) < 2))))
  => (binary_l(t1, l))));

% get_binary_l
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), l : INT):
  ((binary_l(t1, l))
  => (FORALL (k : INT):
     (((0 <= k) AND (k < l)) => ((0 <= (t1[k])) AND ((t1[k]) < 2))))));

% get_binary_one
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), k : INT, l : INT):
  ((binary_l(t1, l))
  => (((0 <= k) AND (k < l)) => ((NOT ((t1[k]) = 0)) => ((t1[k]) = 1)))));

% get_binary_zero
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), k : INT, l : INT):
  ((binary_l(t1, l))
  => (((0 <= k) AND (k < l)) => ((NOT ((t1[k]) = 1)) => ((t1[k]) = 0)))));

% binary_is_binary_l
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), l : INT):
  ((binary(t1)) => (binary_l(t1, l))));

% binary_leq
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), k : INT, l : INT):
  ((l <= k) => ((binary_l(t1, k)) => (binary_l(t1, l)))));

% set_binary
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT)):
  ((FORALL (k : INT): ((0 <= (t1[k])) AND ((t1[k]) < 2))) => (binary(t1))));

% get_binary
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT)):
  ((binary(t1)) => (FORALL (k : INT): ((0 <= (t1[k])) AND ((t1[k]) < 2)))));

shift: (ty, uni, INT, INT) -> uni;

% shift_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT): (sort(a, shift(a, x, x1, x2)))));

% shift'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, k : INT): (tb2t33(shift(angle1, 
  t2tb35(f), i, k)) = (f[(k + i)])));

% shift'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, k : INT): (tb2t5(shift(int, 
  t2tb7(f), i, k)) = (f[(k + i)])));

% shift'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, k : INT): (shift(a, f, i, k) = infix_at(a, int,
  f, t2tb5((k + i))))));

% shift_value
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, k : INT): (tb2t33(shift(angle1, 
  t2tb35(f), i, k)) = (f[(k + i)])));

% shift_value
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, k : INT): (tb2t5(shift(int, 
  t2tb7(f), i, k)) = (f[(k + i)])));

% shift_value
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, k : INT): (shift(a, f, i, k) = infix_at(a, int,
  f, t2tb5((k + i))))));

% shiftz
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), k : INT): (tb2t33(shift(angle1, 
  t2tb35(f), 0, k)) = (f[k])));

% shiftz
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), k : INT): (tb2t5(shift(int, t2tb7(f), 0,
  k)) = (f[k])));

% shiftz
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, k : INT): (shift(a, f, 0, k) = infix_at(a, int, f, 
  t2tb5(k)))));

% shiftz_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, k : INT):
  ((i = 0) => (tb2t33(shift(angle1, t2tb35(f), i, k)) = (f[k]))));

% shiftz_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, k : INT):
  ((i = 0) => (tb2t5(shift(int, t2tb7(f), i, k)) = (f[k]))));

% shiftz_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, k : INT):
  ((i = 0) => (shift(a, f, i, k) = infix_at(a, int, f, t2tb5(k))))));

shift_closure: (ty) -> uni;

% shift_closure_sort
  ASSERT
  (FORALL (a : ty): (sort(infix_mngt(infix_mngt(int, a), infix_mngt(int, 
  infix_mngt(int, a))), shift_closure(a))));

t2tb78: ((ARRAY (ARRAY INT OF angle) OF (ARRAY INT OF (ARRAY INT OF angle)))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY (ARRAY INT OF angle) OF (ARRAY INT OF (ARRAY INT OF angle)))):
  (sort(infix_mngt(infix_mngt(int, angle1), infix_mngt(int, infix_mngt(int,
  angle1))), t2tb78(x))));

tb2t78: (uni) -> (ARRAY (ARRAY INT OF angle) OF (ARRAY INT OF (ARRAY INT OF angle)));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY (ARRAY INT OF angle) OF (ARRAY INT OF (ARRAY INT OF angle)))):PATTERN (
  t2tb78(i)):  (tb2t78(t2tb78(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb78(tb2t78(j))): 
  ((sort(infix_mngt(infix_mngt(int, angle1), infix_mngt(int, infix_mngt(int,
  angle1))), j)) => (t2tb78(tb2t78(j)) = j)));

% shift_closure_def
  ASSERT
  (FORALL (y : (ARRAY INT OF angle), y1 : INT, y2 : INT): ((tb2t35(infix_at(
  infix_mngt(int, angle1), int, infix_at(infix_mngt(int, infix_mngt(int,
  angle1)), infix_mngt(int, angle1), shift_closure(angle1), t2tb35(y)), 
  t2tb5(y1)))[y2]) = tb2t33(shift(angle1, t2tb35(y), y1, y2))));

t2tb23: ((ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF (ARRAY INT OF INT)))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF (ARRAY INT OF INT)))):
  (sort(infix_mngt(infix_mngt(int, int), infix_mngt(int, infix_mngt(int,
  int))), t2tb23(x))));

tb2t23: (uni) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF (ARRAY INT OF INT)));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF (ARRAY INT OF INT)))):PATTERN (
  t2tb23(i)):  (tb2t23(t2tb23(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb23(tb2t23(j))):  (t2tb23(tb2t23(j)) = j));

% shift_closure_def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), y1 : INT, y2 : INT): ((tb2t7(infix_at(
  infix_mngt(int, int), int, infix_at(infix_mngt(int, infix_mngt(int, int)), 
  infix_mngt(int, int), shift_closure(int), t2tb7(y)), t2tb5(y1)))[y2]) = 
  tb2t5(shift(int, t2tb7(y), y1, y2))));

% shift_closure_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (y : uni, y1 : INT, y2 : INT): (infix_at(a, int, infix_at(
  infix_mngt(int, a), int, infix_at(infix_mngt(int, infix_mngt(int, a)), 
  infix_mngt(int, a), shift_closure(a), y), t2tb5(y1)), t2tb5(y2)) = shift(a,
  y, y1, y2))));

% shiftz_quant
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni):
  ((sort(infix_mngt(int, a), f)) => (infix_at(infix_mngt(int, a), int, 
  infix_at(infix_mngt(int, infix_mngt(int, a)), infix_mngt(int, a), 
  shift_closure(a), f), t2tb5(0)) = f))));

% shiftz_quant_rev
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni):
  ((sort(infix_mngt(int, a), f)) => (f = infix_at(infix_mngt(int, a), int, 
  infix_at(infix_mngt(int, infix_mngt(int, a)), infix_mngt(int, a), 
  shift_closure(a), f), t2tb5(0))))));

concat_fun: (ty, uni, uni, INT, INT) -> uni;

% concat_fun_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT): (sort(a, concat_fun(a, x,
  x1, x2, x3)))));

% concat_fun'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  k : INT):
  (IF (k < i) THEN (tb2t33(concat_fun(angle1, t2tb35(f), t2tb35(g), i,
  k)) = (f[k])) ELSE (tb2t33(concat_fun(angle1, t2tb35(f), t2tb35(g), i,
  k)) = (g[(k - i)])) ENDIF));

% concat_fun'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, k : INT):
  (IF (k < i) THEN (tb2t5(concat_fun(int, t2tb7(f), t2tb7(g), i,
  k)) = (f[k])) ELSE (tb2t5(concat_fun(int, t2tb7(f), t2tb7(g), i,
  k)) = (g[(k - i)])) ENDIF));

% concat_fun'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, g : uni, i : INT, k : INT):
  (IF (k < i) THEN (concat_fun(a, f, g, i, k) = infix_at(a, int, f, 
  t2tb5(k))) ELSE (concat_fun(a, f, g, i, k) = infix_at(a, int, g, 
  t2tb5((k - i)))) ENDIF)));

% shift_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, j : INT, k : INT): (shift(a, infix_at(
  infix_mngt(int, a), int, infix_at(infix_mngt(int, infix_mngt(int, a)), 
  infix_mngt(int, a), shift_closure(a), f), t2tb5(j)), i, k) = shift(a, f,
  (i + j), k))));

% concat_fun_value
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  k : INT): (tb2t33(concat_fun(angle1, t2tb35(f), t2tb35(g), i,
  k)) = (IF (k < i) THEN (f[k]) ELSE (g[(k - i)]) ENDIF)));

% concat_fun_value
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, k : INT):
  (tb2t5(concat_fun(int, t2tb7(f), t2tb7(g), i,
  k)) = (IF (k < i) THEN (f[k]) ELSE (g[(k - i)]) ENDIF)));

% concat_fun_value
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, g : uni, i : INT, k : INT): (concat_fun(a, f, g, i,
  k) = (IF (k < i) THEN infix_at(a, int, f, t2tb5(k)) ELSE infix_at(a, int,
       g, t2tb5((k - i))) ENDIF))));

% concat_eq
  ASSERT
  (FORALL (f1 : (ARRAY INT OF angle), g1 : (ARRAY INT OF angle),
  f2 : (ARRAY INT OF angle), g2 : (ARRAY INT OF angle), i1 : INT, i2 : INT,
  k : INT):
  ((FORALL (l : INT): ((l < i1) => ((f1[l]) = (f2[l]))))
  => ((FORALL (l : INT): ((0 <= l) => ((g1[l]) = (g2[l]))))
     => ((i1 = i2) => (tb2t33(concat_fun(angle1, t2tb35(f1), t2tb35(g1), i1,
        k)) = tb2t33(concat_fun(angle1, t2tb35(f2), t2tb35(g2), i2, k)))))));

% concat_eq
  ASSERT
  (FORALL (f1 : (ARRAY INT OF INT), g1 : (ARRAY INT OF INT),
  f2 : (ARRAY INT OF INT), g2 : (ARRAY INT OF INT), i1 : INT, i2 : INT,
  k : INT):
  ((FORALL (l : INT): ((l < i1) => ((f1[l]) = (f2[l]))))
  => ((FORALL (l : INT): ((0 <= l) => ((g1[l]) = (g2[l]))))
     => ((i1 = i2) => (tb2t5(concat_fun(int, t2tb7(f1), t2tb7(g1), i1, k)) = 
        tb2t5(concat_fun(int, t2tb7(f2), t2tb7(g2), i2, k)))))));

% concat_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (f1 : uni, g1 : uni, f2 : uni, g2 : uni, i1 : INT, i2 : INT,
  k : INT):
  ((FORALL (l : INT):
   ((l < i1) => (infix_at(a, int, f1, t2tb5(l)) = infix_at(a, int, f2, 
   t2tb5(l)))))
  => ((FORALL (l : INT):
      ((0 <= l) => (infix_at(a, int, g1, t2tb5(l)) = infix_at(a, int, g2, 
      t2tb5(l)))))
     => ((i1 = i2) => (concat_fun(a, f1, g1, i1, k) = concat_fun(a, f2, g2,
        i2, k)))))));

mod_func: (ty, uni, INT, INT) -> uni;

% mod_func_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT): (sort(a, mod_func(a, x, x1, x2)))));

% mod_func'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), k : INT, i : INT):
  ((0 < k) => (tb2t33(mod_func(angle1, t2tb35(f), k, i)) = (f[mod(i, k)]))));

% mod_func'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), k : INT, i : INT):
  ((0 < k) => (tb2t5(mod_func(int, t2tb7(f), k, i)) = (f[mod(i, k)]))));

% mod_func'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, k : INT, i : INT):
  ((0 < k) => (mod_func(a, f, k, i) = infix_at(a, int, f, t2tb5(mod(i, k)))))));

% mod_func_inf
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), k : INT, i : INT):
  ((0 < k)
  => (((0 <= i) AND (i < k)) => (tb2t33(mod_func(angle1, t2tb35(f), k,
     i)) = (f[i])))));

% mod_func_inf
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), k : INT, i : INT):
  ((0 < k)
  => (((0 <= i) AND (i < k)) => (tb2t5(mod_func(int, t2tb7(f), k,
     i)) = (f[i])))));

% mod_func_inf
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, k : INT, i : INT):
  ((0 < k)
  => (((0 <= i) AND (i < k)) => (mod_func(a, f, k, i) = infix_at(a, int, f, 
     t2tb5(i)))))));

mod_func_closure: (ty) -> uni;

% mod_func_closure_sort
  ASSERT
  (FORALL (a : ty): (sort(infix_mngt(infix_mngt(int, a), infix_mngt(int, 
  infix_mngt(int, a))), mod_func_closure(a))));

% mod_func_closure_def
  ASSERT
  (FORALL (y : (ARRAY INT OF angle), y1 : INT, y2 : INT): ((tb2t35(infix_at(
  infix_mngt(int, angle1), int, infix_at(infix_mngt(int, infix_mngt(int,
  angle1)), infix_mngt(int, angle1), mod_func_closure(angle1), t2tb35(y)), 
  t2tb5(y1)))[y2]) = tb2t33(mod_func(angle1, t2tb35(y), y1, y2))));

% mod_func_closure_def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), y1 : INT, y2 : INT): ((tb2t7(infix_at(
  infix_mngt(int, int), int, infix_at(infix_mngt(int, infix_mngt(int, int)), 
  infix_mngt(int, int), mod_func_closure(int), t2tb7(y)), t2tb5(y1)))[y2]) = 
  tb2t5(mod_func(int, t2tb7(y), y1, y2))));

% mod_func_closure_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (y : uni, y1 : INT, y2 : INT): (infix_at(a, int, infix_at(
  infix_mngt(int, a), int, infix_at(infix_mngt(int, infix_mngt(int, a)), 
  infix_mngt(int, a), mod_func_closure(a), y), t2tb5(y1)), t2tb5(y2)) = 
  mod_func(a, y, y1, y2))));

% shift_mod
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, k : INT, i : INT):
  ((0 < k) => (mod_func(a, f, k, i) = shift(a, infix_at(infix_mngt(int, a),
  int, infix_at(infix_mngt(int, infix_mngt(int, a)), infix_mngt(int, a), 
  mod_func_closure(a), f), t2tb5(k)), k, i)))));

% shift_mod_rev
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, k : INT, i : INT):
  ((0 < k) => (shift(a, infix_at(infix_mngt(int, a), int, infix_at(
  infix_mngt(int, infix_mngt(int, a)), infix_mngt(int, a), 
  mod_func_closure(a), f), t2tb5(k)), k, i) = mod_func(a, f, k, i)))));

head_bit: (INT, INT) -> INT;

% head_bit'def
  ASSERT
  (FORALL (i : INT, k : INT):
  ((0 < k)
  => (((0 <= i) AND (i < power(2, k))) => (head_bit(i, k) = div(i, power(2,
     (k - 1)))))));

% head_bit'spec
  ASSERT
  (FORALL (i : INT, k : INT):
  ((0 < k)
  => (((0 <= i) AND (i < power(2, k)))
     => ((0 <= head_bit(i, k)) AND (head_bit(i, k) <= 1)))));

tail_bits: (INT, INT) -> INT;

% tail_bits'def
  ASSERT
  (FORALL (i : INT, k : INT):
  ((0 < k)
  => (((0 <= i) AND (i < power(2, k))) => (tail_bits(i, k) = mod(i, power(2,
     (k - 1)))))));

% tail_bits'spec
  ASSERT
  (FORALL (i : INT, k : INT):
  ((0 < k)
  => (((0 <= i) AND (i < power(2, k)))
     => ((0 <= tail_bits(i, k)) AND (tail_bits(i, k) <= power(2, (k - 1)))))));

ht_to_int: (INT, INT, INT) -> INT;

% ht_to_int'def
  ASSERT
  (FORALL (hi : INT, ti : INT, k : INT):
  ((0 < k)
  => (((0 <= hi) AND (hi < 2))
     => (((0 <= ti) AND (ti < power(2, (k - 1)))) => (ht_to_int(hi, ti,
        k) = ((hi * power(2, (k - 1))) + ti))))));

% head_tail_inv
  ASSERT
  (FORALL (i : INT, k : INT):
  ((0 < k)
  => (((0 <= i) AND (i < power(2, k))) => (ht_to_int(head_bit(i, k), 
     tail_bits(i, k), k) = i))));

% ht_to_int_head
  ASSERT
  (FORALL (i : INT, ti : INT, k : INT):
  ((0 < k)
  => (((0 <= i) AND (i < power(2, k)))
     => (((0 <= ti) AND (ti < power(2, (k - 1)))) => (head_bit(ht_to_int(
        head_bit(i, k), ti, k), k) = head_bit(i, k))))));

% ht_to_int_tail
  ASSERT
  (FORALL (hi : INT, i : INT, k : INT):
  ((0 < k)
  => (((0 <= i) AND (i < power(2, k)))
     => (((0 <= hi) AND (hi < 2)) => (tail_bits(ht_to_int(hi, tail_bits(i,
        k), k), k) = tail_bits(i, k))))));

% concat_fun_bin_i
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT, k : INT):
  ((binary(f))
  => ((binary(g))
     => ((0 <= tb2t5(concat_fun(int, t2tb7(f), t2tb7(g), i, k))) AND (tb2t5(
        concat_fun(int, t2tb7(f), t2tb7(g), i, k)) < 2)))));

% shift_bin_i
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, k : INT):
  ((binary(f))
  => ((0 <= tb2t5(shift(int, t2tb7(f), i, k))) AND (tb2t5(shift(int, 
     t2tb7(f), i, k)) < 2))));

concat_fun_closure: (ty) -> uni;

% concat_fun_closure_sort
  ASSERT
  (FORALL (a : ty): (sort(infix_mngt(infix_mngt(int, a), infix_mngt(
  infix_mngt(int, a), infix_mngt(int, infix_mngt(int, a)))), 
  concat_fun_closure(a))));

t2tb79: ((ARRAY (ARRAY INT OF angle) OF (ARRAY (ARRAY INT OF angle) OF (ARRAY INT OF (ARRAY INT OF angle))))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY (ARRAY INT OF angle) OF (ARRAY (ARRAY INT OF angle) OF (ARRAY INT OF (ARRAY INT OF angle))))):
  (sort(infix_mngt(infix_mngt(int, angle1), infix_mngt(infix_mngt(int,
  angle1), infix_mngt(int, infix_mngt(int, angle1)))), t2tb79(x))));

tb2t79: (uni) -> (ARRAY (ARRAY INT OF angle) OF (ARRAY (ARRAY INT OF angle) OF (ARRAY INT OF (ARRAY INT OF angle))));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY (ARRAY INT OF angle) OF (ARRAY (ARRAY INT OF angle) OF (ARRAY INT OF (ARRAY INT OF angle))))):PATTERN (
  t2tb79(i)):  (tb2t79(t2tb79(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb79(tb2t79(j))): 
  ((sort(infix_mngt(infix_mngt(int, angle1), infix_mngt(infix_mngt(int,
  angle1), infix_mngt(int, infix_mngt(int, angle1)))), j)) => (t2tb79(
  tb2t79(j)) = j)));

% concat_fun_closure_def
  ASSERT
  (FORALL (y : (ARRAY INT OF angle), y1 : (ARRAY INT OF angle), y2 : INT,
  y3 : INT): ((tb2t35(infix_at(infix_mngt(int, angle1), int, infix_at(
  infix_mngt(int, infix_mngt(int, angle1)), infix_mngt(int, angle1), 
  infix_at(infix_mngt(infix_mngt(int, angle1), infix_mngt(int, 
  infix_mngt(int, angle1))), infix_mngt(int, angle1), 
  concat_fun_closure(angle1), t2tb35(y)), t2tb35(y1)), t2tb5(y2)))[y3]) = 
  tb2t33(concat_fun(angle1, t2tb35(y), t2tb35(y1), y2, y3))));

t2tb24: ((ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF (ARRAY INT OF INT))))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF (ARRAY INT OF INT))))):
  (sort(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int, int), 
  infix_mngt(int, infix_mngt(int, int)))), t2tb24(x))));

tb2t24: (uni) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF (ARRAY INT OF INT))));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF (ARRAY INT OF INT))))):PATTERN (
  t2tb24(i)):  (tb2t24(t2tb24(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb24(tb2t24(j))):  (t2tb24(tb2t24(j)) = j));

% concat_fun_closure_def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), y1 : (ARRAY INT OF INT), y2 : INT,
  y3 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, infix_at(
  infix_mngt(int, infix_mngt(int, int)), infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), infix_mngt(int, infix_mngt(int, int))), 
  infix_mngt(int, int), concat_fun_closure(int), t2tb7(y)), t2tb7(y1)), 
  t2tb5(y2)))[y3]) = tb2t5(concat_fun(int, t2tb7(y), t2tb7(y1), y2, y3))));

% concat_fun_closure_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (y : uni, y1 : uni, y2 : INT, y3 : INT): (infix_at(a, int, 
  infix_at(infix_mngt(int, a), int, infix_at(infix_mngt(int, infix_mngt(int,
  a)), infix_mngt(int, a), infix_at(infix_mngt(infix_mngt(int, a), 
  infix_mngt(int, infix_mngt(int, a))), infix_mngt(int, a), 
  concat_fun_closure(a), y), y1), t2tb5(y2)), t2tb5(y3)) = concat_fun(a, y,
  y1, y2, y3))));

% concat_fun_bin
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), i : INT):
  ((binary(f))
  => ((binary(g)) => (binary(tb2t7(infix_at(infix_mngt(int, int), int, 
     infix_at(infix_mngt(int, infix_mngt(int, int)), infix_mngt(int, int), 
     infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, 
     infix_mngt(int, int))), infix_mngt(int, int), concat_fun_closure(int), 
     t2tb7(f)), t2tb7(g)), t2tb5(i))))))));

% mod_func_bin
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), k : INT):
  ((0 < k)
  => ((binary(f)) => (binary(tb2t7(infix_at(infix_mngt(int, int), int, 
     infix_at(infix_mngt(int, infix_mngt(int, int)), infix_mngt(int, int), 
     mod_func_closure(int), t2tb7(f)), t2tb5(k))))))));

% shift_bin
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT):
  ((binary(f)) => (binary(tb2t7(infix_at(infix_mngt(int, int), int, infix_at(
  infix_mngt(int, infix_mngt(int, int)), infix_mngt(int, int), 
  shift_closure(int), t2tb7(f)), t2tb5(i)))))));

fc121: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), x : INT): ((
  fc121(f, g)[x]) = (f[(g[x])])));

% binary_comp
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT)):
  ((binary(f)) => (binary(fc121(f, g)))));

% set_is_all_binary
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT)):
  ((FORALL (k : INT): ((0 <= (t1[k])) AND ((t1[k]) < 2))) => (binary(t1))));

nary_length: (INT, INT) -> INT;

% nary_length'spec
  ASSERT
  (FORALL (i : INT, n : INT):
  ((1 < n)
  => ((0 <= i)
     => (((0 < i)
         => ((power(n, (nary_length(i, n) - 1)) <= i) AND (i < power(n, 
            nary_length(i, n)))))
        AND (((i < n) => (nary_length(i, n) = 1))
            AND ((1 <= nary_length(i, n)) AND (i = mod(i, power(n, 
                nary_length(i, n))))))))));

binary_length: (INT) -> INT;

% binary_length'def
  ASSERT
  (FORALL (i : INT): ((0 <= i) => (binary_length(i) = nary_length(i, 2))));

% binary_length'spec
  ASSERT
  (FORALL (i : INT):
  ((0 <= i)
  => (((0 < i)
      => ((power(2, (binary_length(i) - 1)) <= i) AND (i < power(2, 
         binary_length(i)))))
     AND (((i < 2) => (binary_length(i) = 1))
         AND ((1 <= binary_length(i)) AND (i = mod(i, power(2, 
             binary_length(i)))))))));

% set_binary_length
  ASSERT
  (FORALL (i : INT, k : INT):
  ((0 <= i)
  => ((0 <= k)
     => (((0 < i) => ((power(2, (k - 1)) <= i) AND (i < power(2, k))))
        => (((i < 2) => (k = 1)) => (k = binary_length(i)))))));

% set_binary_length_b
  ASSERT
  (FORALL (i : INT, k : INT):
  ((0 <= i) => ((0 < k) => ((i < power(2, k)) => (binary_length(i) <= k)))));

bitvec : TYPE;

bitvec1: ty;

value: (bitvec) -> (ARRAY INT OF INT);

length: (bitvec) -> INT;

% bitvec'invariant
  ASSERT
  (FORALL (self : bitvec):PATTERN (length(self)): PATTERN (value(self)): 
  ((0 <= length(self))
  AND ((FORALL (i : INT):
       (((0 <= i) AND (i < length(self)))
       => ((0 <= (value(self)[i])) AND ((value(self)[i]) < 2))))
      AND (FORALL (i : INT):
          ((NOT ((0 <= i) AND (i < length(self)))) => ((value(self)[i]) = 0))))));

bvlength: ((ARRAY INT OF INT), INT) -> BOOLEAN;

% bvlength'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT):
  ((bvlength(f, i))
  <=> (FORALL (k : INT):
      (((0 <= k) AND (k < i)) => ((0 <= (f[k])) AND ((f[k]) < 2))))));

% binary_mult
  ASSERT
  (FORALL (a : INT, b : INT): (mod((a * b), 2) = (mod(a, 2) * mod(b, 2))));

% getbv'spec
  ASSERT (FORALL (a : bitvec): (binary(value(a))));

to_bool: (INT) -> BITVECTOR(1);

% to_bool'def
  ASSERT
  (FORALL (i : INT):
  (((0 <= i) AND (i < 2))
  => (IF (NOT (i = 0)) THEN (to_bool(i) = 0bin1) ELSE (
     to_bool(i) = 0bin0) ENDIF)));

% getbv_bound
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  ((0 <= (value(bv)[i])) AND ((value(bv)[i]) < 2)));

% getbv_eq
  ASSERT
  (FORALL (bvx : bitvec, bvy : bitvec, i : INT):
  ((bvx = bvy) => ((value(bvx)[i]) = (value(bvy)[i]))));

% getbv_eq_gen
  ASSERT
  (FORALL (bvx : bitvec, bvy : bitvec, i : INT, j : INT):
  ((bvx = bvy) => ((i = j) => ((value(bvx)[i]) = (value(bvy)[j])))));

setbv: ((ARRAY INT OF INT), INT, INT) -> (ARRAY INT OF INT);

% setbv'def
  ASSERT
  (FORALL (bv : (ARRAY INT OF INT), i : INT, j : INT):
  (FORALL (k : INT): ((setbv(bv, i,
  j)[k]) = (IF (k = i) THEN j ELSE (bv[k]) ENDIF))));

% setbv'spec
  ASSERT
  (FORALL (bv : (ARRAY INT OF INT), i : INT, j : INT):
  ((FORALL (k : INT): ((NOT (k = i)) => ((setbv(bv, i, j)[k]) = (bv[k]))))
  AND ((setbv(bv, i, j)[i]) = j)));

setbv_int: ((ARRAY INT OF INT), (ARRAY INT OF INT), INT,
  INT) -> (ARRAY INT OF INT);

% setbv_int'def
  ASSERT
  (FORALL (bv1 : (ARRAY INT OF INT), bv2 : (ARRAY INT OF INT), i : INT,
  j : INT):
  (FORALL (k : INT): ((setbv_int(bv1, bv2, i,
  j)[k]) = (IF ((i < k) AND (k <= j)) THEN (bv2[(k - i)])
           ELSE (bv1[k]) ENDIF))));

% setbv_int'spec
  ASSERT
  (FORALL (bv1 : (ARRAY INT OF INT), bv2 : (ARRAY INT OF INT), i : INT,
  j : INT):
  ((FORALL (k : INT):
   (((i < k) AND (k <= j)) => ((setbv_int(bv1, bv2, i,
   j)[k]) = (bv2[(k - i)]))))
  AND ((FORALL (k : INT):
       ((k <= i) => ((setbv_int(bv1, bv2, i, j)[k]) = (bv1[k]))))
      AND (FORALL (k : INT):
          ((j < k) => ((setbv_int(bv1, bv2, i, j)[k]) = (bv1[k])))))));

% set_bvlength
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  ((FORALL (k : INT):
   (((1 <= k) AND (k < i))
   => ((0 <= (value(bv)[k])) AND ((value(bv)[k]) < 2))))
  => (bvlength(value(bv), i))));

% null_product_bitvec
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((n = length(x))
  => ((FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 1)))
     => (ind_iproduct(value(x), 0, n) = 1))));

% non_null_product_bitvec
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((n = length(x))
  => ((NOT
      (FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 1))))
     => (ind_iproduct(value(x), 0, n) = 0))));

fc748: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((fc748(x)[i]) = (1 - (value(x)[i]))));

% null_product_bitvec_inv
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((n = length(x))
  => ((FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 0)))
     => (ind_iproduct(fc748(x), 0, n) = 1))));

fc749: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((fc749(x)[i]) = (1 - (value(x)[i]))));

% non_null_product_bitvec_inv
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((n = length(x))
  => ((NOT
      (FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 0))))
     => (ind_iproduct(fc749(x), 0, n) = 0))));

% null_product_bitvec_rev
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((n = length(x))
  => ((ind_iproduct(value(x), 0, n) = 1)
     => (FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 1))))));

% non_null_product_bitvec_rev
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((n = length(x))
  => ((ind_iproduct(value(x), 0, n) = 0)
     => (NOT
        (FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 1)))))));

fc750: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((fc750(x)[i]) = (1 - (value(x)[i]))));

% null_product_bitvec_inv_rev
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((n = length(x))
  => ((ind_iproduct(fc750(x), 0, n) = 1)
     => (FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 0))))));

fc751: (bitvec) -> (ARRAY INT OF INT);

fc752: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((fc751(x)[i]) = (1 - (value(x)[i]))));

% fc'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((fc752(x)[i]) = (1 - (value(x)[i]))));

% inter
  ASSERT
  (FORALL (x : bitvec, n : INT, k : INT):
  ((n = length(x))
  => ((ind_iproduct(fc751(x), 0, n) = 0)
     => (((0 <= k) AND (k <= n))
        => ((FORALL (i : INT):
            (((0 <= i) AND (i < n)) => ((value(x)[i]) = 0)))
           => (ind_iproduct(fc752(x), 0, k) = 1))))));

fc753: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((fc753(x)[i]) = (1 - (value(x)[i]))));

% non_null_product_bitvec_inv_rev
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((n = length(x))
  => ((ind_iproduct(fc753(x), 0, n) = 0)
     => (NOT
        (FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 0)))))));

% set_flength
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT):
  ((FORALL (k : INT):
   (((0 <= k) AND (k < i)) => ((0 <= (f[k])) AND ((f[k]) < 2))))
  => (bvlength(f, i))));

% get_bvlength
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT):
  ((bvlength(f, i))
  => (FORALL (k : INT):
     (((0 <= k) AND (k < i)) => ((0 <= (f[k])) AND ((f[k]) < 2))))));

% set_bv_to
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT):
  ((0 < i)
  => ((FORALL (j : INT):
      (((0 <= j) AND (j < i)) => ((0 <= (f[j])) AND ((f[j]) <= 1))))
     => (bvlength(f, i)))));

% set_in_range_val
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i < length(bv)))
  => ((0 <= (value(bv)[i])) AND ((value(bv)[i]) < 2))));

% bvlengthm
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i < length(bv))) => (bvlength(value(bv), i))));

in_range: (bitvec, INT) -> BOOLEAN;

% in_range'def
  ASSERT
  (FORALL (bv : bitvec, r : INT):
  ((in_range(bv, r)) <=> ((0 <= r) AND (r < length(bv)))));

% binary_bv
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  ((in_range(bv, i)) => ((0 <= (value(bv)[i])) AND ((value(bv)[i]) <= 1))));

% equal_bv
  ASSERT
  (FORALL (m : bitvec, n : bitvec):
  ((m = n)
  <=> ((length(m) = length(n))
      AND (FORALL (i : INT):
          ((in_range(m, i)) => ((value(m)[i]) = (value(n)[i])))))));

% set_equal_bv
  ASSERT
  (FORALL (bv : bitvec, bvqt : bitvec):
  ((length(bv) = length(bvqt))
  => ((FORALL (i : INT):
      (((0 <= i) AND (i < length(bv))) => ((value(bv)[i]) = (
      value(bvqt)[i]))))
     => (bv = bvqt))));

% get_equal_bv
  ASSERT
  (FORALL (bv : bitvec, bvqt : bitvec):
  ((bv = bvqt)
  => ((length(bv) = length(bvqt))
     AND (FORALL (i : INT):
         (((0 <= i) AND (i < length(bv))) => ((value(bv)[i]) = (
         value(bvqt)[i])))))));

make_bv: ((ARRAY INT OF INT), INT) -> bitvec;

% make_bv'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT):
  ((FORALL (i : INT):
   (((0 <= i) AND (i < s2)) => ((0 <= (f[i])) AND ((f[i]) < 2))))
  => ((0 <= s2)
     => ((length(make_bv(f, s2)) = s2)
        AND ((FORALL (i : INT):
             (((0 <= i) AND (i < s2)) => ((value(make_bv(f,
             s2))[i]) = (f[i]))))
            AND (FORALL (i : INT):
                ((NOT ((0 <= i) AND (i < s2))) => ((value(make_bv(f,
                s2))[i]) = 0))))))));

make_bv_m: ((ARRAY INT OF INT), INT) -> bitvec;

result96: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), k : INT): ((result96(f)[k]) = mod((f[k]),
  2)));

% make_bv_m'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT):
  ((0 <= s2) => (make_bv_m(f, s2) = make_bv(result96(f), s2))));

% make_bv_m'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT):
  ((0 <= s2)
  => ((length(make_bv_m(f, s2)) = s2)
     AND ((FORALL (i : INT): (bvlength(value(make_bv_m(f, s2)), i)))
         AND ((FORALL (k : INT):
              (((0 <= k) AND (k < s2)) => ((value(make_bv_m(f, s2))[k]) = 
              mod((f[k]), 2))))
             AND (FORALL (k : INT):
                 ((NOT ((0 <= k) AND (k < s2))) => ((value(make_bv_m(f,
                 s2))[k]) = 0))))))));

bitvec_null: bitvec;

result14: (ARRAY INT OF INT);

% result'def
  ASSERT (FORALL (us : INT): ((result14[us]) = 0));

% bitvec_null'def
  ASSERT (bitvec_null = make_bv(result14, 0));

% assert_make_bv_no_bound
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT, i : INT):
  ((FORALL (i1 : INT):
   (((0 <= i1) AND (i1 < s2)) => ((0 <= (f[i1])) AND ((f[i1]) < 2))))
  => (((1 <= i) AND (i <= s2)) => ((value(make_bv(f, 0))[i]) = 0))));

% make_bv_length
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT):
  ((FORALL (i : INT):
   (((0 <= i) AND (i < s2)) => ((0 <= (f[i])) AND ((f[i]) < 2))))
  => ((0 <= s2) => (length(make_bv(f, s2)) = s2))));

% assert_make_bv
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT, i : INT):
  ((FORALL (i1 : INT):
   (((0 <= i1) AND (i1 < s2)) => ((0 <= (f[i1])) AND ((f[i1]) < 2))))
  => ((0 <= s2) => ((value(make_bv(f,
     s2))[i]) = (IF ((0 <= i) AND (i < s2)) THEN (f[i]) ELSE 0 ENDIF)))));

% assert_make_m
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT, i : INT):
  ((0 <= s2) => ((value(make_bv_m(f,
  s2))[i]) = (IF ((0 <= i) AND (i < s2)) THEN mod((f[i]), 2) ELSE 0 ENDIF))));

% make_bv_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), fqt : (ARRAY INT OF INT), n : INT,
  nqt : INT):
  ((0 <= n)
  => ((n = nqt)
     => ((FORALL (i : INT): (((0 <= i) AND (i < n)) => ((f[i]) = (fqt[i]))))
        => ((FORALL (i : INT):
            (((0 <= i) AND (i < n)) => ((0 <= (f[i])) AND ((f[i]) < 2))))
           => (make_bv(f, n) = make_bv(fqt, nqt)))))));

% assert_make_bv_b
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT, i : INT):
  ((FORALL (i1 : INT):
   (((0 <= i1) AND (i1 < s2)) => ((0 <= (f[i1])) AND ((f[i1]) < 2))))
  => (((0 <= i) AND (i < s2)) => ((value(make_bv(f, s2))[i]) = (f[i])))));

% assert_make_m_b
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT, i : INT):
  (((0 <= i) AND (i < s2))
  => ((0 <= s2) => ((value(make_bv_m(f, s2))[i]) = mod((f[i]), 2)))));

% make_m_bv_length
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT, i : INT):
  ((0 <= s2) => (bvlength(value(make_bv_m(f, s2)), i))));

% make_m_length
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT):
  ((0 <= s2) => (length(make_bv_m(f, s2)) = s2)));

% set_equal_bv_make
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), s2 : INT):
  ((FORALL (i : INT): ((0 <= (f[i])) AND ((f[i]) < 2)))
  => ((0 <= s2)
     => ((FORALL (i : INT): ((f[i]) = (g[i]))) => (make_bv(f, s2) = 
        make_bv(g, s2))))));

% set_equal_bv_make_
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), s2 : INT):
  ((0 <= s2)
  => ((FORALL (i : INT):
      (((0 <= i) AND (i < s2)) => ((0 <= (f[i])) AND ((f[i]) < 2))))
     => ((FORALL (i : INT): (((0 <= i) AND (i < s2)) => ((f[i]) = (g[i]))))
        => (make_bv(f, s2) = make_bv(g, s2))))));

% set_equal_bv_m_make
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), s2 : INT):
  ((0 <= s2)
  => ((FORALL (i : INT): (mod((f[i]), 2) = mod((g[i]), 2))) => (make_bv_m(f,
     s2) = make_bv_m(g, s2)))));

% make_bv_itself
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((length(x) = n) => (make_bv(value(x), n) = x)));

head: (bitvec) -> INT;

% head'def
  ASSERT
  (FORALL (bv : bitvec): ((1 <= length(bv)) => (head(bv) = (value(bv)[0]))));

% head'spec
  ASSERT
  (FORALL (bv : bitvec):
  ((1 <= length(bv)) => ((0 <= head(bv)) AND (head(bv) <= 1))));

makes_bv: ((ARRAY INT OF INT), INT) -> bitvec;

result97: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((
  result97(f)[i]) = (IF (LET q1_ = (f[i]) IN ((0 <= q1_) AND (q1_ < 2)))
                    THEN (f[i]) ELSE 0 ENDIF)));

% makes_bv'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT):
  ((0 <= s2) => (makes_bv(f, s2) = make_bv(result97(f), s2))));

% makes_bv'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT):
  ((0 <= s2)
  => ((length(makes_bv(f, s2)) = s2)
     AND ((FORALL (i : INT):
          (((0 <= i) AND (i < s2))
          => (((0 <= (f[i])) AND ((f[i]) < 2)) => ((value(makes_bv(f,
             s2))[i]) = (f[i])))))
         AND (((FORALL (i : INT):
               (((0 <= i) AND (i < s2)) => ((0 <= (f[i])) AND ((f[i]) < 2))))
              => (makes_bv(f, s2) = make_bv(f, s2)))
             AND (FORALL (i : INT):
                 ((NOT ((0 <= i) AND (i < s2))) => ((value(makes_bv(f,
                 s2))[i]) = 0))))))));

% assert_makes_bv_c
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT, i : INT):
  ((FORALL (i1 : INT):
   (((0 <= i1) AND (i1 < s2)) => ((0 <= (f[i1])) AND ((f[i1]) < 2))))
  => ((0 <= s2) => ((value(makes_bv(f,
     s2))[i]) = (IF ((0 <= i) AND (i < s2)) THEN (f[i]) ELSE 0 ENDIF)))));

% assert_makes_bv_b
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT, i : INT):
  ((FORALL (i1 : INT):
   (((0 <= i1) AND (i1 < s2)) => ((0 <= (f[i1])) AND ((f[i1]) < 2))))
  => ((0 <= s2)
     => (((0 <= i) AND (i < s2)) => ((value(makes_bv(f, s2))[i]) = (f[i]))))));

% assert_makes_bv
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT, i : INT):
  ((FORALL (i1 : INT):
   (((0 <= i1) AND (i1 < s2)) => ((0 <= (f[i1])) AND ((f[i1]) < 2))))
  => ((0 <= s2) => ((value(makes_bv(f,
     s2))[i]) = (IF (((0 <= i) AND (i < s2)) AND (0 <= (f[i]))) THEN (f[i])
                ELSE 0 ENDIF)))));

% makes_bv_length
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : INT):
  ((0 <= s2) => (length(makes_bv(f, s2)) = s2)));

tail: (bitvec) -> bitvec;

result98: (bitvec) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (bv : bitvec, i : INT): ((result98(bv)[i]) = (value(bv)[(i + 1)])));

% tail'def
  ASSERT
  (FORALL (bv : bitvec):
  ((1 <= length(bv)) => (tail(bv) = make_bv(result98(bv), (length(bv) - 1)))));

% tail'spec
  ASSERT
  (FORALL (bv : bitvec):
  ((1 <= length(bv))
  => ((length(tail(bv)) = (length(bv) - 1))
     AND (FORALL (i : INT):
         ((in_range(tail(bv), i)) => ((value(tail(bv))[i]) = (
         value(bv)[(i + 1)])))))));

concat_l: (bitvec, INT) -> bitvec;

result99: (bitvec, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (bv : bitvec, i : INT, k : INT): ((result99(bv,
  i)[k]) = (IF (k = 0) THEN i ELSE (value(bv)[(k - 1)]) ENDIF)));

% concat_l'def
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i <= 1)) => (concat_l(bv, i) = make_bv(result99(bv, i), (
  length(bv) + 1)))));

% concat_l'spec
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i <= 1))
  => ((length(concat_l(bv, i)) = (length(bv) + 1))
     AND (((value(concat_l(bv, i))[0]) = i)
         AND (FORALL (j : INT):
             ((in_range(bv, j)) => ((value(concat_l(bv, i))[(j + 1)]) = (
             value(bv)[j]))))))));

% concat_l_value
  ASSERT
  (FORALL (bv : bitvec, i : INT, k : INT):
  (((0 <= i) AND (i < 2)) => ((value(concat_l(bv,
  i))[k]) = (IF (k = 0) THEN i
            ELSE (IF ((0 < k) AND (k <= (length(bv) + 1))) THEN (
                 value(bv)[(k - 1)]) ELSE 0 ENDIF) ENDIF))));

% concat_l_value_b
  ASSERT
  (FORALL (bv : bitvec, i : INT, k : INT):
  (((0 <= k) AND (k < (length(bv) + 1)))
  => (((0 <= i) AND (i < 2)) => ((value(concat_l(bv,
     i))[k]) = (IF (k = 0) THEN i ELSE (value(bv)[(k - 1)]) ENDIF)))));

% concat_ht
  ASSERT
  (FORALL (bv : bitvec):
  ((1 <= length(bv)) => (bv = concat_l(tail(bv), head(bv)))));

% concat_ht_union
  ASSERT
  (FORALL (bv : bitvec):
  ((2 <= length(bv))
  => ((NOT (bv = concat_l(tail(bv), 0))) => (bv = concat_l(tail(bv), 1)))));

bv_to_int: (bitvec) -> INT;

result100: (bitvec) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((
  result100(bv)[k]) = (IF (in_range(bv, k)) THEN ((value(bv)[k]) * power(2,
                      ((length(bv) - 1) - k))) ELSE 1 ENDIF)));

% bv_to_int'def
  ASSERT
  (FORALL (bv : bitvec): (bv_to_int(bv) = ind_isum(result100(bv), 0, 
  length(bv))));

fc754: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc754(bv)[k]) = ((value(bv)[k]) * 
  power(2, ((length(bv) - 1) - k)))));

% bv_to_int'spec
  ASSERT
  (FORALL (bv : bitvec):
  ((bv_to_int(bv) = ind_isum(fc754(bv), 0, length(bv))) AND (0 <= 
  bv_to_int(bv))));

% bv_to_int_eq
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((bv1 = bv2) => (bv_to_int(bv1) = bv_to_int(bv2))));

fc755: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc755(bv)[k]) = ((value(bv)[k]) * 
  power(2, ((length(bv) - 1) - k)))));

% bv_to_int_sum
  ASSERT
  (FORALL (bv : bitvec): (bv_to_int(bv) = ind_isum(fc755(bv), 0, 
  length(bv))));

fc756: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc756(bv)[k]) = ((value(bv)[((
  length(bv) - 1) - k)]) * power(2, k))));

% bv_to_int_sum_inv
  ASSERT
  (FORALL (bv : bitvec): (bv_to_int(bv) = ind_isum(fc756(bv), 0, 
  length(bv))));

fc757: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc757(bv)[k]) = ((- (value(bv)[k])) * 
  power(2, ((length(bv) - 1) - k)))));

% bv_to_int_sum_opp
  ASSERT
  (FORALL (bv : bitvec): ((- bv_to_int(bv)) = ind_isum(fc757(bv), 0, 
  length(bv))));

% bv_to_int_onebit
  ASSERT
  (FORALL (bv : bitvec):
  ((length(bv) = 1) => (bv_to_int(bv) = (value(bv)[0]))));

fc758: (bitvec) -> (ARRAY INT OF INT);

fc759: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc758(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc759(bv)[l]) = ((value(bv)[((
  length(bv) - 1) - l)]) * power(2, l))));

% ind_isum_bv_rev
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i <= length(bv))) => (ind_isum(fc758(bv), i, length(bv)) = 
  ind_isum(fc759(bv), 0, (length(bv) - i)))));

fc134: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

fc135: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, l : INT): ((fc134(f,
  n)[l]) = ((f[l]) * power(2, ((n - 1) - l)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, l : INT): ((fc135(f,
  n)[l]) = ((f[((n - 1) - l)]) * power(2, l))));

% ind_isum_bin_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, i : INT):
  (((0 <= i) AND (i < n))
  => ((binary(f)) => (ind_isum(fc134(f, n), i, n) = ind_isum(fc135(f, n), 0,
     (n - i))))));

fc136: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

fc137: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, l : INT): ((fc136(f,
  n)[l]) = ((f[l]) * power(2, ((n - 1) - l)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, l : INT): ((fc137(f,
  n)[l]) = ((f[((n - 1) - l)]) * power(2, l))));

% ind_isum_bin_rev_z
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((0 <= n)
  => ((binary(f)) => (ind_isum(fc136(f, n), 0, n) = ind_isum(fc137(f, n), 0,
     n)))));

fc760: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc760(bv)[k]) = ((value(bv)[((
  length(bv) - 1) - k)]) * power(2, k))));

% bv_to_int_sum_rev
  ASSERT
  (FORALL (bv : bitvec): (ind_isum(fc760(bv), 0, length(bv)) = 
  bv_to_int(bv)));

fc761: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc761(bv)[l]) = ((value(bv)[l]) * 
  power(2, l))));

% ind_isum_bv_bound_growing
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 < i) AND (i < length(bv))) => (ind_isum(fc761(bv), 0, i) < power(2,
  i))));

fc762: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc762(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% ind_isum_bv_bound
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i < length(bv))) => (ind_isum(fc762(bv), i, length(bv)) < 
  power(2, (length(bv) - i)))));

fc141: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, l : INT): ((fc141(f,
  n)[l]) = ((f[l]) * power(2, ((n - 1) - l)))));

% ind_isum_bin_bound
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, i : INT):
  (((0 <= i) AND (i < n))
  => ((binary(f)) => (ind_isum(fc141(f, n), i, n) < power(2, (n - i))))));

% bv_to_int_bound
  ASSERT
  (FORALL (bv : bitvec):
  ((1 <= length(bv)) => (bv_to_int(bv) < power(2, length(bv)))));

% bv_to_int_bound_gen
  ASSERT
  (FORALL (bv : bitvec, l : INT):
  ((0 <= l) => ((length(bv) = l) => (bv_to_int(bv) < power(2, l)))));

int_to_bv: (INT, INT) -> bitvec;

result101: (INT, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((result101(i,
  n)[k]) = (IF ((0 <= k) AND (k < n)) THEN div(mod(i, power(2, (n - k))), 
           power(2, ((n - k) - 1))) ELSE 0 ENDIF)));

% int_to_bv'def
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n) => (int_to_bv(i, n) = make_bv(result101(i, n), n))));

fc763: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc763(i, n)[k]) = div(mod(i, 
  power(2, (n - k))), power(2, ((n - k) - 1)))));

% int_to_bv'spec
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => ((length(int_to_bv(i, n)) = n) AND (int_to_bv(i, n) = make_bv(fc763(i,
     n), n)))));

constant_size: (ty, uni, uni) -> BOOLEAN;

% constant_size'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  (((constant_size(a, s2, f))
   => (FORALL (e : uni):
      ((mem(a, e, s2))
      => ((rows(complex1, infix_at(matrix(complex1), a, f, e)) = 
         rows(complex1, infix_at(matrix(complex1), a, f, choose(a, s2))))
         AND (columns(complex1, infix_at(matrix(complex1), a, f, e)) = 
         columns(complex1, infix_at(matrix(complex1), a, f, choose(a, s2))))))))
  AND ((FORALL (e : uni):
       ((sort(a, e))
       => ((mem(a, e, s2))
          => ((rows(complex1, infix_at(matrix(complex1), a, f, e)) = 
             rows(complex1, infix_at(matrix(complex1), a, f, choose(a, s2))))
             AND (columns(complex1, infix_at(matrix(complex1), a, f, e)) = 
             columns(complex1, infix_at(matrix(complex1), a, f, choose(a,
             s2))))))))
      => (constant_size(a, s2, f))))));

% set_constant_size
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((FORALL (e : uni, eqt : uni):
   ((sort(a, e))
   => ((sort(a, eqt))
      => ((mem(a, e, s2))
         => ((mem(a, eqt, s2)) => (rows(complex1, infix_at(matrix(complex1),
            a, f, e)) = rows(complex1, infix_at(matrix(complex1), a, f,
            eqt))))))))
  => ((FORALL (e : uni, eqt : uni):
      ((sort(a, e))
      => ((sort(a, eqt))
         => ((mem(a, e, s2))
            => ((mem(a, eqt, s2)) => (columns(complex1, infix_at(
               matrix(complex1), a, f, e)) = columns(complex1, infix_at(
               matrix(complex1), a, f, eqt))))))))
     => (constant_size(a, s2, f))))));

% set_constant_size_exists
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((EXISTS (r : INT):
   (FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a, f,
      e)) = r)))))
  => ((EXISTS (c : INT):
      (FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (columns(complex1, infix_at(matrix(complex1), a,
         f, e)) = c)))))
     => (constant_size(a, s2, f))))));

% set_constant_size_t
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, r : INT, c : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a, f,
      e)) = r))))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (columns(complex1, infix_at(matrix(complex1), a,
         f, e)) = c))))
     => (constant_size(a, s2, f))))));

fc143: (ty, uni, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni, x2 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc143(a, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, p : uni, m : matrix_complex, j : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc143(a, f, p, m),
  j)) = (IF (tb2t2(infix_at(bool, a, p, j)) = 0bin1) THEN tb2t18(infix_at(
        matrix(complex1), a, f, j)) ELSE m ENDIF))));

% guarded_set_constant_size
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, p : uni, m : matrix_complex):
  ((constant_size(a, s2, f))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (tb2t2(infix_at(bool, a, p, e)) = 0bin1))))
     => (constant_size(a, s2, fc143(a, f, p, m)))))));

fc144: (ty, uni, matrix_complex, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex, x2 : INT, x3 : INT): (sort(
  infix_mngt(a, matrix(complex1)), fc144(a, x, x1, x2, x3)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, i : INT, j : INT, e : uni): (tb2t18(
  infix_at(matrix(complex1), a, fc144(a, f, m, i, j), e)) = tb2t18(
  set1(complex1, t2tb18(m), i, j, infix_at(complex1, a, f, e))))));

% set_constant_size_set
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, i : INT, j : INT):
  ((valid_index(complex1, t2tb18(m), i, j)) => (constant_size(a, s2, fc144(a,
  f, m, i, j))))));

% get_constant_size
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((FORALL (e : uni, eqt : uni):
      ((mem(a, e, s2))
      => ((mem(a, eqt, s2)) => (rows(complex1, infix_at(matrix(complex1), a,
         f, e)) = rows(complex1, infix_at(matrix(complex1), a, f, eqt))))))
     AND (FORALL (e : uni, eqt : uni):
         ((mem(a, e, s2))
         => ((mem(a, eqt, s2)) => (columns(complex1, infix_at(
            matrix(complex1), a, f, e)) = columns(complex1, infix_at(
            matrix(complex1), a, f, eqt))))))))));

s_rows: (ty, uni, uni) -> INT;

% s_rows'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((constant_size(a, s2, f)) => (s_rows(a, s2, f) = rows(complex1, infix_at(
  matrix(complex1), a, f, choose(a, s2)))))));

% s_rows'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((0 < s_rows(a, s2, f))
     AND ((FORALL (e : uni):
          ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a,
          f, e)) = s_rows(a, s2, f))))
         AND (FORALL (e : uni, eqt : uni):
             ((mem(a, e, s2))
             => ((mem(a, eqt, s2)) => (rows(complex1, infix_at(
                matrix(complex1), a, f, e)) = rows(complex1, infix_at(
                matrix(complex1), a, f, eqt)))))))))));

s_columns: (ty, uni, uni) -> INT;

% s_columns'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((constant_size(a, s2, f)) => (s_columns(a, s2, f) = columns(complex1, 
  infix_at(matrix(complex1), a, f, choose(a, s2)))))));

% s_columns'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((0 < s_columns(a, s2, f))
     AND ((FORALL (e : uni):
          ((mem(a, e, s2)) => (columns(complex1, infix_at(matrix(complex1),
          a, f, e)) = s_columns(a, s2, f))))
         AND (FORALL (e : uni, eqt : uni):
             ((mem(a, e, s2))
             => ((mem(a, eqt, s2)) => (columns(complex1, infix_at(
                matrix(complex1), a, f, e)) = columns(complex1, infix_at(
                matrix(complex1), a, f, eqt)))))))))));

% set_s_rows
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, r : INT):
  ((constant_size(a, s2, f))
  => ((rows(complex1, infix_at(matrix(complex1), a, f, choose(a, s2))) = r)
     => (s_rows(a, s2, f) = r)))));

% set_s_rows_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, elt : uni):
  ((constant_size(a, s2, f))
  => ((mem(a, elt, s2)) => (s_rows(a, s2, f) = rows(complex1, infix_at(
     matrix(complex1), a, f, elt)))))));

% set_s_columns
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, r : INT):
  ((constant_size(a, s2, f))
  => ((columns(complex1, infix_at(matrix(complex1), a, f, choose(a,
     s2))) = r) => (s_columns(a, s2, f) = r)))));

% set_s_columns_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, elt : uni):
  ((constant_size(a, s2, f))
  => ((mem(a, elt, s2)) => (s_columns(a, s2, f) = columns(complex1, infix_at(
     matrix(complex1), a, f, elt)))))));

% s_rows_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, g : uni):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (tb2t18(infix_at(matrix(complex1), a, f,
            e)) = tb2t18(infix_at(matrix(complex1), a, g, e))))))
        => (s_rows(a, s2, f) = s_rows(a, s2, g)))))));

% set_constant_size_give
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, r : INT, c : INT):
  ((0 < cardinal(a, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a, f,
         e)) = r))))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (columns(complex1, infix_at(matrix(complex1),
            a, f, e)) = c))))
        => ((constant_size(a, s2, f))
           AND ((FORALL (e : uni):
                ((mem(a, e, s2)) => (rows(complex1, infix_at(
                matrix(complex1), a, f, e)) = r)))
               AND ((FORALL (e : uni):
                    ((mem(a, e, s2)) => (columns(complex1, infix_at(
                    matrix(complex1), a, f, e)) = c)))
                   AND ((s_rows(a, s2, f) = r) AND (s_columns(a, s2, f) = c))))))))));

% s_columns_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, g : uni):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (tb2t18(infix_at(matrix(complex1), a, f,
            e)) = tb2t18(infix_at(matrix(complex1), a, g, e))))))
        => (s_columns(a, s2, f) = s_columns(a, s2, g)))))));

% subset_constant_size
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((NOT (is_empty(a, sqt)))
     => ((subset(a, sqt, s2))
        => ((constant_size(a, sqt, f))
           AND ((s_rows(a, sqt, f) = s_rows(a, s2, f)) AND (s_columns(a, sqt,
               f) = s_columns(a, s2, f)))))))));

% set_s_rows_rem
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((1 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((constant_size(a, remove(a, choose(a, s2), s2), f)) AND (s_rows(a, 
        remove(a, choose(a, s2), s2), f) = rows(complex1, infix_at(
        matrix(complex1), a, f, choose(a, s2)))))))));

% set_s_columns_rem
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((1 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((constant_size(a, remove(a, choose(a, s2), s2), f)) AND (
        s_columns(a, remove(a, choose(a, s2), s2), f) = columns(complex1, 
        infix_at(matrix(complex1), a, f, choose(a, s2)))))))));

% set_s_rows_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, x : uni):
  ((0 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((columns(complex1, infix_at(matrix(complex1), a, f, x)) = 
        s_columns(a, s2, f))
        => ((rows(complex1, infix_at(matrix(complex1), a, f, x)) = s_rows(a,
           s2, f)) => (s_rows(a, add(a, x, s2), f) = s_rows(a, s2, f))))))));

% set_s_columns_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, x : uni):
  ((0 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((columns(complex1, infix_at(matrix(complex1), a, f, x)) = 
        s_columns(a, s2, f))
        => ((rows(complex1, infix_at(matrix(complex1), a, f, x)) = s_rows(a,
           s2, f)) => (s_columns(a, add(a, x, s2), f) = s_columns(a, s2, f))))))));

% set_s_rows_columns_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, x : uni):
  ((0 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((columns(complex1, infix_at(matrix(complex1), a, f, x)) = 
        s_columns(a, s2, f))
        => ((rows(complex1, infix_at(matrix(complex1), a, f, x)) = s_rows(a,
           s2, f))
           => ((s_columns(a, add(a, x, s2), f) = s_columns(a, s2, f)) AND (
              s_rows(a, add(a, x, s2), f) = s_rows(a, s2, f)))))))));

mat_sum: (ty, uni, uni) -> matrix_complex;

% mat_sum'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2))
     => (IF (cardinal(a, s2) = 1) THEN (mat_sum(a, s2, f) = tb2t18(infix_at(
        matrix(complex1), a, f, element(a, s2)))) ELSE (mat_sum(a, s2, f) = 
        add_mat(tb2t18(infix_at(matrix(complex1), a, f, choose(a, s2))), 
        mat_sum(a, remove(a, choose(a, s2), s2), f))) ENDIF)))));

% mat_sum'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2))
     => ((rows(complex1, t2tb18(mat_sum(a, s2, f))) = s_rows(a, s2, f))
        AND ((columns(complex1, t2tb18(mat_sum(a, s2, f))) = s_columns(a, s2,
            f))
            AND ((FORALL (e : uni):
                 ((mem(a, e, s2)) => (rows(complex1, infix_at(
                 matrix(complex1), a, f, e)) = s_rows(a, s2, f))))
                AND (FORALL (e : uni):
                    ((mem(a, e, s2)) => (columns(complex1, infix_at(
                    matrix(complex1), a, f, e)) = s_columns(a, s2, f)))))))))));

% columns_mat_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, n : INT):
  ((NOT (cardinal(a, s2) = 0))
  => ((constant_size(a, s2, f))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (columns(complex1, infix_at(matrix(complex1),
            a, f, e)) = n))))
        => (columns(complex1, t2tb18(mat_sum(a, s2, f))) = n))))));

% rows_mat_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, n : INT):
  ((NOT (cardinal(a, s2) = 0))
  => ((constant_size(a, s2, f))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a,
            f, e)) = n))))
        => (rows(complex1, t2tb18(mat_sum(a, s2, f))) = n))))));

% mat_sum_cardone
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((cardinal(a, s2) = 1) => (mat_sum(a, s2, f) = tb2t18(infix_at(
  matrix(complex1), a, f, element(a, s2)))))));

fc764: (ty, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT): (sort(infix_mngt(a, complex1), 
  fc764(a, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, j : INT, e : uni): (tb2t(infix_at(complex1, a, 
  fc764(a, f, i, j), e)) = tb2t(get(complex1, infix_at(matrix(complex1), a,
  f, e), i, j)))));

% mat_sum_to_sum_pre
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, i : INT, j : INT):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2))
     => (((0 <= i) AND (i < s_rows(a, s2, f)))
        => (((0 <= j) AND (j < s_columns(a, s2, f))) => (tb2t(get(complex1, 
           t2tb18(mat_sum(a, s2, f)), i, j)) = sum(a, s2, fc764(a, f, i,
           j)))))))));

fc765: (ty, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT): (sort(infix_mngt(a, complex1), 
  fc765(a, x, x1, x2)))));

fc766: (ty, uni, uni) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, j : INT, e : uni): (tb2t(infix_at(complex1, a, 
  fc765(a, f, i, j), e)) = tb2t(get(complex1, infix_at(matrix(complex1), a,
  f, e), i, j)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, i : INT, j : INT): (tb2t(infix_at(complex1,
  int, infix_at(infix_mngt(int, complex1), int, t2tb15(fc766(a, s2, f)), 
  t2tb5(i)), t2tb5(j))) = sum(a, s2, fc765(a, f, i, j)))));

% mat_sum_to_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2)) => (mat_sum(a, s2, f) = tb2t18(make_f(complex1, 
     s_rows(a, s2, f), s_columns(a, s2, f), t2tb15(fc766(a, s2, f)))))))));

fc767: (ty, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT): (sort(infix_mngt(a, complex1), 
  fc767(a, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, j : INT, e : uni): (tb2t(infix_at(complex1, a, 
  fc767(a, f, i, j), e)) = tb2t(get(complex1, infix_at(matrix(complex1), a,
  f, e), i, j)))));

% mat_sum_value
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, i : INT, j : INT):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2))
     => ((valid_index(complex1, t2tb18(mat_sum(a, s2, f)), i, j)) => (tb2t(
        get(complex1, t2tb18(mat_sum(a, s2, f)), i, j)) = sum(a, s2, fc767(a,
        f, i, j))))))));

% mat_sum_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, x : uni):
  ((0 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((rows(complex1, infix_at(matrix(complex1), a, f, x)) = s_rows(a, s2,
        f))
        => ((columns(complex1, infix_at(matrix(complex1), a, f, x)) = 
           s_columns(a, s2, f))
           => ((NOT (mem(a, x, s2))) => (mat_sum(a, add(a, x, s2), f) = 
              add_mat(tb2t18(infix_at(matrix(complex1), a, f, x)), mat_sum(a,
              s2, f))))))))));

% mat_sum_plus_one
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((1 < cardinal(a, s2))
  => ((constant_size(a, s2, f)) => (mat_sum(a, s2, f) = add_mat(tb2t18(
     infix_at(matrix(complex1), a, f, choose(a, s2))), mat_sum(a, remove(a, 
     choose(a, s2), s2), f)))))));

fc768: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, matrix(complex1)), 
  fc768(b, x, x1)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, g : uni, k : uni): (tb2t18(infix_at(matrix(complex1), b, 
  fc768(b, f, g), k)) = add_mat(tb2t18(infix_at(matrix(complex1), b, f, k)), 
  tb2t18(infix_at(matrix(complex1), b, g, k))))));

% mat_sum_comp_pre
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, g : uni, i : INT, j : INT):
  ((constant_size(b, s2, f))
  => ((constant_size(b, s2, g))
     => (((0 <= i) AND (i < s_rows(b, s2, f)))
        => (((0 <= j) AND (j < s_columns(b, s2, f)))
           => ((s_rows(b, s2, f) = s_rows(b, s2, g))
              => ((s_columns(b, s2, f) = s_columns(b, s2, g))
                 => ((0 < cardinal(b, s2)) => (tb2t(get(complex1, t2tb18(
                    mat_sum(b, s2, fc768(b, f, g))), i, j)) = tb2t(
                    get(complex1, t2tb18(add_mat(mat_sum(b, s2, f), 
                    mat_sum(b, s2, g))), i, j))))))))))));

fc769: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, matrix(complex1)), 
  fc769(b, x, x1)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, g : uni, k : uni): (tb2t18(infix_at(matrix(complex1), b, 
  fc769(b, f, g), k)) = add_mat(tb2t18(infix_at(matrix(complex1), b, f, k)), 
  tb2t18(infix_at(matrix(complex1), b, g, k))))));

% mat_sum_comp
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, g : uni):
  ((constant_size(b, s2, f))
  => ((constant_size(b, s2, g))
     => ((s_rows(b, s2, f) = s_rows(b, s2, g))
        => ((s_columns(b, s2, f) = s_columns(b, s2, g))
           => ((0 < cardinal(b, s2)) => (mat_sum(b, s2, fc769(b, f, g)) = 
              add_mat(mat_sum(b, s2, f), mat_sum(b, s2, g))))))))));

fc770: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, matrix(complex1)), 
  fc770(b, x, x1)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, g : uni, k : uni): (tb2t18(infix_at(matrix(complex1), b, 
  fc770(b, f, g), k)) = add_mat(tb2t18(infix_at(matrix(complex1), b, f, k)), 
  tb2t18(infix_at(matrix(complex1), b, g, k))))));

% mat_sum_comp_rec
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, g : uni):
  ((constant_size(b, s2, f))
  => ((constant_size(b, s2, g))
     => ((s_rows(b, s2, f) = s_rows(b, s2, g))
        => ((s_columns(b, s2, f) = s_columns(b, s2, g))
           => ((0 < cardinal(b, s2)) => (add_mat(mat_sum(b, s2, f), 
              mat_sum(b, s2, g)) = mat_sum(b, s2, fc770(b, f, g))))))))));

fc771: (ty, ty, uni, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT): (sort(infix_mngt(a,
  complex1), fc771(b, a, x, x1, x2, x3)))));

fc772: (ty, ty, uni, INT, INT, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT, x3 : uni): (sort(infix_mngt(b,
  complex1), fc772(b, a, x, x1, x2, x3)))));

fc773: (ty, ty, uni, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT): (sort(infix_mngt(a,
  complex1), fc773(b, a, x, x1, x2, x3)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (sqt : uni, f : uni, i : INT, j : INT, e : uni): (tb2t(
  infix_at(complex1, a, fc771(b, a, sqt, f, i, j), e)) = tb2t(get(complex1, 
  t2tb18(mat_sum(b, sqt, infix_at(infix_mngt(b, matrix(complex1)), a, f,
  e))), i, j)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, i : INT, j : INT, e : uni, e1 : uni): (tb2t(
  infix_at(complex1, b, fc772(b, a, f, i, j, e), e1)) = tb2t(get(complex1, 
  infix_at(matrix(complex1), b, infix_at(infix_mngt(b, matrix(complex1)), a,
  f, e), e1), i, j)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (sqt : uni, f : uni, i : INT, j : INT, e : uni): (tb2t(
  infix_at(complex1, a, fc773(b, a, sqt, f, i, j), e)) = sum(b, sqt, fc772(b,
  a, f, i, j, e)))));

% mat_sum_to_sum_fun
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni, r : INT, c : INT, i : INT, j : INT):
  ((0 < cardinal(a, s2))
  => ((0 < cardinal(b, sqt))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => (FORALL (e1 : uni):
            ((sort(b, e1))
            => ((mem(a, e, s2))
               => ((mem(b, e1, sqt)) => (rows(complex1, infix_at(
                  matrix(complex1), b, infix_at(infix_mngt(b, 
                  matrix(complex1)), a, f, e), e1)) = r)))))))
        => ((FORALL (e : uni):
            ((sort(a, e))
            => (FORALL (e1 : uni):
               ((sort(b, e1))
               => ((mem(a, e, s2))
                  => ((mem(b, e1, sqt)) => (columns(complex1, infix_at(
                     matrix(complex1), b, infix_at(infix_mngt(b, 
                     matrix(complex1)), a, f, e), e1)) = c)))))))
           => (((0 <= i) AND (i < r))
              => (((0 <= j) AND (j < c)) => (sum(a, s2, fc771(b, a, sqt, f,
                 i, j)) = sum(a, s2, fc773(b, a, sqt, f, i, j)))))))))));

fc774: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc774(b, a, x, x1)))));

fc775: (ty, ty, uni, INT, INT, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : INT, x2 : INT, x3 : uni): (sort(infix_mngt(b,
  complex1), fc775(b, a, x, x1, x2, x3)))));

fc776: (ty, ty, uni, uni, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT, x3 : INT): (sort(infix_mngt(a,
  complex1), fc776(b, a, x, x1, x2, x3)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (sqt : uni, f : uni, e : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc774(b, a, sqt, f), e)) = mat_sum(b, sqt, infix_at(infix_mngt(b, 
  matrix(complex1)), a, f, e)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, i : INT, j : INT, e : uni, eqt : uni): (tb2t(
  infix_at(complex1, b, fc775(b, a, f, i, j, e), eqt)) = tb2t(get(complex1, 
  infix_at(matrix(complex1), b, infix_at(infix_mngt(b, matrix(complex1)), a,
  f, e), eqt), i, j)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (sqt : uni, f : uni, i : INT, j : INT, e : uni): (tb2t(
  infix_at(complex1, a, fc776(b, a, sqt, f, i, j), e)) = sum(b, sqt, fc775(b,
  a, f, i, j, e)))));

% mat_sum_to_sum_double_pre
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni, r : INT, c : INT, i : INT, j : INT):
  ((FORALL (e : uni, eqt : uni):
   ((sort(a, e))
   => ((sort(b, eqt))
      => ((mem(a, e, s2))
         => ((mem(b, eqt, sqt)) => (rows(complex1, infix_at(matrix(complex1),
            b, infix_at(infix_mngt(b, matrix(complex1)), a, f, e),
            eqt)) = r))))))
  => ((FORALL (e : uni, eqt : uni):
      ((sort(a, e))
      => ((sort(b, eqt))
         => ((mem(a, e, s2))
            => ((mem(b, eqt, sqt)) => (columns(complex1, infix_at(
               matrix(complex1), b, infix_at(infix_mngt(b, matrix(complex1)),
               a, f, e), eqt)) = c))))))
     => (((0 <= i) AND (i < r))
        => (((0 <= j) AND (j < c))
           => ((0 < cardinal(a, s2))
              => ((0 < cardinal(b, sqt)) => (tb2t(get(complex1, t2tb18(
                 mat_sum(a, s2, fc774(b, a, sqt, f))), i, j)) = sum(a, s2, 
                 fc776(b, a, sqt, f, i, j)))))))))));

fc777: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc777(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, n : matrix_complex, e : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc777(a, f, n), e)) = mat_mult(tb2t18(infix_at(
  matrix(complex1), a, f, e)), n))));

% mat_mult_sum_out_l
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, n : matrix_complex):
  ((0 < cardinal(a, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (columns(complex1, infix_at(matrix(complex1), a,
         f, e)) = rows(complex1, t2tb18(n))))))
     => ((EXISTS (r : INT):
         (FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a,
            f, e)) = r)))))
        => (mat_mult(mat_sum(a, s2, f), n) = mat_sum(a, s2, fc777(a, f, n))))))));

mat_sum_dim: (ty, uni, uni, INT, INT) -> matrix_complex;

% mat_sum_dim'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, r : INT, c : INT):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a,
            f, e)) = r))))
        => ((FORALL (e : uni):
            ((sort(a, e))
            => ((mem(a, e, s2)) => (columns(complex1, infix_at(
               matrix(complex1), a, f, e)) = c))))
           => (IF (cardinal(a, s2) = 0) THEN (mat_sum_dim(a, s2, f, r, c) = 
              tb2t18(make(complex1, r, c, t2tb(c_zero)))) ELSE (
              mat_sum_dim(a, s2, f, r, c) = mat_sum(a, s2, f)) ENDIF)))))));

% mat_sum_dim'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, r : INT, c : INT):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a,
            f, e)) = r))))
        => ((FORALL (e : uni):
            ((sort(a, e))
            => ((mem(a, e, s2)) => (columns(complex1, infix_at(
               matrix(complex1), a, f, e)) = c))))
           => (((0 < cardinal(a, s2)) => (mat_sum_dim(a, s2, f, r, c) = 
               mat_sum(a, s2, f)))
              AND (((cardinal(a, s2) = 0) => (mat_sum_dim(a, s2, f, r, c) = 
                   tb2t18(make(complex1, r, c, t2tb(c_zero)))))
                  AND ((rows(complex1, t2tb18(mat_sum_dim(a, s2, f, r,
                      c))) = r) AND (columns(complex1, t2tb18(mat_sum_dim(a,
                      s2, f, r, c))) = c))))))))));

% mat_sum_dim_to_mat_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, r : INT, c : INT):
  ((0 < cardinal(a, s2))
  => ((0 < r)
     => ((0 < c)
        => ((FORALL (e : uni):
            ((sort(a, e))
            => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1),
               a, f, e)) = r))))
           => ((FORALL (e : uni):
               ((sort(a, e))
               => ((mem(a, e, s2)) => (columns(complex1, infix_at(
                  matrix(complex1), a, f, e)) = c))))
              => (mat_sum_dim(a, s2, f, r, c) = mat_sum(a, s2, f)))))))));

% mat_sum_dim_to_make_zero
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, r : INT, c : INT):
  ((cardinal(a, s2) = 0)
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a, f,
         e)) = r))))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (columns(complex1, infix_at(matrix(complex1),
            a, f, e)) = c))))
        => ((0 < r)
           => ((0 < c) => (mat_sum_dim(a, s2, f, r, c) = tb2t18(
              make(complex1, r, c, t2tb(c_zero)))))))))));

% mat_sum_dim_add
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, x : uni, r : INT, c : INT):
  ((0 <= cardinal(a, s2))
  => ((NOT (mem(a, x, s2)))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, add(a, x, s2))) => (rows(complex1, infix_at(
            matrix(complex1), a, f, e)) = r))))
        => ((FORALL (e : uni):
            ((sort(a, e))
            => ((mem(a, e, add(a, x, s2))) => (columns(complex1, infix_at(
               matrix(complex1), a, f, e)) = c))))
           => ((0 < r)
              => ((0 < c) => (mat_sum_dim(a, add(a, x, s2), f, r, c) = 
                 add_mat(tb2t18(infix_at(matrix(complex1), a, f, x)), 
                 mat_sum_dim(a, s2, f, r, c)))))))))));

fc778: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc778(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, a1 : complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc778(a, f, a1), k)) = infix_asdtdt(a1, tb2t18(
  infix_at(matrix(complex1), a, f, k))))));

% mat_sum_scalar
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, a1 : complex):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2)) => (mat_sum(a, s2, fc778(a, f, a1)) = 
     infix_asdtdt(a1, mat_sum(a, s2, f)))))));

fc779: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc779(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, a1 : complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc779(a, f, a1), k)) = infix_asdtdt(a1, tb2t18(
  infix_at(matrix(complex1), a, f, k))))));

% mat_sum_scalar_rev
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, a1 : complex):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2)) => (infix_asdtdt(a1, mat_sum(a, s2, f)) = 
     mat_sum(a, s2, fc779(a, f, a1)))))));

fc780: (ty, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc780(a, x)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex, us : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc780(a, x), us)) = x)));

% mat_sum_const
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, x : matrix_complex):
  ((0 < cardinal(a, s2)) => (mat_sum(a, s2, fc780(a, x)) = infix_asdtdt(
  i_to_c(cardinal(a, s2)), x)))));

fc781: (ty, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc781(a, x)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex, us : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc781(a, x), us)) = x)));

% mat_sum_quot
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, x : matrix_complex):
  ((0 < cardinal(a, s2)) => (x = infix_asdtdt(infix_sldt(c_one, i_to_c(
  cardinal(a, s2))), mat_sum(a, s2, fc781(a, x)))))));

fc782: (ty, uni, matrix_complex, INT, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex, x2 : INT, x3 : INT): (sort(
  infix_mngt(a, matrix(complex1)), fc782(a, x, x1, x2, x3)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, i : INT, j : INT, k : uni): (tb2t18(
  infix_at(matrix(complex1), a, fc782(a, f, m, i, j), k)) = infix_asdtdt(
  tb2t(get(complex1, infix_at(matrix(complex1), a, f, k), i, j)), m))));

% mat_sum_scalar_right
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, i : INT, j : INT):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2))
     => (((0 <= i) AND (i < s_rows(a, s2, f)))
        => (((0 <= j) AND (j < s_columns(a, s2, f))) => (infix_asdtdt(tb2t(
           get(complex1, t2tb18(mat_sum(a, s2, f)), i, j)), m) = mat_sum(a,
           s2, fc782(a, f, m, i, j)))))))));

% mat_sum_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, g : uni):
  ((0 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((FORALL (a1 : uni):
         ((sort(a, a1))
         => ((mem(a, a1, s2)) => (tb2t18(infix_at(matrix(complex1), a, f,
            a1)) = tb2t18(infix_at(matrix(complex1), a, g, a1))))))
        => (mat_sum(a, s2, f) = mat_sum(a, s2, g)))))));

% mat_sum_eq_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni, g : uni):
  ((0 < cardinal(a, s2))
  => ((s2 = sqt)
     => ((constant_size(a, s2, f))
        => ((FORALL (a1 : uni):
            ((sort(a, a1))
            => ((mem(a, a1, s2)) => (tb2t18(infix_at(matrix(complex1), a, f,
               a1)) = tb2t18(infix_at(matrix(complex1), a, g, a1))))))
           => (mat_sum(a, s2, f) = mat_sum(a, sqt, g))))))));

% mat_sum_eq_gen_int
  ASSERT
  (FORALL (i1 : INT, i2 : INT, o1 : INT, o2 : INT,
  f : (ARRAY INT OF matrix_complex), g : (ARRAY INT OF matrix_complex)):
  ((i1 < o1)
  => ((i1 = o1)
     => ((i2 = o2)
        => ((constant_size(int, t2tb6(to_fset(i1, o1)), t2tb21(f)))
           => ((FORALL (a : INT):
               ((mem(int, t2tb5(a), t2tb6(to_fset(i1, o1)))) => (tb2t18(
               infix_at(matrix(complex1), int, t2tb21(f), t2tb5(a))) = 
               tb2t18(infix_at(matrix(complex1), int, t2tb21(g), t2tb5(a))))))
              => (mat_sum(int, t2tb6(to_fset(i1, o1)), t2tb21(f)) = 
              mat_sum(int, t2tb6(to_fset(i2, o2)), t2tb21(g)))))))));

% mat_sum_comp_eq
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, g : uni, h : uni):
  ((constant_size(b, s2, f))
  => ((constant_size(b, s2, g))
     => ((constant_size(b, s2, h))
        => (((s_rows(b, s2, f) = s_rows(b, s2, g)) AND (s_rows(b, s2, g) = 
            s_rows(b, s2, h)))
           => (((s_columns(b, s2, f) = s_columns(b, s2, g)) AND (s_columns(b,
               s2, g) = s_columns(b, s2, h)))
              => ((0 < cardinal(b, s2))
                 => ((FORALL (e : uni):
                     ((sort(b, e))
                     => (FORALL (i : INT, j : INT):
                        ((mem(b, e, s2))
                        => (((0 <= i) AND (i < s_rows(b, s2, f)))
                           => (((0 <= j) AND (j < s_columns(b, s2, f))) => (
                              infix_pldt(tb2t(get(complex1, infix_at(
                              matrix(complex1), b, f, e), i, j)), tb2t(
                              get(complex1, infix_at(matrix(complex1), b, g,
                              e), i, j))) = tb2t(get(complex1, infix_at(
                              matrix(complex1), b, h, e), i, j)))))))))
                    => (add_mat(mat_sum(b, s2, f), mat_sum(b, s2, g)) = 
                    mat_sum(b, s2, h)))))))))));

% mat_sum_dim_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, g : uni, r : INT, c : INT):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a,
            f, e)) = r))))
        => ((FORALL (e : uni):
            ((sort(a, e))
            => ((mem(a, e, s2)) => (columns(complex1, infix_at(
               matrix(complex1), a, f, e)) = c))))
           => ((FORALL (e : uni):
               ((sort(a, e))
               => ((mem(a, e, s2)) => (tb2t18(infix_at(matrix(complex1), a,
                  f, e)) = tb2t18(infix_at(matrix(complex1), a, g, e))))))
              => (mat_sum_dim(a, s2, f, r, c) = mat_sum_dim(a, s2, g, r, c)))))))));

fc164: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc164(b, a, x, x1)))));

t2tb80: ((ARRAY angle OF matrix_complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY angle OF matrix_complex)): (sort(infix_mngt(angle1, 
  matrix(complex1)), t2tb80(x))));

tb2t80: (uni) -> (ARRAY angle OF matrix_complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY angle OF matrix_complex)):PATTERN (t2tb80(i)):  (
  tb2t80(t2tb80(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb80(tb2t80(j))): 
  ((sort(infix_mngt(angle1, matrix(complex1)), j)) => (t2tb80(
  tb2t80(j)) = j)));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY angle OF matrix_complex), t1 : (ARRAY INT OF angle),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc164(angle1, int, 
  t2tb80(f), t2tb35(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1),
  angle1, t2tb80(f), t2tb33((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), t1 : (ARRAY INT OF INT),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc164(int, int, 
  t2tb21(f), t2tb7(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1), int, 
  t2tb21(f), t2tb5((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, t1 : uni, a1 : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc164(b, a, f, t1), a1)) = tb2t18(infix_at(matrix(complex1), b, f, 
  infix_at(b, a, t1, a1))))));

% constant_size_map
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, t1 : uni):
  ((constant_size(a, s2, fc164(b, a, f, t1))) => (constant_size(b, map(b, a,
  t1, s2), f)))));

fc783: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc783(b, a, x, x1)))));

fc784: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc784(b, a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY angle OF matrix_complex), t1 : (ARRAY INT OF angle),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc783(angle1, int, 
  t2tb80(f), t2tb35(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1),
  angle1, t2tb80(f), t2tb33((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), t1 : (ARRAY INT OF INT),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc783(int, int, 
  t2tb21(f), t2tb7(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1), int, 
  t2tb21(f), t2tb5((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, t1 : uni, a1 : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc783(b, a, f, t1), a1)) = tb2t18(infix_at(matrix(complex1), b, f, 
  infix_at(b, a, t1, a1))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY angle OF matrix_complex), t1 : (ARRAY INT OF angle),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc784(angle1, int, 
  t2tb80(f), t2tb35(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1),
  angle1, t2tb80(f), t2tb33((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), t1 : (ARRAY INT OF INT),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc784(int, int, 
  t2tb21(f), t2tb7(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1), int, 
  t2tb21(f), t2tb5((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, t1 : uni, a1 : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc784(b, a, f, t1), a1)) = tb2t18(infix_at(matrix(complex1), b, f, 
  infix_at(b, a, t1, a1))))));

% map_mat_sum
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, t1 : uni):
  ((0 < cardinal(a, s2))
  => ((constant_size(a, s2, fc783(b, a, f, t1)))
     => ((p_injective(b, a, t1, s2)) => (mat_sum(b, map(b, a, t1, s2), f) = 
        mat_sum(a, s2, fc784(b, a, f, t1))))))));

fc785: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc785(b, a, x, x1)))));

fc786: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc786(b, a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY angle OF matrix_complex), t1 : (ARRAY INT OF angle),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc785(angle1, int, 
  t2tb80(f), t2tb35(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1),
  angle1, t2tb80(f), t2tb33((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), t1 : (ARRAY INT OF INT),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc785(int, int, 
  t2tb21(f), t2tb7(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1), int, 
  t2tb21(f), t2tb5((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, t1 : uni, a1 : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc785(b, a, f, t1), a1)) = tb2t18(infix_at(matrix(complex1), b, f, 
  infix_at(b, a, t1, a1))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY angle OF matrix_complex), t1 : (ARRAY INT OF angle),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc786(angle1, int, 
  t2tb80(f), t2tb35(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1),
  angle1, t2tb80(f), t2tb33((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), t1 : (ARRAY INT OF INT),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc786(int, int, 
  t2tb21(f), t2tb7(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1), int, 
  t2tb21(f), t2tb5((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, t1 : uni, a1 : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc786(b, a, f, t1), a1)) = tb2t18(infix_at(matrix(complex1), b, f, 
  infix_at(b, a, t1, a1))))));

% map_mat_sum_rec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, t1 : uni):
  ((0 < cardinal(a, s2))
  => ((constant_size(a, s2, fc785(b, a, f, t1)))
     => ((p_injective(b, a, t1, s2)) => (mat_sum(a, s2, fc786(b, a, f,
        t1)) = mat_sum(b, map(b, a, t1, s2), f)))))));

identity1: (ARRAY matrix_complex OF matrix_complex);

% identity_def
  ASSERT
  (FORALL (y : matrix_complex): (tb2t18(infix_at(matrix(complex1), 
  matrix(complex1), t2tb19(identity1), t2tb18(y))) = y));

set_lpmatrix_complexrp: TYPE;

t2tb25: (set_lpmatrix_complexrp) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : set_lpmatrix_complexrp): (sort(set(matrix(complex1)), 
  t2tb25(x))));

tb2t25: (uni) -> set_lpmatrix_complexrp;

% BridgeL
  ASSERT
  (FORALL (i : set_lpmatrix_complexrp):PATTERN (t2tb25(i)):  (tb2t25(
  t2tb25(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb25(tb2t25(j))): 
  ((sort(set(matrix(complex1)), j)) => (t2tb25(tb2t25(j)) = j)));

% mat_sum_id
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((0 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((constant_size(matrix(complex1), map(matrix(complex1), a, f, s2), 
        t2tb19(identity1)))
        => ((p_injective(matrix(complex1), a, f, s2)) => (mat_sum(
           matrix(complex1), map(matrix(complex1), a, f, s2), 
           t2tb19(identity1)) = mat_sum(a, s2, f))))))));

nonn_mat_subset: (ty, uni, uni) -> uni;

% nonn_mat_subset_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(a), nonn_mat_subset(a, x, x1)))));

result102: (ty, uni, uni) -> uni;

% result_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, bool), result102(a, x,
  x1)))));

% result'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, e : uni):
  ((tb2t2(infix_at(bool, a, result102(a, f, s2), e)) = 0bin1)
  <=> (NOT (infix_eqeq(matrix(complex1), infix_at(matrix(complex1), a, f, e), 
      make(complex1, s_rows(a, s2, f), s_columns(a, s2, f), t2tb(c_zero))))))));

% nonn_mat_subset'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((constant_size(a, s2, f)) => (nonn_mat_subset(a, f, s2) = filter_(a, s2, 
  result102(a, f, s2))))));

% nonn_mat_subset'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((constant_size(a, s2, f))
  => ((subset(a, nonn_mat_subset(a, f, s2), s2))
     AND ((FORALL (e : uni):
          ((mem(a, e, nonn_mat_subset(a, f, s2))) => (mem(a, e, s2))))
         AND ((constant_size(a, nonn_mat_subset(a, f, s2), f))
             AND (((NOT (nonn_mat_subset(a, f, s2) = empty(a))) => (s_rows(a, 
                  nonn_mat_subset(a, f, s2), f) = s_rows(a, s2, f)))
                 AND ((NOT (nonn_mat_subset(a, f, s2) = empty(a))) => (
                     s_columns(a, nonn_mat_subset(a, f, s2), f) = 
                     s_columns(a, s2, f))))))))));

% mat_subset_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((constant_size(a, s2, f))
  => (FORALL (e : uni):
     ((mem(a, e, nonn_mat_subset(a, f, s2))) => (mem(a, e, s2)))))));

% mat_subset_nonn_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((constant_size(a, s2, f))
  => (FORALL (e : uni):
     ((mem(a, e, nonn_mat_subset(a, f, s2)))
     => (NOT (tb2t18(infix_at(matrix(complex1), a, f, e)) = tb2t18(
        make(complex1, s_rows(a, s2, f), s_columns(a, s2, f), 
        t2tb(c_zero))))))))));

% nonn_mat_sum_cardzero
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, r : INT, c : INT):
  ((cardinal(a, s2) = 0)
  => ((0 < r)
     => ((0 < c) => (mat_sum_dim(a, s2, f, r, c) = mat_sum_dim(a, 
        nonn_mat_subset(a, f, s2), f, r, c)))))));

% nonn_mat_sum_cardone
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, r : INT, c : INT):
  ((cardinal(a, s2) = 1)
  => ((0 < r)
     => ((0 < c)
        => ((rows(complex1, infix_at(matrix(complex1), a, f, choose(a,
           s2))) = r)
           => ((columns(complex1, infix_at(matrix(complex1), a, f, choose(a,
              s2))) = c) => (mat_sum_dim(a, s2, f, r, c) = mat_sum_dim(a, 
              nonn_mat_subset(a, f, s2), f, r, c)))))))));

% mat_sum_null_but_maybe_one_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, e : uni):
  ((1 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((mem(a, e, s2))
        => ((FORALL (eqt : uni):
            ((sort(a, eqt))
            => ((mem(a, eqt, s2))
               => ((NOT (e = eqt)) => (null_mat(tb2t18(infix_at(
                  matrix(complex1), a, f, eqt))))))))
           => (mat_sum(a, s2, f) = tb2t18(infix_at(matrix(complex1), a, f,
           e)))))))));

% nonn_mat_sum_plus_one
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, r : INT, c : INT):
  ((1 < cardinal(a, s2))
  => ((0 < r)
     => ((0 < c)
        => ((FORALL (e : uni):
            ((sort(a, e))
            => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1),
               a, f, e)) = r))))
           => ((FORALL (e : uni):
               ((sort(a, e))
               => ((mem(a, e, s2)) => (columns(complex1, infix_at(
                  matrix(complex1), a, f, e)) = c))))
              => ((mat_sum_dim(a, remove(a, choose(a, s2), s2), f, r, c) = 
                 mat_sum_dim(a, nonn_mat_subset(a, f, remove(a, choose(a,
                 s2), s2)), f, r, c)) => (mat_sum_dim(a, s2, f, r, c) = 
                 mat_sum_dim(a, nonn_mat_subset(a, f, s2), f, r, c))))))))));

% nonn_mat_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, r : INT, c : INT):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a,
            f, e)) = r))))
        => ((FORALL (e : uni):
            ((sort(a, e))
            => ((mem(a, e, s2)) => (columns(complex1, infix_at(
               matrix(complex1), a, f, e)) = c))))
           => (mat_sum_dim(a, s2, f, r, c) = mat_sum_dim(a, 
           nonn_mat_subset(a, f, s2), f, r, c))))))));

fc787: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, c : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc787(c, a, x, x1)))));

fc788: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (b : ty, c : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(b, matrix(complex1)), 
  fc788(c, b, x, x1)))));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF angle), f : (ARRAY angle OF matrix_complex),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc787(angle1, int, 
  t2tb35(t1), t2tb80(f)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1),
  angle1, t2tb80(f), t2tb33((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (t1 : (ARRAY INT OF INT), f : (ARRAY INT OF matrix_complex),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc787(int, int, 
  t2tb7(t1), t2tb21(f)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1), int, 
  t2tb21(f), t2tb5((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, c : ty):
  (FORALL (t1 : uni, f : uni, a1 : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc787(c, a, t1, f), a1)) = tb2t18(infix_at(matrix(complex1), c, f, 
  infix_at(c, a, t1, a1))))));

% fc'def
  ASSERT
  (FORALL (t2 : (ARRAY INT OF angle), f : (ARRAY angle OF matrix_complex),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc788(angle1, int, 
  t2tb35(t2), t2tb80(f)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1),
  angle1, t2tb80(f), t2tb33((t2[a]))))));

% fc'def
  ASSERT
  (FORALL (t2 : (ARRAY INT OF INT), f : (ARRAY INT OF matrix_complex),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc788(int, int, 
  t2tb7(t2), t2tb21(f)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1), int, 
  t2tb21(f), t2tb5((t2[a]))))));

% fc'def
  ASSERT
  (FORALL (b : ty, c : ty):
  (FORALL (t2 : uni, f : uni, a : uni): (tb2t18(infix_at(matrix(complex1), b, 
  fc788(c, b, t2, f), a)) = tb2t18(infix_at(matrix(complex1), c, f, 
  infix_at(c, b, t2, a))))));

% mat_sum_map_map
  ASSERT
  (FORALL (a : ty, b : ty, c : ty):
  (FORALL (s11 : uni, s2 : uni, t1 : uni, t2 : uni, f : uni):
  ((0 < cardinal(a, s11))
  => ((p_injective(c, a, t1, s11))
     => ((constant_size(a, s11, fc787(c, a, t1, f)))
        => ((0 < cardinal(b, s2))
           => ((p_injective(c, b, t2, s2))
              => ((constant_size(b, s2, fc788(c, b, t2, f)))
                 => ((map(c, a, t1, s11) = map(c, b, t2, s2)) => (mat_sum(c, 
                    map(c, a, t1, s11), f) = mat_sum(c, map(c, b, t2, s2),
                    f)))))))))));

% mat_sum_disjoint_transitivity
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, s11 : uni, s21 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((inter(a, s11, s21) = empty(a))
     => ((union(a, s11, s21) = s2)
        => ((0 < cardinal(a, s11))
           => ((0 < cardinal(a, s21)) => (add_mat(mat_sum(a, s11, f), 
              mat_sum(a, s21, f)) = mat_sum(a, s2, f)))))))));

% mat_sum_null
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((1 < cardinal(a, s2))
  => ((constant_size(a, s2, f))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2))
            => (FORALL (i : INT, j : INT):
               ((valid_index(complex1, infix_at(matrix(complex1), a, f, e),
               i, j)) => (tb2t(get(complex1, infix_at(matrix(complex1), a, f,
               e), i, j)) = c_zero))))))
        => (FORALL (i : INT, j : INT):
           ((valid_index(complex1, t2tb18(mat_sum(a, s2, f)), i, j)) => (
           tb2t(get(complex1, t2tb18(mat_sum(a, s2, f)), i, j)) = c_zero))))))));

% mat_sum_null_b
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, r : INT, c : INT):
  ((1 < cardinal(a, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (rows(complex1, infix_at(matrix(complex1), a, f,
         e)) = r))))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (columns(complex1, infix_at(matrix(complex1),
            a, f, e)) = c))))
        => ((FORALL (e : uni):
            ((sort(a, e))
            => ((mem(a, e, s2))
               => (FORALL (i : INT, j : INT):
                  ((valid_index(complex1, infix_at(matrix(complex1), a, f,
                  e), i, j)) => (tb2t(get(complex1, infix_at(
                  matrix(complex1), a, f, e), i, j)) = c_zero))))))
           => (FORALL (i : INT, j : INT):
              (((0 <= i) AND (i < r))
              => (((0 <= j) AND (j < c)) => (tb2t(get(complex1, t2tb18(
                 mat_sum(a, s2, f)), i, j)) = c_zero))))))))));

fc789: (ty, ty, uni, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(a, 
  matrix(complex1)), fc789(b, a, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY angle OF matrix_complex), injz : (ARRAY INT OF angle),
  injo : (ARRAY INT OF angle), e : INT): (tb2t18(infix_at(matrix(complex1),
  int, fc789(angle1, int, t2tb80(f), t2tb35(injz), t2tb35(injo)), 
  t2tb5(e))) = add_mat(tb2t18(infix_at(matrix(complex1), angle1, t2tb80(f), 
  t2tb33((injz[e])))), tb2t18(infix_at(matrix(complex1), angle1, t2tb80(f), 
  t2tb33((injo[e])))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), injz : (ARRAY INT OF INT),
  injo : (ARRAY INT OF INT), e : INT): (tb2t18(infix_at(matrix(complex1),
  int, fc789(int, int, t2tb21(f), t2tb7(injz), t2tb7(injo)), t2tb5(e))) = 
  add_mat(tb2t18(infix_at(matrix(complex1), int, t2tb21(f), 
  t2tb5((injz[e])))), tb2t18(infix_at(matrix(complex1), int, t2tb21(f), 
  t2tb5((injo[e])))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, injz : uni, injo : uni, e : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc789(b, a, f, injz, injo), e)) = add_mat(tb2t18(
  infix_at(matrix(complex1), b, f, infix_at(b, a, injz, e))), tb2t18(
  infix_at(matrix(complex1), b, f, infix_at(b, a, injo, e)))))));

% map_add_mat_sum_t
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni, injz : uni, injo : uni):
  ((constant_size(b, sqt, f))
  => ((0 < cardinal(a, s2))
     => ((inter(b, map(b, a, injz, s2), map(b, a, injo, s2)) = empty(b))
        => ((union(b, map(b, a, injz, s2), map(b, a, injo, s2)) = sqt)
           => ((p_injective(b, a, injo, s2))
              => ((p_injective(b, a, injz, s2)) => (mat_sum(a, s2, fc789(b,
                 a, f, injz, injo)) = mat_sum(b, sqt, f))))))))));

fc790: (ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc790(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, g : uni, e : uni): (tb2t18(infix_at(matrix(complex1), a, 
  fc790(a, f, g), e)) = add_mat(tb2t18(infix_at(matrix(complex1), a, f, e)), 
  tb2t18(infix_at(matrix(complex1), a, g, e))))));

% map_add_mat_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, s11 : uni, s21 : uni, sqt : uni, f : uni, g : uni,
  h : uni):
  ((constant_size(a, sqt, h))
  => ((constant_size(a, s2, f))
     => ((constant_size(a, s2, g))
        => (((s_rows(a, sqt, h) = s_rows(a, s2, f)) AND (s_rows(a, s2, f) = 
            s_rows(a, s2, g)))
           => (((s_columns(a, sqt, h) = s_columns(a, s2, f)) AND (
               s_columns(a, s2, f) = s_columns(a, s2, g)))
              => ((0 < cardinal(a, s2))
                 => ((p_injective(matrix(complex1), a, f, s2))
                    => ((p_injective(matrix(complex1), a, g, s2))
                       => ((p_injective(matrix(complex1), a, h, sqt))
                          => ((tb2t25(map(matrix(complex1), a, f, s2)) = 
                             tb2t25(map(matrix(complex1), a, h, s11)))
                             => ((tb2t25(map(matrix(complex1), a, g, s2)) = 
                                tb2t25(map(matrix(complex1), a, h, s21)))
                                => ((inter(a, s11, s21) = empty(a))
                                   => ((union(a, s11, s21) = sqt) => (
                                      mat_sum(a, s2, fc790(a, f, g)) = 
                                      mat_sum(a, sqt, h)))))))))))))))));

fc791: (bitvec) -> (ARRAY INT OF INT);

fc792: (bitvec) -> (ARRAY INT OF INT);

fc793: (bitvec) -> (ARRAY INT OF INT);

fc794: (bitvec, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc791(bv)[k]) = ((value(bv)[k]) * 
  power(2, ((length(bv) - 1) - k)))));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc792(bv)[k]) = ((value(bv)[k]) * 
  power(2, ((length(bv) - 1) - k)))));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc793(bv)[k]) = ((value(bv)[k]) * 
  power(2, ((length(bv) - 1) - k)))));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, i : INT, k : INT): ((fc794(bv, i)[k]) = ((
  value(bv)[k]) * power(2, ((i - 1) - k)))));

% ind_isum_mod_div
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i < length(bv)))
  => ((mod(ind_isum(fc791(bv), 0, length(bv)), power(2, (length(bv) - i))) = 
     ind_isum(fc792(bv), i, length(bv))) AND (div(ind_isum(fc793(bv), 0, 
     length(bv)), power(2, (length(bv) - i))) = ind_isum(fc794(bv, i), 0,
     i)))));

fc177: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

fc178: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, k : INT): ((fc177(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, k : INT): ((fc178(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))));

% mod_ind_isum
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT):
  (((0 <= i) AND (i <= l))
  => ((binary(f)) => (mod(ind_isum(fc177(f, l), 0, l), power(2, i)) = 
     ind_isum(fc178(f, l), (l - i), l)))));

fc179: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

fc180: ((ARRAY INT OF INT), INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, k : INT): ((fc179(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT, k : INT): ((fc180(f, i,
  l)[k]) = ((f[((k + l) - i)]) * power(2, ((i - 1) - k)))));

% mod_ind_isum_z
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT):
  (((0 <= i) AND (i <= l))
  => ((binary(f)) => (mod(ind_isum(fc179(f, l), 0, l), power(2, i)) = 
     ind_isum(fc180(f, i, l), 0, i)))));

fc181: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

fc182: ((ARRAY INT OF INT), INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, k : INT): ((fc181(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT, k : INT): ((fc182(f, i,
  l)[k]) = ((f[k]) * power(2, (((l - 1) - k) - i)))));

% div_ind_isum
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT):
  (((0 <= i) AND (i <= l))
  => ((binary(f)) => (div(ind_isum(fc181(f, l), 0, l), power(2, i)) = 
     ind_isum(fc182(f, i, l), 0, (l - i))))));

fc795: (bitvec, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, i : INT, l : INT): ((fc795(bv, i)[l]) = ((
  value(bv)[l]) * power(2, (i - l)))));

% ind_isum_mod
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i < length(bv))) => (mod(ind_isum(fc795(bv, i), 0,
  (i + 1)), 2) = (value(bv)[i]))));

fc184: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

fc185: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, k : INT): ((fc184(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, k : INT): ((fc185(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))));

% mod_ind_isum_
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT):
  (((0 <= i) AND (i <= l))
  => ((binary(f)) => (mod(ind_isum(fc184(f, l), 0, l), power(2, i)) = 
     ind_isum(fc185(f, l), (l - i), l)))));

fc186: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

fc187: ((ARRAY INT OF INT), INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, k : INT): ((fc186(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT, k : INT): ((fc187(f, i,
  l)[k]) = ((f[((k + l) - i)]) * power(2, ((i - 1) - k)))));

% mod_ind_isum_z_
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT):
  (((0 <= i) AND (i <= l))
  => ((binary(f)) => (mod(ind_isum(fc186(f, l), 0, l), power(2, i)) = 
     ind_isum(fc187(f, i, l), 0, i)))));

fc188: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

fc189: ((ARRAY INT OF INT), INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, k : INT): ((fc188(f,
  l)[k]) = ((f[k]) * power(2, ((l - 1) - k)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT, k : INT): ((fc189(f, i,
  l)[k]) = ((f[k]) * power(2, (((l - 1) - k) - i)))));

% div_ind_isum_
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, l : INT):
  (((0 <= i) AND (i <= l))
  => ((binary(f)) => (div(ind_isum(fc188(f, l), 0, l), power(2, i)) = 
     ind_isum(fc189(f, i, l), 0, (l - i))))));

fc796: (bitvec, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, i : INT, l : INT): ((fc796(bv, i)[l]) = ((
  value(bv)[l]) * power(2, (i - l)))));

% ind_isum_mod_
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i < length(bv))) => (mod(ind_isum(fc796(bv, i), 0,
  (i + 1)), 2) = (value(bv)[i]))));

fc797: (bitvec) -> (ARRAY INT OF INT);

fc798: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc797(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc798(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% bv_to_int_kth_pre
  ASSERT
  (FORALL (bv : bitvec, k : INT):
  (((0 <= k) AND (k < (length(bv) - 1)))
  => (((value(bv)[k]) = mod(div(ind_isum(fc797(bv), 0, length(bv)), power(2,
     ((length(bv) - k) - 1))), 2)) AND ((value(bv)[k]) = div(mod(ind_isum(
     fc798(bv), 0, length(bv)), power(2, (length(bv) - k))), power(2, ((
     length(bv) - k) - 1)))))));

fc799: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, l : INT): ((fc799(i, n)[l]) = ((value(
  int_to_bv(i, n))[l]) * power(2, ((n - l) - 1)))));

% int_to_bv_sum_pre
  ASSERT
  (FORALL (i : INT, n : INT, k : INT):
  (((k <= n) AND (0 <= k))
  => (((0 <= i) AND (i < power(2, n))) => (mod(i, power(2, k)) = ind_isum(
     fc799(i, n), (n - k), n)))));

fc800: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc800(i, n)[k]) = ((value(
  int_to_bv(i, n))[k]) * power(2, ((n - 1) - k)))));

% int_to_bv_sum
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (i = ind_isum(fc800(i, n), 0, n)))));

fc801: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc801(i, n)[k]) = ((value(
  int_to_bv(i, n))[k]) * power(2, ((n - k) - 1)))));

% int_to_bv_sum_rev
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (ind_isum(fc801(i, n), 0, n) = i))));

fc802: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc802(i, n)[k]) = mod(div(i, 
  power(2, ((n - k) - 1))), 2)));

% int_to_bv_mod_div
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (int_to_bv(i, n) = make_bv(fc802(i,
     n), n)))));

fc803: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, l : INT): ((fc803(i, n)[l]) = ((value(
  int_to_bv(i, n))[l]) * power(2, ((n - 1) - l)))));

% mod_isum
  ASSERT
  (FORALL (i : INT, k : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => (mod(i, power(2, k)) = ind_isum(fc803(i,
        n), (n - k), n))))));

fc804: (INT, INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, k : INT, n : INT, l : INT): ((fc804(i, k, n)[l]) = ((
  value(int_to_bv(i, n))[(l + (n - k))]) * power(2, ((k - l) - 1)))));

% mod_isum_z
  ASSERT
  (FORALL (i : INT, k : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => (mod(i, power(2, k)) = ind_isum(fc804(i,
        k, n), 0, k))))));

fc805: (INT, INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, k : INT, n : INT, l : INT): ((fc805(i, k, n)[l]) = ((
  value(int_to_bv(i, n))[l]) * power(2, (((n - 1) - k) - l)))));

% div_isum
  ASSERT
  (FORALL (i : INT, k : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => (div(i, power(2, k)) = ind_isum(fc805(i,
        k, n), 0, (n - k)))))));

fc806: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc806(i, n)[k]) = div(mod(i, 
  power(2, (n - k))), power(2, ((n - k) - 1)))));

% int_to_bv_div_mod
  ASSERT
  (FORALL (i : INT, k : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => (int_to_bv(i, n) = make_bv(fc806(i, n),
        n))))));

% int_to_bv_value
  ASSERT
  (FORALL (i : INT, n : INT, k : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => ((value(int_to_bv(i, n))[k]) = mod(div(i, 
        power(2, ((n - k) - 1))), 2))))));

% int_to_bv_value_zero
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => ((value(int_to_bv(i,
     n))[0]) = (IF (i < power(2, (n - 1))) THEN 0 ELSE 1 ENDIF)))));

fc807: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc807(i, n)[k]) = mod(div(i, 
  power(2, ((n - k) - 1))), 2)));

% int_to_bv_mod_div_
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (int_to_bv(i, n) = make_bv(fc807(i,
     n), n)))));

fc808: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, l : INT): ((fc808(i, n)[l]) = ((value(
  int_to_bv(i, n))[l]) * power(2, ((n - 1) - l)))));

% mod_isum_
  ASSERT
  (FORALL (i : INT, k : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => (mod(i, power(2, k)) = ind_isum(fc808(i,
        n), (n - k), n))))));

fc809: (INT, INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, k : INT, n : INT, l : INT): ((fc809(i, k, n)[l]) = ((
  value(int_to_bv(i, n))[(l + (n - k))]) * power(2, ((k - l) - 1)))));

% mod_isum_z_
  ASSERT
  (FORALL (i : INT, k : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => (mod(i, power(2, k)) = ind_isum(fc809(i,
        k, n), 0, k))))));

fc810: (INT, INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, k : INT, n : INT, l : INT): ((fc810(i, k, n)[l]) = ((
  value(int_to_bv(i, n))[l]) * power(2, (((n - 1) - k) - l)))));

% div_isum_
  ASSERT
  (FORALL (i : INT, k : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => (div(i, power(2, k)) = ind_isum(fc810(i,
        k, n), 0, (n - k)))))));

fc811: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc811(i, n)[k]) = div(mod(i, 
  power(2, (n - k))), power(2, ((n - k) - 1)))));

% int_to_bv_div_mod_
  ASSERT
  (FORALL (i : INT, k : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => (int_to_bv(i, n) = make_bv(fc811(i, n),
        n))))));

% int_to_bv_value_
  ASSERT
  (FORALL (i : INT, n : INT, k : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= k) AND (k < n)) => ((value(int_to_bv(i, n))[k]) = mod(div(i, 
        power(2, ((n - k) - 1))), 2))))));

% int_to_bv_value_zero_
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => ((value(int_to_bv(i,
     n))[0]) = (IF (i < power(2, (n - 1))) THEN 0 ELSE 1 ENDIF)))));

% int_to_bv_zero
  ASSERT
  (FORALL (n : INT):
  (FORALL (k : INT):
  (((0 <= k) AND (k < n)) => ((value(int_to_bv(0, n))[k]) = 0))));

fc812: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc812(i, n)[k]) = ((value(
  int_to_bv(i, n))[k]) * power(2, ((n - k) - 1)))));

% int_to_sum
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (i = ind_isum(fc812(i, n), 0, n)))));

% int_to_bv_transl
  ASSERT
  (FORALL (i : INT, k : INT, n : INT, t1 : INT):
  (((0 <= i) AND (i < power(2, n)))
  => (((0 <= k) AND (k < (n - t1)))
     => (((0 < t1) AND (t1 <= n)) => ((value(int_to_bv(mod(i, power(2,
        (n - t1))), (n - t1)))[k]) = (value(int_to_bv(i, n))[(k + t1)]))))));

% int_to_bv_transl_div
  ASSERT
  (FORALL (i : INT, k : INT, n : INT, nqt : INT, t1 : INT):
  (((0 <= i) AND (i < power(2, n)))
  => (((0 <= k) AND (k < t1))
     => ((nqt = t1)
        => (((0 < t1) AND (t1 <= n)) => ((value(int_to_bv(div(i, power(2,
           (n - t1))), nqt))[k]) = (value(int_to_bv(i, n))[k])))))));

fc813: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (n : INT, i : INT, j : INT): ((fc813(n, i)[j]) = (1 - (value(
  int_to_bv(i, n))[j]))));

% product_int_to_bv_inv
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (ind_iproduct(fc813(n, i), 0,
     n) = (IF (i = 0) THEN 1 ELSE 0 ENDIF)))));

bin_to_int: ((ARRAY INT OF INT), INT) -> INT;

% bin_to_int'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((0 <= n)
  => ((binary_l(f, n)) => (bin_to_int(f, n) = bv_to_int(make_bv(f, n))))));

fc208: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, k : INT): ((fc208(f,
  n)[k]) = ((f[k]) * power(2, ((n - 1) - k)))));

% bin_to_int'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((0 <= n)
  => ((binary_l(f, n))
     => ((bin_to_int(f, n) = ind_isum(fc208(f, n), 0, n)) AND (0 <= 
        bin_to_int(f, n))))));

int_to_bin: (INT, INT) -> (ARRAY INT OF INT);

% int_to_bin'def
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (int_to_bin(i, n) = value(
     int_to_bv(i, n))))));

fc814: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc814(i, n)[k]) = ((int_to_bin(i,
  n)[k]) * power(2, ((n - 1) - k)))));

% int_to_bin'spec
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => ((i = ind_isum(fc814(i, n), 0, n))
        AND ((binary(int_to_bin(i, n)))
            AND (FORALL (k : INT):
                (((0 <= k) AND (k < n)) => ((int_to_bin(i, n)[k]) = mod(
                div(i, power(2, ((n - k) - 1))), 2)))))))));

% int_to_bv_tail
  ASSERT
  (FORALL (i : INT, n : INT):
  ((1 < n)
  => (((0 <= i) AND (i < power(2, n))) => (int_to_bv(tail_bits(i, n),
     (n - 1)) = tail(int_to_bv(i, n))))));

fc815: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc815(bv)[l]) = ((value(bv)[l]) * 
  power(2, (length(bv) - l)))));

% bound_sum_dec
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((1 <= i) AND (i <= length(bv))) => (ind_isum(fc815(bv), i, (
  length(bv) + 1)) < power(2, ((length(bv) - i) + 1)))));

% bv_to_int_to_bv
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (bv_to_int(int_to_bv(i, n)) = i))));

% bv_to_int_to_bv_
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (bv_to_int(int_to_bv(i, n)) = i))));

fc816: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, l : INT): ((fc816(i, n)[l]) = ((value(
  int_to_bv(i, n))[l]) * power(2, ((n - 1) - l)))));

% tail_bits_sum
  ASSERT
  (FORALL (i : INT, n : INT):
  ((1 < n)
  => ((0 <= i)
     => (((0 <= i) AND (i < power(2, n))) => (tail_bits(i, n) = ind_isum(
        fc816(i, n), 1, n))))));

% int_to_bv_to_int
  ASSERT
  (FORALL (bv : bitvec):
  ((1 <= length(bv)) => (int_to_bv(bv_to_int(bv), length(bv)) = bv)));

% int_to_bv_to_int_
  ASSERT
  (FORALL (bv : bitvec, l : INT):
  ((0 <= l) => ((length(bv) = l) => (int_to_bv(bv_to_int(bv), l) = bv))));

% int_to_bv_to_int_rev
  ASSERT
  (FORALL (bv : bitvec, l : INT):
  ((0 <= l) => ((length(bv) = l) => (bv = int_to_bv(bv_to_int(bv), l)))));

% concat_to_int
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i <= 1)) => (bv_to_int(concat_l(bv, i)) = (
  bv_to_int(bv) + (i * power(2, length(bv)))))));

% bounded_to_int
  ASSERT (FORALL (bv : bitvec): (bv_to_int(bv) < power(2, length(bv))));

% int_to_bv_to_int_value
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  ((1 <= length(bv)) => ((value(int_to_bv(bv_to_int(bv), 
  length(bv)))[i]) = (IF ((0 <= i) AND (i < length(bv))) THEN (value(bv)[i])
                     ELSE 0 ENDIF))));

% int_to_bv_to_int_gen
  ASSERT
  (FORALL (bv : bitvec, n : INT):
  ((1 <= length(bv))
  => ((n = length(bv)) => (int_to_bv(bv_to_int(bv), n) = bv))));

fc817: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc817(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% bv_to_int_mod
  ASSERT
  (FORALL (bv : bitvec, k : INT):
  (((0 <= k) AND (k < length(bv))) => (mod(bv_to_int(bv), power(2, (
  length(bv) - k))) = ind_isum(fc817(bv), k, length(bv)))));

fc818: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc818(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% bv_to_int_mod_rev
  ASSERT
  (FORALL (bv : bitvec, k : INT):
  (((0 <= k) AND (k < length(bv))) => (ind_isum(fc818(bv), k, length(bv)) = 
  mod(bv_to_int(bv), power(2, (length(bv) - k))))));

fc819: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc819(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% bv_to_int_mod_gen
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < n))
  => (FORALL (bv : bitvec):
     ((length(bv) = n) => (mod(bv_to_int(bv), power(2, (length(bv) - k))) = 
     ind_isum(fc819(bv), k, length(bv)))))));

% to_int_head_tail
  ASSERT
  (FORALL (bv : bitvec):
  ((1 <= length(bv))
  => ((bv_to_int(bv) = (bv_to_int(tail(bv)) + (head(bv) * power(2, (
     length(bv) - 1))))) AND (bv_to_int(tail(bv)) = mod(bv_to_int(bv), 
     power(2, (length(bv) - 1)))))));

my_map: (ty, ty, uni, uni) -> uni;

% my_map_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(set(b), my_map(b, a, x, x1)))));

% my_map'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), u : set_int):
  (IF (cardinal(int, t2tb6(u)) = 0) THEN (tb2t71(my_map(angle1, int, 
  t2tb35(f), t2tb6(u))) = tb2t71(empty(angle1))) ELSE (tb2t71(my_map(angle1,
  int, t2tb35(f), t2tb6(u))) = tb2t71(add(angle1, t2tb33((f[tb2t5(choose(int, 
  t2tb6(u)))])), my_map(angle1, int, t2tb35(f), remove(int, choose(int, 
  t2tb6(u)), t2tb6(u)))))) ENDIF));

% my_map'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), u : set_int):
  (IF (cardinal(int, t2tb6(u)) = 0) THEN (tb2t6(my_map(int, int, t2tb7(f), 
  t2tb6(u))) = tb2t6(empty(int))) ELSE (tb2t6(my_map(int, int, t2tb7(f), 
  t2tb6(u))) = tb2t6(add(int, t2tb5((f[tb2t5(choose(int, t2tb6(u)))])), 
  my_map(int, int, t2tb7(f), remove(int, choose(int, t2tb6(u)), 
  t2tb6(u)))))) ENDIF));

% my_map'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, u : uni):
  (IF (cardinal(a, u) = 0) THEN (my_map(b, a, f, u) = empty(b)) ELSE (
  my_map(b, a, f, u) = add(b, infix_at(b, a, f, choose(a, u)), my_map(b, a,
  f, remove(a, choose(a, u), u)))) ENDIF)));

% my_map'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, u : uni): (my_map(b, a, f, u) = map(b, a, f, u))));

% my_map_to_map
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, u : uni): (my_map(b, a, f, u) = map(b, a, f, u))));

% map_to_my_map
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, u : uni): (map(b, a, f, u) = my_map(b, a, f, u))));

set_bitvec: TYPE;

mapz_pre: (INT, set_bitvec) -> set_bitvec;

result21: (ARRAY bitvec OF bitvec);

t2tb26: (bitvec) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : bitvec): (sort(bitvec1, t2tb26(x))));

tb2t26: (uni) -> bitvec;

% BridgeL
  ASSERT (FORALL (i : bitvec):PATTERN (t2tb26(i)):  (tb2t26(t2tb26(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb26(tb2t26(j))): 
  ((sort(bitvec1, j)) => (t2tb26(tb2t26(j)) = j)));

t2tb27: ((ARRAY bitvec OF bitvec)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF bitvec)): (sort(infix_mngt(bitvec1, bitvec1), 
  t2tb27(x))));

tb2t27: (uni) -> (ARRAY bitvec OF bitvec);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF bitvec)):PATTERN (t2tb27(i)):  (tb2t27(
  t2tb27(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb27(tb2t27(j))): 
  ((sort(infix_mngt(bitvec1, bitvec1), j)) => (t2tb27(tb2t27(j)) = j)));

% result'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(result21), 
  t2tb26(bv))) = concat_l(bv, 0)));

t2tb28: (set_bitvec) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : set_bitvec): (sort(set(bitvec1), t2tb28(x))));

tb2t28: (uni) -> set_bitvec;

% BridgeL
  ASSERT
  (FORALL (i : set_bitvec):PATTERN (t2tb28(i)):  (tb2t28(t2tb28(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb28(tb2t28(j))): 
  ((sort(set(bitvec1), j)) => (t2tb28(tb2t28(j)) = j)));

% mapz_pre'def
  ASSERT
  (FORALL (n : INT, s2 : set_bitvec):
  ((1 <= n)
  => ((FORALL (f : bitvec):
      ((mem(bitvec1, t2tb26(f), t2tb28(s2))) <=> (length(f) = (n - 1))))
     => (mapz_pre(n, s2) = tb2t28(my_map(bitvec1, bitvec1, t2tb27(result21), 
     t2tb28(s2)))))));

fc820: (ARRAY INT OF INT);

% fc'def
  ASSERT (FORALL (us : INT): ((fc820[us]) = 0));

% mapz_pre'spec
  ASSERT
  (FORALL (n : INT, s2 : set_bitvec):
  ((1 <= n)
  => ((FORALL (f : bitvec):
      ((mem(bitvec1, t2tb26(f), t2tb28(s2))) <=> (length(f) = (n - 1))))
     => ((mem(bitvec1, t2tb26(make_bv(fc820, n)), t2tb28(mapz_pre(n, s2))))
        AND ((FORALL (e : bitvec):
             ((mem(bitvec1, t2tb26(e), t2tb28(mapz_pre(n, s2)))) => ((
             value(e)[0]) = 0)))
            AND ((FORALL (e : bitvec):
                 ((mem(bitvec1, t2tb26(e), t2tb28(mapz_pre(n, s2))))
                 => (EXISTS (bv : bitvec):
                    ((mem(bitvec1, t2tb26(bv), t2tb28(s2))) AND (e = 
                    concat_l(bv, 0))))))
                AND ((FORALL (e : bitvec):
                     ((mem(bitvec1, t2tb26(e), t2tb28(mapz_pre(n, s2)))) => (
                     length(e) = n)))
                    AND (FORALL (e : bitvec):
                        ((length(e) = n)
                        => (((value(e)[0]) = 0) => (mem(bitvec1, t2tb26(e), 
                           t2tb28(mapz_pre(n, s2))))))))))))));

mapo_pre: (INT, set_bitvec) -> set_bitvec;

result22: (ARRAY bitvec OF bitvec);

% result'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(result22), 
  t2tb26(bv))) = concat_l(bv, 1)));

% mapo_pre'def
  ASSERT
  (FORALL (n : INT, s2 : set_bitvec):
  ((1 <= n)
  => ((FORALL (f : bitvec):
      ((mem(bitvec1, t2tb26(f), t2tb28(s2))) <=> (length(f) = (n - 1))))
     => (mapo_pre(n, s2) = tb2t28(my_map(bitvec1, bitvec1, t2tb27(result22), 
     t2tb28(s2)))))));

fc821: (ARRAY INT OF INT);

% fc'def
  ASSERT (FORALL (us : INT): ((fc821[us]) = 1));

% mapo_pre'spec
  ASSERT
  (FORALL (n : INT, s2 : set_bitvec):
  ((1 <= n)
  => ((FORALL (f : bitvec):
      ((mem(bitvec1, t2tb26(f), t2tb28(s2))) <=> (length(f) = (n - 1))))
     => ((mem(bitvec1, t2tb26(make_bv(fc821, n)), t2tb28(mapo_pre(n, s2))))
        AND ((FORALL (e : bitvec):
             ((mem(bitvec1, t2tb26(e), t2tb28(mapo_pre(n, s2)))) => ((
             value(e)[0]) = 1)))
            AND ((FORALL (e : bitvec):
                 ((mem(bitvec1, t2tb26(e), t2tb28(mapo_pre(n, s2))))
                 => (EXISTS (bv : bitvec):
                    ((mem(bitvec1, t2tb26(bv), t2tb28(s2))) AND (e = 
                    concat_l(bv, 1))))))
                AND ((FORALL (e : bitvec):
                     ((mem(bitvec1, t2tb26(e), t2tb28(mapo_pre(n, s2)))) => (
                     length(e) = n)))
                    AND (FORALL (e : bitvec):
                        ((length(e) = n)
                        => (((value(e)[0]) = 1) => (mem(bitvec1, t2tb26(e), 
                           t2tb28(mapo_pre(n, s2))))))))))))));

n_bvs: (INT) -> set_bitvec;

% n_bvs'spec
  ASSERT
  (FORALL (n : INT):
  ((0 <= n)
  => (((1 <= n)
      => (FORALL (s2 : set_bitvec):
         ((FORALL (f : bitvec):
          ((mem(bitvec1, t2tb26(f), t2tb28(s2))) <=> (length(f) = (n - 1))))
         => (n_bvs(n) = tb2t28(union(bitvec1, t2tb28(mapz_pre(n, s2)), 
         t2tb28(mapo_pre(n, s2))))))))
     AND ((FORALL (f : bitvec):
          ((mem(bitvec1, t2tb26(f), t2tb28(n_bvs(n)))) => (length(f) = n)))
         AND ((FORALL (f : bitvec):
              ((mem(bitvec1, t2tb26(f), t2tb28(n_bvs(n)))) <=> (
              length(f) = n)))
             AND (0 < cardinal(bitvec1, t2tb28(n_bvs(n)))))))));

% in_n_bvs
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((0 <= n)
  => ((length(x) = n) => (mem(bitvec1, t2tb26(x), t2tb28(n_bvs(n)))))));

% get_in_n_bvs
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((0 <= n)
  => ((mem(bitvec1, t2tb26(x), t2tb28(n_bvs(n)))) => (length(x) = n))));

mapz: (INT) -> set_bitvec;

% mapz'def
  ASSERT
  (FORALL (n : INT): ((1 <= n) => (mapz(n) = mapz_pre(n, n_bvs((n - 1))))));

fc822: (ARRAY bitvec OF bitvec);

% fc'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(fc822), 
  t2tb26(bv))) = concat_l(bv, 0)));

% mapz'spec
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => ((mapz(n) = tb2t28(my_map(bitvec1, bitvec1, t2tb27(fc822), t2tb28(
     n_bvs((n - 1))))))
     AND ((0 < cardinal(bitvec1, t2tb28(mapz(n))))
         AND ((FORALL (e : bitvec):
              ((mem(bitvec1, t2tb26(e), t2tb28(mapz(n)))) => ((
              value(e)[0]) = 0)))
             AND ((FORALL (e : bitvec):
                  ((mem(bitvec1, t2tb26(e), t2tb28(mapz(n))))
                  => (EXISTS (bv : bitvec):
                     ((mem(bitvec1, t2tb26(bv), t2tb28(n_bvs((n - 1)))))
                     AND (e = concat_l(bv, 0))))))
                 AND ((FORALL (e : bitvec):
                      ((mem(bitvec1, t2tb26(e), t2tb28(mapz(n)))) => (
                      length(e) = n)))
                     AND (FORALL (e : bitvec):
                         ((length(e) = n)
                         => (((value(e)[0]) = 0) => (mem(bitvec1, t2tb26(e), 
                            t2tb28(mapz(n))))))))))))));

mapo: (INT) -> set_bitvec;

% mapo'def
  ASSERT
  (FORALL (n : INT): ((1 <= n) => (mapo(n) = mapo_pre(n, n_bvs((n - 1))))));

fc823: (ARRAY bitvec OF bitvec);

% fc'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(fc823), 
  t2tb26(bv))) = concat_l(bv, 1)));

% mapo'spec
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => ((mapo(n) = tb2t28(my_map(bitvec1, bitvec1, t2tb27(fc823), t2tb28(
     n_bvs((n - 1))))))
     AND ((0 < cardinal(bitvec1, t2tb28(mapo(n))))
         AND ((FORALL (e : bitvec):
              ((mem(bitvec1, t2tb26(e), t2tb28(mapo(n)))) => ((
              value(e)[0]) = 1)))
             AND ((FORALL (e : bitvec):
                  ((mem(bitvec1, t2tb26(e), t2tb28(mapo(n))))
                  => (EXISTS (bv : bitvec):
                     ((mem(bitvec1, t2tb26(bv), t2tb28(n_bvs((n - 1)))))
                     AND (e = concat_l(bv, 1))))))
                 AND ((FORALL (e : bitvec):
                      ((mem(bitvec1, t2tb26(e), t2tb28(mapo(n)))) => (
                      length(e) = n)))
                     AND (FORALL (e : bitvec):
                         ((length(e) = n)
                         => (((value(e)[0]) = 1) => (mem(bitvec1, t2tb26(e), 
                            t2tb28(mapo(n))))))))))))));

% n_bvs_node
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => ((tb2t28(inter(bitvec1, t2tb28(mapz(n)), t2tb28(mapo(n)))) = tb2t28(
     empty(bitvec1))) AND (tb2t28(union(bitvec1, t2tb28(mapz(n)), t2tb28(
     mapo(n)))) = n_bvs(n)))));

fc824: (ARRAY INT OF INT);

fc825: (ARRAY INT OF INT);

fc826: (ARRAY INT OF INT);

fc827: (ARRAY INT OF INT);

% fc'def
  ASSERT (FORALL (us : INT): ((fc824[us]) = 0));

% fc'def
  ASSERT (FORALL (us : INT): ((fc825[us]) = 0));

% fc'def
  ASSERT (FORALL (us : INT): ((fc826[us]) = 0));

% fc'def
  ASSERT (FORALL (us : INT): ((fc827[us]) = 0));

t2tb29: ((ARRAY bitvec OF matrix_complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF matrix_complex)): (sort(infix_mngt(bitvec1, 
  matrix(complex1)), t2tb29(x))));

tb2t29: (uni) -> (ARRAY bitvec OF matrix_complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF matrix_complex)):PATTERN (t2tb29(i)):  (
  tb2t29(t2tb29(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb29(tb2t29(j))): 
  ((sort(infix_mngt(bitvec1, matrix(complex1)), j)) => (t2tb29(
  tb2t29(j)) = j)));

% n_bvsz'spec
  ASSERT
  ((FORALL (x : bitvec):
   ((length(x) = 0) => (mem(bitvec1, t2tb26(x), t2tb28(n_bvs(0))))))
  AND ((FORALL (x : bitvec):
       ((mem(bitvec1, t2tb26(x), t2tb28(n_bvs(0)))) => (x = make_bv(fc824,
       0))))
      AND ((n_bvs(0) = tb2t28(add(bitvec1, t2tb26(make_bv(fc825, 0)), 
          empty(bitvec1))))
          AND ((tb2t26(choose(bitvec1, t2tb28(n_bvs(0)))) = make_bv(fc826,
              0))
              AND (FORALL (f : (ARRAY bitvec OF matrix_complex)): (
                  mat_sum(bitvec1, t2tb28(n_bvs(0)), t2tb29(f)) = tb2t18(
                  infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(
                  make_bv(fc827, 0))))))))));

fc828: (ARRAY INT OF INT);

fc829: (ARRAY INT OF INT);

fc830: (ARRAY INT OF INT);

fc831: (ARRAY INT OF INT);

% fc'def
  ASSERT (FORALL (us : INT): ((fc828[us]) = 0));

% fc'def
  ASSERT (FORALL (us : INT): ((fc829[us]) = 1));

% fc'def
  ASSERT (FORALL (us : INT): ((fc830[us]) = 0));

% fc'def
  ASSERT (FORALL (us : INT): ((fc831[us]) = 1));

% n_bvso'spec
  ASSERT
  ((FORALL (x : bitvec):
   ((length(x) = 1) => (mem(bitvec1, t2tb26(x), t2tb28(n_bvs(1))))))
  AND ((FORALL (x : bitvec):
       ((mem(bitvec1, t2tb26(x), t2tb28(n_bvs(1)))) => (length(x) = 1)))
      AND ((n_bvs(1) = tb2t28(add(bitvec1, t2tb26(make_bv(fc828, 1)), 
          add(bitvec1, t2tb26(make_bv(fc829, 1)), empty(bitvec1)))))
          AND (FORALL (f : (ARRAY bitvec OF matrix_complex)):
              ((constant_size(bitvec1, t2tb28(n_bvs(1)), t2tb29(f))) => (
              mat_sum(bitvec1, t2tb28(n_bvs(1)), t2tb29(f)) = add_mat(tb2t18(
              infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(
              make_bv(fc830, 1)))), tb2t18(infix_at(matrix(complex1),
              bitvec1, t2tb29(f), t2tb26(make_bv(fc831, 1)))))))))));

fc227: (ARRAY bitvec OF bitvec);

fc228: (ARRAY bitvec OF bitvec);

% fc'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(fc227), 
  t2tb26(bv))) = concat_l(bv, 0)));

% fc'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(fc228), 
  t2tb26(bv))) = concat_l(bv, 1)));

% injective_node
  ASSERT
  (FORALL (n : INT):
  ((0 <= n)
  => ((p_injective(bitvec1, bitvec1, t2tb27(fc227), t2tb28(n_bvs(n))))
     AND (p_injective(bitvec1, bitvec1, t2tb27(fc228), t2tb28(n_bvs(n)))))));

fc229: ((ARRAY bitvec OF matrix_complex)) -> (ARRAY bitvec OF matrix_complex);

fc230: ((ARRAY bitvec OF matrix_complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), bv : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc229(f)), t2tb26(bv))) = 
  tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(concat_l(bv,
  0))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), bv : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc230(f)), t2tb26(bv))) = 
  tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(concat_l(bv,
  1))))));

% mat_sum_n_bvs_pos
  ASSERT
  (FORALL (n : INT, f : (ARRAY bitvec OF matrix_complex)):
  ((0 < n)
  => ((constant_size(bitvec1, t2tb28(n_bvs(n)), t2tb29(f))) => (
     mat_sum(bitvec1, t2tb28(n_bvs(n)), t2tb29(f)) = add_mat(mat_sum(bitvec1, 
     t2tb28(n_bvs((n - 1))), t2tb29(fc229(f))), mat_sum(bitvec1, t2tb28(
     n_bvs((n - 1))), t2tb29(fc230(f))))))));

fc832: (ARRAY INT OF (ARRAY INT OF INT));

% fc'def
  ASSERT
  (FORALL (y0 : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(fc832), t2tb5(y0)))[y1]) = y0));

% mat_sum_n_bvs_null
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex)): (mat_sum(bitvec1, t2tb28(
  n_bvs(0)), t2tb29(f)) = tb2t18(infix_at(matrix(complex1), bitvec1, 
  t2tb29(f), t2tb26(make_bv(tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(fc832), t2tb5(0))), 0))))));

fc833: (ARRAY INT OF (ARRAY INT OF INT));

% fc'def
  ASSERT
  (FORALL (y0 : INT, y1 : INT): ((tb2t7(infix_at(infix_mngt(int, int), int, 
  t2tb8(fc833), t2tb5(y0)))[y1]) = y0));

% mat_sum_n_bvs_null_eq
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), x : matrix_complex):
  ((x = tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(make_bv(
  tb2t7(infix_at(infix_mngt(int, int), int, t2tb8(fc833), t2tb5(0))), 0)))))
  => (mat_sum(bitvec1, t2tb28(n_bvs(0)), t2tb29(f)) = x)));

% get_n_bvs
  ASSERT
  (FORALL (bv : bitvec): (mem(bitvec1, t2tb26(bv), t2tb28(n_bvs(
  length(bv))))));

% get_n_bvs_gen
  ASSERT
  (FORALL (bv : bitvec, l : INT):
  ((l = length(bv)) => (mem(bitvec1, t2tb26(bv), t2tb28(n_bvs(l))))));

% set_n_bvs
  ASSERT
  (FORALL (bv : bitvec):
  ((mem(bitvec1, t2tb26(bv), t2tb28(n_bvs(length(bv)))))
  => (FORALL (i : INT):
     ((NOT ((0 <= i) AND (i < length(bv)))) => ((value(bv)[i]) = 0)))));

% int_to_bv_n_bvs
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (mem(bitvec1, t2tb26(int_to_bv(i,
     n)), t2tb28(n_bvs(n)))))));

fc233: (ARRAY bitvec OF bitvec);

fc234: (ARRAY bitvec OF bitvec);

% fc'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(fc233), 
  t2tb26(bv))) = concat_l(bv, 0)));

% fc'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(fc234), 
  t2tb26(bv))) = concat_l(bv, 1)));

% n_bvs_def_pos
  ASSERT
  (FORALL (n : INT):
  ((0 < n) => (n_bvs(n) = tb2t28(union(bitvec1, map(bitvec1, bitvec1, 
  t2tb27(fc233), t2tb28(n_bvs((n - 1)))), map(bitvec1, bitvec1, 
  t2tb27(fc234), t2tb28(n_bvs((n - 1)))))))));

bv_to_int_closure: (ARRAY bitvec OF INT);

t2tb30: ((ARRAY bitvec OF INT)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF INT)): (sort(infix_mngt(bitvec1, int), 
  t2tb30(x))));

tb2t30: (uni) -> (ARRAY bitvec OF INT);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF INT)):PATTERN (t2tb30(i)):  (tb2t30(
  t2tb30(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb30(tb2t30(j))):  (t2tb30(tb2t30(j)) = j));

% bv_to_int_closure_def
  ASSERT
  (FORALL (y : bitvec): (tb2t5(infix_at(int, bitvec1, 
  t2tb30(bv_to_int_closure), t2tb26(y))) = bv_to_int(y)));

% map_n_bvs
  ASSERT
  (FORALL (n : INT):
  ((0 < n) => (to_fset(0, power(2, n)) = tb2t6(map(int, bitvec1, 
  t2tb30(bv_to_int_closure), t2tb28(n_bvs(n)))))));

fc235: ((ARRAY INT OF complex)) -> (ARRAY bitvec OF complex);

t2tb31: ((ARRAY bitvec OF complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF complex)): (sort(infix_mngt(bitvec1,
  complex1), t2tb31(x))));

tb2t31: (uni) -> (ARRAY bitvec OF complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF complex)):PATTERN (t2tb31(i)):  (tb2t31(
  t2tb31(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb31(tb2t31(j))): 
  ((sort(infix_mngt(bitvec1, complex1), j)) => (t2tb31(tb2t31(j)) = j)));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), k : bitvec): (tb2t(infix_at(complex1,
  bitvec1, t2tb31(fc235(f)), t2tb26(k))) = tb2t(infix_at(complex1, int, 
  t2tb12(f), t2tb5(bv_to_int(k))))));

% ind_sum_bv
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), n : INT):
  ((1 <= n) => (ind_sum(f, 0, power(2, n)) = sum(bitvec1, t2tb28(n_bvs(n)), 
  t2tb31(fc235(f))))));

first_div: (bitvec, bitvec) -> INT;

% first_div'spec
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((length(bv1) = length(bv2))
  => ((NOT (bv1 = bv2))
     => ((FORALL (j : INT):
         (((0 <= j) AND (j < first_div(bv1, bv2))) => ((value(bv1)[j]) = (
         value(bv2)[j]))))
        AND (((first_div(bv1, bv2) < length(bv1))
             => (NOT ((value(bv1)[first_div(bv1, bv2)]) = (value(bv2)[
                first_div(bv1, bv2)]))))
            AND ((0 <= first_div(bv1, bv2)) AND (first_div(bv1, bv2) < 
                length(bv1))))))));

fc236: (INT) -> (ARRAY bitvec OF bitvec);

% fc'def
  ASSERT
  (FORALL (i : INT, bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(
  fc236(i)), t2tb26(bv))) = concat_l(bv, i)));

% injective_concat
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i <= 1)) => (p_injective(bitvec1, bitvec1, t2tb27(
     fc236(i)), t2tb28(n_bvs(n)))))));

% inf_first_div
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((length(bv1) = length(bv2))
  => ((NOT (bv1 = bv2))
     => (FORALL (j : INT):
        ((1 <= j)
        => ((NOT ((value(bv1)[j]) = (value(bv2)[j]))) => (first_div(bv1,
           bv2) <= j)))))));

% first_div_diff
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((length(bv1) = length(bv2))
  => ((NOT (bv1 = bv2))
     => (NOT ((value(bv1)[first_div(bv1, bv2)]) = (value(bv2)[first_div(bv1,
        bv2)]))))));

% exists_first_div
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((length(bv1) = length(bv2))
  => ((NOT (bv1 = bv2))
     => (EXISTS (i : INT):
        (((0 <= i) AND (i < length(bv1))) AND (i = first_div(bv1, bv2)))))));

% set_diff_length
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((NOT (length(bv1) = length(bv2))) => (NOT (bv1 = bv2))));

% set_diff_val
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, i : INT):
  ((length(bv1) = length(bv2))
  => (((0 <= i) AND (i < length(bv1)))
     => ((NOT ((value(bv1)[i]) = (value(bv2)[i]))) => (NOT (bv1 = bv2))))));

fc834: (bitvec) -> (ARRAY INT OF INT);

fc835: (bitvec) -> (ARRAY INT OF INT);

fc836: (bitvec) -> (ARRAY INT OF INT);

fc837: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((
  fc834(bv)[l]) = (IF (l < length(bv)) THEN ((value(bv)[l]) * power(2, ((
                  length(bv) - 1) - l))) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((
  fc835(bv)[l]) = (IF (l < length(bv)) THEN ((value(bv)[l]) * power(2, ((
                  length(bv) - 1) - l))) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc836(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc837(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% kth_decomp
  ASSERT
  (FORALL (bv : bitvec, k : INT):
  (((0 <= k) AND (k < length(bv)))
  => ((bv_to_int(bv) = ((ind_isum(fc834(bv), 0, k) + ((value(bv)[k]) * 
     power(2, ((length(bv) - 1) - k)))) + ind_isum(fc835(bv), (k + 1), 
     length(bv)))) AND (bv_to_int(bv) = ((ind_isum(fc836(bv), 0, k) + ((
     value(bv)[k]) * power(2, ((length(bv) - 1) - k)))) + ind_isum(fc837(bv),
     (k + 1), length(bv)))))));

fc838: (INT, INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (i : INT, j : INT, n : INT, k : INT): (tb2t(infix_at(complex1, int, 
  t2tb12(fc838(i, j, n)), t2tb5(k))) = indic(int, t2tb5((value(int_to_bv(i,
  n))[k])), t2tb5((value(int_to_bv(j, n))[k])))));

% int_to_bv_prod
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < power(2, n))) => (ind_product(fc838(i, j, n), 0,
        n) = indic(int, t2tb5(i), t2tb5(j)))))));

fc839: (INT, INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, j : INT, k : INT): (tb2t(infix_at(complex1, int, 
  t2tb12(fc839(i, n, j)), t2tb5(k))) = indic(int, t2tb5((value(int_to_bv(i,
  n))[k])), t2tb5((value(int_to_bv(j, n))[k])))));

% int_to_bv_prod_gen
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => (FORALL (j : INT):
        (((0 <= j) AND (j < power(2, n))) => (ind_product(fc839(i, n, j), 0,
        n) = indic(int, t2tb5(i), t2tb5(j))))))));

fc840: (bitvec) -> (ARRAY INT OF INT);

fc841: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc840(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc841(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% kth_decomp_bound_zero
  ASSERT
  (FORALL (bv : bitvec, k : INT):
  (((0 <= k) AND (k < length(bv)))
  => (((value(bv)[k]) = 0)
     => ((ind_isum(fc840(bv), 0, k) <= bv_to_int(bv)) AND (bv_to_int(bv) < (
        ind_isum(fc841(bv), 0, k) + power(2, ((length(bv) - k) - 1))))))));

fc842: (bitvec) -> (ARRAY INT OF INT);

fc843: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc842(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - 1) - l)))));

% fc'def
  ASSERT
  (FORALL (bv : bitvec, l : INT): ((fc843(bv)[l]) = ((value(bv)[l]) * 
  power(2, ((length(bv) - l) - 1)))));

% kth_decomp_bound_one
  ASSERT
  (FORALL (bv : bitvec, k : INT):
  (((0 <= k) AND (k < length(bv)))
  => (((value(bv)[k]) = 1)
     => (((ind_isum(fc842(bv), 0, k) + power(2, ((length(bv) - k) - 1))) <= 
        bv_to_int(bv)) AND (bv_to_int(bv) < (ind_isum(fc843(bv), 0, k) + 
        power(2, (length(bv) - k))))))));

% bv_to_int_length_2
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 2)
  => (((value(x)[0]) = div(bv_to_int(x), 2)) AND ((value(x)[1]) = mod(
     bv_to_int(x), 2)))));

% bv_to_int_length_2_gen
  ASSERT
  ((FORALL (x : bitvec):
   ((length(x) = 2) => ((value(x)[0]) = div(bv_to_int(x), 2))))
  AND (FORALL (x : bitvec):
      ((length(x) = 2) => ((value(x)[1]) = mod(bv_to_int(x), 2)))));

bv_inversion: (bitvec) -> bitvec;

result103: (bitvec) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((result103(bv)[k]) = (value(bv)[((
  length(bv) - k) - 1)])));

% bv_inversion'def
  ASSERT
  (FORALL (bv : bitvec): (bv_inversion(bv) = make_bv(result103(bv), 
  length(bv))));

% bv_inversion'spec
  ASSERT
  (FORALL (bv : bitvec):
  ((length(bv_inversion(bv)) = length(bv))
  AND (FORALL (k : INT):
      ((in_range(bv_inversion(bv), k)) => ((value(bv_inversion(bv))[k]) = (
      value(bv)[((length(bv) - k) - 1)]))))));

% bv_inversion_value
  ASSERT
  (FORALL (bv : bitvec, i : INT): ((value(bv_inversion(bv))[i]) = (
  value(bv)[((length(bv) - i) - 1)])));

% bv_inversion_invol
  ASSERT (FORALL (bv : bitvec): (bv_inversion(bv_inversion(bv)) = bv));

int_bit_inversion: (INT, INT) -> INT;

% int_bit_inversion'def
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (int_bit_inversion(i, n) = 
     bv_to_int(bv_inversion(int_to_bv(i, n)))))));

% int_bit_inversion'spec
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => ((0 <= int_bit_inversion(i, n)) AND (int_bit_inversion(i, n) < 
        power(2, n))))));

int_bit_inversion_ext: (INT, INT) -> INT;

% int_bit_inversion_ext'def
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i <= power(2, n)))
     => (IF (i = power(2, n)) THEN (int_bit_inversion_ext(i, n) = i) ELSE (
        int_bit_inversion_ext(i, n) = bv_to_int(bv_inversion(int_to_bv(i,
        n)))) ENDIF))));

% int_bit_inversion_ext'spec
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i <= power(2, n)))
     => (((0 <= int_bit_inversion_ext(i, n)) AND (int_bit_inversion_ext(i,
         n) <= power(2, n)))
        AND ((i = power(2, n)) => (int_bit_inversion_ext(i, n) = power(2,
            n)))))));

% int_bit_inversion_invol
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (int_bit_inversion(
     int_bit_inversion(i, n), n) = i))));

% int_bit_inversion_inj
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < power(2, n)))
        => ((NOT (i = j))
           => (NOT (int_bit_inversion(i, n) = int_bit_inversion(j, n))))))));

% int_bit_inversion_ext_invol
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i <= power(2, n))) => (int_bit_inversion_ext(
     int_bit_inversion_ext(i, n), n) = i))));

% int_bit_inversion_onebit
  ASSERT
  (FORALL (i : INT):
  (((0 <= i) AND (i < 2)) => (int_bit_inversion(i, 1) = i)));

% int_bit_inversion_zero
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n) => ((0 = i) => (int_bit_inversion(i, n) = 0))));

fc844: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc844(bv)[k]) = ((value(bv)[((
  length(bv) - k) - 1)]) * power(2, ((length(bv) - 1) - k)))));

% bv_to_int_sum_inversion
  ASSERT
  (FORALL (bv : bitvec):
  ((0 < length(bv)) => (int_bit_inversion(bv_to_int(bv), length(bv)) = 
  ind_isum(fc844(bv), 0, length(bv)))));

fc845: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc845(bv)[k]) = ((value(bv)[k]) * 
  power(2, k))));

% bv_to_int_sum_inversion_inc
  ASSERT
  (FORALL (bv : bitvec):
  ((0 < length(bv)) => (int_bit_inversion(bv_to_int(bv), length(bv)) = 
  ind_isum(fc845(bv), 0, length(bv)))));

% inversion_to_int_comm
  ASSERT
  (FORALL (bv : bitvec):
  ((0 < length(bv)) => (int_to_bv(int_bit_inversion(bv_to_int(bv), 
  length(bv)), length(bv)) = bv_inversion(bv))));

fc846: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc846(i, n)[k]) = ((value(
  int_to_bv(i, n))[((n - k) - 1)]) * power(2, ((n - 1) - k)))));

% bv_inversion_sum
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (int_bit_inversion(i, n) = 
     ind_isum(fc846(i, n), 0, n)))));

fc847: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc847(bv)[k]) = ((value(bv)[((
  length(bv) - k) - 1)]) * power(2, ((length(bv) - 1) - k)))));

% bv_to_int_inversion_sum
  ASSERT
  (FORALL (bv : bitvec): (bv_to_int(bv_inversion(bv)) = ind_isum(fc847(bv),
  0, length(bv))));

% bv_to_int_bit_inversion
  ASSERT
  (FORALL (bv : bitvec):
  ((0 < length(bv)) => (bv_to_int(bv_inversion(bv)) = int_bit_inversion(
  bv_to_int(bv), length(bv)))));

fc848: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : bitvec, k : INT): ((fc848(bv)[k]) = ((value(bv)[k]) * 
  power(2, k))));

% bv_to_int_inversion_sum_inc
  ASSERT
  (FORALL (bv : bitvec):
  ((0 < length(bv)) => (bv_to_int(bv_inversion(bv)) = ind_isum(fc848(bv), 0, 
  length(bv)))));

% bv_m_to_int_bit_inversion
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((0 < n) => (bv_to_int(bv_inversion(make_bv_m(f, n))) = int_bit_inversion(
  bv_to_int(make_bv_m(f, n)), n))));

fc849: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, k : INT): ((fc849(i, n)[k]) = ((value(
  int_to_bv(i, n))[(n - k)]) * power(2, ((n - k) - 1)))));

% int_bit_inversion_tail_bits
  ASSERT
  (FORALL (i : INT, n : INT):
  ((1 < n)
  => (((0 <= i) AND (i < power(2, n))) => (int_bit_inversion(tail_bits(i, n),
     (n - 1)) = ind_isum(fc849(i, n), 1, n)))));

fc253: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (bv : (ARRAY INT OF INT), n : INT, k : INT): ((fc253(bv, n)[k]) = (
  mod((bv[((n - 1) - k)]), 2) * power(2, ((n - k) - 1)))));

% tail_bits_int_bit_inversion
  ASSERT
  (FORALL (bv : (ARRAY INT OF INT), n : INT):
  ((1 < n) => (tail_bits(int_bit_inversion(bv_to_int(make_bv_m(bv, n)), n),
  n) = ind_isum(fc253(bv, n), 1, n))));

% int_bit_inversion_ht
  ASSERT
  (FORALL (i : INT, n : INT):
  ((1 < n)
  => (((0 <= i) AND (i < power(2, n))) => (int_bit_inversion(i, n) = ((2 * 
     int_bit_inversion(tail_bits(i, n), (n - 1))) + head_bit(i, n))))));

% bv_inversion_ht
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((1 < n) => (bv_to_int(bv_inversion(make_bv_m(f, n))) = (head(make_bv_m(f,
  n)) + (2 * bv_to_int(bv_inversion(tail(make_bv_m(f, n)))))))));

% bv_inversion_ht_bv
  ASSERT
  (FORALL (bv : bitvec):
  ((1 < length(bv)) => (bv_to_int(bv_inversion(bv)) = (head(bv) + (2 * 
  bv_to_int(bv_inversion(tail(bv))))))));

% bv_to_int_ht
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((1 < n) => (bv_to_int(make_bv_m(f, n)) = ((power(2, (n - 1)) * head(
  make_bv_m(f, n))) + bv_to_int(tail(make_bv_m(f, n)))))));

% bv_inversion_mult_ht
  ASSERT
  (FORALL (fx : (ARRAY INT OF INT), fy : (ARRAY INT OF INT), n : INT):
  ((1 < n) => ((bv_to_int(make_bv_m(fx, n)) * bv_to_int(bv_inversion(
  make_bv_m(fy, n)))) = (((head(make_bv_m(fy, n)) * bv_to_int(make_bv_m(fx,
  n))) + (bv_to_int(tail(make_bv_m(fx, n))) * (2 * bv_to_int(bv_inversion(
  tail(make_bv_m(fy, n))))))) + (power(2, n) * (head(make_bv_m(fx, n)) * 
  bv_to_int(bv_inversion(tail(make_bv_m(fy, n))))))))));

% bv_inversion_mult_ht_bv
  ASSERT
  (FORALL (bvx : bitvec, bvy : bitvec):
  ((1 < length(bvx))
  => ((length(bvx) = length(bvy)) => ((bv_to_int(bvx) * bv_to_int(
     bv_inversion(bvy))) = (((head(bvy) * bv_to_int(bvx)) + (bv_to_int(
     tail(bvx)) * (2 * bv_to_int(bv_inversion(tail(bvy)))))) + (power(2, 
     length(bvx)) * (head(bvx) * bv_to_int(bv_inversion(tail(bvy))))))))));

ang_sum: ((ARRAY INT OF angle), INT, INT) -> angle;

ang_add_closure: (ARRAY angle OF (ARRAY angle OF angle));

% ang_add_closure_def
  ASSERT
  (FORALL (y : angle, y1 : angle): (tb2t33(infix_at(angle1, angle1, infix_at(
  infix_mngt(angle1, angle1), angle1, t2tb34(ang_add_closure), t2tb33(y)), 
  t2tb33(y1))) = ang_add(y, y1)));

% ang_sum'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  (IF (j <= i) THEN (ang_sum(f, i, j) = ang_zero) ELSE (ang_sum(f, i, j) = 
  tb2t33(int_iterate(angle1, t2tb34(ang_add_closure), t2tb35(f), i,
  j))) ENDIF));

% ang_sumto_int_iterate
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  ((i < j) => (ang_sum(f, i, j) = tb2t33(int_iterate(angle1, 
  t2tb34(ang_add_closure), t2tb35(f), i, j)))));

% ang_sum_plus_one
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  (((i + 1) < j) => (ang_sum(f, i, j) = ang_add((f[i]), ang_sum(f, (i + 1),
  j)))));

% ang_sum_cardone
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  ((j = (i + 1)) => (ang_sum(f, i, j) = (f[i]))));

% ang_sum_cardone_p
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT, r : angle):
  ((j = (i + 1)) => (((f[i]) = r) => (r = ang_sum(f, i, j)))));

% ang_sum_neutral
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  ((i <= j)
  => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = ang_zero)))
     => (ang_sum(f, i, j) = ang_zero))));

% ang_sum_def_plus_one_com
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  (((i + 1) < j) => (ang_add((f[i]), ang_sum(f, (i + 1), j)) = ang_sum(f, i,
  j))));

% ang_sum_right_extension
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  (((i + 1) < j) => (ang_sum(f, i, j) = ang_add(ang_sum(f, i, (j - 1)),
  (f[(j - 1)])))));

% ang_sum_re
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  (((i + 1) <= j) => (ang_sum(f, i, j) = ang_add(ang_sum(f, i, (j - 1)),
  (f[(j - 1)])))));

% ang_sum_transitivity
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, k : INT, j : INT):
  (((i < k) AND (k < j)) => (ang_sum(f, i, j) = ang_add(ang_sum(f, i, k), 
  ang_sum(f, k, j)))));

% ang_sum_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT):
  ((i <= j)
  => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k])))) => (
     ang_sum(f, i, j) = ang_sum(g, i, j)))));

% ang_sum_int_to_ang
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT):
  ((i < j)
  => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k]))))
     => ((EXISTS (n : INT):
         (FORALL (k : INT):
         (EXISTS (j1 : INT, jqt : INT):
         (((f[k]) = infix_sldtsl(j1, n))
         AND (((g[k]) = infix_sldtsl(jqt, n)) AND (j1 = jqt))))))
        => (ang_sum(f, i, j) = ang_sum(g, i, j))))));

% vang_sum_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT):
  ((i < j)
  => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k])))) => (
     ang_exp(ang_sum(f, i, j)) = ang_exp(ang_sum(g, i, j))))));

% vang_sum_scal_eq
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle),
  m : matrix_complex, n : matrix_complex, i : INT, j : INT):
  ((i < j)
  => ((m = n)
     => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k]))))
        => (infix_asdtdt(ang_exp(ang_sum(f, i, j)), m) = infix_asdtdt(
        ang_exp(ang_sum(g, i, j)), n))))));

fc254: ((ARRAY INT OF angle)) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), k : INT): ((fc254(f)[k]) = 
  ang_inv((f[k]))));

% ang_sum_inv
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT): (ang_inv(ang_sum(f,
  i, j)) = ang_sum(fc254(f), i, j)));

% ang_sum_plus_one_p
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT, l : INT, m : INT, r : angle):
  (((i + 1) < j)
  => ((l = (i + 1))
     => ((m = j)
        => (((g[i]) = r)
           => ((FORALL (k : INT):
               ((((i + 1) <= k) AND (k < j)) => ((f[k]) = (g[k]))))
              => (ang_add(r, ang_sum(f, l, m)) = ang_sum(g, i, j))))))));

% vang_sum_plus_one_p
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT, l : INT, m : INT, r : angle):
  (((i + 1) < j)
  => ((l = (i + 1))
     => ((m = j)
        => (((g[i]) = r)
           => ((FORALL (k : INT):
               ((((i + 1) <= k) AND (k < j)) => ((f[k]) = (g[k]))))
              => (infix_asdt(ang_exp(r), ang_exp(ang_sum(f, l, m))) = 
              ang_exp(ang_sum(g, i, j)))))))));

% vang_sum_plus_one_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT, l : INT, m : INT, r : angle):
  (((i + 1) < j)
  => ((l = (i + 1))
     => ((m = j)
        => (((g[i]) = r)
           => ((FORALL (k : INT):
               ((((i + 1) <= k) AND (k < j)) => ((f[k]) = (g[k]))))
              => (ang_exp(ang_sum(g, i, j)) = infix_asdt(ang_exp(r), ang_exp(
              ang_sum(f, l, m))))))))));

% ang_sum_right_extension_p
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT, l : INT, m : INT, r : angle):
  (((i + 1) < j)
  => ((m = (j - 1))
     => ((l = i)
        => (((g[(j - 1)]) = r)
           => ((FORALL (k : INT):
               (((i <= k) AND (k < (j - 1))) => ((f[k]) = (g[k]))))
              => (ang_add(ang_sum(f, l, m), r) = ang_sum(g, i, j))))))));

% vang_sum_right_extension_p
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT, l : INT, m : INT, r : angle):
  (((i + 1) < j)
  => ((m = (j - 1))
     => ((l = i)
        => (((g[(j - 1)]) = r)
           => ((FORALL (k : INT):
               (((i <= k) AND (k < (j - 1))) => ((f[k]) = (g[k]))))
              => (infix_asdt(ang_exp(ang_sum(f, l, m)), ang_exp(r)) = 
              ang_exp(ang_sum(g, i, j)))))))));

% vang_sum_right_extension_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT, l : INT, m : INT, r : angle):
  (((i + 1) < j)
  => ((m = (j - 1))
     => ((l = i)
        => (((g[(j - 1)]) = r)
           => ((FORALL (k : INT):
               (((i <= k) AND (k < (j - 1))) => ((f[k]) = (g[k]))))
              => (ang_exp(ang_sum(g, i, j)) = infix_asdt(ang_exp(ang_sum(f,
              l, m)), ang_exp(r)))))))));

% ang_sum_cardzero
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  ((j <= i) => (ang_sum(f, i, j) = ang_zero)));

% ang_sum_eq_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT, iqt : INT, jqt : INT):
  ((i < j)
  => ((i = iqt)
     => ((j = jqt)
        => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k]))))
           => (ang_sum(f, i, j) = ang_sum(g, iqt, jqt)))))));

fc255: ((ARRAY INT OF (ARRAY INT OF angle)), INT) -> (ARRAY INT OF angle);

fc256: ((ARRAY INT OF (ARRAY INT OF angle)), INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)), l : INT, x : INT): ((
  fc255(f, l)[x]) = ang_sum(tb2t35(infix_at(infix_mngt(int, angle1), int, 
  t2tb36(f), t2tb5(x))), x, l)));

% fc'def
  ASSERT
  (FORALL (g : (ARRAY INT OF (ARRAY INT OF angle)), lqt : INT, x : INT): ((
  fc256(g, lqt)[x]) = ang_sum(tb2t35(infix_at(infix_mngt(int, angle1), int, 
  t2tb36(g), t2tb5(x))), x, lqt)));

% ang_sum_sum_eq_vl
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)),
  g : (ARRAY INT OF (ARRAY INT OF angle)), i : INT, j : INT, iqt : INT,
  jqt : INT, l : INT, lqt : INT):
  ((i < j)
  => ((j <= l)
     => ((i = iqt)
        => ((j = jqt)
           => ((l = lqt)
              => ((FORALL (x : INT, xqt : INT):
                  (((i <= x) AND (x < j))
                  => (((x <= xqt) AND (xqt < l)) => ((tb2t35(infix_at(
                     infix_mngt(int, angle1), int, t2tb36(f), 
                     t2tb5(x)))[xqt]) = (tb2t35(infix_at(infix_mngt(int,
                     angle1), int, t2tb36(g), t2tb5(x)))[xqt])))))
                 => (ang_sum(fc255(f, l), i, j) = ang_sum(fc256(g, lqt), iqt,
                 jqt)))))))));

fc850: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, k : INT): ((fc850(f, n)[k]) = 
  infix_sldtsl((- (f[k])), n)));

% ang_sum_minus
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT, j : INT, n : INT):
  ((0 <= n)
  => ((i < j) => (ang_sum(fc850(f, n), i, j) = infix_sldtsl((- ind_isum(f, i,
     j)), n)))));

% multiple_control_as_ang_sum
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     ((length(x) = n)
     => ((IF (FORALL (j : INT):
             (((0 <= j) AND (j < n)) => ((value(x)[j]) = 1)))
         THEN infix_sldtsl(1, 1) ELSE ang_zero ENDIF) = 
     ang_mult_int(infix_sldtsl(1, 1), ind_iproduct(value(x), 0, n)))))));

% multiple_control_as_ang_sum_rev
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     ((length(x) = n) => (ang_mult_int(infix_sldtsl(1, 1), ind_iproduct(
     value(x), 0,
     n)) = (IF (FORALL (j : INT):
               (((0 <= j) AND (j < n)) => ((value(x)[j]) = 1)))
           THEN infix_sldtsl(1, 1) ELSE ang_zero ENDIF))))));

fc258: ((ARRAY INT OF INT), (ARRAY INT OF angle)) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), t1 : (ARRAY INT OF angle), b : INT): ((
  fc258(f, t1)[b]) = (t1[(f[b])])));

% ang_sum_map
  ASSERT
  (FORALL (i : INT, j : INT, k : INT, l : INT, f : (ARRAY INT OF INT),
  t1 : (ARRAY INT OF angle)):
  ((i < j)
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(i, j)), t2tb6(to_fset(k,
     l)))) => (ang_sum(t1, k, l) = ang_sum(fc258(f, t1), i, j)))));

% ang_sum_break
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT, y : INT):
  (((i <= y) AND (y <= j)) => (ang_sum(f, i, j) = ang_add(ang_sum(f, i, y), 
  ang_sum(f, y, j)))));

% ang_sum_break_zero_l
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT, y : INT):
  (((i <= y) AND (y <= j))
  => ((FORALL (k : INT): (((i <= k) AND (k < y)) => ((f[k]) = ang_zero)))
     => (ang_sum(f, y, j) = ang_sum(f, i, j)))));

% ang_sum_break_zero_lg
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY INT OF angle), i : INT,
  j : INT, y : INT):
  (((i <= y) AND (y <= j))
  => ((FORALL (k : INT): (((i <= k) AND (k < y)) => ((f[k]) = ang_zero)))
     => ((FORALL (k : INT): (((i <= k) AND (k < j)) => ((f[k]) = (g[k]))))
        => (ang_sum(f, y, j) = ang_sum(g, i, j))))));

t2tb37: ((ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle)))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle)))): (sort(
  infix_mngt(bitvec1, infix_mngt(int, infix_mngt(int, angle1))), t2tb37(x))));

tb2t37: (uni) -> (ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle)));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle)))):PATTERN (
  t2tb37(i)):  (tb2t37(t2tb37(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb37(tb2t37(j))): 
  ((sort(infix_mngt(bitvec1, infix_mngt(int, infix_mngt(int, angle1))), j))
  => (t2tb37(tb2t37(j)) = j)));

t2tb38: ((ARRAY bitvec OF (ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle))))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY bitvec OF (ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle))))):
  (sort(infix_mngt(bitvec1, infix_mngt(bitvec1, infix_mngt(int, 
  infix_mngt(int, angle1)))), t2tb38(x))));

tb2t38: (uni) -> (ARRAY bitvec OF (ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle))));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY bitvec OF (ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle))))):PATTERN (
  t2tb38(i)):  (tb2t38(t2tb38(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb38(tb2t38(j))): 
  ((sort(infix_mngt(bitvec1, infix_mngt(bitvec1, infix_mngt(int, 
  infix_mngt(int, angle1)))), j)) => (t2tb38(tb2t38(j)) = j)));

% ang_sum_break_zero_lg_params
  ASSERT
  (FORALL
  (f : (ARRAY bitvec OF (ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle)))),
  g : (ARRAY bitvec OF (ARRAY bitvec OF (ARRAY INT OF (ARRAY INT OF angle)))),
  i : INT, j : INT, s2 : INT, r : INT):
  ((0 <= s2)
  => ((0 <= r)
     => ((FORALL (x : bitvec, z : bitvec):
         (FORALL (a : INT, k : INT):
         ((length(x) = s2)
         => ((length(z) = r)
            => (((i <= a) AND (a < j))
               => (((i <= k) AND (k < a)) => ((tb2t35(infix_at(
                  infix_mngt(int, angle1), int, infix_at(infix_mngt(int, 
                  infix_mngt(int, angle1)), bitvec1, infix_at(
                  infix_mngt(bitvec1, infix_mngt(int, infix_mngt(int,
                  angle1))), bitvec1, t2tb38(g), t2tb26(x)), t2tb26(z)), 
                  t2tb5(a)))[k]) = ang_zero)))))))
        => ((FORALL (x : bitvec, z : bitvec):
            (FORALL (a : INT, k : INT):
            ((length(x) = s2)
            => ((length(z) = r)
               => (((i <= a) AND (a < j))
                  => (((a <= k) AND (k < j)) => ((tb2t35(infix_at(
                     infix_mngt(int, angle1), int, infix_at(infix_mngt(int, 
                     infix_mngt(int, angle1)), bitvec1, infix_at(
                     infix_mngt(bitvec1, infix_mngt(int, infix_mngt(int,
                     angle1))), bitvec1, t2tb38(f), t2tb26(x)), t2tb26(z)), 
                     t2tb5(a)))[k]) = (tb2t35(infix_at(infix_mngt(int,
                     angle1), int, infix_at(infix_mngt(int, infix_mngt(int,
                     angle1)), bitvec1, infix_at(infix_mngt(bitvec1, 
                     infix_mngt(int, infix_mngt(int, angle1))), bitvec1, 
                     t2tb38(g), t2tb26(x)), t2tb26(z)), t2tb5(a)))[k]))))))))
           => (FORALL (x : bitvec, z : bitvec):
              (FORALL (a : INT):
              ((length(x) = s2)
              => ((length(z) = r)
                 => (((i <= a) AND (a < j)) => (ang_sum(tb2t35(infix_at(
                    infix_mngt(int, angle1), int, infix_at(infix_mngt(int, 
                    infix_mngt(int, angle1)), bitvec1, infix_at(
                    infix_mngt(bitvec1, infix_mngt(int, infix_mngt(int,
                    angle1))), bitvec1, t2tb38(f), t2tb26(x)), t2tb26(z)), 
                    t2tb5(a))), a, j) = ang_sum(tb2t35(infix_at(
                    infix_mngt(int, angle1), int, infix_at(infix_mngt(int, 
                    infix_mngt(int, angle1)), bitvec1, infix_at(
                    infix_mngt(bitvec1, infix_mngt(int, infix_mngt(int,
                    angle1))), bitvec1, t2tb38(g), t2tb26(x)), t2tb26(z)), 
                    t2tb5(a))), i, j))))))))))));

% ang_sum_break_zero_l_params
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, g : uni, i : INT, j : INT, l : INT):
  (((i <= l) AND (l <= j))
  => (FORALL (x : uni, y : uni):
     ((FORALL (k : INT):
      (((i <= k) AND (k < l)) => ((tb2t35(infix_at(infix_mngt(int, angle1),
      a, infix_at(infix_mngt(a, infix_mngt(int, angle1)), a, f, x),
      y))[k]) = ang_zero)))
     => ((FORALL (k : INT):
         (((i <= k) AND (k < j)) => ((tb2t35(infix_at(infix_mngt(int,
         angle1), a, infix_at(infix_mngt(a, infix_mngt(int, angle1)), a, f,
         x), y))[k]) = (tb2t35(infix_at(infix_mngt(int, angle1), a, infix_at(
         infix_mngt(a, infix_mngt(int, angle1)), a, g, x), y))[k]))))
        => (ang_sum(tb2t35(infix_at(infix_mngt(int, angle1), a, infix_at(
        infix_mngt(a, infix_mngt(int, angle1)), a, g, x), y)), i, j) = 
        ang_sum(tb2t35(infix_at(infix_mngt(int, angle1), a, infix_at(
        infix_mngt(a, infix_mngt(int, angle1)), a, f, x), y)), l, j))))))));

% ang_sum_break_param
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)), i : INT, j : INT):
  ((i < j)
  => (FORALL (y : INT):
     (((i <= y) AND (y < j)) => (ang_sum(tb2t35(infix_at(infix_mngt(int,
     angle1), int, t2tb36(f), t2tb5(y))), i, j) = ang_add(ang_sum(tb2t35(
     infix_at(infix_mngt(int, angle1), int, t2tb36(f), t2tb5(y))), i, y), 
     ang_sum(tb2t35(infix_at(infix_mngt(int, angle1), int, t2tb36(f), 
     t2tb5(y))), y, j)))))));

% ang_sum_neutral_param_r
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)), i : INT, j : INT):
  ((i < j)
  => (FORALL (y : INT):
     (((i <= y) AND (y < j))
     => ((FORALL (k : INT):
         (((y <= k) AND (k < j)) => ((tb2t35(infix_at(infix_mngt(int,
         angle1), int, t2tb36(f), t2tb5(y)))[k]) = ang_zero)))
        => (ang_sum(tb2t35(infix_at(infix_mngt(int, angle1), int, t2tb36(f), 
        t2tb5(y))), y, j) = ang_zero))))));

% ang_sum_neutral_param_l
  ASSERT
  (FORALL (f : (ARRAY INT OF (ARRAY INT OF angle)), i : INT, j : INT):
  ((i < j)
  => (FORALL (y : INT):
     (((i <= y) AND (y < j))
     => ((FORALL (k : INT):
         (((i <= k) AND (k < y)) => ((tb2t35(infix_at(infix_mngt(int,
         angle1), int, t2tb36(f), t2tb5(y)))[k]) = ang_zero)))
        => (ang_sum(tb2t35(infix_at(infix_mngt(int, angle1), int, t2tb36(f), 
        t2tb5(y))), i, y) = ang_zero))))));

fc259: ((ARRAY INT OF angle), INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), k : INT, b : INT): ((fc259(f,
  k)[b]) = (f[(b + k)])));

% ang_sum_transl
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT, k : INT):
  ((i < j) => (ang_sum(f, i, j) = ang_sum(fc259(f, k), (i - k), (j - k)))));

fc260: ((ARRAY INT OF angle)) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), b : INT): ((
  fc260(f)[b]) = (f[(b - 1)])));

% ang_sum_transl_one
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, j : INT):
  ((i < j) => (ang_sum(f, i, j) = ang_sum(fc260(f), (i + 1), (j + 1)))));

fc261: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, k : INT): ((fc261(f, n)[k]) = 
  infix_sldtsl((f[k]), n)));

% ang_sum_to_ind_isum
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, i : INT, j : INT):
  ((0 <= n)
  => ((i < j) => (ang_sum(fc261(f, n), i, j) = infix_sldtsl(ind_isum(f, i,
     j), n)))));

fc262: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, k : INT): ((fc262(f, n)[k]) = 
  infix_sldtsl((f[k]), n)));

% ind_isum_to_d_sum
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, i : INT, j : INT):
  ((0 <= n)
  => ((i < j) => (infix_sldtsl(ind_isum(f, i, j), n) = ang_sum(fc262(f, n),
     i, j)))));

fc263: ((ARRAY INT OF INT), INT, INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (bvx : (ARRAY INT OF INT), k : INT, n : INT, x : INT): ((fc263(bvx,
  k, n)[x]) = infix_sldtsl((((bvx[x]) * power(2, ((n - x) - 1))) * k), n)));

% ang_sum_int_decomp
  ASSERT
  (FORALL (bvx : (ARRAY INT OF INT), k : INT, n : INT):
  ((0 < n)
  => ((binary(bvx)) => (ang_sum(fc263(bvx, k, n), 0, n) = infix_sldtsl((
     bin_to_int(bvx, n) * k), n)))));

fc264: ((ARRAY INT OF INT), INT, INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (bvx : (ARRAY INT OF INT), n : INT, k : INT, x : INT): ((fc264(bvx,
  n, k)[x]) = infix_sldtsl((((bvx[x]) * power(2, ((n - x) - 1))) * k), n)));

% ang_sum_int_decomp_gen
  ASSERT
  (FORALL (bvx : (ARRAY INT OF INT), n : INT):
  ((0 < n)
  => ((binary(bvx))
     => (FORALL (k : INT): (ang_sum(fc264(bvx, n, k), 0, n) = infix_sldtsl((
        bin_to_int(bvx, n) * k), n))))));

fc851: (INT, bitvec, INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, k : INT, i : INT): ((fc851(n, x, k)[i]) = 
  infix_sldtsl((((value(x)[i]) * power(2, ((n - i) - 1))) * k), n)));

% ang_sum_bv_to_int
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     (FORALL (k : INT):
     ((length(x) = n) => (ang_sum(fc851(n, x, k), 0, n) = infix_sldtsl((
     bv_to_int(x) * k), n)))))));

fc852: (INT, bitvec, INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, k : INT, i : INT): ((fc852(n, x, k)[i]) = 
  infix_sldtsl((((value(x)[i]) * power(2, ((n - i) - 1))) * k), n)));

% ang_sum_bv_to_int_
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     (FORALL (k : INT):
     ((length(x) = n) => (ang_sum(fc852(n, x, k), 0, n) = infix_sldtsl((
     bv_to_int(x) * k), n)))))));

fc853: (INT, bitvec, bitvec, INT) -> (ARRAY INT OF angle);

fc854: (INT, bitvec, bitvec) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, target : INT, k : INT): ((
  fc853(n, x, y, target)[k]) = infix_sldtsl((((value(y)[k]) * (
  value(x)[target])) * power(2, (((n - k) - 1) + ((n - target) - 1)))), n)));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, target : INT): ((fc854(n, x,
  y)[target]) = ang_sum(fc853(n, x, y, target), ((n - target) - 1), n)));

% ang_sum_sum_bv_to_int_mult
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec):
  ((0 < n)
  => ((length(x) = n)
     => ((length(y) = n) => (ang_sum(fc854(n, x, y), 0, n) = infix_sldtsl((
        bv_to_int(x) * bv_to_int(y)), n))))));

fc855: (INT, bitvec, bitvec, INT) -> (ARRAY INT OF angle);

fc856: (INT, bitvec, bitvec) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, target : INT, k : INT): ((
  fc855(n, x, y, target)[k]) = infix_sldtsl((((value(y)[k]) * (
  value(x)[target])) * power(2, (((n - k) - 1) + ((n - target) - 1)))), n)));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, target : INT): ((fc856(n, x,
  y)[target]) = ang_sum(fc855(n, x, y, target), ((n - target) - 1), n)));

% ang_sum_sum_bv_to_int_mult_gen
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec, y : bitvec):
     ((length(x) = n)
     => ((length(y) = n) => (ang_sum(fc856(n, x, y), 0, n) = infix_sldtsl((
        bv_to_int(x) * bv_to_int(y)), n)))))));

fc271: ((ARRAY INT OF INT), INT, INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (bvx : (ARRAY INT OF INT), n : INT, k : INT, x : INT): ((fc271(bvx,
  n, k)[x]) = infix_sldtsl((((bvx[x]) * power(2, ((n - x) - 1))) * k), n)));

% ang_sum_int_decomp_gen_rev
  ASSERT
  (FORALL (bvx : (ARRAY INT OF INT), n : INT):
  ((0 < n)
  => ((binary(bvx))
     => (FORALL (k : INT): (infix_sldtsl((bin_to_int(bvx, n) * k), n) = 
        ang_sum(fc271(bvx, n, k), 0, n))))));

fc857: (angle, (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (o : angle, f : (ARRAY INT OF INT), i : INT): ((fc857(o, f)[i]) = 
  ang_mult_int(o, (f[i]))));

% sum_ang_mult_int_e
  ASSERT
  (FORALL (o : angle, f : (ARRAY INT OF INT), l : INT, h : INT):
  ((l < h) => (ang_sum(fc857(o, f), l, h) = ang_mult_int(o, ind_isum(f, l,
  h)))));

fc273: ((ARRAY INT OF complex)) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (phi : (ARRAY INT OF complex), i : INT): ((fc273(phi)[i]) = 
  real_to_ang(tb2t(infix_at(complex1, int, t2tb12(phi), t2tb5(i))))));

% real_to_ang_sum
  ASSERT
  (FORALL (phi : (ARRAY INT OF complex), l : INT, h : INT):
  ((l < h)
  => ((FORALL (i : INT):
      (((l <= i) AND (i < h)) => (real_(tb2t(infix_at(complex1, int, 
      t2tb12(phi), t2tb5(i)))))))
     => (ang_sum(fc273(phi), l, h) = real_to_ang(ind_sum(phi, l, h))))));

fc274: ((ARRAY INT OF INT), complex) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : complex, i : INT): ((fc274(f,
  x)[i]) = real_to_ang(infix_asdt(x, i_to_c((f[i]))))));

% real_to_ang_sum_int
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, h : INT, x : complex):
  ((l < h)
  => ((real_(x)) => (ang_sum(fc274(f, x), l, h) = real_to_ang(infix_asdt(x, 
     i_to_c(ind_isum(f, l, h))))))));

fc275: ((ARRAY INT OF INT), complex) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : complex, i : INT): ((fc275(f,
  x)[i]) = real_to_ang(infix_asdt(x, i_to_c((f[i]))))));

% real_to_ang_sum_int_gen
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT, h : INT):
  ((l < h)
  => (FORALL (x : complex):
     ((real_(x)) => (ang_sum(fc275(f, x), l, h) = real_to_ang(infix_asdt(x, 
     i_to_c(ind_isum(f, l, h)))))))));

fc858: (complex, bitvec) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (x : complex, y : bitvec, i : INT): ((fc858(x, y)[i]) = 
  real_to_ang(infix_asdt(infix_asdt(x, i_to_c(power(2, i))), i_to_c((
  value(y)[i]))))));

% real_to_ang_bv_inversion
  ASSERT
  (FORALL (ft : INT, x : complex, y : bitvec):
  ((0 < ft)
  => ((real_(x))
     => ((length(y) = ft) => (ang_sum(fc858(x, y), 0, ft) = real_to_ang(
        infix_asdt(x, i_to_c(bv_to_int(bv_inversion(y))))))))));

fc859: ((ARRAY INT OF angle), INT) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, x : INT): ((fc859(f, i)[x]) = 
  ang_mult_int((f[x]), i)));

% sum_ang_mult_int
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), i : INT, l : INT, h : INT):
  ((l < h) => (ang_sum(fc859(f, i), l, h) = ang_mult_int(ang_sum(f, l, h),
  i))));

fc860: (bitvec, complex) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (x : bitvec, theta : complex, i : INT): ((fc860(x, theta)[i]) = 
  real_to_ang(infix_asdt(infix_asdt(theta, i_to_c(power(2, i))), i_to_c((
  value(x)[i]))))));

% ang_sum_bv_to_int_inversion_pre
  ASSERT
  (FORALL (n : INT, x : bitvec):
  ((0 < n)
  => ((length(x) = n)
     => (FORALL (theta : complex):
        ((real_(theta)) => (real_to_ang(infix_asdt(theta, i_to_c(bv_to_int(
        bv_inversion(x))))) = ang_sum(fc860(x, theta), 0, n)))))));

fc861: (bitvec, complex) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (x : bitvec, theta : complex, i : INT): ((fc861(x, theta)[i]) = 
  real_to_ang(infix_asdt(infix_asdt(theta, i_to_c(power(2, i))), i_to_c((
  value(x)[i]))))));

% ang_sum_bv_to_int_inversion
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     (FORALL (theta : complex):
     ((length(x) = n)
     => ((real_(theta)) => (real_to_ang(infix_asdt(theta, i_to_c(bv_to_int(
        bv_inversion(x))))) = ang_sum(fc861(x, theta), 0, n))))))));

fc862: (INT, bitvec, complex) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, theta : complex, i : INT): ((fc862(n, x,
  theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta, i_to_c(power(2,
  ((n - i) - 1)))), i_to_c((- (value(x)[i])))))));

% ang_sum_bv_to_int_opp_pre
  ASSERT
  (FORALL (n : INT, x : bitvec):
  ((0 < n)
  => ((length(x) = n)
     => (FORALL (theta : complex):
        ((real_(theta)) => (real_to_ang(infix_asdt(theta, i_to_c((- 
        bv_to_int(x))))) = ang_sum(fc862(n, x, theta), 0, n)))))));

fc863: (INT, bitvec, complex) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, theta : complex, i : INT): ((fc863(n, x,
  theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta, i_to_c(power(2,
  ((n - i) - 1)))), i_to_c((- (value(x)[i])))))));

% ang_sum_bv_to_int_opp
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     (FORALL (theta : complex):
     ((length(x) = n)
     => ((real_(theta)) => (real_to_ang(infix_asdt(theta, i_to_c((- 
        bv_to_int(x))))) = ang_sum(fc863(n, x, theta), 0, n))))))));

fc864: (INT, bitvec, complex) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, theta : complex, i : INT): ((fc864(n, x,
  theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta, i_to_c(power(2,
  ((n - i) - 1)))), i_to_c((value(x)[i]))))));

% ang_sum_bv_to_int_mult_pre
  ASSERT
  (FORALL (n : INT, x : bitvec):
  ((0 < n)
  => ((length(x) = n)
     => (FORALL (theta : complex):
        ((real_(theta)) => (real_to_ang(infix_asdt(theta, i_to_c(
        bv_to_int(x)))) = ang_sum(fc864(n, x, theta), 0, n)))))));

fc865: (INT, bitvec, complex) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, theta : complex, i : INT): ((fc865(n, x,
  theta)[i]) = real_to_ang(infix_asdt(infix_asdt(theta, i_to_c(power(2,
  ((n - i) - 1)))), i_to_c((value(x)[i]))))));

% ang_sum_bv_to_int_mult
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     (FORALL (theta : complex):
     ((length(x) = n)
     => ((real_(theta)) => (real_to_ang(infix_asdt(theta, i_to_c(
        bv_to_int(x)))) = ang_sum(fc865(n, x, theta), 0, n))))))));

fc866: (INT, bitvec, bitvec, INT) -> (ARRAY INT OF angle);

fc867: (INT, bitvec, bitvec) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT, i : INT): ((fc866(n, x,
  y, j)[i]) = infix_sldtsl((((- (value(x)[i])) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j))), n)));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT): ((fc867(n, x, y)[j]) = 
  ang_sum(fc866(n, x, y, j), j, n)));

% rewrite_ang_sum_sum_to_bv_and_inversion
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec):
  ((0 < n)
  => ((length(x) = n)
     => ((length(y) = n) => (ang_sum(fc867(n, x, y), 0, n) = real_to_ang(
        infix_sldt(infix_asdt(i_to_c((- bv_to_int(x))), i_to_c(bv_to_int(
        bv_inversion(y)))), i_to_c(power(2, n)))))))));

fc868: (INT, bitvec, bitvec, INT) -> (ARRAY INT OF angle);

fc869: (INT, bitvec, bitvec) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT, i : INT): ((fc868(n, x,
  y, j)[i]) = infix_sldtsl((((- (value(x)[i])) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j))), n)));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT): ((fc869(n, x, y)[j]) = 
  ang_sum(fc868(n, x, y, j), j, n)));

% rewrite_ang_sum_sum_to_bv_and_inversion_gen
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec, y : bitvec):
     ((length(x) = n)
     => ((length(y) = n) => (ang_sum(fc869(n, x, y), 0, n) = real_to_ang(
        infix_asdt(infix_asdt(i_to_c((- bv_to_int(x))), i_to_c(bv_to_int(
        bv_inversion(y)))), pow_inv_2(n)))))))));

fc870: (INT, bitvec, bitvec, INT) -> (ARRAY INT OF INT);

fc871: (INT, bitvec, bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT, i : INT): ((fc870(n, x,
  y, j)[i]) = (((value(x)[i]) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j)))));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT): ((fc871(n, x, y)[j]) = 
  ind_isum(fc870(n, x, y, j), j, n)));

% int_to_ang_by_sum_mult_break
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec):
  ((0 < n)
  => ((length(x) = n)
     => ((length(y) = n) => (infix_sldtsl(ind_isum(fc871(n, x, y), 0, n),
        n) = infix_sldtsl((bv_to_int(x) * bv_to_int(bv_inversion(y))), n))))));

fc872: (INT, bitvec, bitvec, INT) -> (ARRAY INT OF INT);

fc873: (INT, bitvec, bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT, i : INT): ((fc872(n, x,
  y, j)[i]) = (((value(x)[i]) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j)))));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT): ((fc873(n, x, y)[j]) = 
  ind_isum(fc872(n, x, y, j), j, n)));

% int_to_ang_by_sum_mult_break_gen
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec, y : bitvec):
     ((length(x) = n)
     => ((length(y) = n) => (infix_sldtsl(ind_isum(fc873(n, x, y), 0, n),
        n) = infix_sldtsl((bv_to_int(x) * bv_to_int(bv_inversion(y))), n)))))));

fc874: (INT, bitvec, bitvec, INT) -> (ARRAY INT OF INT);

fc875: (INT, bitvec, bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT, i : INT): ((fc874(n, x,
  y, j)[i]) = (((value(x)[i]) * (value(y)[j])) * power(2,
  (((n - i) - 1) + j)))));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec, j : INT): ((fc875(n, x,
  y)[j]) = (- ind_isum(fc874(n, x, y, j), j, n))));

% int_to_ang_by_sum_mult_break_neg
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec, y : bitvec):
     ((length(x) = n)
     => ((length(y) = n) => (infix_sldtsl(ind_isum(fc875(n, x, y), 0, n),
        n) = infix_sldtsl(((- bv_to_int(x)) * bv_to_int(bv_inversion(y))),
        n)))))));

is_a_ket: (matrix_complex) -> BOOLEAN;

% Is_a_ket
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m))
  <=> ((columns(complex1, t2tb18(m)) = 1)
      AND (EXISTS (s2 : INT):
          ((0 <= s2) AND (rows(complex1, t2tb18(m)) = power(2, s2)))))));

xor_i: (INT, INT) -> INT;

% xor_i'def
  ASSERT
  (FORALL (i : INT, iqt : INT):
  (((0 <= i) AND (i < 2))
  => (((0 <= iqt) AND (iqt < 2))
     => (IF (i = 0) THEN (xor_i(i, iqt) = iqt) ELSE (xor_i(i,
        iqt) = (1 - iqt)) ENDIF))));

% xor_i'spec
  ASSERT
  (FORALL (i : INT, iqt : INT):
  (((0 <= i) AND (i < 2))
  => (((0 <= iqt) AND (iqt < 2))
     => (((i = 0) => ((iqt = 0) => (xor_i(i, iqt) = 0)))
        AND (((i = 0) => ((iqt = 1) => (xor_i(i, iqt) = 1)))
            AND (((i = 1) => ((iqt = 0) => (xor_i(i, iqt) = 1)))
                AND ((i = 1) => ((iqt = 1) => (xor_i(i, iqt) = 0)))))))));

is_a_ket_l: (matrix_complex, INT) -> BOOLEAN;

% is_a_ket_l'def
  ASSERT
  (FORALL (m : matrix_complex, l : INT):
  ((is_a_ket_l(m, l))
  <=> ((0 <= l)
      AND ((columns(complex1, t2tb18(m)) = 1) AND (rows(complex1, 
          t2tb18(m)) = power(2, l))))));

% ket_l_rows
  ASSERT
  (FORALL (m : matrix_complex, l : INT):
  ((is_a_ket_l(m, l)) => (rows(complex1, t2tb18(m)) = power(2, l))));

% ket_l_columns
  ASSERT
  (FORALL (m : matrix_complex):
  ((EXISTS (l : INT): (is_a_ket_l(m, l))) => (columns(complex1, 
  t2tb18(m)) = 1)));

ket_length: (matrix_complex) -> INT;

% ket_length'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m)) => (ket_length(m) = (binary_length(rows(complex1, 
  t2tb18(m))) - 1))));

% ket_length'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m))
  => ((0 <= ket_length(m)) AND (rows(complex1, t2tb18(m)) = power(2, 
     ket_length(m))))));

% get_ket_rev
  ASSERT TRUE;

get_ket_bv: (matrix_complex, bitvec) -> complex;

% get_ket_bv'def
  ASSERT
  (FORALL (x : matrix_complex, bv : bitvec):
  ((is_a_ket_l(x, length(bv))) => (get_ket_bv(x, bv) = tb2t(get(complex1, 
  t2tb18(x), bv_to_int(bv), 0)))));

% get_ket_add
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex, i : INT):
  ((is_a_ket(x))
  => ((is_a_ket(y))
     => ((ket_length(x) = ket_length(y))
        => (((0 <= i) AND (i < power(2, ket_length(y)))) => (tb2t(
           get(complex1, t2tb18(add_mat(x, y)), i, 0)) = infix_pldt(tb2t(
           get(complex1, t2tb18(x), i, 0)), tb2t(get(complex1, t2tb18(y), i,
           0)))))))));

% get_ket_substr
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex, i : INT):
  ((is_a_ket(x))
  => ((is_a_ket(y))
     => ((ket_length(x) = ket_length(y))
        => (((0 <= i) AND (i < power(2, ket_length(y)))) => (tb2t(
           get(complex1, t2tb18(mat_substr(x, y)), i, 0)) = infix_mndt(tb2t(
           get(complex1, t2tb18(x), i, 0)), tb2t(get(complex1, t2tb18(y), i,
           0)))))))));

% mat_mult_ket_l
  ASSERT
  (FORALL (m : matrix_complex, k : matrix_complex, n : INT):
  ((is_a_ket_l(k, n))
  => ((rows(complex1, t2tb18(m)) = power(2, n))
     => ((columns(complex1, t2tb18(m)) = power(2, n)) => (is_a_ket_l(
        mat_mult(m, k), n))))));

% ket_kronecker_values
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT):
  ((is_a_ket(m))
  => ((is_a_ket(n))
     => (((0 <= i) AND (i < (rows(complex1, t2tb18(m)) * rows(complex1, 
         t2tb18(n)))))
        => (tb2t(get(complex1, t2tb18(kronecker(m, n)), i, 0)) = infix_asdt(
        tb2t(get(complex1, t2tb18(m), div(i, rows(complex1, t2tb18(n))), 0)), 
        tb2t(get(complex1, t2tb18(n), mod(i, rows(complex1, t2tb18(n))),
        0))))))));

% ket_l_to_ket
  ASSERT
  (FORALL (m : matrix_complex, l : INT):
  ((is_a_ket_l(m, l)) => ((is_a_ket(m)) AND (ket_length(m) = l))));

% ket_l_to_ket_gen
  ASSERT
  (FORALL (m : matrix_complex):
  ((EXISTS (l : INT): (is_a_ket_l(m, l))) => (is_a_ket(m))));

% ket_to_ket_l
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m)) => (is_a_ket_l(m, ket_length(m)))));

% set_ket_valid_index
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket(m))
  => (((0 <= i) AND (i < power(2, ket_length(m)))) => (valid_index(complex1, 
     t2tb18(m), i, 0)))));

% ket_to_ket_l_l
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket(m)) => ((ket_length(m) = i) => (is_a_ket_l(m, i)))));

% set_constant_size_ket
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket(tb2t18(infix_at(matrix(complex1), a, f,
      e)))))))
  => ((FORALL (e : uni, eqt : uni):
      ((sort(a, e))
      => ((sort(a, eqt))
         => ((mem(a, e, s2))
            => ((mem(a, eqt, s2)) => (ket_length(tb2t18(infix_at(
               matrix(complex1), a, f, e))) = ket_length(tb2t18(infix_at(
               matrix(complex1), a, f, eqt)))))))))
     => (constant_size(a, s2, f))))));

ket_norm_l: (matrix_complex, INT) -> complex;

result24: (matrix_complex) -> (ARRAY INT OF complex);

% result'def
  ASSERT
  (FORALL (x : matrix_complex, k : INT): (tb2t(infix_at(complex1, int, 
  t2tb12(result24(x)), t2tb5(k))) = infix_asdt(modulus(tb2t(get(complex1, 
  t2tb18(x), k, 0))), modulus(tb2t(get(complex1, t2tb18(x), k, 0))))));

% ket_norm_l'def
  ASSERT
  (FORALL (x : matrix_complex, n : INT):
  ((is_a_ket_l(x, n)) => (ket_norm_l(x, n) = square_rt(sum(int, t2tb6(
  to_fset(0, power(2, n))), t2tb12(result24(x)))))));

fc294: (matrix_complex) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (x : matrix_complex, k : INT): (tb2t(infix_at(complex1, int, 
  t2tb12(fc294(x)), t2tb5(k))) = infix_asdt(modulus(tb2t(get(complex1, 
  t2tb18(x), k, 0))), modulus(tb2t(get(complex1, t2tb18(x), k, 0))))));

% ind_sum_ket_norm_l
  ASSERT
  (FORALL (x : matrix_complex, n : INT):
  ((is_a_ket_l(x, n)) => (ket_norm_l(x, n) = square_rt(ind_sum(fc294(x), 0, 
  power(2, n))))));

% ket_norm_one
  ASSERT
  (FORALL (x : matrix_complex, n : INT):
  ((n = 1)
  => ((is_a_ket_l(x, n)) => (ket_norm_l(x, n) = square_rt(infix_pldt(
     infix_asdt(modulus(tb2t(get(complex1, t2tb18(x), 0, 0))), modulus(tb2t(
     get(complex1, t2tb18(x), 0, 0)))), infix_asdt(modulus(tb2t(get(complex1, 
     t2tb18(x), 1, 0))), modulus(tb2t(get(complex1, t2tb18(x), 1, 0))))))))));

% ket_norm_one_c_one
  ASSERT
  (FORALL (x : matrix_complex, n : INT):
  ((n = 1)
  => ((is_a_ket_l(x, n))
     => ((infix_pldt(infix_asdt(modulus(tb2t(get(complex1, t2tb18(x), 0,
        0))), modulus(tb2t(get(complex1, t2tb18(x), 0, 0)))), infix_asdt(
        modulus(tb2t(get(complex1, t2tb18(x), 1, 0))), modulus(tb2t(
        get(complex1, t2tb18(x), 1, 0))))) = c_one) => (ket_norm_l(x,
        n) = c_one)))));

% scalar_ket_norm_l
  ASSERT
  (FORALL (x : matrix_complex, a : complex, n : INT):
  ((infix_lseqdt(c_zero, a))
  => ((is_a_ket_l(x, n)) => (ket_norm_l(infix_asdtdt(a, x), n) = 
     infix_asdt(a, ket_norm_l(x, n))))));

% zero_ket_norm_l
  ASSERT
  (FORALL (x : matrix_complex, n : INT):
  ((is_a_ket_l(x, n))
  => ((ket_norm_l(x, n) = c_zero)
     => (FORALL (i : INT, j : INT):
        (((0 <= i) AND (i < power(2, n)))
        => ((j = 0) => (tb2t(get(complex1, t2tb18(x), i, j)) = c_zero)))))));

normalized_l: (matrix_complex, INT) -> matrix_complex;

% normalized_l'def
  ASSERT
  (FORALL (x : matrix_complex, n : INT):
  ((is_a_ket_l(x, n))
  => ((EXISTS (i : INT):
      (((0 <= i) AND (i < power(2, n)))
      AND (NOT (tb2t(get(complex1, t2tb18(x), i, 0)) = c_zero))))
     => (normalized_l(x, n) = infix_asdtdt(infix_sldt(c_one, ket_norm_l(x,
     n)), x)))));

% normalized_l'spec
  ASSERT
  (FORALL (x : matrix_complex, n : INT):
  ((is_a_ket_l(x, n))
  => ((EXISTS (i : INT):
      (((0 <= i) AND (i < power(2, n)))
      AND (NOT (tb2t(get(complex1, t2tb18(x), i, 0)) = c_zero))))
     => (is_a_ket_l(normalized_l(x, n), n)))));

make_ket: (INT, (ARRAY INT OF complex)) -> matrix_complex;

result104: ((ARRAY INT OF complex)) -> (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), x : INT, us : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  result104(f)), t2tb5(x)), t2tb5(us))) = tb2t(infix_at(complex1, int, 
  t2tb12(f), t2tb5(x)))));

% make_ket'def
  ASSERT
  (FORALL (n : INT, f : (ARRAY INT OF complex)):
  ((0 <= n) => (make_ket(n, f) = tb2t18(make_f(complex1, power(2, n), 1, 
  t2tb15(result104(f)))))));

% make_ket'spec
  ASSERT
  (FORALL (n : INT, f : (ARRAY INT OF complex)):
  ((0 <= n)
  => ((is_a_ket_l(make_ket(n, f), n))
     AND ((FORALL (i : INT):
          (((0 <= i) AND (i < power(2, n))) => (tb2t(get(complex1, t2tb18(
          make_ket(n, f)), i, 0)) = tb2t(infix_at(complex1, int, t2tb12(f), 
          t2tb5(i))))))
         AND (FORALL (i : INT, j : INT):
             ((valid_index(complex1, t2tb18(make_ket(n, f)), i, j)) => (tb2t(
             get(complex1, t2tb18(make_ket(n, f)), i, j)) = tb2t(
             infix_at(complex1, int, t2tb12(f), t2tb5(i))))))))));

% assert_make_ket
  ASSERT
  (FORALL (r : INT, c : INT, f : (ARRAY INT OF complex), i : INT):
  ((c = 1)
  => (((0 <= i) AND (i < power(2, r))) => (tb2t(get(complex1, t2tb18(
     make_ket(r, f)), i, 0)) = tb2t(infix_at(complex1, int, t2tb12(f), 
     t2tb5(i)))))));

% assert_make_ket_l
  ASSERT
  (FORALL (l : INT, f : (ARRAY INT OF complex), i : INT):
  ((0 <= l) => (tb2t(get(complex1, t2tb18(make_ket(l, f)), i, 0)) = tb2t(
  infix_at(complex1, int, t2tb12(f), t2tb5(i))))));

% make_ket_length
  ASSERT
  (FORALL (l : INT, f : (ARRAY INT OF complex)):
  ((0 <= l) => (ket_length(make_ket(l, f)) = l)));

% make_ket_rows
  ASSERT
  (FORALL (l : INT, f : (ARRAY INT OF complex)):
  ((0 <= l) => (rows(complex1, t2tb18(make_ket(l, f))) = power(2, l))));

% make_ket_columns
  ASSERT
  (FORALL (l : INT, f : (ARRAY INT OF complex)):
  ((0 <= l) => (columns(complex1, t2tb18(make_ket(l, f))) = 1)));

make_ket_constant: (INT, complex) -> matrix_complex;

result105: (complex) -> (ARRAY INT OF complex);

% result'def
  ASSERT
  (FORALL (c : complex, us : INT): (tb2t(infix_at(complex1, int, t2tb12(
  result105(c)), t2tb5(us))) = c));

% make_ket_constant'def
  ASSERT
  (FORALL (n : INT, c : complex):
  ((0 <= n) => (make_ket_constant(n, c) = make_ket(n, result105(c)))));

% make_ket_constant'spec
  ASSERT
  (FORALL (n : INT, c : complex):
  ((0 <= n)
  => ((is_a_ket_l(make_ket_constant(n, c), n))
     AND ((FORALL (i : INT):
          (((0 <= i) AND (i < power(2, n))) => (tb2t(get(complex1, t2tb18(
          make_ket_constant(n, c)), i, 0)) = c)))
         AND (FORALL (i : INT, j : INT):
             ((valid_index(complex1, t2tb18(make_ket_constant(n, c)), i, j))
             => (tb2t(get(complex1, t2tb18(make_ket_constant(n, c)), i,
             j)) = c)))))));

% set_equal_ket
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((is_a_ket(m))
  => ((is_a_ket(n))
     => ((ket_length(m) = ket_length(n))
        => ((FORALL (i : INT):
            (((0 <= i) AND (i < power(2, ket_length(m)))) => (tb2t(
            get(complex1, t2tb18(m), i, 0)) = tb2t(get(complex1, t2tb18(n),
            i, 0)))))
           => (m = n))))));

% set_equal_ket_
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((EXISTS (l : INT):
   ((is_a_ket_l(m, l))
   AND ((is_a_ket_l(n, l))
       AND (FORALL (i : INT):
           (((0 <= i) AND (i < power(2, l))) => (tb2t(get(complex1, 
           t2tb18(m), i, 0)) = tb2t(get(complex1, t2tb18(n), i, 0))))))))
  => (m = n)));

add_ket: (matrix_complex, matrix_complex) -> matrix_complex;

% add_ket'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((is_a_ket(m))
  => ((is_a_ket(n))
     => ((ket_length(m) = ket_length(n)) => (add_ket(m, n) = add_mat(m, n))))));

% add_ket'spec
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((is_a_ket(m))
  => ((is_a_ket(n))
     => ((ket_length(m) = ket_length(n))
        => ((is_a_ket(add_ket(m, n)))
           AND ((ket_length(add_ket(m, n)) = ket_length(m))
               AND (FORALL (i : INT):
                   ((valid_index(complex1, t2tb18(add_ket(m, n)), i, 0)) => (
                   tb2t(get(complex1, t2tb18(add_ket(m, n)), i, 0)) = 
                   infix_pldt(tb2t(get(complex1, t2tb18(m), i, 0)), tb2t(
                   get(complex1, t2tb18(n), i, 0))))))))))));

add_ket_l: (matrix_complex, matrix_complex, INT) -> matrix_complex;

result106: (matrix_complex, matrix_complex) -> (ARRAY INT OF complex);

% result'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, i : INT): (tb2t(
  infix_at(complex1, int, t2tb12(result106(m, n)), t2tb5(i))) = infix_pldt(
  tb2t(get(complex1, t2tb18(m), i, 0)), tb2t(get(complex1, t2tb18(n), i,
  0)))));

% add_ket_l'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((0 <= l) => (add_ket_l(m, n, l) = make_ket(l, result106(m, n)))));

% add_ket_l'spec
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((0 <= l)
  => ((is_a_ket_l(add_ket_l(m, n, l), l))
     AND ((ket_length(add_ket_l(m, n, l)) = l)
         AND ((FORALL (i : INT): (tb2t(get(complex1, t2tb18(add_ket_l(m, n,
              l)), i, 0)) = infix_pldt(tb2t(get(complex1, t2tb18(m), i, 0)), 
              tb2t(get(complex1, t2tb18(n), i, 0)))))
             AND ((is_a_ket_l(m, l))
                 => ((is_a_ket_l(n, l)) => (add_ket_l(m, n, l) = add_mat(m,
                    n)))))))));

% add_ket_l_to_add_mat
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((0 <= l)
  => ((is_a_ket_l(m, l))
     => ((is_a_ket_l(n, l)) => (add_ket_l(m, n, l) = add_mat(m, n))))));

% null_add_ket_l
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((is_a_ket_l(m, l))
  => ((is_a_ket_l(n, l)) => ((null_mat(m)) => (add_ket_l(m, n, l) = n)))));

% add_ket_l_null
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((is_a_ket_l(m, l))
  => ((is_a_ket_l(n, l)) => ((null_mat(n)) => (add_ket_l(m, n, l) = m)))));

add_ket_l_eq: (matrix_complex, matrix_complex, matrix_complex,
  matrix_complex, INT) -> tuple0;

% add_ket_l_eq'def
  ASSERT
  (FORALL (m : matrix_complex, mqt : matrix_complex, n : matrix_complex,
  nqt : matrix_complex, l : INT):
  ((is_a_ket_l(m, l))
  => ((is_a_ket_l(n, l))
     => ((m = mqt)
        => ((n = nqt) => (add_ket_l_eq(m, mqt, n, nqt, l) = Tuple0))))));

add_ket_l_closure: (ARRAY matrix_complex OF (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex)));

t2tb39: ((ARRAY matrix_complex OF (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex)))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY matrix_complex OF (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex)))):
  (sort(infix_mngt(matrix(complex1), infix_mngt(matrix(complex1), 
  infix_mngt(int, matrix(complex1)))), t2tb39(x))));

tb2t39: (uni) -> (ARRAY matrix_complex OF (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex)));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY matrix_complex OF (ARRAY matrix_complex OF (ARRAY INT OF matrix_complex)))):PATTERN (
  t2tb39(i)):  (tb2t39(t2tb39(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb39(tb2t39(j))): 
  ((sort(infix_mngt(matrix(complex1), infix_mngt(matrix(complex1), 
  infix_mngt(int, matrix(complex1)))), j)) => (t2tb39(tb2t39(j)) = j)));

% add_ket_l_closure_def
  ASSERT
  (FORALL (y : matrix_complex, y1 : matrix_complex, y2 : INT): (tb2t18(
  infix_at(matrix(complex1), int, infix_at(infix_mngt(int, matrix(complex1)), 
  matrix(complex1), infix_at(infix_mngt(matrix(complex1), infix_mngt(int, 
  matrix(complex1))), matrix(complex1), t2tb39(add_ket_l_closure), 
  t2tb18(y)), t2tb18(y1)), t2tb5(y2))) = add_ket_l(y, y1, y2)));

% add_ket_l_eq'spec
  ASSERT
  (FORALL (m : matrix_complex, mqt : matrix_complex, n : matrix_complex,
  nqt : matrix_complex, l : INT):
  ((is_a_ket_l(m, l))
  => ((is_a_ket_l(n, l))
     => ((m = mqt)
        => ((n = nqt) => (tb2t21(infix_at(infix_mngt(int, matrix(complex1)), 
           matrix(complex1), infix_at(infix_mngt(matrix(complex1), 
           infix_mngt(int, matrix(complex1))), matrix(complex1), 
           t2tb39(add_ket_l_closure), t2tb18(m)), t2tb18(n))) = tb2t21(
           infix_at(infix_mngt(int, matrix(complex1)), matrix(complex1), 
           infix_at(infix_mngt(matrix(complex1), infix_mngt(int, 
           matrix(complex1))), matrix(complex1), t2tb39(add_ket_l_closure), 
           t2tb18(mqt)), t2tb18(nqt)))))))));

% add_ket_l_value
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT, i : INT):
  (((0 <= i) AND (i < power(2, l)))
  => ((0 <= l) => (tb2t(get(complex1, t2tb18(add_ket_l(m, n, l)), i, 0)) = 
     infix_pldt(tb2t(get(complex1, t2tb18(m), i, 0)), tb2t(get(complex1, 
     t2tb18(n), i, 0)))))));

% add_ket_l_length
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((0 <= l) => (ket_length(add_ket_l(m, n, l)) = l)));

% add_ket_l_rows
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((0 <= l) => (rows(complex1, t2tb18(add_ket_l(m, n, l))) = power(2, l))));

% add_ket_l_columns
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((0 <= l) => (columns(complex1, t2tb18(add_ket_l(m, n, l))) = 1)));

% add_ket_l_values
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((0 <= l)
  => (FORALL (i : INT):
     (((0 <= i) AND (i < power(2, l))) => (tb2t(get(complex1, t2tb18(
     add_ket_l(m, n, l)), i, 0)) = infix_pldt(tb2t(get(complex1, t2tb18(m),
     i, 0)), tb2t(get(complex1, t2tb18(n), i, 0))))))));

% add_ket_l_comm
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((0 <= l) => (add_ket_l(m, n, l) = add_ket_l(n, m, l))));

% set_equal_ket_l
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((EXISTS (l : INT): ((is_a_ket_l(m, l)) AND (is_a_ket_l(n, l))))
  => ((FORALL (i : INT):
      (((0 <= i) AND (i < power(2, ket_length(m)))) => (tb2t(get(complex1, 
      t2tb18(m), i, 0)) = tb2t(get(complex1, t2tb18(n), i, 0)))))
     => (m = n))));

% set_equal_ket_l_
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((is_a_ket_l(m, l))
  => ((is_a_ket_l(n, l))
     => ((FORALL (i : INT):
         (((0 <= i) AND (i < power(2, l))) => (tb2t(get(complex1, t2tb18(m),
         i, 0)) = tb2t(get(complex1, t2tb18(n), i, 0)))))
        => (m = n)))));

% get_ket_length
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = 1)
     => ((rows(complex1, t2tb18(m)) = power(2, n)) => (ket_length(m) = n)))));

% set_ket_length
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n)
  => ((is_a_ket(m))
     => ((ket_length(m) = n) => (rows(complex1, t2tb18(m)) = power(2, n))))));

% scalar_ket
  ASSERT
  (FORALL (x : matrix_complex, a : complex):
  ((is_a_ket(x)) => (is_a_ket(infix_asdtdt(a, x)))));

% scalar_ket_length
  ASSERT
  (FORALL (m : matrix_complex, a : complex):
  ((is_a_ket(m)) => (ket_length(infix_asdtdt(a, m)) = ket_length(m))));

% scalar_ket_valid_index
  ASSERT
  (FORALL (m : matrix_complex, a : complex, i : INT):
  ((valid_index(complex1, t2tb18(m), i, 0))
  => ((is_a_ket(m)) => (valid_index(complex1, t2tb18(infix_asdtdt(a, m)), i,
     0)))));

% scalar_ket_l
  ASSERT
  (FORALL (x : matrix_complex, l : INT, a : complex):
  ((is_a_ket_l(x, l)) => (is_a_ket_l(infix_asdtdt(a, x), l))));

% scalar_ket_l_values
  ASSERT
  (FORALL (a : complex, x : matrix_complex, l : INT):
  ((is_a_ket_l(x, l))
  => (FORALL (i : INT):
     (((0 <= i) AND (i < power(2, l))) => (tb2t(get(complex1, t2tb18(
     infix_asdtdt(a, x)), i, 0)) = infix_asdt(a, tb2t(get(complex1, 
     t2tb18(x), i, 0))))))));

% scalar_ket_l_value
  ASSERT
  (FORALL (a : complex, x : matrix_complex, i : INT, l : INT):
  (((0 <= i) AND (i < power(2, l)))
  => ((is_a_ket_l(x, l)) => (tb2t(get(complex1, t2tb18(infix_asdtdt(a, x)),
     i, 0)) = infix_asdt(a, tb2t(get(complex1, t2tb18(x), i, 0)))))));

% scalar_ket_value
  ASSERT
  (FORALL (x : matrix_complex, i : INT, a : complex): (tb2t(get(complex1, 
  t2tb18(infix_asdtdt(a, x)), i, 0)) = infix_asdt(a, tb2t(get(complex1, 
  t2tb18(x), i, 0)))));

% scalar_ket_value_rev
  ASSERT
  (FORALL (x : matrix_complex, i : INT, a : complex): (infix_asdt(a, tb2t(
  get(complex1, t2tb18(x), i, 0))) = tb2t(get(complex1, t2tb18(
  infix_asdtdt(a, x)), i, 0))));

% add_ket_is_a_ket
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket(x))
  => ((is_a_ket(y))
     => ((ket_length(x) = ket_length(y)) => (is_a_ket(add_mat(x, y)))))));

% set_ket_length_gen
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n)
  => ((is_a_ket(m))
     => ((power(2, ket_length(m)) = n) => (rows(complex1, t2tb18(m)) = n)))));

% set_is_a_ket
  ASSERT
  (FORALL (m : matrix_complex):
  ((columns(complex1, t2tb18(m)) = 1)
  => ((EXISTS (s2 : INT):
      ((0 <= s2) AND (rows(complex1, t2tb18(m)) = power(2, s2))))
     => (is_a_ket(m)))));

% set_is_a_ket_l
  ASSERT
  (FORALL (m : matrix_complex, l : INT):
  ((0 <= l)
  => ((columns(complex1, t2tb18(m)) = 1)
     => ((rows(complex1, t2tb18(m)) = power(2, l)) => (is_a_ket_l(m, l))))));

% set_is_a_ket_p
  ASSERT
  (FORALL (m : matrix_complex, l : INT):
  ((0 <= l)
  => ((columns(complex1, t2tb18(m)) = 1)
     => ((rows(complex1, t2tb18(m)) = power(2, l)) => (is_a_ket(m))))));

% get_is_a_ket
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m))
  => ((columns(complex1, t2tb18(m)) = 1) AND (rows(complex1, t2tb18(m)) = 
     power(2, ket_length(m))))));

% get_ket_columns
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m)) => (columns(complex1, t2tb18(m)) = 1)));

% get_ket_rows
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m)) => (rows(complex1, t2tb18(m)) = power(2, ket_length(m)))));

% get_ket_rows_gen
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket(m))
  => ((i = power(2, ket_length(m))) => (rows(complex1, t2tb18(m)) = i))));

% get_ket_rows_length
  ASSERT
  (FORALL (m : matrix_complex, l : INT):
  ((is_a_ket(m))
  => ((ket_length(m) = l) => (rows(complex1, t2tb18(m)) = power(2, l)))));

% ket_kronecker
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex):
  ((is_a_ket(m))
  => ((is_a_ket(n))
     => ((is_a_ket(kronecker(m, n))) AND (ket_length(kronecker(m, n)) = (
        ket_length(m) + ket_length(n)))))));

% ket_kronecker_l
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT, lqt : INT):
  ((is_a_ket_l(m, l))
  => ((is_a_ket_l(n, lqt)) => (is_a_ket_l(kronecker(m, n), (l + lqt))))));

% set_ket_kron_l
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT, lqt : INT,
  lqtqt : INT):
  ((is_a_ket_l(m, l))
  => ((is_a_ket_l(n, lqt))
     => ((lqtqt = (l + lqt)) => (is_a_ket_l(kronecker(m, n), lqtqt))))));

ket: (INT, INT) -> matrix_complex;

% ket'def
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n)
  => (IF ((0 <= i) AND (i < power(2, n))) THEN (ket(n, i) = tb2t18(
     set1(complex1, make(complex1, power(2, n), 1, t2tb(c_zero)), i, 0, 
     t2tb(c_one)))) ELSE (ket(n, i) = tb2t18(make(complex1, power(2, n), 1, 
     t2tb(c_zero)))) ENDIF)));

% ket'spec
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n)
  => ((is_a_ket(ket(n, i)))
     AND ((ket_length(ket(n, i)) = n)
         AND ((columns(complex1, t2tb18(ket(n, i))) = 1)
             AND ((rows(complex1, t2tb18(ket(n, i))) = power(2, n))
                 AND ((((0 <= i) AND (i < power(2, n)))
                      => (FORALL (j : INT):
                         ((valid_index(complex1, t2tb18(ket(n, i)), j, 0))
                         => (tb2t(get(complex1, t2tb18(ket(n, i)), j, 0)) = 
                         indic(int, t2tb5(j), t2tb5(i))))))
                     AND ((FORALL (j : INT):
                          ((valid_index(complex1, t2tb18(ket(n, i)), j, 0))
                          => ((NOT (i = j)) => (tb2t(get(complex1, t2tb18(
                             ket(n, i)), j, 0)) = c_zero))))
                         AND (((0 <= i) AND (i < power(2, n))) => (tb2t(
                             get(complex1, t2tb18(ket(n, i)), i,
                             0)) = c_one))))))))));

% ket_l
  ASSERT
  (FORALL (n : INT, m : INT, i : INT):
  ((0 <= n) => ((n = m) => (is_a_ket_l(ket(n, i), m)))));

% ket_ket_length
  ASSERT
  (FORALL (n : INT, m : INT, i : INT):
  ((0 <= n) => ((n = m) => (ket_length(ket(n, i)) = m))));

% ket_length_explicit
  ASSERT
  (FORALL (n : INT, i : INT): ((0 <= n) => (ket_length(ket(n, i)) = n)));

% ket_eq
  ASSERT
  (FORALL (n1 : INT, n2 : INT, i1 : INT, i2 : INT):
  ((0 <= n1) => ((n1 = n2) => ((i1 = i2) => (ket(n1, i1) = ket(n2, i2))))));

% ket_rows
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (rows(complex1, t2tb18(ket(n,
     i))) = power(2, n)))));

% ket_columns
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n) => (columns(complex1, t2tb18(ket(n, i))) = 1)));

% ket_value
  ASSERT
  (FORALL (n : INT, i : INT, j : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < power(2, n))) => (tb2t(get(complex1, t2tb18(
        ket(n, i)), j, 0)) = (IF (i = j) THEN c_one ELSE c_zero ENDIF))))));

% g_ket_value
  ASSERT
  (FORALL (n : INT, i : INT, j : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < power(2, n))) => (tb2t(get(complex1, t2tb18(
        ket(n, i)), j, 0)) = (IF (i = j) THEN c_one ELSE c_zero ENDIF))))));

% norm_ket_basis
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (ket_norm_l(ket(n, i), n) = c_one))));

% get_ket_
  ASSERT
  (FORALL (m : matrix_complex, i : INT, n : INT):
  ((m = ket(n, i))
  => ((0 <= n)
     => (((0 <= i) AND (i < power(2, n)))
        => ((is_a_ket(m))
           AND ((ket_length(m) = n)
               AND ((columns(complex1, t2tb18(m)) = 1)
                   AND ((rows(complex1, t2tb18(m)) = power(2, n))
                       AND ((FORALL (j : INT):
                            ((valid_index(complex1, t2tb18(m), j, 0)) => (
                            tb2t(get(complex1, t2tb18(m), j, 0)) = indic(int, 
                            t2tb5(j), t2tb5(i)))))
                           AND ((FORALL (j : INT):
                                ((valid_index(complex1, t2tb18(m), j, 0))
                                => ((NOT (i = j)) => (tb2t(get(complex1, 
                                   t2tb18(m), j, 0)) = c_zero))))
                               AND (tb2t(get(complex1, t2tb18(m), i,
                               0)) = c_one)))))))))));

% get_ket_value
  ASSERT
  (FORALL (i : INT, n : INT, j : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < power(2, n))) => (tb2t(get(complex1, t2tb18(
        ket(n, i)), j, 0)) = indic(int, t2tb5(j), t2tb5(i)))))));

% get_ket_values
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (FORALL (j : INT):
        (((0 <= j) AND (j < power(2, n))) => (tb2t(get(complex1, t2tb18(
        ket(n, i)), j, 0)) = indic(int, t2tb5(j), t2tb5(i))))))));

% get_ket_value_z
  ASSERT
  (FORALL (i : INT, n : INT, j : INT, z : INT):
  ((z = 0)
  => ((0 <= n)
     => (((0 <= i) AND (i < power(2, n)))
        => (((0 <= j) AND (j < power(2, n))) => (tb2t(get(complex1, t2tb18(
           ket(n, i)), j, z)) = indic(int, t2tb5(j), t2tb5(i))))))));

% get__ket_value
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < power(2, n))) => (tb2t(get(complex1, t2tb18(
        ket(n, i)), j, 0)) = indic(int, t2tb5(j), t2tb5(i)))))));

% set_ket
  ASSERT
  (FORALL (m : matrix_complex, i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => ((columns(complex1, t2tb18(m)) = 1)
        => ((rows(complex1, t2tb18(m)) = power(2, n))
           => ((FORALL (j : INT):
               ((valid_index(complex1, t2tb18(m), j, 0)) => (tb2t(
               get(complex1, t2tb18(m), j, 0)) = indic(int, t2tb5(j), 
               t2tb5(i)))))
              => (m = ket(n, i))))))));

% kronecker_kets
  ASSERT
  (FORALL (i1 : INT, i2 : INT, n1 : INT, n2 : INT):
  ((0 <= n1)
  => ((0 <= n2)
     => (((0 <= i1) AND (i1 < power(2, n1)))
        => (((0 <= i2) AND (i2 < power(2, n2))) => (kronecker(ket(n1, i1), 
           ket(n2, i2)) = ket((n1 + n2), ((i1 * power(2, n2)) + i2))))))));

% kronecker_kets_
  ASSERT
  (FORALL (i1 : INT, i2 : INT, n1 : INT, n2 : INT):
  ((0 <= n1)
  => ((0 <= n2)
     => (((0 <= i1) AND (i1 < power(2, n1)))
        => (((0 <= i2) AND (i2 < power(2, n2))) => (kronecker(ket(n1, i1), 
           ket(n2, i2)) = ket((n1 + n2), ((i1 * power(2, n2)) + i2))))))));

% kronecker_ket_l
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex, n1 : INT, n2 : INT):
  ((0 <= n1)
  => ((0 <= n2)
     => ((is_a_ket_l(x, n1))
        => ((is_a_ket_l(y, n2)) => (is_a_ket_l(kronecker(x, y), (n1 + n2))))))));

% kronecker_ket_l_sum
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex, n1 : INT, n2 : INT,
  n3 : INT):
  ((0 <= n1)
  => ((0 <= n2)
     => ((is_a_ket_l(x, n1))
        => ((is_a_ket_l(y, n2))
           => ((n3 = (n1 + n2)) => (is_a_ket_l(kronecker(x, y), n3))))))));

% kronecker_kets_bin_to_int
  ASSERT
  (FORALL (f1 : (ARRAY INT OF INT), f2 : (ARRAY INT OF INT), n1 : INT,
  n2 : INT):
  ((binary(f1))
  => ((binary(f2))
     => ((0 <= n1)
        => ((0 <= n2) => (kronecker(ket(n1, bin_to_int(f1, n1)), ket(n2, 
           bin_to_int(f2, n2))) = ket((n1 + n2), ((bin_to_int(f1, n1) * 
           power(2, n2)) + bin_to_int(f2, n2)))))))));

concat: (bitvec, bitvec) -> bitvec;

result107: (bitvec, bitvec) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, i : INT): ((result107(bv1,
  bv2)[i]) = (IF ((length(bv1) <= i) AND (i < (length(bv1) + length(bv2))))
             THEN (value(bv2)[(i - length(bv1))]) ELSE (value(bv1)[i]) ENDIF)));

% concat'def
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec): (concat(bv1, bv2) = make_bv(
  result107(bv1, bv2), (length(bv1) + length(bv2)))));

% concat'spec
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((length(concat(bv1, bv2)) = (length(bv1) + length(bv2)))
  AND ((FORALL (i : INT):
       (((0 <= i) AND (i < length(bv1))) => ((value(concat(bv1, bv2))[i]) = (
       value(bv1)[i]))))
      AND ((FORALL (i : INT):
           ((length(concat(bv1, bv2)) <= i) => ((value(concat(bv1,
           bv2))[i]) = (value(bv1)[i]))))
          AND (FORALL (i : INT):
              (((length(bv1) <= i) AND (i < length(concat(bv1, bv2)))) => ((
              value(concat(bv1, bv2))[i]) = (value(bv2)[(i - length(bv1))]))))))));

% concat_length
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec): (length(concat(bv1, bv2)) = (
  length(bv1) + length(bv2))));

hpart: (bitvec, INT) -> bitvec;

% hpart'def
  ASSERT
  (FORALL (bv : bitvec, m : INT):
  ((0 <= m) => (hpart(bv, m) = make_bv(value(bv), m))));

% hpart'spec
  ASSERT
  (FORALL (bv : bitvec, m : INT):
  ((0 <= m)
  => ((length(hpart(bv, m)) = m)
     AND (((length(bv) = m) => (hpart(bv, m) = bv))
         AND ((FORALL (k : INT):
              (((0 <= k) AND (k < m)) => ((value(hpart(bv, m))[k]) = (
              value(bv)[k]))))
             AND (FORALL (k : INT):
                 ((NOT ((0 <= k) AND (k < m))) => ((value(hpart(bv,
                 m))[k]) = 0))))))));

% hpart_value
  ASSERT
  (FORALL (bv : bitvec, m : INT, i : INT):
  ((0 <= m) => ((value(hpart(bv,
  m))[i]) = (IF ((0 <= i) AND (i < m)) THEN (value(bv)[i]) ELSE 0 ENDIF))));

% hpart_length
  ASSERT
  (FORALL (bv : bitvec, m : INT): ((0 <= m) => (length(hpart(bv, m)) = m)));

% hpart_value_b
  ASSERT
  (FORALL (bv : bitvec, m : INT, i : INT):
  (((0 <= i) AND (i < m)) => ((value(hpart(bv, m))[i]) = (value(bv)[i]))));

tpart: (bitvec, INT) -> bitvec;

result108: (bitvec, INT) -> (ARRAY INT OF INT);

result109: (bitvec, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (bv : bitvec, m : INT, k : INT): ((result108(bv, m)[k]) = (
  value(bv)[(k + m)])));

% result'def
  ASSERT
  (FORALL (bv : bitvec, m : INT, k : INT): ((result109(bv, m)[k]) = (
  value(bv)[(k + m)])));

% tpart'def
  ASSERT
  (FORALL (bv : bitvec, m : INT):
  ((0 <= m)
  => (IF (m <= length(bv)) THEN (tpart(bv, m) = make_bv(result108(bv, m), (
     length(bv) - m))) ELSE (tpart(bv, m) = make_bv(result109(bv, m),
     0)) ENDIF)));

% tpart'spec
  ASSERT
  (FORALL (bv : bitvec, m : INT):
  ((0 <= m)
  => (((m <= length(bv)) => (length(tpart(bv, m)) = (length(bv) - m)))
     AND (((length(bv) < m) => (length(tpart(bv, m)) = 0))
         AND (FORALL (k : INT):
             (((0 <= k) AND (k < length(tpart(bv, m)))) => ((value(tpart(bv,
             m))[k]) = (value(bv)[(k + m)]))))))));

bv_tail: (bitvec, INT) -> bitvec;

% bv_tail'def
  ASSERT
  (FORALL (bv : bitvec, m : INT):
  (((0 <= m) AND (m <= (length(bv) - m))) => (bv_tail(bv, m) = tpart(bv, (
  length(bv) - m)))));

% bv_tail'spec
  ASSERT
  (FORALL (bv : bitvec, m : INT):
  (((0 <= m) AND (m <= (length(bv) - m)))
  => ((length(bv_tail(bv, m)) = m)
     AND (FORALL (k : INT):
         (((0 <= k) AND (k < length(bv_tail(bv, m)))) => ((value(bv_tail(bv,
         m))[k]) = (value(bv)[(k + (length(bv) - m))])))))));

last: (bitvec) -> INT;

% last'def
  ASSERT
  (FORALL (bv : bitvec):
  ((1 <= length(bv)) => (last(bv) = (value(bv)[(length(bv) - 1)]))));

bv_head: (bitvec, INT) -> bitvec;

% bv_head'def
  ASSERT
  (FORALL (bv : bitvec, m : INT):
  (((0 <= m) AND (m <= length(bv))) => (bv_head(bv, m) = hpart(bv, (
  length(bv) - m)))));

% bv_head'spec
  ASSERT
  (FORALL (bv : bitvec, m : INT):
  (((0 <= m) AND (m <= length(bv)))
  => ((length(bv_head(bv, m)) = (length(bv) - m))
     AND (FORALL (k : INT):
         (((0 <= k) AND (k < length(bv_head(bv, m)))) => ((value(bv_head(bv,
         m))[k]) = (value(bv)[k])))))));

htpart: (bitvec, INT, INT) -> bitvec;

result110: (bitvec, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (bv : bitvec, k : INT, i : INT): ((result110(bv, k)[i]) = (
  value(bv)[(k + i)])));

% htpart'def
  ASSERT
  (FORALL (bv : bitvec, k : INT, n : INT):
  ((0 <= k)
  => ((0 <= n) => (htpart(bv, k, n) = make_bv(result110(bv, k), n)))));

% htpart'spec
  ASSERT
  (FORALL (bv : bitvec, k : INT, n : INT):
  ((0 <= k)
  => ((0 <= n)
     => ((length(htpart(bv, k, n)) = n)
        AND (FORALL (i : INT):
            (((0 <= i) AND (i < n)) => ((value(htpart(bv, k, n))[i]) = (
            value(bv)[(k + i)]))))))));

% tpart_value
  ASSERT
  (FORALL (bv : bitvec, m : INT, i : INT):
  ((0 <= m) => ((value(tpart(bv,
  m))[i]) = (IF ((0 <= i) AND (i < (length(bv) - m))) THEN (
            value(bv)[(i + m)]) ELSE 0 ENDIF))));

% tpart_value_b
  ASSERT
  (FORALL (bv : bitvec, m : INT, i : INT):
  ((0 <= m)
  => (((0 <= i) AND (i < (length(bv) - m))) => ((value(tpart(bv, m))[i]) = (
     value(bv)[(i + m)])))));

% tpart_length
  ASSERT
  (FORALL (bv : bitvec, m : INT):
  (((0 <= m) AND (m <= length(bv))) => (length(tpart(bv, m)) = (
  length(bv) - m))));

% htpart_value
  ASSERT
  (FORALL (bv : bitvec, k : INT, n : INT, i : INT):
  ((0 <= k)
  => ((0 <= n) => ((value(htpart(bv, k,
     n))[i]) = (IF ((0 <= i) AND (i < n)) THEN (value(bv)[(k + i)])
               ELSE 0 ENDIF)))));

% htpart_value_b
  ASSERT
  (FORALL (bv : bitvec, k : INT, n : INT, i : INT):
  ((0 <= k)
  => ((0 <= n)
     => (((0 <= i) AND (i < n)) => ((value(htpart(bv, k, n))[i]) = (
        value(bv)[(k + i)]))))));

% htpart_product_
  ASSERT
  (FORALL (x : bitvec, k : INT, n : INT, nqt : INT):
  (((0 <= k) AND (k < n))
  => ((nqt = (n - k)) => (ind_iproduct(value(htpart(x, k, nqt)), 0,
     (n - k)) = ind_iproduct(value(x), k, n)))));

% htpart_product_one
  ASSERT
  (FORALL (x : bitvec, k : INT, n : INT, nqt : INT):
  (((0 <= k) AND (k < n))
  => ((length(x) = n)
     => ((nqt = (n - k))
        => ((ind_iproduct(value(x), 0, n) = 1) => (ind_iproduct(value(
           htpart(x, k, nqt)), 0, (n - k)) = 1))))));

% htpart_product_zero
  ASSERT
  (FORALL (x : bitvec, k : INT, n : INT, nqt : INT):
  (((0 <= k) AND (k < n))
  => ((length(x) = n)
     => ((nqt = (n - k))
        => ((EXISTS (j : INT):
            (((k <= j) AND (j < n)) AND (NOT ((value(x)[j]) = 1))))
           => (ind_iproduct(value(htpart(x, k, nqt)), 0, (n - k)) = 0))))));

% htpart_product
  ASSERT
  (FORALL (x : bitvec, k : INT, n : INT, nqt : INT):
  (((0 <= k) AND (k < n))
  => ((length(x) = n)
     => ((nqt = (n - k)) => (ind_iproduct(value(htpart(x, k, nqt)), 0,
        (n - k)) = (IF (FORALL (j : INT):
                       (((k <= j) AND (j < n)) => ((value(x)[j]) = 1)))
                   THEN 1 ELSE 0 ENDIF))))));

% htpart_length
  ASSERT
  (FORALL (bv : bitvec, k : INT, n : INT):
  ((0 <= k) => ((0 <= n) => (length(htpart(bv, k, n)) = n))));

% tpart_length_gen
  ASSERT
  (FORALL (bv : bitvec, m : INT, l : INT):
  (((0 <= m) AND (m <= length(bv)))
  => ((l = (length(bv) - m)) => (length(tpart(bv, m)) = l))));

% concat_value_left
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, i : INT):
  (((0 <= i) AND (i < length(bv1))) => ((value(concat(bv1, bv2))[i]) = (
  value(bv1)[i]))));

% concat_value
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, i : INT): ((value(concat(bv1,
  bv2))[i]) = (IF ((length(bv1) <= i) AND (i < (length(bv1) + length(bv2))))
              THEN (value(bv2)[(i - length(bv1))])
              ELSE (IF ((0 <= i) AND (i < length(bv1))) THEN (value(bv1)[i])
                   ELSE 0 ENDIF) ENDIF)));

% concat_value_b
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, i : INT):
  (((0 <= i) AND (i < (length(bv1) + length(bv2)))) => ((value(concat(bv1,
  bv2))[i]) = (IF (i < length(bv1)) THEN (value(bv1)[i]) ELSE (
              value(bv2)[(i - length(bv1))]) ENDIF))));

% concat_value_right
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, i : INT):
  (((length(bv1) <= i) AND (i < (length(bv1) + length(bv2)))) => ((value(
  concat(bv1, bv2))[i]) = (value(bv2)[(i - length(bv1))]))));

% concat_value_out
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, i : INT):
  (((length(bv1) + length(bv2)) < i) => ((value(concat(bv1, bv2))[i]) = (
  value(bv1)[i]))));

% concat_value_tpart
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, i : INT):
  (((length(bv1) <= i) AND (i < length(bv2))) => ((value(concat(bv1, 
  tpart(bv2, length(bv1))))[i]) = (value(bv2)[i]))));

% concat_value_ht
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, bv3 : bitvec, bv4 : bitvec, i : INT):
  (((0 <= i) AND (i < length(bv3)))
  => ((((0 <= i) AND (i < length(bv1))) => ((value(bv1)[i]) = (
      value(bv4)[i])))
     => (((length(bv1) <= i) => ((value(bv3)[i]) = (value(bv4)[i])))
        => ((bv2 = tpart(bv3, length(bv1))) => ((value(concat(bv1,
           bv2))[i]) = (value(bv4)[i])))))));

% concat_ht
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, bv3 : bitvec, bv4 : bitvec):
  ((FORALL (i : INT):
   (((0 <= i) AND (i < length(bv1))) => ((value(bv1)[i]) = (value(bv4)[i]))))
  => ((FORALL (i : INT):
      ((length(bv1) <= i) => ((value(bv3)[i]) = (value(bv4)[i]))))
     => ((length(bv4) = (length(bv1) + length(bv2)))
        => (((length(bv1) + length(bv2)) <= length(bv3))
           => ((bv2 = tpart(bv3, length(bv1))) => (concat(bv1, bv2) = bv4)))))));

% set_concat
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, bv4 : bitvec):
  ((FORALL (i : INT):
   (((0 <= i) AND (i < length(bv1))) => ((value(bv1)[i]) = (value(bv4)[i]))))
  => ((FORALL (i : INT):
      ((length(bv1) <= i) => ((value(bv2)[(i - length(bv1))]) = (
      value(bv4)[i]))))
     => ((length(bv4) = (length(bv1) + length(bv2))) => (concat(bv1,
        bv2) = bv4)))));

% concat_m
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec, i1 : INT, i2 : INT):
  ((0 < i1)
  => ((0 < i2)
     => ((length(bv1) = i1)
        => ((length(bv2) = i2) => (concat(make_bv_m(value(bv1), i1), 
           make_bv_m(value(bv2), i2)) = make_bv_m(value(concat(bv1, bv2)),
           (i1 + i2))))))));

% concat_comm
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((hpart(concat(bv1, bv2), length(bv1)) = bv1) AND (tpart(concat(bv1, bv2), 
  length(bv1)) = bv2)));

% concat_and_rec
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i <= length(bv))) => (concat(hpart(bv, i), tpart(bv,
  i)) = bv)));

% bv_decomp_ht
  ASSERT
  (FORALL (bv : bitvec, i : INT):
  (((0 <= i) AND (i <= length(bv))) => (bv = concat(hpart(bv, i), tpart(bv,
  i)))));

% bv_decomp_hhtt
  ASSERT
  (FORALL (bv : bitvec, i : INT, j : INT, k : INT):
  ((0 <= i)
  => ((0 <= j)
     => (((0 <= k) AND (k <= length(bv)))
        => ((k = (i + j)) => (bv = concat(concat(hpart(bv, i), htpart(bv, i,
           j)), tpart(bv, k))))))));

% bv_decomp_hhtt_rev
  ASSERT
  (FORALL (bv : bitvec, i : INT, j : INT, k : INT):
  ((0 <= i)
  => ((0 <= j)
     => (((0 <= k) AND (k <= length(bv)))
        => ((k = (i + j)) => (concat(concat(hpart(bv, i), htpart(bv, i, j)), 
           tpart(bv, k)) = bv))))));

concat_int_bv: (bitvec, INT, INT) -> bitvec;

% concat_int_bv'def
  ASSERT
  (FORALL (bv : bitvec, i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (concat_int_bv(bv, i, n) = 
     concat(bv, int_to_bv(i, n))))));

% concat_int_to_bv_value
  ASSERT
  (FORALL (bv : bitvec, i : INT, n : INT, j : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < length(concat_int_bv(bv, i, n))))
        => ((j < length(bv)) => ((value(concat_int_bv(bv, i, n))[j]) = (
           value(bv)[j])))))));

% bv_to_int_concat
  ASSERT
  (FORALL (bvx : bitvec, bvy : bitvec): (bv_to_int(concat(bvx, bvy)) = ((
  power(2, length(bvy)) * bv_to_int(bvx)) + bv_to_int(bvy))));

% concat_fin
  ASSERT
  (FORALL (f1 : (ARRAY INT OF INT), f2 : (ARRAY INT OF INT), l1 : INT,
  l2 : INT):
  ((0 <= l1)
  => ((0 <= l2)
     => ((binary(f1))
        => ((binary(f2)) => (make_bv(tb2t7(infix_at(infix_mngt(int, int),
           int, infix_at(infix_mngt(int, infix_mngt(int, int)), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, infix_mngt(int, int))), infix_mngt(int, int), 
           concat_fun_closure(int), t2tb7(f1)), t2tb7(f2)), t2tb5(l1))),
           (l1 + l2)) = concat(make_bv(f1, l1), make_bv(f2, l2))))))));

% bin_to_int_concat
  ASSERT
  (FORALL (f1 : (ARRAY INT OF INT), f2 : (ARRAY INT OF INT), l1 : INT,
  l2 : INT):
  ((0 <= l1)
  => ((0 <= l2)
     => ((binary(f1))
        => ((binary(f2)) => (bin_to_int(tb2t7(infix_at(infix_mngt(int, int),
           int, infix_at(infix_mngt(int, infix_mngt(int, int)), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, infix_mngt(int, int))), infix_mngt(int, int), 
           concat_fun_closure(int), t2tb7(f1)), t2tb7(f2)), t2tb5(l1))),
           (l1 + l2)) = ((power(2, l2) * bin_to_int(f1, l1)) + bin_to_int(f2,
           l2))))))));

inv_func: (ty, ty, uni, uni, uni, uni) -> uni;

% inv_func_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni, x3 : uni): (sort(a, inv_func(b, a, x,
  x1, x2, x3)))));

result32: (ty, ty, uni, uni) -> uni;

% result_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, bool), result32(b, a, x,
  x1)))));

% result'def
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), eqt : angle, e : INT): (tb2t2(
  infix_at(bool, int, result32(angle1, int, t2tb35(f), t2tb33(eqt)), 
  t2tb5(e))) = indic_bool(angle1, t2tb33((f[e])), t2tb33(eqt))));

% result'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), eqt : INT, e : INT): (tb2t2(infix_at(bool,
  int, result32(int, int, t2tb7(f), t2tb5(eqt)), t2tb5(e))) = indic_bool(int, 
  t2tb5((f[e])), t2tb5(eqt))));

% result'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, eqt : uni, e : uni): (tb2t2(infix_at(bool, a, result32(b,
  a, f, eqt), e)) = indic_bool(b, infix_at(b, a, f, e), eqt))));

% inv_func'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni, eqt : uni):
  ((p_bijective(b, a, f, s2, sqt))
  => ((mem(b, eqt, sqt)) => (inv_func(b, a, f, s2, sqt, eqt) = element(a, 
     my_filter(a, s2, result32(b, a, f, eqt))))))));

% inv_func'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle,
  eqt : angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => ((mem(angle1, t2tb33(eqt), t2tb71(sqt)))
     => ((mem(int, inv_func(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt), 
        t2tb33(eqt)), t2tb6(s2))) AND ((f[tb2t5(inv_func(angle1, int, 
        t2tb35(f), t2tb6(s2), t2tb71(sqt), t2tb33(eqt)))]) = eqt)))));

% inv_func'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int, eqt : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => ((mem(int, t2tb5(eqt), t2tb6(sqt)))
     => ((mem(int, inv_func(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt), 
        t2tb5(eqt)), t2tb6(s2))) AND ((f[tb2t5(inv_func(int, int, t2tb7(f), 
        t2tb6(s2), t2tb6(sqt), t2tb5(eqt)))]) = eqt)))));

% inv_func'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni, eqt : uni):
  ((sort(b, eqt))
  => ((p_bijective(b, a, f, s2, sqt))
     => ((mem(b, eqt, sqt))
        => ((mem(a, inv_func(b, a, f, s2, sqt, eqt), s2)) AND (infix_at(b, a,
           f, inv_func(b, a, f, s2, sqt, eqt)) = eqt)))))));

inv_func_closure: (ty, ty) -> uni;

% inv_func_closure_sort
  ASSERT
  (FORALL (a : ty, b : ty): (sort(infix_mngt(infix_mngt(a, b), infix_mngt(
  set(a), infix_mngt(set(b), infix_mngt(b, a)))), inv_func_closure(b, a))));

t2tb81: ((ARRAY set_int OF (ARRAY INT OF angle))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY set_int OF (ARRAY INT OF angle))): (sort(infix_mngt(
  set(int), infix_mngt(int, angle1)), t2tb81(x))));

tb2t81: (uni) -> (ARRAY set_int OF (ARRAY INT OF angle));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY set_int OF (ARRAY INT OF angle))):PATTERN (t2tb81(i)): 
  (tb2t81(t2tb81(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb81(tb2t81(j))): 
  ((sort(infix_mngt(set(int), infix_mngt(int, angle1)), j)) => (t2tb81(
  tb2t81(j)) = j)));

t2tb82: ((ARRAY set_angle OF (ARRAY set_int OF (ARRAY INT OF angle)))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY set_angle OF (ARRAY set_int OF (ARRAY INT OF angle)))):
  (sort(infix_mngt(set(angle1), infix_mngt(set(int), infix_mngt(int,
  angle1))), t2tb82(x))));

tb2t82: (uni) -> (ARRAY set_angle OF (ARRAY set_int OF (ARRAY INT OF angle)));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY set_angle OF (ARRAY set_int OF (ARRAY INT OF angle)))):PATTERN (
  t2tb82(i)):  (tb2t82(t2tb82(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb82(tb2t82(j))): 
  ((sort(infix_mngt(set(angle1), infix_mngt(set(int), infix_mngt(int,
  angle1))), j)) => (t2tb82(tb2t82(j)) = j)));

t2tb83: ((ARRAY (ARRAY angle OF INT) OF (ARRAY set_angle OF (ARRAY set_int OF (ARRAY INT OF angle))))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY (ARRAY angle OF INT) OF (ARRAY set_angle OF (ARRAY set_int OF (ARRAY INT OF angle))))):
  (sort(infix_mngt(infix_mngt(angle1, int), infix_mngt(set(angle1), 
  infix_mngt(set(int), infix_mngt(int, angle1)))), t2tb83(x))));

tb2t83: (uni) -> (ARRAY (ARRAY angle OF INT) OF (ARRAY set_angle OF (ARRAY set_int OF (ARRAY INT OF angle))));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY (ARRAY angle OF INT) OF (ARRAY set_angle OF (ARRAY set_int OF (ARRAY INT OF angle))))):PATTERN (
  t2tb83(i)):  (tb2t83(t2tb83(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb83(tb2t83(j))): 
  ((sort(infix_mngt(infix_mngt(angle1, int), infix_mngt(set(angle1), 
  infix_mngt(set(int), infix_mngt(int, angle1)))), j)) => (t2tb83(
  tb2t83(j)) = j)));

% inv_func_closure_def
  ASSERT
  (FORALL (y : (ARRAY angle OF INT), y1 : set_angle, y2 : set_int, y3 : INT):
  ((tb2t35(infix_at(infix_mngt(int, angle1), set(int), infix_at(infix_mngt(
  set(int), infix_mngt(int, angle1)), set(angle1), infix_at(infix_mngt(
  set(angle1), infix_mngt(set(int), infix_mngt(int, angle1))), 
  infix_mngt(angle1, int), inv_func_closure(int, angle1), t2tb72(y)), 
  t2tb71(y1)), t2tb6(y2)))[y3]) = tb2t33(inv_func(int, angle1, t2tb72(y), 
  t2tb71(y1), t2tb6(y2), t2tb5(y3)))));

t2tb84: ((ARRAY set_int OF (ARRAY INT OF INT))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY set_int OF (ARRAY INT OF INT))): (sort(infix_mngt(
  set(int), infix_mngt(int, int)), t2tb84(x))));

tb2t84: (uni) -> (ARRAY set_int OF (ARRAY INT OF INT));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY set_int OF (ARRAY INT OF INT))):PATTERN (t2tb84(i)):  (
  tb2t84(t2tb84(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb84(tb2t84(j))):  (t2tb84(tb2t84(j)) = j));

t2tb85: ((ARRAY set_int OF (ARRAY set_int OF (ARRAY INT OF INT)))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY set_int OF (ARRAY set_int OF (ARRAY INT OF INT)))):
  (sort(infix_mngt(set(int), infix_mngt(set(int), infix_mngt(int, int))), 
  t2tb85(x))));

tb2t85: (uni) -> (ARRAY set_int OF (ARRAY set_int OF (ARRAY INT OF INT)));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY set_int OF (ARRAY set_int OF (ARRAY INT OF INT)))):PATTERN (
  t2tb85(i)):  (tb2t85(t2tb85(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb85(tb2t85(j))):  (t2tb85(tb2t85(j)) = j));

t2tb86: ((ARRAY (ARRAY INT OF INT) OF (ARRAY set_int OF (ARRAY set_int OF (ARRAY INT OF INT))))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY (ARRAY INT OF INT) OF (ARRAY set_int OF (ARRAY set_int OF (ARRAY INT OF INT))))):
  (sort(infix_mngt(infix_mngt(int, int), infix_mngt(set(int), infix_mngt(
  set(int), infix_mngt(int, int)))), t2tb86(x))));

tb2t86: (uni) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY set_int OF (ARRAY set_int OF (ARRAY INT OF INT))));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY (ARRAY INT OF INT) OF (ARRAY set_int OF (ARRAY set_int OF (ARRAY INT OF INT))))):PATTERN (
  t2tb86(i)):  (tb2t86(t2tb86(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb86(tb2t86(j))):  (t2tb86(tb2t86(j)) = j));

% inv_func_closure_def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), y1 : set_int, y2 : set_int, y3 : INT): ((
  tb2t7(infix_at(infix_mngt(int, int), set(int), infix_at(infix_mngt(
  set(int), infix_mngt(int, int)), set(int), infix_at(infix_mngt(set(int), 
  infix_mngt(set(int), infix_mngt(int, int))), infix_mngt(int, int), 
  inv_func_closure(int, int), t2tb7(y)), t2tb6(y1)), t2tb6(y2)))[y3]) = 
  tb2t5(inv_func(int, int, t2tb7(y), t2tb6(y1), t2tb6(y2), t2tb5(y3)))));

% inv_func_closure_def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (y : uni, y1 : uni, y2 : uni, y3 : uni): (infix_at(a, b, infix_at(
  infix_mngt(b, a), set(b), infix_at(infix_mngt(set(b), infix_mngt(b, a)), 
  set(a), infix_at(infix_mngt(set(a), infix_mngt(set(b), infix_mngt(b, a))), 
  infix_mngt(a, b), inv_func_closure(b, a), y), y1), y2), y3) = inv_func(b,
  a, y, y1, y2, y3))));

% bijective_inv_func
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_bijective(b, a, f, s2, sqt)) => (p_bijective(a, b, infix_at(
  infix_mngt(b, a), set(b), infix_at(infix_mngt(set(b), infix_mngt(b, a)), 
  set(a), infix_at(infix_mngt(set(a), infix_mngt(set(b), infix_mngt(b, a))), 
  infix_mngt(a, b), inv_func_closure(b, a), f), s2), sqt), sqt, s2)))));

% inv_rec
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle, e : INT):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => ((mem(int, t2tb5(e), t2tb6(s2))) => (tb2t5(inv_func(angle1, int, 
     t2tb35(f), t2tb6(s2), t2tb71(sqt), t2tb33((f[e])))) = e))));

% inv_rec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int, e : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => ((mem(int, t2tb5(e), t2tb6(s2))) => (tb2t5(inv_func(int, int, t2tb7(f), 
     t2tb6(s2), t2tb6(sqt), t2tb5((f[e])))) = e))));

% inv_rec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni, e : uni):
  ((sort(a, e))
  => ((p_bijective(b, a, f, s2, sqt))
     => ((mem(a, e, s2)) => (inv_func(b, a, f, s2, sqt, infix_at(b, a, f,
        e)) = e))))));

inv_: (ty, ty, uni, uni, uni, uni) -> uni;

% inv__sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni, x3 : uni): (sort(a, inv_(b, a, x, x1,
  x2, x3)))));

% inv_'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni, e : uni):
  ((p_bijective(b, a, f, s2, sqt))
  => ((mem(b, e, sqt)) => (inv_(b, a, f, s2, sqt, e) = inv_func(b, a, f, s2,
     sqt, e))))));

% inv_'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle,
  e : angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => ((mem(angle1, t2tb33(e), t2tb71(sqt)))
     => ((mem(int, inv_(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt), 
        t2tb33(e)), t2tb6(s2))) AND ((f[tb2t5(inv_(angle1, int, t2tb35(f), 
        t2tb6(s2), t2tb71(sqt), t2tb33(e)))]) = e)))));

% inv_'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int, e : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => ((mem(int, t2tb5(e), t2tb6(sqt)))
     => ((mem(int, inv_(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt), t2tb5(e)), 
        t2tb6(s2))) AND ((f[tb2t5(inv_(int, int, t2tb7(f), t2tb6(s2), 
        t2tb6(sqt), t2tb5(e)))]) = e)))));

% inv_'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni, e : uni):
  ((sort(b, e))
  => ((p_bijective(b, a, f, s2, sqt))
     => ((mem(b, e, sqt))
        => ((mem(a, inv_(b, a, f, s2, sqt, e), s2)) AND (infix_at(b, a, f, 
           inv_(b, a, f, s2, sqt, e)) = e)))))));

inv__closure: (ty, ty) -> uni;

% inv__closure_sort
  ASSERT
  (FORALL (a : ty, b : ty): (sort(infix_mngt(infix_mngt(a, b), infix_mngt(
  set(a), infix_mngt(set(b), infix_mngt(b, a)))), inv__closure(b, a))));

% inv__closure_def
  ASSERT
  (FORALL (y : (ARRAY angle OF INT), y1 : set_angle, y2 : set_int, y3 : INT):
  ((tb2t35(infix_at(infix_mngt(int, angle1), set(int), infix_at(infix_mngt(
  set(int), infix_mngt(int, angle1)), set(angle1), infix_at(infix_mngt(
  set(angle1), infix_mngt(set(int), infix_mngt(int, angle1))), 
  infix_mngt(angle1, int), inv__closure(int, angle1), t2tb72(y)), 
  t2tb71(y1)), t2tb6(y2)))[y3]) = tb2t33(inv_(int, angle1, t2tb72(y), 
  t2tb71(y1), t2tb6(y2), t2tb5(y3)))));

% inv__closure_def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), y1 : set_int, y2 : set_int, y3 : INT): ((
  tb2t7(infix_at(infix_mngt(int, int), set(int), infix_at(infix_mngt(
  set(int), infix_mngt(int, int)), set(int), infix_at(infix_mngt(set(int), 
  infix_mngt(set(int), infix_mngt(int, int))), infix_mngt(int, int), 
  inv__closure(int, int), t2tb7(y)), t2tb6(y1)), t2tb6(y2)))[y3]) = tb2t5(
  inv_(int, int, t2tb7(y), t2tb6(y1), t2tb6(y2), t2tb5(y3)))));

% inv__closure_def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (y : uni, y1 : uni, y2 : uni, y3 : uni): (infix_at(a, b, infix_at(
  infix_mngt(b, a), set(b), infix_at(infix_mngt(set(b), infix_mngt(b, a)), 
  set(a), infix_at(infix_mngt(set(a), infix_mngt(set(b), infix_mngt(b, a))), 
  infix_mngt(a, b), inv__closure(b, a), y), y1), y2), y3) = inv_(b, a, y, y1,
  y2, y3))));

% inv_bijective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_bijective(b, a, f, s2, sqt)) => (p_bijective(a, b, infix_at(
  infix_mngt(b, a), set(b), infix_at(infix_mngt(set(b), infix_mngt(b, a)), 
  set(a), infix_at(infix_mngt(set(a), infix_mngt(set(b), infix_mngt(b, a))), 
  infix_mngt(a, b), inv__closure(b, a), f), s2), sqt), sqt, s2)))));

% set_bijective_inv
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), g : (ARRAY INT OF angle),
  s2 : set_angle, b : INT):
  ((mem(int, t2tb5(b), map(int, angle1, t2tb72(f), t2tb71(s2))))
  => ((FORALL (e : angle, eqt : angle):
      ((mem(angle1, t2tb33(e), t2tb71(s2)))
      => ((mem(angle1, t2tb33(eqt), t2tb71(s2)))
         => ((NOT (e = eqt))
            => (NOT (tb2t5(infix_at(int, angle1, t2tb72(f), t2tb33(e))) = 
               tb2t5(infix_at(int, angle1, t2tb72(f), t2tb33(eqt)))))))))
     => ((FORALL (eqt : INT):
         ((mem(int, t2tb5(eqt), map(int, angle1, t2tb72(f), t2tb71(s2))))
         => ((mem(angle1, t2tb33((g[eqt])), t2tb71(s2))) AND (tb2t5(
            infix_at(int, angle1, t2tb72(f), t2tb33((g[eqt])))) = eqt))))
        => ((p_bijective(int, angle1, t2tb72(f), t2tb71(s2), map(int, angle1, 
           t2tb72(f), t2tb71(s2)))) AND (tb2t33(inv_func(int, angle1, 
           t2tb72(f), t2tb71(s2), map(int, angle1, t2tb72(f), t2tb71(s2)), 
           t2tb5(b))) = (g[b])))))));

% set_bijective_inv
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY angle OF INT), s2 : set_int,
  b : angle):
  ((mem(angle1, t2tb33(b), map(angle1, int, t2tb35(f), t2tb6(s2))))
  => ((FORALL (e : INT, eqt : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(int, t2tb5(eqt), t2tb6(s2)))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
     => ((FORALL (eqt : angle):
         ((mem(angle1, t2tb33(eqt), map(angle1, int, t2tb35(f), t2tb6(s2))))
         => ((mem(int, infix_at(int, angle1, t2tb72(g), t2tb33(eqt)), 
            t2tb6(s2))) AND ((f[tb2t5(infix_at(int, angle1, t2tb72(g), 
            t2tb33(eqt)))]) = eqt))))
        => ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), map(angle1, int, 
           t2tb35(f), t2tb6(s2)))) AND (tb2t5(inv_func(angle1, int, 
           t2tb35(f), t2tb6(s2), map(angle1, int, t2tb35(f), t2tb6(s2)), 
           t2tb33(b))) = tb2t5(infix_at(int, angle1, t2tb72(g), t2tb33(b)))))))));

% set_bijective_inv
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), s2 : set_int,
  b : INT):
  ((mem(int, t2tb5(b), map(int, int, t2tb7(f), t2tb6(s2))))
  => ((FORALL (e : INT, eqt : INT):
      ((mem(int, t2tb5(e), t2tb6(s2)))
      => ((mem(int, t2tb5(eqt), t2tb6(s2)))
         => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
     => ((FORALL (eqt : INT):
         ((mem(int, t2tb5(eqt), map(int, int, t2tb7(f), t2tb6(s2))))
         => ((mem(int, t2tb5((g[eqt])), t2tb6(s2)))
            AND ((f[(g[eqt])]) = eqt))))
        => ((p_bijective(int, int, t2tb7(f), t2tb6(s2), map(int, int, 
           t2tb7(f), t2tb6(s2)))) AND (tb2t5(inv_func(int, int, t2tb7(f), 
           t2tb6(s2), map(int, int, t2tb7(f), t2tb6(s2)), 
           t2tb5(b))) = (g[b])))))));

% set_bijective_inv
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, g : uni, s2 : uni, b1 : uni):
  ((mem(b, b1, map(b, a, f, s2)))
  => ((FORALL (e : uni, eqt : uni):
      ((sort(a, e))
      => ((sort(a, eqt))
         => ((mem(a, e, s2))
            => ((mem(a, eqt, s2))
               => ((NOT (e = eqt))
                  => (NOT (infix_at(b, a, f, e) = infix_at(b, a, f, eqt)))))))))
     => ((FORALL (eqt : uni):
         ((sort(b, eqt))
         => ((mem(b, eqt, map(b, a, f, s2)))
            => ((mem(a, infix_at(a, b, g, eqt), s2)) AND (infix_at(b, a, f, 
               infix_at(a, b, g, eqt)) = eqt)))))
        => ((p_bijective(b, a, f, s2, map(b, a, f, s2))) AND (inv_func(b, a,
           f, s2, map(b, a, f, s2), b1) = infix_at(a, b, g, b1))))))));

% set_bij_inv
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), g : (ARRAY INT OF angle),
  s2 : set_angle):
  ((FORALL (e : angle, eqt : angle):
   ((mem(angle1, t2tb33(e), t2tb71(s2)))
   => ((mem(angle1, t2tb33(eqt), t2tb71(s2)))
      => ((NOT (e = eqt))
         => (NOT (tb2t5(infix_at(int, angle1, t2tb72(f), t2tb33(e))) = tb2t5(
            infix_at(int, angle1, t2tb72(f), t2tb33(eqt)))))))))
  => ((FORALL (eqt : INT):
      ((mem(int, t2tb5(eqt), map(int, angle1, t2tb72(f), t2tb71(s2))))
      => ((mem(angle1, t2tb33((g[eqt])), t2tb71(s2))) AND (tb2t5(
         infix_at(int, angle1, t2tb72(f), t2tb33((g[eqt])))) = eqt))))
     => ((p_bijective(int, angle1, t2tb72(f), t2tb71(s2), map(int, angle1, 
        t2tb72(f), t2tb71(s2))))
        AND ((p_bijective(angle1, int, t2tb35(g), map(int, angle1, t2tb72(f), 
            t2tb71(s2)), t2tb71(s2)))
            AND (FORALL (b : INT):
                ((mem(int, t2tb5(b), map(int, angle1, t2tb72(f), 
                t2tb71(s2)))) => (tb2t33(inv_func(int, angle1, t2tb72(f), 
                t2tb71(s2), map(int, angle1, t2tb72(f), t2tb71(s2)), 
                t2tb5(b))) = (g[b])))))))));

% set_bij_inv
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), g : (ARRAY angle OF INT), s2 : set_int):
  ((FORALL (e : INT, eqt : INT):
   ((mem(int, t2tb5(e), t2tb6(s2)))
   => ((mem(int, t2tb5(eqt), t2tb6(s2)))
      => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
  => ((FORALL (eqt : angle):
      ((mem(angle1, t2tb33(eqt), map(angle1, int, t2tb35(f), t2tb6(s2))))
      => ((mem(int, infix_at(int, angle1, t2tb72(g), t2tb33(eqt)), 
         t2tb6(s2))) AND ((f[tb2t5(infix_at(int, angle1, t2tb72(g), 
         t2tb33(eqt)))]) = eqt))))
     => ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), map(angle1, int, 
        t2tb35(f), t2tb6(s2))))
        AND ((p_bijective(int, angle1, t2tb72(g), map(angle1, int, t2tb35(f), 
            t2tb6(s2)), t2tb6(s2)))
            AND (FORALL (b : angle):
                ((mem(angle1, t2tb33(b), map(angle1, int, t2tb35(f), 
                t2tb6(s2)))) => (tb2t5(inv_func(angle1, int, t2tb35(f), 
                t2tb6(s2), map(angle1, int, t2tb35(f), t2tb6(s2)), 
                t2tb33(b))) = tb2t5(infix_at(int, angle1, t2tb72(g), 
                t2tb33(b)))))))))));

% set_bij_inv
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), g : (ARRAY INT OF INT), s2 : set_int):
  ((FORALL (e : INT, eqt : INT):
   ((mem(int, t2tb5(e), t2tb6(s2)))
   => ((mem(int, t2tb5(eqt), t2tb6(s2)))
      => ((NOT (e = eqt)) => (NOT ((f[e]) = (f[eqt])))))))
  => ((FORALL (eqt : INT):
      ((mem(int, t2tb5(eqt), map(int, int, t2tb7(f), t2tb6(s2))))
      => ((mem(int, t2tb5((g[eqt])), t2tb6(s2))) AND ((f[(g[eqt])]) = eqt))))
     => ((p_bijective(int, int, t2tb7(f), t2tb6(s2), map(int, int, t2tb7(f), 
        t2tb6(s2))))
        AND ((p_bijective(int, int, t2tb7(g), map(int, int, t2tb7(f), 
            t2tb6(s2)), t2tb6(s2)))
            AND (FORALL (b : INT):
                ((mem(int, t2tb5(b), map(int, int, t2tb7(f), t2tb6(s2))))
                => (tb2t5(inv_func(int, int, t2tb7(f), t2tb6(s2), map(int,
                int, t2tb7(f), t2tb6(s2)), t2tb5(b))) = (g[b])))))))));

% set_bij_inv
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, g : uni, s2 : uni):
  ((FORALL (e : uni, eqt : uni):
   ((sort(a, e))
   => ((sort(a, eqt))
      => ((mem(a, e, s2))
         => ((mem(a, eqt, s2))
            => ((NOT (e = eqt))
               => (NOT (infix_at(b, a, f, e) = infix_at(b, a, f, eqt)))))))))
  => ((FORALL (eqt : uni):
      ((sort(b, eqt))
      => ((mem(b, eqt, map(b, a, f, s2)))
         => ((mem(a, infix_at(a, b, g, eqt), s2)) AND (infix_at(b, a, f, 
            infix_at(a, b, g, eqt)) = eqt)))))
     => ((p_bijective(b, a, f, s2, map(b, a, f, s2)))
        AND ((p_bijective(a, b, g, map(b, a, f, s2), s2))
            AND (FORALL (b1 : uni):
                ((mem(b, b1, map(b, a, f, s2))) => (inv_func(b, a, f, s2, 
                map(b, a, f, s2), b1) = infix_at(a, b, g, b1))))))))));

inv_f: (ty, ty, uni, uni, uni) -> uni;

% inv_f_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni, x2 : uni): (sort(infix_mngt(b, a), inv_f(b, a,
  x, x1, x2)))));

% inv_f'spec
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), s2 : set_angle, sqt : set_int):
  ((p_bijective(int, angle1, t2tb72(f), t2tb71(s2), t2tb6(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(sqt))) => (mem(angle1, t2tb33((tb2t35(
      inv_f(int, angle1, t2tb72(f), t2tb71(s2), t2tb6(sqt)))[e])), 
      t2tb71(s2)))))
     AND ((FORALL (e : INT):
          ((mem(int, t2tb5(e), t2tb6(sqt))) => (tb2t5(infix_at(int, angle1, 
          t2tb72(f), t2tb33((tb2t35(inv_f(int, angle1, t2tb72(f), t2tb71(s2), 
          t2tb6(sqt)))[e])))) = e)))
         AND (p_bijective(angle1, int, inv_f(int, angle1, t2tb72(f), 
         t2tb71(s2), t2tb6(sqt)), t2tb6(sqt), t2tb71(s2)))))));

% inv_f'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))
  => ((FORALL (e : angle):
      ((mem(angle1, t2tb33(e), t2tb71(sqt))) => (mem(int, infix_at(int,
      angle1, inv_f(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)), 
      t2tb33(e)), t2tb6(s2)))))
     AND ((FORALL (e : angle):
          ((mem(angle1, t2tb33(e), t2tb71(sqt))) => ((f[tb2t5(infix_at(int,
          angle1, inv_f(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)), 
          t2tb33(e)))]) = e)))
         AND (p_bijective(int, angle1, inv_f(angle1, int, t2tb35(f), 
         t2tb6(s2), t2tb71(sqt)), t2tb71(sqt), t2tb6(s2)))))));

% inv_f'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(sqt))) => (mem(int, t2tb5((tb2t7(inv_f(int,
      int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))[e])), t2tb6(s2)))))
     AND ((FORALL (e : INT):
          ((mem(int, t2tb5(e), t2tb6(sqt))) => ((f[(tb2t7(inv_f(int, int, 
          t2tb7(f), t2tb6(s2), t2tb6(sqt)))[e])]) = e)))
         AND (p_bijective(int, int, inv_f(int, int, t2tb7(f), t2tb6(s2), 
         t2tb6(sqt)), t2tb6(sqt), t2tb6(s2)))))));

% inv_f'spec
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_bijective(b, a, f, s2, sqt))
  => ((FORALL (e : uni):
      ((mem(b, e, sqt)) => (mem(a, infix_at(a, b, inv_f(b, a, f, s2, sqt),
      e), s2))))
     AND ((FORALL (e : uni):
          ((sort(b, e))
          => ((mem(b, e, sqt)) => (infix_at(b, a, f, infix_at(a, b, inv_f(b,
             a, f, s2, sqt), e)) = e))))
         AND (p_bijective(a, b, inv_f(b, a, f, s2, sqt), sqt, s2)))))));

% inv_f_back
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), s2 : set_angle, sqt : set_int, e : INT):
  ((mem(int, t2tb5(e), t2tb6(sqt)))
  => ((p_bijective(int, angle1, t2tb72(f), t2tb71(s2), t2tb6(sqt))) => (
     tb2t5(infix_at(int, angle1, t2tb72(f), t2tb33((tb2t35(inv_f(int, angle1, 
     t2tb72(f), t2tb71(s2), t2tb6(sqt)))[e])))) = e))));

% inv_f_back
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle,
  e : angle):
  ((mem(angle1, t2tb33(e), t2tb71(sqt)))
  => ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt))) => ((f[
     tb2t5(infix_at(int, angle1, inv_f(angle1, int, t2tb35(f), t2tb6(s2), 
     t2tb71(sqt)), t2tb33(e)))]) = e))));

% inv_f_back
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int, e : INT):
  ((mem(int, t2tb5(e), t2tb6(sqt)))
  => ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt))) => ((f[(tb2t7(
     inv_f(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))[e])]) = e))));

% inv_f_back
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni, e : uni):
  ((sort(b, e))
  => ((mem(b, e, sqt))
     => ((p_bijective(b, a, f, s2, sqt)) => (infix_at(b, a, f, infix_at(a, b, 
        inv_f(b, a, f, s2, sqt), e)) = e))))));

% inv_f_back_rev
  ASSERT
  (FORALL (f : (ARRAY angle OF INT), s2 : set_angle, sqt : set_int,
  e : angle):
  ((mem(angle1, t2tb33(e), t2tb71(s2)))
  => ((p_bijective(int, angle1, t2tb72(f), t2tb71(s2), t2tb6(sqt))) => ((
     tb2t35(inv_f(int, angle1, t2tb72(f), t2tb71(s2), t2tb6(sqt)))[tb2t5(
     infix_at(int, angle1, t2tb72(f), t2tb33(e)))]) = e))));

% inv_f_back_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle, e : INT):
  ((mem(int, t2tb5(e), t2tb6(s2)))
  => ((p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt))) => (
     tb2t5(infix_at(int, angle1, inv_f(angle1, int, t2tb35(f), t2tb6(s2), 
     t2tb71(sqt)), t2tb33((f[e])))) = e))));

% inv_f_back_rev
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int, e : INT):
  ((mem(int, t2tb5(e), t2tb6(s2)))
  => ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt))) => ((tb2t7(
     inv_f(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))[(f[e])]) = e))));

% inv_f_back_rev
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni, e : uni):
  ((sort(a, e))
  => ((mem(a, e, s2))
     => ((p_bijective(b, a, f, s2, sqt)) => (infix_at(a, b, inv_f(b, a, f,
        s2, sqt), infix_at(b, a, f, e)) = e))))));

% injective_is_bijective
  ASSERT
  (FORALL (f : (ARRAY INT OF angle), s2 : set_int, sqt : set_angle):
  ((p_injective(angle1, int, t2tb35(f), t2tb6(s2)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(angle1, t2tb33((f[e])), 
      t2tb71(sqt)))))
     => ((cardinal(int, t2tb6(s2)) = cardinal(angle1, t2tb71(sqt)))
        => (p_bijective(angle1, int, t2tb35(f), t2tb6(s2), t2tb71(sqt)))))));

% injective_is_bijective
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int):
  ((p_injective(int, int, t2tb7(f), t2tb6(s2)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), 
      t2tb6(sqt)))))
     => ((cardinal(int, t2tb6(s2)) = cardinal(int, t2tb6(sqt)))
        => (p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))))));

% injective_is_bijective
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, sqt : uni):
  ((p_injective(b, a, f, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (mem(b, infix_at(b, a, f, e), sqt)))))
     => ((cardinal(a, s2) = cardinal(b, sqt)) => (p_bijective(b, a, f, s2,
        sqt)))))));

% injective_is_bijective_auto
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  ((p_injective(int, int, t2tb7(f), t2tb6(s2)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), 
      t2tb6(s2)))))
     => ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(s2))) AND (tb2t6(
        map(int, int, t2tb7(f), t2tb6(s2))) = s2)))));

% injective_is_bijective_auto
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((sort(set(a), s2))
  => ((p_injective(a, a, f, s2))
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (mem(a, infix_at(a, a, f, e), s2)))))
        => ((p_bijective(a, a, f, s2, s2)) AND (map(a, a, f, s2) = s2)))))));

inv_auto: (ty, uni, uni) -> uni;

% inv_auto_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, a), inv_auto(a, x, x1)))));

% inv_auto'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  ((p_injective(int, int, t2tb7(f), t2tb6(s2)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), 
      t2tb6(s2)))))
     => (tb2t7(inv_auto(int, t2tb7(f), t2tb6(s2))) = tb2t7(inv_f(int, int, 
     t2tb7(f), t2tb6(s2), t2tb6(s2)))))));

% inv_auto'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((p_injective(a, a, f, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (mem(a, infix_at(a, a, f, e), s2)))))
     => (inv_auto(a, f, s2) = inv_f(a, a, f, s2, s2))))));

% inv_auto'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int):
  ((p_injective(int, int, t2tb7(f), t2tb6(s2)))
  => ((FORALL (e : INT):
      ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((f[e])), 
      t2tb6(s2)))))
     => ((FORALL (e : INT):
         ((mem(int, t2tb5(e), t2tb6(s2))) => (mem(int, t2tb5((tb2t7(
         inv_auto(int, t2tb7(f), t2tb6(s2)))[e])), t2tb6(s2)))))
        AND ((FORALL (e : INT):
             ((mem(int, t2tb5(e), t2tb6(s2))) => ((f[(tb2t7(inv_auto(int, 
             t2tb7(f), t2tb6(s2)))[e])]) = e)))
            AND (p_bijective(int, int, inv_auto(int, t2tb7(f), t2tb6(s2)), 
            t2tb6(s2), t2tb6(s2))))))));

% inv_auto'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni):
  ((p_injective(a, a, f, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (mem(a, infix_at(a, a, f, e), s2)))))
     => ((FORALL (e : uni):
         ((mem(a, e, s2)) => (mem(a, infix_at(a, a, inv_auto(a, f, s2), e),
         s2))))
        AND ((FORALL (e : uni):
             ((sort(a, e))
             => ((mem(a, e, s2)) => (infix_at(a, a, f, infix_at(a, a, 
                inv_auto(a, f, s2), e)) = e))))
            AND (p_bijective(a, a, inv_auto(a, f, s2), s2, s2))))))));

lpbitveccm_bitvecrp: TYPE;

fc295: (ARRAY lpbitveccm_bitvecrp OF bitvec);

fc296: (INT) -> (ARRAY bitvec OF lpbitveccm_bitvecrp);

t2tb40: ((ARRAY lpbitveccm_bitvecrp OF bitvec)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY lpbitveccm_bitvecrp OF bitvec)): (sort(infix_mngt(
  tuple2(bitvec1, bitvec1), bitvec1), t2tb40(x))));

tb2t40: (uni) -> (ARRAY lpbitveccm_bitvecrp OF bitvec);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY lpbitveccm_bitvecrp OF bitvec)):PATTERN (t2tb40(i)):  (
  tb2t40(t2tb40(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb40(tb2t40(j))): 
  ((sort(infix_mngt(tuple2(bitvec1, bitvec1), bitvec1), j)) => (t2tb40(
  tb2t40(j)) = j)));

t2tb41: (lpbitveccm_bitvecrp) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : lpbitveccm_bitvecrp): (sort(tuple2(bitvec1, bitvec1), 
  t2tb41(x))));

tb2t41: (uni) -> lpbitveccm_bitvecrp;

% BridgeL
  ASSERT
  (FORALL (i : lpbitveccm_bitvecrp):PATTERN (t2tb41(i)):  (tb2t41(
  t2tb41(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb41(tb2t41(j))): 
  ((sort(tuple2(bitvec1, bitvec1), j)) => (t2tb41(tb2t41(j)) = j)));

% fc'def
  ASSERT
  (FORALL (o : lpbitveccm_bitvecrp): (tb2t26(infix_at(bitvec1, 
  tuple2(bitvec1, bitvec1), t2tb40(fc295), t2tb41(o))) = concat(tb2t26(
  fir(bitvec1, bitvec1, t2tb41(o))), tb2t26(sec(bitvec1, bitvec1, 
  t2tb41(o))))));

t2tb42: ((ARRAY bitvec OF lpbitveccm_bitvecrp)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF lpbitveccm_bitvecrp)): (sort(
  infix_mngt(bitvec1, tuple2(bitvec1, bitvec1)), t2tb42(x))));

tb2t42: (uni) -> (ARRAY bitvec OF lpbitveccm_bitvecrp);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF lpbitveccm_bitvecrp)):PATTERN (t2tb42(i)):  (
  tb2t42(t2tb42(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb42(tb2t42(j))): 
  ((sort(infix_mngt(bitvec1, tuple2(bitvec1, bitvec1)), j)) => (t2tb42(
  tb2t42(j)) = j)));

% fc'def
  ASSERT
  (FORALL (i : INT, x : bitvec): (tb2t41(infix_at(tuple2(bitvec1, bitvec1),
  bitvec1, t2tb42(fc296(i)), t2tb26(x))) = tb2t41(Tuple2(bitvec1, bitvec1, 
  t2tb26(hpart(x, i)), t2tb26(tpart(x, i))))));

set_lpbitveccm_bitvecrp: TYPE;

t2tb43: (set_lpbitveccm_bitvecrp) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : set_lpbitveccm_bitvecrp): (sort(set(tuple2(bitvec1, bitvec1)), 
  t2tb43(x))));

tb2t43: (uni) -> set_lpbitveccm_bitvecrp;

% BridgeL
  ASSERT
  (FORALL (i : set_lpbitveccm_bitvecrp):PATTERN (t2tb43(i)):  (tb2t43(
  t2tb43(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb43(tb2t43(j))): 
  ((sort(set(tuple2(bitvec1, bitvec1)), j)) => (t2tb43(tb2t43(j)) = j)));

% bijective_concat
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 <= i)
  => ((0 <= j)
     => ((p_bijective(bitvec1, tuple2(bitvec1, bitvec1), t2tb40(fc295), 
        cartesian_product(bitvec1, bitvec1, t2tb28(n_bvs(i)), t2tb28(
        n_bvs(j))), t2tb28(n_bvs((i + j))))) AND (p_bijective(tuple2(bitvec1,
        bitvec1), bitvec1, t2tb42(fc296(i)), t2tb28(n_bvs((i + j))), 
        cartesian_product(bitvec1, bitvec1, t2tb28(n_bvs(i)), t2tb28(
        n_bvs(j)))))))));

% bv_to_int_hpart
  ASSERT
  (FORALL (bv : bitvec, l : INT):
  (((0 <= l) AND (l <= length(bv))) => (bv_to_int(hpart(bv, l)) = div(
  bv_to_int(bv), power(2, (length(bv) - l))))));

% bv_to_int_tpart
  ASSERT
  (FORALL (bv : bitvec, l : INT):
  (((0 <= l) AND (l <= length(bv))) => (bv_to_int(tpart(bv, l)) = mod(
  bv_to_int(bv), power(2, (length(bv) - l))))));

% bv_to_int_hpart_rev
  ASSERT
  (FORALL (bv : bitvec, l : INT, q : INT):
  ((q = (length(bv) - l))
  => (((0 <= l) AND (l <= length(bv))) => (div(bv_to_int(bv), power(2, q)) = 
     bv_to_int(hpart(bv, l))))));

% bv_to_int_tpart_rev
  ASSERT
  (FORALL (bv : bitvec, l : INT, q : INT):
  ((q = (length(bv) - l))
  => (((0 <= l) AND (l <= length(bv))) => (mod(bv_to_int(bv), power(2, q)) = 
     bv_to_int(tpart(bv, l))))));

ind_basis_mat: (INT, INT, INT, INT) -> matrix_complex;

result33: (INT, INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (i : INT, j : INT, k : INT, l : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), int, t2tb15(result33(i, j)), t2tb5(k)), 
  t2tb5(l))) = indic_2(int, int, t2tb5(k), t2tb5(i), t2tb5(l), t2tb5(j))));

% ind_basis_mat'def
  ASSERT
  (FORALL (i : INT, j : INT, r : INT, c : INT):
  (((0 <= i) AND (i < r))
  => (((0 <= j) AND (j < c)) => (ind_basis_mat(i, j, r, c) = tb2t18(
     make_f(complex1, r, c, t2tb15(result33(i, j))))))));

% ind_basis_mat'spec
  ASSERT
  (FORALL (i : INT, j : INT, r : INT, c : INT):
  (((0 <= i) AND (i < r))
  => (((0 <= j) AND (j < c))
     => ((rows(complex1, t2tb18(ind_basis_mat(i, j, r, c))) = r)
        AND ((columns(complex1, t2tb18(ind_basis_mat(i, j, r, c))) = c)
            AND ((FORALL (k : INT, l : INT):
                 ((valid_index(complex1, t2tb18(ind_basis_mat(i, j, r, c)),
                 k, l)) => (tb2t(get(complex1, t2tb18(ind_basis_mat(i, j, r,
                 c)), k, l)) = indic_2(int, int, t2tb5(k), t2tb5(i), 
                 t2tb5(l), t2tb5(j)))))
                AND (FORALL (o : lpintcm_intrp):
                    ((mem(tuple2(int, int), t2tb13(o), t2tb14(
                    mat_indices(complex1, t2tb18(ind_basis_mat(i, j, r,
                    c))))))
                    => ((tb2t(get(complex1, t2tb18(ind_basis_mat(i, j, r,
                       c)), tb2t5(fir(int, int, t2tb13(o))), tb2t5(sec(int,
                       int, t2tb13(o))))) = c_one)
                       <=> ((tb2t5(fir(int, int, t2tb13(o))) = i) AND (tb2t5(
                           sec(int, int, t2tb13(o))) = j)))))))))));

% ind_basis_mat_values
  ASSERT
  (FORALL (i : INT, j : INT, r : INT, c : INT):
  (((0 <= i) AND (i < r))
  => (((0 <= j) AND (j < c))
     => (FORALL (i1 : INT, j1 : INT):
        (((0 <= i1) AND (i1 < r))
        => (((0 <= j1) AND (j1 < c)) => (tb2t(get(complex1, t2tb18(
           ind_basis_mat(i, j, r, c)), i1, j1)) = indic_2(int, int, t2tb5(i), 
           t2tb5(i1), t2tb5(j), t2tb5(j1)))))))));

% unic_ind_basis_mat
  ASSERT
  (FORALL (i1 : INT, j1 : INT, i2 : INT, j2 : INT, r : INT, c : INT):
  (((0 <= i1) AND (i1 < r))
  => (((0 <= j1) AND (j1 < c))
     => (((0 <= i2) AND (i2 < r))
        => (((0 <= j2) AND (j2 < c))
           => ((ind_basis_mat(i1, j1, r, c) = ind_basis_mat(i2, j2, r, c))
              => (tb2t13(Tuple2(int, int, t2tb5(i1), t2tb5(j1))) = tb2t13(
              Tuple2(int, int, t2tb5(i2), t2tb5(j2))))))))));

basis_mat: (INT, INT) -> set_lpmatrix_complexrp;

result111: (INT, INT) -> (ARRAY lpintcm_intrp OF matrix_complex);

t2tb44: ((ARRAY lpintcm_intrp OF matrix_complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY lpintcm_intrp OF matrix_complex)): (sort(infix_mngt(
  tuple2(int, int), matrix(complex1)), t2tb44(x))));

tb2t44: (uni) -> (ARRAY lpintcm_intrp OF matrix_complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY lpintcm_intrp OF matrix_complex)):PATTERN (t2tb44(i)): 
  (tb2t44(t2tb44(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb44(tb2t44(j))): 
  ((sort(infix_mngt(tuple2(int, int), matrix(complex1)), j)) => (t2tb44(
  tb2t44(j)) = j)));

% result'def
  ASSERT
  (FORALL (r : INT, c : INT, o : lpintcm_intrp): (tb2t18(infix_at(
  matrix(complex1), tuple2(int, int), t2tb44(result111(r, c)), 
  t2tb13(o))) = (LET j = tb2t5(Tuple2_proj_21(int, int, t2tb13(o))) IN
                (LET i = tb2t5(Tuple2_proj_11(int, int, t2tb13(o))) IN
                (IF (((0 <= i) AND (i < r)) AND ((0 <= j) AND (j < c))) THEN 
                ind_basis_mat(i, j, r, c) ELSE tb2t18(make(complex1, r, c, 
                t2tb(c_zero))) ENDIF)))));

% basis_mat'def
  ASSERT
  (FORALL (r : INT, c : INT):
  ((0 < r)
  => ((0 < c) => (basis_mat(r, c) = tb2t25(map(matrix(complex1), tuple2(int,
     int), t2tb44(result111(r, c)), cartesian_product(int, int, t2tb6(
     to_fset(0, r)), t2tb6(to_fset(0, c)))))))));

fc876: (INT, INT) -> (ARRAY lpintcm_intrp OF matrix_complex);

fc877: (matrix_complex) -> (ARRAY lpintcm_intrp OF BITVECTOR(1));

% fc'def
  ASSERT
  (FORALL (r : INT, c : INT, o : lpintcm_intrp): (tb2t18(infix_at(
  matrix(complex1), tuple2(int, int), t2tb44(fc876(r, c)), t2tb13(o))) = 
  ind_basis_mat(tb2t5(fir(int, int, t2tb13(o))), tb2t5(sec(int, int, 
  t2tb13(o))), r, c)));

t2tb45: ((ARRAY lpintcm_intrp OF BITVECTOR(1))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY lpintcm_intrp OF BITVECTOR(1))): (sort(infix_mngt(
  tuple2(int, int), bool), t2tb45(x))));

tb2t45: (uni) -> (ARRAY lpintcm_intrp OF BITVECTOR(1));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY lpintcm_intrp OF BITVECTOR(1))):PATTERN (t2tb45(i)):  (
  tb2t45(t2tb45(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb45(tb2t45(j))): 
  ((sort(infix_mngt(tuple2(int, int), bool), j)) => (t2tb45(tb2t45(j)) = j)));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, x : lpintcm_intrp):
  ((tb2t2(infix_at(bool, tuple2(int, int), t2tb45(fc877(m)), 
  t2tb13(x))) = 0bin1) <=> (tb2t(get(complex1, t2tb18(m), tb2t5(fir(int, int, 
  t2tb13(x))), tb2t5(sec(int, int, t2tb13(x))))) = c_one)));

% basis_mat'spec
  ASSERT
  (FORALL (r : INT, c : INT):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (m : matrix_complex):
         ((mem(matrix(complex1), t2tb18(m), t2tb25(basis_mat(r, c))))
         <=> (EXISTS (i : INT, j : INT):
             (((0 <= i) AND (i < r))
             AND (((0 <= j) AND (j < c)) AND (m = ind_basis_mat(i, j, r, c)))))))
        AND ((basis_mat(r, c) = tb2t25(map(matrix(complex1), tuple2(int,
            int), t2tb44(fc876(r, c)), cartesian_product(int, int, t2tb6(
            to_fset(0, r)), t2tb6(to_fset(0, c))))))
            AND ((constant_size(matrix(complex1), t2tb25(basis_mat(r, c)), 
                t2tb19(identity1)))
                AND ((s_columns(matrix(complex1), t2tb25(basis_mat(r, c)), 
                    t2tb19(identity1)) = c)
                    AND ((s_rows(matrix(complex1), t2tb25(basis_mat(r, c)), 
                        t2tb19(identity1)) = r)
                        AND (FORALL (m : matrix_complex):
                            ((mem(matrix(complex1), t2tb18(m), t2tb25(
                            basis_mat(r, c)))) => (cardinal(tuple2(int, int), 
                            my_filter(tuple2(int, int), t2tb14(
                            mat_indices(complex1, t2tb18(m))), t2tb45(
                            fc877(m)))) = 1)))))))))));

basis_mat_indexes: (matrix_complex) -> lpintcm_intrp;

result112: (matrix_complex) -> (ARRAY lpintcm_intrp OF BITVECTOR(1));

% result'def
  ASSERT
  (FORALL (m : matrix_complex, x : lpintcm_intrp):
  ((tb2t2(infix_at(bool, tuple2(int, int), t2tb45(result112(m)), 
  t2tb13(x))) = 0bin1)
  <=> ((mem(tuple2(int, int), t2tb13(x), t2tb14(mat_indices(complex1, 
      t2tb18(m))))) AND (infix_eqeq(matrix(complex1), t2tb18(m), t2tb18(
      ind_basis_mat(tb2t5(fir(int, int, t2tb13(x))), tb2t5(sec(int, int, 
      t2tb13(x))), rows(complex1, t2tb18(m)), columns(complex1, 
      t2tb18(m)))))))));

% basis_mat_indexes'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((mem(matrix(complex1), t2tb18(m), t2tb25(basis_mat(rows(complex1, 
  t2tb18(m)), columns(complex1, t2tb18(m)))))) => (basis_mat_indexes(m) = 
  tb2t13(element(tuple2(int, int), my_filter(tuple2(int, int), t2tb14(
  mat_indices(complex1, t2tb18(m))), t2tb45(result112(m))))))));

fc299: (matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT): (tb2t(infix_at(complex1,
  int, infix_at(infix_mngt(int, complex1), int, t2tb15(fc299(m)), t2tb5(i)), 
  t2tb5(j))) = indic_2(int, int, fir(int, int, t2tb13(basis_mat_indexes(m))), 
  t2tb5(i), sec(int, int, t2tb13(basis_mat_indexes(m))), t2tb5(j))));

% basis_mat_indexes'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((mem(matrix(complex1), t2tb18(m), t2tb25(basis_mat(rows(complex1, 
  t2tb18(m)), columns(complex1, t2tb18(m))))))
  => ((m = ind_basis_mat(tb2t5(fir(int, int, t2tb13(basis_mat_indexes(m)))), 
     tb2t5(sec(int, int, t2tb13(basis_mat_indexes(m)))), rows(complex1, 
     t2tb18(m)), columns(complex1, t2tb18(m))))
     AND ((m = tb2t18(make_f(complex1, rows(complex1, t2tb18(m)), 
         columns(complex1, t2tb18(m)), t2tb15(fc299(m)))))
         AND ((tb2t(get(complex1, t2tb18(m), tb2t5(fir(int, int, t2tb13(
             basis_mat_indexes(m)))), tb2t5(sec(int, int, t2tb13(
             basis_mat_indexes(m)))))) = c_one)
             AND ((FORALL (i : INT, j : INT):
                  ((valid_index(complex1, t2tb18(m), i, j))
                  => ((i = tb2t5(fir(int, int, t2tb13(
                     basis_mat_indexes(m)))))
                     => ((NOT (j = tb2t5(sec(int, int, t2tb13(
                         basis_mat_indexes(m))))))
                        => (tb2t(get(complex1, t2tb18(m), i, j)) = c_zero)))))
                 AND (valid_index(complex1, t2tb18(m), tb2t5(fir(int, int, 
                 t2tb13(basis_mat_indexes(m)))), tb2t5(sec(int, int, t2tb13(
                 basis_mat_indexes(m))))))))))));

fc300: (matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT): (tb2t(infix_at(complex1,
  int, infix_at(infix_mngt(int, complex1), int, t2tb15(fc300(m)), t2tb5(i)), 
  t2tb5(j))) = indic_2(int, int, fir(int, int, t2tb13(basis_mat_indexes(m))), 
  t2tb5(i), sec(int, int, t2tb13(basis_mat_indexes(m))), t2tb5(j))));

% get_basis_mat_indexes
  ASSERT
  (FORALL (m : matrix_complex):
  ((mem(matrix(complex1), t2tb18(m), t2tb25(basis_mat(rows(complex1, 
  t2tb18(m)), columns(complex1, t2tb18(m))))))
  => ((m = ind_basis_mat(tb2t5(fir(int, int, t2tb13(basis_mat_indexes(m)))), 
     tb2t5(sec(int, int, t2tb13(basis_mat_indexes(m)))), rows(complex1, 
     t2tb18(m)), columns(complex1, t2tb18(m))))
     AND ((m = tb2t18(make_f(complex1, rows(complex1, t2tb18(m)), 
         columns(complex1, t2tb18(m)), t2tb15(fc300(m)))))
         AND ((tb2t(get(complex1, t2tb18(m), tb2t5(fir(int, int, t2tb13(
             basis_mat_indexes(m)))), tb2t5(sec(int, int, t2tb13(
             basis_mat_indexes(m)))))) = c_one)
             AND (FORALL (i : INT, j : INT):
                 ((valid_index(complex1, t2tb18(m), i, j))
                 => ((NOT (basis_mat_indexes(m) = tb2t13(Tuple2(int, int, 
                     t2tb5(i), t2tb5(j)))))
                    => (tb2t(get(complex1, t2tb18(m), i, j)) = c_zero)))))))));

fc301: (INT, INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (i : INT, j : INT, i1 : INT, j1 : INT): (tb2t(infix_at(complex1,
  int, infix_at(infix_mngt(int, complex1), int, t2tb15(fc301(i, j)), 
  t2tb5(i1)), t2tb5(j1))) = indic_2(int, int, t2tb5(i), t2tb5(i1), t2tb5(j), 
  t2tb5(j1))));

% set_basis_mat_indexes
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT):
  ((valid_index(complex1, t2tb18(m), i, j))
  => ((mem(matrix(complex1), t2tb18(m), t2tb25(basis_mat(rows(complex1, 
     t2tb18(m)), columns(complex1, t2tb18(m))))))
     => ((tb2t(get(complex1, t2tb18(m), i, j)) = c_one)
        => ((basis_mat_indexes(m) = tb2t13(Tuple2(int, int, t2tb5(i), 
           t2tb5(j))))
           AND ((m = ind_basis_mat(i, j, rows(complex1, t2tb18(m)), 
               columns(complex1, t2tb18(m))))
               AND ((m = tb2t18(make_f(complex1, rows(complex1, t2tb18(m)), 
                   columns(complex1, t2tb18(m)), t2tb15(fc301(i, j)))))
                   AND (FORALL (i1 : INT, j1 : INT):
                       ((valid_index(complex1, t2tb18(m), i1, j1))
                       => ((i1 = i)
                          => ((NOT (j1 = j)) => (tb2t(get(complex1, 
                             t2tb18(m), i1, j1)) = c_zero))))))))))));

basis_projection: (matrix_complex, INT, INT) -> matrix_complex;

% basis_projection'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT):
  (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
  => (((0 <= j) AND (j < columns(complex1, t2tb18(m)))) => (
     basis_projection(m, i, j) = infix_asdtdt(tb2t(get(complex1, t2tb18(m),
     i, j)), ind_basis_mat(i, j, rows(complex1, t2tb18(m)), columns(complex1, 
     t2tb18(m))))))));

fc302: (matrix_complex, INT, INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT, k : INT, l : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc302(m, i, j)), t2tb5(k)), t2tb5(l))) = infix_asdt(tb2t(get(complex1, 
  t2tb18(m), i, j)), indic_2(int, int, t2tb5(k), t2tb5(i), t2tb5(l), 
  t2tb5(j)))));

% basis_projection'spec
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT):
  (((0 <= i) AND (i < rows(complex1, t2tb18(m))))
  => (((0 <= j) AND (j < columns(complex1, t2tb18(m))))
     => ((rows(complex1, t2tb18(basis_projection(m, i, j))) = rows(complex1, 
        t2tb18(m)))
        AND ((columns(complex1, t2tb18(basis_projection(m, i, j))) = 
            columns(complex1, t2tb18(m)))
            AND ((basis_projection(m, i, j) = tb2t18(make_f(complex1, 
                rows(complex1, t2tb18(m)), columns(complex1, t2tb18(m)), 
                t2tb15(fc302(m, i, j)))))
                AND ((tb2t(get(complex1, t2tb18(basis_projection(m, i, j)),
                    i, j)) = tb2t(get(complex1, t2tb18(m), i, j)))
                    AND ((FORALL (iqt : INT, jqt : INT):
                         ((valid_index(complex1, t2tb18(basis_projection(m,
                         i, j)), iqt, jqt))
                         => ((NOT (iqt = i)) => (tb2t(get(complex1, t2tb18(
                            basis_projection(m, i, j)), iqt, jqt)) = c_zero))))
                        AND (FORALL (iqt : INT, jqt : INT):
                            ((valid_index(complex1, t2tb18(
                            basis_projection(m, i, j)), iqt, jqt))
                            => ((NOT (jqt = j)) => (tb2t(get(complex1, 
                               t2tb18(basis_projection(m, i, j)), iqt,
                               jqt)) = c_zero))))))))))));

% basis_projection_null
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT, k : INT, l : INT):
  ((valid_index(complex1, t2tb18(m), i, j))
  => ((valid_index(complex1, t2tb18(m), k, l))
     => (((i = k) => (NOT (j = l))) => (tb2t(get(complex1, t2tb18(
        basis_projection(m, i, j)), k, l)) = c_zero)))));

basis_projections: (matrix_complex) -> set_lpmatrix_complexrp;

result36: (matrix_complex) -> (ARRAY lpintcm_intrp OF matrix_complex);

% result'def
  ASSERT
  (FORALL (m : matrix_complex, o : lpintcm_intrp): (tb2t18(infix_at(
  matrix(complex1), tuple2(int, int), t2tb44(result36(m)), 
  t2tb13(o))) = (IF (valid_index(complex1, t2tb18(m), tb2t5(fir(int, int, 
                t2tb13(o))), tb2t5(sec(int, int, t2tb13(o))))) THEN 
                basis_projection(m, tb2t5(fir(int, int, t2tb13(o))), tb2t5(
                sec(int, int, t2tb13(o)))) ELSE m ENDIF)));

% basis_projections'def
  ASSERT
  (FORALL (m : matrix_complex): (basis_projections(m) = tb2t25(map(
  matrix(complex1), tuple2(int, int), t2tb44(result36(m)), t2tb14(
  to_indexes(complex1, t2tb18(m)))))));

couple_closure: (ty, ty, ty) -> uni;

% couple_closure_sort
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty): (sort(infix_mngt(infix_mngt(a, 
  infix_mngt(b, im1)), infix_mngt(tuple2(a, b), im1)), couple_closure(im1, b,
  a))));

basis_projection_closure: (ARRAY matrix_complex OF (ARRAY INT OF (ARRAY INT OF matrix_complex)));

% couple_closure_def
  ASSERT
  (FORALL (a : ty, b : ty, im1 : ty):
  (FORALL (y : uni, y1 : uni): (infix_at(im1, tuple2(a, b), infix_at(
  infix_mngt(tuple2(a, b), im1), infix_mngt(a, infix_mngt(b, im1)), 
  couple_closure(im1, b, a), y), y1) = couple(im1, b, a, y, y1))));

t2tb46: ((ARRAY INT OF (ARRAY INT OF matrix_complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF (ARRAY INT OF matrix_complex))): (sort(
  infix_mngt(int, infix_mngt(int, matrix(complex1))), t2tb46(x))));

tb2t46: (uni) -> (ARRAY INT OF (ARRAY INT OF matrix_complex));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF (ARRAY INT OF matrix_complex))):PATTERN (
  t2tb46(i)):  (tb2t46(t2tb46(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb46(tb2t46(j))): 
  ((sort(infix_mngt(int, infix_mngt(int, matrix(complex1))), j)) => (t2tb46(
  tb2t46(j)) = j)));

t2tb47: ((ARRAY matrix_complex OF (ARRAY INT OF (ARRAY INT OF matrix_complex)))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY matrix_complex OF (ARRAY INT OF (ARRAY INT OF matrix_complex)))):
  (sort(infix_mngt(matrix(complex1), infix_mngt(int, infix_mngt(int, 
  matrix(complex1)))), t2tb47(x))));

tb2t47: (uni) -> (ARRAY matrix_complex OF (ARRAY INT OF (ARRAY INT OF matrix_complex)));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY matrix_complex OF (ARRAY INT OF (ARRAY INT OF matrix_complex)))):PATTERN (
  t2tb47(i)):  (tb2t47(t2tb47(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb47(tb2t47(j))): 
  ((sort(infix_mngt(matrix(complex1), infix_mngt(int, infix_mngt(int, 
  matrix(complex1)))), j)) => (t2tb47(tb2t47(j)) = j)));

% basis_projection_closure_def
  ASSERT
  (FORALL (y : matrix_complex, y1 : INT, y2 : INT): (tb2t18(infix_at(
  matrix(complex1), int, infix_at(infix_mngt(int, matrix(complex1)), int, 
  infix_at(infix_mngt(int, infix_mngt(int, matrix(complex1))), 
  matrix(complex1), t2tb47(basis_projection_closure), t2tb18(y)), t2tb5(y1)), 
  t2tb5(y2))) = basis_projection(y, y1, y2)));

t2tb48: ((ARRAY (ARRAY INT OF (ARRAY INT OF matrix_complex)) OF (ARRAY lpintcm_intrp OF matrix_complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY (ARRAY INT OF (ARRAY INT OF matrix_complex)) OF (ARRAY lpintcm_intrp OF matrix_complex))):
  (sort(infix_mngt(infix_mngt(int, infix_mngt(int, matrix(complex1))), 
  infix_mngt(tuple2(int, int), matrix(complex1))), t2tb48(x))));

tb2t48: (uni) -> (ARRAY (ARRAY INT OF (ARRAY INT OF matrix_complex)) OF (ARRAY lpintcm_intrp OF matrix_complex));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY (ARRAY INT OF (ARRAY INT OF matrix_complex)) OF (ARRAY lpintcm_intrp OF matrix_complex))):PATTERN (
  t2tb48(i)):  (tb2t48(t2tb48(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb48(tb2t48(j))): 
  ((sort(infix_mngt(infix_mngt(int, infix_mngt(int, matrix(complex1))), 
  infix_mngt(tuple2(int, int), matrix(complex1))), j)) => (t2tb48(
  tb2t48(j)) = j)));

% basis_projections'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((basis_projections(m) = tb2t25(map(matrix(complex1), tuple2(int, int), 
  infix_at(infix_mngt(tuple2(int, int), matrix(complex1)), infix_mngt(int, 
  infix_mngt(int, matrix(complex1))), couple_closure(matrix(complex1), int,
  int), infix_at(infix_mngt(int, infix_mngt(int, matrix(complex1))), 
  matrix(complex1), t2tb47(basis_projection_closure), t2tb18(m))), t2tb14(
  to_indexes(complex1, t2tb18(m))))))
  AND ((FORALL (e : matrix_complex):
       ((mem(matrix(complex1), t2tb18(e), t2tb25(basis_projections(m)))) => (
       rows(complex1, t2tb18(e)) = rows(complex1, t2tb18(m)))))
      AND ((FORALL (e : matrix_complex):
           ((mem(matrix(complex1), t2tb18(e), t2tb25(basis_projections(m))))
           => (columns(complex1, t2tb18(e)) = columns(complex1, t2tb18(m)))))
          AND (constant_size(matrix(complex1), t2tb25(basis_projections(m)), 
          t2tb19(identity1)))))));

fc303: (matrix_complex) -> (ARRAY lpintcm_intrp OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : lpintcm_intrp): (tb2t18(infix_at(
  matrix(complex1), tuple2(int, int), t2tb44(fc303(m)), 
  t2tb13(o))) = (IF (valid_index(complex1, t2tb18(m), tb2t5(fir(int, int, 
                t2tb13(o))), tb2t5(sec(int, int, t2tb13(o))))) THEN 
                basis_projection(m, tb2t5(fir(int, int, t2tb13(o))), tb2t5(
                sec(int, int, t2tb13(o)))) ELSE m ENDIF)));

% rewrite_basis_projections
  ASSERT
  (FORALL (m : matrix_complex): (basis_projections(m) = tb2t25(map(
  matrix(complex1), tuple2(int, int), t2tb44(fc303(m)), t2tb14(
  to_indexes(complex1, t2tb18(m)))))));

indexes_decomp: (matrix_complex) -> matrix_complex;

result37: (matrix_complex) -> (ARRAY lpintcm_intrp OF matrix_complex);

% result'def
  ASSERT
  (FORALL (m : matrix_complex, o : lpintcm_intrp): (tb2t18(infix_at(
  matrix(complex1), tuple2(int, int), t2tb44(result37(m)), 
  t2tb13(o))) = (IF (mem(tuple2(int, int), t2tb13(o), t2tb14(
                to_indexes(complex1, t2tb18(m))))) THEN basis_projection(m, 
                tb2t5(fir(int, int, t2tb13(o))), tb2t5(sec(int, int, 
                t2tb13(o)))) ELSE m ENDIF)));

% indexes_decomp'def
  ASSERT
  (FORALL (m : matrix_complex): (indexes_decomp(m) = mat_sum(tuple2(int,
  int), t2tb14(to_indexes(complex1, t2tb18(m))), t2tb44(result37(m)))));

% indexes_decomp'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((rows(complex1, t2tb18(indexes_decomp(m))) = rows(complex1, t2tb18(m)))
  AND (columns(complex1, t2tb18(indexes_decomp(m))) = columns(complex1, 
  t2tb18(m)))));

fc304: (matrix_complex) -> (ARRAY lpintcm_intrp OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : lpintcm_intrp): (tb2t18(infix_at(
  matrix(complex1), tuple2(int, int), t2tb44(fc304(m)), t2tb13(o))) = 
  basis_projection(m, tb2t5(fir(int, int, t2tb13(o))), tb2t5(sec(int, int, 
  t2tb13(o))))));

% rewrite_indexes_decomp
  ASSERT
  (FORALL (m : matrix_complex): (indexes_decomp(m) = mat_sum(tuple2(int,
  int), t2tb14(to_indexes(complex1, t2tb18(m))), t2tb44(fc304(m)))));

fc305: (matrix_complex, INT, INT) -> (ARRAY lpintcm_intrp OF complex);

t2tb49: ((ARRAY lpintcm_intrp OF complex)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY lpintcm_intrp OF complex)): (sort(infix_mngt(
  tuple2(int, int), complex1), t2tb49(x))));

tb2t49: (uni) -> (ARRAY lpintcm_intrp OF complex);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY lpintcm_intrp OF complex)):PATTERN (t2tb49(i)):  (
  tb2t49(t2tb49(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb49(tb2t49(j))): 
  ((sort(infix_mngt(tuple2(int, int), complex1), j)) => (t2tb49(
  tb2t49(j)) = j)));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT, o : lpintcm_intrp): (tb2t(
  infix_at(complex1, tuple2(int, int), t2tb49(fc305(m, i, j)), t2tb13(o))) = 
  tb2t(get(complex1, t2tb18(basis_projection(m, tb2t5(fir(int, int, 
  t2tb13(o))), tb2t5(sec(int, int, t2tb13(o))))), i, j))));

% indexes_decomp_pre
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT):
  ((valid_index(complex1, t2tb18(m), i, j)) => (tb2t(get(complex1, t2tb18(m),
  i, j)) = sum(tuple2(int, int), t2tb14(to_indexes(complex1, t2tb18(m))), 
  t2tb49(fc305(m, i, j))))));

fc306: (matrix_complex, INT, INT) -> (ARRAY lpintcm_intrp OF complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT, o : lpintcm_intrp): (tb2t(
  infix_at(complex1, tuple2(int, int), t2tb49(fc306(m, i, j)), t2tb13(o))) = 
  tb2t(get(complex1, t2tb18(basis_projection(m, tb2t5(fir(int, int, 
  t2tb13(o))), tb2t5(sec(int, int, t2tb13(o))))), i, j))));

% indexes_decomp_pre_gen
  ASSERT
  (FORALL (m : matrix_complex):
  (FORALL (i : INT, j : INT):
  ((valid_index(complex1, t2tb18(m), i, j)) => (tb2t(get(complex1, t2tb18(m),
  i, j)) = sum(tuple2(int, int), t2tb14(to_indexes(complex1, t2tb18(m))), 
  t2tb49(fc306(m, i, j)))))));

% mat_to_indexes_decomp
  ASSERT (FORALL (m : matrix_complex): (m = indexes_decomp(m)));

basis_decomp: (matrix_complex) -> matrix_complex;

% basis_decomp'def
  ASSERT
  (FORALL (m : matrix_complex): (basis_decomp(m) = mat_sum(matrix(complex1), 
  t2tb25(basis_projections(m)), t2tb19(identity1))));

% basis_decomp'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((rows(complex1, t2tb18(basis_decomp(m))) = rows(complex1, t2tb18(m)))
  AND (columns(complex1, t2tb18(basis_decomp(m))) = columns(complex1, 
  t2tb18(m)))));

% indexes_basis_decomp_equal_pre
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT):
  ((valid_index(complex1, t2tb18(m), i, j)) => (tb2t(get(complex1, t2tb18(
  indexes_decomp(m)), i, j)) = tb2t(get(complex1, t2tb18(basis_decomp(m)), i,
  j)))));

% indexes_basis_decomp_equal
  ASSERT
  (FORALL (m : matrix_complex): (indexes_decomp(m) = basis_decomp(m)));

% mat_to_basis_decomp
  ASSERT (FORALL (m : matrix_complex): (m = indexes_decomp(m)));

fc878: (ty, matrix_complex, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex, x1 : uni, x2 : uni): (sort(infix_mngt(a, 
  matrix(complex1)), fc878(a, x, x1, x2)))));

fc879: (ty, matrix_complex, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex, x1 : uni): (sort(infix_mngt(a, 
  matrix(complex1)), fc879(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : matrix_complex, s2 : uni, f : uni, a1 : uni): (tb2t18(
  infix_at(matrix(complex1), a, fc878(a, m, s2, f),
  a1)) = (IF (mem(a, a1, s2)) THEN mat_mult(m, tb2t18(infix_at(
         matrix(complex1), a, f, a1))) ELSE m ENDIF))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : matrix_complex, f : uni, a1 : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc879(a, m, f), a1)) = mat_mult(m, tb2t18(infix_at(
  matrix(complex1), a, f, a1))))));

% product_mat_sum_r_pre
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : matrix_complex, sqt : uni, s2 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((columns(complex1, t2tb18(m)) = s_rows(a, s2, f))
     => ((subset(a, sqt, s2))
        => ((0 < cardinal(a, sqt))
           => ((mat_mult(m, mat_sum(a, sqt, f)) = mat_sum(a, sqt, fc878(a, m,
              s2, f)))
              AND ((mat_mult(m, mat_sum(a, sqt, f)) = mat_sum(a, sqt, 
                  fc879(a, m, f)))
                  AND ((rows(complex1, t2tb18(mat_sum(a, sqt, f))) = 
                      s_rows(a, s2, f))
                      AND ((columns(complex1, t2tb18(mat_sum(a, sqt, f))) = 
                          s_columns(a, s2, f))
                          AND ((rows(complex1, t2tb18(mat_mult(m, mat_sum(a,
                              sqt, f)))) = rows(complex1, t2tb18(m))) AND (
                              columns(complex1, t2tb18(mat_mult(m, mat_sum(a,
                              sqt, f)))) = s_columns(a, s2, f)))))))))))));

fc880: (ty, matrix_complex, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex, x1 : uni): (sort(infix_mngt(a, 
  matrix(complex1)), fc880(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : matrix_complex, f : uni, a1 : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc880(a, m, f), a1)) = mat_mult(m, tb2t18(infix_at(
  matrix(complex1), a, f, a1))))));

% product_mat_sum_r
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : matrix_complex, s2 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((columns(complex1, t2tb18(m)) = s_rows(a, s2, f))
     => ((0 < cardinal(a, s2)) => (mat_mult(m, mat_sum(a, s2, f)) = 
        mat_sum(a, s2, fc880(a, m, f))))))));

fc881: (ty, matrix_complex, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex, x1 : uni): (sort(infix_mngt(a, 
  matrix(complex1)), fc881(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : matrix_complex, f : uni, a1 : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc881(a, m, f), a1)) = mat_mult(m, tb2t18(infix_at(
  matrix(complex1), a, f, a1))))));

% product_mat_sum_r_rev
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : matrix_complex, s2 : uni, f : uni):
  ((constant_size(a, s2, f))
  => ((columns(complex1, t2tb18(m)) = s_rows(a, s2, f))
     => ((0 < cardinal(a, s2)) => (mat_sum(a, s2, fc881(a, m, f)) = 
        mat_mult(m, mat_sum(a, s2, f))))))));

% p_injective_proj
  ASSERT
  (FORALL (m : matrix_complex): (p_injective(matrix(complex1), tuple2(int,
  int), infix_at(infix_mngt(tuple2(int, int), matrix(complex1)), 
  infix_mngt(int, infix_mngt(int, matrix(complex1))), couple_closure(
  matrix(complex1), int, int), infix_at(infix_mngt(int, infix_mngt(int, 
  matrix(complex1))), matrix(complex1), t2tb47(basis_projection_closure), 
  t2tb18(m))), nonn_mat_subset(tuple2(int, int), infix_at(infix_mngt(
  tuple2(int, int), matrix(complex1)), infix_mngt(int, infix_mngt(int, 
  matrix(complex1))), couple_closure(matrix(complex1), int, int), infix_at(
  infix_mngt(int, infix_mngt(int, matrix(complex1))), matrix(complex1), 
  t2tb47(basis_projection_closure), t2tb18(m))), t2tb14(to_indexes(complex1, 
  t2tb18(m)))))));

% mat_decomp_equal_indexes
  ASSERT (FORALL (m : matrix_complex): (m = indexes_decomp(m)));

ket_basis: (INT) -> set_lpmatrix_complexrp;

% ket_basis'def
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (ket_basis(n) = basis_mat(power(2, n), 1))));

fc311: (INT) -> (ARRAY lpintcm_intrp OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, o : lpintcm_intrp): (tb2t18(infix_at(matrix(complex1), 
  tuple2(int, int), t2tb44(fc311(n)), t2tb13(o))) = ind_basis_mat(tb2t5(
  fir(int, int, t2tb13(o))), tb2t5(sec(int, int, t2tb13(o))), power(2, n),
  1)));

% ket_basis'spec
  ASSERT
  (FORALL (n : INT):
  ((0 <= n)
  => ((ket_basis(n) = tb2t25(map(matrix(complex1), tuple2(int, int), t2tb44(
     fc311(n)), cartesian_product(int, int, t2tb6(to_fset(0, power(2, n))), 
     t2tb6(to_fset(0, 1))))))
     AND ((ket_basis(n) = basis_mat(power(2, n), 1))
         AND ((FORALL (mat : matrix_complex):
              ((mem(matrix(complex1), t2tb18(mat), t2tb25(ket_basis(n))))
              => (rows(complex1, t2tb18(mat)) = power(2, n))))
             AND ((FORALL (mat : matrix_complex):
                  ((mem(matrix(complex1), t2tb18(mat), t2tb25(ket_basis(n))))
                  => (columns(complex1, t2tb18(mat)) = 1)))
                 AND (FORALL (mat : matrix_complex):
                     ((mem(matrix(complex1), t2tb18(mat), t2tb25(
                     ket_basis(n))))
                     => ((rows(complex1, t2tb18(mat)) = power(2, n))
                        AND ((columns(complex1, t2tb18(mat)) = 1)
                            AND (EXISTS (i : INT):
                                ((valid_index(complex1, t2tb18(mat), i, 0))
                                AND (basis_mat_indexes(mat) = tb2t13(
                                Tuple2(int, int, t2tb5(i), t2tb5(0))))))))))))))));

fc312: (INT) -> (ARRAY INT OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, i : INT): (tb2t18(infix_at(matrix(complex1), int, t2tb21(
  fc312(n)), t2tb5(i))) = ind_basis_mat(i, 0, power(2, n), 1)));

% unary_ket_basis
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (ket_basis(n) = tb2t25(map(matrix(complex1), int, t2tb21(
  fc312(n)), t2tb6(to_fset(0, power(2, n))))))));

% to_ket_basis
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (mem(matrix(complex1), t2tb18(
     ind_basis_mat(i, 0, power(2, n), 1)), t2tb25(ket_basis(n)))))));

ket_basis_index: (matrix_complex, INT) -> INT;

% ket_basis_index'def
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n)
  => ((mem(matrix(complex1), t2tb18(m), t2tb25(ket_basis(n)))) => (
     ket_basis_index(m, n) = tb2t5(fir(int, int, t2tb13(
     basis_mat_indexes(m))))))));

fc313: (matrix_complex, INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : INT, i : INT, us : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc313(m, n)), t2tb5(i)), t2tb5(us))) = indic(int, t2tb5(ket_basis_index(m,
  n)), t2tb5(i))));

% ket_basis_index'spec
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n)
  => ((mem(matrix(complex1), t2tb18(m), t2tb25(ket_basis(n))))
     => ((mem(matrix(complex1), t2tb18(ind_basis_mat(ket_basis_index(m, n),
        0, power(2, n), 1)), t2tb25(ket_basis(n))))
        AND ((m = tb2t18(make_f(complex1, rows(complex1, t2tb18(m)), 1, 
            t2tb15(fc313(m, n)))))
            AND ((FORALL (i : INT):
                 ((valid_index(complex1, t2tb18(m), i, 0))
                 => ((NOT (i = ket_basis_index(m, n))) => (tb2t(get(complex1, 
                    t2tb18(m), i, 0)) = c_zero))))
                AND (valid_index(complex1, t2tb18(m), ket_basis_index(m, n),
                0))))))));

fc314: (INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (i : INT, i1 : INT, us : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), int, t2tb15(fc314(i)), t2tb5(i1)), 
  t2tb5(us))) = indic(int, t2tb5(i), t2tb5(i1))));

% set_ket_basis
  ASSERT
  (FORALL (m : matrix_complex, n : INT, i : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => ((mem(matrix(complex1), t2tb18(m), t2tb25(ket_basis(n))))
        => ((tb2t(get(complex1, t2tb18(m), i, 0)) = c_one)
           => ((ket_basis_index(m, n) = i)
              AND ((FORALL (i1 : INT):
                   ((valid_index(complex1, t2tb18(m), i1, 0))
                   => ((NOT (i1 = i)) => (tb2t(get(complex1, t2tb18(m), i1,
                      0)) = c_zero))))
                  AND ((mem(matrix(complex1), t2tb18(m), t2tb25(
                      ket_basis(n)))) AND (m = tb2t18(make_f(complex1, 
                      rows(complex1, t2tb18(m)), columns(complex1, 
                      t2tb18(m)), t2tb15(fc314(i)))))))))))));

% from_ket_basis
  ASSERT
  (FORALL (n : INT, m : matrix_complex):
  ((0 <= n)
  => ((mem(matrix(complex1), t2tb18(m), t2tb25(ket_basis(n))))
     => (EXISTS (i : INT):
        (((0 <= i) AND (i < power(2, n))) AND (m = ind_basis_mat(i, 0, 
        power(2, n), 1)))))));

% int_to_ket_basis
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (mem(matrix(complex1), t2tb18(
     ket(n, i)), t2tb25(ket_basis(n)))))));

is_a_ket_basis_elt: (matrix_complex) -> BOOLEAN;

% is_a_ket_basis_elt'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket_basis_elt(m))
  <=> ((is_a_ket(m)) AND (mem(matrix(complex1), t2tb18(m), t2tb25(ket_basis(
      ket_length(m))))))));

% ket_basis_elt_are_kets
  ASSERT
  (FORALL (m : matrix_complex): ((is_a_ket_basis_elt(m)) => (is_a_ket(m))));

% get_is_a_ket_basis_elt
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket_basis_elt(m))
  => ((is_a_ket(m))
     AND ((mem(matrix(complex1), t2tb18(m), t2tb25(ket_basis(
         ket_length(m)))))
         AND ((EXISTS (i : INT):
              (((0 <= i) AND (i < power(2, ket_length(m)))) AND (m = ket(
              ket_length(m), i))))
             AND ((EXISTS (i : INT):
                  (((0 <= i) AND (i < power(2, ket_length(m))))
                  AND ((tb2t(get(complex1, t2tb18(m), i, 0)) = c_one)
                      AND (FORALL (j : INT):
                          ((((0 <= j) AND (j < power(2, ket_length(m))))
                           AND (NOT (tb2t(get(complex1, t2tb18(m), j,
                               0)) = c_zero)))
                          => (i = j))))))
                 AND (FORALL (i : INT):
                     ((((0 <= i) AND (i < power(2, ket_length(m)))) AND (
                      tb2t(get(complex1, t2tb18(m), i, 0)) = c_one))
                     => (FORALL (j : INT):
                        ((((0 <= j) AND (j < power(2, ket_length(m))))
                         AND (NOT (tb2t(get(complex1, t2tb18(m), j,
                             0)) = c_zero)))
                        => (i = j)))))))))));

% get_is_a_ket_basis_elt_indic
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket_basis_elt(m))
  => (EXISTS (i : INT):
     (((0 <= i) AND (i < power(2, ket_length(m))))
     AND (FORALL (j : INT):
         (((0 <= j) AND (j < power(2, ket_length(m)))) => (tb2t(get(complex1, 
         t2tb18(m), j, 0)) = indic(int, t2tb5(i), t2tb5(j)))))))));

% set_is_a_ket_basis_elt
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m))
  => ((EXISTS (i : INT):
      (((0 <= i) AND (i < power(2, ket_length(m)))) AND (m = ket(
      ket_length(m), i))))
     => (is_a_ket_basis_elt(m)))));

fc315: (INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (j : INT, i : INT, us : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), int, t2tb15(fc315(j)), t2tb5(i)), 
  t2tb5(us))) = indic(int, t2tb5(i), t2tb5(j))));

% set_is_a_ket_basis_elt_exists
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m))
  => ((EXISTS (j : INT):
      (((0 <= j) AND (j < power(2, ket_length(m)))) AND (m = tb2t18(
      make_f(complex1, power(2, ket_length(m)), 1, t2tb15(fc315(j)))))))
     => (is_a_ket_basis_elt(m)))));

% ket_func_sets_ket_basis_elts
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => ((is_a_ket_basis_elt(ket(n, i))) AND (ket_length(ket(n, i)) = n)))));

% kronecker_is_a_ket_basis_elt
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_basis_elt(x))
  => ((is_a_ket_basis_elt(y)) => (is_a_ket_basis_elt(kronecker(x, y))))));

% ket_is_a_ket_basis_elt
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (is_a_ket_basis_elt(ket(n, i))))));

% ket_basis_non_null_val
  ASSERT
  (FORALL (m : matrix_complex, n : INT, i : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n)))
     => ((is_a_ket_basis_elt(m))
        => ((ket_length(m) = n)
           => ((NOT (tb2t(get(complex1, t2tb18(m), i, 0)) = c_zero)) => (m = 
              ket(n, i))))))));

ket_to_int: (matrix_complex) -> INT;

% ket_to_int'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket_basis_elt(m))
  => (((0 <= ket_to_int(m)) AND (ket_to_int(m) < power(2, ket_length(m))))
     AND ((tb2t(get(complex1, t2tb18(m), ket_to_int(m), 0)) = c_one)
         AND ((m = ket(ket_length(m), ket_to_int(m)))
             AND (FORALL (i : INT):
                 (((0 <= i) AND (i < power(2, ket_length(m))))
                 => ((m = ket(ket_length(m), i)) => (i = ket_to_int(m))))))))));

% ket_to_int_ket
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (ket_to_int(ket(n, i)) = i))));

% equal_ket_by_int
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((is_a_ket_l(m, l))
  => ((is_a_ket_l(n, l))
     => ((is_a_ket_basis_elt(n))
        => ((is_a_ket_basis_elt(m))
           => ((ket_to_int(m) = ket_to_int(n)) => (m = n)))))));

bin_to_ket: (INT, (ARRAY INT OF INT)) -> matrix_complex;

% bin_to_ket'def
  ASSERT
  (FORALL (n : INT, bvx : (ARRAY INT OF INT)):
  ((0 <= n)
  => ((binary(bvx)) => (bin_to_ket(n, bvx) = ket(n, bin_to_int(bvx, n))))));

% bin_to_ket'spec
  ASSERT
  (FORALL (n : INT, bvx : (ARRAY INT OF INT)):
  ((0 <= n)
  => ((binary(bvx))
     => ((is_a_ket_basis_elt(bin_to_ket(n, bvx)))
        AND ((ket_length(bin_to_ket(n, bvx)) = n)
            AND ((ket_to_int(bin_to_ket(n, bvx)) = bin_to_int(bvx, n))
                AND ((rows(complex1, t2tb18(bin_to_ket(n, bvx))) = power(2,
                    n))
                    AND ((columns(complex1, t2tb18(bin_to_ket(n, bvx))) = 1)
                        AND ((is_a_ket(bin_to_ket(n, bvx))) AND (is_a_ket_l(
                            bin_to_ket(n, bvx), n)))))))))));

% bin_to_ket_l
  ASSERT
  (FORALL (n : INT, nqt : INT, bvx : (ARRAY INT OF INT)):
  ((0 <= n)
  => ((n = nqt) => ((binary(bvx)) => (is_a_ket_l(bin_to_ket(n, bvx), nqt))))));

% bin_to_ket_eq
  ASSERT
  (FORALL (n1 : INT, n2 : INT, bvx1 : (ARRAY INT OF INT),
  bvx2 : (ARRAY INT OF INT)):
  ((0 <= n1)
  => ((binary(bvx1))
     => ((binary(bvx2))
        => ((n2 = n1)
           => ((FORALL (i : INT):
               (((0 <= i) AND (i < n1)) => ((bvx1[i]) = (bvx2[i]))))
              => (bin_to_ket(n1, bvx1) = bin_to_ket(n2, bvx2))))))));

% kronecker_kets_bin_to_ket
  ASSERT
  (FORALL (f1 : (ARRAY INT OF INT), f2 : (ARRAY INT OF INT), n1 : INT,
  n2 : INT):
  ((binary(f1))
  => ((binary(f2))
     => ((0 <= n1)
        => ((0 <= n2) => (kronecker(bin_to_ket(n1, f1), bin_to_ket(n2,
           f2)) = bin_to_ket((n1 + n2), tb2t7(infix_at(infix_mngt(int, int),
           int, infix_at(infix_mngt(int, infix_mngt(int, int)), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, infix_mngt(int, int))), infix_mngt(int, int), 
           concat_fun_closure(int), t2tb7(f1)), t2tb7(f2)), t2tb5(n1))))))))));

% kronecker_ket_to_int
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_basis_elt(x))
  => ((is_a_ket_basis_elt(y))
     => ((is_a_ket_basis_elt(kronecker(x, y)))
        AND ((ket_length(kronecker(x, y)) = (ket_length(x) + ket_length(y)))
            AND ((kronecker(x, y) = ket((ket_length(x) + ket_length(y)), ((
                ket_to_int(x) * power(2, ket_length(y))) + ket_to_int(y))))
                AND (ket_to_int(kronecker(x, y)) = ((ket_to_int(x) * power(2, 
                ket_length(y))) + ket_to_int(y)))))))));

% ket_ket_to_int
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_basis_elt(x)) => (ket(ket_length(x), ket_to_int(x)) = x)));

% ket_ket_to_int_values
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_basis_elt(x))
  => (FORALL (i : INT, j : INT):
     ((valid_index(complex1, t2tb18(x), i, j)) => (tb2t(get(complex1, 
     t2tb18(x), i, j)) = indic(int, t2tb5(i), t2tb5(ket_to_int(x))))))));

ket_basis_projection: (matrix_complex, INT) -> matrix_complex;

% ket_basis_projection'def
  ASSERT
  (FORALL (m : matrix_complex, j : INT):
  ((is_a_ket(m))
  => (((0 <= j) AND (j < power(2, ket_length(m)))) => (
     ket_basis_projection(m, j) = infix_asdtdt(tb2t(get(complex1, t2tb18(m),
     j, 0)), ket(ket_length(m), j))))));

% ket_basis_projection'spec
  ASSERT
  (FORALL (m : matrix_complex, j : INT):
  ((is_a_ket(m))
  => (((0 <= j) AND (j < power(2, ket_length(m)))) => (
     ket_basis_projection(m, j) = basis_projection(m, j, 0)))));

% ket_basis_projection_columns
  ASSERT
  (FORALL (m : matrix_complex, j : INT):
  ((is_a_ket(m))
  => (((0 <= j) AND (j < power(2, ket_length(m)))) => (columns(complex1, 
     t2tb18(ket_basis_projection(m, j))) = 1))));

% ket_basis_projection_rows
  ASSERT
  (FORALL (m : matrix_complex, j : INT):
  ((is_a_ket(m))
  => (((0 <= j) AND (j < power(2, ket_length(m)))) => (rows(complex1, t2tb18(
     ket_basis_projection(m, j))) = rows(complex1, t2tb18(m))))));

ket_basis_projections: (matrix_complex) -> set_lpmatrix_complexrp;

result38: (matrix_complex) -> (ARRAY INT OF matrix_complex);

% result'def
  ASSERT
  (FORALL (m : matrix_complex, j : INT): (tb2t18(infix_at(matrix(complex1),
  int, t2tb21(result38(m)), 
  t2tb5(j))) = (IF (mem(int, t2tb5(j), t2tb6(to_fset(0, power(2, 
               ket_length(m)))))) THEN ket_basis_projection(m, j)
               ELSE m ENDIF)));

% ket_basis_projections'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m)) => (ket_basis_projections(m) = tb2t25(map(matrix(complex1),
  int, t2tb21(result38(m)), t2tb6(to_fset(0, power(2, ket_length(m)))))))));

% ket_basis_projections'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m)) => (ket_basis_projections(m) = basis_projections(m))));

ket_basis_projections_antec: (matrix_complex) -> tuple0;

% ket_basis_projections_antec'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m)) => (ket_basis_projections_antec(m) = Tuple0)));

% ket_basis_projections_antec'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m))
  => ((FORALL (e : matrix_complex):
      ((mem(matrix(complex1), t2tb18(e), t2tb25(ket_basis_projections(m))))
      <=> (EXISTS (j : INT):
          (((0 <= j) AND (j < power(2, ket_length(m)))) AND (e = 
          ket_basis_projection(m, j))))))
     AND (FORALL (e : matrix_complex):
         ((mem(matrix(complex1), t2tb18(e), t2tb25(
         ket_basis_projections(m))))
         <=> (EXISTS (j : INT, i : INT):
             ((valid_index(complex1, t2tb18(m), j, i)) AND (e = 
             basis_projection(m, j, i)))))))));

ket_sum: (ty, uni, uni) -> matrix_complex;

% ket_sum'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((0 < cardinal(a, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (is_a_ket(tb2t18(infix_at(matrix(complex1), a,
         f, e)))))))
     => ((EXISTS (l : INT):
         (FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (ket_length(tb2t18(infix_at(matrix(complex1),
            a, f, e))) = l)))))
        => (ket_sum(a, s2, f) = mat_sum(a, s2, f)))))));

fc882: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(a, complex1), fc882(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, e : uni): (tb2t(infix_at(complex1, a, fc882(a,
  f, i), e)) = tb2t(get(complex1, infix_at(matrix(complex1), a, f, e), i,
  0)))));

% ket_sum'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((0 < cardinal(a, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (is_a_ket(tb2t18(infix_at(matrix(complex1), a,
         f, e)))))))
     => ((EXISTS (l : INT):
         (FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2)) => (ket_length(tb2t18(infix_at(matrix(complex1),
            a, f, e))) = l)))))
        => ((FORALL (i : INT):
            ((valid_index(complex1, t2tb18(ket_sum(a, s2, f)), i, 0)) => (
            tb2t(get(complex1, t2tb18(ket_sum(a, s2, f)), i, 0)) = sum(a, s2, 
            fc882(a, f, i)))))
           AND ((is_a_ket(ket_sum(a, s2, f)))
               AND (FORALL (e : uni):
                   ((mem(a, e, s2)) => (ket_length(ket_sum(a, s2, f)) = 
                   ket_length(tb2t18(infix_at(matrix(complex1), a, f, e)))))))))))));

ket_sum_l: (ty, uni, uni, INT) -> matrix_complex;

result113: (ARRAY INT OF complex);

fc883: (ARRAY matrix_complex OF (ARRAY INT OF complex));

fc884: (ARRAY matrix_complex OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (us : INT): (tb2t(infix_at(complex1, int, t2tb12(result113), 
  t2tb5(us))) = c_zero));

t2tb50: ((ARRAY matrix_complex OF (ARRAY INT OF complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY matrix_complex OF (ARRAY INT OF complex))): (sort(
  infix_mngt(matrix(complex1), infix_mngt(int, complex1)), t2tb50(x))));

tb2t50: (uni) -> (ARRAY matrix_complex OF (ARRAY INT OF complex));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY matrix_complex OF (ARRAY INT OF complex))):PATTERN (
  t2tb50(i)):  (tb2t50(t2tb50(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb50(tb2t50(j))): 
  ((sort(infix_mngt(matrix(complex1), infix_mngt(int, complex1)), j)) => (
  t2tb50(tb2t50(j)) = j)));

% fc'def
  ASSERT
  (FORALL (y0 : matrix_complex, y1 : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), matrix(complex1), t2tb50(fc883), 
  t2tb18(y0)), t2tb5(y1))) = tb2t(get(complex1, t2tb18(y0), y1, 0))));

% fc'def
  ASSERT
  (FORALL (y0 : matrix_complex, y1 : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), matrix(complex1), t2tb50(fc884), 
  t2tb18(y0)), t2tb5(y1))) = tb2t(get(complex1, t2tb18(y0), y1, 0))));

% ket_sum_l'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((0 <= l)
  => (IF (cardinal(a, s2) = 0) THEN (ket_sum_l(a, s2, f, l) = make_ket(l,
     result113))
     ELSE (IF (cardinal(a, s2) = 1) THEN (ket_sum_l(a, s2, f, l) = 
          make_ket(l, tb2t12(infix_at(infix_mngt(int, complex1), 
          matrix(complex1), t2tb50(fc883), infix_at(matrix(complex1), a, f, 
          choose(a, s2)))))) ELSE (ket_sum_l(a, s2, f, l) = add_ket(
          ket_sum_l(a, remove(a, choose(a, s2), s2), f, l), make_ket(l, 
          tb2t12(infix_at(infix_mngt(int, complex1), matrix(complex1), 
          t2tb50(fc884), infix_at(matrix(complex1), a, f, choose(a,
          s2))))))) ENDIF) ENDIF))));

fc885: (ty, uni, uni) -> (ARRAY INT OF complex);

fc886: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(a, matrix(complex1)), 
  fc886(a, x, x1)))));

fc887: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(a, complex1), fc887(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : uni, j : INT): (tb2t(infix_at(complex1, int, t2tb12(
  fc885(a, f, i)), t2tb5(j))) = tb2t(get(complex1, infix_at(matrix(complex1),
  a, f, i), j, 0)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, l : INT, i : uni): (tb2t18(infix_at(matrix(complex1), a, 
  fc886(a, f, l), i)) = make_ket(l, fc885(a, f, i)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, e : uni): (tb2t(infix_at(complex1, a, fc887(a,
  f, i), e)) = tb2t(get(complex1, infix_at(matrix(complex1), a, f, e), i,
  0)))));

% ket_sum_l'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((0 <= l)
  => (((0 < cardinal(a, s2)) => (ket_sum_l(a, s2, f, l) = mat_sum(a, s2, 
      fc886(a, f, l))))
     AND ((is_a_ket(ket_sum_l(a, s2, f, l)))
         AND ((FORALL (i : INT):
              ((valid_index(complex1, t2tb18(ket_sum_l(a, s2, f, l)), i, 0))
              => (tb2t(get(complex1, t2tb18(ket_sum_l(a, s2, f, l)), i,
              0)) = sum(a, s2, fc887(a, f, i)))))
             AND ((is_a_ket_l(ket_sum_l(a, s2, f, l), l))
                 AND (((0 < cardinal(a, s2))
                      => ((FORALL (e : uni):
                          ((sort(a, e))
                          => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(
                             matrix(complex1), a, f, e)), l)))))
                         => (ket_sum_l(a, s2, f, l) = mat_sum(a, s2, f))))
                     AND (ket_length(ket_sum_l(a, s2, f, l)) = l)))))))));

fc888: (ty, uni, uni) -> (ARRAY INT OF complex);

fc889: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(a, matrix(complex1)), 
  fc889(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : uni, j : INT): (tb2t(infix_at(complex1, int, t2tb12(
  fc888(a, f, i)), t2tb5(j))) = tb2t(get(complex1, infix_at(matrix(complex1),
  a, f, i), j, 0)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, l : INT, i : uni): (tb2t18(infix_at(matrix(complex1), a, 
  fc889(a, f, l), i)) = make_ket(l, fc888(a, f, i)))));

% ket_sum_l_to_mat_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((0 <= l)
  => ((0 < cardinal(a, s2)) => (ket_sum_l(a, s2, f, l) = mat_sum(a, s2, 
     fc889(a, f, l)))))));

% ket_sum_l_rows
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((0 <= l)
  => ((0 < cardinal(a, s2)) => (rows(complex1, t2tb18(ket_sum_l(a, s2, f,
     l))) = power(2, l))))));

fc324: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(a, complex1), fc324(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, e : uni): (tb2t(infix_at(complex1, a, fc324(a,
  f, i), e)) = tb2t(get(complex1, infix_at(matrix(complex1), a, f, e), i,
  0)))));

% ket_sum_l_value
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT, i : INT, j : INT):
  ((0 <= l)
  => (((0 <= i) AND (i < power(2, l)))
     => ((j = 0) => (tb2t(get(complex1, t2tb18(ket_sum_l(a, s2, f, l)), i,
        j)) = sum(a, s2, fc324(a, f, i))))))));

fc890: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(a, complex1), fc890(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, e : uni): (tb2t(infix_at(complex1, a, fc890(a,
  f, i), e)) = tb2t(get(complex1, infix_at(matrix(complex1), a, f, e), i,
  0)))));

% get_ket_sum_l_value
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT, i : INT):
  ((0 <= l)
  => (((0 <= i) AND (i < power(2, l))) => (tb2t(get(complex1, t2tb18(
     ket_sum_l(a, s2, f, l)), i, 0)) = sum(a, s2, fc890(a, f, i)))))));

% ket_sum_l_columns
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((0 <= l) => (columns(complex1, t2tb18(ket_sum_l(a, s2, f, l))) = 1))));

% ket_sum_null_but_maybe_one_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, e : uni):
  ((1 < cardinal(a, s2))
  => ((FORALL (e1 : uni):
      ((sort(a, e1))
      => ((mem(a, e1, s2)) => (is_a_ket(tb2t18(infix_at(matrix(complex1), a,
         f, e1)))))))
     => ((constant_size(a, s2, f))
        => ((mem(a, e, s2))
           => ((FORALL (eqt : uni):
               ((sort(a, eqt))
               => ((mem(a, eqt, s2))
                  => ((NOT (e = eqt)) => (null_mat(tb2t18(infix_at(
                     matrix(complex1), a, f, eqt))))))))
              => (ket_sum(a, s2, f) = tb2t18(infix_at(matrix(complex1), a, f,
              e))))))))));

% ket_sum_null
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((1 < cardinal(a, s2))
  => ((0 <= l)
     => ((FORALL (e : uni):
         ((sort(a, e))
         => ((mem(a, e, s2))
            => (FORALL (i : INT):
               (((0 <= i) AND (i < power(2, l))) => (tb2t(get(complex1, 
               infix_at(matrix(complex1), a, f, e), i, 0)) = c_zero))))))
        => (FORALL (j : INT):
           (((0 <= j) AND (j < power(2, l))) => (tb2t(get(complex1, t2tb18(
           ket_sum_l(a, s2, f, l)), j, 0)) = c_zero))))))));

fc891: (ARRAY matrix_complex OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (y0 : matrix_complex, y1 : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), matrix(complex1), t2tb50(fc891), 
  t2tb18(y0)), t2tb5(y1))) = tb2t(get(complex1, t2tb18(y0), y1, 0))));

% ket_sum_l_null_but_maybe_one_elt
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, e : uni, l : INT):
  ((0 <= l)
  => ((1 < cardinal(a, s2))
     => ((mem(a, e, s2))
        => ((FORALL (eqt : uni):
            ((sort(a, eqt))
            => ((mem(a, eqt, s2))
               => ((NOT (eqt = e))
                  => (FORALL (i : INT):
                     (((0 <= i) AND (i < power(2, l))) => (tb2t(get(complex1, 
                     infix_at(matrix(complex1), a, f, eqt), i, 0)) = c_zero)))))))
           => (ket_sum_l(a, s2, f, l) = make_ket(l, tb2t12(infix_at(
           infix_mngt(int, complex1), matrix(complex1), t2tb50(fc891), 
           infix_at(matrix(complex1), a, f, e)))))))))));

% ket_sum_l_null_but_maybe_one_elt_
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, s2 : uni, e : uni, l : INT):
  ((0 <= l)
  => ((1 < cardinal(a, s2))
     => ((mem(a, e, s2))
        => ((FORALL (eqt : uni):
            ((sort(a, eqt))
            => ((mem(a, eqt, s2)) => (is_a_ket_l(tb2t18(infix_at(
               matrix(complex1), a, f, eqt)), l)))))
           => ((FORALL (eqt : uni):
               ((sort(a, eqt))
               => ((mem(a, eqt, s2))
                  => ((NOT (eqt = e))
                     => (FORALL (i : INT):
                        (((0 <= i) AND (i < power(2, l))) => (tb2t(
                        get(complex1, infix_at(matrix(complex1), a, f, eqt),
                        i, 0)) = c_zero)))))))
              => (ket_sum_l(a, s2, f, l) = tb2t18(infix_at(matrix(complex1),
              a, f, e))))))))));

% ket_sum_ket_l
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((0 <= l) => (is_a_ket_l(ket_sum_l(a, s2, f, l), l)))));

% ket_sum_ket_l_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT, lqt : INT):
  ((0 <= l) => ((l = lqt) => (is_a_ket_l(ket_sum_l(a, s2, f, l), lqt))))));

% add_ket_l_eq
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, mqt : matrix_complex,
  oqt : matrix_complex, l : INT):
  ((0 <= l)
  => ((m = mqt)
     => ((o = oqt) => (add_ket_l(m, o, l) = add_ket_l(mqt, oqt, l))))));

% add_ket_l_eq_scal
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, mqt : matrix_complex,
  oqt : matrix_complex, a : complex, b : complex, aqt : complex,
  bqt : complex, l : INT):
  ((0 <= l)
  => ((m = mqt)
     => ((o = oqt)
        => ((a = aqt)
           => ((b = bqt) => (add_ket_l(infix_asdtdt(a, m), infix_asdtdt(b,
              o), l) = add_ket_l(infix_asdtdt(aqt, mqt), infix_asdtdt(bqt,
              oqt), l))))))));

% add_ket_l_scal
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex, a : complex, l : INT):
  ((is_a_ket_l(x, l))
  => ((is_a_ket_l(y, l)) => (add_ket_l(infix_asdtdt(a, x), infix_asdtdt(a,
     y), l) = infix_asdtdt(a, add_ket_l(x, y, l))))));

% add_ket_l_scal_rev
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex, a : complex, l : INT):
  ((is_a_ket_l(x, l))
  => ((is_a_ket_l(y, l)) => (infix_asdtdt(a, add_ket_l(x, y, l)) = add_ket_l(
     infix_asdtdt(a, x), infix_asdtdt(a, y), l)))));

% get_ket_scalar
  ASSERT
  (FORALL (x : matrix_complex, a : complex, i : INT): (tb2t(get(complex1, 
  t2tb18(infix_asdtdt(a, x)), i, 0)) = infix_asdt(a, tb2t(get(complex1, 
  t2tb18(x), i, 0)))));

% scal_add_scal_ket_l
  ASSERT
  (FORALL (g : complex, a : complex, x : matrix_complex, aqt : complex,
  xqt : matrix_complex, n : INT):
  ((0 <= n) => (infix_asdtdt(g, add_ket_l(infix_asdtdt(a, x), 
  infix_asdtdt(aqt, xqt), n)) = add_ket_l(infix_asdtdt(infix_asdt(g, a), x), 
  infix_asdtdt(infix_asdt(g, aqt), xqt), n))));

% add_ket_l_switch
  ASSERT
  (FORALL (a : matrix_complex, b : matrix_complex, c : matrix_complex,
  d : matrix_complex, n : INT):
  ((0 <= n) => (add_ket_l(add_ket_l(a, b, n), add_ket_l(c, d, n), n) = 
  add_ket_l(add_ket_l(a, c, n), add_ket_l(b, d, n), n))));

% add_ket_scal_fact
  ASSERT
  (FORALL (a : matrix_complex, n : INT, s2 : complex, sqt : complex):
  ((is_a_ket_l(a, n))
  => ((0 <= n) => (add_ket_l(infix_asdtdt(s2, a), infix_asdtdt(sqt, a), n) = 
     infix_asdtdt(infix_pldt(s2, sqt), a)))));

fc327: (ty, uni, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (b : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT): (sort(infix_mngt(b, 
  matrix(complex1)), fc327(b, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, g : uni, l : INT, k : uni): (tb2t18(infix_at(
  matrix(complex1), b, fc327(b, f, g, l), k)) = add_ket_l(tb2t18(infix_at(
  matrix(complex1), b, f, k)), tb2t18(infix_at(matrix(complex1), b, g, k)),
  l))));

% ket_sum_comp_l
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, g : uni, l : INT):
  ((0 <= l) => (ket_sum_l(b, s2, fc327(b, f, g, l), l) = add_ket_l(
  ket_sum_l(b, s2, f, l), ket_sum_l(b, s2, g, l), l)))));

fc328: (ty, uni, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (b : ty):
  (FORALL (x : uni, x1 : uni, x2 : INT): (sort(infix_mngt(b, 
  matrix(complex1)), fc328(b, x, x1, x2)))));

% fc'def
  ASSERT
  (FORALL (b : ty):
  (FORALL (f : uni, g : uni, l : INT, k : uni): (tb2t18(infix_at(
  matrix(complex1), b, fc328(b, f, g, l), k)) = add_ket_l(tb2t18(infix_at(
  matrix(complex1), b, f, k)), tb2t18(infix_at(matrix(complex1), b, g, k)),
  l))));

% ket_sum_comp_l_rev
  ASSERT
  (FORALL (b : ty):
  (FORALL (s2 : uni, f : uni, g : uni, l : INT):
  ((0 <= l) => (add_ket_l(ket_sum_l(b, s2, f, l), ket_sum_l(b, s2, g, l),
  l) = ket_sum_l(b, s2, fc328(b, f, g, l), l)))));

fc329: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc329(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, a1 : complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc329(a, f, a1), k)) = infix_asdtdt(a1, tb2t18(
  infix_at(matrix(complex1), a, f, k))))));

% ket_sum_scalar_l
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, a1 : complex, l : INT):
  ((0 <= l) => (ket_sum_l(a, s2, fc329(a, f, a1), l) = infix_asdtdt(a1, 
  ket_sum_l(a, s2, f, l))))));

% ket_l_ket_sum_scalar
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, a1 : complex, l : INT, n : INT):
  ((0 <= l)
  => ((l = n) => (is_a_ket_l(infix_asdtdt(a1, ket_sum_l(a, s2, f, l)), n))))));

% scal_ket_sum_scalar_l
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, b : complex, l : INT, lqt : INT):
  ((0 <= l)
  => ((l = lqt) => (is_a_ket_l(infix_asdtdt(b, ket_sum_l(a, s2, f, l)),
     lqt))))));

fc330: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc330(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, a1 : complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc330(a, f, a1), k)) = infix_asdtdt(a1, tb2t18(
  infix_at(matrix(complex1), a, f, k))))));

% ket_sum_scalar_rev_l
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, a1 : complex, l : INT):
  ((0 <= l) => (infix_asdtdt(a1, ket_sum_l(a, s2, f, l)) = ket_sum_l(a, s2, 
  fc330(a, f, a1), l)))));

% ket_sum_eq
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni, g : uni, l : INT):
  ((0 <= l)
  => ((s2 = sqt)
     => ((FORALL (a1 : uni):
         ((sort(a, a1))
         => ((mem(a, a1, s2)) => (tb2t18(infix_at(matrix(complex1), a, f,
            a1)) = tb2t18(infix_at(matrix(complex1), a, g, a1))))))
        => (ket_sum_l(a, s2, f, l) = ket_sum_l(a, sqt, g, l)))))));

% ket_sum_eq_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni, g : uni, l1 : INT, l2 : INT):
  ((0 <= l1)
  => ((s2 = sqt)
     => ((l1 = l2)
        => ((FORALL (a1 : uni):
            ((sort(a, a1))
            => ((mem(a, a1, s2)) => (tb2t18(infix_at(matrix(complex1), a, f,
               a1)) = tb2t18(infix_at(matrix(complex1), a, g, a1))))))
           => (ket_sum_l(a, s2, f, l1) = ket_sum_l(a, sqt, g, l2))))))));

fc892: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(a, complex1), fc892(a, x,
  x1)))));

fc893: (ty, uni, INT) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : INT): (sort(infix_mngt(a, complex1), fc893(a, x,
  x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, i : INT, e : uni): (tb2t(infix_at(complex1, a, fc892(a,
  f, i), e)) = tb2t(get(complex1, infix_at(matrix(complex1), a, f, e), i,
  0)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (g : uni, i : INT, e : uni): (tb2t(infix_at(complex1, a, fc893(a,
  g, i), e)) = tb2t(get(complex1, infix_at(matrix(complex1), a, g, e), i,
  0)))));

% ket_sum_eq_by_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, sqt : uni, f : uni, g : uni, l1 : INT, l2 : INT):
  ((0 <= l1)
  => ((s2 = sqt)
     => ((l1 = l2)
        => ((FORALL (i : INT):
            (((0 <= i) AND (i < power(2, l1))) => (sum(a, s2, fc892(a, f,
            i)) = sum(a, s2, fc893(a, g, i)))))
           => (ket_sum_l(a, s2, f, l1) = ket_sum_l(a, sqt, g, l2))))))));

% ket_sum_bvs_eq
  ASSERT
  (FORALL (n1 : INT, n2 : INT, f : (ARRAY bitvec OF matrix_complex),
  g : (ARRAY bitvec OF matrix_complex), l1 : INT, l2 : INT):
  ((0 <= l1)
  => ((l1 = l2)
     => ((n1 = n2)
        => ((0 <= n1)
           => ((FORALL (e : bitvec):
               ((mem(bitvec1, t2tb26(e), t2tb28(n_bvs(n1)))) => (tb2t18(
               infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(e))) = 
               tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(g), 
               t2tb26(e))))))
              => (ket_sum_l(bitvec1, t2tb28(n_bvs(n1)), t2tb29(f), l1) = 
              ket_sum_l(bitvec1, t2tb28(n_bvs(n2)), t2tb29(g), l2))))))));

% ket_sum_scal_bvs_eq
  ASSERT
  (FORALL (n1 : INT, n2 : INT, f : (ARRAY bitvec OF matrix_complex),
  g : (ARRAY bitvec OF matrix_complex), l1 : INT, l2 : INT, s11 : complex,
  s2 : complex):
  ((0 <= l1)
  => ((l1 = l2)
     => ((n1 = n2)
        => ((s11 = s2)
           => ((0 <= n1)
              => ((FORALL (e : bitvec):
                  ((mem(bitvec1, t2tb26(e), t2tb28(n_bvs(n1)))) => (tb2t18(
                  infix_at(matrix(complex1), bitvec1, t2tb29(f), 
                  t2tb26(e))) = tb2t18(infix_at(matrix(complex1), bitvec1, 
                  t2tb29(g), t2tb26(e))))))
                 => (infix_asdtdt(s11, ket_sum_l(bitvec1, t2tb28(n_bvs(n1)), 
                 t2tb29(f), l1)) = infix_asdtdt(s2, ket_sum_l(bitvec1, 
                 t2tb28(n_bvs(n2)), t2tb29(g), l2))))))))));

fc894: (INT, (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

fc895: (INT, (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

t2tb51: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex))): (sort(
  infix_mngt(bitvec1, infix_mngt(bitvec1, matrix(complex1))), t2tb51(x))));

tb2t51: (uni) -> (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex))):PATTERN (
  t2tb51(i)):  (tb2t51(t2tb51(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb51(tb2t51(j))): 
  ((sort(infix_mngt(bitvec1, infix_mngt(bitvec1, matrix(complex1))), j)) => (
  t2tb51(tb2t51(j)) = j)));

% fc'def
  ASSERT
  (FORALL (n2 : INT, f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  l1 : INT, k : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(
  fc894(n2, f, l1)), t2tb26(k))) = ket_sum_l(bitvec1, t2tb28(n_bvs(n2)), 
  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), 
  t2tb26(k)), l1)));

% fc'def
  ASSERT
  (FORALL (n2qt : INT,
  g : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l1qt : INT,
  k : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc895(n2qt,
  g, l1qt)), t2tb26(k))) = ket_sum_l(bitvec1, t2tb28(n_bvs(n2qt)), infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(g), t2tb26(k)),
  l1qt)));

% ket_sum_sum_bvs_eq
  ASSERT
  (FORALL (n1 : INT, n2 : INT, n1qt : INT, n2qt : INT,
  f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  g : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l1 : INT, l2 : INT,
  l1qt : INT, l2qt : INT):
  ((0 <= l1)
  => (((l1 = l2) AND ((l2 = l1qt) AND (l1qt = l2qt)))
     => ((n1 = n1qt)
        => ((0 <= n1)
           => ((n2 = n2qt)
              => ((0 <= n2)
                 => ((FORALL (e : bitvec, eqt : bitvec):
                     ((mem(bitvec1, t2tb26(e), t2tb28(n_bvs(n1))))
                     => ((mem(bitvec1, t2tb26(eqt), t2tb28(n_bvs(n2)))) => (
                        tb2t18(infix_at(matrix(complex1), bitvec1, infix_at(
                        infix_mngt(bitvec1, matrix(complex1)), bitvec1, 
                        t2tb51(f), t2tb26(e)), t2tb26(eqt))) = tb2t18(
                        infix_at(matrix(complex1), bitvec1, infix_at(
                        infix_mngt(bitvec1, matrix(complex1)), bitvec1, 
                        t2tb51(g), t2tb26(e)), t2tb26(eqt)))))))
                    => (ket_sum_l(bitvec1, t2tb28(n_bvs(n1)), t2tb29(
                    fc894(n2, f, l1)), l2) = ket_sum_l(bitvec1, t2tb28(
                    n_bvs(n1qt)), t2tb29(fc895(n2qt, g, l1qt)), l2qt))))))))));

fc896: (INT, (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

fc897: (INT, (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n2 : INT, f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  l1 : INT, k : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(
  fc896(n2, f, l1)), t2tb26(k))) = ket_sum_l(bitvec1, t2tb28(n_bvs(n2)), 
  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), 
  t2tb26(k)), l1)));

% fc'def
  ASSERT
  (FORALL (n2qt : INT,
  g : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l1qt : INT,
  k : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc897(n2qt,
  g, l1qt)), t2tb26(k))) = ket_sum_l(bitvec1, t2tb28(n_bvs(n2qt)), infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(g), t2tb26(k)),
  l1qt)));

% ket_sum_sum_scal_bvs_eq
  ASSERT
  (FORALL (n1 : INT, n2 : INT, n1qt : INT, n2qt : INT,
  f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  g : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l1 : INT, l2 : INT,
  l1qt : INT, l2qt : INT, s11 : complex, s2 : complex):
  ((0 <= l1)
  => (((l1 = l2) AND ((l2 = l1qt) AND (l1qt = l2qt)))
     => ((n1 = n1qt)
        => ((0 <= n1)
           => ((n2 = n2qt)
              => ((s11 = s2)
                 => ((0 <= n2)
                    => ((FORALL (e : bitvec, eqt : bitvec):
                        ((mem(bitvec1, t2tb26(e), t2tb28(n_bvs(n1))))
                        => ((mem(bitvec1, t2tb26(eqt), t2tb28(n_bvs(n2))))
                           => (tb2t18(infix_at(matrix(complex1), bitvec1, 
                           infix_at(infix_mngt(bitvec1, matrix(complex1)),
                           bitvec1, t2tb51(f), t2tb26(e)), t2tb26(eqt))) = 
                           tb2t18(infix_at(matrix(complex1), bitvec1, 
                           infix_at(infix_mngt(bitvec1, matrix(complex1)),
                           bitvec1, t2tb51(g), t2tb26(e)), t2tb26(eqt)))))))
                       => (infix_asdtdt(s11, ket_sum_l(bitvec1, t2tb28(
                       n_bvs(n1)), t2tb29(fc896(n2, f, l1)), l2)) = 
                       infix_asdtdt(s11, ket_sum_l(bitvec1, t2tb28(
                       n_bvs(n1qt)), t2tb29(fc897(n2qt, g, l1qt)), l2qt))))))))))));

fc898: (INT, (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), INT,
  complex) -> (ARRAY bitvec OF matrix_complex);

fc899: (INT, (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n2qt : INT,
  f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l1qt : INT,
  s2 : complex, k : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, 
  t2tb29(fc898(n2qt, f, l1qt, s2)), t2tb26(k))) = infix_asdtdt(s2, 
  ket_sum_l(bitvec1, t2tb28(n_bvs(n2qt)), infix_at(infix_mngt(bitvec1, 
  matrix(complex1)), bitvec1, t2tb51(f), t2tb26(k)), l1qt))));

% fc'def
  ASSERT
  (FORALL (n2 : INT, g : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  l1 : INT, k : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(
  fc899(n2, g, l1)), t2tb26(k))) = ket_sum_l(bitvec1, t2tb28(n_bvs(n2)), 
  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(g), 
  t2tb26(k)), l1)));

% ket_sum_sum_scal_mult_bvs_eq
  ASSERT
  (FORALL (n1 : INT, n2 : INT, n1qt : INT, n2qt : INT,
  f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  g : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l1 : INT, l2 : INT,
  l1qt : INT, l2qt : INT, s11 : complex, s2 : complex, s3 : complex):
  ((0 <= l1)
  => (((l1 = l2) AND ((l2 = l1qt) AND (l1qt = l2qt)))
     => ((n1 = n1qt)
        => ((0 <= n1)
           => ((s3 = infix_asdt(s11, s2))
              => ((n2 = n2qt)
                 => ((0 <= n2)
                    => ((FORALL (e : bitvec, eqt : bitvec):
                        ((mem(bitvec1, t2tb26(e), t2tb28(n_bvs(n1))))
                        => ((mem(bitvec1, t2tb26(eqt), t2tb28(n_bvs(n2))))
                           => (tb2t18(infix_at(matrix(complex1), bitvec1, 
                           infix_at(infix_mngt(bitvec1, matrix(complex1)),
                           bitvec1, t2tb51(f), t2tb26(e)), t2tb26(eqt))) = 
                           tb2t18(infix_at(matrix(complex1), bitvec1, 
                           infix_at(infix_mngt(bitvec1, matrix(complex1)),
                           bitvec1, t2tb51(g), t2tb26(e)), t2tb26(eqt)))))))
                       => (infix_asdtdt(s11, ket_sum_l(bitvec1, t2tb28(
                       n_bvs(n1qt)), t2tb29(fc898(n2qt, f, l1qt, s2)),
                       l2qt)) = infix_asdtdt(s3, ket_sum_l(bitvec1, t2tb28(
                       n_bvs(n1)), t2tb29(fc899(n2, g, l1)), l2))))))))))));

% ket_sum_l_cardone
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((0 <= l)
  => ((cardinal(a, s2) = 1)
     => ((is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f, choose(a, s2))),
        l)) => (ket_sum_l(a, s2, f, l) = tb2t18(infix_at(matrix(complex1), a,
        f, choose(a, s2)))))))));

fc339: (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (us : INT): (tb2t(infix_at(complex1, int, t2tb12(fc339), 
  t2tb5(us))) = c_zero));

% ket_sum_l_empty
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((0 <= l)
  => ((cardinal(a, s2) = 0) => (ket_sum_l(a, s2, f, l) = make_ket(l, fc339))))));

fc900: (ARRAY matrix_complex OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (y0 : matrix_complex, y1 : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), matrix(complex1), t2tb50(fc900), 
  t2tb18(y0)), t2tb5(y1))) = tb2t(get(complex1, t2tb18(y0), y1, 0))));

% ket_sum_l_cardone_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT):
  ((0 <= l)
  => ((cardinal(a, s2) = 1) => (ket_sum_l(a, s2, f, l) = make_ket(l, tb2t12(
     infix_at(infix_mngt(int, complex1), matrix(complex1), t2tb50(fc900), 
     infix_at(matrix(complex1), a, f, choose(a, s2))))))))));

% ket_sum_l_plus_one
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, e : uni, f : uni, l : INT):
  ((0 <= l)
  => ((0 < cardinal(a, s2))
     => ((NOT (mem(a, e, s2))) => (ket_sum_l(a, add(a, e, s2), f, l) = 
        add_ket_l(ket_sum_l(a, s2, f, l), tb2t18(infix_at(matrix(complex1),
        a, f, e)), l)))))));

fc341: ((ARRAY bitvec OF matrix_complex)) -> (ARRAY bitvec OF matrix_complex);

fc342: ((ARRAY bitvec OF matrix_complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), bv : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc341(f)), t2tb26(bv))) = 
  tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(concat_l(bv,
  0))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), bv : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc342(f)), t2tb26(bv))) = 
  tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(concat_l(bv,
  1))))));

% ket_sum_n_bvs_pos
  ASSERT
  (FORALL (n : INT, f : (ARRAY bitvec OF matrix_complex), l : INT):
  ((0 <= l)
  => ((0 < n) => (ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(f), l) = 
     add_ket_l(ket_sum_l(bitvec1, t2tb28(n_bvs((n - 1))), t2tb29(fc341(f)),
     l), ket_sum_l(bitvec1, t2tb28(n_bvs((n - 1))), t2tb29(fc342(f)), l),
     l)))));

% ket_sum_bitvec_one
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), l : INT):
  ((0 <= l) => (ket_sum_l(bitvec1, t2tb28(n_bvs(1)), t2tb29(f), l) = 
  add_ket_l(tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(
  int_to_bv(0, 1)))), tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), 
  t2tb26(int_to_bv(1, 1)))), l))));

% ket_sum_bitvec_zero
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), l : INT, m : INT):
  ((0 <= l)
  => ((m = 0)
     => ((is_a_ket_l(tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), 
        t2tb26(int_to_bv(0, 0)))), l)) => (ket_sum_l(bitvec1, t2tb28(
        n_bvs(m)), t2tb29(f), l) = tb2t18(infix_at(matrix(complex1), bitvec1, 
        t2tb29(f), t2tb26(int_to_bv(0, 0)))))))));

% ket_sum_l_valid_index
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, l : INT, i : INT):
  ((0 <= l)
  => ((0 < cardinal(a, s2))
     => (((0 <= i) AND (i < power(1, l))) => (valid_index(complex1, t2tb18(
        ket_sum_l(a, s2, f, l)), i, 0)))))));

fc343: (ty, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc343(a, x)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex, us : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc343(a, x), us)) = x)));

% ket_sum_const
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, x : matrix_complex, l : INT):
  ((0 <= l)
  => ((is_a_ket_l(x, l)) => (ket_sum_l(a, s2, fc343(a, x), l) = infix_asdtdt(
     i_to_c(cardinal(a, s2)), x))))));

fc344: (ty, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc344(a, x)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex, us : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc344(a, x), us)) = x)));

% ket_sum_const_w
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, x : matrix_complex, l : INT):
  ((0 <= l)
  => ((0 < cardinal(a, s2))
     => ((is_a_ket_l(x, l)) => (infix_asdtdt(infix_sldt(c_one, i_to_c(
        cardinal(a, s2))), ket_sum_l(a, s2, fc344(a, x), l)) = x))))));

fc345: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc345(b, a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY angle OF matrix_complex), t1 : (ARRAY INT OF angle),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc345(angle1, int, 
  t2tb80(f), t2tb35(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1),
  angle1, t2tb80(f), t2tb33((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), t1 : (ARRAY INT OF INT),
  a : INT): (tb2t18(infix_at(matrix(complex1), int, fc345(int, int, 
  t2tb21(f), t2tb7(t1)), t2tb5(a))) = tb2t18(infix_at(matrix(complex1), int, 
  t2tb21(f), t2tb5((t1[a]))))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, t1 : uni, a1 : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc345(b, a, f, t1), a1)) = tb2t18(infix_at(matrix(complex1), b, f, 
  infix_at(b, a, t1, a1))))));

% map_ket_sum_l
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, s2 : uni, t1 : uni, n : INT):
  ((0 <= n)
  => ((p_injective(b, a, t1, s2)) => (ket_sum_l(b, map(b, a, t1, s2), f,
     n) = ket_sum_l(a, s2, fc345(b, a, f, t1), n))))));

% pre_injective_bv_to_int
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((length(bv1) = length(bv2))
  => ((NOT (bv1 = bv2)) => (NOT (bv_to_int(bv1) = bv_to_int(bv2))))));

% injective_bv_to_int
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (p_injective(int, bitvec1, t2tb30(bv_to_int_closure), t2tb28(
  n_bvs(n))))));

% bijective_to_int
  ASSERT
  (FORALL (n : INT):
  ((0 < n) => (p_bijective(int, bitvec1, t2tb30(bv_to_int_closure), t2tb28(
  n_bvs(n)), t2tb6(to_fset(0, power(2, n)))))));

fc346: (INT) -> (ARRAY INT OF bitvec);

t2tb52: ((ARRAY INT OF bitvec)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF bitvec)): (sort(infix_mngt(int, bitvec1), 
  t2tb52(x))));

tb2t52: (uni) -> (ARRAY INT OF bitvec);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF bitvec)):PATTERN (t2tb52(i)):  (tb2t52(
  t2tb52(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb52(tb2t52(j))): 
  ((sort(infix_mngt(int, bitvec1), j)) => (t2tb52(tb2t52(j)) = j)));

% fc'def
  ASSERT
  (FORALL (n : INT, i : INT): (tb2t26(infix_at(bitvec1, int, t2tb52(
  fc346(n)), t2tb5(i))) = int_to_bv(i, n)));

% injective_int_to_bv
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (p_injective(bitvec1, int, t2tb52(fc346(n)), t2tb6(to_fset(0, 
  power(2, n)))))));

% n_bvs_card
  ASSERT
  (FORALL (n : INT):
  ((0 <= n) => (cardinal(bitvec1, t2tb28(n_bvs(n))) = power(2, n))));

fc901: (ARRAY bitvec OF bitvec);

% fc'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(fc901), 
  t2tb26(bv))) = concat_l(bv, 0)));

% concat_first_term_zero
  ASSERT
  (FORALL (e : bitvec, i : INT):
  ((0 <= i)
  => ((mem(bitvec1, t2tb26(e), map(bitvec1, bitvec1, t2tb27(fc901), t2tb28(
     n_bvs(i))))) => ((value(e)[0]) = 0))));

fc902: (ARRAY bitvec OF bitvec);

% fc'def
  ASSERT
  (FORALL (bv : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, t2tb27(fc902), 
  t2tb26(bv))) = concat_l(bv, 1)));

% concat_first_term_one
  ASSERT
  (FORALL (e : bitvec, i : INT):
  ((0 <= i)
  => ((mem(bitvec1, t2tb26(e), map(bitvec1, bitvec1, t2tb27(fc902), t2tb28(
     n_bvs(i))))) => ((value(e)[0]) = 1))));

% bv_sum_to_int_sum
  ASSERT
  (FORALL (n : INT, f : (ARRAY INT OF complex),
  g : (ARRAY bitvec OF complex)):
  ((0 <= n)
  => ((FORALL (x : bitvec):
      ((length(x) = n) => (tb2t(infix_at(complex1, bitvec1, t2tb31(g), 
      t2tb26(x))) = tb2t(infix_at(complex1, int, t2tb12(f), t2tb5(
      bv_to_int(x)))))))
     => (sum(bitvec1, t2tb28(n_bvs(n)), t2tb31(g)) = sum(int, t2tb6(
     to_fset(0, power(2, n))), t2tb12(f))))));

fc903: ((ARRAY bitvec OF matrix_complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), bv : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc903(f)), t2tb26(bv))) = 
  add_mat(tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(
  concat_l(bv, 0)))), tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), 
  t2tb26(concat_l(bv, 1)))))));

% sum_concat
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), i : INT, r : INT, c : INT):
  ((0 < i)
  => ((FORALL (bv : bitvec): (rows(complex1, infix_at(matrix(complex1),
      bitvec1, t2tb29(f), t2tb26(bv))) = r))
     => ((FORALL (bv : bitvec): (columns(complex1, infix_at(matrix(complex1),
         bitvec1, t2tb29(f), t2tb26(bv))) = c))
        => (mat_sum(bitvec1, t2tb28(n_bvs(i)), t2tb29(fc903(f))) = 
        mat_sum(bitvec1, t2tb28(n_bvs((i + 1))), t2tb29(f)))))));

fc904: (complex, complex) -> (ARRAY bitvec OF complex);

% fc'def
  ASSERT
  (FORALL (a : complex, q : complex, i : bitvec): (tb2t(infix_at(complex1,
  bitvec1, t2tb31(fc904(a, q)), t2tb26(i))) = infix_asdt(a, cpower(q, 
  bv_to_int(i)))));

% geometric_series_bv
  ASSERT
  (FORALL (a : complex, q : complex, n : INT):
  ((1 <= n)
  => ((NOT (q = c_one)) => (sum(bitvec1, t2tb28(n_bvs(n)), t2tb31(fc904(a,
     q))) = infix_sldt(infix_asdt(a, infix_mndt(c_one, cpower(q, power(2,
     n)))), infix_mndt(c_one, q))))));

fc905: (complex) -> (ARRAY bitvec OF complex);

% fc'def
  ASSERT
  (FORALL (q : complex, i : bitvec): (tb2t(infix_at(complex1, bitvec1, 
  t2tb31(fc905(q)), t2tb26(i))) = cpower(q, bv_to_int(i))));

% geometric_series_bv_init_one
  ASSERT
  (FORALL (q : complex, n : INT):
  ((1 <= n)
  => ((NOT (q = c_one)) => (sum(bitvec1, t2tb28(n_bvs(n)), t2tb31(
     fc905(q))) = infix_sldt(infix_mndt(c_one, cpower(q, power(2, n))), 
     infix_mndt(c_one, q))))));

fc352: ((ARRAY INT OF matrix_complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), a : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc352(f)), t2tb26(a))) = tb2t18(infix_at(
  matrix(complex1), int, t2tb21(f), t2tb5(bv_to_int(a))))));

% ket_sum_l_to_n_bvs
  ASSERT
  (FORALL (f : (ARRAY INT OF matrix_complex), l : INT, n : INT):
  ((0 <= n)
  => ((0 <= l) => (ket_sum_l(int, t2tb6(to_fset(0, power(2, l))), t2tb21(f),
     n) = ket_sum_l(bitvec1, t2tb28(n_bvs(l)), t2tb29(fc352(f)), n)))));

fc353: ((ARRAY bitvec OF matrix_complex),
  INT) -> (ARRAY INT OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), l : INT, i : INT): (tb2t18(
  infix_at(matrix(complex1), int, t2tb21(fc353(f, l)), t2tb5(i))) = tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(int_to_bv(i, l))))));

% ket_sum_l_to_fset
  ASSERT
  (FORALL (f : (ARRAY bitvec OF matrix_complex), l : INT, n : INT):
  ((0 <= n)
  => ((0 <= l) => (ket_sum_l(bitvec1, t2tb28(n_bvs(l)), t2tb29(f), n) = 
     ket_sum_l(int, t2tb6(to_fset(0, power(2, l))), t2tb21(fc353(f, l)), n)))));

% ket_sum_partition
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, s11 : uni, s21 : uni, f : uni, n : INT):
  ((0 <= n)
  => ((s2 = union(a, s11, s21))
     => ((inter(a, s11, s21) = empty(a)) => (ket_sum_l(a, s2, f, n) = 
        add_ket_l(ket_sum_l(a, s11, f, n), ket_sum_l(a, s21, f, n), n)))))));

fc354: (matrix_complex, INT) -> (ARRAY INT OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : INT, j : INT): (tb2t18(infix_at(
  matrix(complex1), int, t2tb21(fc354(m, n)), t2tb5(j))) = infix_asdtdt(tb2t(
  get(complex1, t2tb18(m), j, 0)), ket(n, j))));

% ket_decomp
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n)
  => ((is_a_ket(m))
     => ((ket_length(m) = n) => (m = mat_sum(int, t2tb6(to_fset(0, power(2,
        n))), t2tb21(fc354(m, n))))))));

fc355: (matrix_complex, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : INT, bvx : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc355(m, n)), t2tb26(bvx))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(m), bv_to_int(bvx), 0)), ket(n, 
  bv_to_int(bvx)))));

% ket_decomp_bv
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n)
  => ((is_a_ket(m))
     => ((ket_length(m) = n) => (m = ket_sum_l(bitvec1, t2tb28(n_bvs(n)), 
        t2tb29(fc355(m, n)), n))))));

fc356: ((ARRAY INT OF complex), INT) -> (ARRAY INT OF matrix_complex);

fc357: ((ARRAY INT OF complex)) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), n : INT, j : INT): (tb2t18(infix_at(
  matrix(complex1), int, t2tb21(fc356(f, n)), t2tb5(j))) = infix_asdtdt(tb2t(
  infix_at(complex1, int, t2tb12(f), t2tb5(j))), ket(n, j))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), x : INT, us : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc357(f)), t2tb5(x)), t2tb5(us))) = tb2t(infix_at(complex1, int, t2tb12(f), 
  t2tb5(x)))));

% ket_recomp
  ASSERT
  (FORALL (f : (ARRAY INT OF complex), n : INT):
  ((0 <= n) => (mat_sum(int, t2tb6(to_fset(0, power(2, n))), t2tb21(fc356(f,
  n))) = tb2t18(make_f(complex1, power(2, n), 1, t2tb15(fc357(f)))))));

fc358: (matrix_complex) -> (ARRAY INT OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, j : INT): (tb2t18(infix_at(matrix(complex1),
  int, t2tb21(fc358(m)), t2tb5(j))) = infix_asdtdt(tb2t(get(complex1, 
  t2tb18(m), j, 0)), ket(ket_length(m), j))));

% ket_decomp_quant
  ASSERT
  (FORALL (m : matrix_complex):
  ((is_a_ket(m)) => (m = mat_sum(int, t2tb6(to_fset(0, power(2, 
  ket_length(m)))), t2tb21(fc358(m))))));

fc359: (matrix_complex, matrix_complex) -> (ARRAY INT OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex, k : INT): (tb2t18(
  infix_at(matrix(complex1), int, t2tb21(fc359(m, x)), t2tb5(k))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(m), k, ket_to_int(x))), ket(
  ket_length(x), k))));

% mat_mult_ket_basis
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex):
  ((is_a_ket_basis_elt(x))
  => (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(m))) AND (
      rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(x))))
     => (mat_mult(m, x) = mat_sum(int, t2tb6(to_fset(0, rows(complex1, 
     t2tb18(x)))), t2tb21(fc359(m, x)))))));

% ket_mult_diag
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex):
  ((1 <= ket_length(x))
  => ((is_a_ket_basis_elt(x))
     => ((rows(complex1, t2tb18(m)) = power(2, ket_length(x)))
        => ((columns(complex1, t2tb18(m)) = power(2, ket_length(x)))
           => ((FORALL (i : INT, j : INT):
               (((0 <= i) AND (i < power(2, ket_length(x))))
               => (((0 <= j) AND (j < power(2, ket_length(x))))
                  => ((NOT (i = j)) => (tb2t(get(complex1, t2tb18(m), i,
                     j)) = c_zero)))))
              => (mat_mult(m, x) = infix_asdtdt(tb2t(get(complex1, t2tb18(m), 
              ket_to_int(x), ket_to_int(x))), ket(ket_length(x), 
              ket_to_int(x))))))))));

fc360: (matrix_complex, matrix_complex,
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex, n : INT, bvx : bitvec): (
  tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc360(m, x, n)), 
  t2tb26(bvx))) = infix_asdtdt(tb2t(get(complex1, t2tb18(m), bv_to_int(bvx), 
  ket_to_int(x))), ket(n, bv_to_int(bvx)))));

% mat_mult_ket_basis_bv
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex, n : INT):
  ((ket_length(x) = n)
  => ((is_a_ket_basis_elt(x))
     => (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(m))) AND (
         rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(x))))
        => (mat_mult(m, x) = ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(
        fc360(m, x, n)), n))))));

fc361: (matrix_complex, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex, bvx : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc361(m, x)), t2tb26(bvx))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(m), bv_to_int(bvx), ket_to_int(x))), 
  ket(ket_length(x), bv_to_int(bvx)))));

% mat_mult_ket_basis_bv_gen
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex):
  ((is_a_ket_basis_elt(x))
  => (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(m))) AND (
      rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(x))))
     => (mat_mult(m, x) = ket_sum_l(bitvec1, t2tb28(n_bvs(ket_length(x))), 
     t2tb29(fc361(m, x)), ket_length(x))))));

fc906: (matrix_complex, matrix_complex,
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex, n : INT, bvx : bitvec): (
  tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc906(m, x, n)), 
  t2tb26(bvx))) = infix_asdtdt(tb2t(get(complex1, t2tb18(x), bv_to_int(bvx),
  0)), mat_mult(m, ket(n, bv_to_int(bvx))))));

% mat_mult_ket_bv
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex, n : INT):
  ((is_a_ket_l(x, n))
  => (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(m)))
      AND ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(x))) AND (
          rows(complex1, t2tb18(x)) = power(2, n))))
     => (mat_mult(m, x) = ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(
     fc906(m, x, n)), n)))));

fc907: (matrix_complex, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex, bvx : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc907(m, x)), t2tb26(bvx))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(x), bv_to_int(bvx), 0)), mat_mult(m, 
  ket(ket_length(x), bv_to_int(bvx))))));

% mat_mult_ket_bv_gen
  ASSERT
  (FORALL (m : matrix_complex, x : matrix_complex):
  ((is_a_ket(x))
  => (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(m))) AND (
      rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(x))))
     => (mat_mult(m, x) = ket_sum_l(bitvec1, t2tb28(n_bvs(ket_length(x))), 
     t2tb29(fc907(m, x)), ket_length(x))))));

fc364: (ty, matrix_complex, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : matrix_complex, x1 : uni): (sort(infix_mngt(a, 
  matrix(complex1)), fc364(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : matrix_complex, f : uni, x : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc364(a, m, f), x)) = mat_mult(m, tb2t18(infix_at(
  matrix(complex1), a, f, x))))));

% mat_mult_ket_sum_l
  ASSERT
  (FORALL (a : ty):
  (FORALL (m : matrix_complex, s2 : uni, f : uni, l : INT):
  ((0 < cardinal(a, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a,
         f, e)), l)))))
     => (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(m))) AND (
         rows(complex1, t2tb18(m)) = power(2, l)))
        => (mat_mult(m, ket_sum_l(a, s2, f, l)) = ket_sum_l(a, s2, fc364(a,
        m, f), l)))))));

fc908: ((ARRAY INT OF INT), (ARRAY INT OF complex),
  INT) -> (ARRAY INT OF matrix_complex);

fc909: ((ARRAY INT OF INT), set_int, set_int, (ARRAY INT OF complex),
  INT) -> (ARRAY INT OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : (ARRAY INT OF complex), n : INT,
  j : INT): (tb2t18(infix_at(matrix(complex1), int, t2tb21(fc908(f, a, n)), 
  t2tb5(j))) = infix_asdtdt(tb2t(infix_at(complex1, int, t2tb12(a), 
  t2tb5(j))), tb2t18(set1(complex1, make(complex1, n, 1, t2tb(c_zero)),
  (f[j]), 0, t2tb(c_one))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int,
  a : (ARRAY INT OF complex), n : INT, j : INT): (tb2t18(infix_at(
  matrix(complex1), int, t2tb21(fc909(f, s2, sqt, a, n)), t2tb5(j))) = 
  infix_asdtdt(tb2t(infix_at(complex1, int, t2tb12(a), inv_func(int, int, 
  t2tb7(f), t2tb6(s2), t2tb6(sqt), t2tb5(j)))), tb2t18(set1(complex1, 
  make(complex1, n, 1, t2tb(c_zero)), j, 0, t2tb(c_one))))));

% fun_inversion_pre
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), s2 : set_int, sqt : set_int,
  a : (ARRAY INT OF complex), n : INT):
  ((0 <= n)
  => ((0 < cardinal(int, t2tb6(s2)))
     => ((p_bijective(int, int, t2tb7(f), t2tb6(s2), t2tb6(sqt)))
        => ((subset(int, t2tb6(s2), t2tb6(to_fset(0, n))))
           => ((subset(int, t2tb6(sqt), t2tb6(to_fset(0, n)))) => (
              mat_sum(int, t2tb6(s2), t2tb21(fc908(f, a, n))) = mat_sum(int, 
              t2tb6(sqt), t2tb21(fc909(f, s2, sqt, a, n))))))))));

fc910: ((ARRAY INT OF INT), (ARRAY INT OF complex),
  matrix_complex) -> (ARRAY INT OF matrix_complex);

fc911: ((ARRAY INT OF INT), (ARRAY INT OF complex), matrix_complex,
  INT) -> (ARRAY INT OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : (ARRAY INT OF complex),
  m : matrix_complex, j : INT): (tb2t18(infix_at(matrix(complex1), int, 
  t2tb21(fc910(f, a, m)), t2tb5(j))) = infix_asdtdt(tb2t(infix_at(complex1,
  int, t2tb12(a), t2tb5(j))), ket(ket_length(m), (f[j])))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : (ARRAY INT OF complex),
  m : matrix_complex, pow_2_n : INT, j : INT): (tb2t18(infix_at(
  matrix(complex1), int, t2tb21(fc911(f, a, m, pow_2_n)), t2tb5(j))) = 
  infix_asdtdt(tb2t(infix_at(complex1, int, t2tb12(a), inv_(int, int, 
  t2tb7(f), t2tb6(to_fset(0, pow_2_n)), t2tb6(to_fset(0, pow_2_n)), 
  t2tb5(j)))), ket(ket_length(m), j))));

% ket_fun_inversion
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), a : (ARRAY INT OF complex),
  m : matrix_complex, pow_2_n : INT):
  ((pow_2_n = power(2, ket_length(m)))
  => ((is_a_ket(m))
     => ((0 < pow_2_n)
        => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, pow_2_n)), 
           t2tb6(to_fset(0, pow_2_n))))
           => ((m = mat_sum(int, t2tb6(to_fset(0, pow_2_n)), t2tb21(fc910(f,
              a, m)))) => (m = mat_sum(int, t2tb6(to_fset(0, pow_2_n)), 
              t2tb21(fc911(f, a, m, pow_2_n))))))))));

% ket_sum_partition_filter
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, p1 : uni, p2 : uni, n : INT):
  ((0 <= n)
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2))
         => ((tb2t2(infix_at(bool, a, p1, e)) = 0bin1)
            <=> (NOT (tb2t2(infix_at(bool, a, p2, e)) = 0bin1))))))
     => (ket_sum_l(a, s2, f, n) = add_ket_l(ket_sum_l(a, my_filter(a, s2,
     p1), f, n), ket_sum_l(a, my_filter(a, s2, p2), f, n), n))))));

% kronecker_neutral_ket_l
  ASSERT (is_a_ket_l(tb2t18(make(complex1, 1, 1, t2tb(c_one))), 0));

% kronecker_neutral_ket_basis
  ASSERT (is_a_ket_basis_elt(tb2t18(make(complex1, 1, 1, t2tb(c_one)))));

% equals_kronecker_neutral
  ASSERT
  (FORALL (n : matrix_complex):
  ((is_a_ket_l(n, 0))
  => ((is_a_ket_basis_elt(n)) => (n = tb2t18(make(complex1, 1, 1, 
     t2tb(c_one)))))));

% get_kronecker_neutral
  ASSERT
  (FORALL (a : matrix_complex, n : matrix_complex):
  ((is_a_ket_l(n, 0)) => ((is_a_ket_basis_elt(n)) => (kronecker(a, n) = a))));

% get_neutral_kronecker
  ASSERT
  (FORALL (a : matrix_complex, n : matrix_complex):
  ((is_a_ket_l(n, 0)) => ((is_a_ket_basis_elt(n)) => (kronecker(n, a) = a))));

% set_kronecker_neutral
  ASSERT
  (FORALL (a : matrix_complex): (a = kronecker(a, tb2t18(make(complex1, 1, 1, 
  t2tb(c_one))))));

% set_neutral_kronecker
  ASSERT
  (FORALL (a : matrix_complex): (a = kronecker(tb2t18(make(complex1, 1, 1, 
  t2tb(c_one))), a)));

hpart_ket: (matrix_complex, INT) -> matrix_complex;

% hpart_ket'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket_basis_elt(m))
  => (((0 <= i) AND (i <= ket_length(m))) => (hpart_ket(m, i) = ket(i, div(
     ket_to_int(m), power(2, (ket_length(m) - i))))))));

% hpart_ket'spec
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket_basis_elt(m))
  => (((0 <= i) AND (i <= ket_length(m)))
     => ((is_a_ket_basis_elt(hpart_ket(m, i)))
        AND ((ket_length(hpart_ket(m, i)) = i) AND (ket_to_int(hpart_ket(m,
            i)) = div(ket_to_int(m), power(2, (ket_length(m) - i)))))))));

% hpart_ket_rows
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket_basis_elt(m))
  => (((0 <= i) AND (i <= ket_length(m))) => (rows(complex1, t2tb18(
     hpart_ket(m, i))) = power(2, i)))));

% hpart_ket_l
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT):
  ((is_a_ket_basis_elt(m))
  => (((0 <= i) AND (i <= ket_length(m)))
     => ((i = j) => (is_a_ket_l(hpart_ket(m, i), j))))));

tpart_ket: (matrix_complex, INT) -> matrix_complex;

% tpart_ket'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket_basis_elt(m))
  => (((0 <= i) AND (i <= ket_length(m))) => (tpart_ket(m, i) = ket((
     ket_length(m) - i), mod(ket_to_int(m), power(2, (ket_length(m) - i))))))));

% tpart_ket'spec
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket_basis_elt(m))
  => (((0 <= i) AND (i <= ket_length(m)))
     => ((is_a_ket_basis_elt(tpart_ket(m, i)))
        AND ((ket_length(tpart_ket(m, i)) = (ket_length(m) - i)) AND (
            ket_to_int(tpart_ket(m, i)) = mod(ket_to_int(m), power(2, (
            ket_length(m) - i)))))))));

% tpart_ket_l
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT):
  ((is_a_ket_basis_elt(m))
  => (((0 <= i) AND (i <= ket_length(m)))
     => ((j = (ket_length(m) - i)) => (is_a_ket_l(tpart_ket(m, i), j))))));

% tpart_ket_rows
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket_basis_elt(m))
  => (((0 <= i) AND (i <= ket_length(m))) => (rows(complex1, t2tb18(
     tpart_ket(m, i))) = power(2, (ket_length(m) - i))))));

% concat_ket
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_basis_elt(x))
  => ((is_a_ket_basis_elt(y))
     => ((is_a_ket_basis_elt(kronecker(x, y)))
        AND ((ket_length(kronecker(x, y)) = (ket_length(x) + ket_length(y)))
            AND (ket_to_int(kronecker(x, y)) = ((ket_to_int(x) * power(2, 
            ket_length(y))) + ket_to_int(y))))))));

% concat_ht_part_ket
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket_basis_elt(m))
  => (((0 <= i) AND (i <= ket_length(m))) => (kronecker(hpart_ket(m, i), 
     tpart_ket(m, i)) = m))));

% ket_ht_decomp
  ASSERT
  (FORALL (n : INT, i : INT, j : INT):
  (((0 <= i) AND (i <= n))
  => (((0 <= j) AND (j < power(2, n))) => (ket(n, j) = kronecker(hpart_ket(
     ket(n, j), i), tpart_ket(ket(n, j), i))))));

% ket_ht_decomp_quant
  ASSERT
  (FORALL (n : INT, i : INT):
  (((0 <= i) AND (i <= n))
  => (FORALL (j : INT):
     (((0 <= j) AND (j < power(2, n))) => (ket(n, j) = kronecker(hpart_ket(
     ket(n, j), i), tpart_ket(ket(n, j), i)))))));

fc369: (matrix_complex, INT) -> (ARRAY INT OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT): (tb2t18(infix_at(
  matrix(complex1), int, t2tb21(fc369(m, i)), t2tb5(j))) = infix_asdtdt(tb2t(
  get(complex1, t2tb18(m), j, 0)), kronecker(hpart_ket(ket(ket_length(m), j),
  i), tpart_ket(ket(ket_length(m), j), i)))));

% ht_decomp
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((is_a_ket(m))
  => (((0 <= i) AND (i <= ket_length(m))) => (m = mat_sum(int, t2tb6(
     to_fset(0, power(2, ket_length(m)))), t2tb21(fc369(m, i)))))));

% not_null_ket_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_basis_elt(x)) => (NOT (null_mat(x)))));

ket_to_bv: (matrix_complex) -> bitvec;

% ket_to_bv'def
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_basis_elt(x)) => (ket_to_bv(x) = int_to_bv(ket_to_int(x), 
  ket_length(x)))));

% ket_to_bv'spec
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_basis_elt(x))
  => ((bv_to_int(ket_to_bv(x)) = ket_to_int(x))
     AND ((length(ket_to_bv(x)) = ket_length(x)) AND (mem(bitvec1, t2tb26(
         ket_to_bv(x)), t2tb28(n_bvs(ket_length(x)))))))));

% ket_to_bv_length
  ASSERT
  (FORALL (x : matrix_complex, n : INT):
  ((is_a_ket_basis_elt(x))
  => ((ket_length(x) = n) => (length(ket_to_bv(x)) = n))));

bv_to_ket: (bitvec) -> matrix_complex;

% bv_to_ket'def
  ASSERT
  (FORALL (bv : bitvec): (bv_to_ket(bv) = ket(length(bv), bv_to_int(bv))));

% bv_to_ket'spec
  ASSERT
  (FORALL (bv : bitvec):
  ((is_a_ket_basis_elt(bv_to_ket(bv)))
  AND ((ket_to_int(bv_to_ket(bv)) = bv_to_int(bv))
      AND ((is_a_ket_l(bv_to_ket(bv), length(bv)))
          AND ((rows(complex1, t2tb18(bv_to_ket(bv))) = power(2, length(bv)))
              AND ((columns(complex1, t2tb18(bv_to_ket(bv))) = 1) AND (
                  bv_to_ket(bv) = bin_to_ket(length(bv), value(bv)))))))));

% ket_to_bv_ket_length
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (length(ket_to_bv(ket(n, i))) = n))));

% is_a_ket_l_bv_to_ket
  ASSERT
  (FORALL (bv : bitvec, l : INT):
  ((length(bv) = l) => (is_a_ket_l(bv_to_ket(bv), l))));

% is_a_ket_l_bv_to_ket_
  ASSERT
  (FORALL (bv : bitvec, l : INT):
  ((mem(bitvec1, t2tb26(bv), t2tb28(n_bvs(l))))
  => ((0 <= l) => (is_a_ket_l(bv_to_ket(bv), l)))));

% bin_to_ket_to_bv_to_ket
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((0 <= n)
  => ((binary(f)) => (bin_to_ket(n, f) = bv_to_ket(make_bv(f, n))))));

% bin_to_ket_to_bv_to_ket_abs
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, a : bitvec):
  ((0 <= n)
  => ((a = make_bv(f, n))
     => ((binary(f)) => (bin_to_ket(n, f) = bv_to_ket(a))))));

% ket_to_int_to_bv_to_ket
  ASSERT
  (FORALL (n : INT, e : bitvec):
  ((0 <= n)
  => ((mem(bitvec1, t2tb26(e), t2tb28(n_bvs(n)))) => (ket(n, bv_to_int(e)) = 
     bv_to_ket(e)))));

% ket_to_bv_ket
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (ket_to_bv(ket(n, i)) = 
     int_to_bv(i, n)))));

% bv_to_ket_length
  ASSERT (FORALL (bv : bitvec): (ket_length(bv_to_ket(bv)) = length(bv)));

% get_ket_bv_to_ket_length
  ASSERT
  (FORALL (bv : bitvec, k : INT):
  (((0 <= k) AND (k < power(2, length(bv)))) => (tb2t(get(complex1, t2tb18(
  bv_to_ket(bv)), k,
  0)) = (IF (k = bv_to_int(bv)) THEN c_one ELSE c_zero ENDIF))));

% is_a_ket_l_bvs
  ASSERT
  (FORALL (e : bitvec, n : INT):
  ((0 <= n)
  => ((mem(bitvec1, t2tb26(e), t2tb28(n_bvs(n)))) => (is_a_ket_l(
     bv_to_ket(e), n)))));

% is_a_ket_l_scal_bvs
  ASSERT
  (FORALL (e : bitvec, n : INT, a : complex):
  ((0 <= n)
  => ((mem(bitvec1, t2tb26(e), t2tb28(n_bvs(n)))) => (is_a_ket_l(
     infix_asdtdt(a, bv_to_ket(e)), n)))));

% ket_to_bv_concat
  ASSERT
  (FORALL (x : bitvec, y : bitvec): (bv_to_ket(concat(x, y)) = kronecker(
  bv_to_ket(x), bv_to_ket(y))));

% bv_to_ket_concat_rev
  ASSERT
  (FORALL (x : bitvec, y : bitvec): (kronecker(bv_to_ket(x), bv_to_ket(y)) = 
  bv_to_ket(concat(x, y))));

% bv_to_ket_kronecker
  ASSERT
  (FORALL (x : bitvec, i : INT):
  (((0 <= i) AND (i <= length(x))) => (bv_to_ket(x) = kronecker(hpart_ket(
  bv_to_ket(x), i), tpart_ket(bv_to_ket(x), i)))));

% bv_to_ket_kronecker_
  ASSERT
  (FORALL (x : bitvec, i : INT):
  (((0 <= i) AND (i <= length(x))) => (bv_to_ket(x) = kronecker(bv_to_ket(
  hpart(x, i)), bv_to_ket(tpart(x, i))))));

% bv_to_ket_to_bv
  ASSERT (FORALL (bv : bitvec): (ket_to_bv(bv_to_ket(bv)) = bv));

% ket_to_bv_to_ket
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_basis_elt(x)) => (bv_to_ket(ket_to_bv(x)) = x)));

% bv_to_ket_eq
  ASSERT
  (FORALL (bv1 : bitvec, bv2 : bitvec):
  ((length(bv1) = length(bv2))
  => ((FORALL (i : INT):
      (((0 <= i) AND (i < length(bv1))) => ((value(bv1)[i]) = (
      value(bv2)[i]))))
     => (bv_to_ket(bv1) = bv_to_ket(bv2)))));

fc912: (matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, bvx : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc912(m)), t2tb26(bvx))) = infix_asdtdt(
  tb2t(get(complex1, t2tb18(m), bv_to_int(bvx), 0)), bv_to_ket(bvx))));

% ket_decomp_
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n)
  => ((is_a_ket(m))
     => ((ket_length(m) = n) => (m = ket_sum_l(bitvec1, t2tb28(n_bvs(n)), 
        t2tb29(fc912(m)), n))))));

% ket_bv_to_int_to_bv_to_ket
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((n = length(x)) => (ket(n, bv_to_int(x)) = bv_to_ket(x))));

% ket_to_bv_kronecker
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_basis_elt(x))
  => ((is_a_ket_basis_elt(y)) => (ket_to_bv(kronecker(x, y)) = concat(
     ket_to_bv(x), ket_to_bv(y))))));

fc913: (matrix_complex, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : INT, bvx : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc913(m, n)), t2tb26(bvx))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(m), bv_to_int(bvx), 0)), ket(n, 
  bv_to_int(bvx)))));

% ket_decomp_bv_ket
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n)
  => ((is_a_ket(m))
     => ((ket_length(m) = n) => (m = ket_sum_l(bitvec1, t2tb28(n_bvs(n)), 
        t2tb29(fc913(m, n)), n))))));

fc914: (ARRAY INT OF INT);

% fc'def
  ASSERT (FORALL (us : INT): ((fc914[us]) = 0));

% ket_zero
  ASSERT
  (FORALL (n : INT):
  ((0 <= n)
  => ((is_a_ket_l(ket(n, 0), n))
     AND ((is_a_ket_basis_elt(ket(n, 0)))
         AND ((ket_to_bv(ket(n, 0)) = make_bv(fc914, n))
             AND (FORALL (i : INT):
                 (((0 <= i) AND (i < n)) => ((value(ket_to_bv(ket(n,
                 0)))[i]) = 0))))))));

fc373: ((ARRAY bitvec OF complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF complex), x : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc373(f)), t2tb26(x))) = infix_asdtdt(
  tb2t(infix_at(complex1, bitvec1, t2tb31(f), t2tb26(x))), bv_to_ket(x))));

% uniform_ket_norm_l
  ASSERT
  (FORALL (x : matrix_complex, f : (ARRAY bitvec OF complex), n : INT):
  ((is_a_ket_l(x, n))
  => ((FORALL (e : bitvec):
      ((mem(bitvec1, t2tb26(e), t2tb28(n_bvs(n)))) => (modulus(tb2t(
      infix_at(complex1, bitvec1, t2tb31(f), t2tb26(e)))) = c_one)))
     => ((x = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(
        n_bvs(n)), t2tb29(fc373(f)), n))) => (ket_norm_l(x, n) = c_one)))));

ket_sum_l_diag: ((ARRAY bitvec OF complex), INT) -> matrix_complex;

result40: ((ARRAY bitvec OF complex)) -> (ARRAY bitvec OF matrix_complex);

% result'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF complex), x : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(result40(f)), t2tb26(x))) = infix_asdtdt(
  tb2t(infix_at(complex1, bitvec1, t2tb31(f), t2tb26(x))), bv_to_ket(x))));

% ket_sum_l_diag'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF complex), l : INT):
  ((0 <= l) => (ket_sum_l_diag(f, l) = ket_sum_l(bitvec1, t2tb28(n_bvs(l)), 
  t2tb29(result40(f)), l))));

% ket_sum_l_diag'spec
  ASSERT
  (FORALL (f : (ARRAY bitvec OF complex), l : INT):
  ((0 <= l)
  => ((is_a_ket_l(ket_sum_l_diag(f, l), l))
     AND (FORALL (i : INT):
         (((0 <= i) AND (i < power(2, l))) => (tb2t(get(complex1, t2tb18(
         ket_sum_l_diag(f, l)), i, 0)) = tb2t(infix_at(complex1, bitvec1, 
         t2tb31(f), t2tb26(int_to_bv(i, l))))))))));

fc915: ((ARRAY bitvec OF complex)) -> (ARRAY bitvec OF matrix_complex);

fc916: ((ARRAY bitvec OF complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF complex), x : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc915(f)), t2tb26(x))) = infix_asdtdt(
  tb2t(infix_at(complex1, bitvec1, t2tb31(f), t2tb26(x))), bv_to_ket(x))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF complex), x : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc916(f)), t2tb26(x))) = infix_asdtdt(
  tb2t(infix_at(complex1, bitvec1, t2tb31(f), t2tb26(x))), bv_to_ket(x))));

% ket_sum_of_scalars
  ASSERT
  (FORALL (f : (ARRAY bitvec OF complex), n : INT):
  ((0 <= n)
  => ((is_a_ket_l(ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc915(f)), n),
     n))
     AND (FORALL (i : INT):
         (((0 <= i) AND (i < power(2, n))) => (tb2t(get(complex1, t2tb18(
         ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc916(f)), n)), i,
         0)) = tb2t(infix_at(complex1, bitvec1, t2tb31(f), t2tb26(
         int_to_bv(i, n))))))))));

fc917: (ty, ty, uni, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc917(b, a, x, x1)))));

fc918: (ty, ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (x : uni): (sort(infix_mngt(tuple2(a, b), matrix(complex1)), 
  fc918(b, a, x)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s2 : uni, f : uni, a1 : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc917(b, a, s2, f), a1)) = mat_sum(b, s2, infix_at(infix_mngt(b, 
  matrix(complex1)), a, f, a1)))));

% fc'def
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (f : uni, o : uni): (tb2t18(infix_at(matrix(complex1), tuple2(a,
  b), fc918(b, a, f), o)) = tb2t18(infix_at(matrix(complex1), b, infix_at(
  infix_mngt(b, matrix(complex1)), a, f, fir(b, a, o)), sec(b, a, o))))));

% mat_sum_sum_cartesian_product_pre
  ASSERT
  (FORALL (a : ty, b : ty):
  (FORALL (s11 : uni, s2 : uni, f : uni, r : INT, c : INT):
  ((0 < r)
  => ((0 < c)
     => ((FORALL (a1 : uni, b1 : uni):
         ((sort(a, a1))
         => ((sort(b, b1))
            => ((mem(a, a1, s11))
               => ((mem(b, b1, s2)) => (rows(complex1, infix_at(
                  matrix(complex1), b, infix_at(infix_mngt(b, 
                  matrix(complex1)), a, f, a1), b1)) = r))))))
        => ((FORALL (a1 : uni, b1 : uni):
            ((sort(a, a1))
            => ((sort(b, b1))
               => ((mem(a, a1, s11))
                  => ((mem(b, b1, s2)) => (columns(complex1, infix_at(
                     matrix(complex1), b, infix_at(infix_mngt(b, 
                     matrix(complex1)), a, f, a1), b1)) = c))))))
           => ((0 < cardinal(a, s11))
              => ((0 < cardinal(b, s2)) => (mat_sum(a, s11, fc917(b, a, s2,
                 f)) = mat_sum(tuple2(a, b), cartesian_product(b, a, s11,
                 s2), fc918(b, a, f)))))))))));

fc378: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

fc379: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), x : INT,
  bvy : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc378(f,
  x)), t2tb26(bvy))) = mat_sum(bitvec1, t2tb28(n_bvs(x)), infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), t2tb26(bvy)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), y : INT,
  bv : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc379(f,
  y)), t2tb26(bv))) = tb2t18(infix_at(matrix(complex1), bitvec1, infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), t2tb26(hpart(bv,
  y))), t2tb26(tpart(bv, y))))));

% mat_sum_comp
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  x : INT, y : INT):
  ((0 <= x)
  => ((0 <= y)
     => ((0 <= l)
        => ((FORALL (bvx : bitvec, bvy : bitvec):
            ((mem(bitvec1, t2tb26(bvx), t2tb28(n_bvs(x))))
            => ((mem(bitvec1, t2tb26(bvy), t2tb28(n_bvs(y)))) => (is_a_ket(
               tb2t18(infix_at(matrix(complex1), bitvec1, infix_at(
               infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), 
               t2tb26(bvy)), t2tb26(bvx))))))))
           => ((FORALL (bvx : bitvec, bvy : bitvec):
               ((mem(bitvec1, t2tb26(bvx), t2tb28(n_bvs(x))))
               => ((mem(bitvec1, t2tb26(bvy), t2tb28(n_bvs(y)))) => (
                  ket_length(tb2t18(infix_at(matrix(complex1), bitvec1, 
                  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, 
                  t2tb51(f), t2tb26(bvy)), t2tb26(bvx)))) = l))))
              => (mat_sum(bitvec1, t2tb28(n_bvs(y)), t2tb29(fc378(f, x))) = 
              mat_sum(bitvec1, t2tb28(n_bvs((x + y))), t2tb29(fc379(f, y))))))))));

fc380: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

fc381: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), y : INT,
  bv : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc380(f,
  y)), t2tb26(bv))) = tb2t18(infix_at(matrix(complex1), bitvec1, infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), t2tb26(hpart(bv,
  y))), t2tb26(tpart(bv, y))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), x : INT,
  bvy : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc381(f,
  x)), t2tb26(bvy))) = mat_sum(bitvec1, t2tb28(n_bvs(x)), infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), t2tb26(bvy)))));

% mat_sum_comp_rev
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  x : INT, y : INT):
  ((0 <= x)
  => ((0 <= y)
     => ((0 <= l)
        => ((FORALL (bvx : bitvec, bvy : bitvec):
            ((mem(bitvec1, t2tb26(bvx), t2tb28(n_bvs(x))))
            => ((mem(bitvec1, t2tb26(bvy), t2tb28(n_bvs(y)))) => (is_a_ket(
               tb2t18(infix_at(matrix(complex1), bitvec1, infix_at(
               infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), 
               t2tb26(bvy)), t2tb26(bvx))))))))
           => ((FORALL (bvx : bitvec, bvy : bitvec):
               ((mem(bitvec1, t2tb26(bvx), t2tb28(n_bvs(x))))
               => ((mem(bitvec1, t2tb26(bvy), t2tb28(n_bvs(y)))) => (
                  ket_length(tb2t18(infix_at(matrix(complex1), bitvec1, 
                  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, 
                  t2tb51(f), t2tb26(bvy)), t2tb26(bvx)))) = l))))
              => (mat_sum(bitvec1, t2tb28(n_bvs((x + y))), t2tb29(fc380(f,
              y))) = mat_sum(bitvec1, t2tb28(n_bvs(y)), t2tb29(fc381(f,
              x))))))))));

fc382: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  (ARRAY bitvec OF complex), INT, INT) -> (ARRAY bitvec OF matrix_complex);

fc383: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  (ARRAY bitvec OF complex), INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  scal : (ARRAY bitvec OF complex), l : INT, x : INT, bvy : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc382(f, scal, l, x)), 
  t2tb26(bvy))) = infix_asdtdt(tb2t(infix_at(complex1, bitvec1, t2tb31(scal), 
  t2tb26(bvy))), ket_sum_l(bitvec1, t2tb28(n_bvs(x)), infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), t2tb26(bvy)),
  l))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  scal : (ARRAY bitvec OF complex), y : INT, bv : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc383(f, scal, y)), t2tb26(bv))) = 
  infix_asdtdt(tb2t(infix_at(complex1, bitvec1, t2tb31(scal), t2tb26(
  hpart(bv, y)))), tb2t18(infix_at(matrix(complex1), bitvec1, infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), t2tb26(hpart(bv,
  y))), t2tb26(tpart(bv, y)))))));

% ket_sum_bin_comp_l
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  scal : (ARRAY bitvec OF complex), l : INT, x : INT, y : INT):
  ((0 <= x)
  => ((0 <= y)
     => ((0 <= l) => (ket_sum_l(bitvec1, t2tb28(n_bvs(y)), t2tb29(fc382(f,
        scal, l, x)), l) = ket_sum_l(bitvec1, t2tb28(n_bvs((x + y))), t2tb29(
        fc383(f, scal, y)), l))))));

fc384: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), INT,
  INT) -> (ARRAY bitvec OF matrix_complex);

fc385: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  x : INT, bvy : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(
  fc384(f, l, x)), t2tb26(bvy))) = ket_sum_l(bitvec1, t2tb28(n_bvs(x)), 
  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), 
  t2tb26(bvy)), l)));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), y : INT,
  bv : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc385(f,
  y)), t2tb26(bv))) = tb2t18(infix_at(matrix(complex1), bitvec1, infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), t2tb26(hpart(bv,
  y))), t2tb26(tpart(bv, y))))));

% ket_sum_bin_comp
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  x : INT, y : INT):
  ((0 <= x)
  => ((0 <= y)
     => ((0 <= l) => (ket_sum_l(bitvec1, t2tb28(n_bvs(y)), t2tb29(fc384(f, l,
        x)), l) = ket_sum_l(bitvec1, t2tb28(n_bvs((x + y))), t2tb29(fc385(f,
        y)), l))))));

fc386: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

fc387: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), INT,
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), y : INT,
  bv : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc386(f,
  y)), t2tb26(bv))) = tb2t18(infix_at(matrix(complex1), bitvec1, infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), t2tb26(hpart(bv,
  y))), t2tb26(tpart(bv, y))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  x : INT, bvy : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(
  fc387(f, l, x)), t2tb26(bvy))) = ket_sum_l(bitvec1, t2tb28(n_bvs(x)), 
  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), 
  t2tb26(bvy)), l)));

% ket_sum_bin_comp_rev
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  x : INT, y : INT):
  ((0 <= x)
  => ((0 <= y)
     => ((0 <= l) => (ket_sum_l(bitvec1, t2tb28(n_bvs((x + y))), t2tb29(
        fc386(f, y)), l) = ket_sum_l(bitvec1, t2tb28(n_bvs(y)), t2tb29(
        fc387(f, l, x)), l))))));

fc388: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)),
  INT) -> (ARRAY bitvec OF matrix_complex);

fc389: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), INT,
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), x : INT,
  bv : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc388(f,
  x)), t2tb26(bv))) = tb2t18(infix_at(matrix(complex1), bitvec1, infix_at(
  infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), t2tb26(hpart(bv,
  x))), t2tb26(tpart(bv, x))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  y : INT, bvx : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(
  fc389(f, l, y)), t2tb26(bvx))) = ket_sum_l(bitvec1, t2tb28(n_bvs(y)), 
  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), 
  t2tb26(bvx)), l)));

% ket_sum_bin_comp_rev_
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  x : INT, y : INT):
  ((0 <= x)
  => ((0 <= y)
     => ((0 <= l) => (ket_sum_l(bitvec1, t2tb28(n_bvs((x + y))), t2tb29(
        fc388(f, x)), l) = ket_sum_l(bitvec1, t2tb28(n_bvs(x)), t2tb29(
        fc389(f, l, y)), l))))));

% ket_sum_bv_to_ints
  ASSERT
  (FORALL (n : INT, f : (ARRAY bitvec OF matrix_complex),
  g : (ARRAY INT OF matrix_complex)):
  ((0 <= n)
  => ((FORALL (x : bitvec):
      ((length(x) = n) => (tb2t18(infix_at(matrix(complex1), bitvec1, 
      t2tb29(f), t2tb26(x))) = tb2t18(infix_at(matrix(complex1), int, 
      t2tb21(g), t2tb5(bv_to_int(x)))))))
     => (ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(f), n) = ket_sum_l(int, 
     t2tb6(to_fset(0, power(2, n))), t2tb21(g), n)))));

fc390: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), INT,
  INT) -> (ARRAY bitvec OF matrix_complex);

fc391: ((ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), INT,
  INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  l2 : INT, x : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(
  fc390(f, l, l2)), t2tb26(x))) = ket_sum_l(bitvec1, t2tb28(n_bvs(l2)), 
  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), 
  t2tb26(x)), l)));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  l1 : INT, y : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(
  fc391(f, l, l1)), t2tb26(y))) = ket_sum_l(bitvec1, t2tb28(n_bvs(l1)), 
  infix_at(infix_mngt(bitvec1, matrix(complex1)), bitvec1, t2tb51(f), 
  t2tb26(y)), l)));

% ket_sum_sum_rev
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF matrix_complex)), l : INT,
  l1 : INT, l2 : INT):
  ((0 <= l)
  => (((0 <= l1) AND (l1 = l2)) => (ket_sum_l(bitvec1, t2tb28(n_bvs(l1)), 
     t2tb29(fc390(f, l, l2)), l) = ket_sum_l(bitvec1, t2tb28(n_bvs(l2)), 
     t2tb29(fc391(f, l, l1)), l)))));

fc919: ((ARRAY bitvec OF complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF complex), y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc919(f)), t2tb26(y))) = infix_asdtdt(
  tb2t(infix_at(complex1, bitvec1, t2tb31(f), t2tb26(y))), bv_to_ket(y))));

% get_ket_sum
  ASSERT
  (FORALL (f : (ARRAY bitvec OF complex), n : INT, i : INT):
  (((0 <= i) AND (i < power(2, n)))
  => ((0 <= n) => (tb2t(get(complex1, t2tb18(ket_sum_l(bitvec1, t2tb28(
     n_bvs(n)), t2tb29(fc919(f)), n)), i, 0)) = tb2t(infix_at(complex1,
     bitvec1, t2tb31(f), t2tb26(int_to_bv(i, n))))))));

% get_ket_scalar_zero
  ASSERT
  (FORALL (x : matrix_complex, a : complex): (tb2t(get(complex1, t2tb18(
  infix_asdtdt(a, x)), 0, 0)) = infix_asdt(a, tb2t(get(complex1, t2tb18(x),
  0, 0)))));

fc393: ((ARRAY bitvec OF (ARRAY bitvec OF complex)),
  bitvec) -> (ARRAY bitvec OF matrix_complex);

fc394: ((ARRAY bitvec OF (ARRAY bitvec OF complex)), set_bitvec,
  INT) -> (ARRAY bitvec OF matrix_complex);

fc395: ((ARRAY bitvec OF (ARRAY bitvec OF complex)),
  bitvec) -> (ARRAY bitvec OF complex);

fc396: ((ARRAY bitvec OF (ARRAY bitvec OF complex)),
  set_bitvec) -> (ARRAY bitvec OF matrix_complex);

t2tb53: ((ARRAY bitvec OF (ARRAY bitvec OF complex))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF (ARRAY bitvec OF complex))): (sort(
  infix_mngt(bitvec1, infix_mngt(bitvec1, complex1)), t2tb53(x))));

tb2t53: (uni) -> (ARRAY bitvec OF (ARRAY bitvec OF complex));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF (ARRAY bitvec OF complex))):PATTERN (
  t2tb53(i)):  (tb2t53(t2tb53(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb53(tb2t53(j))): 
  ((sort(infix_mngt(bitvec1, infix_mngt(bitvec1, complex1)), j)) => (t2tb53(
  tb2t53(j)) = j)));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF complex)), x : bitvec,
  y : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc393(f,
  x)), t2tb26(y))) = infix_asdtdt(tb2t(infix_at(complex1, bitvec1, infix_at(
  infix_mngt(bitvec1, complex1), bitvec1, t2tb53(f), t2tb26(x)), t2tb26(y))), 
  bv_to_ket(y))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF complex)), sy : set_bitvec,
  l : INT, x : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(
  fc394(f, sy, l)), t2tb26(x))) = ket_sum_l(bitvec1, t2tb28(sy), t2tb29(
  fc393(f, x)), l)));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF complex)), y : bitvec,
  x : bitvec): (tb2t(infix_at(complex1, bitvec1, t2tb31(fc395(f, y)), 
  t2tb26(x))) = tb2t(infix_at(complex1, bitvec1, infix_at(infix_mngt(bitvec1,
  complex1), bitvec1, t2tb53(f), t2tb26(x)), t2tb26(y)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF complex)), sx : set_bitvec,
  y : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc396(f,
  sx)), t2tb26(y))) = infix_asdtdt(sum(bitvec1, t2tb28(sx), t2tb31(fc395(f,
  y))), bv_to_ket(y))));

% ket_sum_sum_complex
  ASSERT
  (FORALL (f : (ARRAY bitvec OF (ARRAY bitvec OF complex)), sx : set_bitvec,
  sy : set_bitvec, l : INT):
  ((0 <= l)
  => ((FORALL (x : bitvec):
      ((mem(bitvec1, t2tb26(x), t2tb28(sx))) => (length(x) = l)))
     => ((FORALL (y : bitvec):
         ((mem(bitvec1, t2tb26(y), t2tb28(sy))) => (length(y) = l)))
        => (ket_sum_l(bitvec1, t2tb28(sx), t2tb29(fc394(f, sy, l)), l) = 
        ket_sum_l(bitvec1, t2tb28(sy), t2tb29(fc396(f, sx)), l))))));

% mat_mult_ket_basis_bv_value
  ASSERT
  (FORALL (m : matrix_complex, x : bitvec, i : INT, l : INT):
  ((length(x) = l)
  => (((0 <= i) AND (i < power(2, l)))
     => (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(m))) AND (
         rows(complex1, t2tb18(m)) = power(2, l)))
        => (tb2t(get(complex1, t2tb18(mat_mult(m, bv_to_ket(x))), i, 0)) = 
        tb2t(get(complex1, t2tb18(m), i, bv_to_int(x))))))));

% mat_mult_ket_basis_bv_value_gen
  ASSERT
  (FORALL (m : matrix_complex, l : INT):
  (((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(m))) AND (
   rows(complex1, t2tb18(m)) = power(2, l)))
  => (FORALL (x : bitvec):
     (FORALL (i : INT):
     ((length(x) = l)
     => (((0 <= i) AND (i < power(2, l))) => (tb2t(get(complex1, t2tb18(
        mat_mult(m, bv_to_ket(x))), i, 0)) = tb2t(get(complex1, t2tb18(m), i, 
        bv_to_int(x))))))))));

% mat_mult_ket_injec_eq_left
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, l : INT):
  ((rows(complex1, t2tb18(m)) = power(2, l))
  => ((columns(complex1, t2tb18(m)) = power(2, l))
     => ((rows(complex1, t2tb18(n)) = power(2, l))
        => ((columns(complex1, t2tb18(n)) = power(2, l))
           => ((FORALL (x : bitvec):
               ((length(x) = l) => (mat_mult(m, bv_to_ket(x)) = mat_mult(n, 
               bv_to_ket(x)))))
              => (m = n)))))));

% int_to_bv_to_ket
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < power(2, n))) => (bv_to_ket(int_to_bv(k, n)) = ket(n,
  k))));

pps : TYPE;

pps1: ty;

h_width: (pps) -> INT;

h_range: (pps) -> INT;

h_basis_ket: (pps) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT)));

h_angle: (pps) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF angle));

t2tb54: ((ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))): (sort(
  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), t2tb54(x))));

tb2t54: (uni) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))):PATTERN (
  t2tb54(i)):  (tb2t54(t2tb54(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb54(tb2t54(j))):  (t2tb54(tb2t54(j)) = j));

t2tb55: ((ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT)))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT)))):
  (sort(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int, int), 
  infix_mngt(int, int))), t2tb55(x))));

tb2t55: (uni) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT)));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT)))):PATTERN (
  t2tb55(i)):  (tb2t55(t2tb55(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb55(tb2t55(j))):  (t2tb55(tb2t55(j)) = j));

t2tb56: ((ARRAY (ARRAY INT OF INT) OF angle)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY (ARRAY INT OF INT) OF angle)): (sort(infix_mngt(
  infix_mngt(int, int), angle1), t2tb56(x))));

tb2t56: (uni) -> (ARRAY (ARRAY INT OF INT) OF angle);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY (ARRAY INT OF INT) OF angle)):PATTERN (t2tb56(i)):  (
  tb2t56(t2tb56(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb56(tb2t56(j))): 
  ((sort(infix_mngt(infix_mngt(int, int), angle1), j)) => (t2tb56(
  tb2t56(j)) = j)));

t2tb57: ((ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF angle))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF angle))):
  (sort(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int, int),
  angle1)), t2tb57(x))));

tb2t57: (uni) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF angle));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF angle))):PATTERN (
  t2tb57(i)):  (tb2t57(t2tb57(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb57(tb2t57(j))): 
  ((sort(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int, int),
  angle1)), j)) => (t2tb57(tb2t57(j)) = j)));

% pps'invariant
  ASSERT
  (FORALL (self : pps):PATTERN (h_angle(self)): PATTERN (h_basis_ket(self)):
  PATTERN (h_range(self)): PATTERN (h_width(self)): 
  ((0 <= h_width(self))
  AND ((0 <= h_range(self))
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           ((FORALL (i : INT):
            (((0 <= i) AND (i < h_width(self)))
            => ((0 <= (x[i])) AND ((x[i]) < 2))))
           => ((FORALL (i : INT):
               (((0 <= i) AND (i < h_range(self)))
               => ((0 <= (y[i])) AND ((y[i]) < 2))))
              => (FORALL (i : INT):
                 (((0 <= i) AND (i < h_width(self)))
                 => ((0 <= (tb2t7(infix_at(infix_mngt(int, int), 
                    infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                    int), infix_mngt(int, int)), infix_mngt(int, int), 
                    t2tb55(h_basis_ket(self)), t2tb7(x)), t2tb7(y)))[i]))
                    AND ((tb2t7(infix_at(infix_mngt(int, int), 
                    infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                    int), infix_mngt(int, int)), infix_mngt(int, int), 
                    t2tb55(h_basis_ket(self)), t2tb7(x)), 
                    t2tb7(y)))[i]) < 2)))))))
          AND ((FORALL (x : (ARRAY INT OF INT), xqt : (ARRAY INT OF INT),
               y : (ARRAY INT OF INT), yqt : (ARRAY INT OF INT)):
               ((FORALL (i : INT):
                (((0 <= i) AND (i < h_width(self))) => ((x[i]) = (xqt[i]))))
               => ((FORALL (i : INT):
                   (((0 <= i) AND (i < h_range(self)))
                   => ((y[i]) = (yqt[i]))))
                  => (FORALL (i : INT):
                     (((0 <= i) AND (i < h_width(self))) => ((tb2t7(infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(self)), 
                     t2tb7(x)), t2tb7(y)))[i]) = (tb2t7(infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(self)), 
                     t2tb7(xqt)), t2tb7(yqt)))[i])))))))
              AND (FORALL (x : (ARRAY INT OF INT), xqt : (ARRAY INT OF INT),
                  y : (ARRAY INT OF INT), yqt : (ARRAY INT OF INT)):
                  ((FORALL (i : INT):
                   (((0 <= i) AND (i < h_width(self)))
                   => ((x[i]) = (xqt[i]))))
                  => ((FORALL (i : INT):
                      (((0 <= i) AND (i < h_range(self)))
                      => ((y[i]) = (yqt[i]))))
                     => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                     infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(self)), t2tb7(x)), 
                     t2tb7(y))) = tb2t33(infix_at(angle1, infix_mngt(int,
                     int), infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(self)), 
                     t2tb7(xqt)), t2tb7(yqt))))))))))));

inv_func_int: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% inv_func_int'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
  n)))) => (inv_func_int(f, n) = tb2t7(inverse1(int, int, t2tb7(f), t2tb6(
  to_fset(0, n)), t2tb6(to_fset(0, n)))))));

% inv_func_int'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
  n))))
  => ((p_bijective(int, int, t2tb7(inv_func_int(f, n)), t2tb6(to_fset(0, n)), 
     t2tb6(to_fset(0, n))))
     AND ((FORALL (a : INT):
          (((0 <= a) AND (a < n))
          => ((0 <= (inv_func_int(f, n)[a])) AND ((inv_func_int(f,
             n)[a]) < n))))
         AND ((FORALL (a : INT):
              (((0 <= a) AND (a < n)) => ((f[(inv_func_int(f, n)[a])]) = a)))
             AND ((FORALL (a : INT):
                  (((0 <= a) AND (a < n)) => ((inv_func_int(f,
                  n)[(f[a])]) = a)))
                 AND (FORALL (a : INT, b : INT):
                     (((0 <= a) AND (a < n))
                     => (((0 <= b) AND (b < n))
                        => (((f[a]) = b) => ((inv_func_int(f, n)[b]) = a)))))))))));

% binary_h_basis_ket
  ASSERT
  (FORALL (p : pps, w : INT, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
  ((w = h_width(p))
  => ((binary_l(x, w))
     => ((binary_l(y, h_range(p))) => (binary_l(tb2t7(infix_at(
        infix_mngt(int, int), infix_mngt(int, int), infix_at(infix_mngt(
        infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int, int), 
        t2tb55(h_basis_ket(p)), t2tb7(x)), t2tb7(y))), w))))));

swap_int: (INT, INT, INT) -> (ARRAY INT OF INT);

% swap_int'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (FORALL (i : INT): ((swap_int(t1, t2,
        n)[i]) = (IF (i = t1) THEN t2
                 ELSE (IF (i = t2) THEN t1 ELSE i ENDIF) ENDIF))))));

% swap_int'spec
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((FORALL (a : INT): ((a = t1) => ((swap_int(t1, t2, n)[a]) = t2)))
        AND ((FORALL (a : INT):
             ((a = t2) => ((swap_int(t1, t2, n)[a]) = t1)))
            AND ((FORALL (a : INT):
                 ((NOT (a = t1))
                 => ((NOT (a = t2)) => ((swap_int(t1, t2, n)[a]) = a))))
                AND ((p_bijective(int, int, t2tb7(swap_int(t1, t2, n)), 
                    t2tb6(to_fset(0, n)), t2tb6(to_fset(0, n))))
                    AND (FORALL (i : INT):
                        (((0 <= i) AND (i < n)) => ((inv_func_int(
                        swap_int(t1, t2, n), n)[i]) = (swap_int(t1, t2,
                        n)[i])))))))))));

build_pps: (INT, INT,
  (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))),
  (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF angle))) -> pps;

% build_pps'spec
  ASSERT
  (FORALL (w : INT, r : INT,
  k : (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))),
  a : (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF angle))):
  ((0 <= w)
  => ((0 <= r)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         ((FORALL (i : INT):
          (((0 <= i) AND (i < w)) => ((0 <= (x[i])) AND ((x[i]) < 2))))
         => ((FORALL (i : INT):
             (((0 <= i) AND (i < r)) => ((0 <= (y[i])) AND ((y[i]) < 2))))
            => (FORALL (i : INT):
               (((0 <= i) AND (i < w))
               => ((0 <= (tb2t7(infix_at(infix_mngt(int, int), 
                  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                  int), infix_mngt(int, int)), infix_mngt(int, int), 
                  t2tb55(k), t2tb7(x)), t2tb7(y)))[i])) AND ((tb2t7(infix_at(
                  infix_mngt(int, int), infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                  infix_mngt(int, int), t2tb55(k), t2tb7(x)), 
                  t2tb7(y)))[i]) < 2)))))))
        => ((FORALL (x : (ARRAY INT OF INT), xqt : (ARRAY INT OF INT),
            y : (ARRAY INT OF INT), yqt : (ARRAY INT OF INT)):
            ((FORALL (i : INT):
             (((0 <= i) AND (i < w)) => ((x[i]) = (xqt[i]))))
            => ((FORALL (i : INT):
                (((0 <= i) AND (i < r)) => ((y[i]) = (yqt[i]))))
               => (FORALL (i : INT):
                  (((0 <= i) AND (i < w)) => ((tb2t7(infix_at(infix_mngt(int,
                  int), infix_mngt(int, int), infix_at(infix_mngt(
                  infix_mngt(int, int), infix_mngt(int, int)), 
                  infix_mngt(int, int), t2tb55(k), t2tb7(x)), 
                  t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int, int), 
                  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                  int), infix_mngt(int, int)), infix_mngt(int, int), 
                  t2tb55(k), t2tb7(xqt)), t2tb7(yqt)))[i])))))))
           => ((FORALL (x : (ARRAY INT OF INT), xqt : (ARRAY INT OF INT),
               y : (ARRAY INT OF INT), yqt : (ARRAY INT OF INT)):
               ((FORALL (i : INT):
                (((0 <= i) AND (i < w)) => ((x[i]) = (xqt[i]))))
               => ((FORALL (i : INT):
                   (((0 <= i) AND (i < r)) => ((y[i]) = (yqt[i]))))
                  => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                  int), t2tb57(a), t2tb7(x)), t2tb7(y))) = tb2t33(
                  infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
                  infix_mngt(int, int), angle1), infix_mngt(int, int), 
                  t2tb57(a), t2tb7(xqt)), t2tb7(yqt)))))))
              => ((h_width(build_pps(w, r, k, a)) = w)
                 AND ((h_range(build_pps(w, r, k, a)) = r)
                     AND ((FORALL (x : bitvec, y : bitvec):
                          (FORALL (i : INT):
                          ((length(x) = w)
                          => ((length(y) = r)
                             => (((0 <= i) AND (i < w)) => ((tb2t7(infix_at(
                                infix_mngt(int, int), infix_mngt(int, int), 
                                infix_at(infix_mngt(infix_mngt(int, int), 
                                infix_mngt(int, int)), infix_mngt(int, int), 
                                t2tb55(h_basis_ket(build_pps(w, r, k, a))), 
                                t2tb7(value(x))), t2tb7(value(y))))[i]) = 
                                mod((tb2t7(infix_at(infix_mngt(int, int), 
                                infix_mngt(int, int), infix_at(infix_mngt(
                                infix_mngt(int, int), infix_mngt(int, int)), 
                                infix_mngt(int, int), t2tb55(k), t2tb7(
                                value(x))), t2tb7(value(y))))[i]), 2)))))))
                         AND (FORALL (x : bitvec, y : bitvec):
                             ((length(x) = w)
                             => ((length(y) = r) => (tb2t33(infix_at(angle1, 
                                infix_mngt(int, int), infix_at(infix_mngt(
                                infix_mngt(int, int), angle1), 
                                infix_mngt(int, int), t2tb57(h_angle(
                                build_pps(w, r, k, a))), t2tb7(value(x))), 
                                t2tb7(value(y)))) = tb2t33(infix_at(angle1, 
                                infix_mngt(int, int), infix_at(infix_mngt(
                                infix_mngt(int, int), angle1), 
                                infix_mngt(int, int), t2tb57(a), t2tb7(
                                value(x))), t2tb7(value(y)))))))))))))))));

build_pps_bv: (INT, INT, (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  (ARRAY bitvec OF (ARRAY bitvec OF angle))) -> pps;

result114: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

result115: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

result116: (INT, INT,
  (ARRAY bitvec OF (ARRAY bitvec OF bitvec))) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT)));

result117: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

result118: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

result119: (INT, INT,
  (ARRAY bitvec OF (ARRAY bitvec OF angle))) -> (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF angle));

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), i : INT): ((result114(x)[i]) = mod((x[i]),
  2)));

% result'def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), i : INT): ((result115(y)[i]) = mod((y[i]),
  2)));

t2tb58: ((ARRAY bitvec OF (ARRAY bitvec OF bitvec))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF (ARRAY bitvec OF bitvec))): (sort(
  infix_mngt(bitvec1, infix_mngt(bitvec1, bitvec1)), t2tb58(x))));

tb2t58: (uni) -> (ARRAY bitvec OF (ARRAY bitvec OF bitvec));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF (ARRAY bitvec OF bitvec))):PATTERN (
  t2tb58(i)):  (tb2t58(t2tb58(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb58(tb2t58(j))): 
  ((sort(infix_mngt(bitvec1, infix_mngt(bitvec1, bitvec1)), j)) => (t2tb58(
  tb2t58(j)) = j)));

% result'def
  ASSERT
  (FORALL (w : INT, r : INT, k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (tb2t7(infix_at(
  infix_mngt(int, int), infix_mngt(int, int), infix_at(infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
  result116(w, r, k)), t2tb7(x)), t2tb7(y))) = value(tb2t26(infix_at(bitvec1,
  bitvec1, infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), t2tb26(
  make_bv(result114(x), w))), t2tb26(make_bv(result115(y), r)))))));

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), i : INT): ((result117(x)[i]) = mod((x[i]),
  2)));

% result'def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), i : INT): ((result118(y)[i]) = mod((y[i]),
  2)));

t2tb59: ((ARRAY bitvec OF angle)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF angle)): (sort(infix_mngt(bitvec1, angle1), 
  t2tb59(x))));

tb2t59: (uni) -> (ARRAY bitvec OF angle);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF angle)):PATTERN (t2tb59(i)):  (tb2t59(
  t2tb59(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb59(tb2t59(j))): 
  ((sort(infix_mngt(bitvec1, angle1), j)) => (t2tb59(tb2t59(j)) = j)));

t2tb60: ((ARRAY bitvec OF (ARRAY bitvec OF angle))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF (ARRAY bitvec OF angle))): (sort(
  infix_mngt(bitvec1, infix_mngt(bitvec1, angle1)), t2tb60(x))));

tb2t60: (uni) -> (ARRAY bitvec OF (ARRAY bitvec OF angle));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF (ARRAY bitvec OF angle))):PATTERN (
  t2tb60(i)):  (tb2t60(t2tb60(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb60(tb2t60(j))): 
  ((sort(infix_mngt(bitvec1, infix_mngt(bitvec1, angle1)), j)) => (t2tb60(
  tb2t60(j)) = j)));

% result'def
  ASSERT
  (FORALL (w : INT, r : INT, a : (ARRAY bitvec OF (ARRAY bitvec OF angle)),
  x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (tb2t33(infix_at(angle1, 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), angle1), 
  infix_mngt(int, int), t2tb57(result119(w, r, a)), t2tb7(x)), t2tb7(y))) = 
  tb2t33(infix_at(angle1, bitvec1, infix_at(infix_mngt(bitvec1, angle1),
  bitvec1, t2tb60(a), t2tb26(make_bv(result117(x), w))), t2tb26(make_bv(
  result118(y), r))))));

% build_pps_bv'def
  ASSERT
  (FORALL (w : INT, r : INT, k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= w)
  => ((0 <= r)
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = w)
         => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
            infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
            t2tb26(x)), t2tb26(y)))) = w))))
        => (build_pps_bv(w, r, k, a) = build_pps(w, r, result116(w, r, k), 
        result119(w, r, a)))))));

% build_pps_bv'spec
  ASSERT
  (FORALL (w : INT, r : INT, k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= w)
  => ((0 <= r)
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = w)
         => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
            infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
            t2tb26(x)), t2tb26(y)))) = w))))
        => ((h_width(build_pps_bv(w, r, k, a)) = w)
           AND ((h_range(build_pps_bv(w, r, k, a)) = r)
               AND ((FORALL (x : bitvec, y : bitvec):
                    (FORALL (i : INT):
                    ((length(x) = w)
                    => ((length(y) = r)
                       => (((0 <= i) AND (i < w)) => ((tb2t7(infix_at(
                          infix_mngt(int, int), infix_mngt(int, int), 
                          infix_at(infix_mngt(infix_mngt(int, int), 
                          infix_mngt(int, int)), infix_mngt(int, int), 
                          t2tb55(h_basis_ket(build_pps_bv(w, r, k, a))), 
                          t2tb7(value(x))), t2tb7(value(y))))[i]) = (value(
                          tb2t26(infix_at(bitvec1, bitvec1, infix_at(
                          infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
                          t2tb26(x)), t2tb26(y))))[i])))))))
                   AND (FORALL (x : bitvec, y : bitvec):
                       ((length(x) = w)
                       => ((length(y) = r) => (tb2t33(infix_at(angle1, 
                          infix_mngt(int, int), infix_at(infix_mngt(
                          infix_mngt(int, int), angle1), infix_mngt(int,
                          int), t2tb57(h_angle(build_pps_bv(w, r, k, a))), 
                          t2tb7(value(x))), t2tb7(value(y)))) = tb2t33(
                          infix_at(angle1, bitvec1, infix_at(
                          infix_mngt(bitvec1, angle1), bitvec1, t2tb60(a), 
                          t2tb26(x)), t2tb26(y))))))))))))));

h_basis_ket_bv: (pps, bitvec, bitvec) -> bitvec;

% h_basis_ket_bv'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec):
  ((length(x) = h_width(h))
  => ((length(y) = h_range(h)) => (h_basis_ket_bv(h, x, y) = make_bv(tb2t7(
     infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(
     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int,
     int), t2tb55(h_basis_ket(h)), t2tb7(value(x))), t2tb7(value(y)))), 
     h_width(h))))));

% h_basis_ket_bv'spec
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec):
  ((length(x) = h_width(h))
  => ((length(y) = h_range(h))
     => ((length(h_basis_ket_bv(h, x, y)) = h_width(h))
        AND (FORALL (i : INT):
            (((0 <= i) AND (i < h_width(h))) => ((value(h_basis_ket_bv(h, x,
            y))[i]) = (tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
            int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int,
            int)), infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(
            value(x))), t2tb7(value(y))))[i]))))))));

h_angle_bv: (pps, bitvec, bitvec) -> angle;

% h_angle_bv'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec):
  ((length(x) = h_width(h))
  => ((length(y) = h_range(h)) => (h_angle_bv(h, x, y) = tb2t33(
     infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
     infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(h_angle(h)), 
     t2tb7(value(x))), t2tb7(value(y))))))));

% pps_ket_bound
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
  (((0 <= i) AND (i < h_width(h)))
  => ((FORALL (i1 : INT):
      (((0 <= i1) AND (i1 < h_width(h)))
      => ((0 <= (x[i1])) AND ((x[i1]) < 2))))
     => ((FORALL (i1 : INT):
         (((0 <= i1) AND (i1 < h_range(h)))
         => ((0 <= (y[i1])) AND ((y[i1]) < 2))))
        => ((0 <= (tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
           infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
           infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
           t2tb7(y)))[i])) AND ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
           h_basis_ket(h)), t2tb7(x)), t2tb7(y)))[i]) < 2))))));

% low_pps_ket_bound
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
  (((0 <= i) AND (i < h_width(h)))
  => ((FORALL (i1 : INT):
      (((0 <= i1) AND (i1 < h_width(h)))
      => ((0 <= (x[i1])) AND ((x[i1]) < 2))))
     => ((FORALL (i1 : INT):
         (((0 <= i1) AND (i1 < h_range(h)))
         => ((0 <= (y[i1])) AND ((y[i1]) < 2))))
        => (0 <= (tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
        infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
        infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
        t2tb7(y)))[i]))))));

% high_pps_ket_bound
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
  (((0 <= i) AND (i < h_width(h)))
  => ((FORALL (i1 : INT):
      (((0 <= i1) AND (i1 < h_width(h)))
      => ((0 <= (x[i1])) AND ((x[i1]) < 2))))
     => ((FORALL (i1 : INT):
         (((0 <= i1) AND (i1 < h_range(h)))
         => ((0 <= (y[i1])) AND ((y[i1]) < 2))))
        => ((tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
        infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
        infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
        t2tb7(y)))[i]) < 2)))));

pps_apply_basis: (pps, bitvec) -> matrix_complex;

result120: (pps, bitvec) -> (ARRAY bitvec OF matrix_complex);

% result'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(result120(h, x)), t2tb26(y))) = 
  infix_asdtdt(ang_exp(tb2t33(infix_at(angle1, infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
  t2tb57(h_angle(h)), t2tb7(value(x))), t2tb7(value(y))))), bv_to_ket(
  make_bv(tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(value(x))), t2tb7(
  value(y)))), h_width(h))))));

% pps_apply_basis'def
  ASSERT
  (FORALL (h : pps, x : bitvec):
  ((length(x) = h_width(h)) => (pps_apply_basis(h, x) = infix_asdtdt(
  pow_inv_sqrt_2(h_range(h)), ket_sum_l(bitvec1, t2tb28(n_bvs(h_range(h))), 
  t2tb29(result120(h, x)), h_width(h))))));

fc920: (pps, bitvec, INT) -> (ARRAY bitvec OF complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, i : INT, y : bitvec): (tb2t(
  infix_at(complex1, bitvec1, t2tb31(fc920(h, x, i)), t2tb26(y))) = 
  infix_asdt(ang_exp(tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(
  h_angle(h)), t2tb7(value(x))), t2tb7(value(y))))), indic(int, t2tb5(
  bv_to_int(make_bv(tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
  int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(value(x))), t2tb7(
  value(y)))), h_width(h)))), t2tb5(i)))));

% pps_apply_basis'spec
  ASSERT
  (FORALL (h : pps, x : bitvec):
  ((length(x) = h_width(h))
  => ((is_a_ket_l(pps_apply_basis(h, x), h_width(h)))
     AND (FORALL (i : INT):
         (((0 <= i) AND (i < power(2, h_width(h)))) => (tb2t(get(complex1, 
         t2tb18(pps_apply_basis(h, x)), i, 0)) = infix_asdt(pow_inv_sqrt_2(
         h_range(h)), sum(bitvec1, t2tb28(n_bvs(h_range(h))), t2tb31(fc920(h,
         x, i))))))))));

fc921: (pps, bitvec, bitvec) -> (ARRAY bitvec OF complex);

fc922: (pps, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, z : bitvec, y : bitvec): (tb2t(
  infix_at(complex1, bitvec1, t2tb31(fc921(h, x, z)), t2tb26(y))) = 
  infix_asdt(ang_exp(tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(
  h_angle(h)), t2tb7(value(x))), t2tb7(value(y))))), indic(bitvec1, t2tb26(
  h_basis_ket_bv(h, x, y)), t2tb26(z)))));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, z : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc922(h, x)), t2tb26(z))) = infix_asdtdt(
  infix_asdt(pow_inv_sqrt_2(h_range(h)), sum(bitvec1, t2tb28(n_bvs(
  h_range(h))), t2tb31(fc921(h, x, z)))), ket(h_width(h), bv_to_int(z)))));

% pps_apply_basis_decomp
  ASSERT
  (FORALL (h : pps, x : bitvec):
  ((length(x) = h_width(h)) => (pps_apply_basis(h, x) = ket_sum_l(bitvec1, 
  t2tb28(n_bvs(h_width(h))), t2tb29(fc922(h, x)), h_width(h)))));

% pps_apply_basis_ket_l
  ASSERT
  (FORALL (h : pps, x : bitvec, l : INT):
  ((length(x) = l)
  => ((l = h_width(h)) => (is_a_ket_l(pps_apply_basis(h, x), l)))));

% pps_apply_basis_ket_length
  ASSERT
  (FORALL (h : pps, x : bitvec, l : INT):
  ((length(x) = l)
  => ((l = h_width(h)) => (ket_length(pps_apply_basis(h, x)) = l))));

fc400: (pps, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc400(h, x)), t2tb26(y))) = infix_asdtdt(
  ang_exp(h_angle_bv(h, x, y)), bv_to_ket(h_basis_ket_bv(h, x, y)))));

% pps_apply_basis_bv
  ASSERT
  (FORALL (h : pps, x : bitvec):
  ((length(x) = h_width(h)) => (pps_apply_basis(h, x) = infix_asdtdt(
  pow_inv_sqrt_2(h_range(h)), ket_sum_l(bitvec1, t2tb28(n_bvs(h_range(h))), 
  t2tb29(fc400(h, x)), h_width(h))))));

fc923: (pps, bitvec, INT) -> (ARRAY bitvec OF complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, i : INT, y : bitvec): (tb2t(
  infix_at(complex1, bitvec1, t2tb31(fc923(h, x, i)), t2tb26(y))) = 
  infix_asdt(ang_exp(h_angle_bv(h, x, y)), indic(bitvec1, t2tb26(
  h_basis_ket_bv(h, x, y)), t2tb26(int_to_bv(i, h_width(h)))))));

% pps_apply_basis_value
  ASSERT
  (FORALL (h : pps, x : bitvec):
  ((length(x) = h_width(h))
  => (FORALL (i : INT):
     (((0 <= i) AND (i < power(2, h_width(h)))) => (tb2t(get(complex1, 
     t2tb18(pps_apply_basis(h, x)), i, 0)) = infix_asdt(pow_inv_sqrt_2(
     h_range(h)), sum(bitvec1, t2tb28(n_bvs(h_range(h))), t2tb31(fc923(h, x,
     i)))))))));

fc924: (pps, bitvec, INT) -> (ARRAY bitvec OF BITVECTOR(1));

fc925: (pps, bitvec) -> (ARRAY bitvec OF complex);

t2tb61: ((ARRAY bitvec OF BITVECTOR(1))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF BITVECTOR(1))): (sort(infix_mngt(bitvec1,
  bool), t2tb61(x))));

tb2t61: (uni) -> (ARRAY bitvec OF BITVECTOR(1));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF BITVECTOR(1))):PATTERN (t2tb61(i)):  (tb2t61(
  t2tb61(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb61(tb2t61(j))): 
  ((sort(infix_mngt(bitvec1, bool), j)) => (t2tb61(tb2t61(j)) = j)));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, k : INT, y : bitvec):
  ((tb2t2(infix_at(bool, bitvec1, t2tb61(fc924(h, x, k)), 
  t2tb26(y))) = 0bin1) <=> (h_basis_ket_bv(h, x, y) = int_to_bv(k, 
  h_width(h)))));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec): (tb2t(infix_at(complex1,
  bitvec1, t2tb31(fc925(h, x)), t2tb26(y))) = ang_exp(tb2t33(infix_at(angle1, 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), angle1), 
  infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(value(x))), t2tb7(
  value(y)))))));

% pps_apply_basis_value_filter
  ASSERT
  (FORALL (h : pps, x : bitvec, k : INT):
  ((length(x) = h_width(h))
  => (((0 <= k) AND (k < power(2, h_width(h)))) => (tb2t(get(complex1, 
     t2tb18(pps_apply_basis(h, x)), k, 0)) = infix_asdt(pow_inv_sqrt_2(
     h_range(h)), sum(bitvec1, my_filter(bitvec1, t2tb28(n_bvs(h_range(h))), 
     t2tb61(fc924(h, x, k))), t2tb31(fc925(h, x))))))));

fc926: (pps, bitvec, INT) -> (ARRAY bitvec OF BITVECTOR(1));

fc927: (pps, bitvec) -> (ARRAY bitvec OF complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, k : INT, y : bitvec):
  ((tb2t2(infix_at(bool, bitvec1, t2tb61(fc926(h, x, k)), 
  t2tb26(y))) = 0bin1) <=> (h_basis_ket_bv(h, x, y) = int_to_bv(k, 
  h_width(h)))));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec): (tb2t(infix_at(complex1,
  bitvec1, t2tb31(fc927(h, x)), t2tb26(y))) = ang_exp(tb2t33(infix_at(angle1, 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), angle1), 
  infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(value(x))), t2tb7(
  value(y)))))));

% pps_apply_basis_value_filter_gen
  ASSERT
  (FORALL (h : pps, x : bitvec):
  ((length(x) = h_width(h))
  => (FORALL (k : INT):
     (((0 <= k) AND (k < power(2, h_width(h)))) => (tb2t(get(complex1, 
     t2tb18(pps_apply_basis(h, x)), k, 0)) = infix_asdt(pow_inv_sqrt_2(
     h_range(h)), sum(bitvec1, my_filter(bitvec1, t2tb28(n_bvs(h_range(h))), 
     t2tb61(fc926(h, x, k))), t2tb31(fc927(h, x)))))))));

fc928: (pps, bitvec, bitvec) -> (ARRAY bitvec OF matrix_complex);

fc929: (pps, bitvec, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, z : bitvec, t1 : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc928(h, x, z)), t2tb26(t1))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(pps_apply_basis(h, x)), bv_to_int(
  concat(z, t1)), 0)), bv_to_ket(concat(z, t1)))));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, s2 : INT, z : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc929(h, x, s2)), t2tb26(z))) = 
  ket_sum_l(bitvec1, t2tb28(n_bvs((h_width(h) - s2))), t2tb29(fc928(h, x,
  z)), h_width(h))));

% pps_apply_basis_ht
  ASSERT
  (FORALL (h : pps, x : bitvec, s2 : INT):
  ((length(x) = h_width(h))
  => (((1 <= s2) AND (s2 <= h_width(h))) => (pps_apply_basis(h, x) = 
     ket_sum_l(bitvec1, t2tb28(n_bvs(s2)), t2tb29(fc929(h, x, s2)), 
     h_width(h))))));

pps_apply: (pps, matrix_complex) -> matrix_complex;

result121: (pps, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% result'def
  ASSERT
  (FORALL (h : pps, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(result121(h, x)), 
  t2tb26(y))) = (IF (length(y) = h_width(h)) THEN infix_asdtdt(tb2t(
                get(complex1, t2tb18(x), bv_to_int(y), 0)), 
                pps_apply_basis(h, y)) ELSE x ENDIF)));

% pps_apply'def
  ASSERT
  (FORALL (h : pps, x : matrix_complex):
  ((is_a_ket_l(x, h_width(h))) => (pps_apply(h, x) = ket_sum_l(bitvec1, 
  t2tb28(n_bvs(h_width(h))), t2tb29(result121(h, x)), h_width(h)))));

% pps_apply'spec
  ASSERT
  (FORALL (h : pps, x : matrix_complex):
  ((is_a_ket_l(x, h_width(h))) => (is_a_ket_l(pps_apply(h, x), h_width(h)))));

fc930: (pps, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc930(h, x)), t2tb26(y))) = infix_asdtdt(
  tb2t(get(complex1, t2tb18(x), bv_to_int(y), 0)), pps_apply_basis(h, y))));

% get_pps_apply
  ASSERT
  (FORALL (h : pps, x : matrix_complex):
  ((is_a_ket_l(x, h_width(h))) => (pps_apply(h, x) = ket_sum_l(bitvec1, 
  t2tb28(n_bvs(h_width(h))), t2tb29(fc930(h, x)), h_width(h)))));

% rewrite_pps_apply_basis
  ASSERT
  (FORALL (h : pps, x : matrix_complex):
  ((is_a_ket_l(x, h_width(h)))
  => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = pps_apply_basis(h, 
     ket_to_bv(x))))));

fc931: (pps, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc931(h, x)), t2tb26(y))) = infix_asdtdt(
  ang_exp(tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
  infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(h_angle(h)), 
  t2tb7(value(ket_to_bv(x)))), t2tb7(value(y))))), bv_to_ket(make_bv(tb2t7(
  infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
  h_basis_ket(h)), t2tb7(value(ket_to_bv(x)))), t2tb7(value(y)))), 
  h_width(h))))));

% rewrite_pps_apply_basis_
  ASSERT
  (FORALL (h : pps, x : matrix_complex):
  ((is_a_ket_l(x, h_width(h)))
  => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = infix_asdtdt(
     pow_inv_sqrt_2(h_range(h)), ket_sum_l(bitvec1, t2tb28(n_bvs(
     h_range(h))), t2tb29(fc931(h, x)), h_width(h)))))));

% rewrite_pps_apply_basis_rev
  ASSERT
  (FORALL (h : pps, x : bitvec):
  ((length(x) = h_width(h)) => (pps_apply_basis(h, x) = pps_apply(h, 
  bv_to_ket(x)))));

fc932: (pps, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : matrix_complex, z : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc932(h, x)), t2tb26(z))) = infix_asdtdt(
  tb2t(get(complex1, t2tb18(x), bv_to_int(z), 0)), pps_apply(h, 
  bv_to_ket(z)))));

% pps_apply_decomp
  ASSERT
  (FORALL (h : pps, x : matrix_complex):
  ((is_a_ket_l(x, h_width(h))) => (pps_apply(h, x) = ket_sum_l(bitvec1, 
  t2tb28(n_bvs(h_width(h))), t2tb29(fc932(h, x)), h_width(h)))));

% pps_apply_scal
  ASSERT
  (FORALL (h : pps, x : matrix_complex, a : complex):
  ((is_a_ket_l(x, h_width(h))) => (pps_apply(h, infix_asdtdt(a, x)) = 
  infix_asdtdt(a, pps_apply(h, x)))));

% pps_apply_add
  ASSERT
  (FORALL (h : pps, x : matrix_complex, y : matrix_complex, l : INT):
  ((is_a_ket_l(x, h_width(h)))
  => ((is_a_ket_l(y, h_width(h)))
     => ((l = h_width(h)) => (pps_apply(h, add_ket_l(x, y, l)) = add_ket_l(
        pps_apply(h, x), pps_apply(h, y), l))))));

fc411: (ty, pps, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : pps, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc411(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (h : pps, f : uni, e : uni): (tb2t18(infix_at(matrix(complex1), a, 
  fc411(a, h, f), e)) = pps_apply(h, tb2t18(infix_at(matrix(complex1), a, f,
  e))))));

% pps_apply_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (h : pps, s2 : uni, f : uni, l : INT):
  ((1 <= cardinal(a, s2))
  => ((FORALL (e : uni):
      ((sort(a, e))
      => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a,
         f, e)), h_width(h))))))
     => ((l = h_width(h)) => (pps_apply(h, ket_sum_l(a, s2, f, l)) = 
        ket_sum_l(a, s2, fc411(a, h, f), l)))))));

pps_id: pps;

% pps_id'def
  ASSERT
  ((h_width(pps_id) = 1)
  AND ((h_range(pps_id) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
           h_basis_ket(pps_id)), t2tb7(x)), t2tb7(y)))[i]) = (x[i]))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_id)), t2tb7(x)), t2tb7(y))) = ang_zero)))));

pps_swap: (INT, INT, INT) -> pps;

% pps_swap'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2))
        => ((h_width(pps_swap(t1, t2, n)) = n)
           AND ((h_range(pps_swap(t1, t2, n)) = 0)
               AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                    (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
                    infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                    int), infix_mngt(int, int)), infix_mngt(int, int), 
                    t2tb55(h_basis_ket(pps_swap(t1, t2, n))), t2tb7(x)), 
                    t2tb7(y)))[i]) = (x[(swap_int(t1, t2, n)[i])]))))
                   AND (FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)): (tb2t33(infix_at(angle1, 
                       infix_mngt(int, int), infix_at(infix_mngt(
                       infix_mngt(int, int), angle1), infix_mngt(int, int), 
                       t2tb57(h_angle(pps_swap(t1, t2, n))), t2tb7(x)), 
                       t2tb7(y))) = ang_zero)))))))));

pps_phase: (INT) -> pps;

% pps_phase'spec
  ASSERT
  (FORALL (k : INT):
  ((h_width(pps_phase(k)) = 1)
  AND ((h_range(pps_phase(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(h_basis_ket(
           pps_phase(k))), t2tb7(x)), t2tb7(y)))[i]) = (x[i]))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_phase(k))), t2tb7(x)), t2tb7(y))) = 
              infix_sldtsl(1, k)))))));

pps_rz: (INT) -> pps;

% pps_rz'spec
  ASSERT
  (FORALL (k : INT):
  ((h_width(pps_rz(k)) = 1)
  AND ((h_range(pps_rz(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(h_basis_ket(
           pps_rz(k))), t2tb7(x)), t2tb7(y)))[i]) = (x[i]))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_rz(k))), t2tb7(x)), t2tb7(y))) = 
              infix_sldtsl((x[0]), k)))))));

incr_abs: (INT) -> INT;

% incr_abs'def
  ASSERT
  (FORALL (k : INT):
  (IF (0 <= k) THEN (incr_abs(k) = (k + 1)) ELSE (
  incr_abs(k) = (k - 1)) ENDIF));

% incr_abs'spec
  ASSERT
  (FORALL (k : INT):
  (((0 <= k) => (incr_abs(k) = (k + 1)))
  AND ((k < 0) => (incr_abs(k) = (k - 1)))));

decr_abs: (INT) -> INT;

% decr_abs'def
  ASSERT
  (FORALL (k : INT):
  (IF (k <= 0) THEN (decr_abs(k) = (k + 1)) ELSE (
  decr_abs(k) = (k - 1)) ENDIF));

% decr_abs'spec
  ASSERT
  (FORALL (k : INT):
  (((0 < k) => (decr_abs(k) = (k - 1)))
  AND (((k <= 0) => (decr_abs(k) = (k + 1)))
      AND ((NOT (k = 0))
          => ((NOT (k = (- 1))) => (incr_abs(decr_abs(k)) = k))))));

% decr_inc
  ASSERT (FORALL (k : INT): (decr_abs(incr_abs(k)) = k));

pps_rx: (INT) -> pps;

% pps_rx'spec
  ASSERT
  (FORALL (k : INT):
  ((h_width(pps_rx(k)) = 1)
  AND ((h_range(pps_rx(k)) = 2)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(h_basis_ket(
           pps_rx(k))), t2tb7(x)), t2tb7(y)))[i]) = (y[1]))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_rx(k))), t2tb7(x)), t2tb7(y))) = ang_add(
              ang_add(infix_sldtsl(((x[0]) * (y[0])), 1), 
              infix_sldtsl(((y[0]) * (y[1])), 1)), phase_inv_(((y[0]) - 1), 
              infix_sldtsl(1, incr_abs(k))))))))));

pps_xx: pps;

% pps_xx'def
  ASSERT
  ((h_width(pps_xx) = 1)
  AND ((h_range(pps_xx) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
           h_basis_ket(pps_xx)), t2tb7(x)), t2tb7(y)))[i]) = (1 - (x[i])))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_xx)), t2tb7(x)), t2tb7(y))) = 
              infix_sldtsl(1, 0))))));

pps_yy: pps;

% pps_yy'def
  ASSERT
  ((h_width(pps_yy) = 1)
  AND ((h_range(pps_yy) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
           h_basis_ket(pps_yy)), t2tb7(x)), t2tb7(y)))[i]) = (1 - (x[i])))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_yy)), t2tb7(x)), t2tb7(y))) = 
              phase_inv_((x[0]), infix_sldtsl(1, 2)))))));

pps_zz: pps;

% pps_zz'def
  ASSERT
  ((h_width(pps_zz) = 1)
  AND ((h_range(pps_zz) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
           h_basis_ket(pps_zz)), t2tb7(x)), t2tb7(y)))[i]) = (x[i]))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_zz)), t2tb7(x)), t2tb7(y))) = 
              infix_sldtsl((x[0]), 1))))));

pps_ry: (INT) -> pps;

% pps_ry'spec
  ASSERT
  (FORALL (k : INT):
  ((h_width(pps_ry(k)) = 1)
  AND ((h_range(pps_ry(k)) = 2)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(h_basis_ket(
           pps_ry(k))), t2tb7(x)), t2tb7(y)))[i]) = (y[1]))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_ry(k))), t2tb7(x)), t2tb7(y))) = ang_add(
              ang_add(ang_add(infix_sldtsl(((x[0]) * (y[0])), 1), 
              infix_sldtsl(((y[0]) * (y[1])), 1)), phase_inv_(((y[0]) - 1), 
              infix_sldtsl(1, incr_abs(k)))), infix_sldtsl(((y[1]) - (x[0])),
              2))))))));

pps_rz_b: (INT) -> pps;

% pps_rz_b'spec
  ASSERT
  (FORALL (k : INT):
  ((h_width(pps_rz_b(k)) = 1)
  AND ((h_range(pps_rz_b(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(h_basis_ket(
           pps_rz_b(k))), t2tb7(x)), t2tb7(y)))[i]) = (x[i]))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_rz_b(k))), t2tb7(x)), t2tb7(y))) = 
              phase_inv_(((x[0]) - 1), infix_sldtsl(1, incr_abs(k)))))))));

pps_hadamard: pps;

% pps_hadamard'def
  ASSERT
  ((h_width(pps_hadamard) = 1)
  AND ((h_range(pps_hadamard) = 1)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
           h_basis_ket(pps_hadamard)), t2tb7(x)), t2tb7(y)))[i]) = (y[i]))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_hadamard)), t2tb7(x)), t2tb7(y))) = 
              infix_sldtsl(((x[0]) * (y[0])), 1))))));

pps_cnot: (INT, INT, INT) -> pps;

% pps_cnot'def
  ASSERT
  (FORALL (c : INT, t1 : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (t1 = c))
        => ((h_width(pps_cnot(c, t1, n)) = n)
           AND ((h_range(pps_cnot(c, t1, n)) = 0)
               AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                    (FORALL (i : INT):
                    ((NOT (i = t1)) => ((tb2t7(infix_at(infix_mngt(int, int), 
                    infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                    int), infix_mngt(int, int)), infix_mngt(int, int), 
                    t2tb55(h_basis_ket(pps_cnot(c, t1, n))), t2tb7(x)), 
                    t2tb7(y)))[i]) = (x[i])))))
                   AND ((FORALL (x : (ARRAY INT OF INT),
                        y : (ARRAY INT OF INT)):
                        (FORALL (i : INT):
                        ((i = t1) => ((tb2t7(infix_at(infix_mngt(int, int), 
                        infix_mngt(int, int), infix_at(infix_mngt(
                        infix_mngt(int, int), infix_mngt(int, int)), 
                        infix_mngt(int, int), t2tb55(h_basis_ket(pps_cnot(c,
                        t1, n))), t2tb7(x)), 
                        t2tb7(y)))[i]) = (((x[c]) * (1 - (x[t1]))) + ((1 - (x[c])) * (x[t1])))))))
                       AND (FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)): (tb2t33(infix_at(angle1, 
                           infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), angle1), infix_mngt(int,
                           int), t2tb57(h_angle(pps_cnot(c, t1, n))), 
                           t2tb7(x)), t2tb7(y))) = infix_sldtsl(1, 0)))))))))));

pps_toffoli: (INT, INT, INT, INT) -> pps;

% pps_toffoli'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (t1 = c1))
           => ((NOT (t1 = c2))
              => ((NOT (c2 = c1))
                 => ((h_width(pps_toffoli(c1, c2, t1, n)) = n)
                    AND ((h_range(pps_toffoli(c1, c2, t1, n)) = 0)
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)):
                             (FORALL (i : INT):
                             ((NOT (i = t1)) => ((tb2t7(infix_at(
                             infix_mngt(int, int), infix_mngt(int, int), 
                             infix_at(infix_mngt(infix_mngt(int, int), 
                             infix_mngt(int, int)), infix_mngt(int, int), 
                             t2tb55(h_basis_ket(pps_toffoli(c1, c2, t1, n))), 
                             t2tb7(x)), t2tb7(y)))[i]) = (x[i])))))
                            AND ((FORALL (x : (ARRAY INT OF INT),
                                 y : (ARRAY INT OF INT)):
                                 (FORALL (i : INT):
                                 ((i = t1) => ((tb2t7(infix_at(
                                 infix_mngt(int, int), infix_mngt(int, int), 
                                 infix_at(infix_mngt(infix_mngt(int, int), 
                                 infix_mngt(int, int)), infix_mngt(int, int), 
                                 t2tb55(h_basis_ket(pps_toffoli(c1, c2, t1,
                                 n))), t2tb7(x)), 
                                 t2tb7(y)))[i]) = ((((x[c1]) * (x[c2])) * (1 - (x[i]))) + ((x[t1]) * (1 - ((x[c1]) * (x[c2])))))))))
                                AND (FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)): (tb2t33(
                                    infix_at(angle1, infix_mngt(int, int), 
                                    infix_at(infix_mngt(infix_mngt(int, int),
                                    angle1), infix_mngt(int, int), t2tb57(
                                    h_angle(pps_toffoli(c1, c2, t1, n))), 
                                    t2tb7(x)), t2tb7(y))) = infix_sldtsl(1,
                                    0))))))))))))));

pps_fredkin: (INT, INT, INT, INT) -> pps;

% pps_fredkin'def
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (c = t1))
           => ((NOT (c = t2))
              => ((NOT (t2 = t1))
                 => ((h_width(pps_fredkin(c, t1, t2, n)) = n)
                    AND ((h_range(pps_fredkin(c, t1, t2, n)) = 0)
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)):
                             (FORALL (i : INT):
                             ((i = t1) => ((tb2t7(infix_at(infix_mngt(int,
                             int), infix_mngt(int, int), infix_at(infix_mngt(
                             infix_mngt(int, int), infix_mngt(int, int)), 
                             infix_mngt(int, int), t2tb55(h_basis_ket(
                             pps_fredkin(c, t1, t2, n))), t2tb7(x)), 
                             t2tb7(y)))[i]) = (((x[c]) * (x[t2])) + ((1 - (x[c])) * (x[t1])))))))
                            AND ((FORALL (x : (ARRAY INT OF INT),
                                 y : (ARRAY INT OF INT)):
                                 (FORALL (i : INT):
                                 ((i = t2) => ((tb2t7(infix_at(
                                 infix_mngt(int, int), infix_mngt(int, int), 
                                 infix_at(infix_mngt(infix_mngt(int, int), 
                                 infix_mngt(int, int)), infix_mngt(int, int), 
                                 t2tb55(h_basis_ket(pps_fredkin(c, t1, t2,
                                 n))), t2tb7(x)), 
                                 t2tb7(y)))[i]) = (((x[c]) * (x[t1])) + ((1 - (x[c])) * (x[t2])))))))
                                AND ((FORALL (x : (ARRAY INT OF INT),
                                     y : (ARRAY INT OF INT)):
                                     (FORALL (i : INT):
                                     ((NOT (i = t1))
                                     => ((NOT (i = t2)) => ((tb2t7(infix_at(
                                        infix_mngt(int, int), infix_mngt(int,
                                        int), infix_at(infix_mngt(
                                        infix_mngt(int, int), infix_mngt(int,
                                        int)), infix_mngt(int, int), t2tb55(
                                        h_basis_ket(pps_fredkin(c, t1, t2,
                                        n))), t2tb7(x)), 
                                        t2tb7(y)))[i]) = (x[i]))))))
                                    AND (FORALL (x : (ARRAY INT OF INT),
                                        y : (ARRAY INT OF INT)): (tb2t33(
                                        infix_at(angle1, infix_mngt(int,
                                        int), infix_at(infix_mngt(
                                        infix_mngt(int, int), angle1), 
                                        infix_mngt(int, int), t2tb57(h_angle(
                                        pps_fredkin(c, t1, t2, n))), 
                                        t2tb7(x)), t2tb7(y))) = 
                                        infix_sldtsl(1, 0)))))))))))))));

% pps_id_apply_basis
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 1) => (pps_apply_basis(pps_id, x) = bv_to_ket(x))));

% pps_swap_apply_basis
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 2) => (pps_apply_basis(pps_swap(0, 1, 2), x) = ket(2,
  (IF (bv_to_int(x) = 0) THEN 0
  ELSE (IF (bv_to_int(x) = 1) THEN 2
       ELSE (IF (bv_to_int(x) = 2) THEN 1 ELSE 3 ENDIF) ENDIF) ENDIF)))));

% pps_cnot_apply_basis
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 2) => (pps_apply_basis(pps_cnot(0, 1, 2), x) = ket(2,
  (IF (bv_to_int(x) = 0) THEN 0
  ELSE (IF (bv_to_int(x) = 1) THEN 1
       ELSE (IF (bv_to_int(x) = 2) THEN 3 ELSE 2 ENDIF) ENDIF) ENDIF)))));

% pps_phase_apply_basis
  ASSERT
  (FORALL (k : INT, x : bitvec):
  ((length(x) = 1) => (pps_apply_basis(pps_phase(k), x) = infix_asdtdt(
  ang_exp(infix_sldtsl(1, k)), bv_to_ket(x)))));

% pps_rz_apply_basis
  ASSERT
  (FORALL (k : INT, x : bitvec):
  ((length(x) = 1) => (pps_apply_basis(pps_rz(k), x) = infix_asdtdt(ang_exp(
  infix_sldtsl((value(x)[0]), k)), bv_to_ket(x)))));

% pps_hadamard_apply_basis
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 1) => (pps_apply_basis(pps_hadamard, x) = infix_asdtdt(
  pow_inv_sqrt_2(1), add_ket_l(ket(1, 0), infix_asdtdt(ang_exp(infix_sldtsl((
  value(x)[0]), 1)), ket(1, 1)), 1)))));

pps_seq: (pps, pps) -> pps;

fc933: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc934: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h1 : pps, y : (ARRAY INT OF INT), k : INT): ((fc933(h1,
  y)[k]) = (y[(k + h_range(h1))])));

% fc'def
  ASSERT
  (FORALL (h1 : pps, y : (ARRAY INT OF INT), k : INT): ((fc934(h1,
  y)[k]) = (y[(k + h_range(h1))])));

% pps_seq'spec
  ASSERT
  (FORALL (h1 : pps, h2 : pps):
  ((h_width(h1) = h_width(h2))
  => ((h_width(pps_seq(h1, h2)) = h_width(h1))
     AND ((h_range(pps_seq(h1, h2)) = (h_range(h1) + h_range(h2)))
         AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
              (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
              infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
              infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
              h_basis_ket(pps_seq(h1, h2))), t2tb7(x)), t2tb7(y)))[i]) = (
              tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
              infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int,
              int)), infix_mngt(int, int), t2tb55(h_basis_ket(h2)), infix_at(
              infix_mngt(int, int), infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
              infix_mngt(int, int), t2tb55(h_basis_ket(h1)), t2tb7(x)), 
              t2tb7(y))), t2tb7(fc933(h1, y))))[i]))))
             AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
                 tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                 infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                 int), t2tb57(h_angle(pps_seq(h1, h2))), t2tb7(x)), 
                 t2tb7(y))) = ang_add(tb2t33(infix_at(angle1, infix_mngt(int,
                 int), infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                 infix_mngt(int, int), t2tb57(h_angle(h1)), t2tb7(x)), 
                 t2tb7(y))), tb2t33(infix_at(angle1, infix_mngt(int, int), 
                 infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                 infix_mngt(int, int), t2tb57(h_angle(h2)), infix_at(
                 infix_mngt(int, int), infix_mngt(int, int), infix_at(
                 infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                 infix_mngt(int, int), t2tb55(h_basis_ket(h1)), t2tb7(x)), 
                 t2tb7(y))), t2tb7(fc934(h1, y))))))))))));

pps_place: (pps, INT, INT) -> pps;

fc414: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc415: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc414(t1,
  x)[j]) = (x[(j + t1)])));

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc415(t1,
  x)[j]) = (x[(j + t1)])));

% pps_place'spec
  ASSERT
  (FORALL (h : pps, t1 : INT, n : INT):
  ((0 <= t1)
  => (((t1 + h_width(h)) <= n)
     => ((h_width(pps_place(h, t1, n)) = n)
        AND ((h_range(pps_place(h, t1, n)) = h_range(h))
            AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                 (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
                 infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                 int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                 h_basis_ket(pps_place(h, t1, n))), t2tb7(x)), 
                 t2tb7(y)))[i]) = (IF ((t1 <= i) AND (i < (t1 + h_width(h))))
                                  THEN (tb2t7(infix_at(infix_mngt(int, int), 
                                  infix_mngt(int, int), infix_at(infix_mngt(
                                  infix_mngt(int, int), infix_mngt(int,
                                  int)), infix_mngt(int, int), t2tb55(
                                  h_basis_ket(h)), t2tb7(fc414(t1, x))), 
                                  t2tb7(y)))[(i - t1)]) ELSE (x[i]) ENDIF))))
                AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                    (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                    infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                    int), t2tb57(h_angle(pps_place(h, t1, n))), t2tb7(x)), 
                    t2tb7(y))) = tb2t33(infix_at(angle1, infix_mngt(int,
                    int), infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                    infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(fc415(t1,
                    x))), t2tb7(y)))))))))));

complex_as_a_vector: (complex) -> matrix_complex;

result49: (complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (x : complex, i : INT, us : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), int, t2tb15(result49(x)), t2tb5(i)), 
  t2tb5(us))) = (IF (i = 0) THEN t_real_part(x) ELSE t_im_part(x) ENDIF)));

% complex_as_a_vector'def
  ASSERT
  (FORALL (x : complex): (complex_as_a_vector(x) = tb2t18(make_f(complex1, 2,
  1, t2tb15(result49(x))))));

% complex_as_a_vector'spec
  ASSERT
  (FORALL (x : complex):
  ((is_a_ket_l(complex_as_a_vector(x), 1)) AND (ket_norm_l(
  complex_as_a_vector(x), 1) = modulus(x))));

sin: (complex) -> complex;

% sin'def
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (sin(x) = t_im_part(exp(infix_asdt(im, x))))));

% sin'spec
  ASSERT (FORALL (x : complex): ((real_(x)) => (real_(sin(x)))));

cos: (complex) -> complex;

% cos'def
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (cos(x) = t_real_part(exp(infix_asdt(im, x))))));

% cos'spec
  ASSERT (FORALL (x : complex): ((real_(x)) => (real_(cos(x)))));

% euler_real_r
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (cos(x) = r_to_c(real_part(exp(infix_asdt(im, x)))))));

% euler_im_r
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (sin(x) = r_to_c(im_part(exp(infix_asdt(im, x)))))));

% cos_zero
  ASSERT (cos(c_zero) = c_one);

% cos_half_pi
  ASSERT (cos(infix_sldt(pi, infix_pldt(c_one, c_one))) = c_zero);

% cos_quarter_pi
  ASSERT (cos(infix_sldt(pi, i_to_c(4))) = infix_sldt(square_rt(
  infix_pldt(c_one, c_one)), infix_pldt(c_one, c_one)));

% cos_pi
  ASSERT (cos(pi) = prefix_mndt(c_one));

% sin_zero
  ASSERT (sin(c_zero) = c_zero);

% sin_half_pi
  ASSERT (sin(infix_sldt(pi, infix_pldt(c_one, c_one))) = c_one);

% sin_ang_exp
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (sin(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  x)) = t_im_part(ang_exp(real_to_ang(x))))));

% cos_ang_exp
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (cos(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  x)) = t_real_part(ang_exp(real_to_ang(x))))));

% sin_ang_exp_
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (sin(x) = t_im_part(ang_exp(real_to_ang(infix_sldt(x, 
  infix_asdt(infix_pldt(c_one, c_one), pi))))))));

% cos_ang_exp_
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (cos(x) = t_real_part(ang_exp(real_to_ang(infix_sldt(x, 
  infix_asdt(infix_pldt(c_one, c_one), pi))))))));

% cos_sin_square_add
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (infix_pldt(cpower(cos(x), 2), cpower(sin(x), 2)) = c_one)));

% c_one_minus_sin_square
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (infix_mndt(c_one, cpower(sin(x), 2)) = cpower(cos(x), 2))));

% c_one_minus_cos_square
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (infix_mndt(c_one, cpower(cos(x), 2)) = cpower(sin(x), 2))));

cos_ang: (angle) -> complex;

% cos_ang'def
  ASSERT
  (FORALL (theta : angle): (cos_ang(theta) = cos(infix_asdt(ang_meas(theta), 
  infix_asdt(infix_pldt(c_one, c_one), pi)))));

% cos_ang'spec
  ASSERT
  (FORALL (theta : angle): (cos_ang(theta) = t_real_part(ang_exp(theta))));

sin_ang: (angle) -> complex;

% sin_ang'def
  ASSERT
  (FORALL (theta : angle): (sin_ang(theta) = sin(infix_asdt(ang_meas(theta), 
  infix_asdt(infix_pldt(c_one, c_one), pi)))));

% sin_ang'spec
  ASSERT
  (FORALL (theta : angle): (sin_ang(theta) = t_im_part(ang_exp(theta))));

% euler_moivre_cos
  ASSERT
  (FORALL (theta : angle): (cos_ang(theta) = infix_asdt(infix_sldt(c_one, 
  infix_pldt(c_one, c_one)), infix_pldt(ang_exp(theta), ang_exp(
  ang_inv(theta))))));

% euler_moivre_cos_rev
  ASSERT
  (FORALL (theta : angle): (infix_pldt(ang_exp(theta), ang_exp(
  ang_inv(theta))) = infix_asdt(infix_pldt(c_one, c_one), cos_ang(theta))));

% euler_moivre_cos_int
  ASSERT
  (FORALL (k : INT, n : INT): (cos_ang(infix_sldtsl(k, n)) = infix_asdt(
  infix_sldt(c_one, infix_pldt(c_one, c_one)), infix_pldt(ang_exp(
  infix_sldtsl(k, n)), ang_exp(infix_sldtsl((- k), n))))));

% euler_moivre_cos_rev_int
  ASSERT
  (FORALL (k : INT, n : INT): (infix_pldt(ang_exp(infix_sldtsl(k, n)), 
  ang_exp(infix_sldtsl((- k), n))) = infix_asdt(infix_pldt(c_one, c_one), 
  cos_ang(infix_sldtsl(k, n)))));

% euler_moivre_sin
  ASSERT
  (FORALL (theta : angle): (sin_ang(theta) = infix_asdt(infix_sldt(c_one, 
  infix_asdt(infix_pldt(c_one, c_one), im)), infix_mndt(ang_exp(theta), 
  ang_exp(ang_inv(theta))))));

% euler_moivre_sin_rev
  ASSERT
  (FORALL (theta : angle): (infix_mndt(ang_exp(theta), ang_exp(
  ang_inv(theta))) = infix_asdt(infix_asdt(infix_pldt(c_one, c_one), im), 
  sin_ang(theta))));

% euler_moivre_sin_int
  ASSERT
  (FORALL (k : INT, n : INT): (sin_ang(infix_sldtsl(k, n)) = infix_asdt(
  infix_sldt(c_one, infix_asdt(infix_pldt(c_one, c_one), im)), infix_mndt(
  ang_exp(infix_sldtsl(k, n)), ang_exp(infix_sldtsl((- k), n))))));

% euler_moivre_sin_rev_int
  ASSERT
  (FORALL (k : INT, n : INT): (infix_mndt(ang_exp(infix_sldtsl(k, n)), 
  ang_exp(infix_sldtsl((- k), n))) = infix_asdt(infix_asdt(infix_pldt(c_one,
  c_one), im), sin_ang(infix_sldtsl(k, n)))));

% euler_real
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (cos(x) = t_real_part(exp(infix_asdt(im, x))))));

% euler_im
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (sin(x) = t_im_part(exp(infix_asdt(im, x))))));

arc_cos_ang: (complex) -> angle;

% arc_cos_ang'spec
  ASSERT
  (FORALL (x : complex):
  (((infix_lseqdt(prefix_mndt(c_one), x)) AND (infix_lseqdt(x, c_one)))
  => ((cos_ang(arc_cos_ang(x)) = x)
     AND (((infix_lseqdt(c_zero, ang_meas(arc_cos_ang(x))))
          AND (infix_lseqdt(ang_meas(arc_cos_ang(x)), infix_sldt(c_one, 
          infix_pldt(c_one, c_one)))))
         AND (FORALL (t1 : angle):
             (((infix_lseqdt(c_zero, ang_meas(t1))) AND (infix_lseqdt(
              ang_meas(t1), infix_sldt(c_one, infix_pldt(c_one, c_one)))))
             => ((cos_ang(t1) = x) => (t1 = arc_cos_ang(x)))))))));

% set_arc_cos_ang_exp
  ASSERT
  (FORALL (x : complex, o : angle):
  (((infix_lseqdt(prefix_mndt(c_one), x)) AND (infix_lseqdt(x, c_one)))
  => (((infix_lseqdt(c_zero, ang_meas(o))) AND (infix_lseqdt(ang_meas(o), 
      infix_sldt(c_one, infix_pldt(c_one, c_one)))))
     => ((cos_ang(o) = x) => (arc_cos_ang(x) = o)))));

% arc_cos_ang_exp_plus_inv
  ASSERT
  (FORALL (x : complex):
  (((infix_lseqdt(prefix_mndt(c_one), x)) AND (infix_lseqdt(x, c_one))) => (
  infix_pldt(ang_exp(arc_cos_ang(x)), ang_exp(ang_inv(arc_cos_ang(x)))) = 
  infix_asdt(infix_pldt(c_one, c_one), x))));

% arc_cos_ang_add_inv
  ASSERT
  (FORALL (x : complex):
  (((infix_lseqdt(prefix_mndt(c_one), x)) AND (infix_lseqdt(x, c_one))) => (
  ang_add(arc_cos_ang(x), ang_inv(arc_cos_ang(x))) = ang_zero)));

% ang_add_incr
  ASSERT
  (FORALL (k : INT, i : INT): (ang_add(infix_sldtsl(i, incr_abs(k)), 
  infix_sldtsl(i, incr_abs(k))) = infix_sldtsl(i, k)));

pps_cont: (pps, INT, INT, INT) -> pps;

fc935: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc936: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc935(t1,
  x)[j]) = (x[(j + t1)])));

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc936(t1,
  x)[j]) = (x[(j + t1)])));

% pps_cont'spec
  ASSERT
  (FORALL (h : pps, co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 <= (n - h_width(h))))
  => (((0 <= co) AND (co < n))
     => (((t1 <= co) => ((t1 + h_width(h)) <= co))
        => ((h_width(pps_cont(h, co, t1, n)) = n)
           AND ((h_range(pps_cont(h, co, t1, n)) = h_range(h))
               AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                    (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
                    infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                    int), infix_mngt(int, int)), infix_mngt(int, int), 
                    t2tb55(h_basis_ket(pps_cont(h, co, t1, n))), t2tb7(x)), 
                    t2tb7(y)))[i]) = (IF (((x[co]) = 1)
                                         AND ((t1 <= i) AND (i < (t1 + 
                                             h_width(h)))))
                                     THEN (tb2t7(infix_at(infix_mngt(int,
                                     int), infix_mngt(int, int), infix_at(
                                     infix_mngt(infix_mngt(int, int), 
                                     infix_mngt(int, int)), infix_mngt(int,
                                     int), t2tb55(h_basis_ket(h)), t2tb7(
                                     fc935(t1, x))), t2tb7(y)))[(i - t1)])
                                     ELSE (x[i]) ENDIF))))
                   AND (FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)): (tb2t33(infix_at(angle1, 
                       infix_mngt(int, int), infix_at(infix_mngt(
                       infix_mngt(int, int), angle1), infix_mngt(int, int), 
                       t2tb57(h_angle(pps_cont(h, co, t1, n))), t2tb7(x)), 
                       t2tb7(y))) = ang_add(ang_mult_int(tb2t33(
                       infix_at(angle1, infix_mngt(int, int), infix_at(
                       infix_mngt(infix_mngt(int, int), angle1), 
                       infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(
                       fc936(t1, x))), t2tb7(y))), (x[co])), ang_mult_int(
                       phase_inv_((y[0]), arc_cos_ang(pow_inv_sqrt_2(
                       h_range(h)))), (1 - (x[co])))))))))))));

% pps_apply_cont
  ASSERT
  (FORALL (h : pps, co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 <= (n - h_width(h))))
  => (((0 <= co) AND (co < n))
     => (((t1 <= co) => ((t1 + h_width(h)) <= co))
        => ((FORALL (bv : bitvec):
            ((length(bv) = n)
            => (((value(bv)[co]) = 0) => (pps_apply_basis(pps_cont(h, co, t1,
               n), bv) = bv_to_ket(bv)))))
           AND (FORALL (bv : bitvec):
               ((length(bv) = n)
               => (((value(bv)[co]) = 1) => (pps_apply_basis(pps_cont(h, co,
                  t1, n), bv) = pps_apply_basis(pps_place(h, t1, n), bv))))))))));

% h_basis_ket_bv_seq
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : bitvec, y : bitvec):
  ((h_width(h1) = h_width(h2))
  => ((length(x) = h_width(h1))
     => ((length(y) = (h_range(h1) + h_range(h2))) => (h_basis_ket_bv(
        pps_seq(h1, h2), x, y) = h_basis_ket_bv(h2, h_basis_ket_bv(h1, x, 
        hpart(y, h_range(h1))), tpart(y, h_range(h1))))))));

% h_angle_bv_seq
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : bitvec, y : bitvec):
  ((h_width(h1) = h_width(h2))
  => ((length(x) = h_width(h1))
     => ((length(y) = (h_range(h1) + h_range(h2))) => (h_angle_bv(pps_seq(h1,
        h2), x, y) = ang_add(h_angle_bv(h1, x, hpart(y, h_range(h1))), 
        h_angle_bv(h2, h_basis_ket_bv(h1, x, hpart(y, h_range(h1))), tpart(y, 
        h_range(h1)))))))));

pps_par: (pps, pps) -> pps;

fc937: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc938: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc939: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc940: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h1 : pps, x : (ARRAY INT OF INT), k : INT): ((fc937(h1,
  x)[k]) = (x[(k + h_width(h1))])));

% fc'def
  ASSERT
  (FORALL (h1 : pps, y : (ARRAY INT OF INT), k : INT): ((fc938(h1,
  y)[k]) = (y[(k + h_range(h1))])));

% fc'def
  ASSERT
  (FORALL (h1 : pps, x : (ARRAY INT OF INT), k : INT): ((fc939(h1,
  x)[k]) = (x[(k + h_width(h1))])));

% fc'def
  ASSERT
  (FORALL (h1 : pps, y : (ARRAY INT OF INT), k : INT): ((fc940(h1,
  y)[k]) = (y[(k + h_range(h1))])));

% pps_par'spec
  ASSERT
  (FORALL (h1 : pps, h2 : pps):
  ((h_width(pps_par(h1, h2)) = (h_width(h1) + h_width(h2)))
  AND ((h_range(pps_par(h1, h2)) = (h_range(h1) + h_range(h2)))
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(int, int)), infix_mngt(int, int), t2tb55(h_basis_ket(
           pps_par(h1, h2))), t2tb7(x)), 
           t2tb7(y)))[i]) = (IF (i < h_width(h1)) THEN (tb2t7(infix_at(
                            infix_mngt(int, int), infix_mngt(int, int), 
                            infix_at(infix_mngt(infix_mngt(int, int), 
                            infix_mngt(int, int)), infix_mngt(int, int), 
                            t2tb55(h_basis_ket(h1)), t2tb7(x)), 
                            t2tb7(y)))[i]) ELSE (tb2t7(infix_at(
                            infix_mngt(int, int), infix_mngt(int, int), 
                            infix_at(infix_mngt(infix_mngt(int, int), 
                            infix_mngt(int, int)), infix_mngt(int, int), 
                            t2tb55(h_basis_ket(h2)), t2tb7(fc937(h1, x))), 
                            t2tb7(fc938(h1, y))))[(i - h_width(h1))]) ENDIF))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(pps_par(h1, h2))), t2tb7(x)), t2tb7(y))) = 
              ang_add(tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
              infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
              t2tb57(h_angle(h1)), t2tb7(x)), t2tb7(y))), tb2t33(
              infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
              infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(
              h_angle(h2)), t2tb7(fc939(h1, x))), t2tb7(fc940(h1, y)))))))))));

% h_basis_ket_bv_par
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : bitvec, y : bitvec):
  ((length(x) = (h_width(h1) + h_width(h2)))
  => ((length(y) = (h_range(h1) + h_range(h2))) => (h_basis_ket_bv(
     pps_par(h1, h2), x, y) = concat(h_basis_ket_bv(h1, hpart(x, 
     h_width(h1)), hpart(y, h_range(h1))), h_basis_ket_bv(h2, tpart(x, 
     h_width(h1)), tpart(y, h_range(h1))))))));

% h_angle_bv_par
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : bitvec, y : bitvec):
  ((length(x) = (h_width(h1) + h_width(h2)))
  => ((length(y) = (h_range(h1) + h_range(h2))) => (h_angle_bv(pps_par(h1,
     h2), x, y) = ang_add(h_angle_bv(h1, hpart(x, h_width(h1)), hpart(y, 
     h_range(h1))), h_angle_bv(h2, tpart(x, h_width(h1)), tpart(y, 
     h_range(h1))))))));

% kron_to_ket_l
  ASSERT
  (FORALL (x : matrix_complex, l : INT):
  ((0 <= l)
  => ((is_a_ket_l(kronecker(x, ket(1, 0)), (l + 1))) => (is_a_ket_l(x, l)))));

pps_ancs: (pps, INT) -> pps;

fc422: (pps, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc423: (pps, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h1 : pps, i : INT, x : (ARRAY INT OF INT), k : INT): ((fc422(h1,
  i, x)[k]) = (IF (k < (h_width(h1) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (h1 : pps, i : INT, x : (ARRAY INT OF INT), k : INT): ((fc423(h1,
  i, x)[k]) = (IF (k < (h_width(h1) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% pps_ancs'spec
  ASSERT
  (FORALL (h1 : pps, i : INT):
  ((1 <= i)
  => ((i <= h_width(h1))
     => ((h_width(pps_ancs(h1, i)) = (h_width(h1) - i))
        AND ((h_range(pps_ancs(h1, i)) = h_range(h1))
            AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                 (FORALL (ii : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
                 infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                 int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                 h_basis_ket(pps_ancs(h1, i))), t2tb7(x)), 
                 t2tb7(y)))[ii]) = (tb2t7(infix_at(infix_mngt(int, int), 
                 infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
                 int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                 h_basis_ket(h1)), t2tb7(fc422(h1, i, x))), t2tb7(y)))[ii]))))
                AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                    (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                    infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                    int), t2tb57(h_angle(pps_ancs(h1, i))), t2tb7(x)), 
                    t2tb7(y))) = tb2t33(infix_at(angle1, infix_mngt(int,
                    int), infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                    infix_mngt(int, int), t2tb57(h_angle(h1)), t2tb7(
                    fc423(h1, i, x))), t2tb7(y)))))))))));

% h_basis_ket_bv_anc
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec, i : INT):
  ((1 <= i)
  => ((i <= h_width(h))
     => ((length(x) = (h_width(h) - i))
        => ((length(y) = h_range(h)) => (h_basis_ket_bv(pps_ancs(h, i), x,
           y) = hpart(h_basis_ket_bv(h, concat(x, int_to_bv(0, i)), y), (
           h_width(h) - i))))))));

% h_basis_ket_bv_anc_
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec, l : INT, i : INT):
  ((1 <= i)
  => ((i <= h_width(h))
     => ((tpart(x, l) = int_to_bv(0, i))
        => ((length(x) = h_width(h))
           => ((l = (h_width(h) - i))
              => ((length(y) = h_range(h)) => (h_basis_ket_bv(pps_ancs(h, i), 
                 hpart(x, l), y) = hpart(h_basis_ket_bv(h, x, y), (
                 h_width(h) - i))))))))));

% h_angle_bv_anc
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec, i : INT):
  ((1 <= i)
  => ((i <= h_width(h))
     => ((length(x) = (h_width(h) - i))
        => ((length(y) = h_range(h)) => (h_angle_bv(pps_ancs(h, i), x, y) = 
           h_angle_bv(h, concat(x, int_to_bv(0, i)), y)))))));

% h_angle_bv_anc_
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec, l : INT, i : INT):
  ((1 <= i)
  => ((i <= h_width(h))
     => ((tpart(x, l) = int_to_bv(0, i))
        => ((length(x) = h_width(h))
           => ((l = (h_width(h) - i))
              => ((length(y) = h_range(h)) => (h_angle_bv(pps_ancs(h, i), 
                 hpart(x, l), y) = h_angle_bv(h, x, y)))))))));

% kronecker_scalar_distr
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex): (kronecker(
  infix_asdtdt(a, m), n) = infix_asdtdt(a, kronecker(m, n))));

% kronecker_scalar_distr_r
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex): (
  kronecker(m, infix_asdtdt(a, n)) = infix_asdtdt(a, kronecker(m, n))));

% kronecker_scalar_distr_rev
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex): (
  infix_asdtdt(a, kronecker(m, n)) = kronecker(infix_asdtdt(a, m), n)));

% kronecker_scalar_distr_rev_r
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex): (
  infix_asdtdt(a, kronecker(m, n)) = kronecker(m, infix_asdtdt(a, n))));

% kronecker_scalars
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, a : complex, b : complex):
  (kronecker(infix_asdtdt(a, m), infix_asdtdt(b, n)) = infix_asdtdt(
  infix_asdt(a, b), kronecker(m, n))));

mat_k_id: (matrix_complex, INT) -> matrix_complex;

% mat_k_id'def
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n) => (mat_k_id(m, n) = kronecker(m, identity(n)))));

fc424: (matrix_complex, INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : INT, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc424(m, n)), t2tb5(i)), t2tb5(j))) = infix_asdt(indic(int, t2tb5(mod(i, 
  power(2, n))), t2tb5(mod(j, power(2, n)))), tb2t(get(complex1, t2tb18(m), 
  div(i, power(2, n)), div(j, power(2, n)))))));

% mat_k_id'spec
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n) => (mat_k_id(m, n) = tb2t18(make_f(complex1, (rows(complex1, 
  t2tb18(m)) * power(2, n)), (columns(complex1, t2tb18(m)) * power(2, n)), 
  t2tb15(fc424(m, n)))))));

% mat_k_id_values
  ASSERT
  (FORALL (m : matrix_complex, n : INT, i : INT, j : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < (rows(complex1, t2tb18(m)) * power(2, n))))
     => (((0 <= j) AND (j < (columns(complex1, t2tb18(m)) * power(2, n))))
        => (tb2t(get(complex1, t2tb18(mat_k_id(m, n)), i, j)) = infix_asdt(
        indic(int, t2tb5(mod(i, power(2, n))), t2tb5(mod(j, power(2, n)))), 
        tb2t(get(complex1, t2tb18(m), div(i, power(2, n)), div(j, power(2,
        n))))))))));

% mat_k_id_rows
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n) => (rows(complex1, t2tb18(mat_k_id(m, n))) = (rows(complex1, 
  t2tb18(m)) * power(2, n)))));

% mat_k_id_columns
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n) => (columns(complex1, t2tb18(mat_k_id(m, n))) = (
  columns(complex1, t2tb18(m)) * power(2, n)))));

id_k_mat: (matrix_complex, INT) -> matrix_complex;

% id_k_mat'def
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n) => (id_k_mat(m, n) = kronecker(identity(n), m))));

fc425: (matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT): (tb2t(infix_at(complex1,
  int, infix_at(infix_mngt(int, complex1), int, t2tb15(fc425(m)), t2tb5(i)), 
  t2tb5(j))) = infix_asdt(indic(int, t2tb5(div(i, rows(complex1, 
  t2tb18(m)))), t2tb5(div(j, columns(complex1, t2tb18(m))))), tb2t(
  get(complex1, t2tb18(m), mod(i, rows(complex1, t2tb18(m))), mod(j, 
  columns(complex1, t2tb18(m))))))));

% id_k_mat'spec
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n) => (id_k_mat(m, n) = tb2t18(make_f(complex1, (rows(complex1, 
  t2tb18(m)) * power(2, n)), (columns(complex1, t2tb18(m)) * power(2, n)), 
  t2tb15(fc425(m)))))));

% id_k_mat_values
  ASSERT
  (FORALL (m : matrix_complex, n : INT, i : INT, j : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < (rows(complex1, t2tb18(m)) * power(2, n))))
     => (((0 <= j) AND (j < (columns(complex1, t2tb18(m)) * power(2, n))))
        => (tb2t(get(complex1, t2tb18(id_k_mat(m, n)), i, j)) = infix_asdt(
        indic(int, t2tb5(div(i, rows(complex1, t2tb18(m)))), t2tb5(div(j, 
        columns(complex1, t2tb18(m))))), tb2t(get(complex1, t2tb18(m), mod(i, 
        rows(complex1, t2tb18(m))), mod(j, columns(complex1, t2tb18(m)))))))))));

% id_k_mat_rows
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n) => (rows(complex1, t2tb18(id_k_mat(m, n))) = (rows(complex1, 
  t2tb18(m)) * power(2, n)))));

% id_k_mat_columns
  ASSERT
  (FORALL (m : matrix_complex, n : INT):
  ((0 <= n) => (columns(complex1, t2tb18(id_k_mat(m, n))) = (
  columns(complex1, t2tb18(m)) * power(2, n)))));

mat_prod_k_id: (matrix_complex, matrix_complex, INT) -> matrix_complex;

% mat_prod_k_id'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     mat_prod_k_id(m, o, n) = kronecker(mat_mult(m, o), identity(n))))));

fc426: (matrix_complex, matrix_complex, INT, INT,
  INT) -> (ARRAY INT OF complex);

fc427: (matrix_complex, matrix_complex,
  INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc426(m, o, n, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), div(i, power(2, n)),
  k)), tb2t(get(complex1, t2tb18(o), k, div(j, power(2, n)))))));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT, i : INT,
  j : INT): (tb2t(infix_at(complex1, int, infix_at(infix_mngt(int, complex1),
  int, t2tb15(fc427(m, o, n)), t2tb5(i)), t2tb5(j))) = infix_asdt(indic(int, 
  t2tb5(mod(i, power(2, n))), t2tb5(mod(j, power(2, n)))), ind_sum(fc426(m,
  o, n, i, j), 0, columns(complex1, t2tb18(m))))));

% mat_prod_k_id'spec
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     mat_prod_k_id(m, o, n) = tb2t18(make_f(complex1, (rows(complex1, 
     t2tb18(m)) * power(2, n)), (columns(complex1, t2tb18(o)) * power(2, n)), 
     t2tb15(fc427(m, o, n))))))));

id_k_mat_prod: (matrix_complex, matrix_complex, INT) -> matrix_complex;

% id_k_mat_prod'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     id_k_mat_prod(m, o, n) = kronecker(identity(n), mat_mult(m, o))))));

fc428: (matrix_complex, matrix_complex, INT, INT) -> (ARRAY INT OF complex);

fc429: (matrix_complex,
  matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc428(m, o, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), mod(i, rows(complex1, 
  t2tb18(m))), k)), tb2t(get(complex1, t2tb18(o), k, mod(j, columns(complex1, 
  t2tb18(o))))))));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc429(m, o)), t2tb5(i)), t2tb5(j))) = infix_asdt(indic(int, t2tb5(div(i, 
  rows(complex1, t2tb18(m)))), t2tb5(div(j, columns(complex1, t2tb18(o))))), 
  ind_sum(fc428(m, o, i, j), 0, columns(complex1, t2tb18(m))))));

% id_k_mat_prod'spec
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     id_k_mat_prod(m, o, n) = tb2t18(make_f(complex1, (rows(complex1, 
     t2tb18(m)) * power(2, n)), (columns(complex1, t2tb18(o)) * power(2, n)), 
     t2tb15(fc429(m, o))))))));

fc941: (INT, INT, (ARRAY INT OF complex)) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (v : INT, p : INT, g : (ARRAY INT OF complex), k : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc941(v, p, g)), t2tb5(k))) = infix_asdt(
  indic(int, t2tb5(mod(k, v)), t2tb5(p)), tb2t(infix_at(complex1, int, 
  t2tb12(g), t2tb5(div(k, v)))))));

% filter_sum_mod_indic
  ASSERT
  (FORALL (v : INT, n : INT, p : INT, g : (ARRAY INT OF complex)):
  ((0 < n)
  => ((0 < v)
     => (((0 <= p) AND (p < v)) => (sum(int, t2tb6(to_fset(0, (v * n))), 
        t2tb12(fc941(v, p, g))) = sum(int, t2tb6(to_fset(0, n)), t2tb12(g)))))));

fc942: (INT, INT, (ARRAY INT OF complex)) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (v : INT, p : INT, g : (ARRAY INT OF complex), k : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc942(v, p, g)), t2tb5(k))) = infix_asdt(
  tb2t(infix_at(complex1, int, t2tb12(g), t2tb5(mod(k, v)))), indic(int, 
  t2tb5(div(k, v)), t2tb5(p)))));

% filter_sum_indic_div
  ASSERT
  (FORALL (v : INT, n : INT, p : INT, g : (ARRAY INT OF complex)):
  ((0 < n)
  => ((0 < v)
     => (((0 <= p) AND (p < n)) => (sum(int, t2tb6(to_fset(0, (v * n))), 
        t2tb12(fc942(v, p, g))) = sum(int, t2tb6(to_fset(0, v)), t2tb12(g)))))));

fc943: (INT, INT, (ARRAY INT OF complex)) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (v : INT, p : INT, g : (ARRAY INT OF complex), k : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc943(v, p, g)), t2tb5(k))) = infix_asdt(
  indic(int, t2tb5(mod(k, v)), t2tb5(p)), tb2t(infix_at(complex1, int, 
  t2tb12(g), t2tb5(div(k, v)))))));

% filtered_ind_sum_mod_indic
  ASSERT
  (FORALL (v : INT, n : INT, p : INT, g : (ARRAY INT OF complex)):
  ((0 < n)
  => ((0 < v)
     => (((0 <= p) AND (p < v)) => (ind_sum(fc943(v, p, g), 0, (v * n)) = 
        ind_sum(g, 0, n))))));

fc944: (INT, INT, (ARRAY INT OF complex)) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (v : INT, p : INT, g : (ARRAY INT OF complex), k : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc944(v, p, g)), t2tb5(k))) = infix_asdt(
  tb2t(infix_at(complex1, int, t2tb12(g), t2tb5(mod(k, v)))), indic(int, 
  t2tb5(div(k, v)), t2tb5(p)))));

% filtered_ind_sum_indic_div
  ASSERT
  (FORALL (v : INT, n : INT, p : INT, g : (ARRAY INT OF complex)):
  ((0 < n)
  => ((0 < v)
     => (((0 <= p) AND (p < n)) => (ind_sum(fc944(v, p, g), 0, (v * n)) = 
        ind_sum(g, 0, v))))));

fc434: (matrix_complex, matrix_complex, INT, INT,
  INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, i : INT, j : INT, n : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc434(m, o, i, j, n)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), div(i, power(2, n)),
  k)), tb2t(get(complex1, t2tb18(o), k, div(j, power(2, n)))))));

% prod_mat_k_id_pre
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, i : INT, j : INT,
  n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o)))
     => (((0 <= i) AND (i < (rows(complex1, t2tb18(m)) * power(2, n))))
        => (((0 <= j) AND (j < (columns(complex1, t2tb18(o)) * power(2, n))))
           => (tb2t(get(complex1, t2tb18(mat_mult(mat_k_id(m, n), mat_k_id(o,
           n))), i, j)) = infix_asdt(indic(int, t2tb5(mod(i, power(2, n))), 
           t2tb5(mod(j, power(2, n)))), ind_sum(fc434(m, o, i, j, n), 0, 
           columns(complex1, t2tb18(m))))))))));

prod_mat_k_id: (matrix_complex, matrix_complex, INT) -> matrix_complex;

% prod_mat_k_id'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     prod_mat_k_id(m, o, n) = mat_mult(mat_k_id(m, n), mat_k_id(o, n))))));

fc435: (matrix_complex, matrix_complex, INT, INT,
  INT) -> (ARRAY INT OF complex);

fc436: (matrix_complex, matrix_complex,
  INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc435(m, o, n, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), div(i, power(2, n)),
  k)), tb2t(get(complex1, t2tb18(o), k, div(j, power(2, n)))))));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT, i : INT,
  j : INT): (tb2t(infix_at(complex1, int, infix_at(infix_mngt(int, complex1),
  int, t2tb15(fc436(m, o, n)), t2tb5(i)), t2tb5(j))) = infix_asdt(indic(int, 
  t2tb5(mod(i, power(2, n))), t2tb5(mod(j, power(2, n)))), ind_sum(fc435(m,
  o, n, i, j), 0, columns(complex1, t2tb18(m))))));

% prod_mat_k_id'spec
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     prod_mat_k_id(m, o, n) = tb2t18(make_f(complex1, (rows(complex1, 
     t2tb18(m)) * power(2, n)), (columns(complex1, t2tb18(o)) * power(2, n)), 
     t2tb15(fc436(m, o, n))))))));

% prod_mat_k_id_dec
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     prod_mat_k_id(m, o, n) = mat_prod_k_id(m, o, n)))));

fc437: (matrix_complex, matrix_complex, INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc437(m, o, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), mod(i, rows(complex1, 
  t2tb18(m))), k)), tb2t(get(complex1, t2tb18(o), k, mod(j, columns(complex1, 
  t2tb18(o))))))));

% k_id_prod_mat_pre
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, i : INT, j : INT,
  n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o)))
     => (((0 <= i) AND (i < (rows(complex1, t2tb18(m)) * power(2, n))))
        => (((0 <= j) AND (j < (columns(complex1, t2tb18(o)) * power(2, n))))
           => (tb2t(get(complex1, t2tb18(mat_mult(id_k_mat(m, n), id_k_mat(o,
           n))), i, j)) = infix_asdt(indic(int, t2tb5(div(i, rows(complex1, 
           t2tb18(m)))), t2tb5(div(j, columns(complex1, t2tb18(o))))), 
           ind_sum(fc437(m, o, i, j), 0, columns(complex1, t2tb18(m))))))))));

k_id_prod_mat: (matrix_complex, matrix_complex, INT) -> matrix_complex;

% k_id_prod_mat'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     k_id_prod_mat(m, o, n) = mat_mult(id_k_mat(m, n), id_k_mat(o, n))))));

fc438: (matrix_complex, matrix_complex, INT, INT) -> (ARRAY INT OF complex);

fc439: (matrix_complex,
  matrix_complex) -> (ARRAY INT OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, i : INT, j : INT,
  k : INT): (tb2t(infix_at(complex1, int, t2tb12(fc438(m, o, i, j)), 
  t2tb5(k))) = infix_asdt(tb2t(get(complex1, t2tb18(m), mod(i, rows(complex1, 
  t2tb18(m))), k)), tb2t(get(complex1, t2tb18(o), k, mod(j, columns(complex1, 
  t2tb18(o))))))));

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc439(m, o)), t2tb5(i)), t2tb5(j))) = infix_asdt(indic(int, t2tb5(div(i, 
  rows(complex1, t2tb18(m)))), t2tb5(div(j, columns(complex1, t2tb18(o))))), 
  ind_sum(fc438(m, o, i, j), 0, columns(complex1, t2tb18(m))))));

% k_id_prod_mat'spec
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     k_id_prod_mat(m, o, n) = tb2t18(make_f(complex1, (rows(complex1, 
     t2tb18(m)) * power(2, n)), (columns(complex1, t2tb18(o)) * power(2, n)), 
     t2tb15(fc439(m, o))))))));

% k_id_prod_mat_dec
  ASSERT
  (FORALL (m : matrix_complex, o : matrix_complex, n : INT):
  ((0 <= n)
  => ((columns(complex1, t2tb18(m)) = rows(complex1, t2tb18(o))) => (
     k_id_prod_mat(m, o, n) = id_k_mat_prod(m, o, n)))));

% split_ne_pre
  ASSERT
  (FORALL (m1 : matrix_complex, m2 : matrix_complex, nc1 : INT, nc2 : INT,
  nr1 : INT, nr2 : INT, i : INT, j : INT):
  ((0 <= nr1)
  => ((0 <= nr2)
     => ((0 <= nc1)
        => ((0 <= nc2)
           => ((columns(complex1, t2tb18(m1)) = power(2, nc1))
              => ((columns(complex1, t2tb18(m2)) = power(2, nc2))
                 => ((rows(complex1, t2tb18(m1)) = power(2, nr1))
                    => ((rows(complex1, t2tb18(m2)) = power(2, nr2))
                       => (((0 <= i) AND (i < (power(2, nr1) * power(2,
                           nr2))))
                          => (((0 <= j) AND (j < (power(2, nc1) * power(2,
                              nc2))))
                             => (tb2t(get(complex1, t2tb18(mat_mult(
                             id_k_mat(m1, nr2), mat_k_id(m2, nc1))), i,
                             j)) = tb2t(get(complex1, t2tb18(kronecker(m2,
                             m1)), i, j))))))))))))));

% split_nw_pre
  ASSERT
  (FORALL (m1 : matrix_complex, m2 : matrix_complex, nc1 : INT, nc2 : INT,
  nr1 : INT, nr2 : INT, i : INT, j : INT):
  ((0 <= nr1)
  => ((0 <= nr2)
     => ((0 <= nc1)
        => ((0 <= nc2)
           => ((columns(complex1, t2tb18(m1)) = power(2, nc1))
              => ((columns(complex1, t2tb18(m2)) = power(2, nc2))
                 => ((rows(complex1, t2tb18(m1)) = power(2, nr1))
                    => ((rows(complex1, t2tb18(m2)) = power(2, nr2))
                       => (((0 <= i) AND (i < (power(2, nr1) * power(2,
                           nr2))))
                          => (((0 <= j) AND (j < (power(2, nc1) * power(2,
                              nc2))))
                             => (tb2t(get(complex1, t2tb18(mat_mult(
                             mat_k_id(m1, nr2), id_k_mat(m2, nc1))), i,
                             j)) = tb2t(get(complex1, t2tb18(kronecker(m1,
                             m2)), i, j))))))))))))));

% split_ne
  ASSERT
  (FORALL (m1 : matrix_complex, m2 : matrix_complex, nc1 : INT, nc2 : INT,
  nr1 : INT, nr2 : INT):
  ((0 <= nr1)
  => ((0 <= nr2)
     => ((0 <= nc1)
        => ((0 <= nc2)
           => ((columns(complex1, t2tb18(m1)) = power(2, nc1))
              => ((columns(complex1, t2tb18(m2)) = power(2, nc2))
                 => ((rows(complex1, t2tb18(m1)) = power(2, nr1))
                    => ((rows(complex1, t2tb18(m2)) = power(2, nr2)) => (
                       mat_mult(id_k_mat(m1, nr2), mat_k_id(m2, nc1)) = 
                       kronecker(m2, m1)))))))))));

% split_nw
  ASSERT
  (FORALL (m1 : matrix_complex, m2 : matrix_complex, nc1 : INT, nc2 : INT,
  nr1 : INT, nr2 : INT):
  ((0 <= nr1)
  => ((0 <= nr2)
     => ((0 <= nc1)
        => ((0 <= nc2)
           => ((columns(complex1, t2tb18(m1)) = power(2, nc1))
              => ((columns(complex1, t2tb18(m2)) = power(2, nc2))
                 => ((rows(complex1, t2tb18(m1)) = power(2, nr1))
                    => ((rows(complex1, t2tb18(m2)) = power(2, nr2)) => (
                       mat_mult(mat_k_id(m1, nr2), id_k_mat(m2, nc1)) = 
                       kronecker(m1, m2)))))))))));

% shift_k_id
  ASSERT
  (FORALL (m1 : matrix_complex, m2 : matrix_complex, nc1 : INT, nc2 : INT,
  nr1 : INT, nr2 : INT):
  ((0 <= nr1)
  => ((0 <= nr2)
     => ((0 <= nc1)
        => ((0 <= nc2)
           => ((columns(complex1, t2tb18(m1)) = power(2, nc1))
              => ((columns(complex1, t2tb18(m2)) = power(2, nc2))
                 => ((rows(complex1, t2tb18(m1)) = power(2, nr1))
                    => ((rows(complex1, t2tb18(m2)) = power(2, nr2)) => (
                       mat_mult(mat_k_id(m1, nr2), id_k_mat(m2, nc1)) = 
                       mat_mult(id_k_mat(m2, nr1), mat_k_id(m1, nc2))))))))))));

% kronecker_mult_commut
  ASSERT
  (FORALL (a : matrix_complex, b : matrix_complex, c : matrix_complex,
  d : matrix_complex, ra : INT, ca : INT, cc : INT, rb : INT, cb : INT,
  cd : INT):
  ((0 <= ra)
  => ((0 <= ca)
     => ((0 <= cc)
        => ((0 <= rb)
           => ((0 <= cb)
              => ((0 <= cd)
                 => ((rows(complex1, t2tb18(a)) = power(2, ra))
                    => ((columns(complex1, t2tb18(a)) = power(2, ca))
                       => ((rows(complex1, t2tb18(c)) = power(2, ca))
                          => ((columns(complex1, t2tb18(c)) = power(2, cc))
                             => ((rows(complex1, t2tb18(b)) = power(2, rb))
                                => ((columns(complex1, t2tb18(b)) = power(2,
                                   cb))
                                   => ((rows(complex1, t2tb18(d)) = power(2,
                                      cb))
                                      => ((columns(complex1, t2tb18(d)) = 
                                         power(2, cd)) => (mat_mult(
                                         kronecker(a, b), kronecker(c, d)) = 
                                         kronecker(mat_mult(a, c), 
                                         mat_mult(b, d))))))))))))))))));

isa_square: (matrix_complex) -> BOOLEAN;

% isa_square'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((isa_square(m)) <=> (rows(complex1, t2tb18(m)) = columns(complex1, 
  t2tb18(m)))));

pow2dim: (matrix_complex) -> BOOLEAN;

% pow2dim'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((pow2dim(m))
  <=> (EXISTS (i : INT, j : INT):
      ((rows(complex1, t2tb18(m)) = power(2, i)) AND (columns(complex1, 
      t2tb18(m)) = power(2, j))))));

pow2dim_square: (matrix_complex) -> BOOLEAN;

% pow2dim_square'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((pow2dim_square(m))
  <=> (EXISTS (i : INT):
      ((rows(complex1, t2tb18(m)) = power(2, i)) AND (columns(complex1, 
      t2tb18(m)) = power(2, i))))));

% pow_2dim_kets
  ASSERT (FORALL (m : matrix_complex): ((is_a_ket(m)) => (pow2dim(m))));

lnr: (matrix_complex) -> INT;

% lnr'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((pow2dim(m))
  => ((rows(complex1, t2tb18(m)) = power(2, lnr(m))) AND (0 <= lnr(m)))));

lnc: (matrix_complex) -> INT;

% lnc'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((pow2dim(m))
  => ((columns(complex1, t2tb18(m)) = power(2, lnc(m))) AND (0 <= lnc(m)))));

% get_pow2dim
  ASSERT
  (FORALL (m : matrix_complex):
  ((pow2dim(m))
  => (EXISTS (i : INT, j : INT):
     ((rows(complex1, t2tb18(m)) = power(2, i)) AND (columns(complex1, 
     t2tb18(m)) = power(2, j))))));

% set_pow2dim
  ASSERT
  (FORALL (m : matrix_complex):
  ((EXISTS (i : INT, j : INT):
   ((rows(complex1, t2tb18(m)) = power(2, i)) AND (columns(complex1, 
   t2tb18(m)) = power(2, j))))
  => (pow2dim(m))));

% get_pow2dim_elt
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT):
  ((pow2dim(m))
  => ((lnr(m) = i)
     => ((lnc(m) = j)
        => ((rows(complex1, t2tb18(m)) = power(2, i)) AND (columns(complex1, 
           t2tb18(m)) = power(2, j)))))));

% set_pow2dim_elt
  ASSERT
  (FORALL (m : matrix_complex, i : INT, j : INT):
  ((0 <= i)
  => ((0 <= j)
     => ((rows(complex1, t2tb18(m)) = power(2, i))
        => ((columns(complex1, t2tb18(m)) = power(2, j))
           => ((pow2dim(m)) AND ((lnr(m) = i) AND (lnc(m) = j))))))));

mat_size: (matrix_complex) -> INT;

% mat_size'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((isa_square(m)) => (mat_size(m) = rows(complex1, t2tb18(m)))));

% mat_size'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((isa_square(m))
  => ((mat_size(m) = rows(complex1, t2tb18(m))) AND (mat_size(m) = 
     columns(complex1, t2tb18(m))))));

% get_square
  ASSERT
  (FORALL (m : matrix_complex):
  ((isa_square(m)) => (rows(complex1, t2tb18(m)) = columns(complex1, 
  t2tb18(m)))));

% set_square
  ASSERT
  (FORALL (m : matrix_complex):
  ((rows(complex1, t2tb18(m)) = columns(complex1, t2tb18(m)))
  => (isa_square(m))));

% set_square_elt
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((rows(complex1, t2tb18(m)) = i)
  => ((columns(complex1, t2tb18(m)) = i)
     => ((isa_square(m)) AND (mat_size(m) = i)))));

% get_square_elt
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((isa_square(m))
  => ((mat_size(m) = i)
     => ((rows(complex1, t2tb18(m)) = i) AND (columns(complex1, 
        t2tb18(m)) = i)))));

% pow2dim_square_dec
  ASSERT
  (FORALL (m : matrix_complex):
  ((isa_square(m)) => ((pow2dim(m)) => (pow2dim_square(m)))));

% dec_pow2dim_square
  ASSERT
  (FORALL (m : matrix_complex):
  ((pow2dim_square(m)) => ((isa_square(m)) AND (pow2dim(m)))));

ln_size: (matrix_complex) -> INT;

% ln_size'def
  ASSERT
  (FORALL (m : matrix_complex):
  ((pow2dim_square(m)) => (ln_size(m) = lnr(m))));

% ln_size'spec
  ASSERT
  (FORALL (m : matrix_complex):
  ((pow2dim_square(m))
  => ((ln_size(m) = lnc(m))
     AND ((rows(complex1, t2tb18(m)) = power(2, ln_size(m))) AND (
         columns(complex1, t2tb18(m)) = power(2, ln_size(m)))))));

% set_ln_size_lnc
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((pow2dim_square(m)) => ((lnc(m) = i) => (ln_size(m) = i))));

% set_ln_size_lnr
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((pow2dim_square(m)) => ((lnr(m) = i) => (ln_size(m) = i))));

% set_ln_size_columns
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((0 <= i)
  => ((pow2dim_square(m))
     => ((columns(complex1, t2tb18(m)) = power(2, i)) => (ln_size(m) = i)))));

% set_ln_size_rows
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((0 <= i)
  => ((pow2dim_square(m))
     => ((rows(complex1, t2tb18(m)) = power(2, i)) => (ln_size(m) = i)))));

% set_pow2dim_square
  ASSERT
  (FORALL (m : matrix_complex):
  ((EXISTS (i : INT):
   ((rows(complex1, t2tb18(m)) = columns(complex1, t2tb18(m))) AND (
   columns(complex1, t2tb18(m)) = power(2, i))))
  => (pow2dim_square(m))));

% set_pow2dim_square_elt
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((0 <= i)
  => (((rows(complex1, t2tb18(m)) = columns(complex1, t2tb18(m))) AND (
      columns(complex1, t2tb18(m)) = power(2, i)))
     => ((pow2dim_square(m)) AND (ln_size(m) = i)))));

% get_pow2dim_square_elt
  ASSERT
  (FORALL (m : matrix_complex, i : INT):
  ((pow2dim_square(m))
  => ((ln_size(m) = i)
     => ((rows(complex1, t2tb18(m)) = power(2, i)) AND (columns(complex1, 
        t2tb18(m)) = power(2, i))))));

% kronecker_mult_commut_p
  ASSERT
  (FORALL (a : matrix_complex, b : matrix_complex, c : matrix_complex,
  d : matrix_complex):
  ((columns(complex1, t2tb18(a)) = rows(complex1, t2tb18(c)))
  => ((columns(complex1, t2tb18(b)) = rows(complex1, t2tb18(d)))
     => ((pow2dim(a))
        => ((pow2dim(b))
           => ((pow2dim(c))
              => ((pow2dim(d)) => (mat_mult(kronecker(a, b), kronecker(c,
                 d)) = kronecker(mat_mult(a, c), mat_mult(b, d))))))))));

% kronecker_mult_commut_p_quant
  ASSERT
  (FORALL (a : matrix_complex, b : matrix_complex):
  ((pow2dim(a))
  => ((pow2dim(b))
     => (FORALL (c : matrix_complex, d : matrix_complex):
        ((columns(complex1, t2tb18(a)) = rows(complex1, t2tb18(c)))
        => ((columns(complex1, t2tb18(b)) = rows(complex1, t2tb18(d)))
           => ((pow2dim(c))
              => ((pow2dim(d)) => (mat_mult(kronecker(a, b), kronecker(c,
                 d)) = kronecker(mat_mult(a, c), mat_mult(b, d)))))))))));

% kronecker_add_distr_l
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((rows(complex1, t2tb18(kronecker(add_mat(m, n), o))) = (
        rows(complex1, t2tb18(m)) * rows(complex1, t2tb18(o))))
        AND ((columns(complex1, t2tb18(kronecker(add_mat(m, n), o))) = (
            columns(complex1, t2tb18(m)) * columns(complex1, t2tb18(o))))
            AND (kronecker(add_mat(m, n), o) = add_mat(kronecker(m, o), 
            kronecker(n, o))))))));

% kronecker_add_distr_r
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, o : matrix_complex):
  ((rows(complex1, t2tb18(m)) = rows(complex1, t2tb18(n)))
  => ((columns(complex1, t2tb18(m)) = columns(complex1, t2tb18(n)))
     => ((kronecker(o, add_mat(m, n)) = add_mat(kronecker(o, m), kronecker(o,
        n)))
        AND ((rows(complex1, t2tb18(kronecker(o, add_mat(m, n)))) = (
            rows(complex1, t2tb18(m)) * rows(complex1, t2tb18(o)))) AND (
            columns(complex1, t2tb18(kronecker(o, add_mat(m, n)))) = (
            columns(complex1, t2tb18(m)) * columns(complex1, t2tb18(o)))))))));

% kronecker_ket_add_distr_r
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, x : matrix_complex,
  l : INT, l1 : INT, l2 : INT):
  ((l = (l1 + l2))
  => ((is_a_ket_l(m, l1))
     => ((is_a_ket_l(n, l1))
        => ((is_a_ket_l(x, l2)) => (add_ket_l(kronecker(m, x), kronecker(n,
           x), l) = kronecker(add_ket_l(m, n, l1), x)))))));

fc945: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc945(a, x, x1)))));

fc946: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc946(a, x, x1)))));

fc947: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc947(a, x, x1)))));

fc948: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc948(a, x, x1)))));

fc949: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc949(a, x, x1)))));

fc950: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc950(a, x, x1)))));

fc951: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc951(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc945(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc946(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc947(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc948(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc949(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc950(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc951(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_sum_distr_l
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2))
     => (((columns(complex1, t2tb18(mat_sum(a, s2, fc945(a, f, m)))) = 
         columns(complex1, infix_at(matrix(complex1), a, fc946(a, f, m), 
         choose(a, s2)))) AND (columns(complex1, infix_at(matrix(complex1),
         a, fc947(a, f, m), choose(a, s2))) = (columns(complex1, 
         t2tb18(m)) * columns(complex1, infix_at(matrix(complex1), a, f, 
         choose(a, s2))))))
        AND (((rows(complex1, t2tb18(mat_sum(a, s2, fc948(a, f, m)))) = 
             rows(complex1, infix_at(matrix(complex1), a, fc949(a, f, m), 
             choose(a, s2)))) AND (rows(complex1, infix_at(matrix(complex1),
             a, fc950(a, f, m), choose(a, s2))) = (rows(complex1, 
             t2tb18(m)) * rows(complex1, infix_at(matrix(complex1), a, f, 
             choose(a, s2))))))
            AND (kronecker(mat_sum(a, s2, f), m) = mat_sum(a, s2, fc951(a, f,
            m)))))))));

fc952: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc952(a, x, x1)))));

fc953: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc953(a, x, x1)))));

fc954: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc954(a, x, x1)))));

fc955: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc955(a, x, x1)))));

fc956: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc956(a, x, x1)))));

fc957: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc957(a, x, x1)))));

fc958: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc958(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc952(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc953(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc954(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc955(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc956(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc957(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc958(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% kronecker_sum_distr_r
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2))
     => (((columns(complex1, t2tb18(mat_sum(a, s2, fc952(a, f, m)))) = 
         columns(complex1, infix_at(matrix(complex1), a, fc953(a, f, m), 
         choose(a, s2)))) AND (columns(complex1, infix_at(matrix(complex1),
         a, fc954(a, f, m), choose(a, s2))) = (columns(complex1, 
         t2tb18(m)) * columns(complex1, infix_at(matrix(complex1), a, f, 
         choose(a, s2))))))
        AND (((rows(complex1, t2tb18(mat_sum(a, s2, fc955(a, f, m)))) = 
             rows(complex1, infix_at(matrix(complex1), a, fc956(a, f, m), 
             choose(a, s2)))) AND (rows(complex1, infix_at(matrix(complex1),
             a, fc957(a, f, m), choose(a, s2))) = (rows(complex1, 
             t2tb18(m)) * rows(complex1, infix_at(matrix(complex1), a, f, 
             choose(a, s2))))))
            AND (kronecker(m, mat_sum(a, s2, f)) = mat_sum(a, s2, fc958(a, f,
            m)))))))));

fc959: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc959(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, a1 : complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc959(a, f, a1), k)) = infix_asdtdt(a1, tb2t18(
  infix_at(matrix(complex1), a, f, k))))));

% mat_sum_scalar
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, a1 : complex):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2)) => (mat_sum(a, s2, fc959(a, f, a1)) = 
     infix_asdtdt(a1, mat_sum(a, s2, f)))))));

fc960: (ty, uni, matrix_complex, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex, x2 : complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc960(a, x, x1, x2)))));

fc961: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc961(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, a1 : complex, k : uni): (tb2t18(
  infix_at(matrix(complex1), a, fc960(a, f, m, a1), k)) = kronecker(
  infix_asdtdt(a1, tb2t18(infix_at(matrix(complex1), a, f, k))), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc961(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_sum_distr_sc
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, a1 : complex):
  ((constant_size(a, s2, f))
  => ((0 < cardinal(a, s2)) => (mat_sum(a, s2, fc960(a, f, m, a1)) = 
     infix_asdtdt(a1, mat_sum(a, s2, fc961(a, f, m))))))));

fc962: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc962(a, x, x1)))));

fc963: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc963(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc962(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc963(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_ket_sum_distr_l
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT, l2 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket_l(m, l2))
     => ((0 < cardinal(a, s2))
        => ((is_a_ket_l(ket_sum_l(a, s2, fc962(a, f, m), (l1 + l2)),
           (l1 + l2))) AND (kronecker(ket_sum_l(a, s2, f, l1), m) = 
           ket_sum_l(a, s2, fc963(a, f, m), (l1 + l2)))))))));

fc964: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc964(a, x, x1)))));

fc965: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc965(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc964(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc965(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_ket_sum_distr_l_nol
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket(m))
     => ((0 < cardinal(a, s2))
        => ((is_a_ket_l(ket_sum_l(a, s2, fc964(a, f, m), (l1 + 
           ket_length(m))), (l1 + ket_length(m)))) AND (kronecker(
           ket_sum_l(a, s2, f, l1), m) = ket_sum_l(a, s2, fc965(a, f, m),
           (l1 + ket_length(m))))))))));

fc966: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc966(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc966(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_ket_sum_distr_l_rew
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket(m))
     => ((0 < cardinal(a, s2)) => (kronecker(ket_sum_l(a, s2, f, l1), m) = 
        ket_sum_l(a, s2, fc966(a, f, m), (l1 + ket_length(m)))))))));

fc967: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc967(a, x, x1)))));

fc968: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc968(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc967(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc968(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% kronecker_ket_sum_distr_r
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT, l2 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket_l(m, l2))
     => ((0 < cardinal(a, s2))
        => ((is_a_ket_l(ket_sum_l(a, s2, fc967(a, f, m), (l1 + l2)),
           (l1 + l2))) AND (kronecker(m, ket_sum_l(a, s2, f, l1)) = 
           ket_sum_l(a, s2, fc968(a, f, m), (l1 + l2)))))))));

fc969: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc969(a, x, x1)))));

fc970: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc970(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc969(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc970(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_ket_sum_distr_l_rev
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT, l2 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket_l(m, l2))
     => ((0 < cardinal(a, s2))
        => ((is_a_ket_l(ket_sum_l(a, s2, fc969(a, f, m), (l1 + l2)),
           (l1 + l2))) AND (ket_sum_l(a, s2, fc970(a, f, m), (l1 + l2)) = 
           kronecker(ket_sum_l(a, s2, f, l1), m))))))));

fc971: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc971(a, x, x1)))));

fc972: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc972(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc971(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc972(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% kronecker_ket_sum_distr_r_rev
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT, l2 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket_l(m, l2))
     => ((0 < cardinal(a, s2))
        => ((is_a_ket_l(ket_sum_l(a, s2, fc971(a, f, m), (l1 + l2)),
           (l1 + l2))) AND (ket_sum_l(a, s2, fc972(a, f, m), (l1 + l2)) = 
           kronecker(m, ket_sum_l(a, s2, f, l1)))))))));

fc468: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc468(a, x, x1)))));

fc469: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc469(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc468(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc469(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_ket_sum_distr_l_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT, l2 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket_l(m, l2))
     => ((0 <= l1)
        => ((is_a_ket_l(ket_sum_l(a, s2, fc468(a, f, m), (l1 + l2)),
           (l1 + l2))) AND (kronecker(ket_sum_l(a, s2, f, l1), m) = 
           ket_sum_l(a, s2, fc469(a, f, m), (l1 + l2)))))))));

fc470: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc470(a, x, x1)))));

fc471: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc471(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc470(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc471(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_ket_sum_distr_l_nol_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket(m))
     => ((0 <= l1)
        => ((is_a_ket_l(ket_sum_l(a, s2, fc470(a, f, m), (l1 + 
           ket_length(m))), (l1 + ket_length(m)))) AND (kronecker(
           ket_sum_l(a, s2, f, l1), m) = ket_sum_l(a, s2, fc471(a, f, m),
           (l1 + ket_length(m))))))))));

fc472: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc472(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc472(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_ket_sum_distr_l_rew_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket(m))
     => ((0 <= l1) => (kronecker(ket_sum_l(a, s2, f, l1), m) = ket_sum_l(a,
        s2, fc472(a, f, m), (l1 + ket_length(m)))))))));

fc473: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc473(a, x, x1)))));

fc474: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc474(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc473(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc474(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% kronecker_ket_sum_distr_r_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT, l2 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket_l(m, l2))
     => ((0 <= l1)
        => ((is_a_ket_l(ket_sum_l(a, s2, fc473(a, f, m), (l1 + l2)),
           (l1 + l2))) AND (kronecker(m, ket_sum_l(a, s2, f, l1)) = 
           ket_sum_l(a, s2, fc474(a, f, m), (l1 + l2)))))))));

fc475: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc475(a, x, x1)))));

fc476: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc476(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc475(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc476(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_ket_sum_distr_l_rev_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT, l2 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket_l(m, l2))
     => ((0 <= l1)
        => ((is_a_ket_l(ket_sum_l(a, s2, fc475(a, f, m), (l1 + l2)),
           (l1 + l2))) AND (ket_sum_l(a, s2, fc476(a, f, m), (l1 + l2)) = 
           kronecker(ket_sum_l(a, s2, f, l1), m))))))));

fc477: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc477(a, x, x1)))));

fc478: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc478(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc477(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc478(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% kronecker_ket_sum_distr_r_rev_
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT, l2 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket_l(m, l2))
     => ((0 <= l1)
        => ((is_a_ket_l(ket_sum_l(a, s2, fc477(a, f, m), (l1 + l2)),
           (l1 + l2))) AND (ket_sum_l(a, s2, fc478(a, f, m), (l1 + l2)) = 
           kronecker(m, ket_sum_l(a, s2, f, l1)))))))));

fc973: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc973(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc973(a, f, m), k)) = kronecker(m, tb2t18(infix_at(
  matrix(complex1), a, f, k))))));

% kronecker_ket_sum_distr_r_rew
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, l1 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket(m))
     => ((0 < cardinal(a, s2)) => (kronecker(m, ket_sum_l(a, s2, f, l1)) = 
        ket_sum_l(a, s2, fc973(a, f, m), (l1 + ket_length(m)))))))));

fc974: (ty, uni, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : complex): (sort(infix_mngt(a, matrix(complex1)), 
  fc974(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, a1 : complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc974(a, f, a1), k)) = infix_asdtdt(a1, tb2t18(
  infix_at(matrix(complex1), a, f, k))))));

% ket_sum_scalar
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, a1 : complex, l : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l)))))
  => ((0 < cardinal(a, s2)) => (ket_sum_l(a, s2, fc974(a, f, a1), l) = 
     infix_asdtdt(a1, ket_sum_l(a, s2, f, l)))))));

fc975: (ty, uni, matrix_complex, complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex, x2 : complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc975(a, x, x1, x2)))));

fc976: (ty, uni, matrix_complex) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni, x1 : matrix_complex): (sort(infix_mngt(a, 
  matrix(complex1)), fc976(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, a1 : complex, k : uni): (tb2t18(
  infix_at(matrix(complex1), a, fc975(a, f, m, a1), k)) = kronecker(
  infix_asdtdt(a1, tb2t18(infix_at(matrix(complex1), a, f, k))), m))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, m : matrix_complex, k : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc976(a, f, m), k)) = kronecker(tb2t18(infix_at(
  matrix(complex1), a, f, k)), m))));

% kronecker_ket_sum_distr_sc
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni, m : matrix_complex, a1 : complex, l1 : INT,
  l2 : INT):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1), a, f,
      e)), l1)))))
  => ((is_a_ket_l(m, l2))
     => ((0 < cardinal(a, s2)) => (ket_sum_l(a, s2, fc975(a, f, m, a1),
        (l1 + l2)) = infix_asdtdt(a1, ket_sum_l(a, s2, fc976(a, f, m),
        (l1 + l2)))))))));

fc977: (matrix_complex, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, x : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc977(m, n)), t2tb26(x))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(n), bv_to_int(x), 0)), kronecker(m, 
  bv_to_ket(x)))));

% kronecker_decomp_r
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, lm : INT, ln : INT):
  ((is_a_ket_l(m, lm))
  => ((is_a_ket_l(n, ln)) => (kronecker(m, n) = ket_sum_l(bitvec1, t2tb28(
     n_bvs(ln)), t2tb29(fc977(m, n)), (lm + ln))))));

fc978: (matrix_complex, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, x : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc978(m, n)), t2tb26(x))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(m), bv_to_int(x), 0)), kronecker(
  bv_to_ket(x), n))));

% kronecker_decomp_l
  ASSERT
  (FORALL (m : matrix_complex, n : matrix_complex, lm : INT, ln : INT):
  ((is_a_ket_l(m, lm))
  => ((is_a_ket_l(n, ln)) => (kronecker(m, n) = ket_sum_l(bitvec1, t2tb28(
     n_bvs(lm)), t2tb29(fc978(m, n)), (lm + ln))))));

fc485: (INT, (ARRAY bitvec OF matrix_complex),
  (ARRAY bitvec OF matrix_complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (i : INT, f : (ARRAY bitvec OF matrix_complex),
  g : (ARRAY bitvec OF matrix_complex), k : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc485(i, f, g)), t2tb26(k))) = kronecker(
  tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(hpart(k,
  i)))), tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(g), t2tb26(
  tpart(k, i)))))));

% kronecker_ket_sum_distr_double
  ASSERT
  (FORALL (i : INT, j : INT, f : (ARRAY bitvec OF matrix_complex),
  g : (ARRAY bitvec OF matrix_complex), l1 : INT, l2 : INT):
  ((0 <= i)
  => ((0 <= j)
     => ((FORALL (bv : bitvec):
         ((mem(bitvec1, t2tb26(bv), t2tb28(n_bvs(i)))) => (is_a_ket_l(tb2t18(
         infix_at(matrix(complex1), bitvec1, t2tb29(f), t2tb26(bv))), l1))))
        => ((FORALL (bv : bitvec):
            ((mem(bitvec1, t2tb26(bv), t2tb28(n_bvs(j)))) => (is_a_ket_l(
            tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(g), 
            t2tb26(bv))), l2))))
           => (kronecker(ket_sum_l(bitvec1, t2tb28(n_bvs(i)), t2tb29(f), l1), 
           ket_sum_l(bitvec1, t2tb28(n_bvs(j)), t2tb29(g), l2)) = 
           ket_sum_l(bitvec1, t2tb28(n_bvs((i + j))), t2tb29(fc485(i, f, g)),
           (l1 + l2))))))));

% kronecker_add_null
  ASSERT
  (FORALL (m : matrix_complex, m1 : matrix_complex, m2 : matrix_complex,
  x : matrix_complex, xqt : matrix_complex, l1 : INT, l2 : INT):
  ((is_a_ket_l(m, l1))
  => ((is_a_ket_l(m1, l1))
     => ((is_a_ket_l(m2, l1))
        => ((is_a_ket_l(x, l2))
           => ((is_a_ket_l(xqt, l2))
              => ((is_a_ket_basis_elt(x))
                 => ((is_a_ket_basis_elt(xqt))
                    => ((NOT (ket_to_int(x) = ket_to_int(xqt)))
                       => ((kronecker(m, x) = add_ket_l(kronecker(m1, x), 
                          kronecker(m2, xqt), (l1 + l2)))
                          => ((null_mat(kronecker(m2, xqt)))
                             AND ((null_mat(m2))
                                 AND (FORALL (xqt1 : matrix_complex):
                                     (null_mat(kronecker(m2, xqt1))))))))))))))));

% kronecker_injec_eq_left
  ASSERT
  (FORALL (m : matrix_complex, mqt : matrix_complex, o : matrix_complex):
  ((kronecker(m, o) = kronecker(mqt, o))
  => ((NOT (null_mat(o))) => (m = mqt))));

pps_apply_equiv: (pps, pps) -> BOOLEAN;

% pps_apply_equiv'def
  ASSERT
  (FORALL (h1 : pps, h2 : pps):
  ((pps_apply_equiv(h1, h2))
  <=> ((h_width(h1) = h_width(h2))
      AND (FORALL (x : matrix_complex):
          ((is_a_ket_l(x, h_width(h1))) => (pps_apply(h1, x) = pps_apply(h2,
          x)))))));

% set_pps_apply_equiv
  ASSERT
  (FORALL (h1 : pps, h2 : pps):
  ((h_width(h1) = h_width(h2))
  => ((FORALL (x : bitvec):
      ((length(x) = h_width(h1)) => (pps_apply_basis(h1, x) = 
      pps_apply_basis(h2, x))))
     => (pps_apply_equiv(h1, h2)))));

% set_pps_apply_equiv_sim
  ASSERT
  (FORALL (h1 : pps, h2 : pps):
  ((h_width(h1) = h_width(h2))
  => ((h_range(h1) = h_range(h2))
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         (FORALL (i : INT):
         ((FORALL (j : INT):
          (((0 <= j) AND (j < h_width(h1)))
          => ((0 <= (x[j])) AND ((x[j]) < 2))))
         => ((FORALL (j : INT):
             (((0 <= j) AND (j < h_range(h1)))
             => ((0 <= (y[j])) AND ((y[j]) < 2))))
            => (((0 <= i) AND (i < h_width(h1))) => ((tb2t7(infix_at(
               infix_mngt(int, int), infix_mngt(int, int), infix_at(
               infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
               infix_mngt(int, int), t2tb55(h_basis_ket(h1)), t2tb7(x)), 
               t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int, int), 
               infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
               int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
               h_basis_ket(h2)), t2tb7(x)), t2tb7(y)))[i])))))))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
            ((FORALL (j : INT):
             (((0 <= j) AND (j < h_width(h1)))
             => ((0 <= (x[j])) AND ((x[j]) < 2))))
            => ((FORALL (j : INT):
                (((0 <= j) AND (j < h_range(h1)))
                => ((0 <= (y[j])) AND ((y[j]) < 2))))
               => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
               infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
               int), t2tb57(h_angle(h1)), t2tb7(x)), t2tb7(y))) = tb2t33(
               infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
               infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(
               h_angle(h2)), t2tb7(x)), t2tb7(y)))))))
           => (pps_apply_equiv(h1, h2)))))));

% get_pps_apply_equiv
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : matrix_complex):
  ((h_width(h1) = h_width(h2))
  => ((pps_apply_equiv(h1, h2))
     => ((is_a_ket_l(x, h_width(h1))) => (pps_apply(h1, x) = pps_apply(h2,
        x))))));

% get_pps_apply_basis_equiv
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : bitvec):
  ((h_width(h1) = h_width(h2))
  => ((pps_apply_equiv(h1, h2))
     => ((length(x) = h_width(h1)) => (pps_apply_basis(h1, x) = 
        pps_apply_basis(h2, x))))));

% reflexive_pps_apply_equiv
  ASSERT (FORALL (h : pps): (pps_apply_equiv(h, h)));

% commut_pps_apply_equiv
  ASSERT
  (FORALL (h : pps, hqt : pps):
  ((pps_apply_equiv(h, hqt)) => (pps_apply_equiv(hqt, h))));

% transitive_pps_apply_equiv
  ASSERT
  (FORALL (h : pps, hqt : pps, hqtqt : pps):
  ((pps_apply_equiv(h, hqt))
  => ((pps_apply_equiv(hqt, hqtqt)) => (pps_apply_equiv(h, hqtqt)))));

% pps_apply_basis_seq
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : bitvec):
  ((length(x) = h_width(h1))
  => ((h_width(h1) = h_width(h2)) => (pps_apply_basis(pps_seq(h1, h2), x) = 
     pps_apply(h2, pps_apply_basis(h1, x))))));

% pps_apply_seq
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : matrix_complex):
  ((h_width(h1) = h_width(h2))
  => ((is_a_ket_l(x, h_width(h1))) => (pps_apply(pps_seq(h1, h2), x) = 
     pps_apply(h2, pps_apply(h1, x))))));

fc979: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc980: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h1 : pps, y : (ARRAY INT OF INT), k : INT): ((fc979(h1,
  y)[k]) = (y[(k + h_range(h1))])));

% fc'def
  ASSERT
  (FORALL (h1 : pps, y : (ARRAY INT OF INT), k : INT): ((fc980(h1,
  y)[k]) = (y[(k + h_range(h1))])));

% pps_seq_pred
  ASSERT
  (FORALL (h1 : pps, h2 : pps, h3 : pps):
  (((h_width(h1) = h_width(h2)) AND (h_width(h2) = h_width(h3)))
  => ((h_range(h3) = (h_range(h1) + h_range(h2)))
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         (FORALL (i : INT):
         ((FORALL (j : INT):
          (((0 <= j) AND (j < h_width(h3)))
          => ((0 <= (x[j])) AND ((x[j]) < 2))))
         => ((FORALL (j : INT):
             (((0 <= j) AND (j < h_range(h3)))
             => ((0 <= (y[j])) AND ((y[j]) < 2))))
            => (((0 <= i) AND (i < h_width(h3))) => ((tb2t7(infix_at(
               infix_mngt(int, int), infix_mngt(int, int), infix_at(
               infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
               infix_mngt(int, int), t2tb55(h_basis_ket(h3)), t2tb7(x)), 
               t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int, int), 
               infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
               int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
               h_basis_ket(h2)), infix_at(infix_mngt(int, int), 
               infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
               int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
               h_basis_ket(h1)), t2tb7(x)), t2tb7(y))), t2tb7(fc979(h1,
               y))))[i])))))))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
            ((FORALL (j : INT):
             (((0 <= j) AND (j < h_width(h3)))
             => ((0 <= (x[j])) AND ((x[j]) < 2))))
            => ((FORALL (j : INT):
                (((0 <= j) AND (j < h_range(h3)))
                => ((0 <= (y[j])) AND ((y[j]) < 2))))
               => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
               infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
               int), t2tb57(h_angle(h3)), t2tb7(x)), t2tb7(y))) = ang_add(
               tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
               infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
               int), t2tb57(h_angle(h1)), t2tb7(x)), t2tb7(y))), tb2t33(
               infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
               infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(
               h_angle(h2)), infix_at(infix_mngt(int, int), infix_mngt(int,
               int), infix_at(infix_mngt(infix_mngt(int, int), 
               infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
               h_basis_ket(h1)), t2tb7(x)), t2tb7(y))), t2tb7(fc980(h1,
               y)))))))))
           => (FORALL (x : matrix_complex):
              ((is_a_ket_l(x, h_width(h3))) => (pps_apply(h3, x) = 
              pps_apply(h2, pps_apply(h1, x))))))))));

% pps_apply_basis_par
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : bitvec):
  ((length(x) = (h_width(h1) + h_width(h2))) => (pps_apply_basis(pps_par(h1,
  h2), x) = kronecker(pps_apply_basis(h1, hpart(x, h_width(h1))), 
  pps_apply_basis(h2, tpart(x, h_width(h1)))))));

% pps_apply_par
  ASSERT
  (FORALL (h1 : pps, h2 : pps, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, h_width(h1)))
  => ((is_a_ket_l(y, h_width(h2))) => (pps_apply(pps_par(h1, h2), 
     kronecker(x, y)) = kronecker(pps_apply(h1, x), pps_apply(h2, y))))));

fc981: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc982: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc983: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc984: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h1 : pps, x : (ARRAY INT OF INT), k : INT): ((fc981(h1,
  x)[k]) = (x[(k + h_width(h1))])));

% fc'def
  ASSERT
  (FORALL (h1 : pps, y : (ARRAY INT OF INT), k : INT): ((fc982(h1,
  y)[k]) = (y[(k + h_range(h1))])));

% fc'def
  ASSERT
  (FORALL (h1 : pps, x : (ARRAY INT OF INT), k : INT): ((fc983(h1,
  x)[k]) = (x[(k + h_width(h1))])));

% fc'def
  ASSERT
  (FORALL (h1 : pps, y : (ARRAY INT OF INT), k : INT): ((fc984(h1,
  y)[k]) = (y[(k + h_range(h1))])));

% pps_par_pred
  ASSERT
  (FORALL (h1 : pps, h2 : pps, h3 : pps):
  ((h_width(h3) = (h_width(h1) + h_width(h2)))
  => ((h_range(h3) = (h_range(h1) + h_range(h2)))
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         (FORALL (i : INT):
         ((FORALL (j : INT):
          (((0 <= j) AND (j < h_width(h3)))
          => ((0 <= (x[j])) AND ((x[j]) < 2))))
         => ((FORALL (j : INT):
             (((0 <= j) AND (j < h_range(h3)))
             => ((0 <= (y[j])) AND ((y[j]) < 2))))
            => (((0 <= i) AND (i < h_width(h3))) => ((tb2t7(infix_at(
               infix_mngt(int, int), infix_mngt(int, int), infix_at(
               infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
               infix_mngt(int, int), t2tb55(h_basis_ket(h3)), t2tb7(x)), 
               t2tb7(y)))[i]) = (IF (i < h_width(h1)) THEN (tb2t7(infix_at(
                                infix_mngt(int, int), infix_mngt(int, int), 
                                infix_at(infix_mngt(infix_mngt(int, int), 
                                infix_mngt(int, int)), infix_mngt(int, int), 
                                t2tb55(h_basis_ket(h1)), t2tb7(x)), 
                                t2tb7(y)))[i]) ELSE (tb2t7(infix_at(
                                infix_mngt(int, int), infix_mngt(int, int), 
                                infix_at(infix_mngt(infix_mngt(int, int), 
                                infix_mngt(int, int)), infix_mngt(int, int), 
                                t2tb55(h_basis_ket(h2)), t2tb7(fc981(h1,
                                x))), t2tb7(fc982(h1, y))))[(i - 
                                h_width(h1))]) ENDIF)))))))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
            ((FORALL (j : INT):
             (((0 <= j) AND (j < h_width(h3)))
             => ((0 <= (x[j])) AND ((x[j]) < 2))))
            => ((FORALL (j : INT):
                (((0 <= j) AND (j < h_range(h3)))
                => ((0 <= (y[j])) AND ((y[j]) < 2))))
               => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
               infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
               int), t2tb57(h_angle(h3)), t2tb7(x)), t2tb7(y))) = ang_add(
               tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
               infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
               int), t2tb57(h_angle(h1)), t2tb7(x)), t2tb7(y))), tb2t33(
               infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
               infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(
               h_angle(h2)), t2tb7(fc983(h1, x))), t2tb7(fc984(h1, y)))))))))
           => (FORALL (x : matrix_complex, y : matrix_complex):
              ((is_a_ket_l(x, h_width(h1)))
              => ((is_a_ket_l(y, h_width(h2))) => (pps_apply(h3, kronecker(x,
                 y)) = kronecker(pps_apply(h1, x), pps_apply(h2, y)))))))))));

% pps_apply_basis_anc
  ASSERT
  (FORALL (h : pps, x : bitvec, y : matrix_complex, i : INT):
  ((1 <= i)
  => ((i < h_width(h))
     => ((length(x) = h_width(h))
        => ((tpart(x, (h_width(h) - i)) = int_to_bv(0, i))
           => ((pps_apply_basis(h, x) = kronecker(y, ket(i, 0)))
              => ((is_a_ket_l(y, (h_width(h) - i))) => (pps_apply_basis(
                 pps_ancs(h, i), hpart(x, (h_width(h) - i))) = y))))))));

% pps_apply_basis_anc_
  ASSERT
  (FORALL (h : pps, x : bitvec, y : matrix_complex, i : INT):
  ((1 <= i)
  => ((i < h_width(h))
     => ((length(x) = (h_width(h) - i))
        => ((pps_apply_basis(h, concat(x, int_to_bv(0, i))) = kronecker(y, 
           ket(i, 0)))
           => ((is_a_ket_l(y, (h_width(h) - i))) => (pps_apply_basis(
              pps_ancs(h, i), x) = y)))))));

% pps_apply_anc
  ASSERT
  (FORALL (h : pps,
  path_sem_target : (ARRAY matrix_complex OF matrix_complex),
  x : matrix_complex, i : INT):
  ((1 <= i)
  => ((i < h_width(h))
     => ((is_a_ket_l(x, (h_width(h) - i)))
        => ((FORALL (x1 : matrix_complex):
            ((is_a_ket_l(x1, (h_width(h) - i))) => (pps_apply(h, 
            kronecker(x1, ket(i, 0))) = kronecker(tb2t18(infix_at(
            matrix(complex1), matrix(complex1), t2tb19(path_sem_target), 
            t2tb18(x1))), ket(i, 0)))))
           => ((is_a_ket_l(x, (h_width(h) - i))) => (pps_apply(pps_ancs(h,
              i), x) = tb2t18(infix_at(matrix(complex1), matrix(complex1), 
              t2tb19(path_sem_target), t2tb18(x))))))))));

% pps_apply_equiv_seq
  ASSERT
  (FORALL (h1 : pps, h1qt : pps, h2 : pps, h2qt : pps):
  ((pps_apply_equiv(h1, h1qt))
  => ((pps_apply_equiv(h2, h2qt))
     => ((h_width(h1) = h_width(h2)) => (pps_apply_equiv(pps_seq(h1, h2), 
        pps_seq(h1qt, h2qt)))))));

% pps_apply_equiv_par
  ASSERT
  (FORALL (h1 : pps, h1qt : pps, h2 : pps, h2qt : pps):
  ((pps_apply_equiv(h1, h1qt))
  => ((pps_apply_equiv(h2, h2qt)) => (pps_apply_equiv(pps_par(h1, h2), 
     pps_par(h1qt, h2qt))))));

% pps_apply_equiv_anc
  ASSERT
  (FORALL (h : pps, hqt : pps, i : INT):
  ((1 <= i)
  => ((i < h_width(h))
     => ((pps_apply_equiv(h, hqt))
        => ((EXISTS
            (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
            (FORALL (y : matrix_complex):
            ((is_a_ket_l(y, (h_width(h) - i))) => (pps_apply(h, kronecker(y, 
            ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
            matrix(complex1), t2tb19(path_sem_target), t2tb18(y))), ket(i,
            0))))))
           => (pps_apply_equiv(pps_ancs(h, i), pps_ancs(hqt, i))))))));

% pps_place_image
  ASSERT
  (FORALL (h : pps, k : INT, n : INT, x : bitvec, y : bitvec, z : bitvec):
  ((0 <= k)
  => (((k + h_width(h)) <= n)
     => ((length(x) = k)
        => ((length(y) = h_width(h))
           => ((length(z) = ((n - h_width(h)) - k)) => (pps_apply_basis(
              pps_place(h, k, n), concat(concat(x, y), z)) = kronecker(
              kronecker(bv_to_ket(x), pps_apply_basis(h, y)), bv_to_ket(z)))))))));

% pps_place_image_bv
  ASSERT
  (FORALL (h : pps, t1 : INT, n : INT, x : bitvec):
  ((0 <= t1)
  => (((t1 + h_width(h)) <= n)
     => ((length(x) = n) => (pps_apply_basis(pps_place(h, t1, n), x) = 
        kronecker(kronecker(bv_to_ket(hpart(x, t1)), pps_apply_basis(h, 
        htpart(x, t1, h_width(h)))), bv_to_ket(tpart(x, (t1 + 
        h_width(h))))))))));

% pps_apply_equiv_place
  ASSERT
  (FORALL (h : pps, hqt : pps, t1 : INT, n : INT, tqt : INT, nqt : INT):
  ((0 <= t1)
  => (((t1 + h_width(h)) <= n)
     => ((t1 = tqt)
        => ((n = nqt)
           => ((pps_apply_equiv(h, hqt)) => (pps_apply_equiv(pps_place(h, t1,
              n), pps_place(hqt, tqt, nqt)))))))));

% pps_apply_equiv_cont
  ASSERT
  (FORALL (h : pps, hqt : pps, co : INT, t1 : INT, n : INT, coqt : INT,
  tqt : INT, nqt : INT):
  ((co = coqt)
  => ((t1 = tqt)
     => ((n = nqt)
        => (((0 <= t1) AND (t1 <= (n - h_width(h))))
           => (((0 <= co) AND (co < n))
              => (((t1 <= co) => ((t1 + h_width(h)) <= co))
                 => ((pps_apply_equiv(h, hqt)) => (pps_apply_equiv(
                    pps_cont(h, co, t1, n), pps_cont(hqt, coqt, tqt, nqt)))))))))));

fc492: (pps, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc493: (pps, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h1 : pps, i : INT, x : (ARRAY INT OF INT), k : INT): ((fc492(h1,
  i, x)[k]) = (IF (k < (h_width(h1) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (h1 : pps, i : INT, x : (ARRAY INT OF INT), k : INT): ((fc493(h1,
  i, x)[k]) = (IF (k < (h_width(h1) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% pps_anc_pred
  ASSERT
  (FORALL (h1 : pps, h2 : pps,
  path_sem_target : (ARRAY matrix_complex OF matrix_complex), i : INT):
  ((1 <= i)
  => ((i < h_width(h1))
     => ((FORALL (y : matrix_complex):
         ((is_a_ket_l(y, (h_width(h1) - i))) => (pps_apply(h1, kronecker(y, 
         ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
         matrix(complex1), t2tb19(path_sem_target), t2tb18(y))), ket(i, 0)))))
        => ((h_width(h2) = (h_width(h1) - i))
           => ((h_range(h2) = h_range(h1))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  (FORALL (ii : INT):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(h2)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(h2)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (((0 <= ii) AND (ii < h_width(h2))) => ((tb2t7(
                        infix_at(infix_mngt(int, int), infix_mngt(int, int), 
                        infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h2)), t2tb7(x)), t2tb7(y)))[ii]) = (
                        tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h1)), t2tb7(fc492(h1, i, x))), 
                        t2tb7(y)))[ii])))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(h2)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(h2)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                        infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                        infix_mngt(int, int), t2tb57(h_angle(h2)), t2tb7(x)), 
                        t2tb7(y))) = tb2t33(infix_at(angle1, infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int),
                        angle1), infix_mngt(int, int), t2tb57(h_angle(h1)), 
                        t2tb7(fc493(h1, i, x))), t2tb7(y)))))))
                    => (FORALL (x : bitvec):
                       ((length(x) = h_width(h2)) => (pps_apply_basis(h2,
                       x) = tb2t18(infix_at(matrix(complex1), 
                       matrix(complex1), t2tb19(path_sem_target), t2tb18(
                       bv_to_ket(x)))))))))))))));

fc494: (pps, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc495: (pps, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h1 : pps, i : INT, x : (ARRAY INT OF INT), k : INT): ((fc494(h1,
  i, x)[k]) = (IF (k < (h_width(h1) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (h1 : pps, i : INT, x : (ARRAY INT OF INT), k : INT): ((fc495(h1,
  i, x)[k]) = (IF (k < (h_width(h1) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% pps_anc_pred_
  ASSERT
  (FORALL (h1 : pps, h2 : pps, i : INT):
  ((1 <= i)
  => ((i < h_width(h1))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (y : matrix_complex):
         ((is_a_ket_l(y, (h_width(h1) - i))) => (pps_apply(h1, kronecker(y, 
         ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
         matrix(complex1), t2tb19(path_sem_target), t2tb18(y))), ket(i, 0))))))
        => ((h_width(h2) = (h_width(h1) - i))
           => ((h_range(h2) = h_range(h1))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  (FORALL (ii : INT):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(h2)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(h2)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (((0 <= ii) AND (ii < h_width(h2))) => ((tb2t7(
                        infix_at(infix_mngt(int, int), infix_mngt(int, int), 
                        infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h2)), t2tb7(x)), t2tb7(y)))[ii]) = (
                        tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h1)), t2tb7(fc494(h1, i, x))), 
                        t2tb7(y)))[ii])))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(h2)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(h2)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                        infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                        infix_mngt(int, int), t2tb57(h_angle(h2)), t2tb7(x)), 
                        t2tb7(y))) = tb2t33(infix_at(angle1, infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int),
                        angle1), infix_mngt(int, int), t2tb57(h_angle(h1)), 
                        t2tb7(fc495(h1, i, x))), t2tb7(y)))))))
                    => (FORALL (x : bitvec):
                       ((length(x) = h_width(h2)) => (pps_apply_basis(h1, 
                       concat(x, int_to_bv(0, i))) = kronecker(
                       pps_apply_basis(h2, x), ket(i, 0)))))))))))));

pps_to_mat: (pps) -> matrix_complex;

result50: (pps, bitvec, bitvec) -> (ARRAY INT OF (ARRAY INT OF complex));

result51: (ARRAY INT OF (ARRAY INT OF complex));

result52: (pps, bitvec) -> (ARRAY bitvec OF matrix_complex);

result53: (pps) -> (ARRAY bitvec OF matrix_complex);

% result'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  result50(h, x, y)), t2tb5(i)), 
  t2tb5(j))) = (IF ((i = bv_to_int(h_basis_ket_bv(h, x, y))) AND (j = 
                   bv_to_int(x)))
               THEN ang_exp(h_angle_bv(h, x, y)) ELSE c_zero ENDIF)));

% result'def
  ASSERT
  (FORALL (us : INT, us1 : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), int, t2tb15(result51), t2tb5(us)), 
  t2tb5(us1))) = c_zero));

% result'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(result52(h, x)), 
  t2tb26(y))) = (IF ((length(x) = h_width(h)) AND (length(y) = h_range(h)))
                THEN tb2t18(make_f(complex1, power(2, h_width(h)), power(2, 
                h_width(h)), t2tb15(result50(h, x, y)))) ELSE tb2t18(
                make_f(complex1, power(2, h_width(h)), power(2, h_width(h)), 
                t2tb15(result51))) ENDIF)));

% result'def
  ASSERT
  (FORALL (h : pps, x : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, 
  t2tb29(result53(h)), t2tb26(x))) = mat_sum_dim(bitvec1, t2tb28(n_bvs(
  h_range(h))), t2tb29(result52(h, x)), power(2, h_width(h)), power(2, 
  h_width(h)))));

% pps_to_mat'def
  ASSERT
  (FORALL (h : pps): (pps_to_mat(h) = infix_asdtdt(pow_inv_sqrt_2(
  h_range(h)), mat_sum_dim(bitvec1, t2tb28(n_bvs(h_width(h))), t2tb29(
  result53(h)), power(2, h_width(h)), power(2, h_width(h))))));

fc496: (pps, bitvec, bitvec) -> (ARRAY INT OF (ARRAY INT OF complex));

fc497: (pps, bitvec) -> (ARRAY bitvec OF matrix_complex);

fc498: (pps) -> (ARRAY bitvec OF matrix_complex);

fc499: (pps, bitvec, bitvec) -> (ARRAY INT OF (ARRAY INT OF complex));

fc500: (pps, bitvec) -> (ARRAY bitvec OF matrix_complex);

fc501: (pps) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc496(h, x, y)), t2tb5(i)), 
  t2tb5(j))) = (IF ((i = bv_to_int(h_basis_ket_bv(h, x, y))) AND (j = 
                   bv_to_int(x)))
               THEN ang_exp(h_angle_bv(h, x, y)) ELSE c_zero ENDIF)));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc497(h, x)), t2tb26(y))) = tb2t18(
  make_f(complex1, power(2, h_width(h)), power(2, h_width(h)), t2tb15(
  fc496(h, x, y))))));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, 
  t2tb29(fc498(h)), t2tb26(x))) = mat_sum_dim(bitvec1, t2tb28(n_bvs(
  h_range(h))), t2tb29(fc497(h, x)), power(2, h_width(h)), power(2, 
  h_width(h)))));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec, i : INT, j : INT): (tb2t(
  infix_at(complex1, int, infix_at(infix_mngt(int, complex1), int, t2tb15(
  fc499(h, x, y)), t2tb5(i)), 
  t2tb5(j))) = (IF ((i = bv_to_int(h_basis_ket_bv(h, x, y))) AND (j = 
                   bv_to_int(x)))
               THEN ang_exp(h_angle_bv(h, x, y)) ELSE c_zero ENDIF)));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc500(h, x)), t2tb26(y))) = tb2t18(
  make_f(complex1, power(2, h_width(h)), power(2, h_width(h)), t2tb15(
  fc499(h, x, y))))));

% fc'def
  ASSERT
  (FORALL (h : pps, x : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, 
  t2tb29(fc501(h)), t2tb26(x))) = mat_sum(bitvec1, t2tb28(n_bvs(h_range(h))), 
  t2tb29(fc500(h, x)))));

% pps_to_mat'spec
  ASSERT
  (FORALL (h : pps):
  ((pps_to_mat(h) = infix_asdtdt(pow_inv_sqrt_2(h_range(h)), 
  mat_sum_dim(bitvec1, t2tb28(n_bvs(h_width(h))), t2tb29(fc498(h)), power(2, 
  h_width(h)), power(2, h_width(h)))))
  AND ((pps_to_mat(h) = infix_asdtdt(pow_inv_sqrt_2(h_range(h)), 
      mat_sum(bitvec1, t2tb28(n_bvs(h_width(h))), t2tb29(fc501(h)))))
      AND ((rows(complex1, t2tb18(pps_to_mat(h))) = power(2, h_width(h)))
          AND ((columns(complex1, t2tb18(pps_to_mat(h))) = power(2, 
              h_width(h)))
              AND ((FORALL (x : bitvec):
                   ((length(x) = h_width(h)) => (mat_mult(pps_to_mat(h), 
                   bv_to_ket(x)) = pps_apply_basis(h, x))))
                  AND (FORALL (x : matrix_complex):
                      ((is_a_ket_l(x, h_width(h))) => (mat_mult(
                      pps_to_mat(h), x) = pps_apply(h, x))))))))));

sem_id_mat: (tuple0) -> matrix_complex;

indic_closure: (ty) -> uni;

% indic_closure_sort
  ASSERT
  (FORALL (a : ty): (sort(infix_mngt(a, infix_mngt(a, complex1)), 
  indic_closure(a))));

% indic_closure_def
  ASSERT
  (FORALL (a : ty):
  (FORALL (y : uni, y1 : uni): (tb2t(infix_at(complex1, a, infix_at(
  infix_mngt(a, complex1), a, indic_closure(a), y), y1)) = indic(a, y, y1))));

% sem_id_mat'def
  ASSERT
  (FORALL (us : tuple0): (sem_id_mat(us) = tb2t18(make_f(complex1, 2, 2, 
  indic_closure(int)))));

% sem_id_mat'spec
  ASSERT
  (FORALL (us : tuple0):
  ((rows(complex1, t2tb18(sem_id_mat(us))) = power(2, 1))
  AND ((columns(complex1, t2tb18(sem_id_mat(us))) = power(2, 1))
      AND ((FORALL (x : bitvec):
           ((length(x) = 1) => (mat_mult(sem_id_mat(us), bv_to_ket(x)) = 
           bv_to_ket(x))))
          AND (FORALL (x : bitvec):
              ((length(x) = 1) => (mat_mult(sem_id_mat(us), bv_to_ket(x)) = 
              pps_apply_basis(pps_id, x))))))));

sem_rz_mat: (INT) -> matrix_complex;

result54: (INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (k : INT, i : INT, j : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), int, t2tb15(result54(k)), t2tb5(i)), 
  t2tb5(j))) = (IF (i = j) THEN ang_exp(infix_sldtsl(i, k))
               ELSE c_zero ENDIF)));

% sem_rz_mat'def
  ASSERT
  (FORALL (k : INT): (sem_rz_mat(k) = tb2t18(make_f(complex1, 2, 2, t2tb15(
  result54(k))))));

% sem_rz_mat'spec
  ASSERT
  (FORALL (k : INT):
  ((rows(complex1, t2tb18(sem_rz_mat(k))) = power(2, 1))
  AND ((columns(complex1, t2tb18(sem_rz_mat(k))) = power(2, 1))
      AND ((FORALL (x : bitvec):
           ((length(x) = 1) => (mat_mult(sem_rz_mat(k), bv_to_ket(x)) = 
           infix_asdtdt(ang_exp(infix_sldtsl((value(x)[0]), k)), 
           bv_to_ket(x)))))
          AND (FORALL (x : bitvec):
              ((length(x) = 1) => (mat_mult(sem_rz_mat(k), bv_to_ket(x)) = 
              pps_apply_basis(pps_rz(k), x))))))));

sem_phase_mat: (INT) -> matrix_complex;

result55: (INT) -> (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (k : INT, i : INT, j : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), int, t2tb15(result55(k)), t2tb5(i)), 
  t2tb5(j))) = (IF (i = j) THEN ang_exp(infix_sldtsl(1, k))
               ELSE c_zero ENDIF)));

% sem_phase_mat'def
  ASSERT
  (FORALL (k : INT): (sem_phase_mat(k) = tb2t18(make_f(complex1, 2, 2, 
  t2tb15(result55(k))))));

% sem_phase_mat'spec
  ASSERT
  (FORALL (k : INT):
  ((rows(complex1, t2tb18(sem_phase_mat(k))) = power(2, 1))
  AND ((columns(complex1, t2tb18(sem_phase_mat(k))) = power(2, 1))
      AND ((FORALL (x : bitvec):
           ((length(x) = 1) => (mat_mult(sem_phase_mat(k), bv_to_ket(x)) = 
           infix_asdtdt(ang_exp(infix_sldtsl(1, k)), bv_to_ket(x)))))
          AND (FORALL (x : bitvec):
              ((length(x) = 1) => (mat_mult(sem_phase_mat(k), 
              bv_to_ket(x)) = pps_apply_basis(pps_phase(k), x))))))));

sem_hadamard_mat: (tuple0) -> matrix_complex;

result56: (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (i : INT, j : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), int, t2tb15(result56), t2tb5(i)), t2tb5(j))) = 
  infix_asdt(cpower(prefix_mndt(c_one), (i * j)), pow_inv_sqrt_2(1))));

% sem_hadamard_mat'def
  ASSERT
  (FORALL (us : tuple0): (sem_hadamard_mat(us) = tb2t18(make_f(complex1, 2,
  2, t2tb15(result56)))));

% sem_hadamard_mat'spec
  ASSERT
  (FORALL (us : tuple0):
  ((rows(complex1, t2tb18(sem_hadamard_mat(us))) = power(2, 1))
  AND ((columns(complex1, t2tb18(sem_hadamard_mat(us))) = power(2, 1))
      AND ((FORALL (x : bitvec):
           ((length(x) = 1) => (mat_mult(sem_hadamard_mat(us), 
           bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(1), add_ket_l(ket(1,
           0), infix_asdtdt(ang_exp(infix_sldtsl((value(x)[0]), 1)), ket(1,
           1)), 1)))))
          AND (FORALL (x : bitvec):
              ((length(x) = 1) => (mat_mult(sem_hadamard_mat(us), 
              bv_to_ket(x)) = pps_apply_basis(pps_hadamard, x))))))));

cnot_func: (bitvec) -> bitvec;

result122: (bitvec) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((
  result122(x)[i]) = (IF (i = 0) THEN (value(x)[i]) ELSE (1 - (
                     value(x)[i])) ENDIF)));

% cnot_func'def
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 2)
  => (IF ((value(x)[0]) = 0) THEN (cnot_func(x) = x) ELSE (cnot_func(x) = 
     make_bv(result122(x), 2)) ENDIF)));

% cnot_func'spec
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 2)
  => ((length(cnot_func(x)) = 2)
     AND (((bv_to_int(x) = 0) => (cnot_func(x) = int_to_bv(0, 2)))
         AND (((bv_to_int(x) = 1) => (cnot_func(x) = int_to_bv(1, 2)))
             AND (((bv_to_int(x) = 2) => (cnot_func(x) = int_to_bv(3, 2)))
                 AND ((bv_to_int(x) = 3) => (cnot_func(x) = int_to_bv(2, 2)))))))));

% invol_cnot_func
  ASSERT
  (FORALL (x : bitvec): ((length(x) = 2) => (cnot_func(cnot_func(x)) = x)));

cnot_func_int: (INT) -> INT;

% cnot_func_int'def
  ASSERT
  (FORALL (i : INT): (cnot_func_int(i) = bv_to_int(cnot_func(int_to_bv(i,
  2)))));

% cnot_func_int'spec
  ASSERT
  (FORALL (i : INT):
  (((0 <= cnot_func_int(i)) AND (cnot_func_int(i) < 4))
  AND (((i = 0) => (cnot_func_int(i) = 0))
      AND (((i = 1) => (cnot_func_int(i) = 1))
          AND (((i = 2) => (cnot_func_int(i) = 3))
              AND (((i = 3) => (cnot_func_int(i) = 2))
                  AND (((0 <= i) AND (i < 4)) => (
                      cnot_func_int(i) = (IF (div(i, 2) = 0) THEN i
                                         ELSE (3 - mod(i, 2)) ENDIF)))))))));

% invol_cnot_func_int
  ASSERT
  (FORALL (i : INT):
  (((0 <= i) AND (i < 4)) => (cnot_func_int(cnot_func_int(i)) = i)));

sem_cnot_mat: (tuple0) -> matrix_complex;

result58: (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (i : INT, j : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), int, t2tb15(result58), t2tb5(i)), 
  t2tb5(j))) = (IF (j = cnot_func_int(i)) THEN c_one ELSE c_zero ENDIF)));

% sem_cnot_mat'def
  ASSERT
  (FORALL (us : tuple0): (sem_cnot_mat(us) = tb2t18(make_f(complex1, 4, 4, 
  t2tb15(result58)))));

fc985: (ARRAY INT OF (ARRAY INT OF complex));

fc986: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, j : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), int, t2tb15(fc985), t2tb5(i)), 
  t2tb5(j))) = (IF (j = (IF (div(i, 2) = 0) THEN i ELSE (3 - mod(i,
                        2)) ENDIF))
               THEN c_one ELSE c_zero ENDIF)));

% fc'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((
  fc986(x)[i]) = (IF (i = 0) THEN (value(x)[i]) ELSE (1 - (
                 value(x)[i])) ENDIF)));

% sem_cnot_mat'spec
  ASSERT
  (FORALL (us : tuple0):
  ((rows(complex1, t2tb18(sem_cnot_mat(us))) = power(2, 2))
  AND ((columns(complex1, t2tb18(sem_cnot_mat(us))) = power(2, 2))
      AND ((sem_cnot_mat(us) = tb2t18(make_f(complex1, 4, 4, t2tb15(fc985))))
          AND ((FORALL (x : bitvec):
               ((length(x) = 2) => (mat_mult(sem_cnot_mat(us), 
               bv_to_ket(x)) = 
               bv_to_ket((IF ((value(x)[0]) = 0) THEN x ELSE 
                         int_to_bv((IF (bv_to_int(x) = 2) THEN 3
                                   ELSE 2 ENDIF),
                         2) ENDIF)))))
              AND ((FORALL (x : bitvec):
                   ((length(x) = 2) => (mat_mult(sem_cnot_mat(us), 
                   bv_to_ket(x)) = 
                   bv_to_ket((IF ((value(x)[0]) = 0) THEN x ELSE make_bv(
                             fc986(x), 2) ENDIF)))))
                  AND ((FORALL (i : INT):
                       (((0 <= i) AND (i < power(2, 2))) => (mat_mult(
                       sem_cnot_mat(us), ket(2, i)) = ket(2,
                       (IF (i = 0) THEN 0
                       ELSE (IF (i = 1) THEN 1
                            ELSE (IF (i = 2) THEN 3 ELSE 2 ENDIF) ENDIF) ENDIF)))))
                      AND ((FORALL (x : bitvec):
                           ((length(x) = 2) => (mat_mult(sem_cnot_mat(us), 
                           bv_to_ket(x)) = bv_to_ket(cnot_func(x)))))
                          AND (FORALL (x : bitvec):
                              ((length(x) = 2) => (mat_mult(sem_cnot_mat(us), 
                              bv_to_ket(x)) = pps_apply_basis(pps_cnot(0, 1,
                              2), x))))))))))));

swap_func: (bitvec) -> bitvec;

result123: (bitvec) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((result123(x)[i]) = (value(x)[(1 - i)])));

% swap_func'def
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 2) => (swap_func(x) = make_bv(result123(x), 2))));

% swap_func'spec
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 2)
  => ((length(swap_func(x)) = 2)
     AND (((bv_to_int(x) = 0) => (swap_func(x) = int_to_bv(0, 2)))
         AND (((bv_to_int(x) = 1) => (swap_func(x) = int_to_bv(2, 2)))
             AND (((bv_to_int(x) = 2) => (swap_func(x) = int_to_bv(1, 2)))
                 AND ((bv_to_int(x) = 3) => (swap_func(x) = int_to_bv(3, 2)))))))));

% invol_swap_func
  ASSERT
  (FORALL (x : bitvec): ((length(x) = 2) => (swap_func(swap_func(x)) = x)));

swap_func_int: (INT) -> INT;

% swap_func_int'def
  ASSERT
  (FORALL (i : INT): (swap_func_int(i) = bv_to_int(swap_func(int_to_bv(i,
  2)))));

% swap_func_int'spec
  ASSERT
  (FORALL (i : INT):
  (((0 <= swap_func_int(i)) AND (swap_func_int(i) < 4))
  AND (((i = 0) => (swap_func_int(i) = 0))
      AND (((i = 1) => (swap_func_int(i) = 2))
          AND (((i = 2) => (swap_func_int(i) = 1))
              AND (((i = 3) => (swap_func_int(i) = 3))
                  AND (((0 <= i) AND (i < 4)) => (
                      swap_func_int(i) = (IF (div(i, 2) = mod(i, 2)) THEN i
                                         ELSE (3 - i) ENDIF)))))))));

% invol_swap_func_int
  ASSERT
  (FORALL (i : INT):
  (((0 <= i) AND (i < 4)) => (swap_func_int(swap_func_int(i)) = i)));

sem_swap_mat: (tuple0) -> matrix_complex;

result60: (ARRAY INT OF (ARRAY INT OF complex));

% result'def
  ASSERT
  (FORALL (i : INT, j : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), int, t2tb15(result60), t2tb5(i)), t2tb5(j))) = 
  indic(int, t2tb5(j), t2tb5(swap_func_int(i)))));

% sem_swap_mat'def
  ASSERT
  (FORALL (us : tuple0): (sem_swap_mat(us) = tb2t18(make_f(complex1, 4, 4, 
  t2tb15(result60)))));

fc987: (ARRAY INT OF (ARRAY INT OF complex));

fc988: (bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (i : INT, j : INT): (tb2t(infix_at(complex1, int, infix_at(
  infix_mngt(int, complex1), int, t2tb15(fc987), t2tb5(i)), t2tb5(j))) = 
  indic(int, t2tb5(j), 
  t2tb5((IF (i = 0) THEN i
        ELSE (IF (i = 1) THEN 2 ELSE (IF (i = 2) THEN 1 ELSE 3 ENDIF) ENDIF) ENDIF)))));

% fc'def
  ASSERT
  (FORALL (x : bitvec, i : INT): ((fc988(x)[i]) = (value(x)[(1 - i)])));

% sem_swap_mat'spec
  ASSERT
  (FORALL (us : tuple0):
  ((rows(complex1, t2tb18(sem_swap_mat(us))) = power(2, 2))
  AND ((columns(complex1, t2tb18(sem_swap_mat(us))) = power(2, 2))
      AND ((sem_swap_mat(us) = tb2t18(make_f(complex1, 4, 4, t2tb15(fc987))))
          AND ((FORALL (x : bitvec):
               ((length(x) = 2) => (mat_mult(sem_swap_mat(us), 
               bv_to_ket(x)) = bv_to_ket(make_bv(fc988(x), 2)))))
              AND ((FORALL (x : bitvec):
                   ((length(x) = 2) => (mat_mult(sem_swap_mat(us), 
                   bv_to_ket(x)) = bv_to_ket(swap_func(x)))))
                  AND ((FORALL (i : INT):
                       (((0 <= i) AND (i < power(2, 2))) => (mat_mult(
                       sem_swap_mat(us), ket(2, i)) = ket(2,
                       (IF (i = 0) THEN 0
                       ELSE (IF (i = 1) THEN 2
                            ELSE (IF (i = 2) THEN 1 ELSE 3 ENDIF) ENDIF) ENDIF)))))
                      AND (FORALL (x : bitvec):
                          ((length(x) = 2) => (mat_mult(sem_swap_mat(us), 
                          bv_to_ket(x)) = pps_apply_basis(pps_swap(0, 1, 2),
                          x)))))))))));

circuit_pre : TYPE;

circuit_pre1: ty;

Phase: (INT) -> circuit_pre;

Rz: (INT) -> circuit_pre;

Hadamard: circuit_pre;

Cnot: circuit_pre;

Swap: circuit_pre;

Id: circuit_pre;

Sequence: (circuit_pre, circuit_pre) -> circuit_pre;

Parallel: (circuit_pre, circuit_pre) -> circuit_pre;

Ancillas: (circuit_pre, INT) -> circuit_pre;

match_circuit_pre1: (ty, circuit_pre, uni, uni, uni, uni, uni, uni, uni, uni,
  uni) -> uni;

% match_circuit_pre_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : circuit_pre, x1 : uni, x2 : uni, x3 : uni, x4 : uni, x5 : uni,
  x6 : uni, x7 : uni, x8 : uni, x9 : uni): (sort(a, match_circuit_pre1(a, x,
  x1, x2, x3, x4, x5, x6, x7, x8, x9)))));

% match_circuit_pre_Phase
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, u : INT):
  ((sort(a, z)) => (match_circuit_pre1(a, Phase(u), z, z1, z2, z3, z4, z5,
  z6, z7, z8) = z))));

% match_circuit_pre_Rz
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, u : INT):
  ((sort(a, z1)) => (match_circuit_pre1(a, Rz(u), z, z1, z2, z3, z4, z5, z6,
  z7, z8) = z1))));

% match_circuit_pre_Hadamard
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni):
  ((sort(a, z2)) => (match_circuit_pre1(a, Hadamard, z, z1, z2, z3, z4, z5,
  z6, z7, z8) = z2))));

% match_circuit_pre_Cnot
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni):
  ((sort(a, z3)) => (match_circuit_pre1(a, Cnot, z, z1, z2, z3, z4, z5, z6,
  z7, z8) = z3))));

% match_circuit_pre_Swap
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni):
  ((sort(a, z4)) => (match_circuit_pre1(a, Swap, z, z1, z2, z3, z4, z5, z6,
  z7, z8) = z4))));

% match_circuit_pre_Id
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni):
  ((sort(a, z5)) => (match_circuit_pre1(a, Id, z, z1, z2, z3, z4, z5, z6, z7,
  z8) = z5))));

% match_circuit_pre_Sequence
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, u : circuit_pre, u1 : circuit_pre):
  ((sort(a, z6)) => (match_circuit_pre1(a, Sequence(u, u1), z, z1, z2, z3,
  z4, z5, z6, z7, z8) = z6))));

% match_circuit_pre_Parallel
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, u : circuit_pre, u1 : circuit_pre):
  ((sort(a, z7)) => (match_circuit_pre1(a, Parallel(u, u1), z, z1, z2, z3,
  z4, z5, z6, z7, z8) = z7))));

% match_circuit_pre_Ancillas
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, u : circuit_pre, u1 : INT):
  ((sort(a, z8)) => (match_circuit_pre1(a, Ancillas(u, u1), z, z1, z2, z3,
  z4, z5, z6, z7, z8) = z8))));

index_circuit_pre1: (circuit_pre) -> INT;

% index_circuit_pre_Phase
  ASSERT
  (FORALL (u : INT):PATTERN (Phase(u)):  (index_circuit_pre1(Phase(u)) = 0));

% index_circuit_pre_Rz
  ASSERT
  (FORALL (u : INT):PATTERN (Rz(u)):  (index_circuit_pre1(Rz(u)) = 1));

% index_circuit_pre_Hadamard
  ASSERT (index_circuit_pre1(Hadamard) = 2);

% index_circuit_pre_Cnot
  ASSERT (index_circuit_pre1(Cnot) = 3);

% index_circuit_pre_Swap
  ASSERT (index_circuit_pre1(Swap) = 4);

% index_circuit_pre_Id
  ASSERT (index_circuit_pre1(Id) = 5);

% index_circuit_pre_Sequence
  ASSERT
  (FORALL (u : circuit_pre, u1 : circuit_pre):PATTERN (Sequence(u, u1)):  (
  index_circuit_pre1(Sequence(u, u1)) = 6));

% index_circuit_pre_Parallel
  ASSERT
  (FORALL (u : circuit_pre, u1 : circuit_pre):PATTERN (Parallel(u, u1)):  (
  index_circuit_pre1(Parallel(u, u1)) = 7));

% index_circuit_pre_Ancillas
  ASSERT
  (FORALL (u : circuit_pre, u1 : INT):PATTERN (Ancillas(u, u1)):  (
  index_circuit_pre1(Ancillas(u, u1)) = 8));

Phase_proj_12: (circuit_pre) -> INT;

% Phase_proj_1'def
  ASSERT (FORALL (u : INT): (Phase_proj_12(Phase(u)) = u));

Rz_proj_12: (circuit_pre) -> INT;

% Rz_proj_1'def
  ASSERT (FORALL (u : INT): (Rz_proj_12(Rz(u)) = u));

Sequence_proj_12: (circuit_pre) -> circuit_pre;

% Sequence_proj_1'def
  ASSERT
  (FORALL (u : circuit_pre, u1 : circuit_pre): (Sequence_proj_12(Sequence(u,
  u1)) = u));

Sequence_proj_22: (circuit_pre) -> circuit_pre;

% Sequence_proj_2'def
  ASSERT
  (FORALL (u : circuit_pre, u1 : circuit_pre): (Sequence_proj_22(Sequence(u,
  u1)) = u1));

Parallel_proj_12: (circuit_pre) -> circuit_pre;

% Parallel_proj_1'def
  ASSERT
  (FORALL (u : circuit_pre, u1 : circuit_pre): (Parallel_proj_12(Parallel(u,
  u1)) = u));

Parallel_proj_22: (circuit_pre) -> circuit_pre;

% Parallel_proj_2'def
  ASSERT
  (FORALL (u : circuit_pre, u1 : circuit_pre): (Parallel_proj_22(Parallel(u,
  u1)) = u1));

Ancillas_proj_12: (circuit_pre) -> circuit_pre;

% Ancillas_proj_1'def
  ASSERT
  (FORALL (u : circuit_pre, u1 : INT): (Ancillas_proj_12(Ancillas(u,
  u1)) = u));

Ancillas_proj_22: (circuit_pre) -> INT;

% Ancillas_proj_2'def
  ASSERT
  (FORALL (u : circuit_pre, u1 : INT): (Ancillas_proj_22(Ancillas(u,
  u1)) = u1));

% circuit_pre_inversion
  ASSERT
  (FORALL (u : circuit_pre):
  (((((((((u = Phase(Phase_proj_12(u))) OR (u = Rz(Rz_proj_12(u))))
        OR (u = Hadamard))
       OR (u = Cnot))
      OR (u = Swap))
     OR (u = Id))
    OR (u = Sequence(Sequence_proj_12(u), Sequence_proj_22(u))))
   OR (u = Parallel(Parallel_proj_12(u), Parallel_proj_22(u))))
  OR (u = Ancillas(Ancillas_proj_12(u), Ancillas_proj_22(u)))));

width_pre: (circuit_pre) -> INT;

% width_pre'def
  ASSERT
  (((((((((FORALL (w : INT): (width_pre(Phase(w)) = 1))
         AND (FORALL (w : INT): (width_pre(Rz(w)) = 1)))
        AND (width_pre(Hadamard) = 1))
       AND (width_pre(Cnot) = 2))
      AND (width_pre(Swap) = 2))
     AND (width_pre(Id) = 1))
    AND (FORALL (x : circuit_pre, x1 : circuit_pre): (width_pre(Sequence(x,
        x1)) = width_pre(x))))
   AND (FORALL (x : circuit_pre, x1 : circuit_pre): (width_pre(Parallel(x,
       x1)) = (width_pre(x) + width_pre(x1)))))
  AND (FORALL (x : circuit_pre, x1 : INT): (width_pre(Ancillas(x, x1)) = (
      width_pre(x) - x1))));

build_correct: (circuit_pre) -> BOOLEAN;

% build_correct'def
  ASSERT
  (((((((((FORALL (w : INT): (build_correct(Phase(w))))
         AND (FORALL (w : INT): (build_correct(Rz(w)))))
        AND (build_correct(Hadamard)))
       AND (build_correct(Cnot)))
      AND (build_correct(Swap)))
     AND (build_correct(Id)))
    AND (FORALL (d : circuit_pre, e : circuit_pre):
        ((build_correct(Sequence(d, e)))
        <=> ((width_pre(d) = width_pre(e))
            AND ((build_correct(d)) AND (build_correct(e)))))))
   AND (FORALL (d : circuit_pre, e : circuit_pre):
       ((build_correct(Parallel(d, e)))
       <=> ((build_correct(d)) AND (build_correct(e))))))
  AND (FORALL (d : circuit_pre, i : INT):
      ((build_correct(Ancillas(d, i)))
      <=> ((1 <= i) AND (((i + 1) <= width_pre(d)) AND (build_correct(d)))))));

circ_to_pps_pre: (circuit_pre) -> pps;

% circ_to_pps_pre'def
  ASSERT
  (FORALL (c : circuit_pre):
  ((build_correct(c))
  => (((((((((FORALL (k : INT):
             ((c = Phase(k)) => (circ_to_pps_pre(c) = pps_phase(k))))
            AND (FORALL (k : INT):
                ((c = Rz(k)) => (circ_to_pps_pre(c) = pps_rz(k)))))
           AND ((c = Hadamard) => (circ_to_pps_pre(c) = pps_hadamard)))
          AND ((c = Cnot) => (circ_to_pps_pre(c) = pps_cnot(0, 1, 2))))
         AND ((c = Swap) => (circ_to_pps_pre(c) = pps_swap(0, 1, 2))))
        AND ((c = Id) => (circ_to_pps_pre(c) = pps_id)))
       AND (FORALL (d : circuit_pre, e : circuit_pre):
           ((c = Sequence(d, e)) => (circ_to_pps_pre(c) = pps_seq(
           circ_to_pps_pre(d), circ_to_pps_pre(e))))))
      AND (FORALL (d : circuit_pre, e : circuit_pre):
          ((c = Parallel(d, e)) => (circ_to_pps_pre(c) = pps_par(
          circ_to_pps_pre(d), circ_to_pps_pre(e))))))
     AND (FORALL (d : circuit_pre, i : INT):
         ((c = Ancillas(d, i)) => (circ_to_pps_pre(c) = pps_ancs(
         circ_to_pps_pre(d), i)))))));

% circ_to_pps_pre'spec
  ASSERT
  (FORALL (c : circuit_pre):
  ((build_correct(c))
  => ((h_width(circ_to_pps_pre(c)) = width_pre(c)) AND (1 <= h_width(
     circ_to_pps_pre(c))))));

ancillable_pre: (circuit_pre, INT) -> BOOLEAN;

% ancillable_pre'spec
  ASSERT
  (FORALL (c : circuit_pre, i : INT):
  ((ancillable_pre(c, i))
  <=> (EXISTS (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
      (FORALL (x : matrix_complex):
      ((is_a_ket_l(x, (width_pre(c) - i))) => (pps_apply(circ_to_pps_pre(c), 
      kronecker(x, ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
      matrix(complex1), t2tb19(path_sem_target), t2tb18(x))), ket(i, 0))))))));

correct: (circuit_pre) -> BOOLEAN;

% correct'def
  ASSERT
  (((((((((FORALL (w : INT): (correct(Phase(w))))
         AND (FORALL (w : INT): (correct(Rz(w)))))
        AND (correct(Hadamard)))
       AND (correct(Cnot)))
      AND (correct(Swap)))
     AND (correct(Id)))
    AND (FORALL (d : circuit_pre, e : circuit_pre):
        ((correct(Sequence(d, e)))
        <=> ((width_pre(d) = width_pre(e))
            AND ((correct(d)) AND (correct(e)))))))
   AND (FORALL (d : circuit_pre, e : circuit_pre):
       ((correct(Parallel(d, e))) <=> ((correct(d)) AND (correct(e))))))
  AND (FORALL (d : circuit_pre, i : INT):
      ((correct(Ancillas(d, i)))
      <=> ((1 <= i)
          AND (((i + 1) <= width_pre(d))
              AND ((correct(d)) AND (ancillable_pre(d, i))))))));

% correct'spec
  ASSERT (FORALL (c : circuit_pre): ((correct(c)) => (build_correct(c))));

circuit : TYPE;

circuit1: ty;

pre: (circuit) -> circuit_pre;

% circuit'invariant
  ASSERT
  (FORALL (self : circuit):PATTERN (pre(self)):  (correct(pre(self))));

% injective_pre
  ASSERT
  (FORALL (c : circuit, cqt : circuit):
  ((NOT (c = cqt)) => (NOT (pre(c) = pre(cqt)))));

to_qc: (circuit_pre) -> circuit;

% to_qc'spec
  ASSERT (FORALL (c : circuit_pre): ((correct(c)) => (pre(to_qc(c)) = c)));

int63 : TYPE;

int631: ty;

int63qtint: (int63) -> INT;

% int63'axiom
  ASSERT
  (FORALL (i : int63):
  (((- 4611686018427387904) <= int63qtint(i)) AND (
  int63qtint(i) <= 4611686018427387903)));

in_bounds: (INT) -> BOOLEAN;

% in_bounds'def
  ASSERT
  (FORALL (n : INT):
  ((in_bounds(n))
  <=> (((- 4611686018427387904) <= n) AND (n <= 4611686018427387903))));

% to_int_in_bounds
  ASSERT (FORALL (n : int63): (in_bounds(int63qtint(n))));

% extensionality
  ASSERT
  (FORALL (x : int63, y : int63):
  ((int63qtint(x) = int63qtint(y)) => (x = y)));

div1: (INT, INT) -> INT;

mod1: (INT, INT) -> INT;

% Div_mod
  ASSERT
  (FORALL (x : INT, y : INT):
  ((NOT (y = 0)) => (x = ((y * div1(x, y)) + mod1(x, y)))));

% Div_bound
  ASSERT
  (FORALL (x : INT, y : INT):
  (((0 <= x) AND (0 < y)) => ((0 <= div1(x, y)) AND (div1(x, y) <= x))));

% Mod_bound
  ASSERT
  (FORALL (x : INT, y : INT):
  ((NOT (y = 0)) => (((- abs(y)) < mod1(x, y)) AND (mod1(x, y) < abs(y)))));

% Div_sign_pos
  ASSERT
  (FORALL (x : INT, y : INT): (((0 <= x) AND (0 < y)) => (0 <= div1(x, y))));

% Div_sign_neg
  ASSERT
  (FORALL (x : INT, y : INT): (((x <= 0) AND (0 < y)) => (div1(x, y) <= 0)));

% Mod_sign_pos
  ASSERT
  (FORALL (x : INT, y : INT):
  (((0 <= x) AND (NOT (y = 0))) => (0 <= mod1(x, y))));

% Mod_sign_neg
  ASSERT
  (FORALL (x : INT, y : INT):
  (((x <= 0) AND (NOT (y = 0))) => (mod1(x, y) <= 0)));

% Rounds_toward_zero
  ASSERT
  (FORALL (x : INT, y : INT):
  ((NOT (y = 0)) => (abs((div1(x, y) * y)) <= abs(x))));

% Div_1
  ASSERT (FORALL (x : INT): (div1(x, 1) = x));

% Mod_1
  ASSERT (FORALL (x : INT): (mod1(x, 1) = 0));

% Div_inf
  ASSERT
  (FORALL (x : INT, y : INT): (((0 <= x) AND (x < y)) => (div1(x, y) = 0)));

% Mod_inf
  ASSERT
  (FORALL (x : INT, y : INT): (((0 <= x) AND (x < y)) => (mod1(x, y) = x)));

% Div_mult
  ASSERT
  (FORALL (x : INT, y : INT, z : INT):PATTERN (div1(((x * y) + z), x)): 
  (((0 < x) AND ((0 <= y) AND (0 <= z))) => (div1(((x * y) + z), x) = (y + 
  div1(z, x)))));

% Mod_mult
  ASSERT
  (FORALL (x : INT, y : INT, z : INT):PATTERN (mod1(((x * y) + z), x)): 
  (((0 < x) AND ((0 <= y) AND (0 <= z))) => (mod1(((x * y) + z), x) = mod1(z,
  x))));

max_int: int63;

% max_int'def
  ASSERT (int63qtint(max_int) = 4611686018427387903);

min_int: int63;

% min_int'def
  ASSERT (int63qtint(min_int) = (- 4611686018427387904));

concat1: (string, string) -> string;

% concat_assoc
  ASSERT
  (FORALL (s11 : string, s2 : string, s3 : string): (concat1(concat1(s11,
  s2), s3) = concat1(s11, concat1(s2, s3))));

rliteral13: string;

% rliteral_axiom
  ASSERT TRUE;

% concat_empty
  ASSERT
  (FORALL (s2 : string):
  ((concat1(s2, rliteral13) = concat1(rliteral13, s2)) AND (
  concat1(rliteral13, s2) = s2)));

length1: (string) -> INT;

% length_empty
  ASSERT (length1(rliteral13) = 0);

% length_concat
  ASSERT
  (FORALL (s11 : string, s2 : string): (length1(concat1(s11, s2)) = (
  length1(s11) + length1(s2))));

lt: (string, string) -> BOOLEAN;

% lt_empty
  ASSERT
  (FORALL (s2 : string): ((NOT (s2 = rliteral13)) => (lt(rliteral13, s2))));

% lt_not_com
  ASSERT
  (FORALL (s11 : string, s2 : string):
  ((lt(s11, s2)) => (NOT (lt(s2, s11)))));

% lt_ref
  ASSERT (FORALL (s11 : string): (NOT (lt(s11, s11))));

% lt_trans
  ASSERT
  (FORALL (s11 : string, s2 : string, s3 : string):
  (((lt(s11, s2)) AND (lt(s2, s3))) => (lt(s11, s3))));

le: (string, string) -> BOOLEAN;

% le_empty
  ASSERT (FORALL (s2 : string): (le(rliteral13, s2)));

% le_ref
  ASSERT (FORALL (s11 : string): (le(s11, s11)));

% lt_le
  ASSERT
  (FORALL (s11 : string, s2 : string): ((lt(s11, s2)) => (le(s11, s2))));

% lt_le_eq
  ASSERT
  (FORALL (s11 : string, s2 : string):
  ((le(s11, s2)) => ((lt(s11, s2)) OR (s11 = s2))));

% le_trans
  ASSERT
  (FORALL (s11 : string, s2 : string, s3 : string):
  (((le(s11, s2)) AND (le(s2, s3))) => (le(s11, s3))));

s_at: (string, INT) -> string;

% at_out_of_range
  ASSERT
  (FORALL (s2 : string, i : INT):
  (((i < 0) OR (length1(s2) <= i)) => (s_at(s2, i) = rliteral13)));

% at_empty
  ASSERT (FORALL (i : INT): (s_at(rliteral13, i) = rliteral13));

% at_length
  ASSERT
  (FORALL (s2 : string, i : INT):
  (LET j = s_at(s2, i) IN
  (IF ((0 <= i) AND (i < length1(s2))) THEN (length1(j) = 1) ELSE (
  length1(j) = 0) ENDIF)));

% concat_at
  ASSERT
  (FORALL (s11 : string, s2 : string):
  (LET s3 = concat1(s11, s2) IN
  (FORALL (i : INT):
  ((((0 <= i) AND (i < length1(s11))) => (s_at(s3, i) = s_at(s11, i)))
  AND (((length1(s11) <= i) AND (i < length1(s3))) => (s_at(s3, i) = s_at(s2,
      (i - length1(s11)))))))));

substring: (string, INT, INT) -> string;

% substring_out_of_range
  ASSERT
  (FORALL (s2 : string, i : INT, x : INT):
  (((i < 0) OR (length1(s2) <= i)) => (substring(s2, i, x) = rliteral13)));

% substring_of_length_zero_or_less
  ASSERT
  (FORALL (s2 : string, i : INT, x : INT):
  ((x <= 0) => (substring(s2, i, x) = rliteral13)));

% substring_of_empty
  ASSERT
  (FORALL (i : INT, x : INT): (substring(rliteral13, i, x) = rliteral13));

% substring_smaller
  ASSERT
  (FORALL (s2 : string, i : INT, x : INT): (length1(substring(s2, i, x)) <= 
  length1(s2)));

% substring_smaller_x
  ASSERT
  (FORALL (s2 : string, i : INT, x : INT):
  ((0 <= x) => (length1(substring(s2, i, x)) <= x)));

% substring_length
  ASSERT
  (FORALL (s2 : string, i : INT, x : INT):
  (((0 <= x) AND ((0 <= i) AND (i < length1(s2))))
  => (IF (length1(s2) < (i + x)) THEN (length1(substring(s2, i, x)) = (
     length1(s2) - i)) ELSE (length1(substring(s2, i, x)) = x) ENDIF)));

% substring_at
  ASSERT
  (FORALL (s2 : string, i : INT): (s_at(s2, i) = substring(s2, i, 1)));

% substring_substring
  ASSERT
  (FORALL (s2 : string, ofs : INT, len : INT, ofsqt : INT, lenqt : INT):
  (((0 <= ofs) AND (ofs <= length1(s2)))
  => ((0 <= len)
     => (((ofs + len) <= length1(s2))
        => (((0 <= ofsqt) AND (ofsqt <= len))
           => ((0 <= lenqt)
              => (((ofsqt + lenqt) <= len) => (substring(substring(s2, ofs,
                 len), ofsqt, lenqt) = substring(s2, (ofs + ofsqt), lenqt)))))))));

% concat_substring
  ASSERT
  (FORALL (s2 : string, ofs : INT, len : INT, lenqt : INT):
  (((0 <= ofs) AND (ofs <= length1(s2)))
  => ((0 <= len)
     => (((ofs + len) <= length1(s2))
        => ((0 <= lenqt)
           => (((0 <= ((ofs + len) + lenqt)) AND (((ofs + len) + lenqt) <= 
               length1(s2)))
              => (concat1(substring(s2, ofs, len), substring(s2, (ofs + len),
              lenqt)) = substring(s2, ofs, (len + lenqt)))))))));

prefixof: (string, string) -> BOOLEAN;

% prefixof_substring
  ASSERT
  (FORALL (s11 : string, s2 : string):
  ((prefixof(s11, s2)) <=> (s11 = substring(s2, 0, length1(s11)))));

% prefixof_concat
  ASSERT
  (FORALL (s11 : string, s2 : string): (prefixof(s11, concat1(s11, s2))));

% prefixof_empty
  ASSERT (FORALL (s2 : string): (prefixof(rliteral13, s2)));

% prefixof_empty2
  ASSERT
  (FORALL (s11 : string):
  ((NOT (s11 = rliteral13)) => (NOT (prefixof(s11, rliteral13)))));

suffixof: (string, string) -> BOOLEAN;

% suffixof_substring
  ASSERT
  (FORALL (s11 : string, s2 : string):
  ((suffixof(s11, s2)) <=> (s11 = substring(s2, (length1(s2) - length1(s11)), 
  length1(s11)))));

% suffixof_concat
  ASSERT
  (FORALL (s11 : string, s2 : string): (suffixof(s2, concat1(s11, s2))));

% suffixof_empty
  ASSERT (FORALL (s2 : string): (suffixof(rliteral13, s2)));

% suffixof_empty2
  ASSERT
  (FORALL (s11 : string):
  ((NOT (s11 = rliteral13)) => (NOT (suffixof(s11, rliteral13)))));

contains: (string, string) -> BOOLEAN;

% contains_prefixof
  ASSERT
  (FORALL (s11 : string, s2 : string):
  ((prefixof(s11, s2)) => (contains(s2, s11))));

% contains_suffixof
  ASSERT
  (FORALL (s11 : string, s2 : string):
  ((suffixof(s11, s2)) => (contains(s2, s11))));

% contains_empty
  ASSERT
  (FORALL (s2 : string): ((contains(rliteral13, s2)) <=> (s2 = rliteral13)));

% contains_empty2
  ASSERT (FORALL (s11 : string): (contains(s11, rliteral13)));

% contains_substring
  ASSERT
  (FORALL (s11 : string, s2 : string, i : INT):
  ((substring(s11, i, length1(s2)) = s2) => (contains(s11, s2))));

% contains_concat
  ASSERT
  (FORALL (s11 : string, s2 : string):
  ((contains(concat1(s11, s2), s11)) AND (contains(concat1(s11, s2), s2))));

% contains_at
  ASSERT
  (FORALL (s11 : string, s2 : string, i : INT):
  ((s_at(s11, i) = s2) => (contains(s11, s2))));

indexof: (string, string, INT) -> INT;

% indexof_empty
  ASSERT
  (FORALL (s2 : string, i : INT):
  (((0 <= i) AND (i <= length1(s2))) => (indexof(s2, rliteral13, i) = i)));

% indexof_empty1
  ASSERT
  (FORALL (s2 : string, i : INT):
  (LET j = indexof(rliteral13, s2, i) IN
  ((j = (- 1)) OR ((s2 = rliteral13) AND ((i = j) AND (j = 0))))));

% indexof_contains
  ASSERT
  (FORALL (s11 : string, s2 : string):
  (LET j = indexof(s11, s2, 0) IN
  ((contains(s11, s2))
  => (((0 <= j) AND (j <= length1(s11))) AND (substring(s11, j, 
     length1(s2)) = s2)))));

% contains_indexof
  ASSERT
  (FORALL (s11 : string, s2 : string, i : INT):
  ((0 <= indexof(s11, s2, i)) => (contains(s11, s2))));

% not_contains_indexof
  ASSERT
  (FORALL (s11 : string, s2 : string, i : INT):
  ((NOT (contains(s11, s2))) => (indexof(s11, s2, i) = (- 1))));

% substring_indexof
  ASSERT
  (FORALL (s11 : string, s2 : string, i : INT):
  (LET j = indexof(s11, s2, i) IN
  ((0 <= j) => (substring(s11, j, length1(s2)) = s2))));

% indexof_out_of_range
  ASSERT
  (FORALL (i : INT, s11 : string, s2 : string):
  ((NOT ((0 <= i) AND (i <= length1(s11)))) => (indexof(s11, s2, i) = (- 1))));

% indexof_in_range
  ASSERT
  (FORALL (s11 : string, s2 : string, i : INT):
  (LET j = indexof(s11, s2, i) IN
  (((0 <= i) AND (i <= length1(s11)))
  => ((j = (- 1)) OR ((i <= j) AND (j <= length1(s11)))))));

% indexof_contains_substring
  ASSERT
  (FORALL (s11 : string, s2 : string, i : INT):
  ((((0 <= i) AND (i <= length1(s11))) AND (contains(substring(s11, i, (
   length1(s11) - i)), s2)))
  => ((i <= indexof(s11, s2, i)) AND (indexof(s11, s2, i) <= length1(s11)))));

replace: (string, string, string) -> string;

% replace_empty
  ASSERT
  (FORALL (s11 : string, s3 : string): (replace(s11, rliteral13, s3) = 
  concat1(s3, s11)));

% replace_not_contains
  ASSERT
  (FORALL (s11 : string, s2 : string, s3 : string):
  ((NOT (contains(s11, s2))) => (replace(s11, s2, s3) = s11)));

% replace_empty2
  ASSERT
  (FORALL (s2 : string, s3 : string):
  (LET s4 = replace(rliteral13, s2, s3) IN
  (IF (s2 = rliteral13) THEN (s4 = s3) ELSE (s4 = rliteral13) ENDIF)));

% replace_substring_indexof
  ASSERT
  (FORALL (s11 : string, s2 : string, s3 : string):
  (LET j = indexof(s11, s2, 0) IN (replace(s11, s2,
  s3) = (IF (j < 0) THEN s11 ELSE concat1(concat1(substring(s11, 0, j), s3), 
        substring(s11, (j + length1(s2)), ((length1(s11) - j) - 
        length1(s2)))) ENDIF))));

replaceall: (string, string, string) -> string;

% replaceall_empty1
  ASSERT
  (FORALL (s11 : string, s3 : string): (replaceall(s11, rliteral13,
  s3) = s11));

% not_contains_replaceall
  ASSERT
  (FORALL (s11 : string, s2 : string, s3 : string):
  ((NOT (contains(s11, s2))) => (replaceall(s11, s2, s3) = s11)));

to_int: (string) -> INT;

% to_int_gt_minus_1
  ASSERT (FORALL (s2 : string): ((- 1) <= to_int(s2)));

% to_int_empty
  ASSERT (to_int(rliteral13) = (- 1));

is_digit: (string) -> BOOLEAN;

% is_digit'def
  ASSERT
  (FORALL (s2 : string):
  ((is_digit(s2))
  <=> (((0 <= to_int(s2)) AND (to_int(s2) <= 9)) AND (length1(s2) = 1))));

from_int1: (INT) -> string;

% from_int_negative
  ASSERT (FORALL (i : INT): ((i < 0) <=> (from_int1(i) = rliteral13)));

% from_int_to_int
  ASSERT
  (FORALL (i : INT):
  (IF (0 <= i) THEN (to_int(from_int1(i)) = i) ELSE (to_int(
  from_int1(i)) = (- 1)) ENDIF));

char : TYPE;

char1: ty;

contents2: (char) -> string;

% char'invariant
  ASSERT
  (FORALL (self : char):PATTERN (contents2(self)):  (length1(
  contents2(self)) = 1));

% char_eq
  ASSERT
  (FORALL (c1 : char, c2 : char):
  ((contents2(c1) = contents2(c2)) => (c1 = c2)));

code: (char) -> INT;

% code
  ASSERT (FORALL (c : char): ((0 <= code(c)) AND (code(c) < 256)));

chr: (INT) -> char;

% code_chr
  ASSERT
  (FORALL (n : INT): (((0 <= n) AND (n < 256)) => (code(chr(n)) = n)));

% chr_code
  ASSERT (FORALL (c : char): (chr(code(c)) = c));

get1: (string, INT) -> char;

% get
  ASSERT
  (FORALL (s2 : string, i : INT):
  (((0 <= i) AND (i < length1(s2))) => (contents2(get1(s2, i)) = s_at(s2,
  i))));

% substring_get
  ASSERT
  (FORALL (s2 : string, ofs : INT, len : INT, i : INT):
  (((0 <= ofs) AND (ofs <= length1(s2)))
  => ((0 <= len)
     => (((ofs + len) <= length1(s2))
        => (((0 <= i) AND (i < len)) => (get1(substring(s2, ofs, len), i) = 
           get1(s2, (ofs + i))))))));

% concat_first
  ASSERT
  (FORALL (s11 : string, s2 : string):
  (FORALL (i : INT):
  (((0 <= i) AND (i < length1(s11))) => (get1(concat1(s11, s2), i) = 
  get1(s11, i)))));

% concat_second
  ASSERT
  (FORALL (s11 : string, s2 : string):
  (FORALL (i : INT):
  (((length1(s11) <= i) AND (i < (length1(s11) + length1(s2)))) => (get1(
  concat1(s11, s2), i) = get1(s2, (i - length1(s11)))))));

eq_string: (string, string) -> BOOLEAN;

% eq_string'def
  ASSERT
  (FORALL (s11 : string, s2 : string):
  ((eq_string(s11, s2))
  <=> ((length1(s11) = length1(s2))
      AND (FORALL (i : INT):
          (((0 <= i) AND (i < length1(s11))) => (get1(s11, i) = get1(s2, i)))))));

% extensionality
  ASSERT
  (FORALL (s11 : string, s2 : string): ((eq_string(s11, s2)) => (s11 = s2)));

make1: (INT, char) -> string;

% make_length
  ASSERT
  (FORALL (size2 : INT, v : char):
  ((0 <= size2) => (length1(make1(size2, v)) = size2)));

% make_contents
  ASSERT
  (FORALL (size2 : INT, v : char):
  ((0 <= size2)
  => (FORALL (i : INT):
     (((0 <= i) AND (i < size2)) => (get1(make1(size2, v), i) = v)))));

int_to_string: (INT) -> string;

circ_to_string_: (circuit) -> string;

rliteral14: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral15: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral16: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral17: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral18: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral19: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral20: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral21: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral22: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral23: string;

% rliteral_axiom
  ASSERT TRUE;

rliteral24: string;

% rliteral_axiom
  ASSERT TRUE;

% circ_to_string_'def
  ASSERT
  (FORALL (c : circuit):
  (((((((((FORALL (x : INT):
          ((pre(c) = Phase(x)) => (circ_to_string_(c) = concat1(
          concat1(rliteral14, int_to_string(x)), rliteral15))))
         AND (FORALL (x : INT):
             ((pre(c) = Rz(x)) => (circ_to_string_(c) = concat1(
             concat1(rliteral16, int_to_string(x)), rliteral15)))))
        AND ((pre(c) = Hadamard) => (circ_to_string_(c) = rliteral17)))
       AND ((pre(c) = Cnot) => (circ_to_string_(c) = rliteral18)))
      AND ((pre(c) = Swap) => (circ_to_string_(c) = rliteral19)))
     AND ((pre(c) = Id) => (circ_to_string_(c) = rliteral20)))
    AND (FORALL (x : circuit_pre, x1 : circuit_pre):
        ((pre(c) = Sequence(x, x1)) => (circ_to_string_(c) = concat1(concat1(
        circ_to_string_(to_qc(x)), rliteral21), circ_to_string_(to_qc(x1)))))))
   AND (FORALL (x : circuit_pre, x1 : circuit_pre):
       ((pre(c) = Parallel(x, x1)) => (circ_to_string_(c) = concat1(concat1(
       concat1(concat1(rliteral22, circ_to_string_(to_qc(x))), rliteral23), 
       circ_to_string_(to_qc(x1))), rliteral15)))))
  AND (FORALL (x : circuit_pre, x1 : INT):
      ((pre(c) = Ancillas(x, x1)) => (circ_to_string_(c) = concat1(
      concat1(rliteral24, circ_to_string_(to_qc(x))), rliteral15))))));

circ_to_string: (circuit) -> string;

rliteral25: string;

% rliteral_axiom
  ASSERT TRUE;

% circ_to_string'def
  ASSERT
  (FORALL (c : circuit): (circ_to_string(c) = concat1(circ_to_string_(c),
  rliteral25)));

% to_qc_rev
  ASSERT (FORALL (c : circuit): (c = to_qc(pre(c))));

% to_qc_pre
  ASSERT (FORALL (c : circuit): (to_qc(pre(c)) = c));

% pre_rev
  ASSERT (FORALL (c : circuit_pre): ((correct(c)) => (c = pre(to_qc(c)))));

% pre_to_qc
  ASSERT (FORALL (c : circuit_pre): ((correct(c)) => (pre(to_qc(c)) = c)));

circ_to_pps: (circuit) -> pps;

% circ_to_pps'def
  ASSERT
  (FORALL (c : circuit):
  (((((((((FORALL (k : INT):
          ((pre(c) = Phase(k)) => (circ_to_pps(c) = pps_phase(k))))
         AND (FORALL (k : INT):
             ((pre(c) = Rz(k)) => (circ_to_pps(c) = pps_rz(k)))))
        AND ((pre(c) = Hadamard) => (circ_to_pps(c) = pps_hadamard)))
       AND ((pre(c) = Cnot) => (circ_to_pps(c) = pps_cnot(0, 1, 2))))
      AND ((pre(c) = Swap) => (circ_to_pps(c) = pps_swap(0, 1, 2))))
     AND ((pre(c) = Id) => (circ_to_pps(c) = pps_id)))
    AND (FORALL (d : circuit_pre, e : circuit_pre):
        ((pre(c) = Sequence(d, e)) => (circ_to_pps(c) = pps_seq(circ_to_pps(
        to_qc(d)), circ_to_pps(to_qc(e)))))))
   AND (FORALL (d : circuit_pre, e : circuit_pre):
       ((pre(c) = Parallel(d, e)) => (circ_to_pps(c) = pps_par(circ_to_pps(
       to_qc(d)), circ_to_pps(to_qc(e)))))))
  AND (FORALL (d : circuit_pre, i : INT):
      ((pre(c) = Ancillas(d, i)) => (circ_to_pps(c) = pps_ancs(circ_to_pps(
      to_qc(d)), i))))));

% circ_to_pps'spec
  ASSERT
  (FORALL (c : circuit):
  ((circ_to_pps(c) = circ_to_pps_pre(pre(c)))
  AND ((h_width(circ_to_pps(c)) = width_pre(pre(c))) AND (1 <= h_width(
      circ_to_pps(c))))));

width: (circuit) -> INT;

% width'def
  ASSERT (FORALL (c : circuit): (width(c) = width_pre(pre(c))));

% width'spec
  ASSERT
  (FORALL (c : circuit):
  ((1 <= width(c)) AND (width(c) = h_width(circ_to_pps(c)))));

mat_sem: (circuit) -> matrix_complex;

% mat_sem'def
  ASSERT
  (FORALL (c : circuit):
  (((((((((FORALL (k : INT):
          ((pre(c) = Phase(k)) => (mat_sem(c) = sem_phase_mat(k))))
         AND (FORALL (k : INT):
             ((pre(c) = Rz(k)) => (mat_sem(c) = sem_rz_mat(k)))))
        AND ((pre(c) = Hadamard) => (mat_sem(c) = sem_hadamard_mat(Tuple0))))
       AND ((pre(c) = Cnot) => (mat_sem(c) = sem_cnot_mat(Tuple0))))
      AND ((pre(c) = Swap) => (mat_sem(c) = sem_swap_mat(Tuple0))))
     AND ((pre(c) = Id) => (mat_sem(c) = sem_id_mat(Tuple0))))
    AND (FORALL (d : circuit_pre, e : circuit_pre):
        ((pre(c) = Sequence(d, e)) => (mat_sem(c) = mat_mult(mat_sem(
        to_qc(e)), mat_sem(to_qc(d)))))))
   AND (FORALL (d : circuit_pre, e : circuit_pre):
       ((pre(c) = Parallel(d, e)) => (mat_sem(c) = kronecker(mat_sem(
       to_qc(d)), mat_sem(to_qc(e)))))))
  AND (FORALL (d : circuit_pre, i : INT):
      ((pre(c) = Ancillas(d, i)) => (mat_sem(c) = pps_to_mat(pps_ancs(
      circ_to_pps(to_qc(d)), i)))))));

% mat_sem'spec
  ASSERT
  (FORALL (c : circuit):
  ((rows(complex1, t2tb18(mat_sem(c))) = power(2, width_pre(pre(c))))
  AND ((columns(complex1, t2tb18(mat_sem(c))) = power(2, width_pre(pre(c))))
      AND ((FORALL (x : bitvec):
           ((length(x) = width_pre(pre(c))) => (mat_mult(mat_sem(c), 
           bv_to_ket(x)) = pps_apply_basis(circ_to_pps(c), x))))
          AND (FORALL (x : matrix_complex):
              ((is_a_ket_l(x, width_pre(pre(c)))) => (mat_mult(mat_sem(c),
              x) = pps_apply(circ_to_pps(c), x))))))));

% pps_to_mat_mat_sem
  ASSERT (FORALL (c : circuit): (mat_sem(c) = pps_to_mat(circ_to_pps(c))));

% sem_correction_gen
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (mat_mult(mat_sem(c), x) = pps_apply(
  circ_to_pps(c), x))));

% sem_correction_gen_rev
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (pps_apply(circ_to_pps(c), x) = mat_mult(
  mat_sem(c), x))));

size: (circuit) -> INT;

% size'def
  ASSERT
  (FORALL (c : circuit):
  (((((((((FORALL (w : INT): ((pre(c) = Phase(w)) => (size(c) = 1)))
         AND (FORALL (w : INT): ((pre(c) = Rz(w)) => (size(c) = 1))))
        AND ((pre(c) = Hadamard) => (size(c) = 1)))
       AND ((pre(c) = Cnot) => (size(c) = 1)))
      AND ((pre(c) = Swap) => (size(c) = 0)))
     AND ((pre(c) = Id) => (size(c) = 0)))
    AND (FORALL (x : circuit_pre, x1 : circuit_pre):
        ((pre(c) = Sequence(x, x1)) => (size(c) = (size(to_qc(x)) + size(
        to_qc(x1)))))))
   AND (FORALL (x : circuit_pre, x1 : circuit_pre):
       ((pre(c) = Parallel(x, x1)) => (size(c) = (size(to_qc(x)) + size(
       to_qc(x1)))))))
  AND (FORALL (x : circuit_pre, x1 : INT):
      ((pre(c) = Ancillas(x, x1)) => (size(c) = size(to_qc(x)))))));

% size'spec
  ASSERT (FORALL (c : circuit): (0 <= size(c)));

min: (INT, INT) -> INT;

% min'def
  ASSERT
  (FORALL (x : INT, y : INT):
  (IF (x <= y) THEN (min(x, y) = x) ELSE (min(x, y) = y) ENDIF));

max: (INT, INT) -> INT;

% max'def
  ASSERT
  (FORALL (x : INT, y : INT):
  (IF (x <= y) THEN (max(x, y) = y) ELSE (max(x, y) = x) ENDIF));

% Min_r
  ASSERT (FORALL (x : INT, y : INT): ((y <= x) => (min(x, y) = y)));

% Max_l
  ASSERT (FORALL (x : INT, y : INT): ((y <= x) => (max(x, y) = x)));

% Min_comm
  ASSERT (FORALL (x : INT, y : INT): (min(x, y) = min(y, x)));

% Max_comm
  ASSERT (FORALL (x : INT, y : INT): (max(x, y) = max(y, x)));

% Min_assoc
  ASSERT
  (FORALL (x : INT, y : INT, z : INT): (min(min(x, y), z) = min(x, min(y,
  z))));

% Max_assoc
  ASSERT
  (FORALL (x : INT, y : INT, z : INT): (max(max(x, y), z) = max(x, max(y,
  z))));

min_set: (set_int) -> INT;

% min_set'def
  ASSERT
  (FORALL (s2 : set_int):
  ((0 < cardinal(int, t2tb6(s2)))
  => (IF (cardinal(int, t2tb6(s2)) = 1) THEN (min_set(s2) = tb2t5(choose(int, 
     t2tb6(s2)))) ELSE (min_set(s2) = min(tb2t5(choose(int, t2tb6(s2))), 
     min_set(tb2t6(remove(int, choose(int, t2tb6(s2)), t2tb6(s2)))))) ENDIF)));

% min_set'spec
  ASSERT
  (FORALL (s2 : set_int):
  ((0 < cardinal(int, t2tb6(s2)))
  => ((mem(int, t2tb5(min_set(s2)), t2tb6(s2)))
     AND (FORALL (e : INT):
         ((mem(int, t2tb5(e), t2tb6(s2))) => (min_set(s2) <= e))))));

max_set: (set_int) -> INT;

% max_set'def
  ASSERT
  (FORALL (s2 : set_int):
  ((0 < cardinal(int, t2tb6(s2)))
  => (IF (cardinal(int, t2tb6(s2)) = 1) THEN (max_set(s2) = tb2t5(choose(int, 
     t2tb6(s2)))) ELSE (max_set(s2) = max(tb2t5(choose(int, t2tb6(s2))), 
     max_set(tb2t6(remove(int, choose(int, t2tb6(s2)), t2tb6(s2)))))) ENDIF)));

% max_set'spec
  ASSERT
  (FORALL (s2 : set_int):
  ((0 < cardinal(int, t2tb6(s2)))
  => ((mem(int, t2tb5(max_set(s2)), t2tb6(s2)))
     AND (FORALL (e : INT):
         ((mem(int, t2tb5(e), t2tb6(s2))) => (e <= max_set(s2)))))));

max3: (INT, INT, INT) -> INT;

% max3'def
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): (max3(a, b, c) = max(max(a, b), c)));

% max3'spec
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((a <= max3(a, b, c))
  AND ((b <= max3(a, b, c))
      AND ((c <= max3(a, b, c)) AND (max3(a, b, c) = max(a, max(b, c)))))));

min3: (INT, INT, INT) -> INT;

% min3'def
  ASSERT
  (FORALL (a : INT, b : INT, c : INT): (min3(a, b, c) = min(min(a, b), c)));

% min3'spec
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((min3(a, b, c) <= a)
  AND ((min3(a, b, c) <= b)
      AND ((min3(a, b, c) <= c) AND (min3(a, b, c) = min(a, min(b, c)))))));

midd3: (INT, INT, INT) -> INT;

% midd3'def
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  (IF (min3(a, b, c) = a)
  THEN (IF (max3(a, b, c) = b) THEN (midd3(a, b, c) = c) ELSE (midd3(a, b,
       c) = b) ENDIF)
  ELSE (IF (min3(a, b, c) = b)
       THEN (IF (max3(a, b, c) = a) THEN (midd3(a, b, c) = c) ELSE (midd3(a,
            b, c) = a) ENDIF)
       ELSE (IF (max3(a, b, c) = a) THEN (midd3(a, b, c) = b) ELSE (midd3(a,
            b, c) = a) ENDIF) ENDIF) ENDIF));

% midd3'spec
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((min3(a, b, c) <= midd3(a, b, c)) AND (midd3(a, b, c) <= max3(a, b, c))));

max3_strict: (INT, INT, INT) -> INT;

% max3_strict'def
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((NOT (a = b))
  => ((NOT (a = c))
     => ((NOT (b = c)) => (max3_strict(a, b, c) = max3(a, b, c))))));

% max3_strict'spec
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((NOT (a = b))
  => ((NOT (a = c))
     => ((NOT (b = c))
        => ((min3(a, b, c) < midd3(a, b, c)) AND (midd3(a, b, c) < 
           max3_strict(a, b, c)))))));

min3_strict: (INT, INT, INT) -> INT;

% min3_strict'def
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((NOT (a = b))
  => ((NOT (a = c))
     => ((NOT (b = c)) => (min3_strict(a, b, c) = min3(a, b, c))))));

% min3_strict'spec
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((NOT (a = b))
  => ((NOT (a = c))
     => ((NOT (b = c))
        => ((min3_strict(a, b, c) < midd3(a, b, c)) AND (midd3(a, b, c) < 
           max3_strict(a, b, c)))))));

midd3_strict: (INT, INT, INT) -> INT;

% midd3_strict'def
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((NOT (a = b))
  => ((NOT (a = c))
     => ((NOT (b = c)) => (midd3_strict(a, b, c) = midd3(a, b, c))))));

% midd3_strict'spec
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((NOT (a = b))
  => ((NOT (a = c))
     => ((NOT (b = c))
        => ((min3_strict(a, b, c) < midd3_strict(a, b, c)) AND (
           midd3_strict(a, b, c) < max3_strict(a, b, c)))))));

% max_right
  ASSERT (FORALL (a : INT, b : INT): ((a <= b) => (max(a, b) = b)));

% max_left
  ASSERT (FORALL (a : INT, b : INT): ((b <= a) => (max(a, b) = a)));

min_filter: (set_int, (ARRAY INT OF BITVECTOR(1))) -> INT;

% min_filter'def
  ASSERT
  (FORALL (s2 : set_int, p : (ARRAY INT OF BITVECTOR(1))):
  ((EXISTS (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) AND (tb2t2(infix_at(bool, int, t2tb9(p), 
   t2tb5(e))) = 0bin1)))
  => (IF (tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(min_set(s2)))) = 0bin1)
     THEN (min_filter(s2, p) = min_set(s2)) ELSE (min_filter(s2, p) = 
     min_filter(tb2t6(remove(int, t2tb5(min_set(s2)), t2tb6(s2))), p)) ENDIF)));

% min_filter'spec
  ASSERT
  (FORALL (s2 : set_int, p : (ARRAY INT OF BITVECTOR(1))):
  ((EXISTS (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) AND (tb2t2(infix_at(bool, int, t2tb9(p), 
   t2tb5(e))) = 0bin1)))
  => ((tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(min_filter(s2,
     p)))) = 0bin1)
     AND ((mem(int, t2tb5(min_filter(s2, p)), t2tb6(s2)))
         AND ((FORALL (e : INT):
              ((mem(int, t2tb5(e), t2tb6(s2)))
              => ((tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(e))) = 0bin1)
                 => (min_filter(s2, p) <= e))))
             AND (FORALL (e : INT):
                 ((mem(int, t2tb5(e), t2tb6(s2)))
                 => ((e < min_filter(s2, p))
                    => (NOT (tb2t2(infix_at(bool, int, t2tb9(p), 
                       t2tb5(e))) = 0bin1))))))))));

% min_filter_min_set
  ASSERT
  (FORALL (s2 : set_int, p : (ARRAY INT OF BITVECTOR(1))):
  ((EXISTS (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) AND (tb2t2(infix_at(bool, int, t2tb9(p), 
   t2tb5(e))) = 0bin1)))
  => (min_filter(s2, p) = min_set(tb2t6(my_filter(int, t2tb6(s2), 
  t2tb9(p)))))));

max_filter: (set_int, (ARRAY INT OF BITVECTOR(1))) -> INT;

% max_filter'def
  ASSERT
  (FORALL (s2 : set_int, p : (ARRAY INT OF BITVECTOR(1))):
  ((EXISTS (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) AND (tb2t2(infix_at(bool, int, t2tb9(p), 
   t2tb5(e))) = 0bin1)))
  => (IF (tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(max_set(s2)))) = 0bin1)
     THEN (max_filter(s2, p) = max_set(s2)) ELSE (max_filter(s2, p) = 
     max_filter(tb2t6(remove(int, t2tb5(max_set(s2)), t2tb6(s2))), p)) ENDIF)));

% max_filter'spec
  ASSERT
  (FORALL (s2 : set_int, p : (ARRAY INT OF BITVECTOR(1))):
  ((EXISTS (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) AND (tb2t2(infix_at(bool, int, t2tb9(p), 
   t2tb5(e))) = 0bin1)))
  => ((tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(max_filter(s2,
     p)))) = 0bin1)
     AND ((mem(int, t2tb5(max_filter(s2, p)), t2tb6(s2)))
         AND ((FORALL (e : INT):
              ((mem(int, t2tb5(e), t2tb6(s2)))
              => ((tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(e))) = 0bin1)
                 => (e <= max_filter(s2, p)))))
             AND (FORALL (e : INT):
                 ((mem(int, t2tb5(e), t2tb6(s2)))
                 => ((max_filter(s2, p) < e)
                    => (NOT (tb2t2(infix_at(bool, int, t2tb9(p), 
                       t2tb5(e))) = 0bin1))))))))));

% appr_pre
  ASSERT
  (FORALL (theta : complex, n : INT):
  ((0 < n)
  => ((real_(theta))
     => (((infix_lsdt(c_zero, theta)) AND (infix_lseqdt(theta, c_one)))
        => (EXISTS (k : INT):
           ((mem(int, t2tb5(k), t2tb6(to_fset(0, (n + 1)))))
           AND (infix_lseqdt(modulus(infix_mndt(theta, infix_sldt(i_to_c(k), 
           i_to_c(n)))), infix_sldt(c_one, i_to_c((n * 2)))))))))));

% appr
  ASSERT
  (FORALL (theta : complex, n : INT):
  ((0 < n)
  => ((real_(theta))
     => (((infix_lseqdt(c_zero, theta)) AND (infix_lseqdt(theta, c_one)))
        => (EXISTS (k : INT):
           ((mem(int, t2tb5(k), t2tb6(to_fset(0, (n + 1)))))
           AND (infix_lseqdt(modulus(infix_mndt(theta, infix_sldt(i_to_c(k), 
           i_to_c(n)))), infix_sldt(c_one, i_to_c((n * 2)))))))))));

min_complex: (complex, complex) -> complex;

% min_complex'def
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => (IF (infix_lseqdt(a, b)) THEN (min_complex(a, b) = a) ELSE (
        min_complex(a, b) = b) ENDIF))));

% min_complex'spec
  ASSERT
  (FORALL (a : complex, b : complex):
  ((real_(a))
  => ((real_(b))
     => ((real_(min_complex(a, b)))
        AND ((infix_lseqdt(min_complex(a, b), a)) AND (infix_lseqdt(
            min_complex(a, b), b)))))));

min_set_complex: (ty, uni, uni) -> complex;

% min_set_complex'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((0 < cardinal(a, s2))
  => ((FORALL (x : uni):
      ((sort(a, x))
      => ((mem(a, x, s2)) => (real_(tb2t(infix_at(complex1, a, f, x)))))))
     => (IF (cardinal(a, s2) = 1) THEN (min_set_complex(a, s2, f) = tb2t(
        infix_at(complex1, a, f, choose(a, s2)))) ELSE (min_set_complex(a,
        s2, f) = min_complex(tb2t(infix_at(complex1, a, f, choose(a, s2))), 
        min_set_complex(a, remove(a, choose(a, s2), s2), f))) ENDIF)))));

% min_set_complex'spec
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((0 < cardinal(a, s2))
  => ((FORALL (x : uni):
      ((sort(a, x))
      => ((mem(a, x, s2)) => (real_(tb2t(infix_at(complex1, a, f, x)))))))
     => ((EXISTS (e : uni):
         ((sort(a, e))
         AND ((mem(a, e, s2)) AND (min_set_complex(a, s2, f) = tb2t(
             infix_at(complex1, a, f, e))))))
        AND ((real_(min_set_complex(a, s2, f)))
            AND (FORALL (e : uni):
                ((mem(a, e, s2)) => (infix_lseqdt(min_set_complex(a, s2, f), 
                tb2t(infix_at(complex1, a, f, e))))))))))));

% min_set_complex_pos
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((0 < cardinal(a, s2))
  => ((FORALL (x : uni):
      ((sort(a, x))
      => ((mem(a, x, s2)) => (real_(tb2t(infix_at(complex1, a, f, x)))))))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (infix_lseqdt(c_zero, tb2t(infix_at(complex1,
            a, f, x)))))))
        => (infix_lseqdt(c_zero, min_set_complex(a, s2, f))))))));

ancillas: (circuit) -> INT;

% ancillas'def
  ASSERT
  (FORALL (c : circuit):
  (((((((((FORALL (w : INT): ((pre(c) = Phase(w)) => (ancillas(c) = 0)))
         AND (FORALL (w : INT): ((pre(c) = Rz(w)) => (ancillas(c) = 0))))
        AND ((pre(c) = Hadamard) => (ancillas(c) = 0)))
       AND ((pre(c) = Cnot) => (ancillas(c) = 0)))
      AND ((pre(c) = Swap) => (ancillas(c) = 0)))
     AND ((pre(c) = Id) => (ancillas(c) = 0)))
    AND (FORALL (d : circuit_pre, e : circuit_pre):
        ((pre(c) = Sequence(d, e)) => (ancillas(c) = max(ancillas(to_qc(d)), 
        ancillas(to_qc(e)))))))
   AND (FORALL (d : circuit_pre, e : circuit_pre):
       ((pre(c) = Parallel(d, e)) => (ancillas(c) = (ancillas(to_qc(d)) + 
       ancillas(to_qc(e)))))))
  AND (FORALL (d : circuit_pre, i : INT):
      ((pre(c) = Ancillas(d, i)) => (ancillas(c) = (ancillas(to_qc(d)) + i))))));

% ancillas'spec
  ASSERT (FORALL (c : circuit): (0 <= ancillas(c)));

range: (circuit) -> INT;

% range'def
  ASSERT (FORALL (c : circuit): (range(c) = h_range(circ_to_pps(c))));

% range'spec
  ASSERT (FORALL (c : circuit): (0 <= range(c)));

basis_ket: (circuit, (ARRAY INT OF INT), (ARRAY INT OF INT), INT) -> INT;

% basis_ket'def
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  i : INT): (basis_ket(c, x, y, i) = (tb2t7(infix_at(infix_mngt(int, int), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
  infix_mngt(int, int)), infix_mngt(int, int), t2tb55(h_basis_ket(
  circ_to_pps(c))), t2tb7(x)), t2tb7(y)))[i])));

% basis_ket'spec
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  i : INT):
  ((FORALL (i1 : INT):
   (((0 <= i1) AND (i1 < width(c))) => ((0 <= (x[i1])) AND ((x[i1]) < 2))))
  => ((FORALL (i1 : INT):
      (((0 <= i1) AND (i1 < range(c))) => ((0 <= (y[i1])) AND ((y[i1]) < 2))))
     => (((0 <= i) AND (i < width(c)))
        => ((0 <= basis_ket(c, x, y, i)) AND (basis_ket(c, x, y, i) < 2))))));

basis_ket_closure: (ARRAY circuit OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))));

t2tb62: (circuit) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : circuit): (sort(circuit1, t2tb62(x))));

tb2t62: (uni) -> circuit;

% BridgeL
  ASSERT
  (FORALL (i : circuit):PATTERN (t2tb62(i)):  (tb2t62(t2tb62(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb62(tb2t62(j))): 
  ((sort(circuit1, j)) => (t2tb62(tb2t62(j)) = j)));

t2tb63: ((ARRAY circuit OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY circuit OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))))):
  (sort(infix_mngt(circuit1, infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int)))), t2tb63(x))));

tb2t63: (uni) -> (ARRAY circuit OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY circuit OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))))):PATTERN (
  t2tb63(i)):  (tb2t63(t2tb63(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb63(tb2t63(j))):  (t2tb63(tb2t63(j)) = j));

% basis_ket_closure_def
  ASSERT
  (FORALL (y : circuit, y1 : (ARRAY INT OF INT), y2 : (ARRAY INT OF INT),
  y3 : INT): ((tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int))), circuit1, 
  t2tb63(basis_ket_closure), t2tb62(y)), t2tb7(y1)), t2tb7(y2)))[y3]) = 
  basis_ket(y, y1, y2, y3)));

% binary_basis_ket
  ASSERT
  (FORALL (c : circuit, w : INT, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT)):
  ((w = width(c))
  => ((binary_l(x, w))
     => ((binary_l(y, range(c))) => (binary_l(tb2t7(infix_at(infix_mngt(int,
        int), infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
        infix_mngt(int, int)), infix_mngt(int, int), infix_at(infix_mngt(
        infix_mngt(int, int), infix_mngt(infix_mngt(int, int), 
        infix_mngt(int, int))), circuit1, t2tb63(basis_ket_closure), 
        t2tb62(c)), t2tb7(x)), t2tb7(y))), w))))));

% basis_ket_invariant
  ASSERT
  (FORALL (c : circuit):
  (FORALL (x : (ARRAY INT OF INT), xqt : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), yqt : (ARRAY INT OF INT)):
  ((FORALL (i : INT): (((0 <= i) AND (i < width(c))) => ((x[i]) = (xqt[i]))))
  => ((FORALL (i : INT):
      (((0 <= i) AND (i < range(c))) => ((y[i]) = (yqt[i]))))
     => (FORALL (i : INT):
        (((0 <= i) AND (i < width(c))) => (basis_ket(c, x, y, i) = 
        basis_ket(c, xqt, yqt, i))))))));

ang_ind: (circuit, (ARRAY INT OF INT), (ARRAY INT OF INT)) -> angle;

% ang_ind'def
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
  ang_ind(c, x, y) = tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(
  h_angle(circ_to_pps(c))), t2tb7(x)), t2tb7(y)))));

% ang_ind_invariant
  ASSERT
  (FORALL (c : circuit):
  (FORALL (x : (ARRAY INT OF INT), xqt : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), yqt : (ARRAY INT OF INT)):
  ((FORALL (i : INT): (((0 <= i) AND (i < width(c))) => ((x[i]) = (xqt[i]))))
  => ((FORALL (i : INT):
      (((0 <= i) AND (i < range(c))) => ((y[i]) = (yqt[i]))))
     => (ang_ind(c, x, y) = ang_ind(c, xqt, yqt))))));

phase: (INT) -> circuit;

% phase'spec
  ASSERT
  (FORALL (k : INT):
  ((pre(phase(k)) = Phase(k))
  AND ((circ_to_pps(phase(k)) = pps_phase(k))
      AND ((ancillas(phase(k)) = 0)
          AND ((size(phase(k)) = 1)
              AND ((range(phase(k)) = 0)
                  AND ((width(phase(k)) = 1)
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)):
                           (FORALL (i : INT): (basis_ket(phase(k), x, y,
                           i) = (x[i]))))
                          AND (FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)): (ang_ind(phase(k), x,
                              y) = infix_sldtsl(1, k)))))))))));

rz: (INT) -> circuit;

% rz'spec
  ASSERT
  (FORALL (k : INT):
  ((pre(rz(k)) = Rz(k))
  AND ((circ_to_pps(rz(k)) = pps_rz(k))
      AND ((ancillas(rz(k)) = 0)
          AND ((size(rz(k)) = 1)
              AND ((range(rz(k)) = 0)
                  AND ((width(rz(k)) = 1)
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)):
                           (FORALL (i : INT): (basis_ket(rz(k), x, y,
                           i) = (x[i]))))
                          AND (FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)): (ang_ind(rz(k), x,
                              y) = infix_sldtsl((x[0]), k)))))))))));

hadamard: circuit;

% hadamard'def
  ASSERT
  ((pre(hadamard) = Hadamard)
  AND ((circ_to_pps(hadamard) = pps_hadamard)
      AND ((ancillas(hadamard) = 0)
          AND ((size(hadamard) = 1)
              AND ((range(hadamard) = 1)
                  AND ((width(hadamard) = 1)
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)):
                           (FORALL (i : INT): (basis_ket(hadamard, x, y,
                           i) = (y[i]))))
                          AND (FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)): (ang_ind(hadamard, x,
                              y) = infix_sldtsl(((x[0]) * (y[0])), 1))))))))));

cnot: circuit;

% cnot'def
  ASSERT
  ((pre(cnot) = Cnot)
  AND ((circ_to_pps(cnot) = pps_cnot(0, 1, 2))
      AND ((ancillas(cnot) = 0)
          AND ((size(cnot) = 1)
              AND ((range(cnot) = 0)
                  AND ((width(cnot) = 2)
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)):
                           (FORALL (i : INT):
                           ((NOT (i = 1)) => (basis_ket(cnot, x, y,
                           i) = (x[i])))))
                          AND ((FORALL (x : (ARRAY INT OF INT),
                               y : (ARRAY INT OF INT)):
                               (FORALL (i : INT):
                               ((i = 1) => (basis_ket(cnot, x, y,
                               i) = (((x[0]) * (1 - (x[i]))) + ((x[i]) * (1 - (x[0]))))))))
                              AND (FORALL (x : (ARRAY INT OF INT),
                                  y : (ARRAY INT OF INT)): (ang_ind(cnot, x,
                                  y) = ang_zero))))))))));

id: circuit;

% id'def
  ASSERT
  ((pre(id) = Id)
  AND ((circ_to_pps(id) = pps_id)
      AND ((ancillas(id) = 0)
          AND ((size(id) = 0)
              AND ((range(id) = 0)
                  AND ((width(id) = 1)
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)):
                           (FORALL (i : INT): (basis_ket(id, x, y,
                           i) = (x[i]))))
                          AND (FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)): (ang_ind(id, x,
                              y) = ang_zero)))))))));

swap: circuit;

% swap'def
  ASSERT
  ((pre(swap) = Swap)
  AND ((circ_to_pps(swap) = pps_swap(0, 1, 2))
      AND ((ancillas(swap) = 0)
          AND ((size(swap) = 0)
              AND ((range(swap) = 0)
                  AND ((width(swap) = 2)
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)): (basis_ket(swap, x, y,
                           0) = (x[1])))
                          AND ((FORALL (x : (ARRAY INT OF INT),
                               y : (ARRAY INT OF INT)): (basis_ket(swap, x,
                               y, 1) = (x[0])))
                              AND ((FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)):
                                   (FORALL (i : INT):
                                   (((0 <= i) AND (i < 2)) => (
                                   basis_ket(swap, x, y, i) = (x[(1 - i)])))))
                                  AND (FORALL (x : (ARRAY INT OF INT),
                                      y : (ARRAY INT OF INT)): (ang_ind(swap,
                                      x, y) = ang_zero)))))))))));

sequence: (circuit, circuit) -> circuit;

% sequence'spec
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e))
  => ((pre(sequence(d, e)) = Sequence(pre(d), pre(e)))
     AND ((sequence(d, e) = to_qc(Sequence(pre(d), pre(e)))) AND (
         circ_to_pps(sequence(d, e)) = pps_seq(circ_to_pps(d), 
         circ_to_pps(e)))))));

ancilla: (circuit, INT) -> circuit;

% ancilla'spec
  ASSERT
  (FORALL (d : circuit, i : INT):
  ((1 <= i)
  => (((i + 1) <= width(d))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width(d) - i)))
         => ((is_a_ket_basis_elt(x)) => (pps_apply(circ_to_pps(d), 
            kronecker(x, ket(i, 0))) = kronecker(tb2t18(infix_at(
            matrix(complex1), matrix(complex1), t2tb19(path_sem_target), 
            t2tb18(x))), ket(i, 0)))))))
        => ((pre(ancilla(d, i)) = Ancillas(pre(d), i))
           AND ((ancilla(d, i) = to_qc(Ancillas(pre(d), i))) AND (
               circ_to_pps(ancilla(d, i)) = pps_ancs(circ_to_pps(d), i))))))));

% ancilla_pre_cond
  ASSERT
  (FORALL (d : circuit, e : circuit_pre, i : INT):
  ((pre(d) = Ancillas(e, i))
  => (EXISTS (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
     (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, width(d))) => (pps_apply(circ_to_pps_pre(e), 
     kronecker(x, ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
     matrix(complex1), t2tb19(path_sem_target), t2tb18(x))), ket(i, 0))))))));

parallel: (circuit, circuit) -> circuit;

% parallel'spec
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((pre(parallel(d, e)) = Parallel(pre(d), pre(e)))
  AND ((parallel(d, e) = to_qc(Parallel(pre(d), pre(e)))) AND (circ_to_pps(
      parallel(d, e)) = pps_par(circ_to_pps(d), circ_to_pps(e))))));

% circ_to_pps_width
  ASSERT (FORALL (c : circuit): (h_width(circ_to_pps(c)) = width(c)));

% circ_to_pps_range
  ASSERT (FORALL (c : circuit): (h_range(circ_to_pps(c)) = range(c)));

% circ_to_pps_basis_ket
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  i : INT): ((tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), t2tb55(h_basis_ket(circ_to_pps(c))), t2tb7(x)), 
  t2tb7(y)))[i]) = basis_ket(c, x, y, i)));

% circ_to_pps_basis_ket_gen
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
  tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int,
  int), t2tb55(h_basis_ket(circ_to_pps(c))), t2tb7(x)), t2tb7(y))) = tb2t7(
  infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int, int), 
  infix_mngt(int, int))), circuit1, t2tb63(basis_ket_closure), t2tb62(c)), 
  t2tb7(x)), t2tb7(y)))));

% circ_to_pps_angle
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
  tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
  infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(h_angle(
  circ_to_pps(c))), t2tb7(x)), t2tb7(y))) = ang_ind(c, x, y)));

path_sem_basis: (circuit, matrix_complex) -> matrix_complex;

result124: (circuit, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% result'def
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(result124(c, x)), t2tb26(y))) = 
  infix_asdtdt(ang_exp(ang_ind(c, value(ket_to_bv(x)), value(y))), bv_to_ket(
  make_bv(tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int))), circuit1, 
  t2tb63(basis_ket_closure), t2tb62(c)), t2tb7(value(ket_to_bv(x)))), t2tb7(
  value(y)))), width(c))))));

% path_sem_basis'def
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis(c, x) = infix_asdtdt(
     pow_inv_sqrt_2(range(c)), ket_sum_l(bitvec1, t2tb28(n_bvs(range(c))), 
     t2tb29(result124(c, x)), width(c)))))));

% path_sem_basis'spec
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x))
     => ((is_a_ket_l(path_sem_basis(c, x), width(c))) AND (path_sem_basis(c,
        x) = pps_apply_basis(circ_to_pps(c), ket_to_bv(x)))))));

path_sem: (circuit, matrix_complex) -> matrix_complex;

result125: (circuit, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% result'def
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(result125(c, x)), 
  t2tb26(y))) = (IF (length(y) = width(c)) THEN infix_asdtdt(tb2t(
                get(complex1, t2tb18(x), bv_to_int(y), 0)), path_sem_basis(c, 
                bv_to_ket(y))) ELSE x ENDIF)));

% path_sem'def
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (path_sem(c, x) = ket_sum_l(bitvec1, t2tb28(
  n_bvs(width(c))), t2tb29(result125(c, x)), width(c)))));

% path_sem'spec
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_l(path_sem(c, x), width(c))) AND (path_sem(c, x) = pps_apply(
     circ_to_pps(c), x)))));

% mat_sem_to_path
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (mat_mult(mat_sem(c), x) = path_sem(c, x))));

% path_sem_to_mat
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (path_sem(c, x) = mat_mult(mat_sem(c), x))));

sem: (circuit, matrix_complex, matrix_complex) -> BOOLEAN;

% sem'def
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : matrix_complex):
  ((sem(c, x, y))
  <=> ((is_a_ket_l(x, width(c))) AND (infix_eqeq(matrix(complex1), t2tb18(y), 
      t2tb18(path_sem(c, x)))))));

% path_sem_to_sem
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width(c))) => ((path_sem(c, x) = y) => (sem(c, x, y)))));

% sem_to_path_sem
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : matrix_complex):
  ((sem(c, x, y)) => (path_sem(c, x) = y)));

% path_sem_basis_apply
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis(c, x) = pps_apply_basis(
     circ_to_pps(c), ket_to_bv(x))))));

fc989: (circuit, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc989(c, x)), t2tb26(y))) = infix_asdtdt(
  ang_exp(ang_ind(c, value(ket_to_bv(x)), value(y))), bv_to_ket(make_bv(
  tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int,
  int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int,
  int), infix_mngt(int, int))), circuit1, t2tb63(basis_ket_closure), 
  t2tb62(c)), t2tb7(value(ket_to_bv(x)))), t2tb7(value(y)))), width(c))))));

% path_sem_basis_value
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis(c, x) = infix_asdtdt(
     pow_inv_sqrt_2(range(c)), ket_sum_l(bitvec1, t2tb28(n_bvs(range(c))), 
     t2tb29(fc989(c, x)), width(c)))))));

fc990: (circuit, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc990(c, x)), t2tb26(y))) = infix_asdtdt(
  ang_exp(ang_ind(c, value(ket_to_bv(x)), value(y))), bv_to_ket(make_bv(
  tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int,
  int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int,
  int), infix_mngt(int, int))), circuit1, t2tb63(basis_ket_closure), 
  t2tb62(c)), t2tb7(value(ket_to_bv(x)))), t2tb7(value(y)))), width(c))))));

% path_sem_value_for_basis
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem(c, x) = infix_asdtdt(
     pow_inv_sqrt_2(range(c)), ket_sum_l(bitvec1, t2tb28(n_bvs(range(c))), 
     t2tb29(fc990(c, x)), width(c)))))));

% apply_path_sem_basis
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x)) => (pps_apply_basis(circ_to_pps(c), 
     ket_to_bv(x)) = path_sem_basis(c, x)))));

% path_sem_apply
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (path_sem(c, x) = pps_apply(circ_to_pps(c),
  x))));

% apply_path_sem
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (pps_apply(circ_to_pps(c), x) = path_sem(c,
  x))));

% ancilla_pre_cond_path_sem
  ASSERT
  (FORALL (d : circuit, e : circuit_pre, i : INT):
  ((pre(d) = Ancillas(e, i))
  => (EXISTS (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
     (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, width(d))) => (path_sem(to_qc(e), kronecker(x, ket(i,
     0))) = kronecker(tb2t18(infix_at(matrix(complex1), matrix(complex1), 
     t2tb19(path_sem_target), t2tb18(x))), ket(i, 0))))))));

% ancilla_pre_path_sem
  ASSERT
  (FORALL (d : circuit, e : circuit_pre, i : INT):
  ((pre(d) = Ancillas(e, i))
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, width(d))) => (path_sem(to_qc(e), kronecker(x, ket(i,
     0))) = kronecker(path_sem(d, x), ket(i, 0)))))));

% pre_ancilla
  ASSERT
  (FORALL (d : circuit, e : circuit, i : INT):
  ((pre(d) = Ancillas(pre(e), i)) => (d = ancilla(e, i))));

% set_mat_sem_path_sem
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((rows(complex1, t2tb18(x)) = power(2, width(c)))
  => ((columns(complex1, t2tb18(x)) = power(2, width(c)))
     => ((FORALL (ket1 : matrix_complex):
         ((is_a_ket_l(ket1, width(c)))
         => ((is_a_ket_basis_elt(ket1)) => (mat_mult(x, ket1) = path_sem(c,
            ket1)))))
        => (x = mat_sem(c))))));

% path_sem_basis_ket_l
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, l : INT):
  ((is_a_ket_l(x, width(c)))
  => ((l = width(c))
     => ((is_a_ket_basis_elt(x)) => (is_a_ket_l(path_sem_basis(c, x), l))))));

% path_sem_ket_l
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, l : INT):
  ((is_a_ket_l(x, width(c)))
  => ((l = width(c)) => (is_a_ket_l(path_sem(c, x), l)))));

% path_sem_ket
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (is_a_ket(path_sem(c, x)))));

% path_sem_ket_length
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, l : INT):
  ((is_a_ket_l(x, width(c)))
  => ((l = width(c)) => (ket_length(path_sem(c, x)) = l))));

% path_sem_to_ket_l
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((path_sem(c, x) = y) => (is_a_ket_l(y, width(c))))));

fc991: (circuit, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc991(c, x)), t2tb26(y))) = infix_asdtdt(
  tb2t(get(complex1, t2tb18(x), bv_to_int(y), 0)), path_sem_basis(c, 
  bv_to_ket(y)))));

% get_path_sem
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (path_sem(c, x) = ket_sum_l(bitvec1, t2tb28(
  n_bvs(width(c))), t2tb29(fc991(c, x)), width(c)))));

% get_path_sem_basis
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem(c, x) = path_sem_basis(c, x)))));

% set_path_sem_basis
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis(c, x) = path_sem(c, x)))));

% circ_to_pps_parallel
  ASSERT
  (FORALL (d : circuit, e : circuit): (circ_to_pps(parallel(d, e)) = pps_par(
  circ_to_pps(d), circ_to_pps(e))));

% parallel_width
  ASSERT
  (FORALL (d : circuit, e : circuit): (width(parallel(d, e)) = (width(d) + 
  width(e))));

% parallel_range
  ASSERT
  (FORALL (d : circuit, e : circuit): (range(parallel(d, e)) = (range(d) + 
  range(e))));

% parallel_size
  ASSERT
  (FORALL (d : circuit, e : circuit): (size(parallel(d, e)) = (size(d) + 
  size(e))));

% parallel_ancilla
  ASSERT
  (FORALL (d : circuit, e : circuit): (ancillas(parallel(d, e)) = (
  ancillas(d) + ancillas(e))));

fc509: (circuit, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc510: (circuit, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit, x : (ARRAY INT OF INT), k : INT): ((fc509(d,
  x)[k]) = (x[(k + width(d))])));

% fc'def
  ASSERT
  (FORALL (d : circuit, y : (ARRAY INT OF INT), k : INT): ((fc510(d,
  y)[k]) = (y[(k + range(d))])));

% parallel_basis_ket
  ASSERT
  (FORALL (d : circuit, e : circuit, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), i : INT): (basis_ket(parallel(d, e), x, y,
  i) = (IF (i < width(d)) THEN basis_ket(d, x, y, i) ELSE basis_ket(e, 
       fc509(d, x), fc510(d, y), (i - width(d))) ENDIF)));

fc992: (circuit, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc993: (circuit, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit, x : (ARRAY INT OF INT), k : INT): ((fc992(d,
  x)[k]) = (x[(k + width(d))])));

% fc'def
  ASSERT
  (FORALL (d : circuit, y : (ARRAY INT OF INT), k : INT): ((fc993(d,
  y)[k]) = (y[(k + range(d))])));

% parallel_angle
  ASSERT
  (FORALL (d : circuit, e : circuit, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT)): (ang_ind(parallel(d, e), x, y) = ang_add(
  ang_ind(d, x, y), ang_ind(e, fc992(d, x), fc993(d, y)))));

% circ_to_pps_sequence
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e)) => (circ_to_pps(sequence(d, e)) = pps_seq(
  circ_to_pps(d), circ_to_pps(e)))));

% sequence_width
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e)) => (width(sequence(d, e)) = width(d))));

% sequence_size
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e)) => (size(sequence(d, e)) = (size(d) + size(e)))));

% sequence_ancillas
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e)) => (ancillas(sequence(d, e)) = max(ancillas(d), 
  ancillas(e)))));

% sequence_range
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e)) => (range(sequence(d, e)) = (range(d) + range(e)))));

fc513: (circuit, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit, y : (ARRAY INT OF INT), k : INT): ((fc513(d,
  y)[k]) = (y[(k + range(d))])));

% sequence_basis_ket
  ASSERT
  (FORALL (d : circuit, e : circuit, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), i : INT):
  ((width(d) = width(e)) => (basis_ket(sequence(d, e), x, y, i) = 
  basis_ket(e, tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int))), circuit1, 
  t2tb63(basis_ket_closure), t2tb62(d)), t2tb7(x)), t2tb7(y))), fc513(d, y),
  i))));

fc994: (circuit, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit, y : (ARRAY INT OF INT), k : INT): ((fc994(d,
  y)[k]) = (y[(k + range(d))])));

% sequence_angle
  ASSERT
  (FORALL (d : circuit, e : circuit, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT)):
  ((width(d) = width(e)) => (ang_ind(sequence(d, e), x, y) = ang_add(
  ang_ind(d, x, y), ang_ind(e, tb2t7(infix_at(infix_mngt(int, int), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
  infix_mngt(int, int)), infix_mngt(int, int), infix_at(infix_mngt(
  infix_mngt(int, int), infix_mngt(infix_mngt(int, int), infix_mngt(int,
  int))), circuit1, t2tb63(basis_ket_closure), t2tb62(d)), t2tb7(x)), 
  t2tb7(y))), fc994(d, y))))));

% circ_to_pps_ancilla
  ASSERT
  (FORALL (c : circuit, i : INT):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width(c) - i))) => (path_sem(c, kronecker(x, ket(i,
         0))) = kronecker(tb2t18(infix_at(matrix(complex1), matrix(complex1), 
         t2tb19(path_sem_target), t2tb18(x))), ket(i, 0))))))
        => (circ_to_pps(ancilla(c, i)) = pps_ancs(circ_to_pps(c), i))))));

% ancilla_width
  ASSERT
  (FORALL (c : circuit, i : INT):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width(c) - i))) => (path_sem(c, kronecker(x, ket(i,
         0))) = kronecker(tb2t18(infix_at(matrix(complex1), matrix(complex1), 
         t2tb19(path_sem_target), t2tb18(x))), ket(i, 0))))))
        => (width(ancilla(c, i)) = (width(c) - i))))));

% ancilla_size
  ASSERT
  (FORALL (c : circuit, i : INT):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width(c) - i))) => (path_sem(c, kronecker(x, ket(i,
         0))) = kronecker(tb2t18(infix_at(matrix(complex1), matrix(complex1), 
         t2tb19(path_sem_target), t2tb18(x))), ket(i, 0))))))
        => (size(ancilla(c, i)) = size(c))))));

% ancilla_range
  ASSERT
  (FORALL (c : circuit, i : INT):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width(c) - i))) => (path_sem(c, kronecker(x, ket(i,
         0))) = kronecker(tb2t18(infix_at(matrix(complex1), matrix(complex1), 
         t2tb19(path_sem_target), t2tb18(x))), ket(i, 0))))))
        => (range(ancilla(c, i)) = range(c))))));

% ancilla_ancilla
  ASSERT
  (FORALL (c : circuit, i : INT):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width(c) - i))) => (path_sem(c, kronecker(x, ket(i,
         0))) = kronecker(tb2t18(infix_at(matrix(complex1), matrix(complex1), 
         t2tb19(path_sem_target), t2tb18(x))), ket(i, 0))))))
        => (ancillas(ancilla(c, i)) = (ancillas(c) + i))))));

fc515: (circuit, (ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), i : INT, k : INT): ((fc515(c,
  x, i)[k]) = (IF (k < (width(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% ancilla_basis_ket
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  l : INT, i : INT):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (x1 : matrix_complex):
         ((is_a_ket_l(x1, (width(c) - i))) => (path_sem(c, kronecker(x1, 
         ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
         matrix(complex1), t2tb19(path_sem_target), t2tb18(x1))), ket(i,
         0))))))
        => (basis_ket(ancilla(c, i), x, y, l) = basis_ket(c, fc515(c, x, i),
        y, l))))));

fc516: (circuit, (ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), i : INT, k : INT): ((fc516(c,
  x, i)[k]) = (IF (k < (width(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% ancilla_angle
  ASSERT
  (FORALL (c : circuit, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  i : INT):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (x1 : matrix_complex):
         ((is_a_ket_l(x1, (width(c) - i))) => (path_sem(c, kronecker(x1, 
         ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
         matrix(complex1), t2tb19(path_sem_target), t2tb18(x1))), ket(i,
         0))))))
        => (ang_ind(ancilla(c, i), x, y) = ang_ind(c, fc516(c, x, i), y))))));

% sequence_eq
  ASSERT
  (FORALL (d : circuit, dqt : circuit, e : circuit, eqt : circuit):
  ((width(d) = width(e))
  => ((d = dqt) => ((e = eqt) => (sequence(d, e) = sequence(dqt, eqt))))));

ancilla_closure: (ARRAY circuit OF (ARRAY INT OF circuit));

t2tb64: ((ARRAY INT OF circuit)) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF circuit)): (sort(infix_mngt(int, circuit1), 
  t2tb64(x))));

tb2t64: (uni) -> (ARRAY INT OF circuit);

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF circuit)):PATTERN (t2tb64(i)):  (tb2t64(
  t2tb64(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb64(tb2t64(j))): 
  ((sort(infix_mngt(int, circuit1), j)) => (t2tb64(tb2t64(j)) = j)));

t2tb65: ((ARRAY circuit OF (ARRAY INT OF circuit))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY circuit OF (ARRAY INT OF circuit))): (sort(
  infix_mngt(circuit1, infix_mngt(int, circuit1)), t2tb65(x))));

tb2t65: (uni) -> (ARRAY circuit OF (ARRAY INT OF circuit));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY circuit OF (ARRAY INT OF circuit))):PATTERN (
  t2tb65(i)):  (tb2t65(t2tb65(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb65(tb2t65(j))): 
  ((sort(infix_mngt(circuit1, infix_mngt(int, circuit1)), j)) => (t2tb65(
  tb2t65(j)) = j)));

% ancilla_closure_def
  ASSERT
  (FORALL (y : circuit, y1 : INT): (tb2t62(infix_at(circuit1, int, infix_at(
  infix_mngt(int, circuit1), circuit1, t2tb65(ancilla_closure), t2tb62(y)), 
  t2tb5(y1))) = ancilla(y, y1)));

% ancilla_eq
  ASSERT
  (FORALL (c : circuit, cqt : circuit,
  path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
  ((FORALL (x : matrix_complex):
   ((is_a_ket_l(x, width(c))) => (path_sem(c, kronecker(x, ket(1, 0))) = 
   kronecker(tb2t18(infix_at(matrix(complex1), matrix(complex1), 
   t2tb19(path_sem_target), t2tb18(x))), ket(1, 0)))))
  => ((width(c) = width(cqt))
     => ((c = cqt) => (tb2t64(infix_at(infix_mngt(int, circuit1), circuit1, 
        t2tb65(ancilla_closure), t2tb62(c))) = tb2t64(infix_at(
        infix_mngt(int, circuit1), circuit1, t2tb65(ancilla_closure), 
        t2tb62(cqt))))))));

% parallel_eq
  ASSERT
  (FORALL (d : circuit, dqt : circuit, e : circuit, eqt : circuit):
  ((d = dqt) => ((e = eqt) => (parallel(d, e) = parallel(dqt, eqt)))));

fc995: (circuit, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, z : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc995(c, x)), t2tb26(z))) = infix_asdtdt(
  tb2t(get(complex1, t2tb18(x), bv_to_int(z), 0)), path_sem(c, 
  bv_to_ket(z)))));

% path_sem_decomp
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (path_sem(c, x) = ket_sum_l(bitvec1, t2tb28(
  n_bvs(width(c))), t2tb29(fc995(c, x)), width(c)))));

% path_sem_scal_
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : matrix_complex,
  sc : complex):
  ((is_a_ket_l(x, width(c)))
  => ((path_sem(c, x) = y) => (path_sem(c, infix_asdtdt(sc, x)) = 
     infix_asdtdt(sc, y)))));

% path_sem_scal
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, sc : complex):
  ((is_a_ket_l(x, width(c))) => (path_sem(c, infix_asdtdt(sc, x)) = 
  infix_asdtdt(sc, path_sem(c, x)))));

% path_sem_scal_rev
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, sc : complex):
  ((is_a_ket_l(x, width(c))) => (infix_asdtdt(sc, path_sem(c, x)) = 
  path_sem(c, infix_asdtdt(sc, x)))));

% path_sem_add
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, xqt : matrix_complex,
  y : matrix_complex, yqt : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_l(xqt, width(c)))
     => ((path_sem(c, x) = y)
        => ((path_sem(c, xqt) = yqt) => (path_sem(c, add_ket_l(x, xqt, 
           width(c))) = add_ket_l(y, yqt, width(c))))))));

% path_sem_add_
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, xqt : matrix_complex, l : INT):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_l(xqt, width(c)))
     => ((l = width(c)) => (path_sem(c, add_ket_l(x, xqt, l)) = add_ket_l(
        path_sem(c, x), path_sem(c, xqt), l))))));

% path_sem_scal_add_ket_l
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, xqt : matrix_complex,
  a : complex, aqt : complex, n : INT):
  ((width(c) = n)
  => ((is_a_ket_l(x, n))
     => ((is_a_ket_l(xqt, n)) => (path_sem(c, add_ket_l(infix_asdtdt(a, x), 
        infix_asdtdt(aqt, xqt), n)) = add_ket_l(infix_asdtdt(a, path_sem(c,
        x)), infix_asdtdt(aqt, path_sem(c, xqt)), n))))));

% path_sem_substr
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, xqt : matrix_complex,
  y : matrix_complex, yqt : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_l(xqt, width(c)))
     => ((path_sem(c, x) = y)
        => ((path_sem(c, xqt) = yqt) => (path_sem(c, mat_substr(x, xqt)) = 
           mat_substr(y, yqt)))))));

% path_sem_scal_add
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, xqt : matrix_complex,
  y : matrix_complex, yqt : matrix_complex, scal : complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_l(xqt, width(c)))
     => ((path_sem(c, x) = y)
        => ((path_sem(c, xqt) = yqt) => (path_sem(c, infix_asdtdt(scal, 
           add_ket_l(x, xqt, width(c)))) = infix_asdtdt(scal, add_ket_l(y,
           yqt, width(c)))))))));

fc996: (circuit, bitvec, INT) -> (ARRAY bitvec OF complex);

% fc'def
  ASSERT
  (FORALL (c : circuit, x : bitvec, i : INT, y : bitvec): (tb2t(
  infix_at(complex1, bitvec1, t2tb31(fc996(c, x, i)), t2tb26(y))) = 
  infix_asdt(ang_exp(ang_ind(c, value(x), value(y))), indic(bitvec1, t2tb26(
  make_bv(tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int))), circuit1, 
  t2tb63(basis_ket_closure), t2tb62(c)), t2tb7(value(x))), t2tb7(value(y)))), 
  width(c))), t2tb26(int_to_bv(i, width(c)))))));

% pat_sem_apply_basis_value
  ASSERT
  (FORALL (c : circuit, x : bitvec):
  ((length(x) = width(c))
  => (FORALL (i : INT):
     (((0 <= i) AND (i < power(2, width(c)))) => (tb2t(get(complex1, t2tb18(
     path_sem(c, bv_to_ket(x))), i, 0)) = infix_asdt(pow_inv_sqrt_2(
     range(c)), sum(bitvec1, t2tb28(n_bvs(range(c))), t2tb31(fc996(c, x,
     i)))))))));

% path_sem_scal_substr
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, xqt : matrix_complex,
  y : matrix_complex, yqt : matrix_complex, scal : complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_l(xqt, width(c)))
     => ((path_sem(c, x) = y)
        => ((path_sem(c, xqt) = yqt) => (path_sem(c, infix_asdtdt(scal, 
           mat_substr(x, xqt))) = infix_asdtdt(scal, mat_substr(y, yqt))))))));

% path_sem_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit, s2 : uni, f : uni, g : uni, n : INT):
  ((1 <= cardinal(a, s2))
  => ((n = width(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width(c))))))
        => ((FORALL (x : uni):
            ((sort(a, x))
            => ((mem(a, x, s2)) => (path_sem(c, tb2t18(infix_at(
               matrix(complex1), a, f, x))) = tb2t18(infix_at(
               matrix(complex1), a, g, x))))))
           => (path_sem(c, ket_sum_l(a, s2, f, n)) = ket_sum_l(a, s2, g, n))))))));

fc519: (circuit,
  (ARRAY bitvec OF complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit, f : (ARRAY bitvec OF complex), x : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc519(c, f)), t2tb26(x))) = 
  infix_asdtdt(tb2t(infix_at(complex1, bitvec1, t2tb31(f), t2tb26(x))), 
  path_sem(c, bv_to_ket(x)))));

% path_sem_sum_diag
  ASSERT
  (FORALL (c : circuit, s2 : set_bitvec, f : (ARRAY bitvec OF complex),
  l : INT):
  ((s2 = n_bvs(l))
  => ((l = width(c)) => (path_sem(c, ket_sum_l_diag(f, l)) = 
     ket_sum_l(bitvec1, t2tb28(s2), t2tb29(fc519(c, f)), l)))));

fc997: (ty, circuit, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : circuit, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc997(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit, f : uni, x : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc997(a, c, f), x)) = path_sem(c, tb2t18(infix_at(matrix(complex1), a,
  f, x))))));

% path_sem_sum_
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit, s2 : uni, f : uni, n : INT):
  ((1 <= cardinal(a, s2))
  => ((n = width(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width(c))))))
        => (path_sem(c, ket_sum_l(a, s2, f, n)) = ket_sum_l(a, s2, fc997(a,
        c, f), n)))))));

% path_sem_sum_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit, s2 : uni, f : uni, g : uni, n : INT):
  ((1 <= cardinal(a, s2))
  => ((n = width(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width(c))))))
        => ((FORALL (x : uni):
            ((sort(a, x))
            => ((mem(a, x, s2)) => (path_sem(c, tb2t18(infix_at(
               matrix(complex1), a, f, x))) = tb2t18(infix_at(
               matrix(complex1), a, g, x))))))
           => (path_sem(c, ket_sum_l(a, s2, f, n)) = ket_sum_l(a, s2, g, n))))))));

% scal_path_sem_sum_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit, s2 : uni, f : uni, g : uni, n : INT, nqt : INT,
  a1 : complex, b : complex):
  ((1 <= cardinal(a, s2))
  => ((n = width(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width(c))))))
        => ((FORALL (x : uni):
            ((sort(a, x))
            => ((mem(a, x, s2)) => (path_sem(c, tb2t18(infix_at(
               matrix(complex1), a, f, x))) = tb2t18(infix_at(
               matrix(complex1), a, g, x))))))
           => ((a1 = b)
              => ((n = nqt) => (infix_asdtdt(a1, path_sem(c, ket_sum_l(a, s2,
                 f, n))) = infix_asdtdt(b, ket_sum_l(a, s2, g, nqt)))))))))));

fc998: (ty, circuit, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : circuit, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc998(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit, f : uni, x : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc998(a, c, f), x)) = path_sem(c, tb2t18(infix_at(matrix(complex1), a,
  f, x))))));

% scal_path_sem_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit, s2 : uni, f : uni, n : INT, a1 : complex):
  ((1 <= cardinal(a, s2))
  => ((n = width(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width(c))))))
        => (infix_asdtdt(a1, path_sem(c, ket_sum_l(a, s2, f, n))) = 
        infix_asdtdt(a1, ket_sum_l(a, s2, fc998(a, c, f), n))))))));

fc999: (ty, circuit, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : circuit, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc999(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit, f : uni, x : uni): (tb2t18(infix_at(matrix(complex1),
  a, fc999(a, c, f), x)) = path_sem(c, tb2t18(infix_at(matrix(complex1), a,
  f, x))))));

% path_sem_scal_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit, s2 : uni, f : uni, n : INT, a1 : complex):
  ((1 <= cardinal(a, s2))
  => ((n = width(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width(c))))))
        => (path_sem(c, infix_asdtdt(a1, ket_sum_l(a, s2, f, n))) = 
        infix_asdtdt(a1, ket_sum_l(a, s2, fc999(a, c, f), n))))))));

% path_sem_comp_basis
  ASSERT
  (FORALL (d : circuit, e : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(d)))
  => ((is_a_ket_basis_elt(x))
     => ((width(d) = width(e)) => (path_sem_basis(sequence(d, e), x) = 
        path_sem(e, path_sem_basis(d, x)))))));

% path_sem_comp_pre
  ASSERT
  (FORALL (d : circuit, e : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(d)))
  => ((width(d) = width(e)) => (path_sem(sequence(d, e), x) = path_sem(e, 
     path_sem(d, x))))));

% path_sem_comp
  ASSERT
  (FORALL (d : circuit, e : circuit, x : matrix_complex, y : matrix_complex,
  z : matrix_complex):
  ((is_a_ket_l(x, width(d)))
  => ((path_sem(d, x) = y)
     => ((path_sem(e, y) = z)
        => ((width(d) = width(e)) => (path_sem(sequence(d, e), x) = z))))));

% path_sem_comp_
  ASSERT
  (FORALL (d : circuit, e : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(d)))
  => ((width(d) = width(e)) => (path_sem(sequence(d, e), x) = path_sem(e, 
     path_sem(d, x))))));

% sem_comp
  ASSERT
  (FORALL (d : circuit, e : circuit, x : matrix_complex, y : matrix_complex,
  z : matrix_complex):
  ((sem(d, x, y))
  => ((sem(e, y, z))
     => ((width(d) = width(e)) => (sem(sequence(d, e), x, z))))));

% path_sem_kron_basis
  ASSERT
  (FORALL (d : circuit, e : circuit, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width(d)))
  => ((is_a_ket_l(y, width(e)))
     => ((is_a_ket_basis_elt(x))
        => ((is_a_ket_basis_elt(y)) => (path_sem_basis(parallel(d, e), 
           kronecker(x, y)) = kronecker(path_sem_basis(d, x), 
           path_sem_basis(e, y))))))));

% path_sem_kron_pre
  ASSERT
  (FORALL (d : circuit, e : circuit, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width(d)))
  => ((is_a_ket_l(y, width(e))) => (path_sem(parallel(d, e), kronecker(x,
     y)) = kronecker(path_sem(d, x), path_sem(e, y))))));

% path_sem_kron
  ASSERT
  (FORALL (d : circuit, e : circuit, x : matrix_complex,
  xqt : matrix_complex, y : matrix_complex, yqt : matrix_complex):
  ((is_a_ket_l(x, width(d)))
  => ((is_a_ket_l(y, width(e)))
     => ((path_sem(d, x) = xqt)
        => ((path_sem(e, y) = yqt) => (path_sem(parallel(d, e), kronecker(x,
           y)) = kronecker(xqt, yqt)))))));

% path_sem_kron_
  ASSERT
  (FORALL (d : circuit, e : circuit, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width(d)))
  => ((is_a_ket_l(y, width(e))) => (path_sem(parallel(d, e), kronecker(x,
     y)) = kronecker(path_sem(d, x), path_sem(e, y))))));

% path_sem_sequence_parallel_basis
  ASSERT
  (FORALL (a : circuit, b : circuit, d : circuit, e : circuit,
  x : matrix_complex):
  ((is_a_ket_l(x, (width(a) + width(b))))
  => ((width(a) = width(d))
     => ((width(b) = width(e))
        => ((is_a_ket_basis_elt(x)) => (path_sem(sequence(parallel(a, b), 
           parallel(d, e)), x) = path_sem(parallel(sequence(a, d), 
           sequence(b, e)), x)))))));

% path_sem_sequence_parallel
  ASSERT
  (FORALL (a : circuit, b : circuit, d : circuit, e : circuit,
  x : matrix_complex):
  ((is_a_ket_l(x, (width(a) + width(b))))
  => ((width(a) = width(d))
     => ((width(b) = width(e)) => (path_sem(sequence(parallel(a, b), 
        parallel(d, e)), x) = path_sem(parallel(sequence(a, d), sequence(b,
        e)), x))))));

% path_sem_id_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis(id, x) = x))));

% path_sem_id
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem(id, x) = x)));

% path_sem_phase_basis
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => (path_sem(phase(k), x) = infix_asdtdt(
     ang_exp(infix_sldtsl(1, k)), x)))));

% path_sem_phase_basis_inv
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => (path_sem(phase(k), path_sem(phase((- k)),
     x)) = x))));

% path_sem_phase_inv
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem(phase(k), path_sem(phase((- k)), x)) = x)));

% path_sem_rz_basis
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => (path_sem(rz(k), x) = infix_asdtdt(ang_exp(
     infix_sldtsl((value(ket_to_bv(x))[0]), k)), x)))));

% path_sem_rz_basis_inv
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => (path_sem(rz(k), path_sem(rz((- k)),
     x)) = x))));

% path_sem_rz_inv
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem(rz(k), path_sem(rz((- k)), x)) = x)));

% qbit_zero'spec
  ASSERT
  ((tb2t(get(complex1, t2tb18(ket(1, 0)), 0, 0)) = c_one)
  AND ((tb2t(get(complex1, t2tb18(ket(1, 0)), 1, 0)) = c_zero)
      AND ((is_a_ket_l(ket(1, 0), 1))
          AND ((rows(complex1, t2tb18(ket(1, 0))) = 2)
              AND ((columns(complex1, t2tb18(ket(1, 0))) = 1)
                  AND ((tb2t(get(complex1, t2tb18(ket(1, 0)), 0, 0)) = c_one)
                      AND ((tb2t(get(complex1, t2tb18(ket(1, 0)), 1,
                          0)) = c_zero) AND (is_a_ket_basis_elt(ket(1, 0))))))))));

% qbit_one'spec
  ASSERT
  ((tb2t(get(complex1, t2tb18(ket(1, 1)), 0, 0)) = c_zero)
  AND ((tb2t(get(complex1, t2tb18(ket(1, 1)), 1, 0)) = c_one)
      AND ((is_a_ket_l(ket(1, 1), 1))
          AND ((rows(complex1, t2tb18(ket(1, 1))) = 2)
              AND ((columns(complex1, t2tb18(ket(1, 1))) = 1)
                  AND ((tb2t(get(complex1, t2tb18(ket(1, 1)), 0,
                      0)) = c_zero)
                      AND ((tb2t(get(complex1, t2tb18(ket(1, 1)), 1,
                          0)) = c_one) AND (is_a_ket_basis_elt(ket(1, 1))))))))));

% get_ket_one
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => ((NOT (x = ket(1, 0))) => (x = ket(1, 1))))));

% get_ket_zero
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => ((NOT (x = ket(1, 1))) => (x = ket(1, 0))))));

% get_ket_one_decomp_z
  ASSERT
  (FORALL (a : complex, b : complex): (tb2t(get(complex1, t2tb18(add_ket_l(
  infix_asdtdt(a, ket(1, 0)), infix_asdtdt(b, ket(1, 1)), 1)), 0, 0)) = a));

% get_ket_one_decomp_o
  ASSERT
  (FORALL (a : complex, b : complex): (tb2t(get(complex1, t2tb18(add_ket_l(
  infix_asdtdt(a, ket(1, 0)), infix_asdtdt(b, ket(1, 1)), 1)), 1, 0)) = b));

% zero_to_bv
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT):
  (((f[0]) = 0) => ((l = 1) => (ket(1, 0) = bv_to_ket(make_bv(f, l))))));

% one_to_bv
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT):
  (((f[0]) = 1) => ((l = 1) => (ket(1, 1) = bv_to_ket(make_bv(f, l))))));

% bv_to_zero
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT):
  (((f[0]) = 0) => ((l = 1) => (bv_to_ket(make_bv(f, l)) = ket(1, 0)))));

% bv_to_one
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), l : INT):
  (((f[0]) = 1) => ((l = 1) => (bv_to_ket(make_bv(f, l)) = ket(1, 1)))));

% qbit_plus'spec
  ASSERT
  ((pps_apply(pps_hadamard, ket(1, 0)) = infix_asdtdt(pow_inv_sqrt_2(1), 
  add_ket_l(ket(1, 0), ket(1, 1), 1)))
  AND ((is_a_ket_l(pps_apply(pps_hadamard, ket(1, 0)), 1))
      AND ((rows(complex1, t2tb18(pps_apply(pps_hadamard, ket(1, 0)))) = 2)
          AND ((columns(complex1, t2tb18(pps_apply(pps_hadamard, ket(1,
              0)))) = 1)
              AND ((tb2t(get(complex1, t2tb18(pps_apply(pps_hadamard, ket(1,
                  0))), 0, 0)) = pow_inv_sqrt_2(1)) AND (tb2t(get(complex1, 
                  t2tb18(pps_apply(pps_hadamard, ket(1, 0))), 1, 0)) = 
                  pow_inv_sqrt_2(1)))))));

% qbit_minus'spec
  ASSERT
  ((pps_apply(pps_hadamard, ket(1, 1)) = infix_asdtdt(pow_inv_sqrt_2(1), 
  add_ket_l(ket(1, 0), infix_asdtdt(prefix_mndt(c_one), ket(1, 1)), 1)))
  AND ((is_a_ket_l(pps_apply(pps_hadamard, ket(1, 1)), 1))
      AND ((rows(complex1, t2tb18(pps_apply(pps_hadamard, ket(1, 1)))) = 2)
          AND ((columns(complex1, t2tb18(pps_apply(pps_hadamard, ket(1,
              1)))) = 1)
              AND ((tb2t(get(complex1, t2tb18(pps_apply(pps_hadamard, ket(1,
                  1))), 0, 0)) = pow_inv_sqrt_2(1)) AND (tb2t(get(complex1, 
                  t2tb18(pps_apply(pps_hadamard, ket(1, 1))), 1, 0)) = 
                  prefix_mndt(pow_inv_sqrt_2(1))))))));

% add_plus_minus
  ASSERT
  ((add_ket_l(pps_apply(pps_hadamard, ket(1, 0)), pps_apply(pps_hadamard, 
  ket(1, 1)), 1) = infix_asdtdt(square_rt(infix_pldt(c_one, c_one)), ket(1,
  0))) AND (add_ket_l(infix_asdtdt(pow_inv_sqrt_2(1), pps_apply(pps_hadamard, 
  ket(1, 0))), infix_asdtdt(pow_inv_sqrt_2(1), pps_apply(pps_hadamard, ket(1,
  1))), 1) = ket(1, 0)));

% substr_plus_minus
  ASSERT
  ((add_ket_l(pps_apply(pps_hadamard, ket(1, 0)), infix_asdtdt(
  prefix_mndt(c_one), pps_apply(pps_hadamard, ket(1, 1))), 1) = infix_asdtdt(
  square_rt(infix_pldt(c_one, c_one)), ket(1, 1))) AND (add_ket_l(
  infix_asdtdt(pow_inv_sqrt_2(1), pps_apply(pps_hadamard, ket(1, 0))), 
  infix_asdtdt(prefix_mndt(pow_inv_sqrt_2(1)), pps_apply(pps_hadamard, ket(1,
  1))), 1) = ket(1, 1)));

% plus_to_zero
  ASSERT (pps_apply(pps_hadamard, pps_apply(pps_hadamard, ket(1, 0))) = 
  ket(1, 0));

% plus_to_one
  ASSERT (pps_apply(pps_hadamard, pps_apply(pps_hadamard, ket(1, 1))) = 
  ket(1, 1));

% hadamard_comp
  ASSERT
  (FORALL (x : bitvec):
  ((length(x) = 1) => (pps_apply(pps_hadamard, pps_apply(pps_hadamard, 
  bv_to_ket(x))) = bv_to_ket(x))));

% set_equal_qbit
  ASSERT
  (FORALL (a : matrix_complex, b : matrix_complex):
  ((is_a_ket_l(a, 1))
  => ((is_a_ket_l(b, 1))
     => ((tb2t(get(complex1, t2tb18(a), 0, 0)) = tb2t(get(complex1, 
        t2tb18(b), 0, 0)))
        => ((tb2t(get(complex1, t2tb18(a), 1, 0)) = tb2t(get(complex1, 
           t2tb18(b), 1, 0))) => (a = b))))));

xor_qbits: (matrix_complex, matrix_complex) -> matrix_complex;

result126: (matrix_complex, matrix_complex) -> (ARRAY INT OF complex);

% result'def
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex, i : INT): (tb2t(
  infix_at(complex1, int, t2tb12(result126(x, y)), 
  t2tb5(i))) = (IF (i = 0) THEN infix_pldt(infix_asdt(tb2t(get(complex1, 
               t2tb18(x), 0, 0)), tb2t(get(complex1, t2tb18(y), 0, 0))), 
               infix_asdt(tb2t(get(complex1, t2tb18(x), 1, 0)), tb2t(
               get(complex1, t2tb18(y), 1, 0)))) ELSE infix_pldt(infix_asdt(
               tb2t(get(complex1, t2tb18(x), 0, 0)), tb2t(get(complex1, 
               t2tb18(y), 1, 0))), infix_asdt(tb2t(get(complex1, t2tb18(x),
               1, 0)), tb2t(get(complex1, t2tb18(y), 0, 0)))) ENDIF)));

% xor_qbits'def
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_l(y, 1)) => (xor_qbits(x, y) = make_ket(1, result126(x, y))))));

% xor_qbits'spec
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_l(y, 1))
     => ((is_a_ket_l(xor_qbits(x, y), 1))
        AND (((is_a_ket_basis_elt(x))
             => ((is_a_ket_basis_elt(y)) => (xor_qbits(x, y) = ket(1, xor_i(
                ket_to_int(x), ket_to_int(y))))))
            AND ((tb2t(get(complex1, t2tb18(xor_qbits(x, y)), 0, 0)) = 
                infix_pldt(infix_asdt(tb2t(get(complex1, t2tb18(x), 0, 0)), 
                tb2t(get(complex1, t2tb18(y), 0, 0))), infix_asdt(tb2t(
                get(complex1, t2tb18(x), 1, 0)), tb2t(get(complex1, 
                t2tb18(y), 1, 0))))) AND (tb2t(get(complex1, t2tb18(
                xor_qbits(x, y)), 1, 0)) = infix_pldt(infix_asdt(tb2t(
                get(complex1, t2tb18(x), 0, 0)), tb2t(get(complex1, 
                t2tb18(y), 1, 0))), infix_asdt(tb2t(get(complex1, t2tb18(x),
                1, 0)), tb2t(get(complex1, t2tb18(y), 0, 0)))))))))));

% xor_int_to_ket
  ASSERT
  (FORALL (x : matrix_complex, i : INT):
  ((is_a_ket_l(x, 1)) => (is_a_ket_l(xor_qbits(ket(1, i), x), 1))));

% xor_qbit_minus
  ASSERT
  (FORALL (i : INT):
  (((0 <= i) AND (i < 2)) => (xor_qbits(ket(1, i), pps_apply(pps_hadamard, 
  ket(1, 1))) = infix_asdtdt(cpower(prefix_mndt(c_one), i), 
  pps_apply(pps_hadamard, ket(1, 1))))));

fc1000: (ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni): (sort(infix_mngt(a, matrix(complex1)), fc1000(a, x)))));

fc1001: (ty, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : uni): (sort(infix_mngt(a, matrix(complex1)), fc1001(a, x)))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), e : INT): (tb2t18(infix_at(
  matrix(complex1), int, fc1000(int, t2tb7(f)), t2tb5(e))) = xor_qbits(ket(1,
  (f[e])), pps_apply(pps_hadamard, ket(1, 1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, e : uni): (tb2t18(infix_at(matrix(complex1), a, fc1000(a,
  f), e)) = xor_qbits(ket(1, tb2t5(infix_at(int, a, f, e))), 
  pps_apply(pps_hadamard, ket(1, 1))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), e : INT): (tb2t18(infix_at(
  matrix(complex1), int, fc1001(int, t2tb7(f)), t2tb5(e))) = infix_asdtdt(
  cpower(prefix_mndt(c_one), (f[e])), pps_apply(pps_hadamard, ket(1, 1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (f : uni, e : uni): (tb2t18(infix_at(matrix(complex1), a, fc1001(a,
  f), e)) = infix_asdtdt(cpower(prefix_mndt(c_one), tb2t5(infix_at(int, a, f,
  e))), pps_apply(pps_hadamard, ket(1, 1))))));

% ket_sum_xor_qbit_minus
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT)):
  ((FORALL (e : INT):
   ((mem(int, t2tb5(e), t2tb6(s2))) => ((0 <= (f[e])) AND ((f[e]) < 2))))
  => (ket_sum_l(int, t2tb6(s2), fc1000(int, t2tb7(f)), 1) = ket_sum_l(int, 
  t2tb6(s2), fc1001(int, t2tb7(f)), 1))));

% ket_sum_xor_qbit_minus
  ASSERT
  (FORALL (a : ty):
  (FORALL (s2 : uni, f : uni):
  ((FORALL (e : uni):
   ((sort(a, e))
   => ((mem(a, e, s2))
      => ((0 <= tb2t5(infix_at(int, a, f, e))) AND (tb2t5(infix_at(int, a, f,
         e)) < 2)))))
  => (ket_sum_l(a, s2, fc1000(a, f), 1) = ket_sum_l(a, s2, fc1001(a, f), 1)))));

fc1002: ((ARRAY bitvec OF INT)) -> (ARRAY bitvec OF matrix_complex);

fc1003: ((ARRAY bitvec OF INT)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF INT), x : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1002(f)), t2tb26(x))) = infix_asdtdt(
  cpower(prefix_mndt(c_one), tb2t5(infix_at(int, bitvec1, t2tb30(f), 
  t2tb26(x)))), bv_to_ket(x))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF INT), e : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1003(f)), t2tb26(e))) = kronecker(
  bv_to_ket(e), xor_qbits(ket(1, tb2t5(infix_at(int, bitvec1, t2tb30(f), 
  t2tb26(e)))), pps_apply(pps_hadamard, ket(1, 1))))));

% superposition_xor_qbit_minus
  ASSERT
  (FORALL (f : (ARRAY bitvec OF INT), n : INT):
  ((FORALL (e : bitvec):
   ((length(e) = n)
   => ((0 <= tb2t5(infix_at(int, bitvec1, t2tb30(f), t2tb26(e)))) AND (tb2t5(
      infix_at(int, bitvec1, t2tb30(f), t2tb26(e))) < 2))))
  => ((0 <= n) => (kronecker(infix_asdtdt(pow_inv_sqrt_2(n), 
     ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc1002(f)), n)), 
     pps_apply(pps_hadamard, ket(1, 1))) = infix_asdtdt(pow_inv_sqrt_2(n), 
     ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc1003(f)), (n + 1)))))));

fc1004: (INT, bitvec) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (n : INT, y : bitvec, i : INT): ((fc1004(n, y)[i]) = 
  infix_sldtsl(((value(ket_to_bv(ket(n, 0)))[i]) * (value(y)[i])), 1)));

% sum_ket_zero
  ASSERT
  (FORALL (n : INT):
  ((0 <= n)
  => (FORALL (y : bitvec): (ang_sum(fc1004(n, y), 0, n) = ang_zero))));

repeat_pps_had: (INT) -> pps;

% repeat_pps_had'def
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => (IF (n = 1) THEN (repeat_pps_had(n) = pps_hadamard) ELSE (
     repeat_pps_had(n) = pps_par(repeat_pps_had((n - 1)),
     pps_hadamard)) ENDIF)));

fc1005: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT): ((
  fc1005(x, y)[i]) = infix_sldtsl(((x[i]) * (y[i])), 1)));

% repeat_pps_had'spec
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => ((h_width(repeat_pps_had(n)) = n)
     AND ((h_range(repeat_pps_had(n)) = n)
         AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
              (FORALL (i : INT):
              (((0 <= i) AND (i < n)) => ((tb2t7(infix_at(infix_mngt(int,
              int), infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
              int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
              h_basis_ket(repeat_pps_had(n))), t2tb7(x)), 
              t2tb7(y)))[i]) = (y[i])))))
             AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
                 tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                 infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                 int), t2tb57(h_angle(repeat_pps_had(n))), t2tb7(x)), 
                 t2tb7(y))) = ang_sum(fc1005(x, y), 0, n))))))));

kron_had_coeffs: (INT, INT, INT) -> complex;

result127: (INT, INT, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (n : INT, i : INT, j : INT, k : INT): ((result127(n, i, j)[k]) = ((
  value(int_to_bv(i, n))[k]) * (value(int_to_bv(j, n))[k]))));

% kron_had_coeffs'def
  ASSERT
  (FORALL (n : INT, i : INT, j : INT):
  ((0 <= n) => (kron_had_coeffs(n, i, j) = infix_asdt(pow_inv_sqrt_2(n), 
  cpower(prefix_mndt(c_one), ind_isum(result127(n, i, j), 0, n))))));

superposition_state: (INT) -> matrix_complex;

% superposition_state'def
  ASSERT
  (FORALL (n : INT):
  ((1 <= n) => (superposition_state(n) = pps_apply(repeat_pps_had(n), ket(n,
  0)))));

bv_to_ket_closure: (ARRAY bitvec OF matrix_complex);

ket_closure: (ARRAY INT OF (ARRAY INT OF matrix_complex));

% bv_to_ket_closure_def
  ASSERT
  (FORALL (y : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, 
  t2tb29(bv_to_ket_closure), t2tb26(y))) = bv_to_ket(y)));

% ket_closure_def
  ASSERT
  (FORALL (y : INT, y1 : INT): (tb2t18(infix_at(matrix(complex1), int, 
  infix_at(infix_mngt(int, matrix(complex1)), int, t2tb46(ket_closure), 
  t2tb5(y)), t2tb5(y1))) = ket(y, y1)));

% superposition_state'spec
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => ((superposition_state(n) = infix_asdtdt(pow_inv_sqrt_2(n), 
     ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(bv_to_ket_closure), n)))
     AND ((superposition_state(n) = infix_asdtdt(pow_inv_sqrt_2(n), 
         ket_sum_l(int, t2tb6(to_fset(0, power(2, n))), infix_at(
         infix_mngt(int, matrix(complex1)), int, t2tb46(ket_closure), 
         t2tb5(n)), n))) AND (is_a_ket_l(superposition_state(n), n))))));

% get_ket_superposition
  ASSERT
  (FORALL (n : INT, i : INT):
  ((1 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (tb2t(get(complex1, t2tb18(
     superposition_state(n)), i, 0)) = infix_sldt(c_one, square_rt(i_to_c(
     power(2, n))))))));

% repeat_had_twice_bv
  ASSERT
  (FORALL (n : INT, x : bitvec):
  ((1 <= n)
  => ((length(x) = n) => (pps_apply(repeat_pps_had(n), pps_apply(
     repeat_pps_had(n), bv_to_ket(x))) = bv_to_ket(x)))));

% repeat_had_twice_bv_gen
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => (FORALL (x : bitvec):
     ((length(x) = n) => (pps_apply(repeat_pps_had(n), pps_apply(
     repeat_pps_had(n), bv_to_ket(x))) = bv_to_ket(x))))));

% repeat_had_twice_ket
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, n)) => (pps_apply(repeat_pps_had(n), pps_apply(
     repeat_pps_had(n), x)) = x)))));

fc1006: (bitvec, bitvec) -> (ARRAY INT OF INT);

fc1007: (INT, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (x : bitvec, y : bitvec, k : INT): ((fc1006(x, y)[k]) = ((
  value(x)[k]) * (value(y)[k]))));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1007(n, x)), t2tb26(y))) = 
  infix_asdtdt(cpower(prefix_mndt(c_one), ind_isum(fc1006(x, y), 0, n)), 
  bv_to_ket(y))));

% repeat_pps_had_basis_bv
  ASSERT
  (FORALL (n : INT, x : bitvec):
  ((1 <= n)
  => ((length(x) = n) => (pps_apply(repeat_pps_had(n), bv_to_ket(x)) = 
     infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(n_bvs(n)), 
     t2tb29(fc1007(n, x)), n))))));

fc1008: (INT, INT, bitvec) -> (ARRAY INT OF INT);

fc1009: (INT, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, i : INT, y : bitvec, k : INT): ((fc1008(n, i, y)[k]) = ((
  value(int_to_bv(i, n))[k]) * (value(y)[k]))));

% fc'def
  ASSERT
  (FORALL (n : INT, i : INT, y : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(fc1009(n, i)), t2tb26(y))) = infix_asdtdt(cpower(
  prefix_mndt(c_one), ind_isum(fc1008(n, i, y), 0, n)), bv_to_ket(y))));

% repeat_pps_had_basis
  ASSERT
  (FORALL (n : INT, i : INT):
  ((1 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (pps_apply(repeat_pps_had(n), 
     ket(n, i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(
     n_bvs(n)), t2tb29(fc1009(n, i)), n))))));

% repeat_had_superposition
  ASSERT
  (FORALL (n : INT):
  ((1 <= n) => (pps_apply(repeat_pps_had(n), superposition_state(n)) = ket(n,
  0))));

% path_sem_repeat_at_zero_bv
  ASSERT
  (FORALL (n : INT, x : bitvec):
  ((1 <= n)
  => ((length(x) = n) => (tb2t(get(complex1, t2tb18(pps_apply(
     repeat_pps_had(n), bv_to_ket(x))), 0, 0)) = pow_inv_sqrt_2(n)))));

fc1010: (ARRAY matrix_complex OF (ARRAY INT OF complex));

% fc'def
  ASSERT
  (FORALL (y0 : matrix_complex, y1 : INT): (tb2t(infix_at(complex1, int, 
  infix_at(infix_mngt(int, complex1), matrix(complex1), t2tb50(fc1010), 
  t2tb18(y0)), t2tb5(y1))) = tb2t(get(complex1, t2tb18(y0), y1, 0))));

% path_sem_repeat_at_zero
  ASSERT
  (FORALL (n : INT, x : matrix_complex):
  ((1 <= n)
  => ((is_a_ket_l(x, n)) => (tb2t(get(complex1, t2tb18(pps_apply(
     repeat_pps_had(n), x)), 0, 0)) = infix_asdt(pow_inv_sqrt_2(n), ind_sum(
     tb2t12(infix_at(infix_mngt(int, complex1), matrix(complex1), 
     t2tb50(fc1010), t2tb18(x))), 0, power(2, n)))))));

fc1011: ((ARRAY bitvec OF (ARRAY bitvec OF INT)),
  bitvec) -> (ARRAY bitvec OF matrix_complex);

fc1012: ((ARRAY bitvec OF INT), (ARRAY bitvec OF (ARRAY bitvec OF INT)),
  INT) -> (ARRAY bitvec OF matrix_complex);

fc1013: ((ARRAY bitvec OF INT), (ARRAY bitvec OF (ARRAY bitvec OF INT)),
  bitvec) -> (ARRAY bitvec OF complex);

fc1014: ((ARRAY bitvec OF INT), (ARRAY bitvec OF (ARRAY bitvec OF INT)),
  INT) -> (ARRAY bitvec OF matrix_complex);

t2tb66: ((ARRAY bitvec OF (ARRAY bitvec OF INT))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY bitvec OF (ARRAY bitvec OF INT))): (sort(
  infix_mngt(bitvec1, infix_mngt(bitvec1, int)), t2tb66(x))));

tb2t66: (uni) -> (ARRAY bitvec OF (ARRAY bitvec OF INT));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY bitvec OF (ARRAY bitvec OF INT))):PATTERN (t2tb66(i)): 
  (tb2t66(t2tb66(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb66(tb2t66(j))):  (t2tb66(tb2t66(j)) = j));

% fc'def
  ASSERT
  (FORALL (g : (ARRAY bitvec OF (ARRAY bitvec OF INT)), x : bitvec,
  y : bitvec): (tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc1011(g,
  x)), t2tb26(y))) = infix_asdtdt(cpower(prefix_mndt(c_one), tb2t5(
  infix_at(int, bitvec1, infix_at(infix_mngt(bitvec1, int), bitvec1, 
  t2tb66(g), t2tb26(x)), t2tb26(y)))), bv_to_ket(y))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF INT),
  g : (ARRAY bitvec OF (ARRAY bitvec OF INT)), n : INT, x : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc1012(f, g, n)), t2tb26(x))) = 
  infix_asdtdt(cpower(prefix_mndt(c_one), tb2t5(infix_at(int, bitvec1, 
  t2tb30(f), t2tb26(x)))), ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(
  fc1011(g, x)), n))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF INT),
  g : (ARRAY bitvec OF (ARRAY bitvec OF INT)), y : bitvec, x : bitvec): (
  tb2t(infix_at(complex1, bitvec1, t2tb31(fc1013(f, g, y)), t2tb26(x))) = 
  cpower(prefix_mndt(c_one), (tb2t5(infix_at(int, bitvec1, infix_at(
  infix_mngt(bitvec1, int), bitvec1, t2tb66(g), t2tb26(x)), t2tb26(y))) + 
  tb2t5(infix_at(int, bitvec1, t2tb30(f), t2tb26(x)))))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY bitvec OF INT),
  g : (ARRAY bitvec OF (ARRAY bitvec OF INT)), n : INT, y : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc1014(f, g, n)), t2tb26(y))) = 
  infix_asdtdt(sum(bitvec1, t2tb28(n_bvs(n)), t2tb31(fc1013(f, g, y))), 
  bv_to_ket(y))));

% ket_sum_power_minus_one
  ASSERT
  (FORALL (f : (ARRAY bitvec OF INT),
  g : (ARRAY bitvec OF (ARRAY bitvec OF INT)), n : INT):
  ((0 <= n) => (ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc1012(f, g, n)),
  n) = ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc1014(f, g, n)), n))));

% path_sem_hadamard_zero
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = ket(1, 0)) => (path_sem(hadamard, x) = pps_apply(pps_hadamard, ket(1,
  0)))));

% path_sem_hadamard_one
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = ket(1, 1)) => (path_sem(hadamard, x) = pps_apply(pps_hadamard, ket(1,
  1)))));

% path_sem_hadamard_plus
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = pps_apply(pps_hadamard, ket(1, 0))) => (path_sem(hadamard, x) = 
  ket(1, 0))));

% path_sem_hadamard_minus
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = pps_apply(pps_hadamard, ket(1, 1))) => (path_sem(hadamard, x) = 
  ket(1, 1))));

% path_sem_cnot_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2))
  => ((is_a_ket_basis_elt(x)) => (path_sem(cnot,
     x) = (IF (ket_to_int(x) = 0) THEN ket(2, 0)
          ELSE (IF (ket_to_int(x) = 1) THEN ket(2, 1)
               ELSE (IF (ket_to_int(x) = 2) THEN ket(2, 3) ELSE ket(2,
                    2) ENDIF) ENDIF) ENDIF)))));

% path_sem_swap_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2))
  => ((is_a_ket_basis_elt(x)) => (path_sem(swap,
     x) = (IF (ket_to_int(x) = 0) THEN ket(2, 0)
          ELSE (IF (ket_to_int(x) = 1) THEN ket(2, 2)
               ELSE (IF (ket_to_int(x) = 2) THEN ket(2, 1) ELSE ket(2,
                    3) ENDIF) ENDIF) ENDIF)))));

% hadamard_invol
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem(hadamard, path_sem(hadamard, x)) = x)));

ancilla_g: (circuit, INT,
  (ARRAY matrix_complex OF matrix_complex)) -> circuit;

% ancilla_g'def
  ASSERT
  (FORALL (c : circuit, i : INT,
  path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width(c) - i))) => (path_sem(c, kronecker(x, ket(i,
         0))) = kronecker(tb2t18(infix_at(matrix(complex1), matrix(complex1), 
         t2tb19(path_sem_target), t2tb18(x))), ket(i, 0)))))
        => (ancilla_g(c, i, path_sem_target) = ancilla(c, i))))));

fc538: (circuit, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc539: (circuit, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c : circuit, i : INT, x : (ARRAY INT OF INT), k : INT): ((fc538(c,
  i, x)[k]) = (IF (k < (width(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (c : circuit, i : INT, x : (ARRAY INT OF INT), k : INT): ((fc539(c,
  i, x)[k]) = (IF (k < (width(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% ancilla_g'spec
  ASSERT
  (FORALL (c : circuit, i : INT,
  path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width(c) - i))) => (path_sem(c, kronecker(x, ket(i,
         0))) = kronecker(tb2t18(infix_at(matrix(complex1), matrix(complex1), 
         t2tb19(path_sem_target), t2tb18(x))), ket(i, 0)))))
        => ((ancillas(ancilla_g(c, i, path_sem_target)) = (ancillas(c) + i))
           AND ((size(ancilla_g(c, i, path_sem_target)) = size(c))
               AND ((range(ancilla_g(c, i, path_sem_target)) = range(c))
                   AND ((width(ancilla_g(c, i, path_sem_target)) = (
                       width(c) - i))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)):
                            (FORALL (ii : INT): (basis_ket(ancilla_g(c, i,
                            path_sem_target), x, y, ii) = basis_ket(c, 
                            fc538(c, i, x), y, ii))))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)): (ang_ind(
                                ancilla_g(c, i, path_sem_target), x, y) = 
                                ang_ind(c, fc539(c, i, x), y)))
                               AND ((FORALL (x : matrix_complex):
                                    ((is_a_ket_l(x, width(ancilla_g(c, i,
                                    path_sem_target)))) => (kronecker(
                                    path_sem(ancilla_g(c, i,
                                    path_sem_target), x), ket(i, 0)) = 
                                    path_sem(c, kronecker(x, ket(i, 0))))))
                                   AND (FORALL (x : matrix_complex):
                                       ((is_a_ket_l(x, width(ancilla_g(c, i,
                                       path_sem_target)))) => (path_sem(
                                       ancilla_g(c, i, path_sem_target),
                                       x) = tb2t18(infix_at(matrix(complex1), 
                                       matrix(complex1), 
                                       t2tb19(path_sem_target), t2tb18(x)))))))))))))))));

ancilla_spec: (circuit, INT, (ARRAY bitvec OF matrix_complex)) -> circuit;

result128: ((ARRAY bitvec OF matrix_complex),
  matrix_complex) -> (ARRAY bitvec OF matrix_complex);

result129: (circuit, INT,
  (ARRAY bitvec OF matrix_complex)) -> (ARRAY matrix_complex OF matrix_complex);

% result'def
  ASSERT
  (FORALL (path_sem_target : (ARRAY bitvec OF matrix_complex),
  z : matrix_complex, x : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(result128(path_sem_target, z)), t2tb26(x))) = infix_asdtdt(
  tb2t(get(complex1, t2tb18(z), bv_to_int(x), 0)), tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(path_sem_target), t2tb26(x))))));

% result'def
  ASSERT
  (FORALL (c : circuit, i : INT,
  path_sem_target : (ARRAY bitvec OF matrix_complex), z : matrix_complex): (
  tb2t18(infix_at(matrix(complex1), matrix(complex1), t2tb19(result129(c, i,
  path_sem_target)), 
  t2tb18(z))) = (IF (is_a_ket_l(z, (width(c) - i))) THEN ket_sum_l(bitvec1, 
                t2tb28(n_bvs((width(c) - i))), t2tb29(
                result128(path_sem_target, z)), (width(c) - i)) ELSE tb2t18(
                make(complex1, 1, 1, t2tb(c_one))) ENDIF)));

% ancilla_spec'def
  ASSERT
  (FORALL (c : circuit, i : INT,
  path_sem_target : (ARRAY bitvec OF matrix_complex)):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((FORALL (x : bitvec):
         ((length(x) = (width(c) - i)) => (path_sem(c, kronecker(
         bv_to_ket(x), ket(i, 0))) = kronecker(tb2t18(infix_at(
         matrix(complex1), bitvec1, t2tb29(path_sem_target), t2tb26(x))), 
         ket(i, 0)))))
        => (ancilla_spec(c, i, path_sem_target) = ancilla_g(c, i, 
        result129(c, i, path_sem_target)))))));

fc1015: (circuit, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1016: (circuit, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1017: ((ARRAY bitvec OF matrix_complex),
  matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit, i : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc1015(c, i, x)[k]) = (IF (k < (width(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (c : circuit, i : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc1016(c, i, x)[k]) = (IF (k < (width(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (path_sem_target : (ARRAY bitvec OF matrix_complex),
  z : matrix_complex, x : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(fc1017(path_sem_target, z)), t2tb26(x))) = infix_asdtdt(
  tb2t(get(complex1, t2tb18(z), bv_to_int(x), 0)), tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(path_sem_target), t2tb26(x))))));

% ancilla_spec'spec
  ASSERT
  (FORALL (c : circuit, i : INT,
  path_sem_target : (ARRAY bitvec OF matrix_complex)):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((FORALL (x : bitvec):
         ((length(x) = (width(c) - i)) => (path_sem(c, kronecker(
         bv_to_ket(x), ket(i, 0))) = kronecker(tb2t18(infix_at(
         matrix(complex1), bitvec1, t2tb29(path_sem_target), t2tb26(x))), 
         ket(i, 0)))))
        => ((ancillas(ancilla_spec(c, i, path_sem_target)) = (
           ancillas(c) + i))
           AND ((size(ancilla_spec(c, i, path_sem_target)) = size(c))
               AND ((range(ancilla_spec(c, i, path_sem_target)) = range(c))
                   AND ((width(ancilla_spec(c, i, path_sem_target)) = (
                       width(c) - i))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)):
                            (FORALL (ii : INT): (basis_ket(ancilla_spec(c, i,
                            path_sem_target), x, y, ii) = basis_ket(c, 
                            fc1015(c, i, x), y, ii))))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)): (ang_ind(
                                ancilla_spec(c, i, path_sem_target), x, y) = 
                                ang_ind(c, fc1016(c, i, x), y)))
                               AND ((FORALL (x : matrix_complex):
                                    ((is_a_ket_l(x, width(ancilla_spec(c, i,
                                    path_sem_target)))) => (kronecker(
                                    path_sem(ancilla_spec(c, i,
                                    path_sem_target), x), ket(i, 0)) = 
                                    path_sem(c, kronecker(x, ket(i, 0))))))
                                   AND (FORALL (z : matrix_complex):
                                       ((is_a_ket_l(z, width(ancilla_spec(c,
                                       i, path_sem_target)))) => (path_sem(
                                       ancilla_spec(c, i, path_sem_target),
                                       z) = ket_sum_l(bitvec1, t2tb28(n_bvs((
                                       width(c) - i))), t2tb29(
                                       fc1017(path_sem_target, z)), (
                                       width(c) - i))))))))))))))));

% mat_sem_seq
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e)) => (mat_sem(sequence(d, e)) = mat_mult(mat_sem(e), 
  mat_sem(d)))));

% mat_sem_par
  ASSERT
  (FORALL (d : circuit, e : circuit): (mat_sem(parallel(d, e)) = kronecker(
  mat_sem(d), mat_sem(e))));

% mat_sem_anc
  ASSERT
  (FORALL (c : circuit, mat_sem_target : matrix_complex, i : INT):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((rows(complex1, t2tb18(mat_sem_target)) = power(2, (width(c) - i)))
        => ((columns(complex1, t2tb18(mat_sem_target)) = power(2, (
           width(c) - i)))
           => ((FORALL (x : matrix_complex):
               ((is_a_ket_l(x, (width(c) - i))) => (mat_mult(mat_sem(c), 
               kronecker(x, ket(i, 0))) = kronecker(mat_mult(mat_sem_target,
               x), ket(i, 0)))))
              => (mat_sem(ancilla(c, i)) = mat_sem_target)))))));

% mat_sem_anc_
  ASSERT
  (FORALL (c : circuit, mat_sem_target : matrix_complex, i : INT):
  ((1 <= i)
  => ((rows(complex1, t2tb18(mat_sem_target)) = power(2, (width(c) - i)))
     => ((columns(complex1, t2tb18(mat_sem_target)) = power(2, (
        width(c) - i)))
        => (((i + 1) <= width(c))
           => ((FORALL (x : matrix_complex):
               ((is_a_ket_l(x, (width(c) - i)))
               => ((is_a_ket_basis_elt(x)) => (mat_mult(mat_sem(c), 
                  kronecker(x, ket(i, 0))) = kronecker(
                  mat_mult(mat_sem_target, x), ket(i, 0))))))
              => (mat_sem(ancilla(c, i)) = mat_sem_target)))))));

% mat_sem_id
  ASSERT (mat_sem(id) = tb2t18(make_f(complex1, 2, 2, indic_closure(int))));

correct_path_sum_basis: (circuit, pps, bitvec) -> BOOLEAN;

% correct_path_sum_basis'def
  ASSERT
  (FORALL (c : circuit, h : pps, x : bitvec):
  ((correct_path_sum_basis(c, h, x))
  <=> ((LET q1_ = h_width(h) IN ((length(x) = q1_) AND (q1_ = width(c))))
      AND (infix_eqeq(matrix(complex1), t2tb18(mat_mult(mat_sem(c), 
      bv_to_ket(x))), t2tb18(pps_apply_basis(h, x)))))));

correct_path_sum_: (circuit, pps) -> BOOLEAN;

% correct_path_sum_'def
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((correct_path_sum_(c, h))
  <=> ((h_width(h) = width(c))
      AND (FORALL (x : matrix_complex):
          ((is_a_ket_l(x, width(c))) => (pps_apply(h, x) = mat_mult(
          mat_sem(c), x)))))));

% set_correct_path_sum
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((h_width(h) = width(c))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width(c))) => (pps_apply(h, x) = mat_mult(mat_sem(c),
      x))))
     => (correct_path_sum_(c, h)))));

% get_correct_path_sum
  ASSERT
  (FORALL (c : circuit, h : pps, x : matrix_complex):
  ((h_width(h) = width(c))
  => ((is_a_ket_l(x, width(c)))
     => ((correct_path_sum_(c, h)) => (pps_apply(h, x) = mat_mult(mat_sem(c),
        x))))));

% get_correct_path_sum_path
  ASSERT
  (FORALL (c : circuit, h : pps, x : matrix_complex):
  ((h_width(h) = width(c))
  => ((is_a_ket_l(x, width(c)))
     => ((correct_path_sum_(c, h)) => (pps_apply(h, x) = path_sem(c, x))))));

% set_correct_path_sum_basis
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((h_width(h) = width(c))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width(c)))
      => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = mat_mult(mat_sem(c),
         x)))))
     => (correct_path_sum_(c, h)))));

% set_correct_pps
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((h_width(h) = width(c))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width(c)))
      => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = path_sem_basis(c,
         x)))))
     => (correct_path_sum_(c, h)))));

% set_correct_pps_
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((h_width(h) = width(c))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width(c)))
      => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = path_sem(c, x)))))
     => (correct_path_sum_(c, h)))));

fc1018: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1019: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1018(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1019(h,
  y)[k]) = (y[(k + h_range(h))])));

% correct_seq
  ASSERT
  (FORALL (c : circuit, cqt : circuit, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(cqt, hqt))
     => ((width(c) = width(cqt))
        => ((h_width(hqtqt) = width(c))
           => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                     infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqtqt)), t2tb7(x)), 
                     t2tb7(y))) = ang_add(tb2t33(infix_at(angle1, 
                     infix_mngt(int, int), infix_at(infix_mngt(
                     infix_mngt(int, int), angle1), infix_mngt(int, int), 
                     t2tb57(h_angle(h)), t2tb7(x)), t2tb7(y))), tb2t33(
                     infix_at(angle1, infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqt)), infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
                     t2tb7(y))), t2tb7(fc1018(h, y)))))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((0 <= i) AND (i < h_width(hqtqt))) => ((tb2t7(
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqtqt)), t2tb7(x)), 
                           t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int,
                           int), infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), 
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(h)), t2tb7(x)), t2tb7(y))), 
                           t2tb7(fc1019(h, y))))[i])))))))
                    => (correct_path_sum_(sequence(c, cqt), hqtqt))))))))));

seq_pps: (circuit, circuit, pps, pps, pps) -> circuit;

fc1020: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1021: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1020(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1021(h,
  y)[k]) = (y[(k + h_range(h))])));

% seq_pps'def
  ASSERT
  (FORALL (c : circuit, cqt : circuit, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(cqt, hqt))
     => ((width(c) = width(cqt))
        => ((h_width(hqtqt) = width(c))
           => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                     infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqtqt)), t2tb7(x)), 
                     t2tb7(y))) = ang_add(tb2t33(infix_at(angle1, 
                     infix_mngt(int, int), infix_at(infix_mngt(
                     infix_mngt(int, int), angle1), infix_mngt(int, int), 
                     t2tb57(h_angle(h)), t2tb7(x)), t2tb7(y))), tb2t33(
                     infix_at(angle1, infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqt)), infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
                     t2tb7(y))), t2tb7(fc1020(h, y)))))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((0 <= i) AND (i < h_width(hqtqt))) => ((tb2t7(
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqtqt)), t2tb7(x)), 
                           t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int,
                           int), infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), 
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(h)), t2tb7(x)), t2tb7(y))), 
                           t2tb7(fc1021(h, y))))[i])))))))
                    => (seq_pps(c, cqt, h, hqt, hqtqt) = sequence(c, cqt))))))))));

fc1022: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1023: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1022(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1023(h,
  y)[k]) = (y[(k + h_range(h))])));

% seq_pps'spec
  ASSERT
  (FORALL (c : circuit, cqt : circuit, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(cqt, hqt))
     => ((width(c) = width(cqt))
        => ((h_width(hqtqt) = width(c))
           => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                     infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqtqt)), t2tb7(x)), 
                     t2tb7(y))) = ang_add(tb2t33(infix_at(angle1, 
                     infix_mngt(int, int), infix_at(infix_mngt(
                     infix_mngt(int, int), angle1), infix_mngt(int, int), 
                     t2tb57(h_angle(h)), t2tb7(x)), t2tb7(y))), tb2t33(
                     infix_at(angle1, infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqt)), infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
                     t2tb7(y))), t2tb7(fc1022(h, y)))))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((0 <= i) AND (i < h_width(hqtqt))) => ((tb2t7(
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqtqt)), t2tb7(x)), 
                           t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int,
                           int), infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), 
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(h)), t2tb7(x)), t2tb7(y))), 
                           t2tb7(fc1023(h, y))))[i])))))))
                    => ((width(seq_pps(c, cqt, h, hqt, hqtqt)) = width(c))
                       AND ((size(seq_pps(c, cqt, h, hqt, hqtqt)) = (
                           size(c) + size(cqt)))
                           AND ((ancillas(seq_pps(c, cqt, h, hqt, hqtqt)) = 
                               max(ancillas(c), ancillas(cqt)))
                               AND ((correct_path_sum_(seq_pps(c, cqt, h,
                                   hqt, hqtqt), hqtqt)) AND (seq_pps(c, cqt,
                                   h, hqt, hqtqt) = sequence(c, cqt))))))))))))));

fc1024: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1025: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1026: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1027: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1024(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1025(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1026(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1027(h,
  y)[k]) = (y[(k + h_range(h))])));

% correct_par
  ASSERT
  (FORALL (c : circuit, cqt : circuit, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(cqt, hqt))
     => ((h_width(hqtqt) = (width(c) + width(cqt)))
        => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((FORALL (j : INT):
                (((0 <= j) AND (j < h_width(hqtqt)))
                => ((0 <= (x[j])) AND ((x[j]) < 2))))
               => ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_range(hqtqt)))
                   => ((0 <= (y[j])) AND ((y[j]) < 2))))
                  => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                  int), t2tb57(h_angle(hqtqt)), t2tb7(x)), t2tb7(y))) = 
                  ang_add(tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(x)), 
                  t2tb7(y))), tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(hqt)), t2tb7(fc1024(h,
                  x))), t2tb7(fc1025(h, y)))))))))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  (FORALL (i : INT):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (((0 <= i) AND (i < h_width(h))) => ((tb2t7(infix_at(
                        infix_mngt(int, int), infix_mngt(int, int), infix_at(
                        infix_mngt(infix_mngt(int, int), infix_mngt(int,
                        int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(hqtqt)), t2tb7(x)), t2tb7(y)))[i]) = (
                        tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h)), t2tb7(x)), t2tb7(y)))[i])))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((h_width(h) <= i) AND (i < h_width(hqtqt)))
                           => ((tb2t7(infix_at(infix_mngt(int, int), 
                           infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqtqt)), 
                           t2tb7(x)), t2tb7(y)))[i]) = (tb2t7(infix_at(
                           infix_mngt(int, int), infix_mngt(int, int), 
                           infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqt)), t2tb7(fc1026(h, x))), 
                           t2tb7(fc1027(h, y))))[(i - h_width(h))])))))))
                    => (correct_path_sum_(parallel(c, cqt), hqtqt))))))))));

sequence_ghost_pps: (circuit, circuit, pps, pps, pps) -> circuit;

fc1028: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1029: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1028(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1029(h,
  y)[k]) = (y[(k + h_range(h))])));

% sequence_ghost_pps'def
  ASSERT
  (FORALL (c : circuit, cqt : circuit, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(cqt, hqt))
     => ((width(c) = width(cqt))
        => ((h_width(hqtqt) = width(c))
           => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                     infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqtqt)), t2tb7(x)), 
                     t2tb7(y))) = ang_add(tb2t33(infix_at(angle1, 
                     infix_mngt(int, int), infix_at(infix_mngt(
                     infix_mngt(int, int), angle1), infix_mngt(int, int), 
                     t2tb57(h_angle(h)), t2tb7(x)), t2tb7(y))), tb2t33(
                     infix_at(angle1, infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqt)), infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
                     t2tb7(y))), t2tb7(fc1028(h, y)))))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((0 <= i) AND (i < h_width(hqtqt))) => ((tb2t7(
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqtqt)), t2tb7(x)), 
                           t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int,
                           int), infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), 
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(h)), t2tb7(x)), t2tb7(y))), 
                           t2tb7(fc1029(h, y))))[i])))))))
                    => (sequence_ghost_pps(c, cqt, h, hqt, hqtqt) = 
                    sequence(c, cqt))))))))));

fc1030: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1031: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1030(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1031(h,
  y)[k]) = (y[(k + h_range(h))])));

% sequence_ghost_pps'spec
  ASSERT
  (FORALL (c : circuit, cqt : circuit, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(cqt, hqt))
     => ((width(c) = width(cqt))
        => ((h_width(hqtqt) = width(c))
           => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                     infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqtqt)), t2tb7(x)), 
                     t2tb7(y))) = ang_add(tb2t33(infix_at(angle1, 
                     infix_mngt(int, int), infix_at(infix_mngt(
                     infix_mngt(int, int), angle1), infix_mngt(int, int), 
                     t2tb57(h_angle(h)), t2tb7(x)), t2tb7(y))), tb2t33(
                     infix_at(angle1, infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqt)), infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
                     t2tb7(y))), t2tb7(fc1030(h, y)))))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((0 <= i) AND (i < h_width(hqtqt))) => ((tb2t7(
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqtqt)), t2tb7(x)), 
                           t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int,
                           int), infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), 
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(h)), t2tb7(x)), t2tb7(y))), 
                           t2tb7(fc1031(h, y))))[i])))))))
                    => ((width(sequence_ghost_pps(c, cqt, h, hqt, hqtqt)) = 
                       width(c))
                       AND ((size(sequence_ghost_pps(c, cqt, h, hqt,
                           hqtqt)) = (size(c) + size(cqt)))
                           AND ((ancillas(sequence_ghost_pps(c, cqt, h, hqt,
                               hqtqt)) = max(ancillas(c), ancillas(cqt)))
                               AND ((correct_path_sum_(sequence_ghost_pps(c,
                                   cqt, h, hqt, hqtqt), hqtqt)) AND (
                                   sequence_ghost_pps(c, cqt, h, hqt,
                                   hqtqt) = sequence(c, cqt))))))))))))));

parallel_ghost_pps: (circuit, circuit, pps, pps, pps) -> circuit;

fc1032: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1033: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1034: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1035: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1032(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1033(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1034(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1035(h,
  y)[k]) = (y[(k + h_range(h))])));

% parallel_ghost_pps'def
  ASSERT
  (FORALL (c : circuit, cqt : circuit, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(cqt, hqt))
     => ((h_width(hqtqt) = (width(c) + width(cqt)))
        => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((FORALL (j : INT):
                (((0 <= j) AND (j < h_width(hqtqt)))
                => ((0 <= (x[j])) AND ((x[j]) < 2))))
               => ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_range(hqtqt)))
                   => ((0 <= (y[j])) AND ((y[j]) < 2))))
                  => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                  int), t2tb57(h_angle(hqtqt)), t2tb7(x)), t2tb7(y))) = 
                  ang_add(tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(x)), 
                  t2tb7(y))), tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(hqt)), t2tb7(fc1032(h,
                  x))), t2tb7(fc1033(h, y)))))))))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  (FORALL (i : INT):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (((0 <= i) AND (i < h_width(h))) => ((tb2t7(infix_at(
                        infix_mngt(int, int), infix_mngt(int, int), infix_at(
                        infix_mngt(infix_mngt(int, int), infix_mngt(int,
                        int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(hqtqt)), t2tb7(x)), t2tb7(y)))[i]) = (
                        tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h)), t2tb7(x)), t2tb7(y)))[i])))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((h_width(h) <= i) AND (i < h_width(hqtqt)))
                           => ((tb2t7(infix_at(infix_mngt(int, int), 
                           infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqtqt)), 
                           t2tb7(x)), t2tb7(y)))[i]) = (tb2t7(infix_at(
                           infix_mngt(int, int), infix_mngt(int, int), 
                           infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqt)), t2tb7(fc1034(h, x))), 
                           t2tb7(fc1035(h, y))))[(i - h_width(h))])))))))
                    => (parallel_ghost_pps(c, cqt, h, hqt, hqtqt) = 
                    parallel(c, cqt))))))))));

fc1036: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1037: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1038: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1039: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1036(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1037(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1038(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1039(h,
  y)[k]) = (y[(k + h_range(h))])));

% parallel_ghost_pps'spec
  ASSERT
  (FORALL (c : circuit, cqt : circuit, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(cqt, hqt))
     => ((h_width(hqtqt) = (width(c) + width(cqt)))
        => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((FORALL (j : INT):
                (((0 <= j) AND (j < h_width(hqtqt)))
                => ((0 <= (x[j])) AND ((x[j]) < 2))))
               => ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_range(hqtqt)))
                   => ((0 <= (y[j])) AND ((y[j]) < 2))))
                  => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                  int), t2tb57(h_angle(hqtqt)), t2tb7(x)), t2tb7(y))) = 
                  ang_add(tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(x)), 
                  t2tb7(y))), tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(hqt)), t2tb7(fc1036(h,
                  x))), t2tb7(fc1037(h, y)))))))))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  (FORALL (i : INT):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (((0 <= i) AND (i < h_width(h))) => ((tb2t7(infix_at(
                        infix_mngt(int, int), infix_mngt(int, int), infix_at(
                        infix_mngt(infix_mngt(int, int), infix_mngt(int,
                        int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(hqtqt)), t2tb7(x)), t2tb7(y)))[i]) = (
                        tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h)), t2tb7(x)), t2tb7(y)))[i])))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((h_width(h) <= i) AND (i < h_width(hqtqt)))
                           => ((tb2t7(infix_at(infix_mngt(int, int), 
                           infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqtqt)), 
                           t2tb7(x)), t2tb7(y)))[i]) = (tb2t7(infix_at(
                           infix_mngt(int, int), infix_mngt(int, int), 
                           infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqt)), t2tb7(fc1038(h, x))), 
                           t2tb7(fc1039(h, y))))[(i - h_width(h))])))))))
                    => ((correct_path_sum_(parallel_ghost_pps(c, cqt, h, hqt,
                       hqtqt), hqtqt))
                       AND ((width(parallel_ghost_pps(c, cqt, h, hqt,
                           hqtqt)) = (width(c) + width(cqt)))
                           AND ((size(parallel_ghost_pps(c, cqt, h, hqt,
                               hqtqt)) = (size(c) + size(cqt)))
                               AND ((ancillas(parallel_ghost_pps(c, cqt, h,
                                   hqt, hqtqt)) = (ancillas(c) + 
                                   ancillas(cqt))) AND (parallel_ghost_pps(c,
                                   cqt, h, hqt, hqtqt) = parallel(c, cqt))))))))))))));

fc1040: (circuit, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1041: (circuit, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c : circuit, i : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc1040(c, i, x)[k]) = (IF (k < (width(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (c : circuit, i : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc1041(c, i, x)[k]) = (IF (k < (width(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% correct_ancilla
  ASSERT
  (FORALL (c : circuit, h : pps, hqt : pps, i : INT):
  ((1 <= i)
  => (((i + 1) <= width(c))
     => ((correct_path_sum_(c, h))
        => ((EXISTS
            (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
            (FORALL (x : matrix_complex):
            ((is_a_ket_l(x, (width(c) - i))) => (path_sem(c, kronecker(x, 
            ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
            matrix(complex1), t2tb19(path_sem_target), t2tb18(x))), ket(i,
            0))))))
           => ((h_width(hqt) = (width(c) - i))
              => ((h_range(hqt) = h_range(h))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (ii : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => ((tb2t7(infix_at(infix_mngt(int, int), 
                        infix_mngt(int, int), infix_at(infix_mngt(
                        infix_mngt(int, int), infix_mngt(int, int)), 
                        infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), 
                        t2tb7(x)), t2tb7(y)))[ii]) = (tb2t7(infix_at(
                        infix_mngt(int, int), infix_mngt(int, int), infix_at(
                        infix_mngt(infix_mngt(int, int), infix_mngt(int,
                        int)), infix_mngt(int, int), t2tb55(h_basis_ket(h)), 
                        t2tb7(fc1040(c, i, x))), t2tb7(y)))[ii]))))))
                    => ((FORALL (x : (ARRAY INT OF INT),
                        y : (ARRAY INT OF INT)): (tb2t33(infix_at(angle1, 
                        infix_mngt(int, int), infix_at(infix_mngt(
                        infix_mngt(int, int), angle1), infix_mngt(int, int), 
                        t2tb57(h_angle(hqt)), t2tb7(x)), t2tb7(y))) = tb2t33(
                        infix_at(angle1, infix_mngt(int, int), infix_at(
                        infix_mngt(infix_mngt(int, int), angle1), 
                        infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(
                        fc1041(c, i, x))), t2tb7(y)))))
                       => (correct_path_sum_(ancilla(c, i), hqt)))))))))));

% set_correct_main_path_sum
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((h_width(h) = width(c))
  => ((h_range(h) = range(c))
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = width(c))
         => ((length(y) = range(c)) => (tb2t33(infix_at(angle1, 
            infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int),
            angle1), infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(
            value(x))), t2tb7(value(y)))) = ang_ind(c, value(x), value(y))))))
        => ((FORALL (x : bitvec, y : bitvec):
            (FORALL (i : INT):
            (((0 <= i) AND (i < width(c)))
            => ((length(x) = width(c))
               => ((length(y) = range(c)) => ((tb2t7(infix_at(infix_mngt(int,
                  int), infix_mngt(int, int), infix_at(infix_mngt(
                  infix_mngt(int, int), infix_mngt(int, int)), 
                  infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(
                  value(x))), t2tb7(value(y))))[i]) = basis_ket(c, value(x), 
                  value(y), i)))))))
           => (correct_path_sum_(c, h)))))));

% set_correct_circ_to_pps
  ASSERT (FORALL (c : circuit): (correct_path_sum_(c, circ_to_pps(c))));

circuit_equiv: (circuit, circuit) -> BOOLEAN;

% circuit_equiv'def
  ASSERT
  (FORALL (c : circuit, cqt : circuit):
  ((circuit_equiv(c, cqt))
  <=> ((width(c) = width(cqt))
      AND (FORALL (x : bitvec):
          ((length(x) = width(c)) => (path_sem(c, bv_to_ket(x)) = 
          path_sem(cqt, bv_to_ket(x))))))));

% path_to_mat_sem
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((path_sem(c, x) = y) => (mat_mult(mat_sem(c), x) = y))));

% path_to_mat_sem_rev
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((path_sem(c, x) = y) => (y = mat_mult(mat_sem(c), x)))));

% mat_to_path_sem
  ASSERT
  (FORALL (c : circuit, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((mat_mult(mat_sem(c), x) = y) => (path_sem(c, x) = y))));

% path_to_mat_sem_exp
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (path_sem(c, x) = mat_mult(mat_sem(c), x))));

% mat_to_path_sem_exp
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (mat_mult(mat_sem(c), x) = path_sem(c, x))));

% set_path_sem_by_correct_pps
  ASSERT
  (FORALL (c : circuit, h : pps, x : matrix_complex):
  ((correct_path_sum_(c, h))
  => ((is_a_ket_l(x, width(c)))
     => ((is_a_ket_basis_elt(x)) => (path_sem(c, x) = pps_apply(h, x))))));

fc1042: (circuit, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1042(c, x)), t2tb26(y))) = 
  infix_asdtdt(ang_exp(ang_ind(c, value(x), value(y))), bv_to_ket(make_bv(
  tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int,
  int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int,
  int), infix_mngt(int, int))), circuit1, t2tb63(basis_ket_closure), 
  t2tb62(c)), t2tb7(value(x))), t2tb7(value(y)))), width(c))))));

% set_path_sem_by_main_pps
  ASSERT
  (FORALL (c : circuit, x : bitvec):
  ((length(x) = width(c)) => (path_sem(c, bv_to_ket(x)) = infix_asdtdt(
  pow_inv_sqrt_2(range(c)), ket_sum_l(bitvec1, t2tb28(n_bvs(range(c))), 
  t2tb29(fc1042(c, x)), width(c))))));

% set_path_sem_by_correct_pps_gen
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((correct_path_sum_(c, h))
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, width(c)))
     => ((is_a_ket_basis_elt(x)) => (path_sem(c, x) = pps_apply(h, x)))))));

% set_correct_path_sum_sim
  ASSERT
  (FORALL (c : circuit, h : pps, hqt : pps):
  ((h_range(h) = h_range(hqt))
  => ((h_width(h) = h_width(hqt))
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = width(c))
         => ((length(y) = h_range(h)) => (tb2t33(infix_at(angle1, 
            infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int),
            angle1), infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(
            value(x))), t2tb7(value(y)))) = tb2t33(infix_at(angle1, 
            infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int),
            angle1), infix_mngt(int, int), t2tb57(h_angle(hqt)), t2tb7(
            value(x))), t2tb7(value(y))))))))
        => ((FORALL (x : bitvec, y : bitvec):
            (FORALL (i : INT):
            ((length(x) = width(c))
            => ((length(y) = h_range(h))
               => (((0 <= i) AND (i < width(c))) => ((tb2t7(infix_at(
                  infix_mngt(int, int), infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                  infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(
                  value(x))), t2tb7(value(y))))[i]) = (tb2t7(infix_at(
                  infix_mngt(int, int), infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                  infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), t2tb7(
                  value(x))), t2tb7(value(y))))[i])))))))
           => ((correct_path_sum_(c, h)) => (correct_path_sum_(c, hqt))))))));

% set_correct_path_sum_by_main_sim
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((h_range(h) = range(c))
  => ((h_width(h) = width(c))
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = width(c))
         => ((length(y) = h_range(h)) => (tb2t33(infix_at(angle1, 
            infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int),
            angle1), infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(
            value(x))), t2tb7(value(y)))) = ang_ind(c, value(x), value(y))))))
        => ((FORALL (x : bitvec, y : bitvec):
            (FORALL (i : INT):
            ((length(x) = width(c))
            => ((length(y) = h_range(h))
               => (((0 <= i) AND (i < width(c))) => ((tb2t7(infix_at(
                  infix_mngt(int, int), infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                  infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(
                  value(x))), t2tb7(value(y))))[i]) = basis_ket(c, value(x), 
                  value(y), i)))))))
           => (correct_path_sum_(c, h)))))));

% path_sum_equiv
  ASSERT
  (FORALL (c : circuit, h : pps, hqt : pps):
  ((0 <= h_range(h))
  => ((h_range(h) = h_range(hqt))
     => ((h_width(h) = h_width(hqt))
        => ((FORALL (x : bitvec, y : bitvec):
            ((length(x) = width(c))
            => ((length(y) = h_range(h)) => (tb2t33(infix_at(angle1, 
               infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
               int), angle1), infix_mngt(int, int), t2tb57(h_angle(h)), 
               t2tb7(value(x))), t2tb7(value(y)))) = tb2t33(infix_at(angle1, 
               infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
               int), angle1), infix_mngt(int, int), t2tb57(h_angle(hqt)), 
               t2tb7(value(x))), t2tb7(value(y))))))))
           => ((FORALL (x : bitvec, y : bitvec):
               (FORALL (i : INT):
               (((0 <= i) AND (i < width(c)))
               => ((length(x) = width(c))
                  => ((length(y) = h_range(h)) => ((tb2t7(infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(
                     value(x))), t2tb7(value(y))))[i]) = (tb2t7(infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), t2tb7(
                     value(x))), t2tb7(value(y))))[i])))))))
              => ((correct_path_sum_(c, h)) <=> (correct_path_sum_(c, hqt)))))))));

% path_sum_pps_apply_equiv
  ASSERT
  (FORALL (c : circuit, h : pps, hqt : pps):
  ((pps_apply_equiv(h, hqt))
  => ((correct_path_sum_(c, h)) => (correct_path_sum_(c, hqt)))));

% path_sum_pps_apply_equiv_ref
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((pps_apply_equiv(h, circ_to_pps(c))) => (correct_path_sum_(c, h))));

% path_sum_pps_apply_equiv_rev
  ASSERT
  (FORALL (c : circuit, h : pps, hqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(c, hqt)) => (pps_apply_equiv(h, hqt)))));

% path_sum_pps_apply_equiv_ref_rev
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((correct_path_sum_(c, h)) => (pps_apply_equiv(h, circ_to_pps(c)))));

% correct_to_path_sem
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((correct_path_sum_(c, h))
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, width(c))) => (pps_apply(h, x) = path_sem(c, x))))));

% correct_to_mat_sem
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((correct_path_sum_(c, h))
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, width(c))) => (pps_apply(h, x) = mat_mult(mat_sem(c),
     x))))));

% swap_invol_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2))
  => ((is_a_ket_basis_elt(x)) => (path_sem(swap, path_sem(swap, x)) = x))));

% cnot_invol_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2))
  => ((is_a_ket_basis_elt(x)) => (path_sem(cnot, path_sem(cnot, x)) = x))));

% swap_invol
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2)) => (path_sem(swap, path_sem(swap, x)) = x)));

% cnot_invol
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2)) => (path_sem(cnot, path_sem(cnot, x)) = x)));

% mat_sem_to_correct
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((h_width(h) = width(c))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width(c)))
      => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = mat_mult(mat_sem(c),
         x)))))
     => (correct_path_sum_(c, h)))));

% path_sem_to_correct
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((h_width(h) = width(c))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width(c)))
      => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = path_sem(c, x)))))
     => (correct_path_sum_(c, h)))));

% correct_main_path_sum
  ASSERT (FORALL (c : circuit): (correct_path_sum_(c, circ_to_pps(c))));

correct_path_sum_bv: (circuit, INT,
  (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  (ARRAY bitvec OF (ARRAY bitvec OF angle))) -> BOOLEAN;

% correct_path_sum_bv'def
  ASSERT
  (FORALL (c : circuit, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width(c)))))
     => ((correct_path_sum_bv(c, r, k, a)) <=> (correct_path_sum_(c, 
        build_pps_bv(width(c), r, k, a)))))));

% correct_path_sum_to_bv
  ASSERT
  (FORALL (c : circuit, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width(c)))))
     => ((correct_path_sum_(c, build_pps_bv(width(c), r, k, a)))
        => (correct_path_sum_bv(c, r, k, a))))));

% correct_path_sum_by_bv
  ASSERT
  (FORALL (c : circuit, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((FORALL (x : bitvec, y : bitvec):
   ((length(x) = width(c))
   => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, infix_at(
      infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), t2tb26(x)), 
      t2tb26(y)))) = width(c)))))
  => ((0 <= r)
     => ((correct_path_sum_bv(c, r, k, a)) => (correct_path_sum_(c, 
        build_pps_bv(width(c), r, k, a)))))));

% correct_path_sum_bv_main
  ASSERT
  (FORALL (c : circuit, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width(c)))))
     => ((FORALL (x : bitvec, y : bitvec):
         (FORALL (i : INT):
         ((length(x) = width(c))
         => ((length(y) = r)
            => (((0 <= i) AND (i < width(c))) => ((value(tb2t26(
               infix_at(bitvec1, bitvec1, infix_at(infix_mngt(bitvec1,
               bitvec1), bitvec1, t2tb58(k), t2tb26(x)), t2tb26(y))))[i]) = 
               basis_ket(c, value(x), value(y), i)))))))
        => ((FORALL (x : bitvec, y : bitvec):
            ((length(x) = width(c))
            => ((length(y) = r) => (tb2t33(infix_at(angle1, bitvec1, 
               infix_at(infix_mngt(bitvec1, angle1), bitvec1, t2tb60(a), 
               t2tb26(x)), t2tb26(y))) = ang_ind(c, value(x), value(y))))))
           => ((r = range(c)) => (correct_path_sum_bv(c, r, k, a))))))));

fc568: ((ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  (ARRAY bitvec OF (ARRAY bitvec OF angle)),
  bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle)), x : bitvec, y : bitvec): (
  tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc568(k, a, x)), 
  t2tb26(y))) = infix_asdtdt(ang_exp(tb2t33(infix_at(angle1, bitvec1, 
  infix_at(infix_mngt(bitvec1, angle1), bitvec1, t2tb60(a), t2tb26(x)), 
  t2tb26(y)))), bv_to_ket(tb2t26(infix_at(bitvec1, bitvec1, infix_at(
  infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), t2tb26(x)), 
  t2tb26(y)))))));

% correct_path_sum_bv_apply
  ASSERT
  (FORALL (c : circuit, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle)), x : bitvec):
  ((0 <= r)
  => ((FORALL (x1 : bitvec, y : bitvec):
      ((length(x1) = width(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x1)), t2tb26(y)))) = width(c)))))
     => ((length(x) = width(c))
        => ((correct_path_sum_bv(c, r, k, a)) => (path_sem(c, 
           bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(r), ket_sum_l(bitvec1, 
           t2tb28(n_bvs(r)), t2tb29(fc568(k, a, x)), width(c)))))))));

% correct_path_sum_bv_sim
  ASSERT
  (FORALL (c : circuit, r1 : INT,
  k1 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a1 : (ARRAY bitvec OF (ARRAY bitvec OF angle)), r2 : INT,
  k2 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a2 : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r1)
  => ((r1 = r2)
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = width(c))
         => ((length(y) = r1) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
            infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k1), 
            t2tb26(x)), t2tb26(y)))) = width(c)))))
        => ((FORALL (x : bitvec, y : bitvec):
            ((length(x) = width(c))
            => ((length(y) = r1) => (tb2t26(infix_at(bitvec1, bitvec1, 
               infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k1), 
               t2tb26(x)), t2tb26(y))) = tb2t26(infix_at(bitvec1, bitvec1, 
               infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k2), 
               t2tb26(x)), t2tb26(y)))))))
           => ((FORALL (x : bitvec, y : bitvec):
               ((length(x) = width(c))
               => ((length(y) = r1) => (tb2t33(infix_at(angle1, bitvec1, 
                  infix_at(infix_mngt(bitvec1, angle1), bitvec1, t2tb60(a1), 
                  t2tb26(x)), t2tb26(y))) = tb2t33(infix_at(angle1, bitvec1, 
                  infix_at(infix_mngt(bitvec1, angle1), bitvec1, t2tb60(a2), 
                  t2tb26(x)), t2tb26(y)))))))
              => ((correct_path_sum_bv(c, r1, k1, a1))
                 => (correct_path_sum_bv(c, r2, k2, a2)))))))));

ids: (INT) -> circuit;

% ids'def
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => (IF (n = 1) THEN (ids(n) = id) ELSE (ids(n) = parallel(ids((n - 1)),
     id)) ENDIF)));

% ids'spec
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => ((width(ids(n)) = n)
     AND ((size(ids(n)) = 0)
         AND ((ancillas(ids(n)) = 0)
             AND ((range(ids(n)) = 0)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT)):
                      (FORALL (i : INT): (basis_ket(ids(n), x, y,
                      i) = (x[i]))))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind(ids(n), x,
                          y) = ang_zero))
                         AND ((FORALL (x : matrix_complex):
                              ((is_a_ket_l(x, n))
                              => ((is_a_ket_basis_elt(x)) => (path_sem(
                                 ids(n), x) = x))))
                             AND (FORALL (x : matrix_complex):
                                 ((is_a_ket_l(x, n)) => (path_sem(ids(n),
                                 x) = x))))))))))));

place_zero: (circuit, INT) -> circuit;

% place_zero'def
  ASSERT
  (FORALL (c : circuit, n : INT):
  ((width(c) <= n)
  => (IF (n = width(c)) THEN (place_zero(c, n) = c) ELSE (place_zero(c, n) = 
     parallel(c, ids((n - width(c))))) ENDIF)));

% place_zero'spec
  ASSERT
  (FORALL (c : circuit, n : INT):
  ((width(c) <= n)
  => ((ancillas(place_zero(c, n)) = ancillas(c))
     AND ((size(place_zero(c, n)) = size(c))
         AND ((range(place_zero(c, n)) = range(c))
             AND ((width(place_zero(c, n)) = n)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT)):
                      (FORALL (i : INT):
                      (((0 <= i) AND (i < n)) => (basis_ket(place_zero(c, n),
                      x, y,
                      i) = (IF ((0 <= i) AND (i < width(c))) THEN 
                           basis_ket(c, x, y, i) ELSE (x[i]) ENDIF)))))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind(place_zero(c, n),
                          x, y) = ang_ind(c, x, y)))
                         AND (place_zero(c,
                         n) = (IF (n = width(c)) THEN c ELSE parallel(c, 
                              ids((n - width(c)))) ENDIF))))))))));

place: (circuit, INT, INT) -> circuit;

% place'def
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => (IF (k = 0) THEN (place(c, k, n) = place_zero(c, n)) ELSE (place(c,
        k, n) = parallel(ids(k), place_zero(c, (n - k)))) ENDIF))));

fc569: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc570: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, x : (ARRAY INT OF INT), j : INT): ((fc569(k,
  x)[j]) = (x[(j + k)])));

% fc'def
  ASSERT
  (FORALL (k : INT, x : (ARRAY INT OF INT), j : INT): ((fc570(k,
  x)[j]) = (x[(j + k)])));

% place'spec
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((ancillas(place(c, k, n)) = ancillas(c))
        AND ((size(place(c, k, n)) = size(c))
            AND ((range(place(c, k, n)) = range(c))
                AND ((width(place(c, k, n)) = n)
                    AND ((FORALL (x : (ARRAY INT OF INT),
                         y : (ARRAY INT OF INT)):
                         (FORALL (i : INT):
                         (((0 <= i) AND (i < n)) => (basis_ket(place(c, k,
                         n), x, y,
                         i) = (IF ((k <= i) AND (i < (k + width(c)))) THEN 
                              basis_ket(c, fc569(k, x), y, (i - k))
                              ELSE (x[i]) ENDIF)))))
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)): (ang_ind(place(c, k,
                             n), x, y) = ang_ind(c, fc570(k, x), y)))
                            AND (place(c, k,
                            n) = (IF ((k = 0) AND (n = (k + width(c))))
                                 THEN c
                                 ELSE (IF (k = 0) THEN parallel(c, 
                                      ids(((n - k) - width(c))))
                                      ELSE (IF (n = (k + width(c))) THEN 
                                           parallel(ids(k), c) ELSE parallel(
                                           ids(k), parallel(c, 
                                           ids(((n - k) - width(c))))) ENDIF) ENDIF) ENDIF)))))))))));

ket_zero: matrix_complex;

% ket_zero'def
  ASSERT
  ((is_a_ket_l(ket_zero, 0))
  AND ((is_a_ket_basis_elt(ket_zero))
      AND ((FORALL (i : INT):
           ((i = 0) => (tb2t(get(complex1, t2tb18(ket_zero), i, 0)) = c_one)))
          AND ((rows(complex1, t2tb18(ket_zero)) = 1) AND (columns(complex1, 
              t2tb18(ket_zero)) = 1)))));

% get_ket_zero
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = ket_zero)
  => ((is_a_ket_l(x, 0))
     AND (FORALL (i : INT):
         ((i = 0) => (tb2t(get(complex1, t2tb18(x), i, 0)) = c_one))))));

% set_ket_zero
  ASSERT
  (FORALL (x : matrix_complex):
  ((rows(complex1, t2tb18(x)) = 1)
  => ((columns(complex1, t2tb18(x)) = 1)
     => ((tb2t(get(complex1, t2tb18(x), 0, 0)) = c_one) => (x = ket_zero)))));

% ket_to_bv_zero
  ASSERT
  (FORALL (x : bitvec): ((length(x) = 0) => (x = ket_to_bv(ket_zero))));

% bv_to_ket_zero
  ASSERT
  (FORALL (x : bitvec): ((length(x) = 0) => (bv_to_ket(x) = ket_zero)));

% ket_zero_kron
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((x = ket_zero) => (kronecker(x, y) = y)));

% kron_ket_zero
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((x = ket_zero) => (kronecker(y, x) = y)));

% place_circ_to_pps
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  ((0 <= k)
  => (((width(c) + k) <= n) => (correct_path_sum_(place(c, k, n), pps_place(
     circ_to_pps(c), k, n))))));

% pps_apply_equiv_by_circ
  ASSERT
  (FORALL (c : circuit, h : pps, hqt : pps):
  ((correct_path_sum_(c, h))
  => ((correct_path_sum_(c, hqt)) => (pps_apply_equiv(h, hqt)))));

% place_pps
  ASSERT
  (FORALL (c : circuit, h : pps, k : INT, n : INT):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((correct_path_sum_(c, h)) => (correct_path_sum_(place(c, k, n), 
        pps_place(h, k, n)))))));

% place_kron
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, x : matrix_complex,
  y : matrix_complex, yqt : matrix_complex, z : matrix_complex):
  ((0 < k)
  => (((width(c) + k) < n)
     => ((is_a_ket_l(x, k))
        => ((is_a_ket_l(y, width(c)))
           => ((is_a_ket_l(z, ((n - width(c)) - k)))
              => ((path_sem(c, y) = yqt) => (path_sem(place(c, k, n), 
                 kronecker(x, kronecker(y, z))) = kronecker(x, kronecker(yqt,
                 z))))))))));

% place_kron_left
  ASSERT
  (FORALL (c : circuit, n : INT, y : matrix_complex, yqt : matrix_complex,
  z : matrix_complex):
  ((width(c) < n)
  => ((is_a_ket_l(y, width(c)))
     => ((is_a_ket_l(z, (n - width(c))))
        => ((path_sem(c, y) = yqt) => (path_sem(place(c, 0, n), kronecker(y,
           z)) = kronecker(yqt, z)))))));

% place_kron_right
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  ((0 < k)
  => ((n = (width(c) + k))
     => (FORALL (y : matrix_complex, x : matrix_complex):
        ((is_a_ket_l(x, k))
        => ((is_a_ket_l(y, (n - k))) => (path_sem(place(c, k, n), 
           kronecker(x, y)) = kronecker(x, path_sem(c, y)))))))));

% place_kron_right_sem
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  ((0 < k)
  => ((n = (width(c) + k))
     => (FORALL (y : matrix_complex, x : matrix_complex, z : matrix_complex):
        ((is_a_ket_l(x, k))
        => ((is_a_ket_l(y, (n - k)))
           => ((sem(c, y, z)) => (sem(place(c, k, n), kronecker(x, y), 
              kronecker(x, z))))))))));

% place_zero_kron
  ASSERT
  (FORALL (c : circuit, n : INT, x : bitvec):
  ((width(c) <= n)
  => ((length(x) = n) => (path_sem(place_zero(c, n), 
     bv_to_ket(x)) = (IF (n = width(c)) THEN path_sem(c, bv_to_ket(x)) ELSE 
                     kronecker(path_sem(c, bv_to_ket(hpart(x, width(c)))), 
                     bv_to_ket(tpart(x, width(c)))) ENDIF)))));

% place_kron_gen
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, x : bitvec):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((length(x) = n) => (path_sem(place(c, k, n), 
        bv_to_ket(x)) = (IF (k = 0)
                        THEN (IF (n = width(c)) THEN path_sem(c, 
                             bv_to_ket(x)) ELSE kronecker(path_sem(c, 
                             bv_to_ket(hpart(x, width(c)))), bv_to_ket(
                             tpart(x, width(c)))) ENDIF)
                        ELSE (IF (n = (k + width(c))) THEN kronecker(
                             bv_to_ket(hpart(x, k)), path_sem(c, bv_to_ket(
                             tpart(x, k)))) ELSE kronecker(bv_to_ket(hpart(x,
                             k)), kronecker(path_sem(c, bv_to_ket(htpart(x,
                             k, width(c)))), bv_to_ket(tpart(x, (
                             width(c) + k))))) ENDIF) ENDIF))))));

% place_kronecker
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, x : bitvec):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((length(x) = n) => (path_sem(place(c, k, n), bv_to_ket(x)) = 
        kronecker(bv_to_ket(hpart(x, k)), kronecker(path_sem(c, bv_to_ket(
        htpart(x, k, width(c)))), bv_to_ket(tpart(x, (width(c) + k))))))))));

% place_kron_gen_
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  ((0 < k)
  => (((width(c) + k) < n)
     => (FORALL (x : matrix_complex, y : matrix_complex,
        yqt : matrix_complex, z : matrix_complex):
        ((is_a_ket_l(x, k))
        => ((is_a_ket_l(y, width(c)))
           => ((is_a_ket_l(z, ((n - width(c)) - k)))
              => ((sem(c, y, yqt)) => (sem(place(c, k, n), kronecker(x, 
                 kronecker(y, z)), kronecker(x, kronecker(yqt, z))))))))))));

% place_zero_place
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, nqt : INT, x : bitvec):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((n <= nqt)
        => ((length(x) = nqt) => (path_sem(place_zero(place(c, k, n), nqt), 
           bv_to_ket(x)) = path_sem(place(c, k, nqt), bv_to_ket(x))))))));

% place_place
  ASSERT
  (FORALL (c : circuit, k : INT, kqt : INT, n : INT, nqt : INT, x : bitvec):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((0 <= kqt)
        => (((n + kqt) <= nqt)
           => ((length(x) = nqt) => (path_sem(place(place(c, k, n), kqt,
              nqt), bv_to_ket(x)) = path_sem(place(c, (k + kqt), nqt), 
              bv_to_ket(x)))))))));

fc1043: (INT, bitvec) -> (ARRAY INT OF INT);

fc1044: (INT, bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, x : bitvec, i : INT): ((fc1043(k, x)[i]) = (
  value(x)[(i + k)])));

% fc'def
  ASSERT
  (FORALL (k : INT, y : bitvec, i : INT): ((fc1044(k, y)[i]) = (
  value(y)[(i + k)])));

% place_get_ket
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, x : bitvec, y : bitvec):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((length(x) = n)
        => ((length(y) = n)
           => ((hpart(x, k) = hpart(y, k))
              => ((tpart(x, (k + width(c))) = tpart(y, (k + width(c)))) => (
                 tb2t(get(complex1, t2tb18(path_sem(place(c, k, n), 
                 bv_to_ket(x))), bv_to_int(y), 0)) = tb2t(get(complex1, 
                 t2tb18(path_sem(c, bv_to_ket(make_bv(fc1043(k, x), 
                 width(c))))), bv_to_int(make_bv(fc1044(k, y), width(c))),
                 0))))))))));

% place_get_ket_hpart_null
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, x : bitvec, y : bitvec):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((length(x) = n)
        => ((length(y) = n)
           => ((NOT (hpart(x, k) = hpart(y, k))) => (tb2t(get(complex1, 
              t2tb18(path_sem(place(c, k, n), bv_to_ket(x))), bv_to_int(y),
              0)) = c_zero)))))));

% place_get_ket_tpart_null
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, x : bitvec, y : bitvec):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((length(x) = n)
        => ((length(y) = n)
           => ((NOT (tpart(x, (k + width(c))) = tpart(y, (k + width(c)))))
              => (tb2t(get(complex1, t2tb18(path_sem(place(c, k, n), 
              bv_to_ket(x))), bv_to_int(y), 0)) = c_zero)))))));

place_hadamard: (INT, INT) -> circuit;

% place_hadamard'def
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < n)) => (place_hadamard(k, n) = place(hadamard, k, n))));

% place_hadamard'spec
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < n))
  => ((range(place_hadamard(k, n)) = 1)
     AND ((width(place_hadamard(k, n)) = n)
         AND ((size(place_hadamard(k, n)) = 1)
             AND ((ancillas(place_hadamard(k, n)) = 0)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT)):
                      (FORALL (i : INT):
                      (((0 <= i) AND (i < n)) => (basis_ket(place_hadamard(k,
                      n), x, y,
                      i) = (IF (i = k) THEN (y[0]) ELSE (x[i]) ENDIF)))))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind(place_hadamard(k,
                          n), x, y) = infix_sldtsl(((x[k]) * (y[0])), 1)))
                         AND (FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)):
                             (FORALL (m : INT):
                             ((1 <= m) => (ang_ind(place_hadamard(k, n), x,
                             y) = infix_sldtsl((((x[k]) * (y[0])) * power(2,
                             (m - 1))), m)))))))))))));

place_hadamard_bv: (INT, INT) -> circuit;

% place_hadamard_bv'def
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < n)) => (place_hadamard_bv(k, n) = place_hadamard(k,
  n))));

fc1045: (INT, bitvec, bitvec) -> (ARRAY INT OF INT);

fc1046: (INT, INT) -> (ARRAY bitvec OF (ARRAY bitvec OF bitvec));

fc1047: (INT, INT) -> (ARRAY bitvec OF (ARRAY bitvec OF angle));

% fc'def
  ASSERT
  (FORALL (k : INT, x : bitvec, y : bitvec, i : INT): ((fc1045(k, x,
  y)[i]) = (IF (i = k) THEN (value(y)[0]) ELSE (value(x)[i]) ENDIF)));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, x : bitvec, y : bitvec): (tb2t26(
  infix_at(bitvec1, bitvec1, infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, 
  t2tb58(fc1046(k, n)), t2tb26(x)), t2tb26(y))) = make_bv(fc1045(k, x, y),
  n)));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, x : bitvec, y : bitvec): (tb2t33(
  infix_at(angle1, bitvec1, infix_at(infix_mngt(bitvec1, angle1), bitvec1, 
  t2tb60(fc1047(k, n)), t2tb26(x)), t2tb26(y))) = infix_sldtsl((((
  value(x)[k]) * (value(y)[0])) * power(2, (n - 1))), n)));

% place_hadamard_bv'spec
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < n))
  => ((range(place_hadamard_bv(k, n)) = 1)
     AND ((width(place_hadamard_bv(k, n)) = n)
         AND ((size(place_hadamard_bv(k, n)) = 1)
             AND ((ancillas(place_hadamard_bv(k, n)) = 0)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT)):
                      (FORALL (i : INT):
                      (((0 <= i) AND (i < n)) => (basis_ket(
                      place_hadamard_bv(k, n), x, y,
                      i) = (IF (i = k) THEN (y[0]) ELSE (x[i]) ENDIF)))))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind(
                          place_hadamard_bv(k, n), x, y) = 
                          infix_sldtsl(((x[k]) * (y[0])), 1)))
                         AND ((FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)): (ang_ind(
                              place_hadamard_bv(k, n), x, y) = 
                              infix_sldtsl((((x[k]) * (y[0])) * power(2,
                              (n - 1))), n)))
                             AND (correct_path_sum_bv(place_hadamard_bv(k,
                             n), 1, fc1046(k, n), fc1047(k, n))))))))))));

cont_size: INT;

% cont_size'def
  ASSERT (0 < cont_size);

rz_: (INT) -> circuit;

% rz_'def
  ASSERT
  (FORALL (k : INT): (rz_(k) = seq_pps(phase((- incr_abs(k))), rz(k), 
  pps_phase((- incr_abs(k))), pps_rz(k), pps_rz_b(k))));

% rz_'spec
  ASSERT
  (FORALL (k : INT):
  ((pre(rz_(k)) = Sequence(Phase((- incr_abs(k))), Rz(k)))
  AND ((correct_path_sum_(rz_(k), pps_rz_b(k)))
      AND ((ancillas(rz_(k)) = 0)
          AND ((size(rz_(k)) = 2)
              AND ((range(rz_(k)) = 0)
                  AND ((width(rz_(k)) = 1)
                      AND ((path_sem(rz_(k), ket(1, 0)) = infix_asdtdt(
                          ang_exp(infix_sldtsl((- 1), incr_abs(k))), ket(1,
                          0)))
                          AND ((path_sem(rz_(k), ket(1, 1)) = infix_asdtdt(
                              ang_exp(infix_sldtsl(1, incr_abs(k))), ket(1,
                              1)))
                              AND ((FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)):
                                   (FORALL (i : INT): (basis_ket(rz_(k), x,
                                   y, i) = (x[i]))))
                                  AND (FORALL (x : (ARRAY INT OF INT),
                                      y : (ARRAY INT OF INT)):
                                      (((0 <= (x[0])) AND ((x[0]) < 2)) => (
                                      ang_ind(rz_(k), x, y) = 
                                      phase_inv_(((x[0]) - 1), 
                                      infix_sldtsl(1, incr_abs(k))))))))))))))));

rx: (INT) -> circuit;

% rx'def
  ASSERT
  (FORALL (k : INT): (rx(k) = seq_pps(hadamard, seq_pps(rz_(k), hadamard, 
  pps_rz_b(k), pps_hadamard, pps_seq(pps_rz_b(k), pps_hadamard)),
  pps_hadamard, pps_seq(pps_rz_b(k), pps_hadamard), pps_rx(k))));

% rx'spec
  ASSERT
  (FORALL (k : INT):
  ((rx(k) = sequence(hadamard, sequence(rz_(k), hadamard)))
  AND ((pre(rx(k)) = Sequence(Hadamard, Sequence(Sequence(Phase((- 
      incr_abs(k))), Rz(k)), Hadamard)))
      AND ((correct_path_sum_(rx(k), pps_rx(k))) AND (width(rx(k)) = 1)))));

zz: circuit;

% zz'def
  ASSERT ((correct_path_sum_(zz, pps_zz)) AND (width(zz) = 1));

% path_sem_zz_zero
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = ket(1, 0)) => (path_sem(zz, x) = ket(1, 0))));

% path_sem_zz_one
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = ket(1, 1)) => (path_sem(zz, x) = infix_asdtdt(prefix_mndt(c_one), 
  ket(1, 1)))));

% path_sem_zz_plus
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = pps_apply(pps_hadamard, ket(1, 0))) => (path_sem(zz, x) = 
  pps_apply(pps_hadamard, ket(1, 1)))));

% path_sem_zz_minus
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = pps_apply(pps_hadamard, ket(1, 1))) => (path_sem(zz, x) = 
  pps_apply(pps_hadamard, ket(1, 0)))));

xx: circuit;

% xx'def
  ASSERT ((correct_path_sum_(xx, pps_xx)) AND (width(xx) = 1));

path_sem_xx: (matrix_complex) -> matrix_complex;

% path_sem_xx'def
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem_xx(x) = path_sem(xx, x))));

% path_sem_xx'spec
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem_xx(x) = add_ket_l(infix_asdtdt(tb2t(
  get(complex1, t2tb18(x), 1, 0)), ket(1, 0)), infix_asdtdt(tb2t(
  get(complex1, t2tb18(x), 0, 0)), ket(1, 1)), 1))));

% path_sem_xx_add_rev
  ASSERT
  (FORALL (a : complex, b : complex): (path_sem_xx(add_ket_l(infix_asdtdt(a, 
  ket(1, 0)), infix_asdtdt(b, ket(1, 1)), 1)) = add_ket_l(infix_asdtdt(b, 
  ket(1, 0)), infix_asdtdt(a, ket(1, 1)), 1)));

% path_sem_xx_z
  ASSERT (path_sem_xx(ket(1, 0)) = ket(1, 1));

% path_sem_xx_o
  ASSERT (path_sem_xx(ket(1, 1)) = ket(1, 0));

% path_sem_xx_invol
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem_xx(path_sem_xx(x)) = x)));

path_sem_cnot_basis_left: (matrix_complex, matrix_complex) -> matrix_complex;

% path_sem_cnot_basis_left'def
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_l(y, 1))
     => ((is_a_ket_basis_elt(x))
        => ((is_a_ket_basis_elt(y)) => (path_sem_cnot_basis_left(x, y) = 
           path_sem(cnot, kronecker(x, y))))))));

% path_sem_cnot_basis_left'spec
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_l(y, 1))
     => ((is_a_ket_basis_elt(x))
        => ((is_a_ket_basis_elt(y))
           => ((path_sem_cnot_basis_left(x,
              y) = (IF (x = ket(1, 0)) THEN kronecker(x, y) ELSE kronecker(x, 
                   path_sem_xx(y)) ENDIF))
              AND (((x = ket(1, 0)) => (path_sem_cnot_basis_left(x, y) = 
                   kronecker(x, y)))
                  AND ((x = ket(1, 1)) => (path_sem_cnot_basis_left(x, y) = 
                      kronecker(x, path_sem_xx(y)))))))))));

path_sem_cnot: (matrix_complex, matrix_complex) -> matrix_complex;

% path_sem_cnot'def
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_l(y, 1))
     => ((is_a_ket_basis_elt(x)) => (path_sem_cnot(x, y) = path_sem(cnot, 
        kronecker(x, y)))))));

% path_sem_cnot'spec
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_l(y, 1))
     => ((is_a_ket_basis_elt(x))
        => ((path_sem_cnot(x,
           y) = (IF (x = ket(1, 0)) THEN kronecker(x, y) ELSE kronecker(x, 
                path_sem_xx(y)) ENDIF))
           AND (((x = ket(1, 0)) => (path_sem_cnot(x, y) = kronecker(x, y)))
               AND ((x = ket(1, 1)) => (path_sem_cnot(x, y) = kronecker(x, 
                   path_sem_xx(y))))))))));

path_sem_swap: (matrix_complex, matrix_complex) -> matrix_complex;

% path_sem_swap'def
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_l(y, 1)) => (path_sem_swap(x, y) = path_sem(swap, 
     kronecker(x, y))))));

% path_sem_swap'spec
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_l(y, 1)) => (path_sem_swap(x, y) = kronecker(y, x)))));

yy: circuit;

% yy'def
  ASSERT ((correct_path_sum_(yy, pps_yy)) AND (width(yy) = 1));

ry: (INT) -> circuit;

% ry'def
  ASSERT
  (FORALL (k : INT): (ry(k) = seq_pps(seq_pps(rz((- 2)), rx(k), 
  pps_rz((- 2)), pps_rx(k), pps_seq(pps_rz((- 2)), pps_rx(k))), rz(2), 
  pps_seq(pps_rz((- 2)), pps_rx(k)), pps_rz(2), pps_ry(k))));

% ry'spec
  ASSERT
  (FORALL (k : INT):
  ((ry(k) = sequence(sequence(rz((- 2)), rx(k)), rz(2)))
  AND ((pre(ry(k)) = Sequence(Sequence(Rz((- 2)), pre(rx(k))), Rz(2)))
      AND ((correct_path_sum_(ry(k), pps_ry(k))) AND (width(ry(k)) = 1)))));

c_inverse_pre: ((ARRAY INT OF INT), INT, INT) -> INT;

% c_inverse_pre'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT, i : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
  n))))
  => (((0 <= i) AND (i < n))
     => (((0 <= c_inverse_pre(f, n, i)) AND (c_inverse_pre(f, n, i) < n))
        AND ((f[c_inverse_pre(f, n, i)]) = i)))));

c_inverse: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% c_inverse'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
  n))))
  => (FORALL (x : INT): ((c_inverse(f,
     n)[x]) = (IF ((0 <= x) AND (x < n)) THEN c_inverse_pre(f, n, x)
              ELSE x ENDIF)))));

% c_inverse'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
  n))))
  => ((FORALL (b : INT):
      (((0 <= b) AND (b < n))
      => ((0 <= (c_inverse(f, n)[b])) AND ((c_inverse(f, n)[b]) < n))))
     AND ((FORALL (b : INT):
          (((0 <= b) AND (b < n)) => ((f[(c_inverse(f, n)[b])]) = b)))
         AND ((p_bijective(int, int, t2tb7(c_inverse(f, n)), t2tb6(to_fset(0,
             n)), t2tb6(to_fset(0, n))))
             AND ((FORALL (b : INT):
                  (((0 <= b) AND (b < n)) => ((c_inverse(f, n)[(f[b])]) = b)))
                 AND (FORALL (b : INT):
                     (((0 <= b) AND (b < n)) => ((c_inverse(f, n)[b]) = (
                     inv_func_int(f, n)[b]))))))))));

% unic_inverse_c
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), fqt : (ARRAY INT OF INT), n : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
  n))))
  => ((FORALL (a : INT): (((0 <= a) AND (a < n)) => ((fqt[(f[a])]) = a)))
     => (FORALL (b : INT):
        (((0 <= b) AND (b < n)) => ((fqt[b]) = (c_inverse(f, n)[b])))))));

c_inv_func_int: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% c_inv_func_int'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
  n)))) => (c_inv_func_int(f, n) = c_inverse(f, n))));

% c_inv_func_int'spec
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), n : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
  n))))
  => ((FORALL (b : INT):
      (((0 <= b) AND (b < n)) => ((c_inv_func_int(f, n)[b]) = (
      inv_func_int(f, n)[b]))))
     AND ((p_bijective(int, int, t2tb7(c_inv_func_int(f, n)), t2tb6(
         to_fset(0, n)), t2tb6(to_fset(0, n))))
         AND ((FORALL (a : INT):
              (((0 <= a) AND (a < n))
              => ((0 <= (c_inv_func_int(f, n)[a])) AND ((c_inv_func_int(f,
                 n)[a]) < n))))
             AND ((FORALL (a : INT):
                  (((0 <= a) AND (a < n)) => ((f[(c_inv_func_int(f,
                  n)[a])]) = a)))
                 AND ((FORALL (a : INT):
                      (((0 <= a) AND (a < n)) => ((c_inv_func_int(f,
                      n)[(f[a])]) = a)))
                     AND (FORALL (a : INT, b : INT):
                         (((0 <= a) AND (a < n))
                         => (((0 <= b) AND (b < n))
                            => (((f[a]) = b) => ((c_inv_func_int(f,
                               n)[b]) = a))))))))))));

% unic_inverse_c_int
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), fqt : (ARRAY INT OF INT), n : INT):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
  n))))
  => ((FORALL (a : INT): (((0 <= a) AND (a < n)) => ((fqt[(f[a])]) = a)))
     => (FORALL (b : INT):
        (((0 <= b) AND (b < n)) => ((c_inv_func_int(f, n)[b]) = (fqt[b])))))));

qbit_permutes: (circuit) -> BOOLEAN;

% qbit_permutes'def
  ASSERT
  (FORALL (c : circuit):
  (((((((((FORALL (x : INT):
          ((pre(c) = Phase(x)) => (NOT (qbit_permutes(c)))))
         AND (FORALL (x : INT):
             ((pre(c) = Rz(x)) => (NOT (qbit_permutes(c))))))
        AND ((pre(c) = Hadamard) => (NOT (qbit_permutes(c)))))
       AND ((pre(c) = Cnot) => (NOT (qbit_permutes(c)))))
      AND ((pre(c) = Swap) => (qbit_permutes(c))))
     AND ((pre(c) = Id) => (qbit_permutes(c))))
    AND (FORALL (x : circuit_pre, x1 : circuit_pre):
        ((pre(c) = Sequence(x, x1))
        => ((qbit_permutes(c))
           <=> ((qbit_permutes(to_qc(x))) AND (qbit_permutes(to_qc(x1))))))))
   AND (FORALL (x : circuit_pre, x1 : circuit_pre):
       ((pre(c) = Parallel(x, x1))
       => ((qbit_permutes(c))
          <=> ((qbit_permutes(to_qc(x))) AND (qbit_permutes(to_qc(x1))))))))
  AND (FORALL (x : circuit_pre, x1 : INT):
      ((pre(c) = Ancillas(x, x1)) => (NOT (qbit_permutes(c)))))));

% qbit_permutes'spec
  ASSERT
  (FORALL (c : circuit):
  (((qbit_permutes(c)) => (size(c) = 0))
  AND (((qbit_permutes(c)) => (ancillas(c) = 0))
      AND (((qbit_permutes(c)) => (range(c) = 0))
          AND ((qbit_permutes(c))
              => (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
                 ang_ind(c, x, y) = ang_zero)))))));

qbit_permutation: (circuit) -> (ARRAY INT OF INT);

identity2: (ARRAY INT OF INT);

% identity_def
  ASSERT (FORALL (y : INT): ((identity2[y]) = y));

% qbit_permutation'def
  ASSERT
  (FORALL (c : circuit):
  ((qbit_permutes(c))
  => (((((((((FORALL (w : INT):
             ((pre(c) = Phase(w)) => (qbit_permutation(c) = identity2)))
            AND (FORALL (w : INT):
                ((pre(c) = Rz(w)) => (qbit_permutation(c) = identity2))))
           AND ((pre(c) = Hadamard) => (qbit_permutation(c) = identity2)))
          AND ((pre(c) = Cnot) => (qbit_permutation(c) = identity2)))
         AND ((pre(c) = Swap)
             => (FORALL (i : INT): ((
                qbit_permutation(c)[i]) = (IF (i = 0) THEN 1
                                          ELSE (IF (i = 1) THEN 0
                                               ELSE i ENDIF) ENDIF)))))
        AND ((pre(c) = Id) => (qbit_permutation(c) = identity2)))
       AND (FORALL (d : circuit_pre, e : circuit_pre):
           ((pre(c) = Sequence(d, e))
           => (FORALL (i : INT): ((qbit_permutation(c)[i]) = (
              qbit_permutation(to_qc(d))[(qbit_permutation(to_qc(e))[i])]))))))
      AND (FORALL (d : circuit_pre, e : circuit_pre):
          ((pre(c) = Parallel(d, e))
          => (FORALL (i : INT): ((
             qbit_permutation(c)[i]) = (IF (i < width(to_qc(d))) THEN (
                                       qbit_permutation(to_qc(d))[i]) ELSE ((
                                       qbit_permutation(to_qc(e))[(i - width(
                                       to_qc(d)))]) + width(to_qc(d))) ENDIF))))))
     AND (FORALL (w : circuit_pre, w1 : INT):
         ((pre(c) = Ancillas(w, w1)) => (qbit_permutation(c) = identity2))))));

% qbit_permutation'spec
  ASSERT
  (FORALL (c : circuit):
  ((qbit_permutes(c))
  => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
      (FORALL (i : INT):
      (((0 <= i) AND (i < width(c))) => (basis_ket(c, x, y, i) = (x[(
      qbit_permutation(c)[i])])))))
     AND (p_bijective(int, int, t2tb7(qbit_permutation(c)), t2tb6(to_fset(0, 
     width(c))), t2tb6(to_fset(0, width(c))))))));

% in_to_fset_qp
  ASSERT
  (FORALL (c : circuit, i : INT):
  ((qbit_permutes(c))
  => (((0 <= i) AND (i < width(c))) => (mem(int, t2tb5((
     qbit_permutation(c)[i])), t2tb6(to_fset(0, width(c))))))));

% bound_qp
  ASSERT
  (FORALL (c : circuit, i : INT):
  ((qbit_permutes(c))
  => (((0 <= i) AND (i < width(c)))
     => ((0 <= (qbit_permutation(c)[i])) AND ((qbit_permutation(c)[i]) < 
        width(c))))));

qbit_permute_sequence: (circuit, circuit) -> circuit;

% qbit_permute_sequence'def
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e))
  => ((qbit_permutes(d))
     => ((qbit_permutes(e)) => (qbit_permute_sequence(d, e) = sequence(d,
        e))))));

% qbit_permute_sequence'spec
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e))
  => ((qbit_permutes(d))
     => ((qbit_permutes(e))
        => ((qbit_permutes(qbit_permute_sequence(d, e)))
           AND ((FORALL (i : INT): ((qbit_permutation(
                qbit_permute_sequence(d, e))[i]) = (qbit_permutation(d)[(
                qbit_permutation(e)[i])])))
               AND (width(qbit_permute_sequence(d, e)) = width(d))))))));

qbit_permute_parallel: (circuit, circuit) -> circuit;

% qbit_permute_parallel'def
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((qbit_permutes(d))
  => ((qbit_permutes(e)) => (qbit_permute_parallel(d, e) = parallel(d, e)))));

% qbit_permute_parallel'spec
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((qbit_permutes(d))
  => ((qbit_permutes(e))
     => ((qbit_permutes(qbit_permute_parallel(d, e)))
        AND ((FORALL (i : INT): ((qbit_permutation(qbit_permute_parallel(d,
             e))[i]) = (IF (i < width(d)) THEN (qbit_permutation(d)[i])
                       ELSE ((qbit_permutation(e)[(i - width(d))]) + 
                       width(d)) ENDIF)))
            AND (width(qbit_permute_parallel(d, e)) = (width(d) + width(e))))))));

ids_permute: (INT) -> circuit;

% ids_permute'def
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => (IF (n = 1) THEN (ids_permute(n) = id) ELSE (ids_permute(n) = 
     qbit_permute_parallel(ids_permute((n - 1)), id)) ENDIF)));

% ids_permute'spec
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => ((ids_permute(n) = ids(n))
     AND ((width(ids_permute(n)) = n)
         AND ((qbit_permutes(ids_permute(n)))
             AND (FORALL (i : INT): ((qbit_permutation(
                 ids_permute(n))[i]) = i)))))));

permute_place: (circuit, INT, INT) -> circuit;

% permute_place'spec
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  ((0 <= k)
  => (((width(c) + k) <= n)
     => ((qbit_permutes(c))
        => ((width(permute_place(c, k, n)) = n)
           AND ((qbit_permutes(permute_place(c, k, n)))
               AND (FORALL (i : INT):
                   (((0 <= i) AND (i < n)) => ((qbit_permutation(
                   permute_place(c, k,
                   n))[i]) = (IF ((k <= i) AND (i < (k + width(c)))) THEN ((
                             qbit_permutation(c)[(i - k)]) + k) ELSE i ENDIF))))))))));

permute_plus_one: (INT, INT) -> circuit;

% permute_plus_one'def
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= k)
  => (((k + 2) <= n) => (permute_plus_one(k, n) = permute_place(swap, k, n)))));

% permute_plus_one'spec
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= k)
  => (((k + 2) <= n)
     => ((width(permute_plus_one(k, n)) = n)
        AND ((qbit_permutes(permute_plus_one(k, n)))
            AND (FORALL (i : INT):
                (((0 <= i) AND (i < n)) => ((qbit_permutation(
                permute_plus_one(k,
                n))[i]) = (IF (i = k) THEN (k + 1)
                          ELSE (IF (i = (k + 1)) THEN k ELSE i ENDIF) ENDIF)))))))));

up_to_image: (INT, INT, INT) -> circuit;

% up_to_image'def
  ASSERT
  (FORALL (k : INT, fk : INT, n : INT):
  (((0 <= k) AND (k <= fk))
  => ((fk < n)
     => (IF (k = fk) THEN (up_to_image(k, fk, n) = ids_permute(n)) ELSE (
        up_to_image(k, fk, n) = qbit_permute_sequence(up_to_image((k + 1),
        fk, n), permute_plus_one(k, n))) ENDIF))));

% up_to_image'spec
  ASSERT
  (FORALL (k : INT, fk : INT, n : INT):
  (((0 <= k) AND (k <= fk))
  => ((fk < n)
     => ((width(up_to_image(k, fk, n)) = n)
        AND ((qbit_permutes(up_to_image(k, fk, n)))
            AND (FORALL (i : INT):
                (((0 <= i) AND (i < n)) => ((qbit_permutation(up_to_image(k,
                fk,
                n))[i]) = (IF (i = k) THEN fk
                          ELSE (IF ((k < i) AND (i <= fk)) THEN (i - 1)
                               ELSE i ENDIF) ENDIF)))))))));

down_to_image: (INT, INT, INT) -> circuit;

% down_to_image'def
  ASSERT
  (FORALL (k : INT, fk : INT, n : INT):
  (((0 <= fk) AND (fk <= k))
  => ((k < n)
     => (IF (k = fk) THEN (down_to_image(k, fk, n) = ids_permute(n)) ELSE (
        down_to_image(k, fk, n) = qbit_permute_sequence(
        down_to_image((k - 1), fk, n), permute_plus_one((k - 1), n))) ENDIF))));

% down_to_image'spec
  ASSERT
  (FORALL (k : INT, fk : INT, n : INT):
  (((0 <= fk) AND (fk <= k))
  => ((k < n)
     => ((width(down_to_image(k, fk, n)) = n)
        AND ((qbit_permutes(down_to_image(k, fk, n)))
            AND (FORALL (i : INT):
                (((0 <= i) AND (i < n)) => ((qbit_permutation(
                down_to_image(k, fk,
                n))[i]) = (IF (i = k) THEN fk
                          ELSE (IF ((fk <= i) AND (i <= k)) THEN (i + 1)
                               ELSE i ENDIF) ENDIF)))))))));

permute_up: (INT, INT, INT) -> circuit;

% permute_up'def
  ASSERT
  (FORALL (k : INT, fk : INT, n : INT):
  (((0 <= k) AND ((k <= fk) AND (fk < n)))
  => ((fk < n)
     => (IF (k = fk) THEN (permute_up(k, fk, n) = ids_permute(n)) ELSE (
        permute_up(k, fk, n) = qbit_permute_sequence(down_to_image((fk - 1),
        k, n), up_to_image(k, fk, n))) ENDIF))));

% permute_up'spec
  ASSERT
  (FORALL (k : INT, fk : INT, n : INT):
  (((0 <= k) AND ((k <= fk) AND (fk < n)))
  => ((fk < n)
     => ((width(permute_up(k, fk, n)) = n)
        AND ((qbit_permutes(permute_up(k, fk, n)))
            AND (FORALL (i : INT):
                (((0 <= i) AND (i < n)) => ((qbit_permutation(permute_up(k,
                fk,
                n))[i]) = (IF (i = k) THEN fk
                          ELSE (IF (i = fk) THEN k ELSE i ENDIF) ENDIF)))))))));

permute_atom: (INT, INT, INT) -> circuit;

% permute_atom'def
  ASSERT
  (FORALL (k : INT, fk : INT, n : INT):
  (((0 <= k) AND (k < n))
  => (((0 <= fk) AND (fk < n))
     => (IF (k <= fk) THEN (permute_atom(k, fk, n) = permute_up(k, fk, n))
        ELSE (permute_atom(k, fk, n) = permute_up(fk, k, n)) ENDIF))));

% permute_atom'spec
  ASSERT
  (FORALL (k : INT, fk : INT, n : INT):
  (((0 <= k) AND (k < n))
  => (((0 <= fk) AND (fk < n))
     => ((width(permute_atom(k, fk, n)) = n)
        AND ((qbit_permutes(permute_atom(k, fk, n)))
            AND (((qbit_permutation(permute_atom(k, fk, n))[k]) = fk)
                AND (((qbit_permutation(permute_atom(k, fk, n))[fk]) = k)
                    AND (FORALL (i : INT):
                        (((0 <= i) AND (i < n))
                        => ((NOT (i = k))
                           => ((NOT (i = fk)) => ((qbit_permutation(
                              permute_atom(k, fk, n))[i]) = i))))))))))));

permutation_circuit_pre: (INT, INT, (ARRAY INT OF INT)) -> circuit;

% permutation_circuit_pre'def
  ASSERT
  (FORALL (k : INT, n : INT, f : (ARRAY INT OF INT)):
  ((0 < n)
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
     n))))
     => (((0 <= k) AND (k < n))
        => (IF (k = (n - 1)) THEN (permutation_circuit_pre(k, n, f) = 
           permute_atom((c_inv_func_int(f, n)[(n - 1)]), (n - 1), n))
           ELSE (LET o = permutation_circuit_pre((k + 1), n, f) IN (
                permutation_circuit_pre(k, n, f) = qbit_permute_sequence(
                permute_atom(k, (qbit_permutation(o)[(c_inv_func_int(f,
                n)[k])]), n), o))) ENDIF)))));

% permutation_circuit_pre'spec
  ASSERT
  (FORALL (k : INT, n : INT, f : (ARRAY INT OF INT)):
  ((0 < n)
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
     n))))
     => (((0 <= k) AND (k < n))
        => ((width(permutation_circuit_pre(k, n, f)) = n)
           AND ((qbit_permutes(permutation_circuit_pre(k, n, f)))
               AND ((FORALL (i : INT):
                    (((k <= i) AND (i < n)) => ((qbit_permutation(
                    permutation_circuit_pre(k, n, f))[(c_inv_func_int(f,
                    n)[i])]) = i)))
                   AND (FORALL (i : INT):
                       (((0 <= i) AND (i < k))
                       => ((0 <= (qbit_permutation(permutation_circuit_pre(k,
                          n, f))[(c_inv_func_int(f, n)[i])])) AND ((
                          qbit_permutation(permutation_circuit_pre(k, n,
                          f))[(c_inv_func_int(f, n)[i])]) < k)))))))))));

permutation_circuit: (INT, (ARRAY INT OF INT)) -> circuit;

% permutation_circuit'def
  ASSERT
  (FORALL (n : INT, f : (ARRAY INT OF INT)):
  ((0 < n)
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
     n)))) => (permutation_circuit(n, f) = permutation_circuit_pre(0, n, f)))));

fc1048: ((ARRAY INT OF INT), bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : bitvec, i : INT): ((fc1048(f,
  x)[i]) = (value(x)[(f[i])])));

% permutation_circuit'spec
  ASSERT
  (FORALL (n : INT, f : (ARRAY INT OF INT)):
  ((0 < n)
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
     n))))
     => ((width(permutation_circuit(n, f)) = n)
        AND ((qbit_permutes(permutation_circuit(n, f)))
            AND ((FORALL (i : INT):
                 (((0 <= i) AND (i < n)) => ((qbit_permutation(
                 permutation_circuit(n, f))[i]) = (f[i]))))
                AND ((FORALL (i : INT):
                     (((0 <= i) AND (i < n)) => ((qbit_permutation(
                     permutation_circuit(n, f))[(c_inv_func_int(f,
                     n)[i])]) = i)))
                    AND ((FORALL (x : bitvec):
                         ((length(x) = n) => (path_sem(permutation_circuit(n,
                         f), bv_to_ket(x)) = bv_to_ket(make_bv(fc1048(f, x),
                         n)))))
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT), i : INT):
                             (((0 <= i) AND (i < n)) => (basis_ket(
                             permutation_circuit(n, f), x, y,
                             i) = (x[(f[i])]))))
                            AND ((FORALL (x : (ARRAY INT OF INT),
                                 y : (ARRAY INT OF INT)): (ang_ind(
                                 permutation_circuit(n, f), x,
                                 y) = ang_zero))
                                AND ((width(permutation_circuit(n, f)) = n)
                                    AND (range(permutation_circuit(n,
                                    f)) = 0))))))))))));

with_permutation: (circuit, (ARRAY INT OF INT)) -> circuit;

fc577: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc578: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc579: (circuit, (ARRAY INT OF INT),
  (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : (ARRAY INT OF INT), i : INT): ((
  fc577(f, x)[i]) = (x[(f[i])])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : (ARRAY INT OF INT), i : INT): ((
  fc578(f, x)[i]) = (x[(f[i])])));

% fc'def
  ASSERT
  (FORALL (c : circuit, f : (ARRAY INT OF INT), x : (ARRAY INT OF INT),
  i : INT): ((fc579(c, f, x)[i]) = (x[(c_inv_func_int(f, width(c))[i])])));

% with_permutation'spec
  ASSERT
  (FORALL (c : circuit, f : (ARRAY INT OF INT)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, width(c))), t2tb6(
  to_fset(0, width(c)))))
  => ((size(with_permutation(c, f)) = size(c))
     AND ((ancillas(with_permutation(c, f)) = ancillas(c))
         AND ((width(with_permutation(c, f)) = width(c))
             AND ((range(with_permutation(c, f)) = range(c))
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT)): (ang_ind(with_permutation(c,
                      f), x, y) = ang_ind(c, fc577(f, x), y)))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)):
                          (FORALL (i : INT):
                          (((0 <= i) AND (i < width(c))) => (basis_ket(
                          with_permutation(c, f), x, y, i) = basis_ket(c, 
                          fc578(f, x), y, (c_inv_func_int(f, width(c))[i]))))))
                         AND ((FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)):
                              (FORALL (i : INT):
                              (((0 <= i) AND (i < width(c))) => (basis_ket(
                              with_permutation(c, f), fc579(c, f, x), y,
                              i) = basis_ket(c, x, y, (c_inv_func_int(f, 
                              width(c))[i]))))))
                             AND (with_permutation(c, f) = sequence(sequence(
                             permutation_circuit(width(c), f), c), 
                             permutation_circuit(width(c), c_inv_func_int(f, 
                             width(c))))))))))))));

c_swap_int: (INT, INT, INT) -> (ARRAY INT OF INT);

% c_swap_int'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (FORALL (i : INT): ((c_swap_int(t1, t2,
        n)[i]) = (IF (i = t1) THEN t2
                 ELSE (IF (i = t2) THEN t1 ELSE i ENDIF) ENDIF))))));

% c_swap_int'spec
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((FORALL (a : INT): ((a = t1) => ((c_swap_int(t1, t2, n)[a]) = t2)))
        AND ((FORALL (a : INT):
             ((a = t2) => ((c_swap_int(t1, t2, n)[a]) = t1)))
            AND ((FORALL (a : INT):
                 ((NOT (a = t1))
                 => ((NOT (a = t2)) => ((c_swap_int(t1, t2, n)[a]) = a))))
                AND ((p_bijective(int, int, t2tb7(c_swap_int(t1, t2, n)), 
                    t2tb6(to_fset(0, n)), t2tb6(to_fset(0, n))))
                    AND (FORALL (i : INT):
                        (((0 <= i) AND (i < n)) => ((c_inv_func_int(
                        c_swap_int(t1, t2, n), n)[i]) = (c_swap_int(t1, t2,
                        n)[i])))))))))));

with_int_swap: (circuit, INT, INT) -> circuit;

% with_int_swap'def
  ASSERT
  (FORALL (c : circuit, t1 : INT, t2 : INT):
  (((0 <= t1) AND (t1 < width(c)))
  => (((0 <= t2) AND (t2 < width(c))) => (with_int_swap(c, t1, t2) = 
     with_permutation(c, c_swap_int(t1, t2, width(c)))))));

fc580: (INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc581: (INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc582: (INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc583: (INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, x : (ARRAY INT OF INT), i : INT): ((fc580(t1,
  t2,
  x)[i]) = (x[(IF (i = t1) THEN t2
              ELSE (IF (i = t2) THEN t1 ELSE i ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, x : (ARRAY INT OF INT), i : INT): ((fc581(t1,
  t2,
  x)[i]) = (x[(IF (i = t1) THEN t2
              ELSE (IF (i = t2) THEN t1 ELSE i ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, x : (ARRAY INT OF INT), i : INT): ((fc582(t1,
  t2,
  x)[i]) = (x[(IF (i = t1) THEN t2
              ELSE (IF (i = t2) THEN t1 ELSE i ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, x : (ARRAY INT OF INT), i : INT): ((fc583(t1,
  t2,
  x)[i]) = (x[(IF (i = t1) THEN t2
              ELSE (IF (i = t2) THEN t1 ELSE i ENDIF) ENDIF)])));

% with_int_swap'spec
  ASSERT
  (FORALL (c : circuit, t1 : INT, t2 : INT):
  (((0 <= t1) AND (t1 < width(c)))
  => (((0 <= t2) AND (t2 < width(c)))
     => ((size(with_int_swap(c, t1, t2)) = size(c))
        AND ((ancillas(with_int_swap(c, t1, t2)) = ancillas(c))
            AND ((width(with_int_swap(c, t1, t2)) = width(c))
                AND ((range(with_int_swap(c, t1, t2)) = range(c))
                    AND ((FORALL (x : (ARRAY INT OF INT),
                         y : (ARRAY INT OF INT)): (ang_ind(with_int_swap(c,
                         t1, t2), x, y) = ang_ind(c, fc580(t1, t2, x), y)))
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)):
                             (FORALL (i : INT):
                             ((i = t1) => (basis_ket(with_int_swap(c, t1,
                             t2), x, y, i) = basis_ket(c, fc581(t1, t2, x),
                             y, t2)))))
                            AND ((FORALL (x : (ARRAY INT OF INT),
                                 y : (ARRAY INT OF INT)):
                                 (FORALL (i : INT):
                                 ((i = t2) => (basis_ket(with_int_swap(c, t1,
                                 t2), x, y, i) = basis_ket(c, fc582(t1, t2,
                                 x), y, t1)))))
                                AND (FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    (FORALL (i : INT):
                                    (((0 <= i) AND (i < width(c)))
                                    => ((NOT (i = t1))
                                       => ((NOT (i = t2)) => (basis_ket(
                                          with_int_swap(c, t1, t2), x, y,
                                          i) = basis_ket(c, fc583(t1, t2, x),
                                          y, i)))))))))))))))));

% permutation_circuit_equiv
  ASSERT
  (FORALL (n : INT, f : (ARRAY INT OF INT), fqt : (ARRAY INT OF INT)):
  ((0 < n)
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
     n))))
     => ((FORALL (x : INT): (((0 <= x) AND (x < n)) => ((f[x]) = (fqt[x]))))
        => (FORALL (x : matrix_complex):
           ((is_a_ket_l(x, n)) => (path_sem(permutation_circuit(n, f), x) = 
           path_sem(permutation_circuit(n, fqt), x))))))));

fc1049: ((ARRAY INT OF INT), bitvec) -> (ARRAY INT OF INT);

fc1050: ((ARRAY INT OF INT), bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : bitvec, i : INT): ((fc1049(f,
  x)[i]) = (value(x)[(f[i])])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), y : bitvec, i : INT): ((fc1050(f,
  y)[i]) = (value(y)[(f[i])])));

% with_permutation_get_ket
  ASSERT
  (FORALL (c : circuit, f : (ARRAY INT OF INT), x : bitvec, y : bitvec):
  ((length(x) = width(c))
  => ((length(y) = width(c))
     => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, width(c))), t2tb6(
        to_fset(0, width(c))))) => (tb2t(get(complex1, t2tb18(path_sem(
        with_permutation(c, f), bv_to_ket(x))), bv_to_int(y), 0)) = tb2t(
        get(complex1, t2tb18(path_sem(c, bv_to_ket(make_bv(fc1049(f, x), 
        width(c))))), bv_to_int(make_bv(fc1050(f, y), width(c))), 0)))))));

fc1051: ((ARRAY INT OF INT), matrix_complex) -> (ARRAY INT OF INT);

fc1052: (circuit, (ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : matrix_complex, j : INT): ((fc1051(f,
  x)[j]) = (value(ket_to_bv(x))[(f[j])])));

% fc'def
  ASSERT
  (FORALL (c : circuit, f : (ARRAY INT OF INT), i : INT, j : INT): ((
  fc1052(c, f, i)[j]) = (value(int_to_bv(i, width(c)))[(f[j])])));

% with_permutation_get_ket_
  ASSERT
  (FORALL (c : circuit, f : (ARRAY INT OF INT), x : matrix_complex, i : INT):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x))
     => (((0 <= i) AND (i < power(2, width(c))))
        => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, width(c))), 
           t2tb6(to_fset(0, width(c))))) => (tb2t(get(complex1, t2tb18(
           path_sem(with_permutation(c, f), x)), i, 0)) = tb2t(get(complex1, 
           t2tb18(path_sem(c, bv_to_ket(make_bv(fc1051(f, x), width(c))))), 
           bv_to_int(make_bv(fc1052(c, f, i), width(c))), 0))))))));

fc588: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT): ((fc588(k,
  n)[i]) = (IF (i < k) THEN ((i + n) - k) ELSE (i - k) ENDIF)));

% with_permutation_kronecker
  ASSERT
  (FORALL (c : circuit, im1 : matrix_complex, im_d : matrix_complex,
  ant : matrix_complex, ant_d : matrix_complex, k : INT, n : INT):
  ((width(c) = n)
  => (((0 <= k) AND (k < n))
     => ((is_a_ket_l(im1, k))
        => ((is_a_ket_l(im_d, (n - k)))
           => ((is_a_ket_l(ant, k))
              => ((is_a_ket_l(ant_d, (n - k)))
                 => ((is_a_ket_basis_elt(ant))
                    => ((is_a_ket_basis_elt(ant_d))
                       => ((path_sem(c, kronecker(ant, ant_d)) = 
                          kronecker(im1, im_d)) => (path_sem(
                          with_permutation(c, fc588(k, n)), kronecker(ant_d,
                          ant)) = kronecker(im_d, im1))))))))))));

fc589: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT): ((fc589(k,
  n)[i]) = (IF (i < k) THEN ((i + n) - k) ELSE (i - k) ENDIF)));

% with_permutation_kronecker_gen
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  ((width(c) = n)
  => (((0 <= k) AND (k < n))
     => (FORALL (im1 : matrix_complex, im_d : matrix_complex,
        ant : matrix_complex, ant_d : matrix_complex):
        ((is_a_ket_l(ant, k))
        => ((is_a_ket_l(ant_d, (n - k)))
           => ((is_a_ket_l(im1, k))
              => ((is_a_ket_l(im_d, (n - k)))
                 => ((is_a_ket_basis_elt(ant))
                    => ((is_a_ket_basis_elt(ant_d))
                       => ((path_sem(c, kronecker(ant, ant_d)) = 
                          kronecker(im1, im_d)) => (path_sem(
                          with_permutation(c, fc589(k, n)), kronecker(ant_d,
                          ant)) = kronecker(im_d, im1)))))))))))));

fc590: (INT, INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (n1 : INT, n2 : INT, n3 : INT, j : INT): ((fc590(n1, n2,
  n3)[j]) = (IF (j < n1) THEN j
            ELSE (IF (j < (n1 + n3)) THEN (j + n2) ELSE (j - n3) ENDIF) ENDIF)));

% permutation_three_blocks
  ASSERT
  (FORALL (n1 : INT, n2 : INT, n3 : INT, n : INT, x : bitvec, y : bitvec,
  z : bitvec):
  ((length(x) = n1)
  => ((length(y) = n2)
     => ((length(z) = n3)
        => ((0 <= n1)
           => ((0 <= n2)
              => ((0 <= n3)
                 => ((0 < n)
                    => ((n = ((n1 + n2) + n3)) => (path_sem(
                       permutation_circuit(n, fc590(n1, n2, n3)), kronecker(
                       kronecker(bv_to_ket(x), bv_to_ket(y)), 
                       bv_to_ket(z))) = kronecker(kronecker(bv_to_ket(x), 
                       bv_to_ket(z)), bv_to_ket(y))))))))))));

insert_qbits: (circuit, INT, INT, INT) -> circuit;

result67: (INT, INT, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, j : INT): ((result67(k, n,
  i)[j]) = (IF (j < k) THEN j
           ELSE (IF (j < n) THEN (j + i) ELSE ((j - n) + k) ENDIF) ENDIF)));

% insert_qbits'def
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, i : INT):
  ((width(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 < i) => (insert_qbits(c, k, n, i) = with_permutation(parallel(c, 
        ids(i)), result67(k, n, i)))))));

fc591: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc592: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc593: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), j : INT): ((
  fc591(k, n, i,
  x)[j]) = (x[(IF (j < k) THEN j
              ELSE (IF (j < n) THEN (j + i) ELSE ((j - n) + k) ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), ii : INT): ((
  fc592(k, n, i,
  x)[ii]) = (x[(IF (ii < k) THEN ii
               ELSE (IF (ii < n) THEN (ii + i) ELSE ((ii - n) + k) ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), ii : INT): ((
  fc593(k, n, i,
  x)[ii]) = (x[(IF (ii < k) THEN ii
               ELSE (IF (ii < n) THEN (ii + i) ELSE ((ii - n) + k) ENDIF) ENDIF)])));

% insert_qbits'spec
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, i : INT):
  ((width(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 < i)
        => ((ancillas(insert_qbits(c, k, n, i)) = ancillas(c))
           AND ((width(insert_qbits(c, k, n, i)) = (n + i))
               AND ((size(insert_qbits(c, k, n, i)) = size(c))
                   AND ((range(insert_qbits(c, k, n, i)) = range(c))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)): (ang_ind(insert_qbits(c,
                            k, n, i), x, y) = ang_ind(c, fc591(k, n, i, x),
                            y)))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (j : INT):
                                (((0 <= j) AND (j < k)) => (basis_ket(
                                insert_qbits(c, k, n, i), x, y, j) = 
                                basis_ket(c, fc592(k, n, i, x), y, j)))))
                               AND ((FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    (FORALL (j : INT):
                                    ((((k + i) <= j) AND (j < (n + i))) => (
                                    basis_ket(insert_qbits(c, k, n, i), x, y,
                                    j) = basis_ket(c, fc593(k, n, i, x), y,
                                    (j - i))))))
                                   AND (FORALL (x : (ARRAY INT OF INT),
                                       y : (ARRAY INT OF INT)):
                                       (FORALL (j : INT):
                                       (((k <= j) AND (j < (k + i))) => (
                                       basis_ket(insert_qbits(c, k, n, i), x,
                                       y, j) = (x[j]))))))))))))))));

insert_qbits_gen: (circuit, INT, INT, INT) -> circuit;

% insert_qbits_gen'def
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, i : INT):
  ((width(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 <= i)
        => (IF (0 < i) THEN (insert_qbits_gen(c, k, n, i) = insert_qbits(c,
           k, n, i)) ELSE (insert_qbits_gen(c, k, n, i) = c) ENDIF)))));

fc594: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc595: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc596: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), j : INT): ((
  fc594(k, n, i,
  x)[j]) = (x[(IF (j < k) THEN j
              ELSE (IF (j < n) THEN (j + i) ELSE ((j - n) + k) ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), ii : INT): ((
  fc595(k, n, i,
  x)[ii]) = (x[(IF (ii < k) THEN ii
               ELSE (IF (ii < n) THEN (ii + i) ELSE ((ii - n) + k) ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), ii : INT): ((
  fc596(k, n, i,
  x)[ii]) = (x[(IF (ii < k) THEN ii
               ELSE (IF (ii < n) THEN (ii + i) ELSE ((ii - n) + k) ENDIF) ENDIF)])));

% insert_qbits_gen'spec
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, i : INT):
  ((width(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 <= i)
        => ((ancillas(insert_qbits_gen(c, k, n, i)) = ancillas(c))
           AND ((width(insert_qbits_gen(c, k, n, i)) = (n + i))
               AND ((size(insert_qbits_gen(c, k, n, i)) = size(c))
                   AND ((range(insert_qbits_gen(c, k, n, i)) = range(c))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)): (ang_ind(
                            insert_qbits_gen(c, k, n, i), x, y) = ang_ind(c, 
                            fc594(k, n, i, x), y)))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (j : INT):
                                (((0 <= j) AND (j < k)) => (basis_ket(
                                insert_qbits_gen(c, k, n, i), x, y, j) = 
                                basis_ket(c, fc595(k, n, i, x), y, j)))))
                               AND ((FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    (FORALL (j : INT):
                                    ((((k + i) <= j) AND (j < (n + i))) => (
                                    basis_ket(insert_qbits_gen(c, k, n, i),
                                    x, y, j) = basis_ket(c, fc596(k, n, i,
                                    x), y, (j - i))))))
                                   AND (FORALL (x : (ARRAY INT OF INT),
                                       y : (ARRAY INT OF INT)):
                                       (FORALL (j : INT):
                                       (((k <= j) AND (j < (k + i))) => (
                                       basis_ket(insert_qbits_gen(c, k, n,
                                       i), x, y, j) = (x[j]))))))))))))))));

% insert_qbits_path_sem
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT, i : INT, x : bitvec,
  im1 : matrix_complex, im_d : matrix_complex):
  ((width(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 < i)
        => ((length(x) = (n + i))
           => ((is_a_ket_l(im1, k))
              => ((is_a_ket_l(im_d, (n - k)))
                 => ((path_sem(c, bv_to_ket(concat(hpart(x, k), tpart(x,
                    (k + i))))) = kronecker(im1, im_d)) => (path_sem(
                    insert_qbits(c, k, n, i), bv_to_ket(x)) = kronecker(im1, 
                    kronecker(bv_to_ket(htpart(x, k, i)), im_d)))))))))));

% cos_add
  ASSERT
  (FORALL (x : complex, xqt : complex):
  ((real_(x))
  => ((real_(xqt)) => (cos(infix_pldt(x, xqt)) = infix_mndt(infix_asdt(
     cos(x), cos(xqt)), infix_asdt(sin(x), sin(xqt)))))));

% sin_add
  ASSERT
  (FORALL (x : complex, xqt : complex):
  ((real_(x))
  => ((real_(xqt)) => (sin(infix_pldt(x, xqt)) = infix_pldt(infix_asdt(
     sin(x), cos(xqt)), infix_asdt(cos(x), sin(xqt)))))));

% cos_ang_add
  ASSERT
  (FORALL (theta : angle, thetaqt : angle): (cos_ang(ang_add(theta,
  thetaqt)) = infix_mndt(infix_asdt(cos_ang(theta), cos_ang(thetaqt)), 
  infix_asdt(sin_ang(theta), sin_ang(thetaqt)))));

% sin_ang_add
  ASSERT
  (FORALL (theta : angle, thetaqt : angle): (sin_ang(ang_add(theta,
  thetaqt)) = infix_pldt(infix_asdt(sin_ang(theta), cos_ang(thetaqt)), 
  infix_asdt(cos_ang(theta), sin_ang(thetaqt)))));

% cos_ang_add_rev
  ASSERT
  (FORALL (theta : angle, thetaqt : angle): (infix_mndt(infix_asdt(
  cos_ang(theta), cos_ang(thetaqt)), infix_asdt(sin_ang(theta), 
  sin_ang(thetaqt))) = cos_ang(ang_add(theta, thetaqt))));

% sin_ang_add_rev
  ASSERT
  (FORALL (theta : angle, thetaqt : angle): (infix_pldt(infix_asdt(
  sin_ang(theta), cos_ang(thetaqt)), infix_asdt(cos_ang(theta), 
  sin_ang(thetaqt))) = sin_ang(ang_add(theta, thetaqt))));

% sin_ang_add_rev_rev
  ASSERT
  (FORALL (theta : angle, thetaqt : angle): (infix_pldt(infix_asdt(
  cos_ang(theta), sin_ang(thetaqt)), infix_asdt(sin_ang(theta), 
  cos_ang(thetaqt))) = sin_ang(ang_add(theta, thetaqt))));

% sin_ang_inv
  ASSERT
  (FORALL (theta : angle): (sin_ang(ang_inv(theta)) = prefix_mndt(
  sin_ang(theta))));

% cos_ang_inv
  ASSERT
  (FORALL (theta : angle): (cos_ang(ang_inv(theta)) = cos_ang(theta)));

% sin_ang_inv_int
  ASSERT
  (FORALL (k : INT, n : INT): (sin_ang(infix_sldtsl((- k), n)) = prefix_mndt(
  sin_ang(infix_sldtsl(k, n)))));

% cos_ang_inv_int
  ASSERT TRUE;

% sin_ang_zero
  ASSERT (sin_ang(infix_sldtsl(1, 0)) = c_zero);

% sin_ang_one
  ASSERT (sin_ang(infix_sldtsl(1, 1)) = c_zero);

% sin_ang_two
  ASSERT (sin_ang(infix_sldtsl(1, 2)) = c_one);

% sin_ang_three
  ASSERT (sin_ang(infix_sldtsl(1, 3)) = pow_inv_sqrt_2(1));

% cos_ang_zero
  ASSERT (cos_ang(infix_sldtsl(1, 0)) = c_one);

% cos_ang_one
  ASSERT (cos_ang(infix_sldtsl(1, 1)) = prefix_mndt(c_one));

% cos_ang_two
  ASSERT (cos_ang(infix_sldtsl(1, 2)) = c_zero);

% cos_ang_three
  ASSERT (cos_ang(infix_sldtsl(1, 3)) = pow_inv_sqrt_2(1));

% cos_two_x
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (cos(infix_asdt(infix_pldt(c_one, c_one), x)) = infix_mndt(
  cpower(cos(x), 2), cpower(sin(x), 2)))));

% sin_two_x
  ASSERT
  (FORALL (x : complex, xqt : complex):
  ((real_(x))
  => ((real_(xqt)) => (sin(infix_asdt(infix_pldt(c_one, c_one), x)) = 
     infix_asdt(infix_asdt(infix_pldt(c_one, c_one), sin(x)), cos(x))))));

% cos_minus
  ASSERT
  (FORALL (x : complex): ((real_(x)) => (cos(prefix_mndt(x)) = cos(x))));

% sin_minus
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (sin(prefix_mndt(x)) = prefix_mndt(sin(x)))));

% symetries_vert
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((sin(infix_pldt(infix_sldt(pi, infix_pldt(c_one, c_one)), x)) = sin(
     infix_mndt(infix_sldt(pi, infix_pldt(c_one, c_one)), x))) AND (cos(
     infix_pldt(infix_sldt(pi, infix_pldt(c_one, c_one)), x)) = prefix_mndt(
     cos(infix_mndt(infix_sldt(pi, infix_pldt(c_one, c_one)), x)))))));

% pi_minus
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((sin(infix_mndt(pi, x)) = sin(x)) AND (cos(infix_mndt(pi, x)) = 
     prefix_mndt(cos(x))))));

% sin_plus_pi_pos
  ASSERT
  (FORALL (x : complex, k : INT):
  ((real_(x))
  => ((0 <= k)
     => (((even(k) = 0bin1) => (sin(infix_asdt(pi, infix_pldt(x, 
         i_to_c(k)))) = sin(infix_asdt(pi, x))))
        AND ((odd(k) = 0bin1) => (sin(infix_asdt(pi, infix_pldt(x, 
            i_to_c(k)))) = prefix_mndt(sin(infix_asdt(pi, x)))))))));

% sin_plus_pi
  ASSERT
  (FORALL (x : complex, k : INT):
  ((real_(x))
  => (((even(k) = 0bin1) => (sin(infix_asdt(pi, infix_pldt(x, i_to_c(k)))) = 
      sin(infix_asdt(pi, x))))
     AND ((odd(k) = 0bin1) => (sin(infix_asdt(pi, infix_pldt(x, 
         i_to_c(k)))) = prefix_mndt(sin(infix_asdt(pi, x))))))));

% cos_plus_pi_pos
  ASSERT
  (FORALL (x : complex, k : INT):
  ((real_(x))
  => ((0 <= k)
     => (((even(k) = 0bin1) => (cos(infix_asdt(pi, infix_pldt(x, 
         i_to_c(k)))) = cos(infix_asdt(pi, x))))
        AND ((odd(k) = 0bin1) => (cos(infix_asdt(pi, infix_pldt(x, 
            i_to_c(k)))) = prefix_mndt(cos(infix_asdt(pi, x)))))))));

% cos_plus_pi
  ASSERT
  (FORALL (x : complex, k : INT):
  ((real_(x))
  => (((even(k) = 0bin1) => (cos(infix_asdt(pi, infix_pldt(x, i_to_c(k)))) = 
      cos(infix_asdt(pi, x))))
     AND ((odd(k) = 0bin1) => (cos(infix_asdt(pi, infix_pldt(x, 
         i_to_c(k)))) = prefix_mndt(cos(infix_asdt(pi, x))))))));

% mod_sin_plus_pi
  ASSERT
  (FORALL (x : complex, k : INT):
  ((real_(x)) => (modulus(sin(infix_asdt(pi, infix_pldt(x, i_to_c(k))))) = 
  modulus(sin(infix_asdt(pi, x))))));

% mod_cos_plus_pi
  ASSERT
  (FORALL (x : complex, k : INT):
  ((real_(x)) => (modulus(cos(infix_asdt(pi, infix_pldt(x, i_to_c(k))))) = 
  modulus(cos(infix_asdt(pi, x))))));

% sin_mod_two_pi
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (sin(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  x)) = sin(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi), 
  dec_part(x))))));

% cos_mod_two_pi
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (cos(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi),
  x)) = cos(infix_asdt(infix_asdt(infix_pldt(c_one, c_one), pi), 
  dec_part(x))))));

% square_modulus_c_one_minus
  ASSERT
  (FORALL (phi : complex):
  ((real_(phi)) => (cpower(modulus(infix_mndt(c_one, ang_exp(
  real_to_ang(phi)))), 2) = infix_asdt(i_to_c(4), cpower(modulus(sin(
  infix_asdt(pi, phi))), 2)))));

% growing_sine
  ASSERT
  (FORALL (a : complex, b : complex):
  (((infix_lseqdt(c_zero, a))
   AND ((infix_lsdt(a, b)) AND (infix_lseqdt(b, infix_sldt(c_one, 
       infix_pldt(c_one, c_one))))))
  => (infix_lsdt(sin(infix_asdt(pi, a)), sin(infix_asdt(pi, b))))));

% non_null_sine
  ASSERT
  (FORALL (x : complex):
  (((infix_lsdt(c_zero, x)) AND (infix_lsdt(x, pi))) => (infix_lsdt(c_zero, 
  sin(x)))));

% bounded_by_sine
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => (((infix_lseqdt(c_zero, modulus(x))) AND (infix_lseqdt(modulus(x), 
      infix_sldt(c_one, infix_pldt(c_one, c_one)))))
     => (infix_lseqdt(modulus(infix_asdt(infix_pldt(c_one, c_one), x)), 
     modulus(sin(infix_asdt(pi, x))))))));

% bounded_by_sine_one
  ASSERT
  (FORALL (x : complex, k : INT):
  ((0 <= k)
  => ((real_(x))
     => ((infix_lseqdt(modulus(infix_mndt(x, c_one)), infix_sldt(c_one, 
        i_to_c(power(2, (k + 1)))))) => (infix_lseqdt(modulus(infix_asdt(
        infix_asdt(infix_pldt(c_one, c_one), infix_mndt(x, c_one)), i_to_c(
        power(2, k)))), modulus(sin(infix_asdt(infix_asdt(pi, i_to_c(power(2,
        k))), x)))))))));

% bounded_sine
  ASSERT
  (FORALL (x : complex):
  ((real_(x)) => (infix_lseqdt(modulus(sin(x)), modulus(x)))));

% non_c_zero_sin
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => ((infix_lsdt(c_zero, dec_part(x)))
     => (NOT (sin(infix_asdt(pi, x)) = c_zero)))));

% non_c_zero_sin_bounded_mod
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => (((infix_lsdt(c_zero, modulus(x))) AND (infix_lsdt(modulus(x), c_one)))
     => (NOT (sin(infix_asdt(pi, x)) = c_zero)))));

% non_ang_zero_bounded_mod
  ASSERT
  (FORALL (x : complex):
  ((real_(x))
  => (((infix_lsdt(c_zero, modulus(x))) AND (infix_lsdt(modulus(x), c_one)))
     => (NOT (real_to_ang(x) = ang_zero)))));

% non_ang_zero_int_to_ang
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 <= n)
  => ((NOT (mod(k, power(2, n)) = 0))
     => (NOT (infix_sldtsl(k, n) = ang_zero)))));

% modulus_ang_exp
  ASSERT (FORALL (a : angle): (modulus(ang_exp(a)) = c_one));

ket_zero_y: (INT) -> matrix_complex;

% ket_zero_y'def
  ASSERT (FORALL (k : INT): (ket_zero_y(k) = path_sem(ry(k), ket(1, 0))));

% ket_zero_y'spec
  ASSERT
  (FORALL (k : INT):
  ((ket_zero_y(k) = infix_asdtdt(pow_inv_sqrt_2(2), add_ket_l(infix_asdtdt(
  infix_pldt(ang_exp(infix_sldtsl((- 1), incr_abs(k))), ang_exp(
  infix_sldtsl(1, incr_abs(k)))), ket(1, 0)), infix_asdtdt(infix_asdt(im, 
  infix_mndt(ang_exp(infix_sldtsl((- 1), incr_abs(k))), ang_exp(
  infix_sldtsl(1, incr_abs(k))))), ket(1, 1)), 1))) AND (ket_zero_y(k) = 
  add_ket_l(infix_asdtdt(cos_ang(infix_sldtsl(1, incr_abs(k))), ket(1, 0)), 
  infix_asdtdt(sin_ang(infix_sldtsl(1, incr_abs(k))), ket(1, 1)), 1))));

ket_one_y: (INT) -> matrix_complex;

% ket_one_y'def
  ASSERT (FORALL (k : INT): (ket_one_y(k) = path_sem(ry(k), ket(1, 1))));

% ket_one_y'spec
  ASSERT
  (FORALL (k : INT):
  ((ket_one_y(k) = infix_asdtdt(pow_inv_sqrt_2(2), add_ket_l(infix_asdtdt(
  infix_asdt(prefix_mndt(im), infix_mndt(ang_exp(infix_sldtsl((- 1), 
  incr_abs(k))), ang_exp(infix_sldtsl(1, incr_abs(k))))), ket(1, 0)), 
  infix_asdtdt(infix_pldt(ang_exp(infix_sldtsl((- 1), incr_abs(k))), ang_exp(
  infix_sldtsl(1, incr_abs(k)))), ket(1, 1)), 1))) AND (ket_one_y(k) = 
  add_ket_l(infix_asdtdt(prefix_mndt(sin_ang(infix_sldtsl(1, incr_abs(k)))), 
  ket(1, 0)), infix_asdtdt(cos_ang(infix_sldtsl(1, incr_abs(k))), ket(1, 1)),
  1))));

ket_zero_z: (INT) -> matrix_complex;

% ket_zero_z'def
  ASSERT (FORALL (k : INT): (ket_zero_z(k) = path_sem(rz_(k), ket(1, 0))));

% ket_zero_z'spec
  ASSERT
  (FORALL (k : INT): (ket_zero_z(k) = infix_asdtdt(ang_exp(
  infix_sldtsl((- 1), incr_abs(k))), ket(1, 0))));

ket_one_z: (INT) -> matrix_complex;

% ket_one_z'def
  ASSERT (FORALL (k : INT): (ket_one_z(k) = path_sem(rz_(k), ket(1, 1))));

% ket_one_z'spec
  ASSERT
  (FORALL (k : INT): (ket_one_z(k) = infix_asdtdt(ang_exp(infix_sldtsl(1, 
  incr_abs(k))), ket(1, 1))));

% path_sem_ry_add_zero
  ASSERT
  (FORALL (k : INT): (path_sem(ry((- k)), ket_zero_y(k)) = ket(1, 0)));

% path_sem_ry_add_one
  ASSERT (FORALL (k : INT): (path_sem(ry((- k)), ket_one_y(k)) = ket(1, 1)));

% path_sem_ry_add
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem(ry((- k)), path_sem(ry(k), x)) = x)));

% path_sem_ry_twice_zero
  ASSERT
  (FORALL (k : INT): (path_sem(ry(incr_abs(k)), ket_zero_y(incr_abs(k))) = 
  ket_zero_y(k)));

% path_sem_ry_twice_one
  ASSERT
  (FORALL (k : INT): (path_sem(ry(incr_abs(k)), ket_one_y(incr_abs(k))) = 
  ket_one_y(k)));

% path_sem_ry_twice
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem(ry(incr_abs(k)), path_sem(ry(incr_abs(k)),
  x)) = path_sem(ry(k), x))));

% ket_zero_inv_y
  ASSERT (FORALL (k : INT): (path_sem_xx(ket_zero_y(k)) = ket_one_y((- k))));

% ket_one_inv_y
  ASSERT (FORALL (k : INT): (path_sem_xx(ket_one_y(k)) = ket_zero_y((- k))));

% ket_inv_y
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem_xx(path_sem(ry(k), x)) = path_sem(
  ry((- k)), path_sem_xx(x)))));

% ket_inv_y_rev
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem(ry((- k)), path_sem_xx(x)) = path_sem_xx(
  path_sem(ry(k), x)))));

% ket_zero_inv_z
  ASSERT (FORALL (k : INT): (path_sem_xx(ket_zero_z(k)) = ket_one_z((- k))));

% ket_one_inv_z
  ASSERT (FORALL (k : INT): (path_sem_xx(ket_one_z(k)) = ket_zero_z((- k))));

% ket_inv_z
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem_xx(path_sem(rz_(k), x)) = path_sem(
  rz_((- k)), path_sem_xx(x)))));

% ket_inv_z_rev
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem(rz_((- k)), path_sem_xx(x)) = path_sem_xx(
  path_sem(rz_(k), x)))));

contph: (INT) -> circuit;

% contph'def
  ASSERT (FORALL (k : INT): (contph(k) = parallel(rz(k), id)));

% contph'spec
  ASSERT
  (FORALL (k : INT):
  ((width(contph(k)) = 2)
  AND ((range(contph(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 2)) => (basis_ket(contph(k), x, y,
           i) = (x[i]))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
              ang_ind(contph(k), x, y) = infix_sldtsl((x[0]), k)))))));

% path_sem_contph_z
  ASSERT
  (FORALL (k : INT, bv : bitvec):
  ((length(bv) = 2)
  => (((value(bv)[0]) = 0) => (path_sem(contph(k), bv_to_ket(bv)) = 
     bv_to_ket(bv)))));

% path_sem_contph_o
  ASSERT
  (FORALL (k : INT, bv : bitvec):
  ((length(bv) = 2)
  => (((value(bv)[0]) = 1) => (path_sem(contph(k), bv_to_ket(bv)) = path_sem(
     place(phase(k), 1, 2), bv_to_ket(bv))))));

contrz_pre: (INT) -> circuit;

% contrz_pre'def
  ASSERT
  (FORALL (k : INT): (contrz_pre(k) = sequence(sequence(place(rz(
  incr_abs(k)), 1, 2), cnot), place(rz((- incr_abs(k))), 1, 2))));

% contrz_pre'spec
  ASSERT
  (FORALL (k : INT):
  ((width(contrz_pre(k)) = 2)
  AND ((range(contrz_pre(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 2)) => (basis_ket(contrz_pre(k), x, y, i) = 
           basis_ket(cnot, x, y, i))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
              ((binary_l(x, 2)) => (ang_ind(contrz_pre(k), x, y) = 
              phase_inv_((1 - (x[1])), infix_sldtsl((x[0]), incr_abs(k))))))))));

contrz_: (INT) -> circuit;

% contrz_'def
  ASSERT (FORALL (k : INT): (contrz_(k) = sequence(contrz_pre(k), cnot)));

% contrz_'spec
  ASSERT
  (FORALL (k : INT):
  ((width(contrz_(k)) = 2)
  AND ((range(contrz_(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 2))
           => ((binary_l(x, 2)) => (basis_ket(contrz_(k), x, y, i) = (x[i])))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
              ((binary_l(x, 2)) => (ang_ind(contrz_(k), x, y) = 
              phase_inv_((1 - (x[1])), infix_sldtsl((x[0]), incr_abs(k))))))))));

contrz: (INT) -> circuit;

% contrz'def
  ASSERT
  (FORALL (k : INT): (contrz(k) = sequence(contrz_(k), contph(incr_abs(k)))));

% contrz'spec
  ASSERT
  (FORALL (k : INT):
  ((width(contrz(k)) = 2)
  AND ((range(contrz(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 2))
           => ((binary_l(x, 2)) => (basis_ket(contrz(k), x, y, i) = (x[i])))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
              ((binary_l(x, 2)) => (ang_ind(contrz(k), x, y) = 
              infix_sldtsl(((x[0]) * (x[1])), k))))))));

% path_sem_contrz_z
  ASSERT
  (FORALL (k : INT, bv : bitvec):
  ((length(bv) = 2)
  => (((value(bv)[0]) = 0) => (path_sem(contrz(k), bv_to_ket(bv)) = 
     bv_to_ket(bv)))));

% path_sem_contrz_o
  ASSERT
  (FORALL (k : INT, bv : bitvec):
  ((length(bv) = 2)
  => (((value(bv)[0]) = 1) => (path_sem(contrz(k), bv_to_ket(bv)) = path_sem(
     place(rz(k), 1, 2), bv_to_ket(bv))))));

contrz1_2: (INT) -> circuit;

% contrz1_2'def
  ASSERT (FORALL (k : INT): (contrz1_2(k) = parallel(contrz(k), id)));

% contrz1_2'spec
  ASSERT
  (FORALL (k : INT):
  ((width(contrz1_2(k)) = 3)
  AND ((range(contrz1_2(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 2))
           => ((binary_l(x, 2)) => (basis_ket(contrz1_2(k), x, y,
              i) = (x[i])))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
              ((binary_l(x, 3)) => (ang_ind(contrz1_2(k), x, y) = 
              infix_sldtsl(((x[0]) * (x[1])), k))))))));

swap_1_2_in3: circuit;

% swap_1_2_in3'def
  ASSERT
  ((width(swap_1_2_in3) = 3)
  AND ((range(swap_1_2_in3) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 2)) => (basis_ket(swap_1_2_in3, x, y,
           i) = (x[(IF (i = 0) THEN 1
                   ELSE (IF (i = 1) THEN 0 ELSE i ENDIF) ENDIF)]))))
          AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
               ang_ind(swap_1_2_in3, x, y) = infix_sldtsl(0, 1)))
              AND (FORALL (x : matrix_complex, y : matrix_complex,
                  z : matrix_complex):
                  ((is_a_ket_l(x, 1))
                  => ((is_a_ket_l(y, 1))
                     => ((is_a_ket_l(z, 1)) => (path_sem(swap_1_2_in3, 
                        kronecker(kronecker(x, y), z)) = kronecker(
                        kronecker(y, x), z))))))))));

swap_2_3_in3: circuit;

% swap_2_3_in3'def
  ASSERT
  ((width(swap_2_3_in3) = 3)
  AND ((range(swap_2_3_in3) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 2)) => (basis_ket(swap_2_3_in3, x, y,
           i) = (x[(IF (i = 0) THEN i
                   ELSE (IF (i = 1) THEN 2 ELSE 1 ENDIF) ENDIF)]))))
          AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
               ang_ind(swap_2_3_in3, x, y) = infix_sldtsl(0, 1)))
              AND (FORALL (x : matrix_complex, y : matrix_complex,
                  z : matrix_complex):
                  ((is_a_ket_l(x, 1))
                  => ((is_a_ket_l(y, 1))
                     => ((is_a_ket_l(z, 1)) => (path_sem(swap_2_3_in3, 
                        kronecker(kronecker(x, y), z)) = kronecker(
                        kronecker(x, z), y))))))))));

contrz1_3: (INT) -> circuit;

% contrz1_3'def
  ASSERT
  (FORALL (k : INT): (contrz1_3(k) = insert_qbits(contrz(k), 1, 2, 1)));

% contrz1_3'spec
  ASSERT
  (FORALL (k : INT):
  ((width(contrz1_3(k)) = 3)
  AND ((range(contrz1_3(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 3))
           => ((binary_l(x, 3)) => (basis_ket(contrz1_3(k), x, y,
              i) = (x[i])))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
              ((binary_l(x, 3)) => (ang_ind(contrz1_3(k), x, y) = 
              infix_sldtsl(((x[0]) * (x[2])), k))))))));

contrz2_3: (INT) -> circuit;

% contrz2_3'def
  ASSERT (FORALL (k : INT): (contrz2_3(k) = parallel(id, contrz(k))));

% contrz2_3'spec
  ASSERT
  (FORALL (k : INT):
  ((width(contrz2_3(k)) = 3)
  AND ((range(contrz2_3(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 3))
           => ((binary_l(x, 3)) => (basis_ket(contrz2_3(k), x, y,
              i) = (x[i])))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
              ((binary_l(x, 3)) => (ang_ind(contrz2_3(k), x, y) = 
              infix_sldtsl(((x[1]) * (x[2])), k))))))));

contrz_xor_3: (INT) -> circuit;

% contrz_xor_3'spec
  ASSERT
  (FORALL (k : INT):
  ((width(contrz_xor_3(k)) = 3)
  AND ((range(contrz_xor_3(k)) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 3))
           => ((binary_l(x, 3)) => (basis_ket(contrz_xor_3(k), x, y,
              i) = (x[i])))))
          AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
              ((binary_l(x, 3)) => (ang_ind(contrz_xor_3(k), x, y) = 
              infix_sldtsl(((((x[0]) * (1 - (x[1]))) + ((x[1]) * (1 - (x[0])))) * (x[2])),
              k))))))));

% path_sem_xx_plus
  ASSERT (path_sem_xx(pps_apply(pps_hadamard, ket(1, 0))) = 
  pps_apply(pps_hadamard, ket(1, 0)));

% path_sem_xx_minus
  ASSERT (path_sem_xx(pps_apply(pps_hadamard, ket(1, 1))) = infix_asdtdt(
  prefix_mndt(c_one), pps_apply(pps_hadamard, ket(1, 1))));

% ket_zero_y2
  ASSERT
  ((ket_zero_y(2) = pps_apply(pps_hadamard, ket(1, 0))) AND (ket_zero_y(2) = 
  path_sem_xx(pps_apply(pps_hadamard, ket(1, 0)))));

% ket_one_y2
  ASSERT
  ((ket_one_y(2) = infix_asdtdt(prefix_mndt(c_one), pps_apply(pps_hadamard, 
  ket(1, 1)))) AND (ket_one_y(2) = path_sem_xx(pps_apply(pps_hadamard, ket(1,
  1)))));

contry_pre_: (INT, matrix_complex) -> circuit;

% contry_pre_'def
  ASSERT
  (FORALL (k : INT, y : matrix_complex):
  ((is_a_ket_l(y, 1)) => (contry_pre_(k, y) = sequence(sequence(place(ry((- 
  incr_abs(k))), 1, 2), cnot), place(ry(incr_abs(k)), 1, 2)))));

% contry_pre_'spec
  ASSERT
  (FORALL (k : INT, y : matrix_complex):
  ((is_a_ket_l(y, 1))
  => ((path_sem(contry_pre_(k, y), kronecker(ket(1, 0), y)) = kronecker(
     ket(1, 0), y))
     AND ((path_sem(contry_pre_(k, y), kronecker(ket(1, 1), y)) = kronecker(
         ket(1, 1), path_sem(ry(k), path_sem_xx(y)))) AND (width(
         contry_pre_(k, y)) = 2)))));

contry_pre: (INT) -> circuit;

% contry_pre'def
  ASSERT
  (FORALL (k : INT): (contry_pre(k) = sequence(sequence(place(ry((- 
  incr_abs(k))), 1, 2), cnot), place(ry(incr_abs(k)), 1, 2))));

% contry_pre'spec
  ASSERT
  (FORALL (k : INT):
  ((FORALL (y : matrix_complex):
   ((is_a_ket_l(y, 1)) => (path_sem(contry_pre(k), kronecker(ket(1, 0),
   y)) = kronecker(ket(1, 0), y))))
  AND ((FORALL (y : matrix_complex):
       ((is_a_ket_l(y, 1)) => (path_sem(contry_pre(k), kronecker(ket(1, 1),
       y)) = kronecker(ket(1, 1), path_sem(ry(k), path_sem_xx(y))))))
      AND (width(contry_pre(k)) = 2))));

contry: (INT) -> circuit;

% contry'def
  ASSERT (FORALL (k : INT): (contry(k) = sequence(contry_pre(k), cnot)));

% contry'spec
  ASSERT
  (FORALL (k : INT):
  ((FORALL (y : matrix_complex):
   ((is_a_ket_l(y, 1)) => (path_sem(contry(k), kronecker(ket(1, 0), y)) = 
   kronecker(ket(1, 0), y))))
  AND ((FORALL (y : matrix_complex):
       ((is_a_ket_l(y, 1)) => (path_sem(contry(k), kronecker(ket(1, 1),
       y)) = kronecker(ket(1, 1), path_sem(ry((- k)), y)))))
      AND (width(contry(k)) = 2))));

conth: circuit;

% conth'def
  ASSERT
  ((path_sem(conth, kronecker(ket(1, 0), ket(1, 0))) = kronecker(ket(1, 0), 
  ket(1, 0)))
  AND ((path_sem(conth, kronecker(ket(1, 0), ket(1, 1))) = kronecker(ket(1,
      0), ket(1, 1)))
      AND ((path_sem(conth, kronecker(ket(1, 1), ket(1, 0))) = kronecker(
          ket(1, 1), pps_apply(pps_hadamard, ket(1, 0))))
          AND ((path_sem(conth, kronecker(ket(1, 1), ket(1, 1))) = kronecker(
              ket(1, 1), pps_apply(pps_hadamard, ket(1, 1)))) AND (
              width(conth) = 2)))));

% conth_z
  ASSERT
  (FORALL (z : matrix_complex):
  ((is_a_ket_l(z, 1)) => (path_sem(conth, kronecker(ket(1, 0), z)) = 
  kronecker(ket(1, 0), z))));

% conth_o
  ASSERT
  (FORALL (z : matrix_complex):
  ((is_a_ket_l(z, 1)) => (path_sem(conth, kronecker(ket(1, 1), z)) = 
  kronecker(ket(1, 1), path_sem(hadamard, z)))));

conth1_3: circuit;

% conth1_3'def
  ASSERT
  ((FORALL (y : matrix_complex, z : matrix_complex):
   ((is_a_ket_l(y, 1))
   => ((is_a_ket_l(z, 1)) => (path_sem(conth1_3, kronecker(kronecker(ket(1,
      0), y), z)) = kronecker(kronecker(ket(1, 0), y), z)))))
  AND (FORALL (y : matrix_complex, z : matrix_complex):
      ((is_a_ket_l(y, 1))
      => ((is_a_ket_l(z, 1)) => (path_sem(conth1_3, kronecker(kronecker(
         ket(1, 1), y), z)) = kronecker(kronecker(ket(1, 1), y), 
         path_sem(hadamard, z)))))));

ccz: circuit;

% ccz'def
  ASSERT
  ((width(ccz) = 3)
  AND ((range(ccz) = 0)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
           (((0 <= i) AND (i < 3))
           => ((binary_l(x, 3)) => (basis_ket(ccz, x, y, i) = (x[i])))))
          AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((binary_l(x, 3)) => (ang_ind(ccz, x, y) = 
               infix_sldtsl((((x[0]) * (x[1])) * (x[2])), 1))))
              AND (FORALL (x : matrix_complex, y : matrix_complex,
                  z : matrix_complex):
                  ((is_a_ket_l(x, 1))
                  => ((is_a_ket_l(y, 1))
                     => ((is_a_ket_l(z, 1))
                        => ((is_a_ket_basis_elt(x))
                           => ((is_a_ket_basis_elt(y))
                              => ((is_a_ket_basis_elt(z)) => (path_sem(ccz, 
                                 kronecker(kronecker(x, y), z)) = kronecker(
                                 kronecker(x, y), infix_asdtdt(cpower(
                                 prefix_mndt(c_one), ((ket_to_int(x) * 
                                 ket_to_int(y)) * ket_to_int(z))), z))))))))))))));

% ccz_cont_null
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex, z : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_l(y, 1))
     => ((is_a_ket_l(z, 1))
        => ((is_a_ket_basis_elt(x))
           => ((is_a_ket_basis_elt(y))
              => ((NOT ((ket_to_int(x) * ket_to_int(y)) = 1)) => (
                 path_sem(ccz, kronecker(kronecker(x, y), z)) = kronecker(
                 kronecker(x, y), z)))))))));

% ccz_had_basis
  ASSERT
  ((FORALL (x : matrix_complex, y : matrix_complex):
   ((is_a_ket_l(x, 1))
   => ((is_a_ket_l(y, 1))
      => ((is_a_ket_basis_elt(x))
         => ((is_a_ket_basis_elt(y))
            => (((ket_to_int(x) * ket_to_int(y)) = 1) => (path_sem(ccz, 
               kronecker(kronecker(x, y), pps_apply(pps_hadamard, ket(1,
               0)))) = kronecker(kronecker(x, y), pps_apply(pps_hadamard, 
               ket(1, 1))))))))))
  AND (FORALL (x : matrix_complex, y : matrix_complex):
      ((is_a_ket_l(x, 1))
      => ((is_a_ket_l(y, 1))
         => ((is_a_ket_basis_elt(x))
            => ((is_a_ket_basis_elt(y))
               => (((ket_to_int(x) * ket_to_int(y)) = 1) => (path_sem(ccz, 
                  kronecker(kronecker(x, y), pps_apply(pps_hadamard, ket(1,
                  1)))) = kronecker(kronecker(x, y), pps_apply(pps_hadamard, 
                  ket(1, 0)))))))))));

toffoli: circuit;

% toffoli'def
  ASSERT
  ((width(toffoli) = 3)
  AND ((FORALL (x : matrix_complex, y : matrix_complex, z : matrix_complex):
       ((is_a_ket_l(x, 1))
       => ((is_a_ket_l(y, 1))
          => ((is_a_ket_l(z, 1))
             => ((is_a_ket_basis_elt(x))
                => ((is_a_ket_basis_elt(y))
                   => ((is_a_ket_basis_elt(z)) => (path_sem(toffoli, 
                      kronecker(kronecker(x, y), z)) = kronecker(kronecker(x,
                      y), ket(1, mod((ket_to_int(z) + (ket_to_int(x) * 
                      ket_to_int(y))), 2)))))))))))
      AND ((FORALL (bv : bitvec):
           ((length(bv) = 3)
           => (((value(bv)[0]) = 0) => (path_sem(toffoli, bv_to_ket(bv)) = 
              bv_to_ket(bv)))))
          AND (FORALL (bv : bitvec):
              ((length(bv) = 3)
              => (((value(bv)[0]) = 1) => (path_sem(toffoli, 
                 bv_to_ket(bv)) = path_sem(place(cnot, 1, 3), 
                 bv_to_ket(bv)))))))));

toffoli_cont_1_3: circuit;

% toffoli_cont_1_3'def
  ASSERT
  ((width(toffoli_cont_1_3) = 3)
  AND (FORALL (x : matrix_complex, y : matrix_complex, z : matrix_complex):
      ((is_a_ket_l(x, 1))
      => ((is_a_ket_l(y, 1))
         => ((is_a_ket_l(z, 1))
            => ((is_a_ket_basis_elt(x))
               => ((is_a_ket_basis_elt(y))
                  => ((is_a_ket_basis_elt(z)) => (path_sem(toffoli_cont_1_3, 
                     kronecker(kronecker(x, y), z)) = kronecker(kronecker(x, 
                     ket(1, mod((ket_to_int(y) + (ket_to_int(x) * 
                     ket_to_int(z))), 2))), z))))))))));

% toffoli_cont_1_3_id
  ASSERT
  (FORALL (bv : bitvec):
  ((length(bv) = 3)
  => ((((value(bv)[0]) = 1) => ((value(bv)[2]) = 0)) => (
     path_sem(toffoli_cont_1_3, bv_to_ket(bv)) = bv_to_ket(bv)))));

fredkin: circuit;

% fredkin'def
  ASSERT
  ((width(fredkin) = 3)
  AND ((FORALL (x : matrix_complex, y : matrix_complex, z : matrix_complex):
       ((is_a_ket_l(x, 1))
       => ((is_a_ket_l(y, 1))
          => ((is_a_ket_l(z, 1))
             => ((is_a_ket_basis_elt(x))
                => ((is_a_ket_basis_elt(y))
                   => ((is_a_ket_basis_elt(z)) => (path_sem(fredkin, 
                      kronecker(kronecker(x, y),
                      z)) = (IF (x = ket(1, 0)) THEN kronecker(kronecker(x,
                            y), z) ELSE kronecker(kronecker(x, z), y) ENDIF)))))))))
      AND ((FORALL (bv : bitvec):
           ((length(bv) = 3)
           => (((value(bv)[0]) = 0) => (path_sem(fredkin, bv_to_ket(bv)) = 
              bv_to_ket(bv)))))
          AND (FORALL (bv : bitvec):
              ((length(bv) = 3)
              => (((value(bv)[0]) = 1) => (path_sem(fredkin, 
                 bv_to_ket(bv)) = path_sem(place(swap, 1, 3), 
                 bv_to_ket(bv)))))))));

notc: circuit;

% notc'def
  ASSERT
  ((range(notc) = 0)
  AND ((width(notc) = 2)
      AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
           (FORALL (i : INT):
           ((binary_l(x, 2))
           => ((i = 1) => (basis_ket(notc, x, y, i) = (x[i]))))))
          AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               (FORALL (i : INT):
               ((binary_l(x, 2))
               => ((i = 0) => (basis_ket(notc, x, y,
                  i) = (((x[0]) * (1 - (x[1]))) + ((x[1]) * (1 - (x[0])))))))))
              AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
                  ang_ind(notc, x, y) = ang_zero))))));

place_cnot: (INT, INT, INT) -> circuit;

% place_cnot'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1))
        => ((width(place_cnot(c, t1, n)) = n)
           AND ((range(place_cnot(c, t1, n)) = 0)
               AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                    (ang_ind(place_cnot(c, t1, n), x, y) = ang_zero))
                   AND ((FORALL (x : (ARRAY INT OF INT),
                        y : (ARRAY INT OF INT)):
                        (FORALL (i : INT):
                        (((0 <= i) AND (i < n))
                        => ((binary_l(x, n))
                           => ((NOT (i = t1)) => (basis_ket(place_cnot(c, t1,
                              n), x, y, i) = (x[i])))))))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)):
                            (FORALL (i : INT):
                            (((0 <= i) AND (i < n))
                            => ((binary_l(x, n))
                               => ((i = t1) => (basis_ket(place_cnot(c, t1,
                                  n), x, y,
                                  i) = (((x[c]) * (1 - (x[t1]))) + ((1 - (x[c])) * (x[t1])))))))))
                           AND (correct_path_sum_(place_cnot(c, t1, n), 
                           pps_cnot(c, t1, n))))))))))));

cont_zero: (circuit) -> circuit;

% cont_zero'spec
  ASSERT
  (FORALL (c : circuit):
  ((width(cont_zero(c)) = (width(c) + 1))
  AND ((FORALL (bv : bitvec):
       ((length(bv) = (width(c) + 1))
       => (((value(bv)[0]) = 0) => (path_sem(cont_zero(c), bv_to_ket(bv)) = 
          bv_to_ket(bv)))))
      AND ((FORALL (bv : bitvec):
           ((length(bv) = (width(c) + 1))
           => (((value(bv)[0]) = 1) => (path_sem(cont_zero(c), 
              bv_to_ket(bv)) = path_sem(place(c, 1, (width(c) + 1)), 
              bv_to_ket(bv))))))
          AND ((FORALL (x : matrix_complex):
               ((is_a_ket_l(x, width(c))) => (path_sem(cont_zero(c), 
               kronecker(ket(1, 0), x)) = kronecker(ket(1, 0), x))))
              AND (FORALL (x : matrix_complex):
                  ((is_a_ket_l(x, width(c))) => (path_sem(cont_zero(c), 
                  kronecker(ket(1, 1), x)) = kronecker(ket(1, 1), path_sem(c,
                  x))))))))));

% cont_zero_path_sem_kron
  ASSERT
  (FORALL (c : circuit, x : bitvec):
  ((length(x) = width(c))
  => ((path_sem(cont_zero(c), kronecker(ket(1, 0), bv_to_ket(x))) = 
     kronecker(ket(1, 0), bv_to_ket(x))) AND (path_sem(cont_zero(c), 
     kronecker(ket(1, 1), bv_to_ket(x))) = kronecker(ket(1, 1), path_sem(c, 
     bv_to_ket(x)))))));

% cont_zero_sem_kron'spec
  ASSERT
  (FORALL (c : circuit):
  ((width(cont_zero(c)) = (width(c) + 1))
  AND ((FORALL (x : matrix_complex, y : matrix_complex):
       ((sem(c, x, y)) => (sem(cont_zero(c), kronecker(ket(1, 1), x), 
       kronecker(ket(1, 1), y)))))
      AND (FORALL (x : matrix_complex):
          ((is_a_ket_l(x, width(c))) => (sem(cont_zero(c), kronecker(ket(1,
          0), x), kronecker(ket(1, 0), x))))))));

cont_last_qbit: (circuit) -> circuit;

result68: (circuit) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (c : circuit, i : INT): ((
  result68(c)[i]) = (IF (i < 1) THEN (i + width(c)) ELSE (i - 1) ENDIF)));

% cont_last_qbit'def
  ASSERT
  (FORALL (c : circuit): (cont_last_qbit(c) = with_permutation(cont_zero(c), 
  result68(c))));

% cont_last_qbit'spec
  ASSERT
  (FORALL (c : circuit):
  ((width(cont_last_qbit(c)) = (width(c) + 1))
  AND ((FORALL (bv : bitvec):
       ((length(bv) = width(c)) => (path_sem(cont_last_qbit(c), kronecker(
       bv_to_ket(bv), ket(1, 0))) = kronecker(bv_to_ket(bv), ket(1, 0)))))
      AND ((FORALL (bv : bitvec):
           ((length(bv) = width(c)) => (path_sem(cont_last_qbit(c), 
           kronecker(bv_to_ket(bv), ket(1, 1))) = kronecker(path_sem(c, 
           bv_to_ket(bv)), ket(1, 1)))))
          AND ((FORALL (bv : bitvec):
               ((length(bv) = (width(c) + 1))
               => (((value(bv)[width(c)]) = 0) => (path_sem(
                  cont_last_qbit(c), bv_to_ket(bv)) = bv_to_ket(bv)))))
              AND (FORALL (bv : bitvec):
                  ((length(bv) = (width(c) + 1))
                  => (((value(bv)[width(c)]) = 1) => (path_sem(
                     cont_last_qbit(c), bv_to_ket(bv)) = path_sem(place(c, 0,
                     (width(c) + 1)), bv_to_ket(bv)))))))))));

% cont_last_qbit_kron'spec
  ASSERT
  (FORALL (c : circuit):
  ((width(cont_last_qbit(c)) = (width(c) + 1))
  AND ((FORALL (x : matrix_complex, y : matrix_complex):
       ((sem(c, x, y)) => (sem(cont_last_qbit(c), kronecker(x, ket(1, 1)), 
       kronecker(y, ket(1, 1))))))
      AND (FORALL (x : matrix_complex):
          ((is_a_ket_l(x, width(c))) => (sem(cont_last_qbit(c), kronecker(x, 
          ket(1, 0)), kronecker(x, ket(1, 0)))))))));

cont_zero_gen: (circuit, INT, INT) -> circuit;

% cont_zero_gen'def
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  (((1 <= k) AND (k <= (n - width(c)))) => (cont_zero_gen(c, k, n) = 
  cont_zero(place(c, (k - 1), (n - 1))))));

% cont_zero_gen'spec
  ASSERT
  (FORALL (c : circuit, k : INT, n : INT):
  (((1 <= k) AND (k <= (n - width(c))))
  => ((width(cont_zero_gen(c, k, n)) = n)
     AND ((FORALL (bv : bitvec):
          ((length(bv) = n)
          => (((value(bv)[0]) = 0) => (path_sem(cont_zero_gen(c, k, n), 
             bv_to_ket(bv)) = bv_to_ket(bv)))))
         AND (FORALL (bv : bitvec):
             ((length(bv) = n)
             => (((value(bv)[0]) = 1) => (path_sem(cont_zero_gen(c, k, n), 
                bv_to_ket(bv)) = path_sem(place(c, k, n), bv_to_ket(bv))))))))));

cont_before: (circuit, INT, INT, INT) -> circuit;

% cont_before'def
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => ((co < k) => (cont_before(c, co, k, n) = place(cont_zero_gen(c,
        (k - co), (n - co)), co, n))))));

% cont_before'spec
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => ((co < k)
        => ((width(cont_before(c, co, k, n)) = n)
           AND ((FORALL (bv : bitvec):
                ((length(bv) = n)
                => (((value(bv)[co]) = 0) => (path_sem(cont_before(c, co, k,
                   n), bv_to_ket(bv)) = bv_to_ket(bv)))))
               AND (FORALL (bv : bitvec):
                   ((length(bv) = n)
                   => (((value(bv)[co]) = 1) => (path_sem(cont_before(c, co,
                      k, n), bv_to_ket(bv)) = path_sem(place(c, k, n), 
                      bv_to_ket(bv))))))))))));

cont_last_gen: (circuit, INT, INT) -> circuit;

% cont_last_gen'def
  ASSERT
  (FORALL (c : circuit, k : INT, co : INT):
  (((0 <= k) AND (k <= (co - width(c)))) => (cont_last_gen(c, k, co) = 
  cont_last_qbit(place(c, k, co)))));

% cont_last_gen'spec
  ASSERT
  (FORALL (c : circuit, k : INT, co : INT):
  (((0 <= k) AND (k <= (co - width(c))))
  => ((width(cont_last_gen(c, k, co)) = (co + 1))
     AND ((FORALL (bv : bitvec):
          ((length(bv) = (co + 1))
          => (((value(bv)[co]) = 0) => (path_sem(cont_last_gen(c, k, co), 
             bv_to_ket(bv)) = bv_to_ket(bv)))))
         AND (FORALL (bv : bitvec):
             ((length(bv) = (co + 1))
             => (((value(bv)[co]) = 1) => (path_sem(cont_last_gen(c, k, co), 
                bv_to_ket(bv)) = path_sem(place(c, k, (co + 1)), 
                bv_to_ket(bv))))))))));

cont_after: (circuit, INT, INT, INT) -> circuit;

% cont_after'def
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => ((0 <= k)
     => (((k + width(c)) <= co) => (cont_after(c, co, k, n) = place(
        cont_last_gen(c, k, co), 0, n))))));

% cont_after'spec
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => ((0 <= k)
     => (((k + width(c)) <= co)
        => ((width(cont_after(c, co, k, n)) = n)
           AND ((FORALL (bv : bitvec):
                ((length(bv) = n)
                => (((value(bv)[co]) = 0) => (path_sem(cont_after(c, co, k,
                   n), bv_to_ket(bv)) = bv_to_ket(bv)))))
               AND (FORALL (bv : bitvec):
                   ((length(bv) = n)
                   => (((value(bv)[co]) = 1) => (path_sem(cont_after(c, co,
                      k, n), bv_to_ket(bv)) = path_sem(place(c, k, n), 
                      bv_to_ket(bv))))))))))));

cont: (circuit, INT, INT, INT) -> circuit;

% cont'def
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co))
        => (IF (co < k) THEN (cont(c, co, k, n) = cont_before(c, co, k, n))
           ELSE (cont(c, co, k, n) = cont_after(c, co, k, n)) ENDIF)))));

% cont'spec
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co))
        => ((width(cont(c, co, k, n)) = n)
           AND ((FORALL (bv : bitvec):
                ((length(bv) = n)
                => (((value(bv)[co]) = 0) => (path_sem(cont(c, co, k, n), 
                   bv_to_ket(bv)) = bv_to_ket(bv)))))
               AND (FORALL (bv : bitvec):
                   ((length(bv) = n)
                   => (((value(bv)[co]) = 1) => (path_sem(cont(c, co, k, n), 
                      bv_to_ket(bv)) = path_sem(place(c, k, n), 
                      bv_to_ket(bv))))))))))));

% cont_circ_to_pps
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co)) => (correct_path_sum_(cont(c,
        co, k, n), pps_cont(circ_to_pps(c), co, k, n)))))));

% cont_pps
  ASSERT
  (FORALL (c : circuit, h : pps, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co))
        => ((correct_path_sum_(c, h)) => (correct_path_sum_(cont(c, co, k,
           n), pps_cont(h, co, k, n))))))));

% path_cont
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co))
        => ((FORALL (bv : bitvec):
            ((length(bv) = n)
            => (((value(bv)[co]) = 0) => (path_sem(cont(c, co, k, n), 
               bv_to_ket(bv)) = bv_to_ket(bv)))))
           AND (FORALL (bv : bitvec):
               ((length(bv) = n)
               => (((value(bv)[co]) = 1) => (path_sem(cont(c, co, k, n), 
                  bv_to_ket(bv)) = path_sem(place(c, k, n), bv_to_ket(bv)))))))))));

% path_cont_ketz
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT, x : matrix_complex):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co))
        => ((is_a_ket_l(x, n))
           => ((is_a_ket_basis_elt(x))
              => (((value(ket_to_bv(x))[co]) = 0) => (path_sem(cont(c, co, k,
                 n), x) = x))))))));

% path_cont_keto
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT, x : matrix_complex):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co))
        => ((is_a_ket_l(x, n))
           => ((is_a_ket_basis_elt(x))
              => (((value(ket_to_bv(x))[co]) = 1) => (path_sem(cont(c, co, k,
                 n), x) = path_sem(place(c, k, n), x)))))))));

% path_cont_ketz_gen
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co))
        => (FORALL (x : matrix_complex):
           ((is_a_ket_l(x, n))
           => ((is_a_ket_basis_elt(x))
              => (((value(ket_to_bv(x))[co]) = 0) => (path_sem(cont(c, co, k,
                 n), x) = x)))))))));

% path_cont_keto_gen
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co))
        => (FORALL (x : matrix_complex):
           ((is_a_ket_l(x, n))
           => ((is_a_ket_basis_elt(x))
              => (((value(ket_to_bv(x))[co]) = 1) => (path_sem(cont(c, co, k,
                 n), x) = path_sem(place(c, k, n), x))))))))));

% cont_kron_left_bv_to_ket
  ASSERT
  (FORALL (c : circuit, n : INT, x : matrix_complex):
  (((0 <= width(c)) AND (width(c) = (n - 1)))
  => ((is_a_ket_l(x, width(c)))
     => ((FORALL (y : bitvec):
         ((length(y) = 1)
         => (((value(y)[0]) = 0) => (path_sem(cont(c, (n - 1), 0, n), 
            kronecker(x, bv_to_ket(y))) = kronecker(x, bv_to_ket(y))))))
        AND (FORALL (y : bitvec):
            ((length(y) = 1)
            => (((value(y)[0]) = 1) => (path_sem(cont(c, (n - 1), 0, n), 
               kronecker(x, bv_to_ket(y))) = kronecker(path_sem(c, x), 
               bv_to_ket(y))))))))));

% place_kron_left_path
  ASSERT
  (FORALL (c : circuit, n : INT):
  ((width(c) < n)
  => (FORALL (x : matrix_complex, y : matrix_complex):
     ((is_a_ket_l(x, width(c)))
     => ((is_a_ket_l(y, (n - width(c)))) => (path_sem(place(c, 0, n), 
        kronecker(x, y)) = kronecker(path_sem(c, x), y)))))));

% place_kron_left_sem
  ASSERT
  (FORALL (c : circuit, n : INT):
  ((width(c) < n)
  => (FORALL (x : matrix_complex, y : matrix_complex, z : matrix_complex):
     ((is_a_ket_l(y, (n - width(c))))
     => ((sem(c, x, z)) => (sem(place(c, 0, n), kronecker(x, y), kronecker(z,
        y))))))));

% cont_kron_pat_right
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT, y : matrix_complex):
  (((0 <= co) AND (co < k))
  => ((n = (k + width(c)))
     => ((is_a_ket_l(y, width(c)))
        => ((FORALL (x : matrix_complex):
            ((is_a_ket_basis_elt(x))
            => ((is_a_ket_l(x, k))
               => (((value(ket_to_bv(x))[co]) = 0) => (path_sem(cont(c, co,
                  k, n), kronecker(x, y)) = kronecker(x, y))))))
           AND (FORALL (x : matrix_complex):
               ((is_a_ket_basis_elt(x))
               => ((is_a_ket_l(x, k))
                  => (((value(ket_to_bv(x))[co]) = 1) => (path_sem(cont(c,
                     co, k, n), kronecker(x, y)) = kronecker(x, path_sem(c,
                     y))))))))))));

% cont_kron_pat_right_gen
  ASSERT
  (FORALL (circ : circuit, c : INT, k : INT, n : INT):
  (((0 <= c) AND (c < k))
  => ((n = (k + width(circ)))
     => ((FORALL (y : matrix_complex):
         (FORALL (x : bitvec):
         ((is_a_ket_l(y, width(circ)))
         => ((length(x) = k)
            => (((value(x)[c]) = 0) => (path_sem(cont(circ, c, k, n), 
               kronecker(bv_to_ket(x), y)) = kronecker(bv_to_ket(x), y)))))))
        AND (FORALL (y : matrix_complex):
            (FORALL (x : bitvec):
            ((is_a_ket_l(y, width(circ)))
            => ((length(x) = k)
               => (((value(x)[c]) = 1) => (path_sem(cont(circ, c, k, n), 
                  kronecker(bv_to_ket(x), y)) = kronecker(bv_to_ket(x), 
                  path_sem(circ, y))))))))))));

% size_cont
  ASSERT
  (FORALL (c : circuit, co : INT, k : INT, n : INT, s2 : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width(c))))
     => (((k <= co) => ((k + width(c)) <= co))
        => ((size(c) <= s2) => (size(cont(c, co, k, n)) <= (cont_size * s2)))))));

place_xx: (INT, INT) -> circuit;

% place_xx'def
  ASSERT
  (FORALL (t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n)) => (place_xx(t1, n) = place(xx, t1, n))));

fc1053: (INT, bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, bv : bitvec, i : INT): ((fc1053(t1,
  bv)[i]) = (IF (i = t1) THEN (1 - (value(bv)[i])) ELSE (value(bv)[i]) ENDIF)));

% place_xx'spec
  ASSERT
  (FORALL (t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => ((width(place_xx(t1, n)) = n)
     AND ((FORALL (bv : bitvec):
          ((length(bv) = n) => (path_sem(place_xx(t1, n), bv_to_ket(bv)) = 
          bv_to_ket(make_bv(fc1053(t1, bv), n)))))
         AND ((FORALL (bv : bitvec):
              ((length(bv) = n) => (is_a_ket_basis_elt(path_sem(place_xx(t1,
              n), bv_to_ket(bv))))))
             AND ((FORALL (bv : bitvec):
                  ((length(bv) = n) => ((value(ket_to_bv(path_sem(
                  place_xx(t1, n), bv_to_ket(bv))))[t1]) = (1 - (
                  value(bv)[t1])))))
                 AND (FORALL (bv : bitvec):
                     (FORALL (i : INT):
                     ((length(bv) = n)
                     => (((0 <= i) AND (i < n))
                        => ((NOT (i = t1)) => ((value(ket_to_bv(path_sem(
                           place_xx(t1, n), bv_to_ket(bv))))[i]) = (
                           value(bv)[i])))))))))))));

place_cnot_ps: (INT, INT, INT) -> circuit;

% place_cnot_ps'def
  ASSERT
  (FORALL (c : INT, t1 : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1)) => (place_cnot_ps(c, t1, n) = place_cnot(c, t1, n))))));

% place_cnot_ps'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1))
        => ((width(place_cnot_ps(c, t1, n)) = n)
           AND ((FORALL (bv : bitvec):
                ((length(bv) = n) => (is_a_ket_basis_elt(path_sem(
                place_cnot_ps(c, t1, n), bv_to_ket(bv))))))
               AND ((FORALL (bv : bitvec):
                    ((length(bv) = n)
                    => (((value(bv)[c]) = 0) => (path_sem(place_cnot_ps(c,
                       t1, n), bv_to_ket(bv)) = bv_to_ket(bv)))))
                   AND (FORALL (bv : bitvec):
                       ((length(bv) = n)
                       => (((value(bv)[c]) = 1) => (path_sem(place_cnot_ps(c,
                          t1, n), bv_to_ket(bv)) = path_sem(place_xx(t1, n), 
                          bv_to_ket(bv)))))))))))));

place_toffoli_tcc: (INT, INT, INT, INT) -> circuit;

% place_toffoli_tcc'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= t1) AND ((t1 < c1) AND ((c1 < c2) AND (c2 < n)))) => (
  place_toffoli_tcc(c1, c2, t1, n) = cont(place_cnot_ps((c1 - t1), 0,
  ((c1 - t1) + 1)), c2, t1, n))));

fc1054: (INT, INT, INT, matrix_complex) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, x : matrix_complex, i : INT): ((
  fc1054(c1, c2, t1,
  x)[i]) = (IF (i = t1) THEN ((((value(ket_to_bv(x))[c1]) * (value(
           ket_to_bv(x))[c2])) * (1 - (value(ket_to_bv(x))[t1]))) + ((value(
           ket_to_bv(x))[t1]) * (1 - ((value(ket_to_bv(x))[c1]) * (value(
           ket_to_bv(x))[c2]))))) ELSE (value(ket_to_bv(x))[i]) ENDIF)));

% place_toffoli_tcc'spec
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= t1) AND ((t1 < c1) AND ((c1 < c2) AND (c2 < n))))
  => ((width(place_toffoli_tcc(c1, c2, t1, n)) = n)
     AND (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, n))
         => ((is_a_ket_basis_elt(x)) => (path_sem(place_toffoli_tcc(c1, c2,
            t1, n), x) = bv_to_ket(make_bv(fc1054(c1, c2, t1, x), n)))))))));

place_toffoli_ctc: (INT, INT, INT, INT) -> circuit;

% place_toffoli_ctc'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND ((c1 < t1) AND ((t1 < c2) AND (c2 < n)))) => (
  place_toffoli_ctc(c1, c2, t1, n) = cont(place_cnot_ps(0, (t1 - c1),
  ((t1 - c1) + 1)), c2, c1, n))));

fc1055: (INT, INT, INT, matrix_complex) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, x : matrix_complex, i : INT): ((
  fc1055(c1, c2, t1,
  x)[i]) = (IF (i = t1) THEN ((((value(ket_to_bv(x))[c1]) * (value(
           ket_to_bv(x))[c2])) * (1 - (value(ket_to_bv(x))[t1]))) + ((value(
           ket_to_bv(x))[t1]) * (1 - ((value(ket_to_bv(x))[c1]) * (value(
           ket_to_bv(x))[c2]))))) ELSE (value(ket_to_bv(x))[i]) ENDIF)));

% place_toffoli_ctc'spec
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND ((c1 < t1) AND ((t1 < c2) AND (c2 < n))))
  => ((width(place_toffoli_ctc(c1, c2, t1, n)) = n)
     AND (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, n))
         => ((is_a_ket_basis_elt(x)) => (path_sem(place_toffoli_ctc(c1, c2,
            t1, n), x) = bv_to_ket(make_bv(fc1055(c1, c2, t1, x), n)))))))));

place_toffoli_cct: (INT, INT, INT, INT) -> circuit;

% place_toffoli_cct'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND ((c1 < c2) AND ((c2 < t1) AND (t1 < n)))) => (
  place_toffoli_cct(c1, c2, t1, n) = cont(place_cnot_ps(0, (t1 - c2),
  ((t1 - c2) + 1)), c1, c2, n))));

fc1056: (INT, INT, INT, matrix_complex) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, x : matrix_complex, i : INT): ((
  fc1056(c1, c2, t1,
  x)[i]) = (IF (i = t1) THEN ((((value(ket_to_bv(x))[c1]) * (value(
           ket_to_bv(x))[c2])) * (1 - (value(ket_to_bv(x))[t1]))) + ((value(
           ket_to_bv(x))[t1]) * (1 - ((value(ket_to_bv(x))[c1]) * (value(
           ket_to_bv(x))[c2]))))) ELSE (value(ket_to_bv(x))[i]) ENDIF)));

% place_toffoli_cct'spec
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND ((c1 < c2) AND ((c2 < t1) AND (t1 < n))))
  => ((width(place_toffoli_cct(c1, c2, t1, n)) = n)
     AND (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, n))
         => ((is_a_ket_basis_elt(x)) => (path_sem(place_toffoli_cct(c1, c2,
            t1, n), x) = bv_to_ket(make_bv(fc1056(c1, c2, t1, x), n)))))))));

place_toffoli: (INT, INT, INT, INT) -> circuit;

% place_toffoli'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (c2 = t1))
                 => (LET mincont = min(c1, c2) IN
                    (LET maxcont = max(c1, c2) IN
                    (IF (t1 < mincont) THEN (place_toffoli(c1, c2, t1, n) = 
                    place_toffoli_tcc(mincont, maxcont, t1, n))
                    ELSE (IF (t1 < maxcont) THEN (place_toffoli(c1, c2, t1,
                         n) = place_toffoli_ctc(mincont, maxcont, t1, n))
                         ELSE (place_toffoli(c1, c2, t1, n) = 
                         place_toffoli_cct(mincont, maxcont, t1, n)) ENDIF) ENDIF))))))))));

fc1057: (INT, INT, INT, matrix_complex) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, x : matrix_complex, i : INT): ((
  fc1057(c1, c2, t1,
  x)[i]) = (IF (i = t1) THEN ((((value(ket_to_bv(x))[c1]) * (value(
           ket_to_bv(x))[c2])) * (1 - (value(ket_to_bv(x))[t1]))) + ((value(
           ket_to_bv(x))[t1]) * (1 - ((value(ket_to_bv(x))[c1]) * (value(
           ket_to_bv(x))[c2]))))) ELSE (value(ket_to_bv(x))[i]) ENDIF)));

% place_toffoli'spec
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (c2 = t1))
                 => ((width(place_toffoli(c1, c2, t1, n)) = n)
                    AND ((FORALL (x : matrix_complex):
                         ((is_a_ket_l(x, n))
                         => ((is_a_ket_basis_elt(x)) => (path_sem(
                            place_toffoli(c1, c2, t1, n), x) = bv_to_ket(
                            make_bv(fc1057(c1, c2, t1, x), n))))))
                        AND ((correct_path_sum_(place_toffoli(c1, c2, t1, n), 
                            pps_toffoli(c1, c2, t1, n)))
                            AND ((FORALL (bv : bitvec):
                                 ((length(bv) = n) => (is_a_ket_basis_elt(
                                 path_sem(place_toffoli(c1, c2, t1, n), 
                                 bv_to_ket(bv))))))
                                AND ((FORALL (x : matrix_complex):
                                     ((is_a_ket_l(x, n))
                                     => ((is_a_ket_basis_elt(x)) => ((value(
                                        ket_to_bv(path_sem(place_toffoli(c1,
                                        c2, t1, n), x)))[t1]) = ((((value(
                                        ket_to_bv(x))[c1]) * (value(
                                        ket_to_bv(x))[c2])) * (1 - (value(
                                        ket_to_bv(x))[t1]))) + ((value(
                                        ket_to_bv(x))[t1]) * (1 - ((value(
                                        ket_to_bv(x))[c1]) * (value(
                                        ket_to_bv(x))[c2])))))))))
                                    AND (FORALL (x : matrix_complex):
                                        (FORALL (i : INT):
                                        ((is_a_ket_l(x, n))
                                        => ((is_a_ket_basis_elt(x))
                                           => (((0 <= i) AND (i < n))
                                              => ((NOT (i = t1)) => ((value(
                                                 ket_to_bv(path_sem(
                                                 place_toffoli(c1, c2, t1,
                                                 n), x)))[i]) = (value(
                                                 ket_to_bv(x))[i]))))))))))))))))))));

% bricks_toffoli_path
  ASSERT (correct_path_sum_(toffoli, pps_toffoli(0, 1, 2, 3)));

place_fredkin: (INT, INT, INT, INT) -> circuit;

% place_fredkin'def
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (t1 = t2))
           => ((NOT (t1 = c))
              => ((NOT (t2 = c)) => (place_fredkin(c, t1, t2, n) = sequence(
                 sequence(place_toffoli(c, t1, t2, n), place_toffoli(c, t2,
                 t1, n)), place_toffoli(c, t1, t2, n))))))))));

fc1058: (INT, INT, INT, bitvec) -> (ARRAY INT OF INT);

fc1059: (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, bv : bitvec, i : INT): ((fc1058(c,
  t1, t2,
  bv)[i]) = (IF (i = t1) THEN (((value(bv)[c]) * (value(bv)[t2])) + ((1 - (
            value(bv)[c])) * (value(bv)[t1])))
            ELSE (IF (i = t2) THEN (((value(bv)[c]) * (
                 value(bv)[t1])) + ((1 - (value(bv)[c])) * (value(bv)[t2])))
                 ELSE (value(bv)[i]) ENDIF) ENDIF)));

% fc'def
  ASSERT (FORALL (us : INT): ((fc1059[us]) = 0));

% place_fredkin'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (t1 = t2))
           => ((NOT (t1 = c))
              => ((NOT (t2 = c))
                 => ((FORALL (bv : bitvec):
                     (FORALL (i : INT):
                     ((length(bv) = n)
                     => (((value(bv)[c]) = 0)
                        => (((0 <= i) AND (i < n)) => ((value(ket_to_bv(
                           path_sem(place_fredkin(c, t1, t2, n), 
                           bv_to_ket(bv))))[i]) = (value(bv)[i])))))))
                    AND ((FORALL (bv : bitvec):
                         ((length(bv) = n)
                         => (((value(bv)[c]) = 1) => ((value(ket_to_bv(
                            path_sem(place_fredkin(c, t1, t2, n), 
                            bv_to_ket(bv))))[t1]) = (value(bv)[t2])))))
                        AND ((FORALL (bv : bitvec):
                             ((length(bv) = n)
                             => (((value(bv)[c]) = 1) => ((value(ket_to_bv(
                                path_sem(place_fredkin(c, t1, t2, n), 
                                bv_to_ket(bv))))[t2]) = (value(bv)[t1])))))
                            AND ((FORALL (bv : bitvec):
                                 (FORALL (i : INT):
                                 ((length(bv) = n)
                                 => (((value(bv)[c]) = 1)
                                    => (((0 <= i) AND (i < n))
                                       => ((NOT (i = t1))
                                          => ((NOT (i = t2)) => ((value(
                                             ket_to_bv(path_sem(
                                             place_fredkin(c, t1, t2, n), 
                                             bv_to_ket(bv))))[i]) = (
                                             value(bv)[i])))))))))
                                AND ((FORALL (bv : bitvec):
                                     ((length(bv) = n)
                                     => (is_a_ket_basis_elt(path_sem(
                                     place_fredkin(c, t1, t2, n), 
                                     bv_to_ket(bv))))))
                                    AND ((FORALL (bv : bitvec):
                                         ((length(bv) = n) => (path_sem(
                                         place_fredkin(c, t1, t2, n), 
                                         bv_to_ket(bv)) = bv_to_ket(make_bv(
                                         fc1058(c, t1, t2, bv), n)))))
                                        AND ((FORALL (bv : bitvec):
                                             ((length(bv) = n) => (path_sem(
                                             place_fredkin(c, t1, t2, n), 
                                             bv_to_ket(bv)) = bv_to_ket(
                                             make_bv(tb2t7(infix_at(
                                             infix_mngt(int, int), 
                                             infix_mngt(int, int), infix_at(
                                             infix_mngt(infix_mngt(int, int), 
                                             infix_mngt(int, int)), 
                                             infix_mngt(int, int), t2tb55(
                                             h_basis_ket(pps_fredkin(c, t1,
                                             t2, n))), t2tb7(value(bv))), 
                                             t2tb7(fc1059))), n)))))
                                            AND ((correct_path_sum_(
                                                place_fredkin(c, t1, t2, n), 
                                                pps_fredkin(c, t1, t2, n)))
                                                AND (width(place_fredkin(c,
                                                t1, t2, n)) = n))))))))))))))));

% bricks_fredkin_path
  ASSERT (correct_path_sum_(fredkin, pps_fredkin(0, 1, 2, 3)));

swap_c: (INT, INT, INT) -> circuit;

% swap_c'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2)) => (swap_c(t1, t2, n) = permute_atom(t1, t2, n))))));

% swap_c'spec
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2))
        => ((width(swap_c(t1, t2, n)) = n) AND (correct_path_sum_(swap_c(t1,
           t2, n), pps_swap(t1, t2, n))))))));

wired_circuit : TYPE;

wired_circuit1: ty;

Skip: wired_circuit;

Phase1: (INT) -> wired_circuit;

Rx: (INT) -> wired_circuit;

Ry: (INT) -> wired_circuit;

Rz1: (INT) -> wired_circuit;

Rzp: (INT) -> wired_circuit;

Hadamard1: wired_circuit;

S: wired_circuit;

T: wired_circuit;

X: wired_circuit;

Y: wired_circuit;

Z: wired_circuit;

Bricks_Cnot: wired_circuit;

Bricks_Toffoli: wired_circuit;

Bricks_Fredkin: wired_circuit;

Bricks_Swap: wired_circuit;

Swap1: (INT, INT, INT) -> wired_circuit;

Cnot1: (INT, INT, INT) -> wired_circuit;

Toffoli: (INT, INT, INT, INT) -> wired_circuit;

Fredkin: (INT, INT, INT, INT) -> wired_circuit;

Place: (wired_circuit, INT, INT) -> wired_circuit;

Cont: (wired_circuit, INT, INT, INT) -> wired_circuit;

Sequence1: (wired_circuit, wired_circuit) -> wired_circuit;

Parallel1: (wired_circuit, wired_circuit) -> wired_circuit;

Ancillas1: (wired_circuit, INT) -> wired_circuit;

match_wired_circuit1: (ty, wired_circuit, uni, uni, uni, uni, uni, uni, uni,
  uni, uni, uni, uni, uni, uni, uni, uni, uni, uni, uni, uni, uni, uni, uni,
  uni, uni, uni) -> uni;

% match_wired_circuit_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : wired_circuit, x1 : uni, x2 : uni, x3 : uni, x4 : uni,
  x5 : uni, x6 : uni, x7 : uni, x8 : uni, x9 : uni, x10 : uni, x11 : uni,
  x12 : uni, x13 : uni, x14 : uni, x15 : uni, x16 : uni, x17 : uni,
  x18 : uni, x19 : uni, x20 : uni, x21 : uni, x22 : uni, x23 : uni,
  x24 : uni, x25 : uni): (sort(a, match_wired_circuit1(a, x, x1, x2, x3, x4,
  x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20,
  x21, x22, x23, x24, x25)))));

% match_wired_circuit_Skip
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z)) => (match_wired_circuit1(a, Skip, z, z1, z2, z3, z4, z5, z6,
  z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z))));

% match_wired_circuit_Phase
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni, u : INT):
  ((sort(a, z1)) => (match_wired_circuit1(a, Phase1(u), z, z1, z2, z3, z4,
  z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20,
  z21, z22, z23, z24) = z1))));

% match_wired_circuit_Rx
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni, u : INT):
  ((sort(a, z2)) => (match_wired_circuit1(a, Rx(u), z, z1, z2, z3, z4, z5,
  z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z2))));

% match_wired_circuit_Ry
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni, u : INT):
  ((sort(a, z3)) => (match_wired_circuit1(a, Ry(u), z, z1, z2, z3, z4, z5,
  z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z3))));

% match_wired_circuit_Rz
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni, u : INT):
  ((sort(a, z4)) => (match_wired_circuit1(a, Rz1(u), z, z1, z2, z3, z4, z5,
  z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z4))));

% match_wired_circuit_Rzp
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni, u : INT):
  ((sort(a, z5)) => (match_wired_circuit1(a, Rzp(u), z, z1, z2, z3, z4, z5,
  z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z5))));

% match_wired_circuit_Hadamard
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z6)) => (match_wired_circuit1(a, Hadamard1, z, z1, z2, z3, z4,
  z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20,
  z21, z22, z23, z24) = z6))));

% match_wired_circuit_S
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z7)) => (match_wired_circuit1(a, S, z, z1, z2, z3, z4, z5, z6,
  z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z7))));

% match_wired_circuit_T
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z8)) => (match_wired_circuit1(a, T, z, z1, z2, z3, z4, z5, z6,
  z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z8))));

% match_wired_circuit_X
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z9)) => (match_wired_circuit1(a, X, z, z1, z2, z3, z4, z5, z6,
  z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z9))));

% match_wired_circuit_Y
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z10)) => (match_wired_circuit1(a, Y, z, z1, z2, z3, z4, z5, z6,
  z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z10))));

% match_wired_circuit_Z
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z11)) => (match_wired_circuit1(a, Z, z, z1, z2, z3, z4, z5, z6,
  z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20, z21,
  z22, z23, z24) = z11))));

% match_wired_circuit_Bricks_Cnot
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z12)) => (match_wired_circuit1(a, Bricks_Cnot, z, z1, z2, z3, z4,
  z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20,
  z21, z22, z23, z24) = z12))));

% match_wired_circuit_Bricks_Toffoli
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z13)) => (match_wired_circuit1(a, Bricks_Toffoli, z, z1, z2, z3,
  z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19,
  z20, z21, z22, z23, z24) = z13))));

% match_wired_circuit_Bricks_Fredkin
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z14)) => (match_wired_circuit1(a, Bricks_Fredkin, z, z1, z2, z3,
  z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19,
  z20, z21, z22, z23, z24) = z14))));

% match_wired_circuit_Bricks_Swap
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni):
  ((sort(a, z15)) => (match_wired_circuit1(a, Bricks_Swap, z, z1, z2, z3, z4,
  z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18, z19, z20,
  z21, z22, z23, z24) = z15))));

% match_wired_circuit_Swap
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni, u : INT,
  u1 : INT, u2 : INT):
  ((sort(a, z16)) => (match_wired_circuit1(a, Swap1(u, u1, u2), z, z1, z2,
  z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18,
  z19, z20, z21, z22, z23, z24) = z16))));

% match_wired_circuit_Cnot
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni, u : INT,
  u1 : INT, u2 : INT):
  ((sort(a, z17)) => (match_wired_circuit1(a, Cnot1(u, u1, u2), z, z1, z2,
  z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18,
  z19, z20, z21, z22, z23, z24) = z17))));

% match_wired_circuit_Toffoli
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni, u : INT,
  u1 : INT, u2 : INT, u3 : INT):
  ((sort(a, z18)) => (match_wired_circuit1(a, Toffoli(u, u1, u2, u3), z, z1,
  z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17,
  z18, z19, z20, z21, z22, z23, z24) = z18))));

% match_wired_circuit_Fredkin
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni, u : INT,
  u1 : INT, u2 : INT, u3 : INT):
  ((sort(a, z19)) => (match_wired_circuit1(a, Fredkin(u, u1, u2, u3), z, z1,
  z2, z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17,
  z18, z19, z20, z21, z22, z23, z24) = z19))));

% match_wired_circuit_Place
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni,
  u : wired_circuit, u1 : INT, u2 : INT):
  ((sort(a, z20)) => (match_wired_circuit1(a, Place(u, u1, u2), z, z1, z2,
  z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18,
  z19, z20, z21, z22, z23, z24) = z20))));

% match_wired_circuit_Cont
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni,
  u : wired_circuit, u1 : INT, u2 : INT, u3 : INT):
  ((sort(a, z21)) => (match_wired_circuit1(a, Cont(u, u1, u2, u3), z, z1, z2,
  z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18,
  z19, z20, z21, z22, z23, z24) = z21))));

% match_wired_circuit_Sequence
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni,
  u : wired_circuit, u1 : wired_circuit):
  ((sort(a, z22)) => (match_wired_circuit1(a, Sequence1(u, u1), z, z1, z2,
  z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18,
  z19, z20, z21, z22, z23, z24) = z22))));

% match_wired_circuit_Parallel
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni,
  u : wired_circuit, u1 : wired_circuit):
  ((sort(a, z23)) => (match_wired_circuit1(a, Parallel1(u, u1), z, z1, z2,
  z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18,
  z19, z20, z21, z22, z23, z24) = z23))));

% match_wired_circuit_Ancillas
  ASSERT
  (FORALL (a : ty):
  (FORALL (z : uni, z1 : uni, z2 : uni, z3 : uni, z4 : uni, z5 : uni,
  z6 : uni, z7 : uni, z8 : uni, z9 : uni, z10 : uni, z11 : uni, z12 : uni,
  z13 : uni, z14 : uni, z15 : uni, z16 : uni, z17 : uni, z18 : uni,
  z19 : uni, z20 : uni, z21 : uni, z22 : uni, z23 : uni, z24 : uni,
  u : wired_circuit, u1 : INT):
  ((sort(a, z24)) => (match_wired_circuit1(a, Ancillas1(u, u1), z, z1, z2,
  z3, z4, z5, z6, z7, z8, z9, z10, z11, z12, z13, z14, z15, z16, z17, z18,
  z19, z20, z21, z22, z23, z24) = z24))));

index_wired_circuit1: (wired_circuit) -> INT;

% index_wired_circuit_Skip
  ASSERT (index_wired_circuit1(Skip) = 0);

% index_wired_circuit_Phase
  ASSERT
  (FORALL (u : INT):PATTERN (Phase1(u)):  (index_wired_circuit1(
  Phase1(u)) = 1));

% index_wired_circuit_Rx
  ASSERT
  (FORALL (u : INT):PATTERN (Rx(u)):  (index_wired_circuit1(Rx(u)) = 2));

% index_wired_circuit_Ry
  ASSERT
  (FORALL (u : INT):PATTERN (Ry(u)):  (index_wired_circuit1(Ry(u)) = 3));

% index_wired_circuit_Rz
  ASSERT
  (FORALL (u : INT):PATTERN (Rz1(u)):  (index_wired_circuit1(Rz1(u)) = 4));

% index_wired_circuit_Rzp
  ASSERT
  (FORALL (u : INT):PATTERN (Rzp(u)):  (index_wired_circuit1(Rzp(u)) = 5));

% index_wired_circuit_Hadamard
  ASSERT (index_wired_circuit1(Hadamard1) = 6);

% index_wired_circuit_S
  ASSERT (index_wired_circuit1(S) = 7);

% index_wired_circuit_T
  ASSERT (index_wired_circuit1(T) = 8);

% index_wired_circuit_X
  ASSERT (index_wired_circuit1(X) = 9);

% index_wired_circuit_Y
  ASSERT (index_wired_circuit1(Y) = 10);

% index_wired_circuit_Z
  ASSERT (index_wired_circuit1(Z) = 11);

% index_wired_circuit_Bricks_Cnot
  ASSERT (index_wired_circuit1(Bricks_Cnot) = 12);

% index_wired_circuit_Bricks_Toffoli
  ASSERT (index_wired_circuit1(Bricks_Toffoli) = 13);

% index_wired_circuit_Bricks_Fredkin
  ASSERT (index_wired_circuit1(Bricks_Fredkin) = 14);

% index_wired_circuit_Bricks_Swap
  ASSERT (index_wired_circuit1(Bricks_Swap) = 15);

% index_wired_circuit_Swap
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT):PATTERN (Swap1(u, u1, u2)):  (
  index_wired_circuit1(Swap1(u, u1, u2)) = 16));

% index_wired_circuit_Cnot
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT):PATTERN (Cnot1(u, u1, u2)):  (
  index_wired_circuit1(Cnot1(u, u1, u2)) = 17));

% index_wired_circuit_Toffoli
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT):PATTERN (Toffoli(u, u1, u2,
  u3)):  (index_wired_circuit1(Toffoli(u, u1, u2, u3)) = 18));

% index_wired_circuit_Fredkin
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT):PATTERN (Fredkin(u, u1, u2,
  u3)):  (index_wired_circuit1(Fredkin(u, u1, u2, u3)) = 19));

% index_wired_circuit_Place
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT, u2 : INT):PATTERN (Place(u, u1, u2)):
   (index_wired_circuit1(Place(u, u1, u2)) = 20));

% index_wired_circuit_Cont
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT, u2 : INT, u3 : INT):PATTERN (Cont(u,
  u1, u2, u3)):  (index_wired_circuit1(Cont(u, u1, u2, u3)) = 21));

% index_wired_circuit_Sequence
  ASSERT
  (FORALL (u : wired_circuit, u1 : wired_circuit):PATTERN (Sequence1(u, u1)):
   (index_wired_circuit1(Sequence1(u, u1)) = 22));

% index_wired_circuit_Parallel
  ASSERT
  (FORALL (u : wired_circuit, u1 : wired_circuit):PATTERN (Parallel1(u, u1)):
   (index_wired_circuit1(Parallel1(u, u1)) = 23));

% index_wired_circuit_Ancillas
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT):PATTERN (Ancillas1(u, u1)):  (
  index_wired_circuit1(Ancillas1(u, u1)) = 24));

Phase_proj_13: (wired_circuit) -> INT;

% Phase_proj_1'def
  ASSERT (FORALL (u : INT): (Phase_proj_13(Phase1(u)) = u));

Rx_proj_11: (wired_circuit) -> INT;

% Rx_proj_1'def
  ASSERT (FORALL (u : INT): (Rx_proj_11(Rx(u)) = u));

Ry_proj_11: (wired_circuit) -> INT;

% Ry_proj_1'def
  ASSERT (FORALL (u : INT): (Ry_proj_11(Ry(u)) = u));

Rz_proj_13: (wired_circuit) -> INT;

% Rz_proj_1'def
  ASSERT (FORALL (u : INT): (Rz_proj_13(Rz1(u)) = u));

Rzp_proj_11: (wired_circuit) -> INT;

% Rzp_proj_1'def
  ASSERT (FORALL (u : INT): (Rzp_proj_11(Rzp(u)) = u));

Swap_proj_11: (wired_circuit) -> INT;

% Swap_proj_1'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT): (Swap_proj_11(Swap1(u, u1,
  u2)) = u));

Swap_proj_21: (wired_circuit) -> INT;

% Swap_proj_2'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT): (Swap_proj_21(Swap1(u, u1,
  u2)) = u1));

Swap_proj_31: (wired_circuit) -> INT;

% Swap_proj_3'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT): (Swap_proj_31(Swap1(u, u1,
  u2)) = u2));

Cnot_proj_11: (wired_circuit) -> INT;

% Cnot_proj_1'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT): (Cnot_proj_11(Cnot1(u, u1,
  u2)) = u));

Cnot_proj_21: (wired_circuit) -> INT;

% Cnot_proj_2'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT): (Cnot_proj_21(Cnot1(u, u1,
  u2)) = u1));

Cnot_proj_31: (wired_circuit) -> INT;

% Cnot_proj_3'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT): (Cnot_proj_31(Cnot1(u, u1,
  u2)) = u2));

Toffoli_proj_11: (wired_circuit) -> INT;

% Toffoli_proj_1'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT): (Toffoli_proj_11(
  Toffoli(u, u1, u2, u3)) = u));

Toffoli_proj_21: (wired_circuit) -> INT;

% Toffoli_proj_2'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT): (Toffoli_proj_21(
  Toffoli(u, u1, u2, u3)) = u1));

Toffoli_proj_31: (wired_circuit) -> INT;

% Toffoli_proj_3'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT): (Toffoli_proj_31(
  Toffoli(u, u1, u2, u3)) = u2));

Toffoli_proj_41: (wired_circuit) -> INT;

% Toffoli_proj_4'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT): (Toffoli_proj_41(
  Toffoli(u, u1, u2, u3)) = u3));

Fredkin_proj_11: (wired_circuit) -> INT;

% Fredkin_proj_1'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT): (Fredkin_proj_11(
  Fredkin(u, u1, u2, u3)) = u));

Fredkin_proj_21: (wired_circuit) -> INT;

% Fredkin_proj_2'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT): (Fredkin_proj_21(
  Fredkin(u, u1, u2, u3)) = u1));

Fredkin_proj_31: (wired_circuit) -> INT;

% Fredkin_proj_3'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT): (Fredkin_proj_31(
  Fredkin(u, u1, u2, u3)) = u2));

Fredkin_proj_41: (wired_circuit) -> INT;

% Fredkin_proj_4'def
  ASSERT
  (FORALL (u : INT, u1 : INT, u2 : INT, u3 : INT): (Fredkin_proj_41(
  Fredkin(u, u1, u2, u3)) = u3));

Place_proj_11: (wired_circuit) -> wired_circuit;

% Place_proj_1'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT, u2 : INT): (Place_proj_11(Place(u,
  u1, u2)) = u));

Place_proj_21: (wired_circuit) -> INT;

% Place_proj_2'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT, u2 : INT): (Place_proj_21(Place(u,
  u1, u2)) = u1));

Place_proj_31: (wired_circuit) -> INT;

% Place_proj_3'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT, u2 : INT): (Place_proj_31(Place(u,
  u1, u2)) = u2));

Cont_proj_11: (wired_circuit) -> wired_circuit;

% Cont_proj_1'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT, u2 : INT, u3 : INT): (Cont_proj_11(
  Cont(u, u1, u2, u3)) = u));

Cont_proj_21: (wired_circuit) -> INT;

% Cont_proj_2'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT, u2 : INT, u3 : INT): (Cont_proj_21(
  Cont(u, u1, u2, u3)) = u1));

Cont_proj_31: (wired_circuit) -> INT;

% Cont_proj_3'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT, u2 : INT, u3 : INT): (Cont_proj_31(
  Cont(u, u1, u2, u3)) = u2));

Cont_proj_41: (wired_circuit) -> INT;

% Cont_proj_4'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT, u2 : INT, u3 : INT): (Cont_proj_41(
  Cont(u, u1, u2, u3)) = u3));

Sequence_proj_13: (wired_circuit) -> wired_circuit;

% Sequence_proj_1'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : wired_circuit): (Sequence_proj_13(
  Sequence1(u, u1)) = u));

Sequence_proj_23: (wired_circuit) -> wired_circuit;

% Sequence_proj_2'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : wired_circuit): (Sequence_proj_23(
  Sequence1(u, u1)) = u1));

Parallel_proj_13: (wired_circuit) -> wired_circuit;

% Parallel_proj_1'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : wired_circuit): (Parallel_proj_13(
  Parallel1(u, u1)) = u));

Parallel_proj_23: (wired_circuit) -> wired_circuit;

% Parallel_proj_2'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : wired_circuit): (Parallel_proj_23(
  Parallel1(u, u1)) = u1));

Ancillas_proj_13: (wired_circuit) -> wired_circuit;

% Ancillas_proj_1'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT): (Ancillas_proj_13(Ancillas1(u,
  u1)) = u));

Ancillas_proj_23: (wired_circuit) -> INT;

% Ancillas_proj_2'def
  ASSERT
  (FORALL (u : wired_circuit, u1 : INT): (Ancillas_proj_23(Ancillas1(u,
  u1)) = u1));

% wired_circuit_inversion
  ASSERT
  (FORALL (u : wired_circuit):
  (((((((((((((((((((((((((u = Skip) OR (u = Phase1(Phase_proj_13(u))))
                        OR (u = Rx(Rx_proj_11(u))))
                       OR (u = Ry(Ry_proj_11(u))))
                      OR (u = Rz1(Rz_proj_13(u))))
                     OR (u = Rzp(Rzp_proj_11(u))))
                    OR (u = Hadamard1))
                   OR (u = S))
                  OR (u = T))
                 OR (u = X))
                OR (u = Y))
               OR (u = Z))
              OR (u = Bricks_Cnot))
             OR (u = Bricks_Toffoli))
            OR (u = Bricks_Fredkin))
           OR (u = Bricks_Swap))
          OR (u = Swap1(Swap_proj_11(u), Swap_proj_21(u), Swap_proj_31(u))))
         OR (u = Cnot1(Cnot_proj_11(u), Cnot_proj_21(u), Cnot_proj_31(u))))
        OR (u = Toffoli(Toffoli_proj_11(u), Toffoli_proj_21(u), 
        Toffoli_proj_31(u), Toffoli_proj_41(u))))
       OR (u = Fredkin(Fredkin_proj_11(u), Fredkin_proj_21(u), 
       Fredkin_proj_31(u), Fredkin_proj_41(u))))
      OR (u = Place(Place_proj_11(u), Place_proj_21(u), Place_proj_31(u))))
     OR (u = Cont(Cont_proj_11(u), Cont_proj_21(u), Cont_proj_31(u), 
     Cont_proj_41(u))))
    OR (u = Sequence1(Sequence_proj_13(u), Sequence_proj_23(u))))
   OR (u = Parallel1(Parallel_proj_13(u), Parallel_proj_23(u))))
  OR (u = Ancillas1(Ancillas_proj_13(u), Ancillas_proj_23(u)))));

width_pre_: (wired_circuit) -> INT;

% width_pre_'def
  ASSERT
  (((((((((((((((((((((((((width_pre_(Skip) = 1)
                         AND (FORALL (w : INT): (width_pre_(Phase1(w)) = 1)))
                        AND (FORALL (w : INT): (width_pre_(Rx(w)) = 1)))
                       AND (FORALL (w : INT): (width_pre_(Ry(w)) = 1)))
                      AND (FORALL (w : INT): (width_pre_(Rz1(w)) = 1)))
                     AND (FORALL (w : INT): (width_pre_(Rzp(w)) = 1)))
                    AND (width_pre_(Hadamard1) = 1))
                   AND (width_pre_(S) = 1))
                  AND (width_pre_(T) = 1))
                 AND (width_pre_(X) = 1))
                AND (width_pre_(Y) = 1))
               AND (width_pre_(Z) = 1))
              AND (width_pre_(Bricks_Cnot) = 2))
             AND (width_pre_(Bricks_Toffoli) = 3))
            AND (width_pre_(Bricks_Fredkin) = 3))
           AND (width_pre_(Bricks_Swap) = 2))
          AND (FORALL (x : INT, x1 : INT, x2 : INT): (width_pre_(Swap1(x, x1,
              x2)) = x2)))
         AND (FORALL (x : INT, x1 : INT, x2 : INT): (width_pre_(Cnot1(x, x1,
             x2)) = x2)))
        AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT): (width_pre_(
            Toffoli(x, x1, x2, x3)) = x3)))
       AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT): (width_pre_(
           Fredkin(x, x1, x2, x3)) = x3)))
      AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT): (width_pre_(
          Place(x, x1, x2)) = x2)))
     AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT): (
         width_pre_(Cont(x, x1, x2, x3)) = x3)))
    AND (FORALL (x : wired_circuit, x1 : wired_circuit): (width_pre_(
        Sequence1(x, x1)) = width_pre_(x))))
   AND (FORALL (x : wired_circuit, x1 : wired_circuit): (width_pre_(
       Parallel1(x, x1)) = (width_pre_(x) + width_pre_(x1)))))
  AND (FORALL (x : wired_circuit, x1 : INT): (width_pre_(Ancillas1(x,
      x1)) = (width_pre_(x) - x1))));

build_correct_: (wired_circuit) -> BOOLEAN;

% build_correct_'def
  ASSERT
  (((((((((((((((((((((((((build_correct_(Skip))
                         AND (FORALL (w : INT): (build_correct_(Phase1(w)))))
                        AND (FORALL (w : INT): (build_correct_(Rx(w)))))
                       AND (FORALL (w : INT): (build_correct_(Ry(w)))))
                      AND (FORALL (w : INT): (build_correct_(Rz1(w)))))
                     AND (FORALL (w : INT): (build_correct_(Rzp(w)))))
                    AND (build_correct_(Hadamard1)))
                   AND (build_correct_(S)))
                  AND (build_correct_(T)))
                 AND (build_correct_(X)))
                AND (build_correct_(Y)))
               AND (build_correct_(Z)))
              AND (build_correct_(Bricks_Cnot)))
             AND (build_correct_(Bricks_Toffoli)))
            AND (build_correct_(Bricks_Fredkin)))
           AND (build_correct_(Bricks_Swap)))
          AND (FORALL (t1 : INT, t2 : INT, n : INT):
              ((build_correct_(Swap1(t1, t2, n)))
              <=> (((0 <= t1) AND (t1 < n))
                  AND (((0 <= t2) AND (t2 < n)) AND (NOT (t1 = t2)))))))
         AND (FORALL (c : INT, t1 : INT, n : INT):
             ((build_correct_(Cnot1(c, t1, n)))
             <=> (((0 <= c) AND (c < n))
                 AND (((0 <= t1) AND (t1 < n)) AND (NOT (c = t1)))))))
        AND (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
            ((build_correct_(Toffoli(c1, c2, t1, n)))
            <=> (((0 <= c1) AND (c1 < n))
                AND (((0 <= c2) AND (c2 < n))
                    AND (((0 <= t1) AND (t1 < n))
                        AND ((NOT (c1 = t1))
                            AND ((NOT (c2 = t1)) AND (NOT (c1 = c2))))))))))
       AND (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
           ((build_correct_(Fredkin(c1, c2, t1, n)))
           <=> (((0 <= c1) AND (c1 < n))
               AND (((0 <= c2) AND (c2 < n))
                   AND (((0 <= t1) AND (t1 < n))
                       AND ((NOT (c1 = t1))
                           AND ((NOT (c2 = t1)) AND (NOT (c1 = c2))))))))))
      AND (FORALL (c : wired_circuit, t1 : INT, n : INT):
          ((build_correct_(Place(c, t1, n)))
          <=> ((build_correct_(c))
              AND (((0 <= t1) AND (t1 < n)) AND ((t1 + width_pre_(c)) <= n))))))
     AND (FORALL (c : wired_circuit, co : INT, t1 : INT, n : INT):
         ((build_correct_(Cont(c, co, t1, n)))
         <=> ((build_correct_(c))
             AND (((0 <= co) AND (co < n))
                 AND (((0 <= t1) AND (t1 <= (n - width_pre_(c))))
                     AND ((co < t1) OR ((t1 + width_pre_(c)) <= co))))))))
    AND (FORALL (d : wired_circuit, e : wired_circuit):
        ((build_correct_(Sequence1(d, e)))
        <=> ((width_pre_(d) = width_pre_(e))
            AND ((build_correct_(d)) AND (build_correct_(e)))))))
   AND (FORALL (d : wired_circuit, e : wired_circuit):
       ((build_correct_(Parallel1(d, e)))
       <=> ((build_correct_(d)) AND (build_correct_(e))))))
  AND (FORALL (d : wired_circuit, i : INT):
      ((build_correct_(Ancillas1(d, i)))
      <=> ((1 <= i) AND (((i + 1) <= width_pre_(d)) AND (build_correct_(d)))))));

width_pre1: (wired_circuit) -> INT;

% width_pre'def
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct_(c))
  => ((((((((((((((((((((((((((c = Skip) => (width_pre1(c) = 1))
                            AND (FORALL (w : INT):
                                ((c = Phase1(w)) => (width_pre1(c) = 1))))
                           AND (FORALL (w : INT):
                               ((c = Rx(w)) => (width_pre1(c) = 1))))
                          AND (FORALL (w : INT):
                              ((c = Ry(w)) => (width_pre1(c) = 1))))
                         AND (FORALL (w : INT):
                             ((c = Rz1(w)) => (width_pre1(c) = 1))))
                        AND (FORALL (w : INT):
                            ((c = Rzp(w)) => (width_pre1(c) = 1))))
                       AND ((c = Hadamard1) => (width_pre1(c) = 1)))
                      AND ((c = S) => (width_pre1(c) = 1)))
                     AND ((c = T) => (width_pre1(c) = 1)))
                    AND ((c = X) => (width_pre1(c) = 1)))
                   AND ((c = Y) => (width_pre1(c) = 1)))
                  AND ((c = Z) => (width_pre1(c) = 1)))
                 AND ((c = Bricks_Cnot) => (width_pre1(c) = 2)))
                AND ((c = Bricks_Toffoli) => (width_pre1(c) = 3)))
               AND ((c = Bricks_Fredkin) => (width_pre1(c) = 3)))
              AND ((c = Bricks_Swap) => (width_pre1(c) = 2)))
             AND (FORALL (x : INT, x1 : INT, x2 : INT):
                 ((c = Swap1(x, x1, x2)) => (width_pre1(c) = x2))))
            AND (FORALL (x : INT, x1 : INT, x2 : INT):
                ((c = Cnot1(x, x1, x2)) => (width_pre1(c) = x2))))
           AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT):
               ((c = Toffoli(x, x1, x2, x3)) => (width_pre1(c) = x3))))
          AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT):
              ((c = Fredkin(x, x1, x2, x3)) => (width_pre1(c) = x3))))
         AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
             ((c = Place(x, x1, x2)) => (width_pre1(c) = x2))))
        AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
            ((c = Cont(x, x1, x2, x3)) => (width_pre1(c) = x3))))
       AND (FORALL (x : wired_circuit, x1 : wired_circuit):
           ((c = Sequence1(x, x1)) => (width_pre1(c) = width_pre1(x)))))
      AND (FORALL (x : wired_circuit, x1 : wired_circuit):
          ((c = Parallel1(x, x1)) => (width_pre1(c) = (width_pre1(x) + 
          width_pre1(x1))))))
     AND (FORALL (x : wired_circuit, x1 : INT):
         ((c = Ancillas1(x, x1)) => (width_pre1(c) = (width_pre1(x) - x1)))))));

% width_pre'spec
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct_(c))
  => ((1 <= width_pre1(c)) AND (width_pre1(c) = width_pre_(c)))));

build_correct1: (wired_circuit) -> BOOLEAN;

% build_correct'def
  ASSERT
  (((((((((((((((((((((((((build_correct1(Skip))
                         AND (FORALL (w : INT): (build_correct1(Phase1(w)))))
                        AND (FORALL (w : INT): (build_correct1(Rx(w)))))
                       AND (FORALL (w : INT): (build_correct1(Ry(w)))))
                      AND (FORALL (w : INT): (build_correct1(Rz1(w)))))
                     AND (FORALL (w : INT): (build_correct1(Rzp(w)))))
                    AND (build_correct1(Hadamard1)))
                   AND (build_correct1(S)))
                  AND (build_correct1(T)))
                 AND (build_correct1(X)))
                AND (build_correct1(Y)))
               AND (build_correct1(Z)))
              AND (build_correct1(Bricks_Cnot)))
             AND (build_correct1(Bricks_Toffoli)))
            AND (build_correct1(Bricks_Fredkin)))
           AND (build_correct1(Bricks_Swap)))
          AND (FORALL (t1 : INT, t2 : INT, n : INT):
              ((build_correct1(Swap1(t1, t2, n)))
              <=> (((0 <= t1) AND (t1 < n))
                  AND (((0 <= t2) AND (t2 < n)) AND (NOT (t1 = t2)))))))
         AND (FORALL (c : INT, t1 : INT, n : INT):
             ((build_correct1(Cnot1(c, t1, n)))
             <=> (((0 <= c) AND (c < n))
                 AND (((0 <= t1) AND (t1 < n)) AND (NOT (c = t1)))))))
        AND (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
            ((build_correct1(Toffoli(c1, c2, t1, n)))
            <=> (((0 <= c1) AND (c1 < n))
                AND (((0 <= c2) AND (c2 < n))
                    AND (((0 <= t1) AND (t1 < n))
                        AND ((NOT (c1 = t1))
                            AND ((NOT (c2 = t1)) AND (NOT (c1 = c2))))))))))
       AND (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
           ((build_correct1(Fredkin(c1, c2, t1, n)))
           <=> (((0 <= c1) AND (c1 < n))
               AND (((0 <= c2) AND (c2 < n))
                   AND (((0 <= t1) AND (t1 < n))
                       AND ((NOT (c1 = t1))
                           AND ((NOT (c2 = t1)) AND (NOT (c1 = c2))))))))))
      AND (FORALL (c : wired_circuit, t1 : INT, n : INT):
          ((build_correct1(Place(c, t1, n)))
          <=> ((build_correct1(c))
              AND (((0 <= t1) AND (t1 < n)) AND ((t1 + width_pre1(c)) <= n))))))
     AND (FORALL (c : wired_circuit, co : INT, t1 : INT, n : INT):
         ((build_correct1(Cont(c, co, t1, n)))
         <=> ((build_correct1(c))
             AND (((0 <= co) AND (co < n))
                 AND (((0 <= t1) AND (t1 <= (n - width_pre1(c))))
                     AND ((co < t1) OR ((t1 + width_pre1(c)) <= co))))))))
    AND (FORALL (d : wired_circuit, e : wired_circuit):
        ((build_correct1(Sequence1(d, e)))
        <=> ((build_correct1(d))
            AND ((build_correct1(e)) AND (width_pre1(d) = width_pre1(e)))))))
   AND (FORALL (d : wired_circuit, e : wired_circuit):
       ((build_correct1(Parallel1(d, e)))
       <=> ((build_correct1(d)) AND (build_correct1(e))))))
  AND (FORALL (d : wired_circuit, i : INT):
      ((build_correct1(Ancillas1(d, i)))
      <=> ((build_correct1(d)) AND ((1 <= i) AND ((i + 1) <= width_pre1(d)))))));

% build_correct'spec
  ASSERT
  (FORALL (c : wired_circuit): ((build_correct1(c)) <=> (build_correct_(c))));

depth_pre: (wired_circuit) -> INT;

% depth_pre'def
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct1(c))
  => ((((((((((((((((((((((((((c = Skip) => (depth_pre(c) = 0))
                            AND (FORALL (w : INT):
                                ((c = Phase1(w)) => (depth_pre(c) = 1))))
                           AND (FORALL (w : INT):
                               ((c = Rx(w)) => (depth_pre(c) = 1))))
                          AND (FORALL (w : INT):
                              ((c = Ry(w)) => (depth_pre(c) = 1))))
                         AND (FORALL (w : INT):
                             ((c = Rz1(w)) => (depth_pre(c) = 1))))
                        AND (FORALL (w : INT):
                            ((c = Rzp(w)) => (depth_pre(c) = 1))))
                       AND ((c = Hadamard1) => (depth_pre(c) = 1)))
                      AND ((c = S) => (depth_pre(c) = 1)))
                     AND ((c = T) => (depth_pre(c) = 1)))
                    AND ((c = X) => (depth_pre(c) = 1)))
                   AND ((c = Y) => (depth_pre(c) = 1)))
                  AND ((c = Z) => (depth_pre(c) = 1)))
                 AND ((c = Bricks_Cnot) => (depth_pre(c) = 1)))
                AND ((c = Bricks_Toffoli) => (depth_pre(c) = 1)))
               AND ((c = Bricks_Fredkin) => (depth_pre(c) = 1)))
              AND ((c = Bricks_Swap) => (depth_pre(c) = 1)))
             AND (FORALL (w : INT, w1 : INT, w2 : INT):
                 ((c = Swap1(w, w1, w2)) => (depth_pre(c) = 1))))
            AND (FORALL (w : INT, w1 : INT, w2 : INT):
                ((c = Cnot1(w, w1, w2)) => (depth_pre(c) = 1))))
           AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
               ((c = Toffoli(w, w1, w2, w3)) => (depth_pre(c) = 1))))
          AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
              ((c = Fredkin(w, w1, w2, w3)) => (depth_pre(c) = 1))))
         AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
             ((c = Place(x, x1, x2)) => (depth_pre(c) = depth_pre(x)))))
        AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
            ((c = Cont(x, x1, x2, x3)) => (depth_pre(c) = depth_pre(x)))))
       AND (FORALL (x : wired_circuit, x1 : wired_circuit):
           ((c = Sequence1(x, x1)) => (depth_pre(c) = (depth_pre(x) + 
           depth_pre(x1))))))
      AND (FORALL (x : wired_circuit, x1 : wired_circuit):
          ((c = Parallel1(x, x1)) => (depth_pre(c) = max(depth_pre(x), 
          depth_pre(x1))))))
     AND (FORALL (x : wired_circuit, x1 : INT):
         ((c = Ancillas1(x, x1)) => (depth_pre(c) = depth_pre(x)))))));

cont_size1: INT;

% cont_size'def
  ASSERT (1 <= cont_size1);

ancillas_pre: (wired_circuit) -> INT;

% ancillas_pre'def
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct1(c))
  => ((((((((((((((((((((((((((c = Skip) => (ancillas_pre(c) = 0))
                            AND (FORALL (w : INT):
                                ((c = Phase1(w)) => (ancillas_pre(c) = 0))))
                           AND (FORALL (w : INT):
                               ((c = Rx(w)) => (ancillas_pre(c) = 0))))
                          AND (FORALL (w : INT):
                              ((c = Ry(w)) => (ancillas_pre(c) = 0))))
                         AND (FORALL (w : INT):
                             ((c = Rz1(w)) => (ancillas_pre(c) = 0))))
                        AND (FORALL (w : INT):
                            ((c = Rzp(w)) => (ancillas_pre(c) = 0))))
                       AND ((c = Hadamard1) => (ancillas_pre(c) = 0)))
                      AND ((c = S) => (ancillas_pre(c) = 0)))
                     AND ((c = T) => (ancillas_pre(c) = 0)))
                    AND ((c = X) => (ancillas_pre(c) = 0)))
                   AND ((c = Y) => (ancillas_pre(c) = 0)))
                  AND ((c = Z) => (ancillas_pre(c) = 0)))
                 AND ((c = Bricks_Cnot) => (ancillas_pre(c) = 0)))
                AND ((c = Bricks_Toffoli) => (ancillas_pre(c) = 0)))
               AND ((c = Bricks_Fredkin) => (ancillas_pre(c) = 0)))
              AND ((c = Bricks_Swap) => (ancillas_pre(c) = 0)))
             AND (FORALL (w : INT, w1 : INT, w2 : INT):
                 ((c = Swap1(w, w1, w2)) => (ancillas_pre(c) = 0))))
            AND (FORALL (w : INT, w1 : INT, w2 : INT):
                ((c = Cnot1(w, w1, w2)) => (ancillas_pre(c) = 0))))
           AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
               ((c = Toffoli(w, w1, w2, w3)) => (ancillas_pre(c) = 0))))
          AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
              ((c = Fredkin(w, w1, w2, w3)) => (ancillas_pre(c) = 0))))
         AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
             ((c = Place(x, x1, x2)) => (ancillas_pre(c) = ancillas_pre(x)))))
        AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
            ((c = Cont(x, x1, x2, x3)) => (ancillas_pre(c) = 
            ancillas_pre(x)))))
       AND (FORALL (x : wired_circuit, x1 : wired_circuit):
           ((c = Sequence1(x, x1)) => (ancillas_pre(c) = max(ancillas_pre(x), 
           ancillas_pre(x1))))))
      AND (FORALL (x : wired_circuit, x1 : wired_circuit):
          ((c = Parallel1(x, x1)) => (ancillas_pre(c) = (ancillas_pre(x) + 
          ancillas_pre(x1))))))
     AND (FORALL (x : wired_circuit, x1 : INT):
         ((c = Ancillas1(x, x1)) => (ancillas_pre(c) = (
         ancillas_pre(x) + x1)))))));

% ancillas_pre'spec
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct1(c)) => (0 <= ancillas_pre(c))));

atomic: (wired_circuit) -> BOOLEAN;

% atomic'def
  ASSERT
  (((((((((((((((((((((((((NOT (atomic(Skip)))
                         AND (FORALL (x : INT): (atomic(Phase1(x)))))
                        AND (FORALL (x : INT): (atomic(Rx(x)))))
                       AND (FORALL (x : INT): (atomic(Ry(x)))))
                      AND (FORALL (x : INT): (atomic(Rz1(x)))))
                     AND (FORALL (x : INT): (atomic(Rzp(x)))))
                    AND (atomic(Hadamard1)))
                   AND (atomic(S)))
                  AND (atomic(T)))
                 AND (atomic(X)))
                AND (atomic(Y)))
               AND (atomic(Z)))
              AND (NOT (atomic(Bricks_Cnot))))
             AND (NOT (atomic(Bricks_Toffoli))))
            AND (NOT (atomic(Bricks_Fredkin))))
           AND (NOT (atomic(Bricks_Swap))))
          AND (FORALL (w : INT, w1 : INT, w2 : INT):
              (NOT (atomic(Swap1(w, w1, w2))))))
         AND (FORALL (w : INT, w1 : INT, w2 : INT):
             (NOT (atomic(Cnot1(w, w1, w2))))))
        AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
            (NOT (atomic(Toffoli(w, w1, w2, w3))))))
       AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
           (NOT (atomic(Fredkin(w, w1, w2, w3))))))
      AND (FORALL (w : wired_circuit, w1 : INT, w2 : INT):
          (NOT (atomic(Place(w, w1, w2))))))
     AND (FORALL (w : wired_circuit, w1 : INT, w2 : INT, w3 : INT):
         (NOT (atomic(Cont(w, w1, w2, w3))))))
    AND (FORALL (w : wired_circuit, w1 : wired_circuit):
        (NOT (atomic(Sequence1(w, w1))))))
   AND (FORALL (w : wired_circuit, w1 : wired_circuit):
       (NOT (atomic(Parallel1(w, w1))))))
  AND (FORALL (w : wired_circuit, w1 : INT):
      (NOT (atomic(Ancillas1(w, w1))))));

size_pre: (wired_circuit) -> INT;

% size_pre'def
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct1(c))
  => ((((((((((((((((((((((((((c = Skip) => (size_pre(c) = 0))
                            AND (FORALL (w : INT):
                                ((c = Phase1(w)) => (size_pre(c) = 1))))
                           AND (FORALL (w : INT):
                               ((c = Rx(w)) => (size_pre(c) = 1))))
                          AND (FORALL (w : INT):
                              ((c = Ry(w)) => (size_pre(c) = 1))))
                         AND (FORALL (w : INT):
                             ((c = Rz1(w)) => (size_pre(c) = 1))))
                        AND (FORALL (w : INT):
                            ((c = Rzp(w)) => (size_pre(c) = 1))))
                       AND ((c = Hadamard1) => (size_pre(c) = 1)))
                      AND ((c = S) => (size_pre(c) = 1)))
                     AND ((c = T) => (size_pre(c) = 1)))
                    AND ((c = X) => (size_pre(c) = 1)))
                   AND ((c = Y) => (size_pre(c) = 1)))
                  AND ((c = Z) => (size_pre(c) = 1)))
                 AND ((c = Bricks_Cnot) => (size_pre(c) = 1)))
                AND ((c = Bricks_Toffoli) => (size_pre(c) = 1)))
               AND ((c = Bricks_Fredkin) => (size_pre(c) = 1)))
              AND ((c = Bricks_Swap) => (size_pre(c) = 1)))
             AND (FORALL (w : INT, w1 : INT, w2 : INT):
                 ((c = Swap1(w, w1, w2)) => (size_pre(c) = 1))))
            AND (FORALL (w : INT, w1 : INT, w2 : INT):
                ((c = Cnot1(w, w1, w2)) => (size_pre(c) = 1))))
           AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
               ((c = Toffoli(w, w1, w2, w3)) => (size_pre(c) = 1))))
          AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
              ((c = Fredkin(w, w1, w2, w3)) => (size_pre(c) = 1))))
         AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
             ((c = Place(x, x1, x2)) => (size_pre(c) = size_pre(x)))))
        AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
            ((c = Cont(x, x1, x2, x3)) => (size_pre(c) = (
            size_pre(x) * cont_size1)))))
       AND (FORALL (x : wired_circuit, x1 : wired_circuit):
           ((c = Sequence1(x, x1)) => (size_pre(c) = (size_pre(x) + 
           size_pre(x1))))))
      AND (FORALL (x : wired_circuit, x1 : wired_circuit):
          ((c = Parallel1(x, x1)) => (size_pre(c) = (size_pre(x) + 
          size_pre(x1))))))
     AND (FORALL (x : wired_circuit, x1 : INT):
         ((c = Ancillas1(x, x1)) => (size_pre(c) = size_pre(x)))))));

range_pre: (wired_circuit) -> INT;

% range_pre'def
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct1(c))
  => ((((((((((((((((((((((((((c = Skip) => (range_pre(c) = 0))
                            AND (FORALL (w : INT):
                                ((c = Phase1(w)) => (range_pre(c) = 0))))
                           AND (FORALL (x : INT):
                               ((c = Rx(x)) => (range_pre(c) = 2))))
                          AND (FORALL (x : INT):
                              ((c = Ry(x)) => (range_pre(c) = 2))))
                         AND (FORALL (w : INT):
                             ((c = Rz1(w)) => (range_pre(c) = 0))))
                        AND (FORALL (w : INT):
                            ((c = Rzp(w)) => (range_pre(c) = 0))))
                       AND ((c = Hadamard1) => (range_pre(c) = 1)))
                      AND ((c = S) => (range_pre(c) = 0)))
                     AND ((c = T) => (range_pre(c) = 0)))
                    AND ((c = X) => (range_pre(c) = 0)))
                   AND ((c = Y) => (range_pre(c) = 0)))
                  AND ((c = Z) => (range_pre(c) = 0)))
                 AND ((c = Bricks_Cnot) => (range_pre(c) = 0)))
                AND ((c = Bricks_Toffoli) => (range_pre(c) = 0)))
               AND ((c = Bricks_Fredkin) => (range_pre(c) = 0)))
              AND ((c = Bricks_Swap) => (range_pre(c) = 0)))
             AND (FORALL (w : INT, w1 : INT, w2 : INT):
                 ((c = Swap1(w, w1, w2)) => (range_pre(c) = 0))))
            AND (FORALL (w : INT, w1 : INT, w2 : INT):
                ((c = Cnot1(w, w1, w2)) => (range_pre(c) = 0))))
           AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
               ((c = Toffoli(w, w1, w2, w3)) => (range_pre(c) = 0))))
          AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
              ((c = Fredkin(w, w1, w2, w3)) => (range_pre(c) = 0))))
         AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
             ((c = Place(x, x1, x2)) => (range_pre(c) = range_pre(x)))))
        AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
            ((c = Cont(x, x1, x2, x3)) => (range_pre(c) = range_pre(x)))))
       AND (FORALL (x : wired_circuit, x1 : wired_circuit):
           ((c = Sequence1(x, x1)) => (range_pre(c) = (range_pre(x) + 
           range_pre(x1))))))
      AND (FORALL (x : wired_circuit, x1 : wired_circuit):
          ((c = Parallel1(x, x1)) => (range_pre(c) = (range_pre(x) + 
          range_pre(x1))))))
     AND (FORALL (x : wired_circuit, x1 : INT):
         ((c = Ancillas1(x, x1)) => (range_pre(c) = range_pre(x)))))));

% range_pre'spec
  ASSERT
  (FORALL (c : wired_circuit): ((build_correct1(c)) => (0 <= range_pre(c))));

circ_to_pps_pre1: (wired_circuit) -> pps;

% circ_to_pps_pre'def
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct1(c))
  => ((((((((((((((((((((((((((c = Skip) => (circ_to_pps_pre1(c) = pps_id))
                            AND (FORALL (k : INT):
                                ((c = Phase1(k)) => (circ_to_pps_pre1(c) = 
                                pps_phase(k)))))
                           AND (FORALL (k : INT):
                               ((c = Rx(k)) => (circ_to_pps_pre1(c) = 
                               pps_rx(k)))))
                          AND (FORALL (k : INT):
                              ((c = Ry(k)) => (circ_to_pps_pre1(c) = 
                              pps_ry(k)))))
                         AND (FORALL (k : INT):
                             ((c = Rz1(k)) => (circ_to_pps_pre1(c) = 
                             pps_rz_b(k)))))
                        AND (FORALL (k : INT):
                            ((c = Rzp(k)) => (circ_to_pps_pre1(c) = 
                            pps_rz(k)))))
                       AND ((c = Hadamard1) => (
                           circ_to_pps_pre1(c) = pps_hadamard)))
                      AND ((c = S) => (circ_to_pps_pre1(c) = pps_rz(2))))
                     AND ((c = T) => (circ_to_pps_pre1(c) = pps_rz(3))))
                    AND ((c = X) => (circ_to_pps_pre1(c) = pps_xx)))
                   AND ((c = Y) => (circ_to_pps_pre1(c) = pps_yy)))
                  AND ((c = Z) => (circ_to_pps_pre1(c) = pps_zz)))
                 AND ((c = Bricks_Cnot) => (circ_to_pps_pre1(c) = pps_cnot(0,
                     1, 2))))
                AND ((c = Bricks_Toffoli) => (circ_to_pps_pre1(c) = 
                    pps_toffoli(0, 1, 2, 3))))
               AND ((c = Bricks_Fredkin) => (circ_to_pps_pre1(c) = 
                   pps_fredkin(0, 1, 2, 3))))
              AND ((c = Bricks_Swap) => (circ_to_pps_pre1(c) = pps_swap(0, 1,
                  2))))
             AND (FORALL (t1 : INT, t2 : INT, n : INT):
                 ((c = Swap1(t1, t2, n)) => (circ_to_pps_pre1(c) = 
                 pps_swap(t1, t2, n)))))
            AND (FORALL (c1 : INT, t1 : INT, n : INT):
                ((c = Cnot1(c1, t1, n)) => (circ_to_pps_pre1(c) = 
                pps_cnot(c1, t1, n)))))
           AND (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
               ((c = Toffoli(c1, c2, t1, n)) => (circ_to_pps_pre1(c) = 
               pps_toffoli(c1, c2, t1, n)))))
          AND (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
              ((c = Fredkin(c1, c2, t1, n)) => (circ_to_pps_pre1(c) = 
              pps_fredkin(c1, c2, t1, n)))))
         AND (FORALL (c1 : wired_circuit, t1 : INT, n : INT):
             ((c = Place(c1, t1, n)) => (circ_to_pps_pre1(c) = pps_place(
             circ_to_pps_pre1(c1), t1, n)))))
        AND (FORALL (c1 : wired_circuit, co : INT, t1 : INT, n : INT):
            ((c = Cont(c1, co, t1, n)) => (circ_to_pps_pre1(c) = pps_cont(
            circ_to_pps_pre1(c1), co, t1, n)))))
       AND (FORALL (d : wired_circuit, e : wired_circuit):
           ((c = Sequence1(d, e)) => (circ_to_pps_pre1(c) = pps_seq(
           circ_to_pps_pre1(d), circ_to_pps_pre1(e))))))
      AND (FORALL (d : wired_circuit, e : wired_circuit):
          ((c = Parallel1(d, e)) => (circ_to_pps_pre1(c) = pps_par(
          circ_to_pps_pre1(d), circ_to_pps_pre1(e))))))
     AND (FORALL (d : wired_circuit, i : INT):
         ((c = Ancillas1(d, i)) => (circ_to_pps_pre1(c) = pps_ancs(
         circ_to_pps_pre1(d), i)))))));

% circ_to_pps_pre'spec
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct1(c))
  => ((1 <= h_width(circ_to_pps_pre1(c)))
     AND ((h_width(circ_to_pps_pre1(c)) = width_pre1(c)) AND (h_range(
         circ_to_pps_pre1(c)) = range_pre(c))))));

ancillable: (wired_circuit, INT) -> BOOLEAN;

% ancillable'spec
  ASSERT
  (FORALL (c : wired_circuit, i : INT):
  ((ancillable(c, i))
  <=> (EXISTS (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
      (FORALL (x : matrix_complex):
      ((is_a_ket_l(x, (width_pre1(c) - i))) => (pps_apply(
      circ_to_pps_pre1(c), kronecker(x, ket(i, 0))) = kronecker(tb2t18(
      infix_at(matrix(complex1), matrix(complex1), t2tb19(path_sem_target), 
      t2tb18(x))), ket(i, 0))))))));

correct1: (wired_circuit) -> BOOLEAN;

% correct'def
  ASSERT
  (((((((((((((((((((((((((correct1(Skip))
                         AND (FORALL (x : INT): (correct1(Phase1(x)))))
                        AND (FORALL (x : INT): (correct1(Rx(x)))))
                       AND (FORALL (x : INT): (correct1(Ry(x)))))
                      AND (FORALL (x : INT): (correct1(Rz1(x)))))
                     AND (FORALL (x : INT): (correct1(Rzp(x)))))
                    AND (correct1(Hadamard1)))
                   AND (correct1(S)))
                  AND (correct1(T)))
                 AND (correct1(X)))
                AND (correct1(Y)))
               AND (correct1(Z)))
              AND (correct1(Bricks_Cnot)))
             AND (correct1(Bricks_Toffoli)))
            AND (correct1(Bricks_Fredkin)))
           AND (correct1(Bricks_Swap)))
          AND (FORALL (x : INT, x1 : INT, x2 : INT):
              ((correct1(Swap1(x, x1, x2)))
              <=> (((0 <= x) AND (x < x2))
                  AND (((0 <= x1) AND (x1 < x2)) AND (NOT (x = x1)))))))
         AND (FORALL (x : INT, x1 : INT, x2 : INT):
             ((correct1(Cnot1(x, x1, x2)))
             <=> (((0 <= x) AND (x < x2))
                 AND (((0 <= x1) AND (x1 < x2)) AND (NOT (x = x1)))))))
        AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT):
            ((correct1(Toffoli(x, x1, x2, x3)))
            <=> (((0 <= x) AND (x < x3))
                AND (((0 <= x1) AND (x1 < x3))
                    AND (((0 <= x2) AND (x2 < x3))
                        AND ((NOT (x = x2))
                            AND ((NOT (x1 = x2)) AND (NOT (x = x1))))))))))
       AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT):
           ((correct1(Fredkin(x, x1, x2, x3)))
           <=> (((0 <= x) AND (x < x3))
               AND (((0 <= x1) AND (x1 < x3))
                   AND (((0 <= x2) AND (x2 < x3))
                       AND ((NOT (x = x2))
                           AND ((NOT (x1 = x2)) AND (NOT (x = x1))))))))))
      AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
          ((correct1(Place(x, x1, x2)))
          <=> ((correct1(x))
              AND (((0 <= x1) AND (x1 <= x2)) AND ((x1 + 
                  width_pre1(x)) <= x2))))))
     AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
         ((correct1(Cont(x, x1, x2, x3)))
         <=> ((correct1(x))
             AND (((0 <= x1) AND (x1 < x3))
                 AND (((0 <= x2) AND (x2 <= (x3 - width_pre1(x))))
                     AND ((x1 < x2) OR ((x2 + width_pre1(x)) <= x1))))))))
    AND (FORALL (x : wired_circuit, x1 : wired_circuit):
        ((correct1(Sequence1(x, x1)))
        <=> ((correct1(x))
            AND ((correct1(x1)) AND (width_pre1(x) = width_pre1(x1)))))))
   AND (FORALL (x : wired_circuit, x1 : wired_circuit):
       ((correct1(Parallel1(x, x1))) <=> ((correct1(x)) AND (correct1(x1))))))
  AND (FORALL (x : wired_circuit, x1 : INT):
      ((correct1(Ancillas1(x, x1)))
      <=> ((correct1(x))
          AND ((1 <= x1)
              AND (((x1 + 1) <= width_pre1(x)) AND (ancillable(x, x1))))))));

% correct'spec
  ASSERT
  (FORALL (c : wired_circuit): ((correct1(c)) => (build_correct_(c))));

circuit2 : TYPE;

circuit3: ty;

pre1: (circuit2) -> wired_circuit;

% circuit'invariant
  ASSERT
  (FORALL (self : circuit2):PATTERN (pre1(self)):  (correct1(pre1(self))));

% injective_pre
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2):
  ((NOT (c = cqt)) => (NOT (pre1(c) = pre1(cqt)))));

% build_correct_pre
  ASSERT (FORALL (c : circuit2): (build_correct_(pre1(c))));

to_qc1: (wired_circuit) -> circuit2;

% to_qc'def
  ASSERT
  (FORALL (c : wired_circuit): ((correct1(c)) => (pre1(to_qc1(c)) = c)));

range1: (circuit2) -> INT;

% range'def
  ASSERT
  (FORALL (c : circuit2):
  ((((((((((((((((((((((((((pre1(c) = Skip) => (range1(c) = 0))
                         AND (FORALL (w : INT):
                             ((pre1(c) = Phase1(w)) => (range1(c) = 0))))
                        AND (FORALL (x : INT):
                            ((pre1(c) = Rx(x)) => (range1(c) = 2))))
                       AND (FORALL (x : INT):
                           ((pre1(c) = Ry(x)) => (range1(c) = 2))))
                      AND (FORALL (w : INT):
                          ((pre1(c) = Rz1(w)) => (range1(c) = 0))))
                     AND (FORALL (w : INT):
                         ((pre1(c) = Rzp(w)) => (range1(c) = 0))))
                    AND ((pre1(c) = Hadamard1) => (range1(c) = 1)))
                   AND ((pre1(c) = S) => (range1(c) = 0)))
                  AND ((pre1(c) = T) => (range1(c) = 0)))
                 AND ((pre1(c) = X) => (range1(c) = 0)))
                AND ((pre1(c) = Y) => (range1(c) = 0)))
               AND ((pre1(c) = Z) => (range1(c) = 0)))
              AND ((pre1(c) = Bricks_Cnot) => (range1(c) = 0)))
             AND ((pre1(c) = Bricks_Toffoli) => (range1(c) = 0)))
            AND ((pre1(c) = Bricks_Fredkin) => (range1(c) = 0)))
           AND ((pre1(c) = Bricks_Swap) => (range1(c) = 0)))
          AND (FORALL (w : INT, w1 : INT, w2 : INT):
              ((pre1(c) = Swap1(w, w1, w2)) => (range1(c) = 0))))
         AND (FORALL (w : INT, w1 : INT, w2 : INT):
             ((pre1(c) = Cnot1(w, w1, w2)) => (range1(c) = 0))))
        AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
            ((pre1(c) = Toffoli(w, w1, w2, w3)) => (range1(c) = 0))))
       AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
           ((pre1(c) = Fredkin(w, w1, w2, w3)) => (range1(c) = 0))))
      AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
          ((pre1(c) = Place(x, x1, x2)) => (range1(c) = range1(to_qc1(x))))))
     AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
         ((pre1(c) = Cont(x, x1, x2, x3)) => (range1(c) = range1(to_qc1(x))))))
    AND (FORALL (x : wired_circuit, x1 : wired_circuit):
        ((pre1(c) = Sequence1(x, x1)) => (range1(c) = (range1(to_qc1(x)) + 
        range1(to_qc1(x1)))))))
   AND (FORALL (x : wired_circuit, x1 : wired_circuit):
       ((pre1(c) = Parallel1(x, x1)) => (range1(c) = (range1(to_qc1(x)) + 
       range1(to_qc1(x1)))))))
  AND (FORALL (x : wired_circuit, x1 : INT):
      ((pre1(c) = Ancillas1(x, x1)) => (range1(c) = range1(to_qc1(x)))))));

% range'spec
  ASSERT
  (FORALL (c : circuit2):
  ((range1(c) = range_pre(pre1(c)))
  AND ((range1(c) = h_range(circ_to_pps_pre1(pre1(c)))) AND (0 <= range1(c)))));

size1: (circuit2) -> INT;

% size'def
  ASSERT
  (FORALL (c : circuit2):
  ((((((((((((((((((((((((((pre1(c) = Skip) => (size1(c) = 0))
                         AND (FORALL (w : INT):
                             ((pre1(c) = Phase1(w)) => (size1(c) = 1))))
                        AND (FORALL (w : INT):
                            ((pre1(c) = Rx(w)) => (size1(c) = 1))))
                       AND (FORALL (w : INT):
                           ((pre1(c) = Ry(w)) => (size1(c) = 1))))
                      AND (FORALL (w : INT):
                          ((pre1(c) = Rz1(w)) => (size1(c) = 1))))
                     AND (FORALL (w : INT):
                         ((pre1(c) = Rzp(w)) => (size1(c) = 1))))
                    AND ((pre1(c) = Hadamard1) => (size1(c) = 1)))
                   AND ((pre1(c) = S) => (size1(c) = 1)))
                  AND ((pre1(c) = T) => (size1(c) = 1)))
                 AND ((pre1(c) = X) => (size1(c) = 1)))
                AND ((pre1(c) = Y) => (size1(c) = 1)))
               AND ((pre1(c) = Z) => (size1(c) = 1)))
              AND ((pre1(c) = Bricks_Cnot) => (size1(c) = 1)))
             AND ((pre1(c) = Bricks_Toffoli) => (size1(c) = 1)))
            AND ((pre1(c) = Bricks_Fredkin) => (size1(c) = 1)))
           AND ((pre1(c) = Bricks_Swap) => (size1(c) = 1)))
          AND (FORALL (w : INT, w1 : INT, w2 : INT):
              ((pre1(c) = Swap1(w, w1, w2)) => (size1(c) = 1))))
         AND (FORALL (w : INT, w1 : INT, w2 : INT):
             ((pre1(c) = Cnot1(w, w1, w2)) => (size1(c) = 1))))
        AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
            ((pre1(c) = Toffoli(w, w1, w2, w3)) => (size1(c) = 1))))
       AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
           ((pre1(c) = Fredkin(w, w1, w2, w3)) => (size1(c) = 1))))
      AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
          ((pre1(c) = Place(x, x1, x2)) => (size1(c) = size_pre(x)))))
     AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
         ((pre1(c) = Cont(x, x1, x2, x3)) => (size1(c) = (size1(
         to_qc1(x)) * cont_size1)))))
    AND (FORALL (x : wired_circuit, x1 : wired_circuit):
        ((pre1(c) = Sequence1(x, x1)) => (size1(c) = (size1(to_qc1(x)) + 
        size1(to_qc1(x1)))))))
   AND (FORALL (x : wired_circuit, x1 : wired_circuit):
       ((pre1(c) = Parallel1(x, x1)) => (size1(c) = (size1(to_qc1(x)) + 
       size1(to_qc1(x1)))))))
  AND (FORALL (x : wired_circuit, x1 : INT):
      ((pre1(c) = Ancillas1(x, x1)) => (size1(c) = size_pre(x))))));

% size'spec
  ASSERT (FORALL (c : circuit2): (size1(c) = size_pre(pre1(c))));

ancillas1: (circuit2) -> INT;

% ancillas'def
  ASSERT
  (FORALL (c : circuit2):
  ((((((((((((((((((((((((((pre1(c) = Skip) => (ancillas1(c) = 0))
                         AND (FORALL (w : INT):
                             ((pre1(c) = Phase1(w)) => (ancillas1(c) = 0))))
                        AND (FORALL (w : INT):
                            ((pre1(c) = Rx(w)) => (ancillas1(c) = 0))))
                       AND (FORALL (w : INT):
                           ((pre1(c) = Ry(w)) => (ancillas1(c) = 0))))
                      AND (FORALL (w : INT):
                          ((pre1(c) = Rz1(w)) => (ancillas1(c) = 0))))
                     AND (FORALL (w : INT):
                         ((pre1(c) = Rzp(w)) => (ancillas1(c) = 0))))
                    AND ((pre1(c) = Hadamard1) => (ancillas1(c) = 0)))
                   AND ((pre1(c) = S) => (ancillas1(c) = 0)))
                  AND ((pre1(c) = T) => (ancillas1(c) = 0)))
                 AND ((pre1(c) = X) => (ancillas1(c) = 0)))
                AND ((pre1(c) = Y) => (ancillas1(c) = 0)))
               AND ((pre1(c) = Z) => (ancillas1(c) = 0)))
              AND ((pre1(c) = Bricks_Cnot) => (ancillas1(c) = 0)))
             AND ((pre1(c) = Bricks_Toffoli) => (ancillas1(c) = 0)))
            AND ((pre1(c) = Bricks_Fredkin) => (ancillas1(c) = 0)))
           AND ((pre1(c) = Bricks_Swap) => (ancillas1(c) = 0)))
          AND (FORALL (w : INT, w1 : INT, w2 : INT):
              ((pre1(c) = Swap1(w, w1, w2)) => (ancillas1(c) = 0))))
         AND (FORALL (w : INT, w1 : INT, w2 : INT):
             ((pre1(c) = Cnot1(w, w1, w2)) => (ancillas1(c) = 0))))
        AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
            ((pre1(c) = Toffoli(w, w1, w2, w3)) => (ancillas1(c) = 0))))
       AND (FORALL (w : INT, w1 : INT, w2 : INT, w3 : INT):
           ((pre1(c) = Fredkin(w, w1, w2, w3)) => (ancillas1(c) = 0))))
      AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
          ((pre1(c) = Place(x, x1, x2)) => (ancillas1(c) = ancillas1(
          to_qc1(x))))))
     AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
         ((pre1(c) = Cont(x, x1, x2, x3)) => (ancillas1(c) = ancillas1(
         to_qc1(x))))))
    AND (FORALL (x : wired_circuit, x1 : wired_circuit):
        ((pre1(c) = Sequence1(x, x1)) => (ancillas1(c) = max(ancillas1(
        to_qc1(x)), ancillas1(to_qc1(x1)))))))
   AND (FORALL (x : wired_circuit, x1 : wired_circuit):
       ((pre1(c) = Parallel1(x, x1)) => (ancillas1(c) = (ancillas1(
       to_qc1(x)) + ancillas1(to_qc1(x1)))))))
  AND (FORALL (x : wired_circuit, x1 : INT):
      ((pre1(c) = Ancillas1(x, x1)) => (ancillas1(c) = (ancillas1(
      to_qc1(x)) + x1))))));

% ancillas'spec
  ASSERT (FORALL (c : circuit2): (ancillas1(c) = ancillas_pre(pre1(c))));

% ancillas_pos
  ASSERT (FORALL (c : circuit2): (0 <= ancillas1(c)));

% size_pos
  ASSERT (FORALL (c : circuit2): (0 <= size1(c)));

width1: (circuit2) -> INT;

% width'def
  ASSERT
  (FORALL (c : circuit2):
  ((((((((((((((((((((((((((pre1(c) = Skip) => (width1(c) = 1))
                         AND (FORALL (w : INT):
                             ((pre1(c) = Phase1(w)) => (width1(c) = 1))))
                        AND (FORALL (w : INT):
                            ((pre1(c) = Rx(w)) => (width1(c) = 1))))
                       AND (FORALL (w : INT):
                           ((pre1(c) = Ry(w)) => (width1(c) = 1))))
                      AND (FORALL (w : INT):
                          ((pre1(c) = Rz1(w)) => (width1(c) = 1))))
                     AND (FORALL (w : INT):
                         ((pre1(c) = Rzp(w)) => (width1(c) = 1))))
                    AND ((pre1(c) = Hadamard1) => (width1(c) = 1)))
                   AND ((pre1(c) = S) => (width1(c) = 1)))
                  AND ((pre1(c) = T) => (width1(c) = 1)))
                 AND ((pre1(c) = X) => (width1(c) = 1)))
                AND ((pre1(c) = Y) => (width1(c) = 1)))
               AND ((pre1(c) = Z) => (width1(c) = 1)))
              AND ((pre1(c) = Bricks_Cnot) => (width1(c) = 2)))
             AND ((pre1(c) = Bricks_Toffoli) => (width1(c) = 3)))
            AND ((pre1(c) = Bricks_Fredkin) => (width1(c) = 3)))
           AND ((pre1(c) = Bricks_Swap) => (width1(c) = 2)))
          AND (FORALL (x : INT, x1 : INT, x2 : INT):
              ((pre1(c) = Swap1(x, x1, x2)) => (width1(c) = x2))))
         AND (FORALL (x : INT, x1 : INT, x2 : INT):
             ((pre1(c) = Cnot1(x, x1, x2)) => (width1(c) = x2))))
        AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT):
            ((pre1(c) = Toffoli(x, x1, x2, x3)) => (width1(c) = x3))))
       AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT):
           ((pre1(c) = Fredkin(x, x1, x2, x3)) => (width1(c) = x3))))
      AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
          ((pre1(c) = Place(x, x1, x2)) => (width1(c) = x2))))
     AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
         ((pre1(c) = Cont(x, x1, x2, x3)) => (width1(c) = x3))))
    AND (FORALL (x : wired_circuit, x1 : wired_circuit):
        ((pre1(c) = Sequence1(x, x1)) => (width1(c) = width1(to_qc1(x))))))
   AND (FORALL (x : wired_circuit, x1 : wired_circuit):
       ((pre1(c) = Parallel1(x, x1)) => (width1(c) = (width1(to_qc1(x)) + 
       width1(to_qc1(x1)))))))
  AND (FORALL (x : wired_circuit, x1 : INT):
      ((pre1(c) = Ancillas1(x, x1)) => (width1(c) = (width1(
      to_qc1(x)) - x1))))));

% width'spec
  ASSERT
  (FORALL (c : circuit2):
  ((1 <= width1(c)) AND (width1(c) = width_pre1(pre1(c)))));

basis_ket1: (circuit2, (ARRAY INT OF INT), (ARRAY INT OF INT), INT) -> INT;

result130: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

result131: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

basis_ket_closure1: (ARRAY circuit2 OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))));

result132: ((ARRAY INT OF INT), wired_circuit) -> (ARRAY INT OF INT);

result133: ((ARRAY INT OF INT), wired_circuit) -> (ARRAY INT OF INT);

result134: ((ARRAY INT OF INT), wired_circuit) -> (ARRAY INT OF INT);

result135: ((ARRAY INT OF INT), wired_circuit, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), x1 : INT, j : INT): ((result130(x,
  x1)[j]) = (x[(j + x1)])));

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), x1 : INT, j : INT): ((result131(x,
  x1)[j]) = (x[(j + x1)])));

t2tb67: (circuit2) -> uni;

% t2tb_sort
  ASSERT (FORALL (x : circuit2): (sort(circuit3, t2tb67(x))));

tb2t67: (uni) -> circuit2;

% BridgeL
  ASSERT
  (FORALL (i : circuit2):PATTERN (t2tb67(i)):  (tb2t67(t2tb67(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb67(tb2t67(j))): 
  ((sort(circuit3, j)) => (t2tb67(tb2t67(j)) = j)));

t2tb68: ((ARRAY circuit2 OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL
  (x : (ARRAY circuit2 OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))))):
  (sort(infix_mngt(circuit3, infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int)))), t2tb68(x))));

tb2t68: (uni) -> (ARRAY circuit2 OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))));

% BridgeL
  ASSERT
  (FORALL
  (i : (ARRAY circuit2 OF (ARRAY (ARRAY INT OF INT) OF (ARRAY (ARRAY INT OF INT) OF (ARRAY INT OF INT))))):PATTERN (
  t2tb68(i)):  (tb2t68(t2tb68(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb68(tb2t68(j))):  (t2tb68(tb2t68(j)) = j));

% basis_ket_closure_def
  ASSERT
  (FORALL (y : circuit2, y1 : (ARRAY INT OF INT), y2 : (ARRAY INT OF INT),
  y3 : INT): ((tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int))), circuit3, 
  t2tb68(basis_ket_closure1), t2tb67(y)), t2tb7(y1)), t2tb7(y2)))[y3]) = 
  basis_ket1(y, y1, y2, y3)));

% result'def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), x : wired_circuit, k : INT): ((
  result132(y, x)[k]) = (y[(k + range1(to_qc1(x)))])));

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), x1 : wired_circuit, k : INT): ((
  result133(x, x1)[k]) = (x[(k + width1(to_qc1(x1)))])));

% result'def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), x : wired_circuit, k : INT): ((
  result134(y, x)[k]) = (y[(k + range1(to_qc1(x)))])));

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), x1 : wired_circuit, x2 : INT, k : INT): ((
  result135(x, x1,
  x2)[k]) = (IF (k < (width1(to_qc1(x1)) - x2)) THEN (x[k]) ELSE 0 ENDIF)));

% basis_ket'def
  ASSERT
  (FORALL (c : circuit2, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  i : INT):
  ((((((((((((((((((((((((((pre1(c) = Skip) => (basis_ket1(c, x, y,
                          i) = (x[i])))
                         AND (FORALL (x1 : INT):
                             ((pre1(c) = Phase1(x1)) => (basis_ket1(c, x, y,
                             i) = (x[i])))))
                        AND (FORALL (x1 : INT):
                            ((pre1(c) = Rx(x1)) => (basis_ket1(c, x, y,
                            i) = (y[1])))))
                       AND (FORALL (x1 : INT):
                           ((pre1(c) = Ry(x1)) => (basis_ket1(c, x, y,
                           i) = (y[1])))))
                      AND (FORALL (x1 : INT):
                          ((pre1(c) = Rz1(x1)) => (basis_ket1(c, x, y,
                          i) = (x[i])))))
                     AND (FORALL (x1 : INT):
                         ((pre1(c) = Rzp(x1)) => (basis_ket1(c, x, y,
                         i) = (x[i])))))
                    AND ((pre1(c) = Hadamard1) => (basis_ket1(c, x, y,
                        i) = (y[i]))))
                   AND ((pre1(c) = S) => (basis_ket1(c, x, y, i) = (x[i]))))
                  AND ((pre1(c) = T) => (basis_ket1(c, x, y, i) = (x[i]))))
                 AND ((pre1(c) = X) => (basis_ket1(c, x, y,
                     i) = (1 - (x[i])))))
                AND ((pre1(c) = Y) => (basis_ket1(c, x, y,
                    i) = (1 - (x[i])))))
               AND ((pre1(c) = Z) => (basis_ket1(c, x, y, i) = (x[i]))))
              AND ((pre1(c) = Bricks_Cnot)
                  => (IF (i = 1) THEN (basis_ket1(c, x, y,
                     i) = (((x[0]) * (1 - (x[1]))) + ((x[1]) * (1 - (x[0])))))
                     ELSE (basis_ket1(c, x, y, i) = (x[i])) ENDIF)))
             AND ((pre1(c) = Bricks_Toffoli)
                 => (IF (i = 2) THEN (basis_ket1(c, x, y,
                    i) = ((((x[0]) * (x[1])) * (1 - (x[2]))) + ((x[2]) * (1 - ((x[0]) * (x[1]))))))
                    ELSE (basis_ket1(c, x, y, i) = (x[i])) ENDIF)))
            AND ((pre1(c) = Bricks_Fredkin)
                => (IF (i = 1) THEN (basis_ket1(c, x, y,
                   i) = (((x[0]) * (x[2])) + ((1 - (x[0])) * (x[1]))))
                   ELSE (IF (i = 2) THEN (basis_ket1(c, x, y,
                        i) = (((x[0]) * (x[1])) + ((1 - (x[0])) * (x[2]))))
                        ELSE (basis_ket1(c, x, y, i) = (x[i])) ENDIF) ENDIF)))
           AND ((pre1(c) = Bricks_Swap)
               => (IF (i = 0) THEN (basis_ket1(c, x, y, i) = (x[1]))
                  ELSE (IF (i = 1) THEN (basis_ket1(c, x, y, i) = (x[0]))
                       ELSE (basis_ket1(c, x, y, i) = (x[i])) ENDIF) ENDIF)))
          AND (FORALL (x1 : INT, x2 : INT, x3 : INT):
              ((pre1(c) = Swap1(x1, x2, x3))
              => (IF (i = x1) THEN (basis_ket1(c, x, y, i) = (x[x2]))
                 ELSE (IF (i = x2) THEN (basis_ket1(c, x, y, i) = (x[x1]))
                      ELSE (basis_ket1(c, x, y, i) = (x[i])) ENDIF) ENDIF))))
         AND (FORALL (x1 : INT, x2 : INT, x3 : INT):
             ((pre1(c) = Cnot1(x1, x2, x3))
             => (IF (i = x2) THEN (basis_ket1(c, x, y,
                i) = (((x[x1]) * (1 - (x[x2]))) + ((x[x2]) * (1 - (x[x1])))))
                ELSE (basis_ket1(c, x, y, i) = (x[i])) ENDIF))))
        AND (FORALL (x1 : INT, x2 : INT, x3 : INT, x4 : INT):
            ((pre1(c) = Toffoli(x1, x2, x3, x4))
            => (IF (i = x3) THEN (basis_ket1(c, x, y,
               i) = ((((x[x1]) * (x[x2])) * (1 - (x[x3]))) + ((x[x3]) * (1 - ((x[x1]) * (x[x2]))))))
               ELSE (basis_ket1(c, x, y, i) = (x[i])) ENDIF))))
       AND (FORALL (x1 : INT, x2 : INT, x3 : INT, x4 : INT):
           ((pre1(c) = Fredkin(x1, x2, x3, x4))
           => (IF (i = x2) THEN (basis_ket1(c, x, y,
              i) = (((x[x1]) * (x[x3])) + ((1 - (x[x1])) * (x[x2]))))
              ELSE (IF (i = x3) THEN (basis_ket1(c, x, y,
                   i) = (((x[x1]) * (x[x2])) + ((1 - (x[x1])) * (x[x3]))))
                   ELSE (basis_ket1(c, x, y, i) = (x[i])) ENDIF) ENDIF))))
      AND (FORALL (x1 : wired_circuit, x2 : INT, x3 : INT):
          ((pre1(c) = Place(x1, x2, x3))
          => (IF ((x2 <= i) AND (i < (x2 + width1(to_qc1(x1))))) THEN (
             basis_ket1(c, x, y, i) = basis_ket1(to_qc1(x1), result130(x,
             x2), y, (i - x2))) ELSE (basis_ket1(c, x, y, i) = (x[i])) ENDIF))))
     AND (FORALL (x1 : wired_circuit, x2 : INT, x3 : INT, x4 : INT):
         ((pre1(c) = Cont(x1, x2, x3, x4))
         => (IF (((x[x2]) = 1)
                AND ((x3 <= i) AND (i < (x3 + width1(to_qc1(x1))))))
            THEN (basis_ket1(c, x, y, i) = basis_ket1(to_qc1(x1), 
            result131(x, x3), y, (i - x3))) ELSE (basis_ket1(c, x, y,
            i) = (x[i])) ENDIF))))
    AND (FORALL (x1 : wired_circuit, x2 : wired_circuit):
        ((pre1(c) = Sequence1(x1, x2)) => (basis_ket1(c, x, y, i) = 
        basis_ket1(to_qc1(x2), tb2t7(infix_at(infix_mngt(int, int), 
        infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
        infix_mngt(int, int)), infix_mngt(int, int), infix_at(infix_mngt(
        infix_mngt(int, int), infix_mngt(infix_mngt(int, int), 
        infix_mngt(int, int))), circuit3, t2tb68(basis_ket_closure1), t2tb67(
        to_qc1(x1))), t2tb7(x)), t2tb7(y))), result132(y, x1), i)))))
   AND (FORALL (x1 : wired_circuit, x2 : wired_circuit):
       ((pre1(c) = Parallel1(x1, x2))
       => (IF (i < width1(to_qc1(x1))) THEN (basis_ket1(c, x, y, i) = 
          basis_ket1(to_qc1(x1), x, y, i)) ELSE (basis_ket1(c, x, y, i) = 
          basis_ket1(to_qc1(x2), result133(x, x1), result134(y, x1), (i - 
          width1(to_qc1(x1))))) ENDIF))))
  AND (FORALL (x1 : wired_circuit, x2 : INT):
      ((pre1(c) = Ancillas1(x1, x2)) => (basis_ket1(c, x, y, i) = basis_ket1(
      to_qc1(x1), result135(x, x1, x2), y, i))))));

% basis_ket'spec
  ASSERT
  (FORALL (c : circuit2, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  i : INT):
  ((basis_ket1(c, x, y, i) = (tb2t7(infix_at(infix_mngt(int, int), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
  infix_mngt(int, int)), infix_mngt(int, int), t2tb55(h_basis_ket(
  circ_to_pps_pre1(pre1(c)))), t2tb7(x)), t2tb7(y)))[i]))
  AND ((FORALL (i1 : INT):
       (((0 <= i1) AND (i1 < width1(c)))
       => ((0 <= (x[i1])) AND ((x[i1]) < 2))))
      => ((FORALL (i1 : INT):
          (((0 <= i1) AND (i1 < range1(c)))
          => ((0 <= (y[i1])) AND ((y[i1]) < 2))))
         => (((0 <= i) AND (i < width1(c)))
            => ((0 <= basis_ket1(c, x, y, i)) AND (basis_ket1(c, x, y,
               i) < 2)))))));

% basis_ket_invariant
  ASSERT
  (FORALL (c : circuit2):
  (FORALL (x : (ARRAY INT OF INT), xqt : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), yqt : (ARRAY INT OF INT)):
  ((FORALL (i : INT):
   (((0 <= i) AND (i < width1(c))) => ((x[i]) = (xqt[i]))))
  => ((FORALL (i : INT):
      (((0 <= i) AND (i < range1(c))) => ((y[i]) = (yqt[i]))))
     => (FORALL (i : INT):
        (((0 <= i) AND (i < width1(c))) => (basis_ket1(c, x, y, i) = 
        basis_ket1(c, xqt, yqt, i))))))));

% binary_l_basis_ket
  ASSERT
  (FORALL (c : circuit2, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  w : INT):
  ((binary_l(x, width1(c)))
  => ((binary_l(y, range1(c)))
     => ((width1(c) = w) => (binary_l(tb2t7(infix_at(infix_mngt(int, int), 
        infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
        infix_mngt(int, int)), infix_mngt(int, int), infix_at(infix_mngt(
        infix_mngt(int, int), infix_mngt(infix_mngt(int, int), 
        infix_mngt(int, int))), circuit3, t2tb68(basis_ket_closure1), 
        t2tb67(c)), t2tb7(x)), t2tb7(y))), w))))));

ang_ind1: (circuit2, (ARRAY INT OF INT), (ARRAY INT OF INT)) -> angle;

result136: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

result137: ((ARRAY INT OF INT), INT) -> (ARRAY INT OF INT);

result138: ((ARRAY INT OF INT), wired_circuit) -> (ARRAY INT OF INT);

result139: ((ARRAY INT OF INT), wired_circuit) -> (ARRAY INT OF INT);

result140: ((ARRAY INT OF INT), wired_circuit) -> (ARRAY INT OF INT);

result141: ((ARRAY INT OF INT), wired_circuit, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), x1 : INT, j : INT): ((result136(x,
  x1)[j]) = (x[(j + x1)])));

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), x1 : INT, j : INT): ((result137(x,
  x1)[j]) = (x[(j + x1)])));

% result'def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), x : wired_circuit, k : INT): ((
  result138(y, x)[k]) = (y[(k + range1(to_qc1(x)))])));

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), x1 : wired_circuit, k : INT): ((
  result139(x, x1)[k]) = (x[(k + width1(to_qc1(x1)))])));

% result'def
  ASSERT
  (FORALL (y : (ARRAY INT OF INT), x : wired_circuit, k : INT): ((
  result140(y, x)[k]) = (y[(k + range1(to_qc1(x)))])));

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), x1 : wired_circuit, x2 : INT, k : INT): ((
  result141(x, x1,
  x2)[k]) = (IF (k < (width1(to_qc1(x1)) - x2)) THEN (x[k]) ELSE 0 ENDIF)));

% ang_ind'def
  ASSERT
  (FORALL (c : circuit2, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
  ((((((((((((((((((((((((((pre1(c) = Skip) => (ang_ind1(c, x, y) = 
                          infix_sldtsl(0, 0)))
                         AND (FORALL (x1 : INT):
                             ((pre1(c) = Phase1(x1)) => (ang_ind1(c, x, y) = 
                             infix_sldtsl(1, x1)))))
                        AND (FORALL (x1 : INT):
                            ((pre1(c) = Rx(x1)) => (ang_ind1(c, x, y) = 
                            ang_add(ang_add(infix_sldtsl(((x[0]) * (y[0])),
                            1), infix_sldtsl(((y[0]) * (y[1])), 1)), 
                            phase_inv_(((y[0]) - 1), infix_sldtsl(1, 
                            incr_abs(x1))))))))
                       AND (FORALL (x1 : INT):
                           ((pre1(c) = Ry(x1)) => (ang_ind1(c, x, y) = 
                           ang_add(ang_add(ang_add(
                           infix_sldtsl(((x[0]) * (y[0])), 1), 
                           infix_sldtsl(((y[0]) * (y[1])), 1)), 
                           phase_inv_(((y[0]) - 1), infix_sldtsl(1, 
                           incr_abs(x1)))), infix_sldtsl(((y[1]) - (x[0])),
                           2))))))
                      AND (FORALL (x1 : INT):
                          ((pre1(c) = Rz1(x1)) => (ang_ind1(c, x, y) = 
                          phase_inv_(((x[0]) - 1), infix_sldtsl(1, 
                          incr_abs(x1)))))))
                     AND (FORALL (x1 : INT):
                         ((pre1(c) = Rzp(x1)) => (ang_ind1(c, x, y) = 
                         infix_sldtsl((x[0]), x1)))))
                    AND ((pre1(c) = Hadamard1) => (ang_ind1(c, x, y) = 
                        infix_sldtsl(((x[0]) * (y[0])), 1))))
                   AND ((pre1(c) = S) => (ang_ind1(c, x, y) = 
                       infix_sldtsl((x[0]), 2))))
                  AND ((pre1(c) = T) => (ang_ind1(c, x, y) = 
                      infix_sldtsl((x[0]), 3))))
                 AND ((pre1(c) = X) => (ang_ind1(c, x, y) = infix_sldtsl(1,
                     0))))
                AND ((pre1(c) = Y) => (ang_ind1(c, x, y) = phase_inv_((x[0]), 
                    infix_sldtsl(1, 2)))))
               AND ((pre1(c) = Z) => (ang_ind1(c, x, y) = 
                   infix_sldtsl((x[0]), 1))))
              AND ((pre1(c) = Bricks_Cnot) => (ang_ind1(c, x, y) = 
                  infix_sldtsl(1, 0))))
             AND ((pre1(c) = Bricks_Toffoli) => (ang_ind1(c, x, y) = 
                 infix_sldtsl(1, 0))))
            AND ((pre1(c) = Bricks_Fredkin) => (ang_ind1(c, x, y) = 
                infix_sldtsl(1, 0))))
           AND ((pre1(c) = Bricks_Swap) => (ang_ind1(c, x, y) = 
               infix_sldtsl(1, 0))))
          AND (FORALL (x1 : INT, x2 : INT, x3 : INT):
              ((pre1(c) = Swap1(x1, x2, x3)) => (ang_ind1(c, x, y) = 
              infix_sldtsl(1, 0)))))
         AND (FORALL (x1 : INT, x2 : INT, x3 : INT):
             ((pre1(c) = Cnot1(x1, x2, x3)) => (ang_ind1(c, x, y) = 
             infix_sldtsl(1, 0)))))
        AND (FORALL (x1 : INT, x2 : INT, x3 : INT, x4 : INT):
            ((pre1(c) = Toffoli(x1, x2, x3, x4)) => (ang_ind1(c, x, y) = 
            infix_sldtsl(1, 0)))))
       AND (FORALL (x1 : INT, x2 : INT, x3 : INT, x4 : INT):
           ((pre1(c) = Fredkin(x1, x2, x3, x4)) => (ang_ind1(c, x, y) = 
           infix_sldtsl(1, 0)))))
      AND (FORALL (x1 : wired_circuit, x2 : INT, x3 : INT):
          ((pre1(c) = Place(x1, x2, x3)) => (ang_ind1(c, x, y) = tb2t33(
          infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
          infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(
          h_angle(circ_to_pps_pre1(x1))), t2tb7(result136(x, x2))), 
          t2tb7(y)))))))
     AND (FORALL (x1 : wired_circuit, x2 : INT, x3 : INT, x4 : INT):
         ((pre1(c) = Cont(x1, x2, x3, x4)) => (ang_ind1(c, x, y) = ang_add(
         ang_mult_int(tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
         infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), 
         t2tb57(h_angle(circ_to_pps_pre1(x1))), t2tb7(result137(x, x3))), 
         t2tb7(y))), (x[x2])), ang_mult_int(phase_inv_((y[0]), arc_cos_ang(
         pow_inv_sqrt_2(range1(to_qc1(x1))))), (1 - (x[x2]))))))))
    AND (FORALL (x1 : wired_circuit, x2 : wired_circuit):
        ((pre1(c) = Sequence1(x1, x2)) => (ang_ind1(c, x, y) = ang_add(
        tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
        infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(h_angle(
        circ_to_pps_pre1(x1))), t2tb7(x)), t2tb7(y))), tb2t33(
        infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
        infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(h_angle(
        circ_to_pps_pre1(x2))), infix_at(infix_mngt(int, int), 
        infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
        infix_mngt(int, int)), infix_mngt(int, int), infix_at(infix_mngt(
        infix_mngt(int, int), infix_mngt(infix_mngt(int, int), 
        infix_mngt(int, int))), circuit3, t2tb68(basis_ket_closure1), t2tb67(
        to_qc1(x1))), t2tb7(x)), t2tb7(y))), t2tb7(result138(y, x1)))))))))
   AND (FORALL (x1 : wired_circuit, x2 : wired_circuit):
       ((pre1(c) = Parallel1(x1, x2)) => (ang_ind1(c, x, y) = ang_add(tb2t33(
       infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
       infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(h_angle(
       circ_to_pps_pre1(x1))), t2tb7(x)), t2tb7(y))), tb2t33(infix_at(angle1, 
       infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int),
       angle1), infix_mngt(int, int), t2tb57(h_angle(circ_to_pps_pre1(x2))), 
       t2tb7(result139(x, x1))), t2tb7(result140(y, x1)))))))))
  AND (FORALL (x1 : wired_circuit, x2 : INT):
      ((pre1(c) = Ancillas1(x1, x2)) => (ang_ind1(c, x, y) = tb2t33(
      infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
      infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(h_angle(
      circ_to_pps_pre1(x1))), t2tb7(result141(x, x1, x2))), t2tb7(y))))))));

% ang_ind'spec
  ASSERT
  (FORALL (c : circuit2, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
  ang_ind1(c, x, y) = tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(
  h_angle(circ_to_pps_pre1(pre1(c)))), t2tb7(x)), t2tb7(y)))));

% ang_ind_invariant
  ASSERT
  (FORALL (c : circuit2):
  (FORALL (x : (ARRAY INT OF INT), xqt : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), yqt : (ARRAY INT OF INT)):
  ((FORALL (i : INT):
   (((0 <= i) AND (i < width1(c))) => ((x[i]) = (xqt[i]))))
  => ((FORALL (i : INT):
      (((0 <= i) AND (i < range1(c))) => ((y[i]) = (yqt[i]))))
     => (ang_ind1(c, x, y) = ang_ind1(c, xqt, yqt))))));

unwire_pre: (wired_circuit) -> circuit;

% unwire_pre'def
  ASSERT
  (FORALL (c : wired_circuit):
  ((correct1(c))
  => ((((((((((((((((((((((((((c = Skip) => (unwire_pre(c) = id))
                            AND (FORALL (k : INT):
                                ((c = Phase1(k)) => (unwire_pre(c) = 
                                phase(k)))))
                           AND (FORALL (k : INT):
                               ((c = Rx(k)) => (unwire_pre(c) = rx(k)))))
                          AND (FORALL (k : INT):
                              ((c = Ry(k)) => (unwire_pre(c) = ry(k)))))
                         AND (FORALL (k : INT):
                             ((c = Rz1(k)) => (unwire_pre(c) = rz_(k)))))
                        AND (FORALL (k : INT):
                            ((c = Rzp(k)) => (unwire_pre(c) = rz(k)))))
                       AND ((c = Hadamard1) => (unwire_pre(c) = hadamard)))
                      AND ((c = S) => (unwire_pre(c) = rz(2))))
                     AND ((c = T) => (unwire_pre(c) = rz(3))))
                    AND ((c = X) => (unwire_pre(c) = xx)))
                   AND ((c = Y) => (unwire_pre(c) = yy)))
                  AND ((c = Z) => (unwire_pre(c) = zz)))
                 AND ((c = Bricks_Cnot) => (unwire_pre(c) = cnot)))
                AND ((c = Bricks_Toffoli) => (unwire_pre(c) = toffoli)))
               AND ((c = Bricks_Fredkin) => (unwire_pre(c) = fredkin)))
              AND ((c = Bricks_Swap) => (unwire_pre(c) = swap)))
             AND (FORALL (t1 : INT, t2 : INT, n : INT):
                 ((c = Swap1(t1, t2, n)) => (unwire_pre(c) = swap_c(t1, t2,
                 n)))))
            AND (FORALL (c1 : INT, t1 : INT, n : INT):
                ((c = Cnot1(c1, t1, n)) => (unwire_pre(c) = place_cnot(c1,
                t1, n)))))
           AND (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
               ((c = Toffoli(c1, c2, t1, n)) => (unwire_pre(c) = 
               place_toffoli(c1, c2, t1, n)))))
          AND (FORALL (c1 : INT, t1 : INT, t2 : INT, n : INT):
              ((c = Fredkin(c1, t1, t2, n)) => (unwire_pre(c) = 
              place_fredkin(c1, t1, t2, n)))))
         AND (FORALL (c1 : wired_circuit, p : INT, n : INT):
             ((c = Place(c1, p, n)) => (unwire_pre(c) = place(unwire_pre(c1),
             p, n)))))
        AND (FORALL (c1 : wired_circuit, co : INT, t1 : INT, n : INT):
            ((c = Cont(c1, co, t1, n)) => (unwire_pre(c) = cont(
            unwire_pre(c1), co, t1, n)))))
       AND (FORALL (d : wired_circuit, e : wired_circuit):
           ((c = Sequence1(d, e)) => (unwire_pre(c) = sequence(unwire_pre(d), 
           unwire_pre(e))))))
      AND (FORALL (d : wired_circuit, e : wired_circuit):
          ((c = Parallel1(d, e)) => (unwire_pre(c) = parallel(unwire_pre(d), 
          unwire_pre(e))))))
     AND (FORALL (d : wired_circuit, l : INT):
         ((c = Ancillas1(d, l)) => (unwire_pre(c) = ancilla(unwire_pre(d),
         l)))))));

% unwire_pre'spec
  ASSERT
  (FORALL (c : wired_circuit):
  ((correct1(c))
  => ((width(unwire_pre(c)) = width_pre1(c))
     AND ((correct_path_sum_(unwire_pre(c), circ_to_pps_pre1(c)))
         AND (FORALL (x : matrix_complex):
             ((is_a_ket_l(x, width_pre1(c))) => (path_sem(unwire_pre(c),
             x) = pps_apply(circ_to_pps_pre1(c), x))))))));

circ_to_pps1: (circuit2) -> pps;

% circ_to_pps'def
  ASSERT
  (FORALL (c : circuit2): (circ_to_pps1(c) = circ_to_pps_pre1(pre1(c))));

% circ_to_pps'spec
  ASSERT
  (FORALL (c : circuit2):
  ((1 <= h_width(circ_to_pps1(c)))
  AND ((h_width(circ_to_pps1(c)) = width1(c))
      AND ((h_range(circ_to_pps1(c)) = range1(c))
          AND ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
               i : INT): ((tb2t7(infix_at(infix_mngt(int, int), 
               infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
               int), infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
               h_basis_ket(circ_to_pps1(c))), t2tb7(x)), t2tb7(y)))[i]) = 
               basis_ket1(c, x, y, i)))
              AND (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
                  tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                  int), t2tb57(h_angle(circ_to_pps1(c))), t2tb7(x)), 
                  t2tb7(y))) = ang_ind1(c, x, y))))))));

unwire: (circuit2) -> circuit;

% unwire'def
  ASSERT (FORALL (c : circuit2): (unwire(c) = unwire_pre(pre1(c))));

% unwire'spec
  ASSERT
  (FORALL (c : circuit2):
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => (path_sem(unwire(c), x) = pps_apply(
  circ_to_pps1(c), x)))));

phase1: (INT) -> circuit2;

% phase'spec
  ASSERT
  (FORALL (k : INT):
  ((pre1(phase1(k)) = Phase1(k))
  AND ((ancillas1(phase1(k)) = 0)
      AND ((size1(phase1(k)) = 1)
          AND ((range1(phase1(k)) = 0)
              AND ((width1(phase1(k)) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(phase1(k), x, y,
                       i) = (x[i]))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(phase1(k), x,
                          y) = infix_sldtsl(1, k))))))))));

skip: circuit2;

% skip'def
  ASSERT
  ((pre1(skip) = Skip)
  AND ((ancillas1(skip) = 0)
      AND ((size1(skip) = 0)
          AND ((range1(skip) = 0)
              AND ((width1(skip) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(skip, x, y,
                       i) = (x[i]))))
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)): (ang_ind1(skip, x, y) = 
                           infix_sldtsl(1, 0)))
                          AND (FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)):
                              (FORALL (k : INT): (ang_ind1(skip, x, y) = 
                              infix_sldtsl(0, k)))))))))));

rz1: (INT) -> circuit2;

% rz'spec
  ASSERT
  (FORALL (k : INT):
  ((pre1(rz1(k)) = Rz1(k))
  AND ((ancillas1(rz1(k)) = 0)
      AND ((size1(rz1(k)) = 1)
          AND ((range1(rz1(k)) = 0)
              AND ((width1(rz1(k)) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(rz1(k), x, y,
                       i) = (x[i]))))
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)):
                           (((0 <= (x[0])) AND ((x[0]) < 2))
                           => ((k < 0) => (ang_ind1(rz1(k), x, y) = 
                              phase_inv_(((x[0]) - 1), infix_sldtsl(1,
                              (k - 1)))))))
                          AND ((FORALL (x : (ARRAY INT OF INT),
                               y : (ARRAY INT OF INT)):
                               (((0 <= (x[0])) AND ((x[0]) < 2))
                               => ((0 <= k) => (ang_ind1(rz1(k), x, y) = 
                                  phase_inv_(((x[0]) - 1), infix_sldtsl(1,
                                  (k + 1)))))))
                              AND (FORALL (x : (ARRAY INT OF INT),
                                  y : (ARRAY INT OF INT)):
                                  (((0 <= (x[0])) AND ((x[0]) < 2)) => (
                                  ang_ind1(rz1(k), x, y) = 
                                  phase_inv_(((x[0]) - 1), infix_sldtsl(1, 
                                  incr_abs(k)))))))))))))));

rzp: (INT) -> circuit2;

% rzp'spec
  ASSERT
  (FORALL (k : INT):
  ((pre1(rzp(k)) = Rzp(k))
  AND ((ancillas1(rzp(k)) = 0)
      AND ((size1(rzp(k)) = 1)
          AND ((range1(rzp(k)) = 0)
              AND ((width1(rzp(k)) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(rzp(k), x, y,
                       i) = (x[i]))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(rzp(k), x, y) = 
                          infix_sldtsl((x[0]), k))))))))));

rx1: (INT) -> circuit2;

% rx'spec
  ASSERT
  (FORALL (k : INT):
  ((pre1(rx1(k)) = Rx(k))
  AND ((ancillas1(rx1(k)) = 0)
      AND ((size1(rx1(k)) = 1)
          AND ((range1(rx1(k)) = 2)
              AND ((width1(rx1(k)) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(rx1(k), x, y,
                       i) = (y[1]))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(rx1(k), x, y) = 
                          ang_add(ang_add(infix_sldtsl(((x[0]) * (y[0])), 1), 
                          infix_sldtsl(((y[0]) * (y[1])), 1)), 
                          phase_inv_(((y[0]) - 1), infix_sldtsl(1, 
                          incr_abs(k)))))))))))));

ry1: (INT) -> circuit2;

% ry'spec
  ASSERT
  (FORALL (k : INT):
  ((pre1(ry1(k)) = Ry(k))
  AND ((ancillas1(ry1(k)) = 0)
      AND ((size1(ry1(k)) = 1)
          AND ((range1(ry1(k)) = 2)
              AND ((width1(ry1(k)) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(ry1(k), x, y,
                       i) = (y[1]))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(ry1(k), x, y) = 
                          ang_add(ang_add(ang_add(
                          infix_sldtsl(((x[0]) * (y[0])), 1), 
                          infix_sldtsl(((y[0]) * (y[1])), 1)), 
                          phase_inv_(((y[0]) - 1), infix_sldtsl(1, 
                          incr_abs(k)))), infix_sldtsl(((y[1]) - (x[0])),
                          2)))))))))));

hadamard1: circuit2;

% hadamard'def
  ASSERT
  ((pre1(hadamard1) = Hadamard1)
  AND ((ancillas1(hadamard1) = 0)
      AND ((size1(hadamard1) = 1)
          AND ((range1(hadamard1) = 1)
              AND ((width1(hadamard1) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(hadamard1, x, y,
                       i) = (y[i]))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(hadamard1, x,
                          y) = infix_sldtsl(((x[0]) * (y[0])), 1)))))))));

s: circuit2;

% s'def
  ASSERT
  ((pre1(s) = S)
  AND ((ancillas1(s) = 0)
      AND ((size1(s) = 1)
          AND ((range1(s) = 0)
              AND ((width1(s) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(s, x, y, i) = (x[i]))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(s, x, y) = 
                          infix_sldtsl((x[0]), 2)))))))));

t: circuit2;

% t'def
  ASSERT
  ((pre1(t) = T)
  AND ((ancillas1(t) = 0)
      AND ((size1(t) = 1)
          AND ((range1(t) = 0)
              AND ((width1(t) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(t, x, y, i) = (x[i]))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(t, x, y) = 
                          infix_sldtsl((x[0]), 3)))))))));

xx1: circuit2;

% xx'def
  ASSERT
  ((pre1(xx1) = X)
  AND ((ancillas1(xx1) = 0)
      AND ((size1(xx1) = 1)
          AND ((range1(xx1) = 0)
              AND ((width1(xx1) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(xx1, x, y,
                       i) = (1 - (x[i])))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(xx1, x, y) = 
                          infix_sldtsl(1, 0)))))))));

yy1: circuit2;

% yy'def
  ASSERT
  ((pre1(yy1) = Y)
  AND ((ancillas1(yy1) = 0)
      AND ((size1(yy1) = 1)
          AND ((range1(yy1) = 0)
              AND ((width1(yy1) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(yy1, x, y,
                       i) = (1 - (x[i])))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(yy1, x, y) = 
                          phase_inv_((x[0]), infix_sldtsl(1, 2))))))))));

zz1: circuit2;

% zz'def
  ASSERT
  ((pre1(zz1) = Z)
  AND ((ancillas1(zz1) = 0)
      AND ((size1(zz1) = 1)
          AND ((range1(zz1) = 0)
              AND ((width1(zz1) = 1)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(zz1, x, y,
                       i) = (x[i]))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(zz1, x, y) = 
                          infix_sldtsl((x[0]), 1)))))))));

bricks_cnot: circuit2;

% bricks_cnot'def
  ASSERT
  ((pre1(bricks_cnot) = Bricks_Cnot)
  AND ((ancillas1(bricks_cnot) = 0)
      AND ((size1(bricks_cnot) = 1)
          AND ((range1(bricks_cnot) = 0)
              AND ((width1(bricks_cnot) = 2)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT):
                       ((NOT (i = 1)) => (basis_ket1(bricks_cnot, x, y,
                       i) = (x[i])))))
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)):
                           (FORALL (i : INT):
                           ((i = 1) => (basis_ket1(bricks_cnot, x, y,
                           i) = (((x[0]) * (1 - (x[1]))) + ((x[1]) * (1 - (x[0]))))))))
                          AND (FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)): (ang_ind1(bricks_cnot,
                              x, y) = infix_sldtsl(1, 0))))))))));

bricks_toffoli: circuit2;

% bricks_toffoli'def
  ASSERT
  ((pre1(bricks_toffoli) = Bricks_Toffoli)
  AND ((ancillas1(bricks_toffoli) = 0)
      AND ((size1(bricks_toffoli) = 1)
          AND ((range1(bricks_toffoli) = 0)
              AND ((width1(bricks_toffoli) = 3)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT):
                       ((NOT (i = 2)) => (basis_ket1(bricks_toffoli, x, y,
                       i) = (x[i])))))
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)):
                           (FORALL (i : INT):
                           ((i = 2) => (basis_ket1(bricks_toffoli, x, y,
                           i) = ((((x[0]) * (x[1])) * (1 - (x[2]))) + ((x[2]) * (1 - ((x[0]) * (x[1])))))))))
                          AND (FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)): (
                              ang_ind1(bricks_toffoli, x, y) = 
                              infix_sldtsl(1, 0))))))))));

bricks_fredkin: circuit2;

% bricks_fredkin'def
  ASSERT
  ((pre1(bricks_fredkin) = Bricks_Fredkin)
  AND ((ancillas1(bricks_fredkin) = 0)
      AND ((size1(bricks_fredkin) = 1)
          AND ((range1(bricks_fredkin) = 0)
              AND ((width1(bricks_fredkin) = 3)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT):
                       ((i = 1) => (basis_ket1(bricks_fredkin, x, y,
                       i) = (((x[0]) * (x[2])) + ((1 - (x[0])) * (x[1])))))))
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT)):
                           (FORALL (i : INT):
                           ((i = 2) => (basis_ket1(bricks_fredkin, x, y,
                           i) = (((x[0]) * (x[1])) + ((1 - (x[0])) * (x[2])))))))
                          AND ((FORALL (x : (ARRAY INT OF INT),
                               y : (ARRAY INT OF INT)):
                               (FORALL (i : INT):
                               ((NOT (i = 1))
                               => ((NOT (i = 2)) => (
                                  basis_ket1(bricks_fredkin, x, y,
                                  i) = (x[i]))))))
                              AND (FORALL (x : (ARRAY INT OF INT),
                                  y : (ARRAY INT OF INT)): (
                                  ang_ind1(bricks_fredkin, x, y) = 
                                  infix_sldtsl(1, 0)))))))))));

bricks_swap: circuit2;

% bricks_swap'def
  ASSERT
  ((pre1(bricks_swap) = Bricks_Swap)
  AND ((ancillas1(bricks_swap) = 0)
      AND ((size1(bricks_swap) = 1)
          AND ((range1(bricks_swap) = 0)
              AND ((width1(bricks_swap) = 2)
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(bricks_swap, x, y,
                       i) = (IF (i = 0) THEN (x[1])
                            ELSE (IF (i = 1) THEN (x[0]) ELSE (x[i]) ENDIF) ENDIF))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(bricks_swap, x,
                          y) = infix_sldtsl(1, 0)))))))));

cnot1: (INT, INT, INT) -> circuit2;

% cnot'spec
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (t1 = co))
        => ((pre1(cnot1(co, t1, n)) = Cnot1(co, t1, n))
           AND ((ancillas1(cnot1(co, t1, n)) = 0)
               AND ((size1(cnot1(co, t1, n)) = 1)
                   AND ((range1(cnot1(co, t1, n)) = 0)
                       AND ((width1(cnot1(co, t1, n)) = n)
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (i : INT):
                                ((NOT (i = t1)) => (basis_ket1(cnot1(co, t1,
                                n), x, y, i) = (x[i])))))
                               AND ((FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    (FORALL (i : INT):
                                    ((i = t1) => (basis_ket1(cnot1(co, t1,
                                    n), x, y,
                                    i) = (((x[co]) * (1 - (x[t1]))) + ((x[t1]) * (1 - (x[co]))))))))
                                   AND (FORALL (x : (ARRAY INT OF INT),
                                       y : (ARRAY INT OF INT)): (ang_ind1(
                                       cnot1(co, t1, n), x, y) = 
                                       infix_sldtsl(1, 0))))))))))))));

toffoli1: (INT, INT, INT, INT) -> circuit2;

% toffoli'spec
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (t1 = c1))
           => ((NOT (t1 = c2))
              => ((NOT (c2 = c1))
                 => ((pre1(toffoli1(c1, c2, t1, n)) = Toffoli(c1, c2, t1, n))
                    AND ((ancillas1(toffoli1(c1, c2, t1, n)) = 0)
                        AND ((size1(toffoli1(c1, c2, t1, n)) = 1)
                            AND ((range1(toffoli1(c1, c2, t1, n)) = 0)
                                AND ((width1(toffoli1(c1, c2, t1, n)) = n)
                                    AND ((FORALL (x : (ARRAY INT OF INT),
                                         y : (ARRAY INT OF INT)):
                                         (FORALL (i : INT):
                                         ((NOT (i = t1)) => (basis_ket1(
                                         toffoli1(c1, c2, t1, n), x, y,
                                         i) = (x[i])))))
                                        AND ((FORALL (x : (ARRAY INT OF INT),
                                             y : (ARRAY INT OF INT)):
                                             (FORALL (i : INT):
                                             ((i = t1) => (basis_ket1(
                                             toffoli1(c1, c2, t1, n), x, y,
                                             i) = ((((x[c1]) * (x[c2])) * (1 - (x[t1]))) + ((x[t1]) * (1 - ((x[c1]) * (x[c2])))))))))
                                            AND (FORALL
                                                (x : (ARRAY INT OF INT),
                                                y : (ARRAY INT OF INT)): (
                                                ang_ind1(toffoli1(c1, c2, t1,
                                                n), x, y) = infix_sldtsl(1,
                                                0)))))))))))))))));

fredkin1: (INT, INT, INT, INT) -> circuit2;

% fredkin'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (c = t1))
           => ((NOT (c = t2))
              => ((NOT (t2 = t1))
                 => ((pre1(fredkin1(c, t1, t2, n)) = Fredkin(c, t1, t2, n))
                    AND ((ancillas1(fredkin1(c, t1, t2, n)) = 0)
                        AND ((size1(fredkin1(c, t1, t2, n)) = 1)
                            AND ((range1(fredkin1(c, t1, t2, n)) = 0)
                                AND ((width1(fredkin1(c, t1, t2, n)) = n)
                                    AND ((FORALL (x : (ARRAY INT OF INT),
                                         y : (ARRAY INT OF INT)):
                                         (FORALL (i : INT):
                                         ((i = t1) => (basis_ket1(fredkin1(c,
                                         t1, t2, n), x, y,
                                         i) = (((x[c]) * (x[t2])) + ((1 - (x[c])) * (x[t1])))))))
                                        AND ((FORALL (x : (ARRAY INT OF INT),
                                             y : (ARRAY INT OF INT)):
                                             (FORALL (i : INT):
                                             ((i = t2) => (basis_ket1(
                                             fredkin1(c, t1, t2, n), x, y,
                                             i) = (((x[c]) * (x[t1])) + ((1 - (x[c])) * (x[t2])))))))
                                            AND ((FORALL
                                                 (x : (ARRAY INT OF INT),
                                                 y : (ARRAY INT OF INT)):
                                                 (FORALL (i : INT):
                                                 ((NOT (i = t1))
                                                 => ((NOT (i = t2)) => (
                                                    basis_ket1(fredkin1(c,
                                                    t1, t2, n), x, y,
                                                    i) = (x[i]))))))
                                                AND (FORALL
                                                    (x : (ARRAY INT OF INT),
                                                    y : (ARRAY INT OF INT)):
                                                    (ang_ind1(fredkin1(c, t1,
                                                    t2, n), x, y) = 
                                                    infix_sldtsl(1, 0))))))))))))))))));

swap1: (INT, INT, INT) -> circuit2;

% swap'spec
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2))
        => ((pre1(swap1(t1, t2, n)) = Swap1(t1, t2, n))
           AND ((ancillas1(swap1(t1, t2, n)) = 0)
               AND ((size1(swap1(t1, t2, n)) = 1)
                   AND ((range1(swap1(t1, t2, n)) = 0)
                       AND ((width1(swap1(t1, t2, n)) = n)
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (i : INT):
                                ((i = t1) => (basis_ket1(swap1(t1, t2, n), x,
                                y, i) = (x[t2])))))
                               AND ((FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    (FORALL (i : INT):
                                    ((i = t2) => (basis_ket1(swap1(t1, t2,
                                    n), x, y, i) = (x[t1])))))
                                   AND ((FORALL (x : (ARRAY INT OF INT),
                                        y : (ARRAY INT OF INT)):
                                        (FORALL (i : INT):
                                        ((NOT (i = t1))
                                        => ((NOT (i = t2)) => (basis_ket1(
                                           swap1(t1, t2, n), x, y,
                                           i) = (x[i]))))))
                                       AND (FORALL (x : (ARRAY INT OF INT),
                                           y : (ARRAY INT OF INT)): (
                                           ang_ind1(swap1(t1, t2, n), x,
                                           y) = infix_sldtsl(1, 0)))))))))))))));

place1: (circuit2, INT, INT) -> circuit2;

fc604: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc605: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, x : (ARRAY INT OF INT), j : INT): ((fc604(k,
  x)[j]) = (x[(j + k)])));

% fc'def
  ASSERT
  (FORALL (k : INT, x : (ARRAY INT OF INT), j : INT): ((fc605(k,
  x)[j]) = (x[(j + k)])));

% place'spec
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((pre1(place1(c, k, n)) = Place(pre1(c), k, n))
        AND ((ancillas1(place1(c, k, n)) = ancillas1(c))
            AND ((size1(place1(c, k, n)) = size1(c))
                AND ((width1(place1(c, k, n)) = n)
                    AND ((range1(place1(c, k, n)) = range1(c))
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)):
                             (FORALL (i : INT): (basis_ket1(place1(c, k, n),
                             x, y,
                             i) = (IF ((k <= i) AND (i < (k + width1(c))))
                                  THEN basis_ket1(c, fc604(k, x), y, (i - k))
                                  ELSE (x[i]) ENDIF))))
                            AND (FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)): (ang_ind1(place1(c,
                                k, n), x, y) = ang_ind1(c, fc605(k, x), y))))))))))));

cont1: (circuit2, INT, INT, INT) -> circuit2;

fc1060: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1061: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, x : (ARRAY INT OF INT), j : INT): ((fc1060(k,
  x)[j]) = (x[(j + k)])));

% fc'def
  ASSERT
  (FORALL (k : INT, x : (ARRAY INT OF INT), j : INT): ((fc1061(k,
  x)[j]) = (x[(j + k)])));

% cont'spec
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co))
        => ((pre1(cont1(c, co, k, n)) = Cont(pre1(c), co, k, n))
           AND ((width1(cont1(c, co, k, n)) = n)
               AND ((ancillas1(cont1(c, co, k, n)) = ancillas1(c))
                   AND ((size1(cont1(c, co, k, n)) = (size1(c) * cont_size1))
                       AND ((range1(cont1(c, co, k, n)) = range1(c))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (i : INT): (basis_ket1(cont1(c, co,
                                k, n), x, y,
                                i) = (IF (((x[co]) = 1)
                                         AND ((k <= i) AND (i < (k + 
                                             width1(c)))))
                                     THEN basis_ket1(c, fc1060(k, x), y,
                                     (i - k)) ELSE (x[i]) ENDIF))))
                               AND (FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)): (ang_ind1(
                                   cont1(c, co, k, n), x, y) = ang_add(
                                   ang_mult_int(ang_ind1(c, fc1061(k, x), y),
                                   (x[co])), ang_mult_int(phase_inv_((y[0]), 
                                   arc_cos_ang(pow_inv_sqrt_2(range1(c)))),
                                   (1 - (x[co]))))))))))))))));

infix_mnmn: (circuit2, circuit2) -> circuit2;

fc1062: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1063: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc1062(d,
  y)[k]) = (y[(k + range1(d))])));

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc1063(d,
  y)[k]) = (y[(k + range1(d))])));

% infix --'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((pre1(infix_mnmn(d, e)) = Sequence1(pre1(d), pre1(e)))
     AND ((ancillas1(infix_mnmn(d, e)) = max(ancillas1(d), ancillas1(e)))
         AND ((size1(infix_mnmn(d, e)) = (size1(d) + size1(e)))
             AND ((width1(infix_mnmn(d, e)) = width1(d))
                 AND ((range1(infix_mnmn(d, e)) = (range1(d) + range1(e)))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)):
                          (FORALL (i : INT): (basis_ket1(infix_mnmn(d, e), x,
                          y, i) = basis_ket1(e, tb2t7(infix_at(
                          infix_mngt(int, int), infix_mngt(int, int), 
                          infix_at(infix_mngt(infix_mngt(int, int), 
                          infix_mngt(int, int)), infix_mngt(int, int), 
                          infix_at(infix_mngt(infix_mngt(int, int), 
                          infix_mngt(infix_mngt(int, int), infix_mngt(int,
                          int))), circuit3, t2tb68(basis_ket_closure1), 
                          t2tb67(d)), t2tb7(x)), t2tb7(y))), fc1062(d, y),
                          i))))
                         AND (FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)): (ang_ind1(infix_mnmn(d,
                             e), x, y) = ang_add(ang_ind1(d, x, y), 
                             ang_ind1(e, tb2t7(infix_at(infix_mngt(int, int), 
                             infix_mngt(int, int), infix_at(infix_mngt(
                             infix_mngt(int, int), infix_mngt(int, int)), 
                             infix_mngt(int, int), infix_at(infix_mngt(
                             infix_mngt(int, int), infix_mngt(infix_mngt(int,
                             int), infix_mngt(int, int))), circuit3, 
                             t2tb68(basis_ket_closure1), t2tb67(d)), 
                             t2tb7(x)), t2tb7(y))), fc1063(d, y)))))))))))));

% sequence_eq
  ASSERT
  (FORALL (d : circuit2, dqt : circuit2, e : circuit2, eqt : circuit2):
  ((width1(d) = width1(e))
  => ((d = dqt) => ((e = eqt) => (infix_mnmn(d, e) = infix_mnmn(dqt, eqt))))));

infix_slsl: (circuit2, circuit2) -> circuit2;

fc1064: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1065: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1066: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1067: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit2, x : (ARRAY INT OF INT), k : INT): ((fc1064(d,
  x)[k]) = (x[(k + width1(d))])));

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc1065(d,
  y)[k]) = (y[(k + range1(d))])));

% fc'def
  ASSERT
  (FORALL (d : circuit2, x : (ARRAY INT OF INT), k : INT): ((fc1066(d,
  x)[k]) = (x[(k + width1(d))])));

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc1067(d,
  y)[k]) = (y[(k + range1(d))])));

% infix //'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((pre1(infix_slsl(d, e)) = Parallel1(pre1(d), pre1(e)))
  AND ((ancillas1(infix_slsl(d, e)) = (ancillas1(d) + ancillas1(e)))
      AND ((size1(infix_slsl(d, e)) = (size1(d) + size1(e)))
          AND ((width1(infix_slsl(d, e)) = (width1(d) + width1(e)))
              AND ((range1(infix_slsl(d, e)) = (range1(d) + range1(e)))
                  AND ((FORALL (x : (ARRAY INT OF INT),
                       y : (ARRAY INT OF INT)):
                       (FORALL (i : INT): (basis_ket1(infix_slsl(d, e), x, y,
                       i) = (IF (i < width1(d)) THEN basis_ket1(d, x, y, i)
                            ELSE basis_ket1(e, fc1064(d, x), fc1065(d, y),
                            (i - width1(d))) ENDIF))))
                      AND (FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(infix_slsl(d,
                          e), x, y) = ang_add(ang_ind1(d, x, y), ang_ind1(e, 
                          fc1066(d, x), fc1067(d, y))))))))))));

path_sem_basis1: (circuit2, matrix_complex) -> matrix_complex;

result142: (circuit2, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% result'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(result142(c, x)), t2tb26(y))) = 
  infix_asdtdt(ang_exp(ang_ind1(c, value(ket_to_bv(x)), value(y))), 
  bv_to_ket(make_bv(tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
  int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int))), circuit3, 
  t2tb68(basis_ket_closure1), t2tb67(c)), t2tb7(value(ket_to_bv(x)))), t2tb7(
  value(y)))), width1(c))))));

% path_sem_basis'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(c, x) = infix_asdtdt(
     pow_inv_sqrt_2(range1(c)), ket_sum_l(bitvec1, t2tb28(n_bvs(range1(c))), 
     t2tb29(result142(c, x)), width1(c)))))));

% path_sem_basis'spec
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x))
     => ((is_a_ket_l(path_sem_basis1(c, x), width1(c))) AND (
        path_sem_basis1(c, x) = pps_apply_basis(circ_to_pps1(c), 
        ket_to_bv(x)))))));

path_sem1: (circuit2, matrix_complex) -> matrix_complex;

result143: (circuit2, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% result'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(result143(c, x)), 
  t2tb26(y))) = (IF (length(y) = width1(c)) THEN infix_asdtdt(tb2t(
                get(complex1, t2tb18(x), bv_to_int(y), 0)), 
                path_sem_basis1(c, bv_to_ket(y))) ELSE x ENDIF)));

% path_sem'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => (path_sem1(c, x) = ket_sum_l(bitvec1, 
  t2tb28(n_bvs(width1(c))), t2tb29(result143(c, x)), width1(c)))));

% path_sem'spec
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_l(path_sem1(c, x), width1(c))) AND (path_sem1(c, x) = 
     pps_apply(circ_to_pps1(c), x)))));

ancilla_pre: (circuit2, INT) -> circuit2;

fc614: (circuit2, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc615: (circuit2, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c : circuit2, l : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc614(c, l, x)[k]) = (IF (k < (width1(c) - l)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (c : circuit2, l : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc615(c, l, x)[k]) = (IF (k < (width1(c) - l)) THEN (x[k]) ELSE 0 ENDIF)));

% ancilla_pre'spec
  ASSERT
  (FORALL (c : circuit2, l : INT):
  ((1 <= l)
  => ((l < width1(c))
     => ((EXISTS
         (path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
         (FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width1(c) - l))) => (pps_apply(circ_to_pps1(c), 
         kronecker(x, ket(l, 0))) = kronecker(tb2t18(infix_at(
         matrix(complex1), matrix(complex1), t2tb19(path_sem_target), 
         t2tb18(x))), ket(l, 0))))))
        => ((FORALL (x : matrix_complex):
            ((is_a_ket_l(x, (width1(c) - l))) => (pps_apply(circ_to_pps1(c), 
            kronecker(x, ket(l, 0))) = kronecker(path_sem1(ancilla_pre(c, l),
            x), ket(l, 0)))))
           AND ((pre1(ancilla_pre(c, l)) = Ancillas1(pre1(c), l))
               AND ((ancillas1(ancilla_pre(c, l)) = (ancillas1(c) + l))
                   AND ((size1(ancilla_pre(c, l)) = size1(c))
                       AND ((width1(ancilla_pre(c, l)) = (width1(c) - l))
                           AND ((range1(ancilla_pre(c, l)) = range1(c))
                               AND ((FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    (FORALL (i : INT): (basis_ket1(
                                    ancilla_pre(c, l), x, y, i) = 
                                    basis_ket1(c, fc614(c, l, x), y, i))))
                                   AND (FORALL (x : (ARRAY INT OF INT),
                                       y : (ARRAY INT OF INT)): (ang_ind1(
                                       ancilla_pre(c, l), x, y) = ang_ind1(c, 
                                       fc615(c, l, x), y))))))))))))));

ancilla1: (circuit2, INT) -> circuit2;

fc616: (circuit2, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc617: (circuit2, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c : circuit2, l : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc616(c, l, x)[k]) = (IF (k < (width1(c) - l)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (c : circuit2, l : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc617(c, l, x)[k]) = (IF (k < (width1(c) - l)) THEN (x[k]) ELSE 0 ENDIF)));

% ancilla'spec
  ASSERT
  (FORALL (c : circuit2, l : INT):
  ((1 <= l)
  => ((l < width1(c))
     => ((FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width1(c) - l)))
         => ((is_a_ket_basis_elt(x))
            => (EXISTS (y : matrix_complex): (path_sem1(c, kronecker(x, 
               ket(l, 0))) = kronecker(y, ket(l, 0)))))))
        => ((FORALL (x : matrix_complex):
            ((is_a_ket_l(x, (width1(c) - l))) => (path_sem1(c, kronecker(x, 
            ket(l, 0))) = kronecker(path_sem1(ancilla1(c, l), x), ket(l,
            0)))))
           AND ((FORALL (x : matrix_complex, y : matrix_complex):
                ((is_a_ket_l(x, (width1(c) - l)))
                => ((path_sem1(c, kronecker(x, ket(l, 0))) = kronecker(y, 
                   ket(l, 0))) => (path_sem1(ancilla1(c, l), x) = y))))
               AND ((pre1(ancilla1(c, l)) = Ancillas1(pre1(c), l))
                   AND ((ancillas1(ancilla1(c, l)) = (ancillas1(c) + l))
                       AND ((size1(ancilla1(c, l)) = size1(c))
                           AND ((width1(ancilla1(c, l)) = (width1(c) - l))
                               AND ((range1(ancilla1(c, l)) = range1(c))
                                   AND ((FORALL (x : (ARRAY INT OF INT),
                                        y : (ARRAY INT OF INT)):
                                        (FORALL (i : INT): (basis_ket1(
                                        ancilla1(c, l), x, y, i) = 
                                        basis_ket1(c, fc616(c, l, x), y, i))))
                                       AND (FORALL (x : (ARRAY INT OF INT),
                                           y : (ARRAY INT OF INT)): (
                                           ang_ind1(ancilla1(c, l), x, y) = 
                                           ang_ind1(c, fc617(c, l, x), y)))))))))))))));

% set_ancilla_circ
  ASSERT
  (FORALL (x : wired_circuit, c : circuit2, l : INT):
  ((1 <= l)
  => ((l < width1(c))
     => ((correct1(x))
        => ((pre1(c) = Ancillas1(x, l)) => (c = ancilla1(to_qc1(x), l)))))));

% get_path_sem_basis
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(c, x) = path_sem_basis1(c, x)))));

fc1068: (circuit2, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1068(c, x)), t2tb26(y))) = 
  infix_asdtdt(ang_exp(ang_ind1(c, value(ket_to_bv(x)), value(y))), 
  bv_to_ket(make_bv(tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
  int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int))), circuit3, 
  t2tb68(basis_ket_closure1), t2tb67(c)), t2tb7(value(ket_to_bv(x)))), t2tb7(
  value(y)))), width1(c))))));

% rewrite_path_sem_basis
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(c, x) = infix_asdtdt(
     pow_inv_sqrt_2(range1(c)), ket_sum_l(bitvec1, t2tb28(n_bvs(range1(c))), 
     t2tb29(fc1068(c, x)), width1(c)))))));

% path_sem_basis_comp_
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(d)))
  => ((is_a_ket_basis_elt(x))
     => ((width1(d) = width1(e)) => (path_sem_basis1(infix_mnmn(d, e), x) = 
        path_sem1(e, path_sem_basis1(d, x)))))));

% path_sem_basis_kron
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex,
  xqt : matrix_complex, y : matrix_complex, yqt : matrix_complex):
  ((is_a_ket_l(x, width1(d)))
  => ((is_a_ket_l(y, width1(e)))
     => ((is_a_ket_basis_elt(x))
        => ((is_a_ket_basis_elt(y))
           => ((path_sem_basis1(d, x) = xqt)
              => ((path_sem_basis1(e, y) = yqt) => (path_sem_basis1(
                 infix_slsl(d, e), kronecker(x, y)) = kronecker(xqt, yqt)))))))));

% path_sem_basis_par
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, (width1(d) + width1(e))))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(infix_slsl(d, e), x) = kronecker(
     path_sem1(d, bv_to_ket(hpart(ket_to_bv(x), width1(d)))), path_sem1(e, 
     bv_to_ket(tpart(ket_to_bv(x), width1(d)))))))));

% path_sem_comp_
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(d)))
  => ((width1(d) = width1(e)) => (path_sem1(infix_mnmn(d, e), x) = 
     path_sem1(e, path_sem1(d, x))))));

% path_sem_kron
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex,
  xqt : matrix_complex, y : matrix_complex, yqt : matrix_complex):
  ((is_a_ket_l(x, width1(d)))
  => ((is_a_ket_l(y, width1(e)))
     => ((path_sem1(d, x) = xqt)
        => ((path_sem1(e, y) = yqt) => (path_sem1(infix_slsl(d, e), 
           kronecker(x, y)) = kronecker(xqt, yqt)))))));

% path_sem_comp_rev
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(d)))
  => ((width1(d) = width1(e)) => (path_sem1(e, path_sem1(d, x)) = path_sem1(
     infix_mnmn(d, e), x)))));

% unwire_path_sem
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => (path_sem1(c, x) = path_sem(unwire(c), x))));

% unwire_path_sem_basis
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(c, x) = path_sem_basis(
     unwire(c), x)))));

% unwire_width
  ASSERT (FORALL (c : circuit2): (width1(c) = width(unwire(c))));

wire_pre: (circuit_pre) -> circuit2;

% wire_pre'def
  ASSERT
  (FORALL (c : circuit_pre):
  ((correct(c))
  => (((((((((FORALL (k : INT):
             ((c = Phase(k)) => (wire_pre(c) = phase1(k))))
            AND (FORALL (k : INT): ((c = Rz(k)) => (wire_pre(c) = rzp(k)))))
           AND ((c = Hadamard) => (wire_pre(c) = hadamard1)))
          AND ((c = Cnot) => (wire_pre(c) = bricks_cnot)))
         AND ((c = Swap) => (wire_pre(c) = bricks_swap)))
        AND ((c = Id) => (wire_pre(c) = skip)))
       AND (FORALL (d : circuit_pre, e : circuit_pre):
           ((c = Sequence(d, e)) => (wire_pre(c) = infix_mnmn(wire_pre(d), 
           wire_pre(e))))))
      AND (FORALL (d : circuit_pre, e : circuit_pre):
          ((c = Parallel(d, e)) => (wire_pre(c) = infix_slsl(wire_pre(d), 
          wire_pre(e))))))
     AND (FORALL (d : circuit_pre, l : INT):
         ((c = Ancillas(d, l)) => (wire_pre(c) = ancilla1(wire_pre(d), l)))))));

% wire_pre'spec
  ASSERT
  (FORALL (c : circuit_pre):
  ((correct(c))
  => ((width1(wire_pre(c)) = width_pre(c))
     AND ((FORALL (x : matrix_complex):
          ((is_a_ket_l(x, width1(wire_pre(c))))
          => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(wire_pre(c), x) = 
             path_sem_basis(to_qc(c), x)))))
         AND (FORALL (x : matrix_complex):
             ((is_a_ket_l(x, width1(wire_pre(c)))) => (path_sem1(wire_pre(c),
             x) = path_sem(to_qc(c), x))))))));

wire: (circuit) -> circuit2;

% wire'def
  ASSERT (FORALL (c : circuit): (wire(c) = wire_pre(pre(c))));

% wire'spec
  ASSERT
  (FORALL (c : circuit):
  ((width1(wire(c)) = width(c))
  AND ((FORALL (x : matrix_complex):
       ((is_a_ket_l(x, width1(wire(c))))
       => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(wire(c), x) = 
          path_sem_basis(c, x)))))
      AND (FORALL (x : matrix_complex):
          ((is_a_ket_l(x, width1(wire(c)))) => (path_sem1(wire(c), x) = 
          path_sem(c, x)))))));

% wire_path_sem
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c))) => (path_sem(c, x) = path_sem1(wire(c), x))));

% wire_path_sem_basis
  ASSERT
  (FORALL (c : circuit, x : matrix_complex):
  ((is_a_ket_l(x, width(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis(c, x) = path_sem_basis1(
     wire(c), x)))));

% wire_width
  ASSERT (FORALL (c : circuit): (width(c) = width1(wire(c))));

% unwire_embedding_path_sem
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => (path_sem1(c, x) = path_sem1(wire(
  unwire(c)), x))));

% unwire_embedding_path_sem_basis
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(c, x) = path_sem_basis1(
     wire(unwire(c)), x)))));

% to_qc_rev
  ASSERT (FORALL (c : circuit2): (c = to_qc1(pre1(c))));

% to_qc_pre
  ASSERT (FORALL (c : circuit2): (to_qc1(pre1(c)) = c));

% pre_rev
  ASSERT
  (FORALL (c : wired_circuit): ((correct1(c)) => (c = pre1(to_qc1(c)))));

% pre_to_qc
  ASSERT
  (FORALL (c : wired_circuit): ((correct1(c)) => (pre1(to_qc1(c)) = c)));

% path_sem_apply
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => (path_sem1(c, x) = pps_apply(
  circ_to_pps1(c), x))));

% apply_path_sem
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => (pps_apply(circ_to_pps1(c), x) = 
  path_sem1(c, x))));

correct_path_sum: (circuit2, pps) -> BOOLEAN;

% correct_path_sum'def
  ASSERT
  (FORALL (c : circuit2, p : pps):
  ((correct_path_sum(c, p)) <=> (pps_apply_equiv(circ_to_pps1(c), p))));

% set_correct_pps_basis
  ASSERT
  (FORALL (c : circuit2, h : pps):
  ((h_width(h) = width1(c))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width1(c)))
      => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = path_sem_basis1(c,
         x)))))
     => (correct_path_sum(c, h)))));

% set_correct_pps
  ASSERT
  (FORALL (c : circuit2, h : pps):
  ((h_width(h) = width1(c))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width1(c)))
      => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = path_sem1(c, x)))))
     => (correct_path_sum(c, h)))));

% get_correct_pps
  ASSERT
  (FORALL (c : circuit2, h : pps, x : matrix_complex):
  ((h_width(h) = width1(c))
  => ((is_a_ket_l(x, width1(c)))
     => ((correct_path_sum(c, h)) => (pps_apply(h, x) = path_sem1(c, x))))));

% unwire_correct
  ASSERT
  (FORALL (c : circuit2, h : pps):
  ((correct_path_sum(c, h)) => (correct_path_sum_(unwire(c), h))));

% unwire_correct_rev
  ASSERT
  (FORALL (c : circuit2, h : pps):
  ((correct_path_sum_(unwire(c), h)) => (correct_path_sum(c, h))));

% wire_correct
  ASSERT
  (FORALL (c : circuit, h : pps):
  ((correct_path_sum_(c, h)) => (correct_path_sum(wire(c), h))));

% unwire_ancillable
  ASSERT
  (FORALL (c : circuit2, l : INT):
  ((0 <= l)
  => ((ancillable(pre1(c), l)) => (ancillable_pre(pre(unwire(c)), l)))));

% unwire_sequence
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e)) => (unwire(infix_mnmn(d, e)) = sequence(unwire(d), 
  unwire(e)))));

% unwire_parallel
  ASSERT
  (FORALL (d : circuit2, e : circuit2): (unwire(infix_slsl(d, e)) = parallel(
  unwire(d), unwire(e))));

% unwire_place
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT):
  ((0 <= k)
  => (((width1(c) + k) <= n) => (unwire(place1(c, k, n)) = place(unwire(c),
     k, n)))));

% unwire_cont
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co)) => (unwire(cont1(c, co, k,
        n)) = cont(unwire(c), co, k, n))))));

% unwire_ancilla
  ASSERT
  (FORALL (c : circuit2, l : INT):
  ((1 <= l)
  => ((l < width1(c))
     => ((ancillable(pre1(c), l)) => (unwire(ancilla1(c, l)) = ancilla(
        unwire(c), l))))));

% unwire_skip
  ASSERT (unwire(skip) = id);

% unwire_hadamard
  ASSERT (unwire(hadamard1) = hadamard);

% unwire_s
  ASSERT (unwire(s) = rz(2));

% unwire_t
  ASSERT (unwire(t) = rz(3));

% unwire_xx
  ASSERT (unwire(xx1) = xx);

% unwire_yy
  ASSERT (unwire(yy1) = yy);

% unwire_zz
  ASSERT (unwire(zz1) = zz);

% unwire_phase
  ASSERT (FORALL (k : INT): (unwire(phase1(k)) = phase(k)));

% unwire_rx
  ASSERT (FORALL (k : INT): (unwire(rx1(k)) = rx(k)));

% unwire_ry
  ASSERT (FORALL (k : INT): (unwire(ry1(k)) = ry(k)));

% unwire_rz
  ASSERT (FORALL (k : INT): (unwire(rz1(k)) = rz_(k)));

% unwire_rzp
  ASSERT (FORALL (k : INT): (unwire(rzp(k)) = rz(k)));

% unwire_cnot
  ASSERT
  (FORALL (c : INT, t1 : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (t1 = c)) => (unwire(cnot1(c, t1, n)) = place_cnot(c, t1, n))))));

% unwire_swap
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t2 = t1)) => (unwire(swap1(t1, t2, n)) = swap_c(t1, t2, n))))));

% unwire_toffoli
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (t1 = c1))
           => ((NOT (t1 = c2))
              => ((NOT (c2 = c1)) => (unwire(toffoli1(c1, c2, t1, n)) = 
                 place_toffoli(c1, c2, t1, n)))))))));

% unwire_fredkin
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (c = t1))
           => ((NOT (c = t2))
              => ((NOT (t2 = t1)) => (unwire(fredkin1(c, t1, t2, n)) = 
                 place_fredkin(c, t1, t2, n)))))))));

% wire_sequence
  ASSERT
  (FORALL (d : circuit, e : circuit):
  ((width(d) = width(e)) => (wire(sequence(d, e)) = infix_mnmn(wire(d), 
  wire(e)))));

% wire_parallel
  ASSERT
  (FORALL (d : circuit, e : circuit): (wire(parallel(d, e)) = infix_slsl(
  wire(d), wire(e))));

% wire_ancilla
  ASSERT
  (FORALL (c : circuit, l : INT):
  ((1 <= l)
  => ((l < width(c))
     => ((ancillable_pre(pre(c), l)) => (wire(ancilla(c, l)) = ancilla1(
        wire(c), l))))));

% positive_width
  ASSERT (FORALL (c : circuit2): (0 <= width1(c)));

% circ_to_pps_width
  ASSERT (FORALL (c : circuit2): (h_width(circ_to_pps1(c)) = width1(c)));

% circ_to_pps_range
  ASSERT (FORALL (c : circuit2): (h_range(circ_to_pps1(c)) = range1(c)));

% circ_to_pps_basis_ket
  ASSERT
  (FORALL (c : circuit2, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  i : INT): ((tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), t2tb55(h_basis_ket(circ_to_pps1(c))), t2tb7(x)), 
  t2tb7(y)))[i]) = basis_ket1(c, x, y, i)));

% circ_to_pps_basis_ket_gen
  ASSERT
  (FORALL (c : circuit2, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
  tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int,
  int), t2tb55(h_basis_ket(circ_to_pps1(c))), t2tb7(x)), t2tb7(y))) = tb2t7(
  infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int, int), 
  infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int, int), 
  infix_mngt(int, int))), circuit3, t2tb68(basis_ket_closure1), t2tb67(c)), 
  t2tb7(x)), t2tb7(y)))));

% circ_to_pps_angle
  ASSERT
  (FORALL (c : circuit2, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)): (
  tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(infix_mngt(
  infix_mngt(int, int), angle1), infix_mngt(int, int), t2tb57(h_angle(
  circ_to_pps1(c))), t2tb7(x)), t2tb7(y))) = ang_ind1(c, x, y)));

sem1: (circuit2, matrix_complex, matrix_complex) -> BOOLEAN;

% sem'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : matrix_complex):
  ((sem1(c, x, y))
  <=> ((is_a_ket_l(x, width1(c))) AND (infix_eqeq(matrix(complex1), 
      t2tb18(y), t2tb18(path_sem1(c, x)))))));

% path_sem_to_sem
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => ((path_sem1(c, x) = y) => (sem1(c, x, y)))));

% sem_to_path_sem
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : matrix_complex):
  ((sem1(c, x, y)) => (path_sem1(c, x) = y)));

fc1069: (circuit2, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1069(c, x)), t2tb26(y))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(x), bv_to_int(y), 0)), 
  path_sem_basis1(c, bv_to_ket(y)))));

% get_path_sem
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => (path_sem1(c, x) = ket_sum_l(bitvec1, 
  t2tb28(n_bvs(width1(c))), t2tb29(fc1069(c, x)), width1(c)))));

fc1070: (circuit2, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1070(c, x)), t2tb26(y))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(x), bv_to_int(y), 0)), 
  path_sem_basis1(c, bv_to_ket(y)))));

% get_path_sem_gen
  ASSERT
  (FORALL (c : circuit2):
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => (path_sem1(c, x) = ket_sum_l(bitvec1, 
  t2tb28(n_bvs(width1(c))), t2tb29(fc1070(c, x)), width1(c))))));

fc1071: (circuit2, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, z : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1071(c, x)), t2tb26(z))) = 
  infix_asdtdt(tb2t(get(complex1, t2tb18(x), bv_to_int(z), 0)), path_sem1(c, 
  bv_to_ket(z)))));

% path_sem_decomp
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c))) => (path_sem1(c, x) = ket_sum_l(bitvec1, 
  t2tb28(n_bvs(width1(c))), t2tb29(fc1071(c, x)), width1(c)))));

ancilla_g1: (circuit2, INT,
  (ARRAY matrix_complex OF matrix_complex)) -> circuit2;

% ancilla_g'def
  ASSERT
  (FORALL (c : circuit2, i : INT,
  path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
  ((1 <= i)
  => (((i + 1) <= width1(c))
     => ((FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width1(c) - i))) => (path_sem1(c, kronecker(x, 
         ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
         matrix(complex1), t2tb19(path_sem_target), t2tb18(x))), ket(i, 0)))))
        => (ancilla_g1(c, i, path_sem_target) = ancilla1(c, i))))));

fc622: (circuit2, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc623: (circuit2, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c : circuit2, i : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc622(c, i, x)[k]) = (IF (k < (width1(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% fc'def
  ASSERT
  (FORALL (c : circuit2, i : INT, x : (ARRAY INT OF INT), k : INT): ((
  fc623(c, i, x)[k]) = (IF (k < (width1(c) - i)) THEN (x[k]) ELSE 0 ENDIF)));

% ancilla_g'spec
  ASSERT
  (FORALL (c : circuit2, i : INT,
  path_sem_target : (ARRAY matrix_complex OF matrix_complex)):
  ((1 <= i)
  => (((i + 1) <= width1(c))
     => ((FORALL (x : matrix_complex):
         ((is_a_ket_l(x, (width1(c) - i))) => (path_sem1(c, kronecker(x, 
         ket(i, 0))) = kronecker(tb2t18(infix_at(matrix(complex1), 
         matrix(complex1), t2tb19(path_sem_target), t2tb18(x))), ket(i, 0)))))
        => ((ancillas1(ancilla_g1(c, i, path_sem_target)) = (
           ancillas1(c) + i))
           AND ((size1(ancilla_g1(c, i, path_sem_target)) = size1(c))
               AND ((range1(ancilla_g1(c, i, path_sem_target)) = range1(c))
                   AND ((width1(ancilla_g1(c, i, path_sem_target)) = (
                       width1(c) - i))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)):
                            (FORALL (ii : INT): (basis_ket1(ancilla_g1(c, i,
                            path_sem_target), x, y, ii) = basis_ket1(c, 
                            fc622(c, i, x), y, ii))))
                           AND (FORALL (x : (ARRAY INT OF INT),
                               y : (ARRAY INT OF INT)): (ang_ind1(
                               ancilla_g1(c, i, path_sem_target), x, y) = 
                               ang_ind1(c, fc623(c, i, x), y))))))))))));

sequence_ghost_pps1: (circuit2, circuit2, pps, pps, pps) -> circuit2;

fc1072: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1073: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1072(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1073(h,
  y)[k]) = (y[(k + h_range(h))])));

% sequence_ghost_pps'def
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum(c, h))
  => ((correct_path_sum(cqt, hqt))
     => ((width1(c) = width1(cqt))
        => ((h_width(hqtqt) = width1(c))
           => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                     infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqtqt)), t2tb7(x)), 
                     t2tb7(y))) = ang_add(tb2t33(infix_at(angle1, 
                     infix_mngt(int, int), infix_at(infix_mngt(
                     infix_mngt(int, int), angle1), infix_mngt(int, int), 
                     t2tb57(h_angle(h)), t2tb7(x)), t2tb7(y))), tb2t33(
                     infix_at(angle1, infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqt)), infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
                     t2tb7(y))), t2tb7(fc1072(h, y)))))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((0 <= i) AND (i < h_width(hqtqt))) => ((tb2t7(
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqtqt)), t2tb7(x)), 
                           t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int,
                           int), infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), 
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(h)), t2tb7(x)), t2tb7(y))), 
                           t2tb7(fc1073(h, y))))[i])))))))
                    => (sequence_ghost_pps1(c, cqt, h, hqt, hqtqt) = 
                    infix_mnmn(c, cqt))))))))));

fc1074: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1075: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1074(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1075(h,
  y)[k]) = (y[(k + h_range(h))])));

% sequence_ghost_pps'spec
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum(c, h))
  => ((correct_path_sum(cqt, hqt))
     => ((width1(c) = width1(cqt))
        => ((h_width(hqtqt) = width1(c))
           => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                     infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqtqt)), t2tb7(x)), 
                     t2tb7(y))) = ang_add(tb2t33(infix_at(angle1, 
                     infix_mngt(int, int), infix_at(infix_mngt(
                     infix_mngt(int, int), angle1), infix_mngt(int, int), 
                     t2tb57(h_angle(h)), t2tb7(x)), t2tb7(y))), tb2t33(
                     infix_at(angle1, infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqt)), infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
                     t2tb7(y))), t2tb7(fc1074(h, y)))))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((0 <= i) AND (i < h_width(hqtqt))) => ((tb2t7(
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqtqt)), t2tb7(x)), 
                           t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int,
                           int), infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), 
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(h)), t2tb7(x)), t2tb7(y))), 
                           t2tb7(fc1075(h, y))))[i])))))))
                    => ((width1(sequence_ghost_pps1(c, cqt, h, hqt,
                       hqtqt)) = width1(c))
                       AND ((size1(sequence_ghost_pps1(c, cqt, h, hqt,
                           hqtqt)) = (size1(c) + size1(cqt)))
                           AND ((ancillas1(sequence_ghost_pps1(c, cqt, h,
                               hqt, hqtqt)) = max(ancillas1(c), 
                               ancillas1(cqt))) AND (correct_path_sum(
                               sequence_ghost_pps1(c, cqt, h, hqt, hqtqt),
                               hqtqt)))))))))))));

parallel_ghost_pps1: (circuit2, circuit2, pps, pps, pps) -> circuit2;

fc1076: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1077: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1078: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1079: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1076(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1077(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1078(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1079(h,
  y)[k]) = (y[(k + h_range(h))])));

% parallel_ghost_pps'def
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum(c, h))
  => ((correct_path_sum(cqt, hqt))
     => ((h_width(hqtqt) = (width1(c) + width1(cqt)))
        => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((FORALL (j : INT):
                (((0 <= j) AND (j < h_width(hqtqt)))
                => ((0 <= (x[j])) AND ((x[j]) < 2))))
               => ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_range(hqtqt)))
                   => ((0 <= (y[j])) AND ((y[j]) < 2))))
                  => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                  int), t2tb57(h_angle(hqtqt)), t2tb7(x)), t2tb7(y))) = 
                  ang_add(tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(x)), 
                  t2tb7(y))), tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(hqt)), t2tb7(fc1076(h,
                  x))), t2tb7(fc1077(h, y)))))))))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  (FORALL (i : INT):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (((0 <= i) AND (i < h_width(h))) => ((tb2t7(infix_at(
                        infix_mngt(int, int), infix_mngt(int, int), infix_at(
                        infix_mngt(infix_mngt(int, int), infix_mngt(int,
                        int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(hqtqt)), t2tb7(x)), t2tb7(y)))[i]) = (
                        tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h)), t2tb7(x)), t2tb7(y)))[i])))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((h_width(h) <= i) AND (i < h_width(hqtqt)))
                           => ((tb2t7(infix_at(infix_mngt(int, int), 
                           infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqtqt)), 
                           t2tb7(x)), t2tb7(y)))[i]) = (tb2t7(infix_at(
                           infix_mngt(int, int), infix_mngt(int, int), 
                           infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqt)), t2tb7(fc1078(h, x))), 
                           t2tb7(fc1079(h, y))))[(i - h_width(h))])))))))
                    => (parallel_ghost_pps1(c, cqt, h, hqt, hqtqt) = 
                    infix_slsl(c, cqt))))))))));

fc1080: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1081: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1082: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1083: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1080(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1081(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1082(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1083(h,
  y)[k]) = (y[(k + h_range(h))])));

% parallel_ghost_pps'spec
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum(c, h))
  => ((correct_path_sum(cqt, hqt))
     => ((h_width(hqtqt) = (width1(c) + width1(cqt)))
        => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((FORALL (j : INT):
                (((0 <= j) AND (j < h_width(hqtqt)))
                => ((0 <= (x[j])) AND ((x[j]) < 2))))
               => ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_range(hqtqt)))
                   => ((0 <= (y[j])) AND ((y[j]) < 2))))
                  => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                  int), t2tb57(h_angle(hqtqt)), t2tb7(x)), t2tb7(y))) = 
                  ang_add(tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(x)), 
                  t2tb7(y))), tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(hqt)), t2tb7(fc1080(h,
                  x))), t2tb7(fc1081(h, y)))))))))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  (FORALL (i : INT):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (((0 <= i) AND (i < h_width(h))) => ((tb2t7(infix_at(
                        infix_mngt(int, int), infix_mngt(int, int), infix_at(
                        infix_mngt(infix_mngt(int, int), infix_mngt(int,
                        int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(hqtqt)), t2tb7(x)), t2tb7(y)))[i]) = (
                        tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h)), t2tb7(x)), t2tb7(y)))[i])))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((h_width(h) <= i) AND (i < h_width(hqtqt)))
                           => ((tb2t7(infix_at(infix_mngt(int, int), 
                           infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqtqt)), 
                           t2tb7(x)), t2tb7(y)))[i]) = (tb2t7(infix_at(
                           infix_mngt(int, int), infix_mngt(int, int), 
                           infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqt)), t2tb7(fc1082(h, x))), 
                           t2tb7(fc1083(h, y))))[(i - h_width(h))])))))))
                    => ((correct_path_sum(parallel_ghost_pps1(c, cqt, h, hqt,
                       hqtqt), hqtqt))
                       AND ((width1(parallel_ghost_pps1(c, cqt, h, hqt,
                           hqtqt)) = (width1(c) + width1(cqt)))
                           AND ((size1(parallel_ghost_pps1(c, cqt, h, hqt,
                               hqtqt)) = (size1(c) + size1(cqt))) AND (
                               ancillas1(parallel_ghost_pps1(c, cqt, h, hqt,
                               hqtqt)) = (ancillas1(c) + ancillas1(cqt))))))))))))));

% path_sem_scal_
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : matrix_complex,
  sc : complex):
  ((is_a_ket_l(x, width1(c)))
  => ((path_sem1(c, x) = y) => (path_sem1(c, infix_asdtdt(sc, x)) = 
     infix_asdtdt(sc, y)))));

% path_sem_scal
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, sc : complex):
  ((is_a_ket_l(x, width1(c))) => (path_sem1(c, infix_asdtdt(sc, x)) = 
  infix_asdtdt(sc, path_sem1(c, x)))));

% path_sem_scal_rev
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, sc : complex):
  ((is_a_ket_l(x, width1(c))) => (infix_asdtdt(sc, path_sem1(c, x)) = 
  path_sem1(c, infix_asdtdt(sc, x)))));

fc636: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc637: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit2, x : (ARRAY INT OF INT), k : INT): ((fc636(d,
  x)[k]) = (x[(k + width1(d))])));

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc637(d,
  y)[k]) = (y[(k + range1(d))])));

% parallel_basis_ket
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), i : INT): (basis_ket1(infix_slsl(d, e), x, y,
  i) = (IF (i < width1(d)) THEN basis_ket1(d, x, y, i) ELSE basis_ket1(e, 
       fc636(d, x), fc637(d, y), (i - width1(d))) ENDIF)));

fc1084: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1085: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit2, x : (ARRAY INT OF INT), k : INT): ((fc1084(d,
  x)[k]) = (x[(k + width1(d))])));

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc1085(d,
  y)[k]) = (y[(k + range1(d))])));

% parallel_angle
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT)): (ang_ind1(infix_slsl(d, e), x, y) = ang_add(
  ang_ind1(d, x, y), ang_ind1(e, fc1084(d, x), fc1085(d, y)))));

% path_sem_add
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, xqt : matrix_complex,
  y : matrix_complex, yqt : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_l(xqt, width1(c)))
     => ((path_sem1(c, x) = y)
        => ((path_sem1(c, xqt) = yqt) => (path_sem1(c, add_ket_l(x, xqt, 
           width1(c))) = add_ket_l(y, yqt, width1(c))))))));

% path_sem_add_
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, xqt : matrix_complex, n : INT):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_l(xqt, width1(c)))
     => ((width1(c) = n) => (path_sem1(c, add_ket_l(x, xqt, n)) = add_ket_l(
        path_sem1(c, x), path_sem1(c, xqt), n))))));

% path_sem_scal_add_ket_l
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, xqt : matrix_complex,
  a : complex, aqt : complex, n : INT):
  ((width1(c) = n)
  => ((is_a_ket_l(x, n))
     => ((is_a_ket_l(xqt, n)) => (path_sem1(c, add_ket_l(infix_asdtdt(a, x), 
        infix_asdtdt(aqt, xqt), n)) = add_ket_l(infix_asdtdt(a, path_sem1(c,
        x)), infix_asdtdt(aqt, path_sem1(c, xqt)), n))))));

% path_sem_substr
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, xqt : matrix_complex,
  y : matrix_complex, yqt : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_l(xqt, width1(c)))
     => ((path_sem1(c, x) = y)
        => ((path_sem1(c, xqt) = yqt) => (path_sem1(c, mat_substr(x, xqt)) = 
           mat_substr(y, yqt)))))));

% path_sem_scal_add
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, xqt : matrix_complex,
  y : matrix_complex, yqt : matrix_complex, scal : complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_l(xqt, width1(c)))
     => ((path_sem1(c, x) = y)
        => ((path_sem1(c, xqt) = yqt) => (path_sem1(c, infix_asdtdt(scal, 
           add_ket_l(x, xqt, width1(c)))) = infix_asdtdt(scal, add_ket_l(y,
           yqt, width1(c)))))))));

% path_sem_basis_apply
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(c, x) = pps_apply_basis(
     circ_to_pps1(c), ket_to_bv(x))))));

fc1086: (circuit2, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1086(c, x)), t2tb26(y))) = 
  infix_asdtdt(ang_exp(ang_ind1(c, value(ket_to_bv(x)), value(y))), 
  bv_to_ket(make_bv(tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
  int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int))), circuit3, 
  t2tb68(basis_ket_closure1), t2tb67(c)), t2tb7(value(ket_to_bv(x)))), t2tb7(
  value(y)))), width1(c))))));

% path_sem_basis_value
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(c, x) = infix_asdtdt(
     pow_inv_sqrt_2(range1(c)), ket_sum_l(bitvec1, t2tb28(n_bvs(range1(c))), 
     t2tb29(fc1086(c, x)), width1(c)))))));

fc1087: (circuit2, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1087(c, x)), t2tb26(y))) = 
  infix_asdtdt(ang_exp(ang_ind1(c, value(ket_to_bv(x)), value(y))), 
  bv_to_ket(make_bv(tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
  int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
  infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
  infix_mngt(int, int), infix_mngt(int, int))), circuit3, 
  t2tb68(basis_ket_closure1), t2tb67(c)), t2tb7(value(ket_to_bv(x)))), t2tb7(
  value(y)))), width1(c))))));

% path_sem_value_for_basis
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(c, x) = infix_asdtdt(
     pow_inv_sqrt_2(range1(c)), ket_sum_l(bitvec1, t2tb28(n_bvs(range1(c))), 
     t2tb29(fc1087(c, x)), width1(c)))))));

% apply_path_sem_basis
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_basis_elt(x)) => (pps_apply_basis(circ_to_pps1(c), 
     ket_to_bv(x)) = path_sem_basis1(c, x)))));

% path_sem_ket_l
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, l : INT):
  ((is_a_ket_l(x, width1(c)))
  => ((l = width1(c)) => (is_a_ket_l(path_sem1(c, x), l)))));

% path_sem_scal_substr
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, xqt : matrix_complex,
  y : matrix_complex, yqt : matrix_complex, scal : complex):
  ((is_a_ket_l(x, width1(c)))
  => ((is_a_ket_l(xqt, width1(c)))
     => ((path_sem1(c, x) = y)
        => ((path_sem1(c, xqt) = yqt) => (path_sem1(c, infix_asdtdt(scal, 
           mat_substr(x, xqt))) = infix_asdtdt(scal, mat_substr(y, yqt))))))));

% path_sem_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit2, s2 : uni, f : uni, g : uni, n : INT):
  ((1 <= cardinal(a, s2))
  => ((n = width1(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width1(c))))))
        => ((FORALL (x : uni):
            ((sort(a, x))
            => ((mem(a, x, s2)) => (path_sem1(c, tb2t18(infix_at(
               matrix(complex1), a, f, x))) = tb2t18(infix_at(
               matrix(complex1), a, g, x))))))
           => (path_sem1(c, ket_sum_l(a, s2, f, n)) = ket_sum_l(a, s2, g,
           n))))))));

fc642: (circuit2,
  (ARRAY bitvec OF complex)) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit2, f : (ARRAY bitvec OF complex), x : bitvec): (tb2t18(
  infix_at(matrix(complex1), bitvec1, t2tb29(fc642(c, f)), t2tb26(x))) = 
  infix_asdtdt(tb2t(infix_at(complex1, bitvec1, t2tb31(f), t2tb26(x))), 
  path_sem1(c, bv_to_ket(x)))));

% path_sem_sum_diag
  ASSERT
  (FORALL (c : circuit2, s2 : set_bitvec, f : (ARRAY bitvec OF complex),
  l : INT):
  ((s2 = n_bvs(l))
  => ((l = width1(c)) => (path_sem1(c, ket_sum_l_diag(f, l)) = 
     ket_sum_l(bitvec1, t2tb28(s2), t2tb29(fc642(c, f)), l)))));

fc1088: (ty, circuit2, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : circuit2, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc1088(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit2, f : uni, x : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc1088(a, c, f), x)) = path_sem1(c, tb2t18(infix_at(
  matrix(complex1), a, f, x))))));

% path_sem_sum_
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit2, s2 : uni, f : uni, n : INT):
  ((1 <= cardinal(a, s2))
  => ((n = width1(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width1(c))))))
        => (path_sem1(c, ket_sum_l(a, s2, f, n)) = ket_sum_l(a, s2, fc1088(a,
        c, f), n)))))));

% path_sem_sum_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit2, s2 : uni, f : uni, g : uni, n : INT):
  ((1 <= cardinal(a, s2))
  => ((n = width1(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width1(c))))))
        => ((FORALL (x : uni):
            ((sort(a, x))
            => ((mem(a, x, s2)) => (path_sem1(c, tb2t18(infix_at(
               matrix(complex1), a, f, x))) = tb2t18(infix_at(
               matrix(complex1), a, g, x))))))
           => (path_sem1(c, ket_sum_l(a, s2, f, n)) = ket_sum_l(a, s2, g,
           n))))))));

% scal_path_sem_sum_gen
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit2, s2 : uni, f : uni, g : uni, n : INT, nqt : INT,
  a1 : complex, b : complex):
  ((1 <= cardinal(a, s2))
  => ((n = width1(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width1(c))))))
        => ((FORALL (x : uni):
            ((sort(a, x))
            => ((mem(a, x, s2)) => (path_sem1(c, tb2t18(infix_at(
               matrix(complex1), a, f, x))) = tb2t18(infix_at(
               matrix(complex1), a, g, x))))))
           => ((a1 = b)
              => ((n = nqt) => (infix_asdtdt(a1, path_sem1(c, ket_sum_l(a,
                 s2, f, n))) = infix_asdtdt(b, ket_sum_l(a, s2, g, nqt)))))))))));

fc1089: (ty, circuit2, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : circuit2, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc1089(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit2, f : uni, x : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc1089(a, c, f), x)) = path_sem1(c, tb2t18(infix_at(
  matrix(complex1), a, f, x))))));

% scal_path_sem_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit2, s2 : uni, f : uni, n : INT, a1 : complex):
  ((1 <= cardinal(a, s2))
  => ((n = width1(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width1(c))))))
        => (infix_asdtdt(a1, path_sem1(c, ket_sum_l(a, s2, f, n))) = 
        infix_asdtdt(a1, ket_sum_l(a, s2, fc1089(a, c, f), n))))))));

fc1090: (ty, circuit2, uni) -> uni;

% fc_sort
  ASSERT
  (FORALL (a : ty):
  (FORALL (x : circuit2, x1 : uni): (sort(infix_mngt(a, matrix(complex1)), 
  fc1090(a, x, x1)))));

% fc'def
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit2, f : uni, x : uni): (tb2t18(infix_at(
  matrix(complex1), a, fc1090(a, c, f), x)) = path_sem1(c, tb2t18(infix_at(
  matrix(complex1), a, f, x))))));

% path_sem_scal_sum
  ASSERT
  (FORALL (a : ty):
  (FORALL (c : circuit2, s2 : uni, f : uni, n : INT, a1 : complex):
  ((1 <= cardinal(a, s2))
  => ((n = width1(c))
     => ((FORALL (x : uni):
         ((sort(a, x))
         => ((mem(a, x, s2)) => (is_a_ket_l(tb2t18(infix_at(matrix(complex1),
            a, f, x)), width1(c))))))
        => (path_sem1(c, infix_asdtdt(a1, ket_sum_l(a, s2, f, n))) = 
        infix_asdtdt(a1, ket_sum_l(a, s2, fc1090(a, c, f), n))))))));

% path_sem_sequence_parallel_basis
  ASSERT
  (FORALL (a : circuit2, b : circuit2, d : circuit2, e : circuit2,
  x : matrix_complex):
  ((is_a_ket_l(x, (width1(a) + width1(b))))
  => ((width1(a) = width1(d))
     => ((width1(b) = width1(e))
        => ((is_a_ket_basis_elt(x)) => (path_sem1(infix_mnmn(infix_slsl(a,
           b), infix_slsl(d, e)), x) = path_sem1(infix_slsl(infix_mnmn(a, d), 
           infix_mnmn(b, e)), x)))))));

% path_sem_sequence_parallel
  ASSERT
  (FORALL (a : circuit2, b : circuit2, d : circuit2, e : circuit2,
  x : matrix_complex):
  ((is_a_ket_l(x, (width1(a) + width1(b))))
  => ((width1(a) = width1(d))
     => ((width1(b) = width1(e)) => (path_sem1(infix_mnmn(infix_slsl(a, b), 
        infix_slsl(d, e)), x) = path_sem1(infix_slsl(infix_mnmn(a, d), 
        infix_mnmn(b, e)), x))))));

% path_sem_phase_basis
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(phase1(k),
     x) = (IF (0 <= k) THEN infix_asdtdt(ang_exp(int_to_ang(1, k)), x) ELSE 
          infix_asdtdt(ang_exp(int_to_ang((- 1), (- k))), x) ENDIF)))));

% path_sem_phase_basis_inv
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(phase1(k), path_sem1(
     phase1((- k)), x)) = x))));

% path_sem_phase_inv
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem1(phase1(k), path_sem1(phase1((- k)),
  x)) = x)));

% path_sem_rz_basis
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(rzp(k), x) = infix_asdtdt(
     ang_exp(infix_sldtsl((value(ket_to_bv(x))[0]), k)), x)))));

% path_sem_rz_basis_inv
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(rzp(k), path_sem1(rzp((- k)),
     x)) = x))));

% path_sem_rz_inv
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem1(rzp(k), path_sem1(rzp((- k)), x)) = x)));

% path_sem_hadamard_zero
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = ket(1, 0)) => (path_sem1(hadamard1, x) = pps_apply(pps_hadamard, 
  ket(1, 0)))));

% path_sem_hadamard_one
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = ket(1, 1)) => (path_sem1(hadamard1, x) = pps_apply(pps_hadamard, 
  ket(1, 1)))));

% path_sem_hadamard_plus
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = pps_apply(pps_hadamard, ket(1, 0))) => (path_sem1(hadamard1, x) = 
  ket(1, 0))));

% path_sem_hadamard_minus
  ASSERT
  (FORALL (x : matrix_complex):
  ((x = pps_apply(pps_hadamard, ket(1, 1))) => (path_sem1(hadamard1, x) = 
  ket(1, 1))));

% path_semnot_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(bricks_cnot,
     x) = (IF (ket_to_int(x) = 0) THEN ket(2, 0)
          ELSE (IF (ket_to_int(x) = 1) THEN ket(2, 1)
               ELSE (IF (ket_to_int(x) = 2) THEN ket(2, 3) ELSE ket(2,
                    2) ENDIF) ENDIF) ENDIF)))));

% path_sem_swap_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(bricks_swap,
     x) = (IF (ket_to_int(x) = 0) THEN ket(2, 0)
          ELSE (IF (ket_to_int(x) = 1) THEN ket(2, 2)
               ELSE (IF (ket_to_int(x) = 2) THEN ket(2, 1) ELSE ket(2,
                    3) ENDIF) ENDIF) ENDIF)))));

% hadamard_invol
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem1(hadamard1, path_sem1(hadamard1, x)) = x)));

fc1091: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1092: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1091(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1092(h,
  y)[k]) = (y[(k + h_range(h))])));

% correct_seq
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum(c, h))
  => ((correct_path_sum(cqt, hqt))
     => ((width1(c) = width1(cqt))
        => ((h_width(hqtqt) = width1(c))
           => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (tb2t33(infix_at(angle1, infix_mngt(int, int), 
                     infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqtqt)), t2tb7(x)), 
                     t2tb7(y))) = ang_add(tb2t33(infix_at(angle1, 
                     infix_mngt(int, int), infix_at(infix_mngt(
                     infix_mngt(int, int), angle1), infix_mngt(int, int), 
                     t2tb57(h_angle(h)), t2tb7(x)), t2tb7(y))), tb2t33(
                     infix_at(angle1, infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), angle1), 
                     infix_mngt(int, int), t2tb57(h_angle(hqt)), infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(x)), 
                     t2tb7(y))), t2tb7(fc1091(h, y)))))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((0 <= i) AND (i < h_width(hqtqt))) => ((tb2t7(
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqtqt)), t2tb7(x)), 
                           t2tb7(y)))[i]) = (tb2t7(infix_at(infix_mngt(int,
                           int), infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), 
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(h)), t2tb7(x)), t2tb7(y))), 
                           t2tb7(fc1092(h, y))))[i])))))))
                    => (correct_path_sum(infix_mnmn(c, cqt), hqtqt))))))))));

fc1093: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1094: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1095: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1096: (pps, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1093(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1094(h,
  y)[k]) = (y[(k + h_range(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, x : (ARRAY INT OF INT), k : INT): ((fc1095(h,
  x)[k]) = (x[(k + h_width(h))])));

% fc'def
  ASSERT
  (FORALL (h : pps, y : (ARRAY INT OF INT), k : INT): ((fc1096(h,
  y)[k]) = (y[(k + h_range(h))])));

% correct_par
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, h : pps, hqt : pps, hqtqt : pps):
  ((correct_path_sum(c, h))
  => ((correct_path_sum(cqt, hqt))
     => ((h_width(hqtqt) = (width1(c) + width1(cqt)))
        => ((h_range(hqtqt) = (h_range(h) + h_range(hqt)))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((FORALL (j : INT):
                (((0 <= j) AND (j < h_width(hqtqt)))
                => ((0 <= (x[j])) AND ((x[j]) < 2))))
               => ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_range(hqtqt)))
                   => ((0 <= (y[j])) AND ((y[j]) < 2))))
                  => (tb2t33(infix_at(angle1, infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), angle1), infix_mngt(int,
                  int), t2tb57(h_angle(hqtqt)), t2tb7(x)), t2tb7(y))) = 
                  ang_add(tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(x)), 
                  t2tb7(y))), tb2t33(infix_at(angle1, infix_mngt(int, int), 
                  infix_at(infix_mngt(infix_mngt(int, int), angle1), 
                  infix_mngt(int, int), t2tb57(h_angle(hqt)), t2tb7(fc1093(h,
                  x))), t2tb7(fc1094(h, y)))))))))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
                  (FORALL (i : INT):
                  ((FORALL (j : INT):
                   (((0 <= j) AND (j < h_width(hqtqt)))
                   => ((0 <= (x[j])) AND ((x[j]) < 2))))
                  => ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_range(hqtqt)))
                      => ((0 <= (y[j])) AND ((y[j]) < 2))))
                     => (((0 <= i) AND (i < h_width(h))) => ((tb2t7(infix_at(
                        infix_mngt(int, int), infix_mngt(int, int), infix_at(
                        infix_mngt(infix_mngt(int, int), infix_mngt(int,
                        int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(hqtqt)), t2tb7(x)), t2tb7(y)))[i]) = (
                        tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int,
                        int), infix_at(infix_mngt(infix_mngt(int, int), 
                        infix_mngt(int, int)), infix_mngt(int, int), t2tb55(
                        h_basis_ket(h)), t2tb7(x)), t2tb7(y)))[i])))))))
                 => ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT):
                     ((FORALL (j : INT):
                      (((0 <= j) AND (j < h_width(hqtqt)))
                      => ((0 <= (x[j])) AND ((x[j]) < 2))))
                     => ((FORALL (j : INT):
                         (((0 <= j) AND (j < h_range(hqtqt)))
                         => ((0 <= (y[j])) AND ((y[j]) < 2))))
                        => (((h_width(h) <= i) AND (i < h_width(hqtqt)))
                           => ((tb2t7(infix_at(infix_mngt(int, int), 
                           infix_mngt(int, int), infix_at(infix_mngt(
                           infix_mngt(int, int), infix_mngt(int, int)), 
                           infix_mngt(int, int), t2tb55(h_basis_ket(hqtqt)), 
                           t2tb7(x)), t2tb7(y)))[i]) = (tb2t7(infix_at(
                           infix_mngt(int, int), infix_mngt(int, int), 
                           infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           t2tb55(h_basis_ket(hqt)), t2tb7(fc1095(h, x))), 
                           t2tb7(fc1096(h, y))))[(i - h_width(h))])))))))
                    => (correct_path_sum(infix_slsl(c, cqt), hqtqt))))))))));

% set_correct_main_path_sum
  ASSERT
  (FORALL (c : circuit2, h : pps):
  ((h_width(h) = width1(c))
  => ((h_range(h) = range1(c))
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = width1(c))
         => ((length(y) = range1(c)) => (tb2t33(infix_at(angle1, 
            infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int),
            angle1), infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(
            value(x))), t2tb7(value(y)))) = ang_ind1(c, value(x), value(y))))))
        => ((FORALL (x : bitvec, y : bitvec):
            (FORALL (i : INT):
            (((0 <= i) AND (i < width1(c)))
            => ((length(x) = width1(c))
               => ((length(y) = range1(c)) => ((tb2t7(infix_at(
                  infix_mngt(int, int), infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                  infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(
                  value(x))), t2tb7(value(y))))[i]) = basis_ket1(c, value(x), 
                  value(y), i)))))))
           => (correct_path_sum(c, h)))))));

% set_path_sem_by_correct_pps
  ASSERT
  (FORALL (c : circuit2, h : pps, x : matrix_complex):
  ((correct_path_sum(c, h))
  => ((is_a_ket_l(x, width1(c)))
     => ((is_a_ket_basis_elt(x)) => (path_sem1(c, x) = pps_apply(h, x))))));

fc1097: (circuit2, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (c : circuit2, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1097(c, x)), t2tb26(y))) = 
  infix_asdtdt(ang_exp(ang_ind1(c, value(x), value(y))), bv_to_ket(make_bv(
  tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(
  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int,
  int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int,
  int), infix_mngt(int, int))), circuit3, t2tb68(basis_ket_closure1), 
  t2tb67(c)), t2tb7(value(x))), t2tb7(value(y)))), width1(c))))));

% set_path_sem_by_main_pps
  ASSERT
  (FORALL (c : circuit2, x : bitvec):
  ((length(x) = width1(c)) => (path_sem1(c, bv_to_ket(x)) = infix_asdtdt(
  pow_inv_sqrt_2(range1(c)), ket_sum_l(bitvec1, t2tb28(n_bvs(range1(c))), 
  t2tb29(fc1097(c, x)), width1(c))))));

% set_path_sem_by_correct_pps_gen
  ASSERT
  (FORALL (c : circuit2, h : pps):
  ((correct_path_sum(c, h))
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, width1(c)))
     => ((is_a_ket_basis_elt(x)) => (path_sem1(c, x) = pps_apply(h, x)))))));

% set_correct_path_sum_sim
  ASSERT
  (FORALL (c : circuit2, h : pps, hqt : pps):
  ((h_range(h) = h_range(hqt))
  => ((h_width(h) = h_width(hqt))
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = width1(c))
         => ((length(y) = h_range(h)) => (tb2t33(infix_at(angle1, 
            infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int),
            angle1), infix_mngt(int, int), t2tb57(h_angle(h)), t2tb7(
            value(x))), t2tb7(value(y)))) = tb2t33(infix_at(angle1, 
            infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int),
            angle1), infix_mngt(int, int), t2tb57(h_angle(hqt)), t2tb7(
            value(x))), t2tb7(value(y))))))))
        => ((FORALL (x : bitvec, y : bitvec):
            (FORALL (i : INT):
            ((length(x) = width1(c))
            => ((length(y) = h_range(h))
               => (((0 <= i) AND (i < width1(c))) => ((tb2t7(infix_at(
                  infix_mngt(int, int), infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                  infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(
                  value(x))), t2tb7(value(y))))[i]) = (tb2t7(infix_at(
                  infix_mngt(int, int), infix_mngt(int, int), infix_at(
                  infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                  infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), t2tb7(
                  value(x))), t2tb7(value(y))))[i])))))))
           => ((correct_path_sum(c, h)) => (correct_path_sum(c, hqt))))))));

% path_sum_equiv
  ASSERT
  (FORALL (c : circuit2, h : pps, hqt : pps):
  ((0 <= h_range(h))
  => ((h_range(h) = h_range(hqt))
     => ((h_width(h) = h_width(hqt))
        => ((FORALL (x : bitvec, y : bitvec):
            ((length(x) = width1(c))
            => ((length(y) = h_range(h)) => (tb2t33(infix_at(angle1, 
               infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
               int), angle1), infix_mngt(int, int), t2tb57(h_angle(h)), 
               t2tb7(value(x))), t2tb7(value(y)))) = tb2t33(infix_at(angle1, 
               infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int,
               int), angle1), infix_mngt(int, int), t2tb57(h_angle(hqt)), 
               t2tb7(value(x))), t2tb7(value(y))))))))
           => ((FORALL (x : bitvec, y : bitvec):
               (FORALL (i : INT):
               (((0 <= i) AND (i < width1(c)))
               => ((length(x) = width1(c))
                  => ((length(y) = h_range(h)) => ((tb2t7(infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(h)), t2tb7(
                     value(x))), t2tb7(value(y))))[i]) = (tb2t7(infix_at(
                     infix_mngt(int, int), infix_mngt(int, int), infix_at(
                     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
                     infix_mngt(int, int), t2tb55(h_basis_ket(hqt)), t2tb7(
                     value(x))), t2tb7(value(y))))[i])))))))
              => ((correct_path_sum(c, h)) <=> (correct_path_sum(c, hqt)))))))));

% correct_to_path_sem
  ASSERT
  (FORALL (c : circuit2, h : pps):
  ((correct_path_sum(c, h))
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, width1(c))) => (pps_apply(h, x) = path_sem1(c, x))))));

% swap_invol_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(bricks_swap, 
     path_sem1(bricks_swap, x)) = x))));

% path_sem_to_correct
  ASSERT
  (FORALL (c : circuit2, h : pps):
  ((h_width(h) = width1(c))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width1(c)))
      => ((is_a_ket_basis_elt(x)) => (pps_apply(h, x) = path_sem1(c, x)))))
     => (correct_path_sum(c, h)))));

% correct_main_path_sum
  ASSERT (FORALL (c : circuit2): (correct_path_sum(c, circ_to_pps1(c))));

correct_path_sum_bv1: (circuit2, INT,
  (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  (ARRAY bitvec OF (ARRAY bitvec OF angle))) -> BOOLEAN;

% correct_path_sum_bv'def
  ASSERT
  (FORALL (c : circuit2, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width1(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width1(c)))))
     => ((correct_path_sum_bv1(c, r, k, a)) <=> (correct_path_sum(c, 
        build_pps_bv(width1(c), r, k, a)))))));

% correct_path_sum_to_bv
  ASSERT
  (FORALL (c : circuit2, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width1(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width1(c)))))
     => ((correct_path_sum(c, build_pps_bv(width1(c), r, k, a)))
        => (correct_path_sum_bv1(c, r, k, a))))));

% unwire_correct_bv
  ASSERT
  (FORALL (c : circuit2, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width1(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width1(c)))))
     => ((correct_path_sum_bv1(c, r, k, a)) => (correct_path_sum_bv(
        unwire(c), r, k, a))))));

% unwire_correct_bv_rev
  ASSERT
  (FORALL (c : circuit2, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width1(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width1(c)))))
     => ((correct_path_sum_bv(unwire(c), r, k, a))
        => (correct_path_sum_bv1(c, r, k, a))))));

% wire_correct_bv
  ASSERT
  (FORALL (c : circuit, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width(c)))))
     => ((correct_path_sum_bv(c, r, k, a)) => (correct_path_sum_bv1(wire(c),
        r, k, a))))));

% correct_path_sum_by_bv
  ASSERT
  (FORALL (c : circuit2, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width1(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width1(c)))))
     => ((correct_path_sum_bv1(c, r, k, a)) => (correct_path_sum(c, 
        build_pps_bv(width1(c), r, k, a)))))));

% correct_path_sum_bv_main
  ASSERT
  (FORALL (c : circuit2, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r)
  => ((FORALL (x : bitvec, y : bitvec):
      ((length(x) = width1(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x)), t2tb26(y)))) = width1(c)))))
     => ((FORALL (x : bitvec, y : bitvec):
         (FORALL (i : INT):
         ((length(x) = width1(c))
         => ((length(y) = r)
            => (((0 <= i) AND (i < width1(c))) => ((value(tb2t26(
               infix_at(bitvec1, bitvec1, infix_at(infix_mngt(bitvec1,
               bitvec1), bitvec1, t2tb58(k), t2tb26(x)), t2tb26(y))))[i]) = 
               basis_ket1(c, value(x), value(y), i)))))))
        => ((FORALL (x : bitvec, y : bitvec):
            ((length(x) = width1(c))
            => ((length(y) = r) => (tb2t33(infix_at(angle1, bitvec1, 
               infix_at(infix_mngt(bitvec1, angle1), bitvec1, t2tb60(a), 
               t2tb26(x)), t2tb26(y))) = ang_ind1(c, value(x), value(y))))))
           => ((r = range1(c)) => (correct_path_sum_bv1(c, r, k, a))))))));

fc653: ((ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  (ARRAY bitvec OF (ARRAY bitvec OF angle)),
  bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle)), x : bitvec, y : bitvec): (
  tb2t18(infix_at(matrix(complex1), bitvec1, t2tb29(fc653(k, a, x)), 
  t2tb26(y))) = infix_asdtdt(ang_exp(tb2t33(infix_at(angle1, bitvec1, 
  infix_at(infix_mngt(bitvec1, angle1), bitvec1, t2tb60(a), t2tb26(x)), 
  t2tb26(y)))), bv_to_ket(tb2t26(infix_at(bitvec1, bitvec1, infix_at(
  infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), t2tb26(x)), 
  t2tb26(y)))))));

% correct_path_sum_bv_apply
  ASSERT
  (FORALL (c : circuit2, r : INT,
  k : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a : (ARRAY bitvec OF (ARRAY bitvec OF angle)), x : bitvec):
  ((0 <= r)
  => ((FORALL (x1 : bitvec, y : bitvec):
      ((length(x1) = width1(c))
      => ((length(y) = r) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
         infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k), 
         t2tb26(x1)), t2tb26(y)))) = width1(c)))))
     => ((length(x) = width1(c))
        => ((correct_path_sum_bv1(c, r, k, a)) => (path_sem1(c, 
           bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(r), ket_sum_l(bitvec1, 
           t2tb28(n_bvs(r)), t2tb29(fc653(k, a, x)), width1(c)))))))));

seq_pps_bv: (circuit2, circuit2, INT, INT, INT,
  (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  (ARRAY bitvec OF (ARRAY bitvec OF angle)),
  (ARRAY bitvec OF (ARRAY bitvec OF angle)),
  (ARRAY bitvec OF (ARRAY bitvec OF angle))) -> circuit2;

% seq_pps_bv'def
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, r1 : INT, r2 : INT, r3 : INT,
  k1 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  k2 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  k3 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a1 : (ARRAY bitvec OF (ARRAY bitvec OF angle)),
  a2 : (ARRAY bitvec OF (ARRAY bitvec OF angle)),
  a3 : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r1)
  => ((0 <= r2)
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = width1(c))
         => ((length(y) = r1) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
            infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k1), 
            t2tb26(x)), t2tb26(y)))) = width1(c)))))
        => ((FORALL (x : bitvec, y : bitvec):
            ((length(x) = width1(c))
            => ((length(y) = r2) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
               infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k2), 
               t2tb26(x)), t2tb26(y)))) = width1(c)))))
           => ((FORALL (x : bitvec, y : bitvec):
               ((length(x) = width1(c))
               => ((length(y) = r3) => (length(tb2t26(infix_at(bitvec1,
                  bitvec1, infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, 
                  t2tb58(k3), t2tb26(x)), t2tb26(y)))) = width1(c)))))
              => ((width1(c) = width1(cqt))
                 => ((r3 = (r1 + r2))
                    => ((correct_path_sum_bv1(c, r1, k1, a1))
                       => ((correct_path_sum_bv1(cqt, r2, k2, a2))
                          => ((FORALL (x : bitvec, y : bitvec):
                              ((length(x) = width1(c))
                              => ((length(y) = r3) => (tb2t33(
                                 infix_at(angle1, bitvec1, infix_at(
                                 infix_mngt(bitvec1, angle1), bitvec1, 
                                 t2tb60(a3), t2tb26(x)), t2tb26(y))) = 
                                 ang_add(tb2t33(infix_at(angle1, bitvec1, 
                                 infix_at(infix_mngt(bitvec1, angle1),
                                 bitvec1, t2tb60(a1), t2tb26(x)), t2tb26(
                                 hpart(y, r1)))), tb2t33(infix_at(angle1,
                                 bitvec1, infix_at(infix_mngt(bitvec1,
                                 angle1), bitvec1, t2tb60(a2), 
                                 infix_at(bitvec1, bitvec1, infix_at(
                                 infix_mngt(bitvec1, bitvec1), bitvec1, 
                                 t2tb58(k1), t2tb26(x)), t2tb26(hpart(y,
                                 r1)))), t2tb26(tpart(y, r1)))))))))
                             => ((FORALL (x : bitvec, y : bitvec):
                                 ((length(x) = width1(c))
                                 => ((length(y) = r3) => (tb2t26(
                                    infix_at(bitvec1, bitvec1, infix_at(
                                    infix_mngt(bitvec1, bitvec1), bitvec1, 
                                    t2tb58(k3), t2tb26(x)), t2tb26(y))) = 
                                    tb2t26(infix_at(bitvec1, bitvec1, 
                                    infix_at(infix_mngt(bitvec1, bitvec1),
                                    bitvec1, t2tb58(k2), infix_at(bitvec1,
                                    bitvec1, infix_at(infix_mngt(bitvec1,
                                    bitvec1), bitvec1, t2tb58(k1), 
                                    t2tb26(x)), t2tb26(hpart(y, r1)))), 
                                    t2tb26(tpart(y, r1))))))))
                                => (seq_pps_bv(c, cqt, r1, r2, r3, k1, k2,
                                k3, a1, a2, a3) = infix_mnmn(c, cqt))))))))))))));

% seq_pps_bv'spec
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, r1 : INT, r2 : INT, r3 : INT,
  k1 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  k2 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  k3 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a1 : (ARRAY bitvec OF (ARRAY bitvec OF angle)),
  a2 : (ARRAY bitvec OF (ARRAY bitvec OF angle)),
  a3 : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((0 <= r1)
  => ((0 <= r2)
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = width1(c))
         => ((length(y) = r1) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
            infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k1), 
            t2tb26(x)), t2tb26(y)))) = width1(c)))))
        => ((FORALL (x : bitvec, y : bitvec):
            ((length(x) = width1(c))
            => ((length(y) = r2) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
               infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k2), 
               t2tb26(x)), t2tb26(y)))) = width1(c)))))
           => ((FORALL (x : bitvec, y : bitvec):
               ((length(x) = width1(c))
               => ((length(y) = r3) => (length(tb2t26(infix_at(bitvec1,
                  bitvec1, infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, 
                  t2tb58(k3), t2tb26(x)), t2tb26(y)))) = width1(c)))))
              => ((width1(c) = width1(cqt))
                 => ((r3 = (r1 + r2))
                    => ((correct_path_sum_bv1(c, r1, k1, a1))
                       => ((correct_path_sum_bv1(cqt, r2, k2, a2))
                          => ((FORALL (x : bitvec, y : bitvec):
                              ((length(x) = width1(c))
                              => ((length(y) = r3) => (tb2t33(
                                 infix_at(angle1, bitvec1, infix_at(
                                 infix_mngt(bitvec1, angle1), bitvec1, 
                                 t2tb60(a3), t2tb26(x)), t2tb26(y))) = 
                                 ang_add(tb2t33(infix_at(angle1, bitvec1, 
                                 infix_at(infix_mngt(bitvec1, angle1),
                                 bitvec1, t2tb60(a1), t2tb26(x)), t2tb26(
                                 hpart(y, r1)))), tb2t33(infix_at(angle1,
                                 bitvec1, infix_at(infix_mngt(bitvec1,
                                 angle1), bitvec1, t2tb60(a2), 
                                 infix_at(bitvec1, bitvec1, infix_at(
                                 infix_mngt(bitvec1, bitvec1), bitvec1, 
                                 t2tb58(k1), t2tb26(x)), t2tb26(hpart(y,
                                 r1)))), t2tb26(tpart(y, r1)))))))))
                             => ((FORALL (x : bitvec, y : bitvec):
                                 ((length(x) = width1(c))
                                 => ((length(y) = r3) => (tb2t26(
                                    infix_at(bitvec1, bitvec1, infix_at(
                                    infix_mngt(bitvec1, bitvec1), bitvec1, 
                                    t2tb58(k3), t2tb26(x)), t2tb26(y))) = 
                                    tb2t26(infix_at(bitvec1, bitvec1, 
                                    infix_at(infix_mngt(bitvec1, bitvec1),
                                    bitvec1, t2tb58(k2), infix_at(bitvec1,
                                    bitvec1, infix_at(infix_mngt(bitvec1,
                                    bitvec1), bitvec1, t2tb58(k1), 
                                    t2tb26(x)), t2tb26(hpart(y, r1)))), 
                                    t2tb26(tpart(y, r1))))))))
                                => ((seq_pps_bv(c, cqt, r1, r2, r3, k1, k2,
                                   k3, a1, a2, a3) = infix_mnmn(c, cqt))
                                   AND ((width1(seq_pps_bv(c, cqt, r1, r2,
                                       r3, k1, k2, k3, a1, a2, a3)) = 
                                       width1(c))
                                       AND ((size1(seq_pps_bv(c, cqt, r1, r2,
                                           r3, k1, k2, k3, a1, a2, a3)) = (
                                           size1(c) + size1(cqt)))
                                           AND ((ancillas1(seq_pps_bv(c, cqt,
                                               r1, r2, r3, k1, k2, k3, a1,
                                               a2, a3)) = max(ancillas1(c), 
                                               ancillas1(cqt)))
                                               AND (correct_path_sum_bv1(
                                               seq_pps_bv(c, cqt, r1, r2, r3,
                                               k1, k2, k3, a1, a2, a3), r3,
                                               k3, a3))))))))))))))))));

% correct_path_sum_bv_sim
  ASSERT
  (FORALL (c : circuit2, r1 : INT,
  k1 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a1 : (ARRAY bitvec OF (ARRAY bitvec OF angle)), r2 : INT,
  k2 : (ARRAY bitvec OF (ARRAY bitvec OF bitvec)),
  a2 : (ARRAY bitvec OF (ARRAY bitvec OF angle))):
  ((r1 = r2)
  => ((0 <= r1)
     => ((FORALL (x : bitvec, y : bitvec):
         ((length(x) = width1(c))
         => ((length(y) = r1) => (length(tb2t26(infix_at(bitvec1, bitvec1, 
            infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k1), 
            t2tb26(x)), t2tb26(y)))) = width1(c)))))
        => ((FORALL (x : bitvec, y : bitvec):
            ((length(x) = width1(c))
            => ((length(y) = r1) => (tb2t26(infix_at(bitvec1, bitvec1, 
               infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k1), 
               t2tb26(x)), t2tb26(y))) = tb2t26(infix_at(bitvec1, bitvec1, 
               infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(k2), 
               t2tb26(x)), t2tb26(y)))))))
           => ((FORALL (x : bitvec, y : bitvec):
               ((length(x) = width1(c))
               => ((length(y) = r1) => (tb2t33(infix_at(angle1, bitvec1, 
                  infix_at(infix_mngt(bitvec1, angle1), bitvec1, t2tb60(a1), 
                  t2tb26(x)), t2tb26(y))) = tb2t33(infix_at(angle1, bitvec1, 
                  infix_at(infix_mngt(bitvec1, angle1), bitvec1, t2tb60(a2), 
                  t2tb26(x)), t2tb26(y)))))))
              => ((correct_path_sum_bv1(c, r1, k1, a1))
                 => (correct_path_sum_bv1(c, r2, k2, a2)))))))));

% path_sem_comp
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex,
  y : matrix_complex, z : matrix_complex):
  ((is_a_ket_l(x, width1(d)))
  => ((path_sem1(d, x) = y)
     => ((path_sem1(e, y) = z)
        => ((width1(d) = width1(e)) => (path_sem1(infix_mnmn(d, e), x) = z))))));

path_seq: (circuit2, circuit2, matrix_complex, matrix_complex,
  matrix_complex, INT) -> circuit2;

% path_seq'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex,
  y : matrix_complex, z : matrix_complex, w : INT):
  ((is_a_ket_l(x, w))
  => ((path_sem1(d, x) = y)
     => ((path_sem1(e, y) = z)
        => (((width1(d) = width1(e)) AND (width1(e) = w)) => (path_seq(d, e,
           x, y, z, w) = infix_mnmn(d, e)))))));

% path_seq'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex,
  y : matrix_complex, z : matrix_complex, w : INT):
  ((is_a_ket_l(x, w))
  => ((path_sem1(d, x) = y)
     => ((path_sem1(e, y) = z)
        => (((width1(d) = width1(e)) AND (width1(e) = w))
           => ((width1(path_seq(d, e, x, y, z, w)) = w)
              AND ((path_sem1(path_seq(d, e, x, y, z, w), x) = z)
                  AND ((is_a_ket_l(z, w)) AND (path_seq(d, e, x, y, z, w) = 
                      infix_mnmn(d, e))))))))));

% path_sem_comp_
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(d)))
  => ((width1(d) = width1(e)) => (path_sem1(infix_mnmn(d, e), x) = 
     path_sem1(e, path_sem1(d, x))))));

% sem_comp
  ASSERT
  (FORALL (d : circuit2, e : circuit2, x : matrix_complex,
  y : matrix_complex, z : matrix_complex):
  ((sem1(d, x, y))
  => ((sem1(e, y, z))
     => ((width1(d) = width1(e)) => (sem1(infix_mnmn(d, e), x, z))))));

% path_sem_cnot_basis
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 2))
  => ((is_a_ket_basis_elt(x)) => (path_sem1(bricks_cnot,
     x) = (IF (ket_to_int(x) = 0) THEN ket(2, 0)
          ELSE (IF (ket_to_int(x) = 1) THEN ket(2, 1)
               ELSE (IF (ket_to_int(x) = 2) THEN ket(2, 3) ELSE ket(2,
                    2) ENDIF) ENDIF) ENDIF)))));

% place_kron
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, x : matrix_complex,
  y : matrix_complex, yqt : matrix_complex, z : matrix_complex):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((is_a_ket_l(x, k))
        => ((is_a_ket_l(y, width1(c)))
           => ((is_a_ket_l(z, ((n - width1(c)) - k)))
              => ((path_sem1(c, y) = yqt) => (path_sem1(place1(c, k, n), 
                 kronecker(x, kronecker(y, z))) = kronecker(x, kronecker(yqt,
                 z))))))))));

% place_width
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT):
  ((0 <= k) => (((width1(c) + k) <= n) => (width1(place1(c, k, n)) = n))));

fc654: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, x : (ARRAY INT OF INT), j : INT): ((fc654(k,
  x)[j]) = (x[(j + k)])));

% place_bv_in
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
        ((binary_l(x, n))
        => (((k <= i) AND (i < (k + width1(c)))) => (basis_ket1(place1(c, k,
           n), x, y, i) = basis_ket1(c, fc654(k, x), y, (i - k)))))))));

% place_bv_out
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
        ((binary_l(x, n))
        => (((0 <= i) AND (i < n))
           => ((NOT ((k <= i) AND (i < (k + width1(c))))) => (basis_ket1(
              place1(c, k, n), x, y, i) = (x[i])))))))));

% sequence_width
  ASSERT
  (FORALL (c : circuit2, d : circuit2):
  ((width1(c) = width1(d)) => (width1(infix_mnmn(c, d)) = width1(c))));

% place_kron_bv
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, bv : bitvec):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((length(bv) = n) => (path_sem1(place1(c, k, n), bv_to_ket(bv)) = 
        kronecker(kronecker(bv_to_ket(hpart(bv, k)), path_sem1(c, bv_to_ket(
        htpart(bv, k, width1(c))))), bv_to_ket(tpart(bv, (k + width1(c))))))))));

% place_kron_exp
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, x : matrix_complex,
  y : matrix_complex, z : matrix_complex):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((is_a_ket_l(x, k))
        => ((is_a_ket_l(y, width1(c)))
           => ((is_a_ket_l(z, ((n - width1(c)) - k))) => (path_sem1(place1(c,
              k, n), kronecker(x, kronecker(y, z))) = kronecker(x, kronecker(
              path_sem1(c, y), z)))))))));

% place_kron_left
  ASSERT
  (FORALL (c : circuit2, n : INT, y : matrix_complex, yqt : matrix_complex,
  z : matrix_complex):
  ((width1(c) <= n)
  => ((is_a_ket_l(y, width1(c)))
     => ((is_a_ket_l(z, (n - width1(c))))
        => ((path_sem1(c, y) = yqt) => (path_sem1(place1(c, 0, n), 
           kronecker(y, z)) = kronecker(yqt, z)))))));

% place_kron_right
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT):
  ((0 < k)
  => ((n = (width1(c) + k))
     => (FORALL (y : matrix_complex, x : matrix_complex):
        ((is_a_ket_l(x, k))
        => ((is_a_ket_l(y, (n - k))) => (path_sem1(place1(c, k, n), 
           kronecker(x, y)) = kronecker(x, path_sem1(c, y)))))))));

% place_place
  ASSERT
  (FORALL (c : circuit2, k : INT, kqt : INT, n : INT, nqt : INT, x : bitvec):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((0 <= kqt)
        => (((n + kqt) <= nqt)
           => ((length(x) = nqt) => (path_sem1(place1(place1(c, k, n), kqt,
              nqt), bv_to_ket(x)) = path_sem1(place1(c, (k + kqt), nqt), 
              bv_to_ket(x)))))))));

fc1098: (INT, bitvec) -> (ARRAY INT OF INT);

fc1099: (INT, bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, x : bitvec, i : INT): ((fc1098(k, x)[i]) = (
  value(x)[(i + k)])));

% fc'def
  ASSERT
  (FORALL (k : INT, y : bitvec, i : INT): ((fc1099(k, y)[i]) = (
  value(y)[(i + k)])));

% place_get_ket
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, x : bitvec, y : bitvec):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((length(x) = n)
        => ((length(y) = n)
           => ((hpart(x, k) = hpart(y, k))
              => ((tpart(x, (k + width1(c))) = tpart(y, (k + width1(c))))
                 => (tb2t(get(complex1, t2tb18(path_sem1(place1(c, k, n), 
                 bv_to_ket(x))), bv_to_int(y), 0)) = tb2t(get(complex1, 
                 t2tb18(path_sem1(c, bv_to_ket(make_bv(fc1098(k, x), 
                 width1(c))))), bv_to_int(make_bv(fc1099(k, y), width1(c))),
                 0))))))))));

% place_get_ket_hpart_null
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, x : bitvec, y : bitvec):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((length(x) = n)
        => ((length(y) = n)
           => ((NOT (hpart(x, k) = hpart(y, k))) => (tb2t(get(complex1, 
              t2tb18(path_sem1(place1(c, k, n), bv_to_ket(x))), bv_to_int(y),
              0)) = c_zero)))))));

% place_get_ket_tpart_null
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, x : bitvec, y : bitvec):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((length(x) = n)
        => ((length(y) = n)
           => ((NOT (tpart(x, (k + width1(c))) = tpart(y, (k + width1(c)))))
              => (tb2t(get(complex1, t2tb18(path_sem1(place1(c, k, n), 
              bv_to_ket(x))), bv_to_int(y), 0)) = c_zero)))))));

place_hadamard1: (INT, INT) -> circuit2;

% place_hadamard'def
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < n)) => (place_hadamard1(k, n) = place1(hadamard1, k,
  n))));

% place_hadamard'spec
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < n))
  => ((range1(place_hadamard1(k, n)) = 1)
     AND ((size1(place_hadamard1(k, n)) = 1)
         AND ((width1(place_hadamard1(k, n)) = n)
             AND ((ancillas1(place_hadamard1(k, n)) = 0)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT)):
                      (FORALL (i : INT):
                      (((0 <= i) AND (i < n)) => (basis_ket1(
                      place_hadamard1(k, n), x, y,
                      i) = (IF (i = k) THEN (y[0]) ELSE (x[i]) ENDIF)))))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(
                          place_hadamard1(k, n), x, y) = 
                          infix_sldtsl(((x[k]) * (y[0])), 1)))
                         AND ((FORALL (m : INT):
                              (FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)):
                              ((1 <= m) => (ang_ind1(place_hadamard1(k, n),
                              x, y) = infix_sldtsl((((x[k]) * (y[0])) * 
                              power(2, (m - 1))), m)))))
                             AND (FORALL (m : INT):
                                 (FORALL (x : (ARRAY INT OF INT),
                                 y : (ARRAY INT OF INT)):
                                 ((1 <= m) => (ang_ind1(place_hadamard1(k,
                                 n), x, y) = 
                                 infix_sldtsl((- (((x[k]) * (y[0])) * 
                                 power(2, (m - 1)))), m))))))))))))));

place_hadamard_bv1: (INT, INT) -> circuit2;

% place_hadamard_bv'def
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < n)) => (place_hadamard_bv1(k, n) = place_hadamard1(k,
  n))));

fc1100: (INT, bitvec, bitvec) -> (ARRAY INT OF INT);

fc1101: (INT, INT) -> (ARRAY bitvec OF (ARRAY bitvec OF bitvec));

fc1102: (INT, INT) -> (ARRAY bitvec OF (ARRAY bitvec OF angle));

% fc'def
  ASSERT
  (FORALL (k : INT, x : bitvec, y : bitvec, i : INT): ((fc1100(k, x,
  y)[i]) = (IF (i = k) THEN (value(y)[0]) ELSE (value(x)[i]) ENDIF)));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, x : bitvec, y : bitvec): (tb2t26(
  infix_at(bitvec1, bitvec1, infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, 
  t2tb58(fc1101(k, n)), t2tb26(x)), t2tb26(y))) = make_bv(fc1100(k, x, y),
  n)));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, x : bitvec, y : bitvec): (tb2t33(
  infix_at(angle1, bitvec1, infix_at(infix_mngt(bitvec1, angle1), bitvec1, 
  t2tb60(fc1102(k, n)), t2tb26(x)), t2tb26(y))) = infix_sldtsl((((
  value(x)[k]) * (value(y)[0])) * power(2, (n - 1))), n)));

% place_hadamard_bv'spec
  ASSERT
  (FORALL (k : INT, n : INT):
  (((0 <= k) AND (k < n))
  => ((range1(place_hadamard_bv1(k, n)) = 1)
     AND ((width1(place_hadamard_bv1(k, n)) = n)
         AND ((size1(place_hadamard_bv1(k, n)) = 1)
             AND ((ancillas1(place_hadamard_bv1(k, n)) = 0)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT)):
                      (FORALL (i : INT):
                      (((0 <= i) AND (i < n)) => (basis_ket1(
                      place_hadamard_bv1(k, n), x, y,
                      i) = (IF (i = k) THEN (y[0]) ELSE (x[i]) ENDIF)))))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(
                          place_hadamard_bv1(k, n), x, y) = 
                          infix_sldtsl(((x[k]) * (y[0])), 1)))
                         AND ((FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)):
                              (FORALL (m : INT):
                              ((1 <= m) => (ang_ind1(place_hadamard_bv1(k,
                              n), x, y) = infix_sldtsl((((x[k]) * (y[0])) * 
                              power(2, (m - 1))), m)))))
                             AND (correct_path_sum_bv1(place_hadamard_bv1(k,
                             n), 1, fc1101(k, n), fc1102(k, n))))))))))));

% path_cont
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co))
        => ((FORALL (bv : bitvec):
            ((length(bv) = n)
            => (((value(bv)[co]) = 0) => (path_sem1(cont1(c, co, k, n), 
               bv_to_ket(bv)) = bv_to_ket(bv)))))
           AND (FORALL (bv : bitvec):
               ((length(bv) = n)
               => (((value(bv)[co]) = 1) => (path_sem1(cont1(c, co, k, n), 
                  bv_to_ket(bv)) = path_sem1(place1(c, k, n), 
                  bv_to_ket(bv)))))))))));

% cont_width
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co)) => (width1(cont1(c, co, k,
        n)) = n)))));

% path_cont_ketz
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT, x : matrix_complex):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co))
        => ((is_a_ket_l(x, n))
           => ((is_a_ket_basis_elt(x))
              => (((value(ket_to_bv(x))[co]) = 0) => (path_sem1(cont1(c, co,
                 k, n), x) = x))))))));

% path_cont_keto
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT, x : matrix_complex):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co))
        => ((is_a_ket_l(x, n))
           => ((is_a_ket_basis_elt(x))
              => (((value(ket_to_bv(x))[co]) = 1) => (path_sem1(cont1(c, co,
                 k, n), x) = path_sem1(place1(c, k, n), x)))))))));

% path_cont_ketz_gen
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co))
        => (FORALL (x : matrix_complex):
           ((is_a_ket_l(x, n))
           => ((is_a_ket_basis_elt(x))
              => (((value(ket_to_bv(x))[co]) = 0) => (path_sem1(cont1(c, co,
                 k, n), x) = x)))))))));

% path_cont_keto_gen
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co))
        => (FORALL (x : matrix_complex):
           ((is_a_ket_l(x, n))
           => ((is_a_ket_basis_elt(x))
              => (((value(ket_to_bv(x))[co]) = 1) => (path_sem1(cont1(c, co,
                 k, n), x) = path_sem1(place1(c, k, n), x))))))))));

% cont_kron_left_bv_to_ket
  ASSERT
  (FORALL (c : circuit2, n : INT, x : matrix_complex):
  (((0 <= width1(c)) AND (width1(c) = (n - 1)))
  => ((is_a_ket_l(x, width1(c)))
     => ((FORALL (y : bitvec):
         ((length(y) = 1)
         => (((value(y)[0]) = 0) => (path_sem1(cont1(c, (n - 1), 0, n), 
            kronecker(x, bv_to_ket(y))) = kronecker(x, bv_to_ket(y))))))
        AND (FORALL (y : bitvec):
            ((length(y) = 1)
            => (((value(y)[0]) = 1) => (path_sem1(cont1(c, (n - 1), 0, n), 
               kronecker(x, bv_to_ket(y))) = kronecker(path_sem1(c, x), 
               bv_to_ket(y))))))))));

% place_kron_left_path
  ASSERT
  (FORALL (c : circuit2, n : INT):
  ((width1(c) < n)
  => (FORALL (x : matrix_complex, y : matrix_complex):
     ((is_a_ket_l(x, width1(c)))
     => ((is_a_ket_l(y, (n - width1(c)))) => (path_sem1(place1(c, 0, n), 
        kronecker(x, y)) = kronecker(path_sem1(c, x), y)))))));

% place_kron_left_sem
  ASSERT
  (FORALL (c : circuit2, n : INT):
  ((width1(c) < n)
  => (FORALL (x : matrix_complex, y : matrix_complex, z : matrix_complex):
     ((is_a_ket_l(y, (n - width1(c))))
     => ((sem1(c, x, z)) => (sem1(place1(c, 0, n), kronecker(x, y), 
        kronecker(z, y))))))));

% cont_kron_pat_right
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT, y : matrix_complex):
  (((0 <= co) AND (co < k))
  => ((n = (k + width1(c)))
     => ((is_a_ket_l(y, width1(c)))
        => ((FORALL (x : matrix_complex):
            ((is_a_ket_basis_elt(x))
            => ((is_a_ket_l(x, k))
               => (((value(ket_to_bv(x))[co]) = 0) => (path_sem1(cont1(c, co,
                  k, n), kronecker(x, y)) = kronecker(x, y))))))
           AND (FORALL (x : matrix_complex):
               ((is_a_ket_basis_elt(x))
               => ((is_a_ket_l(x, k))
                  => (((value(ket_to_bv(x))[co]) = 1) => (path_sem1(cont1(c,
                     co, k, n), kronecker(x, y)) = kronecker(x, path_sem1(c,
                     y))))))))))));

% cont_kron_zero
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT, x : matrix_complex,
  y : matrix_complex, z : matrix_complex):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co))
        => ((is_a_ket_l(x, k))
           => ((is_a_ket_l(y, width1(c)))
              => ((is_a_ket_l(z, ((n - k) - width1(c))))
                 => ((is_a_ket_basis_elt(x))
                    => ((is_a_ket_basis_elt(z))
                       => (((co < k) => ((value(ket_to_bv(x))[co]) = 0))
                          => (((k <= co) => ((value(
                              ket_to_bv(z))[((co - k) - width1(c))]) = 0))
                             => (path_sem1(cont1(c, co, k, n), kronecker(
                             kronecker(x, y), z)) = kronecker(kronecker(x,
                             y), z)))))))))))));

% cont_kron_one
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT, x : matrix_complex,
  y : matrix_complex, z : matrix_complex):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co))
        => ((is_a_ket_l(x, k))
           => ((is_a_ket_l(y, width1(c)))
              => ((is_a_ket_l(z, ((n - k) - width1(c))))
                 => ((is_a_ket_basis_elt(x))
                    => ((is_a_ket_basis_elt(z))
                       => (((co < k) => ((value(ket_to_bv(x))[co]) = 1))
                          => (((k <= co) => ((value(
                              ket_to_bv(z))[((co - k) - width1(c))]) = 1))
                             => (path_sem1(cont1(c, co, k, n), kronecker(
                             kronecker(x, y), z)) = path_sem1(place1(c, k,
                             n), kronecker(kronecker(x, y), z))))))))))))));

% cont_kron_pat_right_gen
  ASSERT
  (FORALL (circ : circuit2, c : INT, k : INT, n : INT):
  (((0 <= c) AND (c < k))
  => ((n = (k + width1(circ)))
     => ((FORALL (y : matrix_complex):
         (FORALL (x : bitvec):
         ((is_a_ket_l(y, width1(circ)))
         => ((length(x) = k)
            => (((value(x)[c]) = 0) => (path_sem1(cont1(circ, c, k, n), 
               kronecker(bv_to_ket(x), y)) = kronecker(bv_to_ket(x), y)))))))
        AND (FORALL (y : matrix_complex):
            (FORALL (x : bitvec):
            ((is_a_ket_l(y, width1(circ)))
            => ((length(x) = k)
               => (((value(x)[c]) = 1) => (path_sem1(cont1(circ, c, k, n), 
                  kronecker(bv_to_ket(x), y)) = kronecker(bv_to_ket(x), 
                  path_sem1(circ, y))))))))))));

% cont_kron_pat_right_gen_ket
  ASSERT
  (FORALL (circ : circuit2, c : INT, k : INT, n : INT):
  (((0 <= c) AND (c < k))
  => ((n = (k + width1(circ)))
     => ((FORALL (x : matrix_complex, y : matrix_complex):
         ((is_a_ket_l(y, width1(circ)))
         => ((is_a_ket_l(x, k))
            => ((is_a_ket_basis_elt(x))
               => (((value(ket_to_bv(x))[c]) = 0) => (path_sem1(cont1(circ,
                  c, k, n), kronecker(x, y)) = kronecker(x, y)))))))
        AND (FORALL (x : matrix_complex, y : matrix_complex):
            ((is_a_ket_l(y, width1(circ)))
            => ((is_a_ket_l(x, k))
               => ((is_a_ket_basis_elt(x))
                  => (((value(ket_to_bv(x))[c]) = 1) => (path_sem1(
                     cont1(circ, c, k, n), kronecker(x, y)) = kronecker(x, 
                     path_sem1(circ, y))))))))))));

cont_last_qbit_kron: (circuit2) -> circuit2;

% cont_last_qbit_kron'def
  ASSERT
  (FORALL (c : circuit2): (cont_last_qbit_kron(c) = cont1(c, width1(c), 0, (
  width1(c) + 1))));

% cont_last_qbit_kron'spec
  ASSERT
  (FORALL (c : circuit2):
  ((size1(cont_last_qbit_kron(c)) <= (size1(c) * cont_size1))
  AND ((ancillas1(cont_last_qbit_kron(c)) = ancillas1(c))
      AND ((range1(cont_last_qbit_kron(c)) = range1(c))
          AND ((width1(cont_last_qbit_kron(c)) = (width1(c) + 1))
              AND ((FORALL (x : matrix_complex, y : matrix_complex):
                   ((sem1(c, x, y)) => (sem1(cont_last_qbit_kron(c), 
                   kronecker(x, ket(1, 1)), kronecker(y, ket(1, 1))))))
                  AND (FORALL (x : matrix_complex):
                      ((is_a_ket_l(x, width1(c))) => (sem1(
                      cont_last_qbit_kron(c), kronecker(x, ket(1, 0)), 
                      kronecker(x, ket(1, 0))))))))))));

cont_last_qbit_kron_path: (circuit2) -> circuit2;

% cont_last_qbit_kron_path'def
  ASSERT
  (FORALL (c : circuit2): (cont_last_qbit_kron_path(c) = cont1(c, width1(c),
  0, (width1(c) + 1))));

% cont_last_qbit_kron_path'spec
  ASSERT
  (FORALL (c : circuit2):
  ((size1(cont_last_qbit_kron_path(c)) <= (size1(c) * cont_size1))
  AND ((ancillas1(cont_last_qbit_kron_path(c)) = ancillas1(c))
      AND ((range1(cont_last_qbit_kron_path(c)) = range1(c))
          AND ((width1(cont_last_qbit_kron_path(c)) = (width1(c) + 1))
              AND ((FORALL (x : matrix_complex, y : matrix_complex):
                   ((is_a_ket_l(x, width1(c)))
                   => ((path_sem1(c, x) = y) => (path_sem1(
                      cont_last_qbit_kron_path(c), kronecker(x, ket(1,
                      1))) = kronecker(y, ket(1, 1))))))
                  AND (FORALL (x : matrix_complex):
                      ((is_a_ket_l(x, width1(c))) => (path_sem1(
                      cont_last_qbit_kron_path(c), kronecker(x, ket(1,
                      0))) = kronecker(x, ket(1, 0)))))))))));

seq_diag: (circuit2, circuit2) -> circuit2;

% seq_diag'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((range1(e) = 0)
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
            i : INT):
            ((binary_l(x, width1(d)))
            => (((0 <= i) AND (i < width1(d))) => (basis_ket1(d, x, y,
               i) = (x[i])))))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
               i : INT):
               ((binary_l(x, width1(e)))
               => (((0 <= i) AND (i < width1(e))) => (basis_ket1(e, x, y,
                  i) = (x[i])))))
              => (seq_diag(d, e) = infix_mnmn(d, e))))))));

% seq_diag'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((range1(e) = 0)
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
            i : INT):
            ((binary_l(x, width1(d)))
            => (((0 <= i) AND (i < width1(d))) => (basis_ket1(d, x, y,
               i) = (x[i])))))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
               i : INT):
               ((binary_l(x, width1(e)))
               => (((0 <= i) AND (i < width1(e))) => (basis_ket1(e, x, y,
                  i) = (x[i])))))
              => ((size1(seq_diag(d, e)) = (size1(d) + size1(e)))
                 AND ((ancillas1(seq_diag(d, e)) = max(ancillas1(d), 
                     ancillas1(e)))
                     AND ((pre1(seq_diag(d, e)) = Sequence1(pre1(d), 
                         pre1(e)))
                         AND ((FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT), i : INT):
                              ((binary_l(x, width1(d)))
                              => (((0 <= i) AND (i < width1(d))) => (
                                 basis_ket1(seq_diag(d, e), x, y,
                                 i) = (x[i])))))
                             AND ((width1(seq_diag(d, e)) = width1(d))
                                 AND ((range1(seq_diag(d, e)) = 0)
                                     AND (FORALL (x : (ARRAY INT OF INT),
                                         y : (ARRAY INT OF INT)):
                                         ((binary_l(x, width1(d))) => (
                                         ang_ind1(seq_diag(d, e), x, y) = 
                                         ang_add(ang_ind1(d, x, y), 
                                         ang_ind1(e, x, y)))))))))))))))));

cont_diag: (circuit2, INT, INT, INT) -> circuit2;

% cont_diag'def
  ASSERT
  (FORALL (c : circuit2, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - width1(c))))
     => (((t1 <= co) => ((t1 + width1(c)) <= co))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
            i : INT):
            ((binary_l(x, width1(c)))
            => (((0 <= i) AND (i < width1(c))) => (basis_ket1(c, x, y,
               i) = (x[i])))))
           => ((range1(c) = 0) => (cont_diag(c, co, t1, n) = cont1(c, co, t1,
              n))))))));

fc1103: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc1103(t1,
  x)[j]) = (x[(j + t1)])));

% cont_diag'spec
  ASSERT
  (FORALL (c : circuit2, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - width1(c))))
     => (((t1 <= co) => ((t1 + width1(c)) <= co))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
            i : INT):
            ((binary_l(x, width1(c)))
            => (((0 <= i) AND (i < width1(c))) => (basis_ket1(c, x, y,
               i) = (x[i])))))
           => ((range1(c) = 0)
              => ((size1(cont_diag(c, co, t1, n)) <= (cont_size1 * size1(c)))
                 AND ((ancillas1(cont_diag(c, co, t1, n)) = ancillas1(c))
                     AND ((pre1(cont_diag(c, co, t1, n)) = Cont(pre1(c), co,
                         t1, n))
                         AND ((width1(cont_diag(c, co, t1, n)) = n)
                             AND ((range1(cont_diag(c, co, t1, n)) = 0)
                                 AND ((FORALL (x : (ARRAY INT OF INT),
                                      y : (ARRAY INT OF INT)):
                                      ((binary_l(x, n))
                                      => (FORALL (i : INT): (basis_ket1(
                                         cont_diag(c, co, t1, n), x, y,
                                         i) = (x[i])))))
                                     AND (FORALL (x : (ARRAY INT OF INT),
                                         y : (ARRAY INT OF INT)):
                                         ((binary_l(x, n)) => (ang_ind1(
                                         cont_diag(c, co, t1, n), x, y) = 
                                         ang_mult_int(ang_ind1(c, fc1103(t1,
                                         x), y), (x[co])))))))))))))))));

place_diag: (circuit2, INT, INT) -> circuit2;

% place_diag'def
  ASSERT
  (FORALL (c : circuit2, t1 : INT, n : INT):
  ((0 <= t1)
  => (((t1 + width1(c)) <= n)
     => ((range1(c) = 0)
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
            i : INT):
            ((binary_l(x, width1(c)))
            => (((0 <= i) AND (i < width1(c))) => (basis_ket1(c, x, y,
               i) = (x[i])))))
           => (place_diag(c, t1, n) = place1(c, t1, n)))))));

fc661: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc661(t1,
  x)[j]) = (x[(j + t1)])));

% place_diag'spec
  ASSERT
  (FORALL (c : circuit2, t1 : INT, n : INT):
  ((0 <= t1)
  => (((t1 + width1(c)) <= n)
     => ((range1(c) = 0)
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
            i : INT):
            ((binary_l(x, width1(c)))
            => (((0 <= i) AND (i < width1(c))) => (basis_ket1(c, x, y,
               i) = (x[i])))))
           => ((ancillas1(place_diag(c, t1, n)) = ancillas1(c))
              AND ((size1(place_diag(c, t1, n)) = size1(c))
                  AND ((pre1(place_diag(c, t1, n)) = Place(pre1(c), t1, n))
                      AND ((width1(place_diag(c, t1, n)) = n)
                          AND ((range1(place_diag(c, t1, n)) = 0)
                              AND ((FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)):
                                   (FORALL (i : INT):
                                   ((binary_l(x, n)) => (basis_ket1(
                                   place_diag(c, t1, n), x, y, i) = (x[i])))))
                                  AND (FORALL (x : (ARRAY INT OF INT),
                                      y : (ARRAY INT OF INT)):
                                      ((binary_l(x, n)) => (ang_ind1(
                                      place_diag(c, t1, n), x, y) = 
                                      ang_ind1(c, fc661(t1, x), y)))))))))))))));

seq_diag_right: (circuit2, circuit2) -> circuit2;

% seq_diag_right'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(e) = 0)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
         (((0 <= i) AND (i < width1(e)))
         => ((binary_l(x, width1(e))) => (basis_ket1(e, x, y, i) = (x[i])))))
        => (seq_diag_right(d, e) = infix_mnmn(d, e))))));

fc1104: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc1104(d,
  y)[k]) = (y[(k + range1(d))])));

% seq_diag_right'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(e) = 0)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
         (((0 <= i) AND (i < width1(e)))
         => ((binary_l(x, width1(e))) => (basis_ket1(e, x, y, i) = (x[i])))))
        => ((size1(seq_diag_right(d, e)) = (size1(d) + size1(e)))
           AND ((ancillas1(seq_diag_right(d, e)) = max(ancillas1(d), 
               ancillas1(e)))
               AND ((pre1(seq_diag_right(d, e)) = Sequence1(pre1(d), 
                   pre1(e)))
                   AND ((width1(seq_diag_right(d, e)) = width1(d))
                       AND ((range1(seq_diag_right(d, e)) = range1(d))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (i : INT):
                                ((binary_l(x, width1(seq_diag_right(d, e))))
                                => ((binary_l(y, range1(seq_diag_right(d,
                                   e))))
                                   => (((0 <= i) AND (i < width1(d))) => (
                                      basis_ket1(seq_diag_right(d, e), x, y,
                                      i) = basis_ket1(d, x, y, i)))))))
                               AND (FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)):
                                   ((binary_l(x, width1(seq_diag_right(d,
                                   e))))
                                   => ((binary_l(y, range1(seq_diag_right(d,
                                      e)))) => (ang_ind1(seq_diag_right(d,
                                      e), x, y) = ang_add(ang_ind1(d, x, y), 
                                      ang_ind1(e, tb2t7(infix_at(
                                      infix_mngt(int, int), infix_mngt(int,
                                      int), infix_at(infix_mngt(
                                      infix_mngt(int, int), infix_mngt(int,
                                      int)), infix_mngt(int, int), infix_at(
                                      infix_mngt(infix_mngt(int, int), 
                                      infix_mngt(infix_mngt(int, int), 
                                      infix_mngt(int, int))), circuit3, 
                                      t2tb68(basis_ket_closure1), t2tb67(d)), 
                                      t2tb7(x)), t2tb7(y))), fc1104(d, y)))))))))))))))));

seq_diag_left: (circuit2, circuit2) -> circuit2;

% seq_diag_left'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
         ((binary_l(x, width1(e)))
         => (((0 <= i) AND (i < width1(e))) => (basis_ket1(d, x, y,
            i) = (x[i])))))
        => (seq_diag_left(d, e) = infix_mnmn(d, e))))));

% seq_diag_left'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
         ((binary_l(x, width1(e)))
         => (((0 <= i) AND (i < width1(e))) => (basis_ket1(d, x, y,
            i) = (x[i])))))
        => ((size1(seq_diag_left(d, e)) = (size1(d) + size1(e)))
           AND ((ancillas1(seq_diag_left(d, e)) = max(ancillas1(d), 
               ancillas1(e)))
               AND ((pre1(seq_diag_left(d, e)) = Sequence1(pre1(d), pre1(e)))
                   AND ((width1(seq_diag_left(d, e)) = width1(d))
                       AND ((range1(seq_diag_left(d, e)) = range1(e))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (i : INT):
                                ((binary_l(x, width1(seq_diag_left(d, e))))
                                => (((0 <= i) AND (i < width1(d))) => (
                                   basis_ket1(seq_diag_left(d, e), x, y,
                                   i) = basis_ket1(e, x, y, i))))))
                               AND (FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)):
                                   ((binary_l(x, width1(seq_diag_left(d,
                                   e)))) => (ang_ind1(seq_diag_left(d, e), x,
                                   y) = ang_add(ang_ind1(d, x, y), 
                                   ang_ind1(e, x, y)))))))))))))));

% path_sem_diag
  ASSERT
  (FORALL (d : circuit2, x : bitvec):
  ((length(x) = width1(d))
  => ((range1(d) = 0)
     => ((FORALL (x1 : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
         ((binary_l(x1, width1(d)))
         => (((0 <= i) AND (i < width1(d))) => (basis_ket1(d, x1, y,
            i) = (x1[i])))))
        => (path_sem1(d, bv_to_ket(x)) = infix_asdtdt(ang_exp(ang_ind1(d, 
        value(x), identity2)), bv_to_ket(x)))))));

% path_sem_diag_basis
  ASSERT
  (FORALL (d : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(d)))
  => ((is_a_ket_basis_elt(x))
     => ((range1(d) = 0)
        => ((FORALL (x1 : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
            i : INT):
            ((binary_l(x1, width1(d)))
            => (((0 <= i) AND (i < width1(d))) => (basis_ket1(d, x1, y,
               i) = (x1[i])))))
           => (path_sem1(d, x) = infix_asdtdt(ang_exp(ang_ind1(d, value(
           ket_to_bv(x)), identity2)), x)))))));

% path_sem_diag_apply
  ASSERT
  (FORALL (d : circuit2, x : bitvec, a : complex):
  ((length(x) = width1(d))
  => ((range1(d) = 0)
     => ((FORALL (x1 : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT):
         ((binary_l(x1, width1(d)))
         => (((0 <= i) AND (i < width1(d))) => (basis_ket1(d, x1, y,
            i) = (x1[i])))))
        => ((FORALL (y : bitvec):
            ((length(y) = 0) => (ang_exp(ang_ind1(d, value(x), 
            value(y))) = a)))
           => (path_sem1(d, bv_to_ket(x)) = infix_asdtdt(a, bv_to_ket(x))))))));

m_skip: (INT) -> circuit2;

% m_skip'def
  ASSERT
  (FORALL (k : INT):
  ((0 < k)
  => (IF (k = 1) THEN (m_skip(k) = skip) ELSE (m_skip(k) = infix_slsl(
     m_skip((k - 1)), skip)) ENDIF)));

% m_skip'spec
  ASSERT
  (FORALL (k : INT):
  ((0 < k)
  => ((size1(m_skip(k)) = 0)
     AND ((unwire(m_skip(k)) = ids(k))
         AND ((ancillas1(m_skip(k)) = 0)
             AND ((size1(m_skip(k)) = 0)
                 AND ((range1(m_skip(k)) = 0)
                     AND ((width1(m_skip(k)) = k)
                         AND ((FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)):
                              (FORALL (i : INT): (basis_ket1(m_skip(k), x, y,
                              i) = (x[i]))))
                             AND ((FORALL (x : (ARRAY INT OF INT),
                                  y : (ARRAY INT OF INT)): (ang_ind1(
                                  m_skip(k), x, y) = infix_sldtsl(1, 0)))
                                 AND (FORALL (x : (ARRAY INT OF INT),
                                     y : (ARRAY INT OF INT)):
                                     (FORALL (k1 : INT): (ang_ind1(m_skip(k),
                                     x, y) = infix_sldtsl(0, k1))))))))))))));

% m_skip_path_sem
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((0 < k) => ((is_a_ket_l(x, k)) => (path_sem1(m_skip(k), x) = x))));

permutation_circuit_pre1: (INT, INT, (ARRAY INT OF INT)) -> circuit2;

% permutation_circuit_pre'spec
  ASSERT
  (FORALL (k : INT, n : INT, f : (ARRAY INT OF INT)):
  (((0 <= k) AND (k < n))
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
     n))))
     => ((unwire(permutation_circuit_pre1(k, n, f)) = 
        permutation_circuit_pre(k, n, f))
        AND ((width1(permutation_circuit_pre1(k, n, f)) = n)
            AND ((size1(permutation_circuit_pre1(k, n, f)) <= (n - k))
                AND ((ancillas1(permutation_circuit_pre1(k, n, f)) = 0)
                    AND ((range1(permutation_circuit_pre1(k, n, f)) = 0)
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)): (ang_ind1(
                             permutation_circuit_pre1(k, n, f), x, y) = 
                             ang_ind(permutation_circuit_pre(k, n, f), x,
                             y)))
                            AND (FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (i : INT):
                                (((0 <= i) AND (i < n)) => (basis_ket1(
                                permutation_circuit_pre1(k, n, f), x, y,
                                i) = basis_ket(permutation_circuit_pre(k, n,
                                f), x, y, i))))))))))))));

permutation_circuit1: (INT, (ARRAY INT OF INT)) -> circuit2;

% permutation_circuit'def
  ASSERT
  (FORALL (n : INT, f : (ARRAY INT OF INT)):
  ((0 < n)
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
     n)))) => (permutation_circuit1(n, f) = permutation_circuit_pre1(0, n,
     f)))));

fc1105: ((ARRAY INT OF INT), bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : bitvec, i : INT): ((fc1105(f,
  x)[i]) = (value(x)[(f[i])])));

% permutation_circuit'spec
  ASSERT
  (FORALL (n : INT, f : (ARRAY INT OF INT)):
  ((0 < n)
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, n)), t2tb6(to_fset(0,
     n))))
     => ((unwire(permutation_circuit1(n, f)) = permutation_circuit(n, f))
        AND ((width1(permutation_circuit1(n, f)) = n)
            AND ((size1(permutation_circuit1(n, f)) <= n)
                AND ((ancillas1(permutation_circuit1(n, f)) = 0)
                    AND ((range1(permutation_circuit1(n, f)) = 0)
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)): (ang_ind1(
                             permutation_circuit1(n, f), x, y) = ang_zero))
                            AND ((FORALL (x : (ARRAY INT OF INT),
                                 y : (ARRAY INT OF INT)):
                                 (FORALL (i : INT):
                                 (((0 <= i) AND (i < n)) => (basis_ket1(
                                 permutation_circuit1(n, f), x, y,
                                 i) = (x[(f[i])])))))
                                AND (FORALL (x : bitvec):
                                    ((length(x) = n) => (path_sem1(
                                    permutation_circuit1(n, f), 
                                    bv_to_ket(x)) = bv_to_ket(make_bv(
                                    fc1105(f, x), n)))))))))))))));

gen_phase: (INT, INT) -> circuit2;

% gen_phase'def
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 < n) => ((0 <= k) => (gen_phase(k, n) = place1(phase1(k), 0, n)))));

% gen_phase'spec
  ASSERT
  (FORALL (k : INT, n : INT):
  ((0 < n)
  => ((0 <= k)
     => ((size1(gen_phase(k, n)) = 1)
        AND ((range1(gen_phase(k, n)) = 0)
            AND ((width1(gen_phase(k, n)) = n)
                AND ((FORALL (x : (ARRAY INT OF INT),
                     y : (ARRAY INT OF INT)):
                     (FORALL (i : INT): (basis_ket1(gen_phase(k, n), x, y,
                     i) = (x[i]))))
                    AND (FORALL (x : (ARRAY INT OF INT),
                        y : (ARRAY INT OF INT)): (ang_ind1(gen_phase(k, n),
                        x, y) = infix_sldtsl(1, k))))))))));

crz: (INT, INT, INT, INT) -> circuit2;

% crz'def
  ASSERT
  (FORALL (c : INT, t1 : INT, k : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1)) => (crz(c, t1, k, n) = cont1(rzp(k), c, t1, n))))));

% crz'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, k : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1))
        => ((width1(crz(c, t1, k, n)) = n)
           AND ((size1(crz(c, t1, k, n)) = cont_size1)
               AND ((range1(crz(c, t1, k, n)) = 0)
                   AND ((ancillas1(crz(c, t1, k, n)) = 0)
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT), i : INT): (basis_ket1(
                            crz(c, t1, k, n), x, y, i) = (x[i])))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)): (ang_ind1(crz(c, t1,
                                k, n), x, y) = 
                                infix_sldtsl(((x[c]) * (x[t1])), k)))
                               AND (FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT), kqt : INT):
                                   (((0 <= k) AND (k <= kqt)) => (ang_ind1(
                                   crz(c, t1, k, n), x, y) = 
                                   infix_sldtsl((((x[c]) * (x[t1])) * 
                                   power(2, (kqt - k))), kqt))))))))))))));

prz: (INT, INT, INT) -> circuit2;

% prz'def
  ASSERT
  (FORALL (k : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n)) => (prz(k, t1, n) = place1(rzp(k), t1, n))));

% prz'spec
  ASSERT
  (FORALL (k : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => ((width1(prz(k, t1, n)) = n)
     AND ((size1(prz(k, t1, n)) = 1)
         AND ((range1(prz(k, t1, n)) = 0)
             AND ((ancillas1(prz(k, t1, n)) = 0)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT), i : INT): (basis_ket1(prz(k,
                      t1, n), x, y, i) = (x[i])))
                     AND (FORALL (x : (ARRAY INT OF INT),
                         y : (ARRAY INT OF INT)):
                         (((0 <= k) AND (k <= n)) => (ang_ind1(prz(k, t1, n),
                         x, y) = infix_sldtsl(((x[t1]) * power(2, (n - k))),
                         n)))))))))));

crzn: (INT, INT, INT, INT) -> circuit2;

% crzn'def
  ASSERT
  (FORALL (c : INT, t1 : INT, k : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1))
        => ((k <= 0) => (crzn(c, t1, k, n) = cont1(rzp(k), c, t1, n)))))));

% crzn'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, k : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1))
        => ((k <= 0)
           => ((width1(crzn(c, t1, k, n)) = n)
              AND ((size1(crzn(c, t1, k, n)) = cont_size1)
                  AND ((range1(crzn(c, t1, k, n)) = 0)
                      AND ((FORALL (x : (ARRAY INT OF INT),
                           y : (ARRAY INT OF INT), i : INT): (basis_ket1(
                           crzn(c, t1, k, n), x, y, i) = (x[i])))
                          AND ((ancillas1(crzn(c, t1, k, n)) = 0)
                              AND (FORALL (x : (ARRAY INT OF INT),
                                  y : (ARRAY INT OF INT), kqt : INT):
                                  (((- k) <= kqt) => (ang_ind1(crzn(c, t1, k,
                                  n), x, y) = 
                                  infix_sldtsl((- (((x[c]) * (x[t1])) * 
                                  power(2, (kqt + k)))), kqt))))))))))))));

crzn_up: (INT, INT, INT, INT, INT) -> circuit2;

% crzn_up'def
  ASSERT
  (FORALL (c : INT, t1 : INT, k : INT, n : INT, den : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1))
        => ((k <= 0)
           => (((- k) <= den) => (crzn_up(c, t1, k, n, den) = cont1(rzp(k),
              c, t1, n))))))));

% crzn_up'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, k : INT, n : INT, den : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1))
        => ((k <= 0)
           => (((- k) <= den)
              => ((width1(crzn_up(c, t1, k, n, den)) = n)
                 AND ((size1(crzn_up(c, t1, k, n, den)) = cont_size1)
                     AND ((range1(crzn_up(c, t1, k, n, den)) = 0)
                         AND ((FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT), i : INT): (basis_ket1(
                              crzn_up(c, t1, k, n, den), x, y, i) = (x[i])))
                             AND ((ancillas1(crzn_up(c, t1, k, n, den)) = 0)
                                 AND (FORALL (x : (ARRAY INT OF INT),
                                     y : (ARRAY INT OF INT)): (ang_ind1(
                                     crzn_up(c, t1, k, n, den), x, y) = 
                                     infix_sldtsl((- (((x[c]) * (x[t1])) * 
                                     power(2, (den + k)))), den))))))))))))));

% bv_to_int_zero
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((0 < n)
  => ((length(x) = n)
     => ((FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 0)))
        => (bv_to_int(x) = 0)))));

% bv_to_int_all_one
  ASSERT
  (FORALL (x : bitvec, n : INT):
  ((0 < n)
  => ((length(x) = n)
     => ((FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 1)))
        => (bv_to_int(x) = (power(2, n) - 1))))));

% bv_to_int_zero_gen
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     ((length(x) = n)
     => ((FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 0)))
        => (bv_to_int(x) = 0))))));

% bv_to_int_zero_gen_rev
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     ((length(x) = n)
     => ((bv_to_int(x) = 0)
        => (FORALL (i : INT):
           (((0 <= i) AND (i < n)) => ((value(x)[i]) = 0))))))));

% bv_to_int_all_one_gen
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     ((length(x) = n)
     => ((FORALL (i : INT): (((0 <= i) AND (i < n)) => ((value(x)[i]) = 1)))
        => (bv_to_int(x) = (power(2, n) - 1)))))));

% bv_to_int_all_one_gen_rev
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     ((length(x) = n)
     => ((bv_to_int(x) = (power(2, n) - 1))
        => (FORALL (i : INT):
           (((0 <= i) AND (i < n)) => ((value(x)[i]) = 1))))))));

bin_check_zero: ((ARRAY INT OF INT), INT) -> angle;

result144: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), i : INT): ((
  result144(x)[i]) = (x[(i + 1)])));

% bin_check_zero'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), n : INT):
  ((0 <= n)
  => ((binary_l(x, n))
     => (IF (n = 0) THEN (bin_check_zero(x, n) = infix_sldtsl(1, 1))
        ELSE (IF (n = 1)
             THEN (IF ((x[0]) = 1) THEN (bin_check_zero(x, n) = 
                  infix_sldtsl(1, 1)) ELSE (bin_check_zero(x,
                  n) = ang_zero) ENDIF)
             ELSE (IF ((x[0]) = 1) THEN (bin_check_zero(x, n) = 
                  bin_check_zero(result144(x), (n - 1))) ELSE (
                  bin_check_zero(x, n) = ang_zero) ENDIF) ENDIF) ENDIF))));

% bin_check_zero'spec
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), n : INT):
  ((0 <= n)
  => ((binary_l(x, n)) => (bin_check_zero(x,
     n) = (IF (FORALL (j : INT): (((0 <= j) AND (j < n)) => ((x[j]) = 1)))
          THEN infix_sldtsl(1, 1) ELSE ang_zero ENDIF)))));

% bin_check_zero_int
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (bin_check_zero(int_to_bin(i, n),
     n) = (IF (i = (power(2, n) - 1)) THEN infix_sldtsl(1, 1)
          ELSE ang_zero ENDIF)))));

fc664: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), i : INT): ((fc664(x)[i]) = (x[(i + 1)])));

% bin_check_zero_plus_one
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), n : INT):
  ((binary_l(x, n))
  => ((1 < n) => (bin_check_zero(x,
     n) = (IF ((x[0]) = 1) THEN bin_check_zero(fc664(x), (n - 1))
          ELSE ang_zero ENDIF)))));

% bin_check_zero_two
  ASSERT
  (FORALL (x : (ARRAY INT OF INT)):
  ((binary_l(x, 2)) => (bin_check_zero(x,
  2) = (IF (((x[0]) = (x[1])) AND ((x[1]) = 1)) THEN infix_sldtsl(1, 1)
       ELSE ang_zero ENDIF))));

c_rzp_one: (INT, INT, INT) -> circuit2;

% c_rzp_one'def
  ASSERT
  (FORALL (c : INT, t1 : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1)) => (c_rzp_one(c, t1, n) = crz(c, t1, 1, n))))));

% c_rzp_one'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (c = t1))
        => ((width1(c_rzp_one(c, t1, n)) = n)
           AND ((size1(c_rzp_one(c, t1, n)) = cont_size1)
               AND ((range1(c_rzp_one(c, t1, n)) = 0)
                   AND ((FORALL (x : (ARRAY INT OF INT),
                        y : (ARRAY INT OF INT), i : INT): (basis_ket1(
                        c_rzp_one(c, t1, n), x, y, i) = (x[i])))
                       AND ((ancillas1(c_rzp_one(c, t1, n)) = 0)
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)): (ang_ind1(
                                c_rzp_one(c, t1, n), x, y) = 
                                infix_sldtsl(((x[c]) * (x[t1])), 1)))
                               AND (FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)):
                                   ((n = 2)
                                   => ((binary_l(x, 2)) => (ang_ind1(
                                      c_rzp_one(c, t1, n), x, y) = 
                                      bin_check_zero(x, 2)))))))))))))));

repeat_had: (INT) -> circuit2;

% repeat_had'def
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => (IF (n = 1) THEN (repeat_had(n) = hadamard1) ELSE (repeat_had(n) = 
     infix_slsl(repeat_had((n - 1)), hadamard1)) ENDIF)));

fc665: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), i : INT): ((
  fc665(x, y)[i]) = 
  int_to_ang((IF (((x[i]) = (y[i])) AND ((y[i]) = 1)) THEN 1 ELSE 0 ENDIF),
  1)));

% repeat_had'spec
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => ((width1(repeat_had(n)) = n)
     AND ((range1(repeat_had(n)) = n)
         AND ((size1(repeat_had(n)) = n)
             AND ((ancillas1(repeat_had(n)) = 0)
                 AND ((circ_to_pps1(repeat_had(n)) = repeat_pps_had(n))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)):
                          (FORALL (i : INT):
                          (((0 <= i) AND (i < n)) => (basis_ket1(
                          repeat_had(n), x, y, i) = (y[i])))))
                         AND (FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)):
                             ((binary_l(x, n))
                             => ((binary_l(y, n)) => (ang_ind1(repeat_had(n),
                                x, y) = ang_sum(fc665(x, y), 0, n)))))))))))));

fc1106: (bitvec, bitvec) -> (ARRAY INT OF INT);

fc1107: (INT, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (x : bitvec, y : bitvec, k : INT): ((fc1106(x, y)[k]) = ((
  value(x)[k]) * (value(y)[k]))));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1107(n, x)), t2tb26(y))) = 
  infix_asdtdt(cpower(prefix_mndt(c_one), ind_isum(fc1106(x, y), 0, n)), 
  bv_to_ket(y))));

% repeat_had_basis_bv
  ASSERT
  (FORALL (n : INT, x : bitvec):
  ((1 <= n)
  => ((length(x) = n) => (path_sem1(repeat_had(n), bv_to_ket(x)) = 
     infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(n_bvs(n)), 
     t2tb29(fc1107(n, x)), n))))));

fc1108: (INT, INT, bitvec) -> (ARRAY INT OF INT);

fc1109: (INT, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, i : INT, y : bitvec, k : INT): ((fc1108(n, i, y)[k]) = ((
  value(int_to_bv(i, n))[k]) * (value(y)[k]))));

% fc'def
  ASSERT
  (FORALL (n : INT, i : INT, y : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(fc1109(n, i)), t2tb26(y))) = infix_asdtdt(cpower(
  prefix_mndt(c_one), ind_isum(fc1108(n, i, y), 0, n)), bv_to_ket(y))));

% repeat_had_basis
  ASSERT
  (FORALL (n : INT, i : INT):
  ((1 <= n)
  => (((0 <= i) AND (i < power(2, n))) => (path_sem1(repeat_had(n), ket(n,
     i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(
     n_bvs(n)), t2tb29(fc1109(n, i)), n))))));

% path_sem_repeat_had_superposition
  ASSERT
  (FORALL (n : INT):
  ((1 <= n) => (path_sem1(repeat_had(n), superposition_state(n)) = ket(n,
  0))));

% path_sem_repeat_had_invol
  ASSERT
  (FORALL (n : INT, x : matrix_complex):
  ((is_a_ket_l(x, n))
  => ((1 <= n) => (path_sem1(repeat_had(n), path_sem1(repeat_had(n),
     x)) = x))));

% path_sem_repeat_had_to_superposition
  ASSERT
  (FORALL (n : INT):
  ((1 <= n) => (path_sem1(repeat_had(n), ket(n, 0)) = 
  superposition_state(n))));

seq_flat_mute: (circuit2, circuit2) -> circuit2;

% seq_flat_mute'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((range1(e) = 0)
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
            ((binary_l(x, width1(d))) => (ang_ind1(d, x, y) = infix_sldtsl(1,
            0))))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((binary_l(x, width1(e))) => (ang_ind1(e, x, y) = 
               infix_sldtsl(1, 0))))
              => (seq_flat_mute(d, e) = infix_mnmn(d, e))))))));

% seq_flat_mute'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((range1(e) = 0)
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
            ((binary_l(x, width1(d))) => (ang_ind1(d, x, y) = infix_sldtsl(1,
            0))))
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((binary_l(x, width1(e))) => (ang_ind1(e, x, y) = 
               infix_sldtsl(1, 0))))
              => ((size1(seq_flat_mute(d, e)) = (size1(d) + size1(e)))
                 AND ((ancillas1(seq_flat_mute(d, e)) = max(ancillas1(d), 
                     ancillas1(e)))
                     AND ((pre1(seq_flat_mute(d, e)) = Sequence1(pre1(d), 
                         pre1(e)))
                         AND ((width1(seq_flat_mute(d, e)) = width1(d))
                             AND ((FORALL (x : (ARRAY INT OF INT),
                                  y : (ARRAY INT OF INT)):
                                  (FORALL (i : INT):
                                  ((binary_l(x, width1(d)))
                                  => (((0 <= i) AND (i < width1(d))) => (
                                     basis_ket1(seq_flat_mute(d, e), x, y,
                                     i) = basis_ket1(e, tb2t7(infix_at(
                                     infix_mngt(int, int), infix_mngt(int,
                                     int), infix_at(infix_mngt(
                                     infix_mngt(int, int), infix_mngt(int,
                                     int)), infix_mngt(int, int), infix_at(
                                     infix_mngt(infix_mngt(int, int), 
                                     infix_mngt(infix_mngt(int, int), 
                                     infix_mngt(int, int))), circuit3, 
                                     t2tb68(basis_ket_closure1), t2tb67(d)), 
                                     t2tb7(x)), t2tb7(y))), y, i))))))
                                 AND ((width1(seq_flat_mute(d, e)) = 
                                     width1(d))
                                     AND ((range1(seq_flat_mute(d, e)) = 0)
                                         AND (FORALL (x : (ARRAY INT OF INT),
                                             y : (ARRAY INT OF INT)):
                                             ((binary_l(x, width1(d))) => (
                                             ang_ind1(seq_flat_mute(d, e), x,
                                             y) = infix_sldtsl(1, 0)))))))))))))))));

cont_flat_mute: (circuit2, INT, INT, INT) -> circuit2;

% cont_flat_mute'def
  ASSERT
  (FORALL (c : circuit2, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - width1(c))))
     => (((t1 <= co) => ((t1 + width1(c)) <= co))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
            ((binary_l(x, width1(c))) => (ang_ind1(c, x, y) = infix_sldtsl(1,
            0))))
           => ((range1(c) = 0) => (cont_flat_mute(c, co, t1, n) = cont1(c,
              co, t1, n))))))));

fc1110: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc1110(t1,
  x)[j]) = (x[(j + t1)])));

% cont_flat_mute'spec
  ASSERT
  (FORALL (c : circuit2, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - width1(c))))
     => (((t1 <= co) => ((t1 + width1(c)) <= co))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
            ((binary_l(x, width1(c))) => (ang_ind1(c, x, y) = infix_sldtsl(1,
            0))))
           => ((range1(c) = 0)
              => ((size1(cont_flat_mute(c, co, t1, n)) <= (cont_size1 * 
                 size1(c)))
                 AND ((ancillas1(cont_flat_mute(c, co, t1, n)) = 
                     ancillas1(c))
                     AND ((pre1(cont_flat_mute(c, co, t1, n)) = Cont(pre1(c),
                         co, t1, n))
                         AND ((width1(cont_flat_mute(c, co, t1, n)) = n)
                             AND ((range1(cont_flat_mute(c, co, t1, n)) = 0)
                                 AND ((FORALL (x : (ARRAY INT OF INT),
                                      y : (ARRAY INT OF INT)):
                                      (FORALL (i : INT):
                                      ((binary_l(x, n))
                                      => (((0 <= i) AND (i < n)) => (
                                         basis_ket1(cont_flat_mute(c, co, t1,
                                         n), x, y,
                                         i) = (IF (((x[co]) = 1)
                                                  AND ((t1 <= i)
                                                      AND (i < (t1 + 
                                                      width1(c)))))
                                              THEN basis_ket1(c, fc1110(t1,
                                              x), y, (i - t1))
                                              ELSE (x[i]) ENDIF))))))
                                     AND (FORALL (x : (ARRAY INT OF INT),
                                         y : (ARRAY INT OF INT)):
                                         ((binary_l(x, n)) => (ang_ind1(
                                         cont_flat_mute(c, co, t1, n), x,
                                         y) = infix_sldtsl(1, 0))))))))))))))));

cont_flat_mute_lemma: (circuit2, INT, INT, INT) -> tuple0;

% cont_flat_mute_lemma'def
  ASSERT
  (FORALL (c : circuit2, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - width1(c))))
     => (((t1 <= co) => ((t1 + width1(c)) <= co))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
            ((binary_l(x, width1(c))) => (ang_ind1(c, x, y) = infix_sldtsl(1,
            0))))
           => ((range1(c) = 0) => (cont_flat_mute_lemma(c, co, t1,
              n) = Tuple0)))))));

fc671: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc671(t1,
  x)[j]) = (x[(j + t1)])));

% cont_flat_mute_lemma'spec
  ASSERT
  (FORALL (c : circuit2, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - width1(c))))
     => (((t1 <= co) => ((t1 + width1(c)) <= co))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
            ((binary_l(x, width1(c))) => (ang_ind1(c, x, y) = infix_sldtsl(1,
            0))))
           => ((range1(c) = 0)
              => ((range1(cont1(c, co, t1, n)) = 0)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT)):
                      (FORALL (i : INT):
                      ((binary_l(x, n))
                      => (((0 <= i) AND (i < n)) => (basis_ket1(cont1(c, co,
                         t1, n), x, y,
                         i) = (IF (((x[co]) = 1)
                                  AND ((t1 <= i) AND (i < (t1 + width1(c)))))
                              THEN basis_ket1(c, fc671(t1, x), y, (i - t1))
                              ELSE (x[i]) ENDIF))))))
                     AND (FORALL (x : (ARRAY INT OF INT),
                         y : (ARRAY INT OF INT)):
                         ((binary_l(x, n)) => (ang_ind1(cont1(c, co, t1, n),
                         x, y) = infix_sldtsl(1, 0))))))))))));

seq_flat_mute_right: (circuit2, circuit2) -> circuit2;

% seq_flat_mute_right'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(e) = 0)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         ((binary_l(x, width1(e))) => (ang_ind1(e, x, y) = infix_sldtsl(1,
         0))))
        => (seq_flat_mute_right(d, e) = infix_mnmn(d, e))))));

fc672: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc672(d,
  y)[k]) = (y[(k + range1(d))])));

% seq_flat_mute_right'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(e) = 0)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         ((binary_l(x, width1(e))) => (ang_ind1(e, x, y) = infix_sldtsl(1,
         0))))
        => ((size1(seq_flat_mute_right(d, e)) = (size1(d) + size1(e)))
           AND ((ancillas1(seq_flat_mute_right(d, e)) = max(ancillas1(d), 
               ancillas1(e)))
               AND ((width1(seq_flat_mute_right(d, e)) = width1(d))
                   AND ((pre1(seq_flat_mute_right(d, e)) = Sequence1(pre1(d), 
                       pre1(e)))
                       AND ((range1(seq_flat_mute_right(d, e)) = range1(d))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (i : INT):
                                ((binary_l(x, width1(d)))
                                => ((binary_l(y, range1(d)))
                                   => (((0 <= i) AND (i < width1(d))) => (
                                      basis_ket1(seq_flat_mute_right(d, e),
                                      x, y, i) = basis_ket1(e, tb2t7(
                                      infix_at(infix_mngt(int, int), 
                                      infix_mngt(int, int), infix_at(
                                      infix_mngt(infix_mngt(int, int), 
                                      infix_mngt(int, int)), infix_mngt(int,
                                      int), infix_at(infix_mngt(
                                      infix_mngt(int, int), infix_mngt(
                                      infix_mngt(int, int), infix_mngt(int,
                                      int))), circuit3, 
                                      t2tb68(basis_ket_closure1), t2tb67(d)), 
                                      t2tb7(x)), t2tb7(y))), fc672(d, y),
                                      i)))))))
                               AND (FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)):
                                   ((binary_l(x, width1(d)))
                                   => ((binary_l(y, range1(d))) => (ang_ind1(
                                      seq_flat_mute_right(d, e), x, y) = 
                                      ang_ind1(d, x, y)))))))))))))));

seq_flat_mute_left: (circuit2, circuit2) -> circuit2;

% seq_flat_mute_left'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         ((binary_l(x, width1(d))) => (ang_ind1(d, x, y) = infix_sldtsl(1,
         0))))
        => (seq_flat_mute_left(d, e) = infix_mnmn(d, e))))));

% seq_flat_mute_left'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         ((binary_l(x, width1(d))) => (ang_ind1(d, x, y) = infix_sldtsl(1,
         0))))
        => ((size1(seq_flat_mute_left(d, e)) = (size1(d) + size1(e)))
           AND ((ancillas1(seq_flat_mute_left(d, e)) = max(ancillas1(d), 
               ancillas1(e)))
               AND ((pre1(seq_flat_mute_left(d, e)) = Sequence1(pre1(d), 
                   pre1(e)))
                   AND ((width1(seq_flat_mute_left(d, e)) = width1(d))
                       AND ((range1(seq_flat_mute_left(d, e)) = range1(e))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (i : INT):
                                ((binary_l(x, width1(d)))
                                => ((binary_l(y, range1(e)))
                                   => (((0 <= i) AND (i < width1(d))) => (
                                      basis_ket1(seq_flat_mute_left(d, e), x,
                                      y, i) = basis_ket1(e, tb2t7(infix_at(
                                      infix_mngt(int, int), infix_mngt(int,
                                      int), infix_at(infix_mngt(
                                      infix_mngt(int, int), infix_mngt(int,
                                      int)), infix_mngt(int, int), infix_at(
                                      infix_mngt(infix_mngt(int, int), 
                                      infix_mngt(infix_mngt(int, int), 
                                      infix_mngt(int, int))), circuit3, 
                                      t2tb68(basis_ket_closure1), t2tb67(d)), 
                                      t2tb7(x)), t2tb7(y))), y, i)))))))
                               AND (FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)):
                                   ((binary_l(x, width1(d)))
                                   => ((binary_l(y, range1(e))) => (ang_ind1(
                                      seq_flat_mute_left(d, e), x, y) = 
                                      ang_ind1(e, tb2t7(infix_at(
                                      infix_mngt(int, int), infix_mngt(int,
                                      int), infix_at(infix_mngt(
                                      infix_mngt(int, int), infix_mngt(int,
                                      int)), infix_mngt(int, int), infix_at(
                                      infix_mngt(infix_mngt(int, int), 
                                      infix_mngt(infix_mngt(int, int), 
                                      infix_mngt(int, int))), circuit3, 
                                      t2tb68(basis_ket_closure1), t2tb67(d)), 
                                      t2tb7(x)), t2tb7(y))), y)))))))))))))));

% path_sem_flat_mute
  ASSERT
  (FORALL (d : circuit2, x : bitvec):
  ((length(x) = width1(d))
  => ((range1(d) = 0)
     => ((FORALL (x1 : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         ((binary_l(x1, width1(d))) => (ang_ind1(d, x1, y) = infix_sldtsl(1,
         0))))
        => (path_sem1(d, bv_to_ket(x)) = bv_to_ket(make_bv(tb2t7(infix_at(
        infix_mngt(int, int), infix_mngt(int, int), infix_at(infix_mngt(
        infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int, int), 
        infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int,
        int), infix_mngt(int, int))), circuit3, t2tb68(basis_ket_closure1), 
        t2tb67(d)), t2tb7(value(x))), t2tb7(identity2))), width1(d))))))));

% path_sem_flat_mute_gen
  ASSERT
  (FORALL (d : circuit2):
  ((range1(d) = 0)
  => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
      ((binary_l(x, width1(d))) => (ang_ind1(d, x, y) = infix_sldtsl(1, 0))))
     => (FORALL (x : bitvec):
        ((length(x) = width1(d)) => (path_sem1(d, bv_to_ket(x)) = bv_to_ket(
        make_bv(tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
        infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
        infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
        infix_mngt(infix_mngt(int, int), infix_mngt(int, int))), circuit3, 
        t2tb68(basis_ket_closure1), t2tb67(d)), t2tb7(value(x))), 
        t2tb7(identity2))), width1(d)))))))));

% path_sem_flat_mute_ket
  ASSERT
  (FORALL (d : circuit2):
  ((range1(d) = 0)
  => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
      ((binary_l(x, width1(d))) => (ang_ind1(d, x, y) = infix_sldtsl(1, 0))))
     => (FORALL (x : matrix_complex):
        ((is_a_ket_l(x, width1(d)))
        => ((is_a_ket_basis_elt(x)) => (path_sem1(d, x) = bv_to_ket(make_bv(
           tb2t7(infix_at(infix_mngt(int, int), infix_mngt(int, int), 
           infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), 
           infix_mngt(int, int), infix_at(infix_mngt(infix_mngt(int, int), 
           infix_mngt(infix_mngt(int, int), infix_mngt(int, int))), circuit3, 
           t2tb68(basis_ket_closure1), t2tb67(d)), t2tb7(value(
           ket_to_bv(x)))), t2tb7(identity2))), width1(d))))))))));

% path_sem_flat_mute_bv
  ASSERT
  (FORALL (d : circuit2, x : bitvec, y : bitvec):
  ((length(x) = width1(d))
  => ((length(y) = width1(d))
     => ((range1(d) = 0)
        => ((FORALL (i : INT):
            (((0 <= i) AND (i < width1(d))) => (basis_ket1(d, value(x),
            identity2, i) = (value(y)[i]))))
           => ((FORALL (x1 : (ARRAY INT OF INT), y1 : (ARRAY INT OF INT)):
               ((binary_l(x1, width1(d))) => (ang_ind1(d, x1, y1) = 
               infix_sldtsl(1, 0))))
              => (path_sem1(d, bv_to_ket(x)) = bv_to_ket(y))))))));

fc1111: (INT, matrix_complex) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, ket1 : matrix_complex, i : INT): ((fc1111(k,
  ket1)[i]) = (IF (i = k) THEN (1 - (value(ket_to_bv(ket1))[i])) ELSE (value(
              ket_to_bv(ket1))[i]) ENDIF)));

% sem_ind_cnot
  ASSERT
  (FORALL (c : INT, k : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= k) AND (k < n))
     => ((NOT (k = c))
        => ((FORALL (ket1 : matrix_complex):
            ((is_a_ket_l(ket1, n))
            => ((is_a_ket_basis_elt(ket1))
               => (((value(ket_to_bv(ket1))[c]) = 0) => (path_sem1(cnot1(c,
                  k, n), ket1) = ket1)))))
           AND (FORALL (ket1 : matrix_complex):
               ((is_a_ket_l(ket1, n))
               => ((is_a_ket_basis_elt(ket1))
                  => (((value(ket_to_bv(ket1))[c]) = 1) => (path_sem1(
                     cnot1(c, k, n), ket1) = bv_to_ket(make_bv(fc1111(k,
                     ket1), n))))))))))));

% sem_ind_cnot_zero
  ASSERT
  (FORALL (n : INT):
  ((1 < n)
  => ((FORALL (ket1 : matrix_complex):
      (FORALL (i : INT):
      ((is_a_ket_l(ket1, (n - 1)))
      => ((is_a_ket_basis_elt(ket1))
         => (((0 <= i) AND (i < 2))
            => (((value(ket_to_bv(ket1))[0]) = 1) => (path_sem1(cnot1(0,
               (n - 1), n), kronecker(ket1, ket(1, i))) = kronecker(ket1, 
               ket(1, (1 - i))))))))))
     AND (FORALL (ket1 : matrix_complex):
         (FORALL (i : INT):
         ((is_a_ket_l(ket1, (n - 1)))
         => ((is_a_ket_basis_elt(ket1))
            => (((0 <= i) AND (i < 2))
               => (((value(ket_to_bv(ket1))[0]) = 0) => (path_sem1(cnot1(0,
                  (n - 1), n), kronecker(ket1, ket(1, i))) = kronecker(ket1, 
                  ket(1, i))))))))))));

ind_neg_cnot: (INT, INT, INT) -> circuit2;

fc1112: (INT, INT, bitvec) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (c : INT, k : INT, x : bitvec, i : INT): ((fc1112(c, k,
  x)[i]) = (IF (i = k)
           THEN (IF ((value(x)[c]) = 0) THEN (1 - (value(x)[i])) ELSE (
                value(x)[i]) ENDIF)
           ELSE (value(x)[i]) ENDIF)));

% ind_neg_cnot'spec
  ASSERT
  (FORALL (c : INT, k : INT, n : INT):
  (((0 <= c) AND (c < n))
  => (((0 <= k) AND (k < n))
     => ((NOT (k = c))
        => ((range1(ind_neg_cnot(c, k, n)) = 0)
           AND ((ancillas1(ind_neg_cnot(c, k, n)) = 0)
               AND ((size1(ind_neg_cnot(c, k, n)) = 3)
                   AND ((FORALL (x : (ARRAY INT OF INT),
                        y : (ARRAY INT OF INT), i : INT):
                        ((binary_l(x, n))
                        => (((0 <= i) AND (i < n)) => (basis_ket1(
                           ind_neg_cnot(c, k, n), x, y,
                           i) = (IF (i = k)
                                THEN (IF ((x[c]) = 0) THEN (1 - (x[i]))
                                     ELSE (x[i]) ENDIF)
                                ELSE (x[i]) ENDIF)))))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)):
                            ((binary_l(x, n)) => (ang_ind1(ind_neg_cnot(c, k,
                            n), x, y) = ang_zero)))
                           AND ((FORALL (x : bitvec):
                                ((length(x) = n) => (path_sem1(
                                ind_neg_cnot(c, k, n), bv_to_ket(x)) = 
                                bv_to_ket(make_bv(fc1112(c, k, x), n)))))
                               AND (width1(ind_neg_cnot(c, k, n)) = n)))))))))));

fc1113: (INT, matrix_complex) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (n : INT, ket1 : matrix_complex, i : INT): ((fc1113(n,
  ket1)[i]) = (IF (i = n) THEN (1 - (value(ket_to_bv(ket1))[i])) ELSE (value(
              ket_to_bv(ket1))[i]) ENDIF)));

% sem_ind_neg_cnot_zero
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => ((FORALL (i : INT):
      (((0 <= i) AND (i < power(2, (n - 1)))) => (path_sem1(ind_neg_cnot(0,
      n, (n + 1)), kronecker(ket(n, i), ket(1, 1))) = kronecker(ket(n, i), 
      ket(1, 0)))))
     AND ((FORALL (i : INT):
          (((power(2, (n - 1)) <= i) AND (i < power(2, n))) => (path_sem1(
          ind_neg_cnot(0, n, (n + 1)), kronecker(ket(n, i), ket(1, 0))) = 
          kronecker(ket(n, i), ket(1, 0)))))
         AND ((FORALL (ket1 : matrix_complex):
              ((is_a_ket_l(ket1, (n + 1)))
              => ((is_a_ket_basis_elt(ket1))
                 => (((value(ket_to_bv(ket1))[0]) = 1) => (path_sem1(
                    ind_neg_cnot(0, n, (n + 1)), ket1) = ket1)))))
             AND (FORALL (ket1 : matrix_complex):
                 ((is_a_ket_l(ket1, (n + 1)))
                 => ((is_a_ket_basis_elt(ket1))
                    => (((value(ket_to_bv(ket1))[0]) = 0) => (path_sem1(
                       ind_neg_cnot(0, n, (n + 1)), ket1) = bv_to_ket(
                       make_bv(fc1113(n, ket1), (n + 1)))))))))))));

repeat_xx: (INT) -> circuit2;

% repeat_xx'def
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => (IF (n = 1) THEN (repeat_xx(n) = xx1) ELSE (repeat_xx(n) = infix_slsl(
     repeat_xx((n - 1)), xx1)) ENDIF)));

% repeat_xx'spec
  ASSERT
  (FORALL (n : INT):
  ((1 <= n)
  => ((width1(repeat_xx(n)) = n)
     AND ((range1(repeat_xx(n)) = 0)
         AND ((size1(repeat_xx(n)) = n)
             AND ((ancillas1(repeat_xx(n)) = 0)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT)):
                      (FORALL (i : INT):
                      (((0 <= i) AND (i < n)) => (basis_ket1(repeat_xx(n), x,
                      y, i) = (1 - (x[i]))))))
                     AND (FORALL (x : (ARRAY INT OF INT),
                         y : (ARRAY INT OF INT)): (ang_ind1(repeat_xx(n), x,
                         y) = ang_zero)))))))));

with_permutation1: (circuit2, (ARRAY INT OF INT)) -> circuit2;

fc676: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc677: ((ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc678: (circuit2, (ARRAY INT OF INT),
  (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : (ARRAY INT OF INT), i : INT): ((
  fc676(f, x)[i]) = (x[(f[i])])));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), x : (ARRAY INT OF INT), i : INT): ((
  fc677(f, x)[i]) = (x[(f[i])])));

% fc'def
  ASSERT
  (FORALL (c : circuit2, f : (ARRAY INT OF INT), x : (ARRAY INT OF INT),
  i : INT): ((fc678(c, f, x)[i]) = (x[(c_inv_func_int(f, width1(c))[i])])));

% with_permutation'spec
  ASSERT
  (FORALL (c : circuit2, f : (ARRAY INT OF INT)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, width1(c))), t2tb6(
  to_fset(0, width1(c)))))
  => ((unwire(with_permutation1(c, f)) = with_permutation(unwire(c), f))
     AND ((size1(with_permutation1(c, f)) <= ((2 * width1(c)) + size1(c)))
         AND ((ancillas1(with_permutation1(c, f)) = ancillas1(c))
             AND ((width1(with_permutation1(c, f)) = width1(c))
                 AND ((range1(with_permutation1(c, f)) = range1(c))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)): (ang_ind1(
                          with_permutation1(c, f), x, y) = ang_ind1(c, 
                          fc676(f, x), y)))
                         AND ((FORALL (x : (ARRAY INT OF INT),
                              y : (ARRAY INT OF INT)):
                              (FORALL (i : INT):
                              (((0 <= i) AND (i < width1(c))) => (basis_ket1(
                              with_permutation1(c, f), x, y, i) = 
                              basis_ket1(c, fc677(f, x), y, (
                              c_inv_func_int(f, width1(c))[i]))))))
                             AND ((FORALL (x : (ARRAY INT OF INT),
                                  y : (ARRAY INT OF INT)):
                                  (FORALL (i : INT):
                                  (((0 <= i) AND (i < width1(c))) => (
                                  basis_ket1(with_permutation1(c, f), 
                                  fc678(c, f, x), y, i) = basis_ket1(c, x, y,
                                  (c_inv_func_int(f, width1(c))[i]))))))
                                 AND (with_permutation1(c, f) = infix_mnmn(
                                 infix_mnmn(permutation_circuit1(width1(c),
                                 f), c), permutation_circuit1(width1(c), 
                                 c_inv_func_int(f, width1(c)))))))))))))));

unwire_with_permutation: (circuit2, (ARRAY INT OF INT)) -> tuple0;

% unwire_with_permutation'def
  ASSERT
  (FORALL (c : circuit2, f : (ARRAY INT OF INT)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, width1(c))), t2tb6(
  to_fset(0, width1(c))))) => (unwire_with_permutation(c, f) = Tuple0)));

% unwire_with_permutation'spec
  ASSERT
  (FORALL (c : circuit2, f : (ARRAY INT OF INT)):
  ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, width1(c))), t2tb6(
  to_fset(0, width1(c)))))
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, width1(c))) => (path_sem1(with_permutation1(c, f), x) = 
     path_sem(with_permutation(unwire(c), f), x))))));

fc679: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT): ((fc679(k,
  n)[i]) = (IF (i < k) THEN ((i + n) - k) ELSE (i - k) ENDIF)));

% with_permutation_kronecker_gen
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT):
  ((width1(c) = n)
  => (((0 <= k) AND (k < n))
     => (FORALL (im1 : matrix_complex, im_d : matrix_complex,
        ant : matrix_complex, ant_d : matrix_complex):
        ((is_a_ket_l(ant, k))
        => ((is_a_ket_l(ant_d, (n - k)))
           => ((is_a_ket_l(im1, k))
              => ((is_a_ket_l(im_d, (n - k)))
                 => ((is_a_ket_basis_elt(ant))
                    => ((is_a_ket_basis_elt(ant_d))
                       => ((path_sem1(c, kronecker(ant, ant_d)) = 
                          kronecker(im1, im_d)) => (path_sem1(
                          with_permutation1(c, fc679(k, n)), kronecker(ant_d,
                          ant)) = kronecker(im_d, im1)))))))))))));

permutation_three_blocks: (INT, INT, INT, INT) -> circuit2;

result84: (INT, INT, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (n1 : INT, n2 : INT, n3 : INT, j : INT): ((result84(n1, n2,
  n3)[j]) = (IF (j < n1) THEN j
            ELSE (IF (j < (n1 + n3)) THEN (j + n2) ELSE (j - n3) ENDIF) ENDIF)));

% permutation_three_blocks'def
  ASSERT
  (FORALL (n1 : INT, n2 : INT, n3 : INT, n : INT):
  ((0 <= n1)
  => ((0 <= n2)
     => ((0 <= n3)
        => ((0 < n)
           => ((n = ((n1 + n2) + n3)) => (permutation_three_blocks(n1, n2,
              n3, n) = permutation_circuit1(n, result84(n1, n2, n3)))))))));

% permutation_three_blocks'spec
  ASSERT
  (FORALL (n1 : INT, n2 : INT, n3 : INT, n : INT):
  ((0 <= n1)
  => ((0 <= n2)
     => ((0 <= n3)
        => ((0 < n)
           => ((n = ((n1 + n2) + n3))
              => ((size1(permutation_three_blocks(n1, n2, n3, n)) <= n)
                 AND ((ancillas1(permutation_three_blocks(n1, n2, n3,
                     n)) = 0)
                     AND ((width1(permutation_three_blocks(n1, n2, n3,
                         n)) = n)
                         AND (FORALL (x : bitvec, y : bitvec, z : bitvec):
                             ((length(x) = n1)
                             => ((length(y) = n2)
                                => ((length(z) = n3) => (path_sem1(
                                   permutation_three_blocks(n1, n2, n3, n), 
                                   kronecker(kronecker(bv_to_ket(x), 
                                   bv_to_ket(y)), bv_to_ket(z))) = kronecker(
                                   kronecker(bv_to_ket(x), bv_to_ket(z)), 
                                   bv_to_ket(y))))))))))))))));

insert_qbits1: (circuit2, INT, INT, INT) -> circuit2;

result85: (INT, INT, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, j : INT): ((result85(k, n,
  i)[j]) = (IF (j < k) THEN j
           ELSE (IF (j < n) THEN (j + i) ELSE ((j - n) + k) ENDIF) ENDIF)));

% insert_qbits'def
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, i : INT):
  ((width1(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 < i) => (insert_qbits1(c, k, n, i) = with_permutation1(
        infix_slsl(c, m_skip(i)), result85(k, n, i)))))));

fc680: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc681: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc682: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), j : INT): ((
  fc680(k, n, i,
  x)[j]) = (x[(IF (j < k) THEN j
              ELSE (IF (j < n) THEN (j + i) ELSE ((j - n) + k) ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), ii : INT): ((
  fc681(k, n, i,
  x)[ii]) = (x[(IF (ii < k) THEN ii
               ELSE (IF (ii < n) THEN (ii + i) ELSE ((ii - n) + k) ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), ii : INT): ((
  fc682(k, n, i,
  x)[ii]) = (x[(IF (ii < k) THEN ii
               ELSE (IF (ii < n) THEN (ii + i) ELSE ((ii - n) + k) ENDIF) ENDIF)])));

% insert_qbits'spec
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, i : INT):
  ((width1(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 < i)
        => ((ancillas1(insert_qbits1(c, k, n, i)) = ancillas1(c))
           AND ((width1(insert_qbits1(c, k, n, i)) = (n + i))
               AND ((size1(insert_qbits1(c, k, n, i)) <= ((2 * (n + i)) + 
                   size1(c)))
                   AND ((range1(insert_qbits1(c, k, n, i)) = range1(c))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)): (ang_ind1(
                            insert_qbits1(c, k, n, i), x, y) = ang_ind1(c, 
                            fc680(k, n, i, x), y)))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (j : INT):
                                (((0 <= j) AND (j < k)) => (basis_ket1(
                                insert_qbits1(c, k, n, i), x, y, j) = 
                                basis_ket1(c, fc681(k, n, i, x), y, j)))))
                               AND ((FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    (FORALL (j : INT):
                                    ((((k + i) <= j) AND (j < (n + i))) => (
                                    basis_ket1(insert_qbits1(c, k, n, i), x,
                                    y, j) = basis_ket1(c, fc682(k, n, i, x),
                                    y, (j - i))))))
                                   AND (FORALL (x : (ARRAY INT OF INT),
                                       y : (ARRAY INT OF INT)):
                                       (FORALL (j : INT):
                                       (((k <= j) AND (j < (k + i))) => (
                                       basis_ket1(insert_qbits1(c, k, n, i),
                                       x, y, j) = (x[j]))))))))))))))));

% insert_qbits_path_sem
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, i : INT, x : bitvec,
  im1 : matrix_complex, im_d : matrix_complex):
  ((width1(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 < i)
        => ((length(x) = (n + i))
           => ((is_a_ket_l(im1, k))
              => ((is_a_ket_l(im_d, (n - k)))
                 => ((path_sem1(c, bv_to_ket(concat(hpart(x, k), tpart(x,
                    (k + i))))) = kronecker(im1, im_d)) => (path_sem1(
                    insert_qbits1(c, k, n, i), bv_to_ket(x)) = kronecker(im1, 
                    kronecker(bv_to_ket(htpart(x, k, i)), im_d)))))))))));

% insert_qbits_path_sem_basis
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, i : INT, x : matrix_complex,
  y : matrix_complex, z : matrix_complex, xqt : matrix_complex,
  zqt : matrix_complex):
  ((width1(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 < i)
        => ((is_a_ket_l(x, k))
           => ((is_a_ket_basis_elt(x))
              => ((is_a_ket_basis_elt(y))
                 => ((is_a_ket_basis_elt(z))
                    => ((is_a_ket_l(xqt, k))
                       => ((is_a_ket_l(y, i))
                          => ((is_a_ket_l(z, (n - k)))
                             => ((is_a_ket_l(zqt, (n - k)))
                                => ((path_sem1(c, kronecker(x, z)) = 
                                   kronecker(xqt, zqt)) => (path_sem1(
                                   insert_qbits1(c, k, n, i), kronecker(x, 
                                   kronecker(y, z))) = kronecker(xqt, 
                                   kronecker(y, zqt))))))))))))))));

insert_qbits_gen1: (circuit2, INT, INT, INT) -> circuit2;

% insert_qbits_gen'def
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, i : INT):
  ((width1(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 <= i)
        => (IF (0 < i) THEN (insert_qbits_gen1(c, k, n, i) = insert_qbits1(c,
           k, n, i)) ELSE (insert_qbits_gen1(c, k, n, i) = c) ENDIF)))));

fc683: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc684: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc685: (INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), j : INT): ((
  fc683(k, n, i,
  x)[j]) = (x[(IF (j < k) THEN j
              ELSE (IF (j < n) THEN (j + i) ELSE ((j - n) + k) ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), ii : INT): ((
  fc684(k, n, i,
  x)[ii]) = (x[(IF (ii < k) THEN ii
               ELSE (IF (ii < n) THEN (ii + i) ELSE ((ii - n) + k) ENDIF) ENDIF)])));

% fc'def
  ASSERT
  (FORALL (k : INT, n : INT, i : INT, x : (ARRAY INT OF INT), ii : INT): ((
  fc685(k, n, i,
  x)[ii]) = (x[(IF (ii < k) THEN ii
               ELSE (IF (ii < n) THEN (ii + i) ELSE ((ii - n) + k) ENDIF) ENDIF)])));

% insert_qbits_gen'spec
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT, i : INT):
  ((width1(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 <= i)
        => ((ancillas1(insert_qbits_gen1(c, k, n, i)) = ancillas1(c))
           AND ((width1(insert_qbits_gen1(c, k, n, i)) = (n + i))
               AND ((size1(insert_qbits_gen1(c, k, n,
                   i)) <= ((2 * (n + i)) + size1(c)))
                   AND ((range1(insert_qbits_gen1(c, k, n, i)) = range1(c))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)): (ang_ind1(
                            insert_qbits_gen1(c, k, n, i), x, y) = 
                            ang_ind1(c, fc683(k, n, i, x), y)))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                (FORALL (j : INT):
                                (((0 <= j) AND (j < k)) => (basis_ket1(
                                insert_qbits_gen1(c, k, n, i), x, y, j) = 
                                basis_ket1(c, fc684(k, n, i, x), y, j)))))
                               AND ((FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    (FORALL (j : INT):
                                    ((((k + i) <= j) AND (j < (n + i))) => (
                                    basis_ket1(insert_qbits_gen1(c, k, n, i),
                                    x, y, j) = basis_ket1(c, fc685(k, n, i,
                                    x), y, (j - i))))))
                                   AND ((FORALL (x : (ARRAY INT OF INT),
                                        y : (ARRAY INT OF INT)):
                                        (FORALL (j : INT):
                                        (((k <= j) AND (j < (k + i))) => (
                                        basis_ket1(insert_qbits_gen1(c, k, n,
                                        i), x, y, j) = (x[j])))))
                                       AND (FORALL (im1 : matrix_complex,
                                           im_d : matrix_complex,
                                           inserted : matrix_complex,
                                           x : bitvec):
                                           ((is_a_ket_l(im1, k))
                                           => ((is_a_ket_l(im_d, (n - k)))
                                              => ((inserted = bv_to_ket(
                                                 htpart(x, k, i)))
                                                 => ((length(x) = (n + i))
                                                    => ((path_sem1(c, 
                                                       bv_to_ket(concat(
                                                       hpart(x, k), tpart(x,
                                                       (k + i))))) = 
                                                       kronecker(im1, im_d))
                                                       => (path_sem1(
                                                       insert_qbits_gen1(c,
                                                       k, n, i), 
                                                       bv_to_ket(x)) = 
                                                       kronecker(im1, 
                                                       kronecker(inserted,
                                                       im_d)))))))))))))))))))));

swap_lists: (INT, INT, INT, INT) -> circuit2;

% swap_lists'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, l : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => ((0 < l)
     => (((c2 + l) <= n)
        => (((c1 + l) <= c2)
           => ((NOT (c1 = c2)) => (swap_lists(c1, c2, l, n) = place1(
              insert_qbits_gen1(permutation_three_blocks(0, l, l, (2 * l)),
              l, (2 * l), (c2 - l)), 0, n))))))));

% swap_lists'spec
  ASSERT
  (FORALL (c1 : INT, c2 : INT, l : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => ((0 < l)
     => (((c2 + l) <= n)
        => (((c1 + l) <= c2)
           => ((NOT (c1 = c2))
              => ((size1(swap_lists(c1, c2, l, n)) <= (2 * ((2 * l) + c2)))
                 AND ((ancillas1(swap_lists(c1, c2, l, n)) = 0) AND (width1(
                     swap_lists(c1, c2, l, n)) = n)))))))));

% swap_lists_kets_basis
  ASSERT
  (FORALL (c2 : INT, l : INT, n : INT):
  ((0 < l)
  => (((0 <= (c2 + l)) AND ((c2 + l) <= n))
     => (FORALL (a : matrix_complex, x : matrix_complex, y : matrix_complex,
        z : matrix_complex):
        ((is_a_ket_l(a, (c2 - l)))
        => ((is_a_ket_l(x, l))
           => ((is_a_ket_l(y, l))
              => ((is_a_ket_l(z, ((n - c2) - l)))
                 => ((is_a_ket_basis_elt(x))
                    => ((is_a_ket_basis_elt(y))
                       => ((is_a_ket_basis_elt(a))
                          => ((is_a_ket_basis_elt(z)) => (path_sem1(
                             swap_lists(0, c2, l, n), kronecker(x, kronecker(
                             kronecker(a, y), z))) = kronecker(y, kronecker(
                             kronecker(a, x), z)))))))))))))));

% swap_lists_kets
  ASSERT
  (FORALL (c2 : INT, l : INT, n : INT):
  ((0 < l)
  => (((0 <= (c2 + l)) AND ((c2 + l) <= n))
     => (FORALL (a : matrix_complex, x : matrix_complex, y : matrix_complex,
        z : matrix_complex):
        ((is_a_ket_l(a, (c2 - l)))
        => ((is_a_ket_l(x, l))
           => ((is_a_ket_l(y, l))
              => ((is_a_ket_l(z, ((n - c2) - l))) => (path_sem1(swap_lists(0,
                 c2, l, n), kronecker(x, kronecker(kronecker(a, y), z))) = 
                 kronecker(y, kronecker(kronecker(a, x), z)))))))))));

cascade_cont_rz_neg: (INT, INT, INT, INT, INT) -> circuit2;

% cascade_cont_rz_neg'def
  ASSERT
  (FORALL (first_k : INT, first_c : INT, t1 : INT, l : INT, n : INT):
  (((0 <= l) AND (l < n))
  => (((0 <= first_c) AND (first_c < n))
     => (((0 <= t1) AND (t1 < n))
        => (((first_c + l) < n)
           => ((0 <= first_k)
              => (((first_k + l) <= n)
                 => (((t1 <= (first_c + l)) => (t1 < first_c))
                    => (IF (l = 0) THEN (cascade_cont_rz_neg(first_k,
                       first_c, t1, l, n) = crzn_up(first_c, t1, (- first_k),
                       n, n)) ELSE (cascade_cont_rz_neg(first_k, first_c, t1,
                       l, n) = seq_diag(cascade_cont_rz_neg(first_k, first_c,
                       t1, (l - 1), n), crzn_up((first_c + l), t1,
                       (- (first_k + l)), n, n))) ENDIF)))))))));

fc1114: (INT, INT, INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (first_k : INT, first_c : INT, t1 : INT, n : INT,
  x : (ARRAY INT OF INT), k : INT): ((fc1114(first_k, first_c, t1, n,
  x)[k]) = (((x[(first_c + k)]) * (x[t1])) * power(2, (n - (k + first_k))))));

% cascade_cont_rz_neg'spec
  ASSERT
  (FORALL (first_k : INT, first_c : INT, t1 : INT, l : INT, n : INT):
  (((0 <= l) AND (l < n))
  => (((0 <= first_c) AND (first_c < n))
     => (((0 <= t1) AND (t1 < n))
        => (((first_c + l) < n)
           => ((0 <= first_k)
              => (((first_k + l) <= n)
                 => (((t1 <= (first_c + l)) => (t1 < first_c))
                    => ((width1(cascade_cont_rz_neg(first_k, first_c, t1, l,
                       n)) = n)
                       AND ((range1(cascade_cont_rz_neg(first_k, first_c, t1,
                           l, n)) = 0)
                           AND ((ancillas1(cascade_cont_rz_neg(first_k,
                               first_c, t1, l, n)) = 0)
                               AND ((size1(cascade_cont_rz_neg(first_k,
                                   first_c, t1, l,
                                   n)) <= (cont_size1 * (l + 1)))
                                   AND ((FORALL (x : (ARRAY INT OF INT),
                                        y : (ARRAY INT OF INT), i : INT):
                                        (((0 <= i) AND (i < n))
                                        => ((binary_l(x, n)) => (basis_ket1(
                                           cascade_cont_rz_neg(first_k,
                                           first_c, t1, l, n), x, y,
                                           i) = (x[i])))))
                                       AND (FORALL (x : (ARRAY INT OF INT),
                                           y : (ARRAY INT OF INT)):
                                           ((binary_l(x, n)) => (ang_ind1(
                                           cascade_cont_rz_neg(first_k,
                                           first_c, t1, l, n), x, y) = 
                                           infix_sldtsl((- ind_isum(
                                           fc1114(first_k, first_c, t1, n,
                                           x), 0, (l + 1))), n)))))))))))))))));

cascade_cont_qft: (INT, INT) -> circuit2;

% cascade_cont_qft'def
  ASSERT
  (FORALL (t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < (n - 1))) => (cascade_cont_qft(t1, n) = 
  cascade_cont_rz_neg(2, (t1 + 1), t1, (n - (t1 + 2)), n))));

fc1115: (INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1116: (INT, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, n : INT, x : (ARRAY INT OF INT), k : INT): ((fc1115(t1,
  n, x)[k]) = (((x[((t1 + 1) + k)]) * (x[t1])) * power(2, (n - (k + 2))))));

% fc'def
  ASSERT
  (FORALL (t1 : INT, n : INT, x : (ARRAY INT OF INT), k : INT): ((fc1116(t1,
  n, x)[k]) = (((x[t1]) * (x[k])) * power(2, (((n - k) - 1) + t1)))));

% cascade_cont_qft'spec
  ASSERT
  (FORALL (t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < (n - 1)))
  => ((width1(cascade_cont_qft(t1, n)) = n)
     AND ((size1(cascade_cont_qft(t1, n)) <= (cont_size1 * ((n - t1) - 1)))
         AND ((ancillas1(cascade_cont_qft(t1, n)) = 0)
             AND ((range1(cascade_cont_qft(t1, n)) = 0)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT), i : INT):
                      (((0 <= i) AND (i < n))
                      => ((binary_l(x, n)) => (basis_ket1(
                         cascade_cont_qft(t1, n), x, y, i) = (x[i])))))
                     AND ((FORALL (x : (ARRAY INT OF INT),
                          y : (ARRAY INT OF INT)):
                          ((binary_l(x, n)) => (ang_ind1(cascade_cont_qft(t1,
                          n), x, y) = infix_sldtsl((- ind_isum(fc1115(t1, n,
                          x), 0, ((n - (t1 + 2)) + 1))), n))))
                         AND (FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)):
                             ((binary_l(x, n)) => (ang_ind1(
                             cascade_cont_qft(t1, n), x, y) = 
                             infix_sldtsl((- ind_isum(fc1116(t1, n, x),
                             (t1 + 1), n)), n))))))))))));

qft_rev_line: (INT, INT) -> circuit2;

% qft_rev_line'def
  ASSERT
  (FORALL (t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (IF (t1 = (n - 1)) THEN (qft_rev_line(t1, n) = place_hadamard1(t1, n))
     ELSE (qft_rev_line(t1, n) = seq_diag_right(place_hadamard1(t1, n), 
     cascade_cont_qft(t1, n))) ENDIF)));

fc1117: (INT, INT, (ARRAY INT OF INT),
  (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, n : INT, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
  j : INT): ((fc1117(t1, n, x, y)[j]) = (((x[j]) * (y[0])) * power(2,
  (((n - j) - 1) + t1)))));

% qft_rev_line'spec
  ASSERT
  (FORALL (t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => ((size1(qft_rev_line(t1, n)) <= ((cont_size1 * ((n - t1) - 1)) + 1))
     AND ((ancillas1(qft_rev_line(t1, n)) = 0)
         AND ((width1(qft_rev_line(t1, n)) = n)
             AND ((range1(qft_rev_line(t1, n)) = 1)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT), i : INT):
                      (((0 <= i) AND (i < n))
                      => ((binary_l(x, n))
                         => ((binary_l(y, 1)) => (basis_ket1(qft_rev_line(t1,
                            n), x, y,
                            i) = (IF (i = t1) THEN (y[0]) ELSE (x[i]) ENDIF))))))
                     AND (FORALL (x : (ARRAY INT OF INT),
                         y : (ARRAY INT OF INT)):
                         ((binary_l(x, n))
                         => ((binary_l(y, 1)) => (ang_ind1(qft_rev_line(t1,
                            n), x, y) = infix_sldtsl((- ind_isum(fc1117(t1,
                            n, x, y), t1, n)), n))))))))))));

qft_rev_be: (INT) -> circuit2;

fc1118: (INT, (ARRAY INT OF INT), (ARRAY INT OF INT),
  INT) -> (ARRAY INT OF INT);

fc1119: (INT, (ARRAY INT OF INT), (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (n : INT, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), l : INT,
  k : INT): ((fc1118(n, x, y, l)[k]) = (((x[k]) * (y[l])) * power(2,
  (((n - k) - 1) + l)))));

% fc'def
  ASSERT
  (FORALL (n : INT, x : (ARRAY INT OF INT), y : (ARRAY INT OF INT), l : INT):
  ((fc1119(n, x, y)[l]) = (- ind_isum(fc1118(n, x, y, l), l, n))));

% qft_rev_be'spec
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => ((size1(qft_rev_be(n)) <= ((cont_size1 * ind_isum(identity2, 0,
     n)) + n))
     AND ((ancillas1(qft_rev_be(n)) = 0)
         AND ((width1(qft_rev_be(n)) = n)
             AND ((range1(qft_rev_be(n)) = n)
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      y : (ARRAY INT OF INT), i : INT):
                      (((0 <= i) AND (i < n))
                      => ((binary_l(x, n))
                         => ((binary_l(y, n)) => (basis_ket1(qft_rev_be(n),
                            x, y, i) = (y[i]))))))
                     AND (FORALL (x : (ARRAY INT OF INT),
                         y : (ARRAY INT OF INT)):
                         ((binary_l(x, n))
                         => ((binary_l(y, n)) => (ang_ind1(qft_rev_be(n), x,
                            y) = infix_sldtsl(ind_isum(fc1119(n, x, y), 0,
                            n), n))))))))))));

qft_rev_coeff: (bitvec, bitvec, INT) -> complex;

% qft_rev_coeff'def
  ASSERT
  (FORALL (x : bitvec, y : bitvec, n : INT):
  ((0 < n) => (qft_rev_coeff(x, y, n) = ang_exp(real_to_ang(infix_asdt(
  infix_asdt(i_to_c((- bv_to_int(x))), i_to_c(bv_to_int(bv_inversion(y)))), 
  pow_inv_2(n)))))));

fc1120: (bitvec, bitvec, INT, INT) -> (ARRAY INT OF INT);

fc1121: (bitvec, bitvec, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (x : bitvec, y : bitvec, n : INT, l : INT, k : INT): ((fc1120(x, y,
  n, l)[k]) = (((value(x)[k]) * (value(y)[l])) * power(2,
  (((n - k) - 1) + l)))));

% fc'def
  ASSERT
  (FORALL (x : bitvec, y : bitvec, n : INT, l : INT): ((fc1121(x, y,
  n)[l]) = (- ind_isum(fc1120(x, y, n, l), l, n))));

% qft_rev_coeff'spec
  ASSERT
  (FORALL (x : bitvec, y : bitvec, n : INT):
  ((0 < n)
  => ((length(x) = n)
     => ((length(y) = n) => (qft_rev_coeff(x, y, n) = ang_exp(infix_sldtsl(
        ind_isum(fc1121(x, y, n), 0, n), n)))))));

fc694: (INT, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc694(n, x)), t2tb26(y))) = infix_asdtdt(
  qft_rev_coeff(ket_to_bv(x), y, n), bv_to_ket(y))));

% path_sem_rev_qft_unit_be
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, n))
     => ((is_a_ket_basis_elt(x)) => (path_sem1(qft_rev_be(n), x) = 
        infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(n_bvs(n)), 
        t2tb29(fc694(n, x)), n))))))));

int_qft_rev_coeff: (INT, INT, INT) -> complex;

% int_qft_rev_coeff'def
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_rev_coeff(i, j, n) = ang_exp(real_to_ang(infix_asdt(
  infix_asdt(i_to_c(mod((- i), power(2, n))), i_to_c(int_bit_inversion(mod(j, 
  power(2, n)), n))), pow_inv_2(n)))))));

% int_qft_rev_coeff'spec
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n)
  => ((int_qft_rev_coeff(i, j, n) = ang_exp(real_to_ang(infix_asdt(
     infix_asdt(i_to_c((- mod(i, power(2, n)))), i_to_c(int_bit_inversion(
     mod(j, power(2, n)), n))), pow_inv_2(n))))) AND (int_qft_rev_coeff(i, j,
     n) = qft_rev_coeff(int_to_bv(mod(i, power(2, n)), n), int_to_bv(mod(j, 
     power(2, n)), n), n)))));

% qft_rev_coeff_int_to_ang
  ASSERT
  (FORALL (x : bitvec, y : bitvec, n : INT):
  ((0 < n)
  => ((length(x) = n)
     => ((length(y) = n) => (qft_rev_coeff(x, y, n) = ang_exp(
        infix_sldtsl(((- bv_to_int(x)) * bv_to_int(bv_inversion(y))), n)))))));

fc695: (INT, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, y : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(fc695(i, n)), t2tb26(y))) = infix_asdtdt(qft_rev_coeff(
  int_to_bv(i, n), y, n), bv_to_ket(y))));

% path_sem_rev_qft_ket_be
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (path_sem1(qft_rev_be(n), ket(n,
     i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(
     n_bvs(n)), t2tb29(fc695(i, n)), n))))));

% get_path_sem_rev_qft_ket_be
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < power(2, n))) => (tb2t(get(complex1, t2tb18(
        path_sem1(qft_rev_be(n), ket(n, i))), j, 0)) = infix_asdt(
        pow_inv_sqrt_2(n), qft_rev_coeff(int_to_bv(i, n), int_to_bv(j, n),
        n)))))));

fc696: (INT, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, y : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(fc696(i, n)), t2tb26(y))) = infix_asdtdt(
  int_qft_rev_coeff(i, bv_to_int(y), n), bv_to_ket(y))));

% path_sem_rev_qft_ket_ind_be
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (path_sem1(qft_rev_be(n), ket(n,
     i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(
     n_bvs(n)), t2tb29(fc696(i, n)), n))))));

fc697: (INT, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc697(n, x)), t2tb26(y))) = infix_asdtdt(
  qft_rev_coeff(x, y, n), bv_to_ket(y))));

% path_sem_rev_qft_bv_be
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     ((length(x) = n) => (path_sem1(qft_rev_be(n), bv_to_ket(x)) = 
     infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(n_bvs(n)), 
     t2tb29(fc697(n, x)), n)))))));

% int_qft_rev_coeff_expo
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_rev_coeff(i, j, n) = cpower(ang_exp(real_to_ang(
  infix_asdt(i_to_c((- mod(i, power(2, n)))), pow_inv_2(n)))), 
  int_bit_inversion(mod(j, power(2, n)), n)))));

qft_rev: (INT) -> circuit2;

% qft_rev'def
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (IF (n = 1) THEN (qft_rev(n) = qft_rev_be(n))
     ELSE (IF (n = 2) THEN (qft_rev(n) = infix_mnmn(qft_rev_be(n),
          bricks_swap)) ELSE (qft_rev(n) = infix_mnmn(qft_rev_be(n), 
          permutation_circuit1(n, tb2t7(infix_at(infix_mngt(int, int), int, 
          t2tb8(infix_mn_closure), t2tb5((n - 1))))))) ENDIF) ENDIF)));

fc1122: (INT, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1122(n, x)), t2tb26(y))) = 
  infix_asdtdt(qft_rev_coeff(x, bv_inversion(y), n), bv_to_ket(y))));

% qft_rev'spec
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => ((size1(qft_rev(n)) <= polysquare(n, cont_size1, 0, 0))
     AND ((ancillas1(qft_rev(n)) = 0)
         AND ((width1(qft_rev(n)) = n)
             AND ((FORALL (x : bitvec):
                  ((length(x) = n) => (path_sem1(qft_rev(n), bv_to_ket(x)) = 
                  infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(
                  n_bvs(n)), t2tb29(fc1122(n, x)), n)))))
                 AND (FORALL (x : bitvec):
                     (FORALL (i : INT):
                     ((length(x) = n)
                     => (((0 <= i) AND (i < power(2, n))) => (tb2t(
                        get(complex1, t2tb18(path_sem1(qft_rev(n), 
                        bv_to_ket(x))), i, 0)) = infix_asdt(
                        pow_inv_sqrt_2(n), qft_rev_coeff(x, bv_inversion(
                        int_to_bv(i, n)), n)))))))))))));

infix_lseqgt: (circuit2, circuit2) -> BOOLEAN;

% infix <=>'def
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2):
  ((infix_lseqgt(c, cqt))
  <=> ((width1(c) = width1(cqt))
      AND (FORALL (x : matrix_complex):
          ((is_a_ket_l(x, width1(c)))
          => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(c, x) = 
             path_sem_basis1(cqt, x))))))));

% set_equiv_circuits_basis
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2):
  ((width1(c) = width1(cqt))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width1(c)))
      => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(c, x) = 
         path_sem_basis1(cqt, x)))))
     => (infix_lseqgt(c, cqt)))));

% set_equiv_circuits_bv
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2):
  ((width1(c) = width1(cqt))
  => ((FORALL (x : bitvec):
      ((length(x) = width1(c)) => (path_sem1(c, bv_to_ket(x)) = 
      path_sem1(cqt, bv_to_ket(x)))))
     => (infix_lseqgt(c, cqt)))));

% set_equiv_circuits
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2):
  ((width1(c) = width1(cqt))
  => ((FORALL (x : matrix_complex):
      ((is_a_ket_l(x, width1(c)))
      => ((is_a_ket_basis_elt(x)) => (path_sem1(c, x) = path_sem1(cqt, x)))))
     => (infix_lseqgt(c, cqt)))));

% set_equiv_circuits_path_sem
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2):
  ((width1(c) = width1(cqt))
  => ((range1(c) = range1(cqt))
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         ((binary_l(x, width1(c)))
         => ((binary_l(y, range1(c))) => (ang_ind1(c, x, y) = ang_ind1(cqt,
            x, y)))))
        => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
            i : INT):
            ((binary_l(x, width1(c)))
            => ((binary_l(y, range1(c)))
               => (((0 <= i) AND (i < width1(c))) => (basis_ket1(c, x, y,
                  i) = basis_ket1(cqt, x, y, i))))))
           => (infix_lseqgt(c, cqt)))))));

% get_equiv_circuits_basis
  ASSERT
  (FORALL (c1 : circuit2, c2 : circuit2, x : matrix_complex):
  ((infix_lseqgt(c1, c2))
  => ((is_a_ket_l(x, width1(c1)))
     => ((is_a_ket_basis_elt(x)) => (path_sem_basis1(c1, x) = 
        path_sem_basis1(c2, x))))));

% get_equiv_circuits
  ASSERT
  (FORALL (c1 : circuit2, c2 : circuit2, x : matrix_complex):
  ((infix_lseqgt(c1, c2))
  => ((is_a_ket_l(x, width1(c1))) => (path_sem1(c1, x) = path_sem1(c2, x)))));

% get_correct_path_sum_equiv
  ASSERT
  (FORALL (c1 : circuit2, c2 : circuit2, h : pps):
  ((infix_lseqgt(c1, c2))
  => ((correct_path_sum(c1, h)) => (correct_path_sum(c2, h)))));

% get_equiv_circuits_width
  ASSERT
  (FORALL (c1 : circuit2, c2 : circuit2):
  ((infix_lseqgt(c1, c2)) => (width1(c1) = width1(c2))));

% refl_circuit_equiv
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2):
  ((c = cqt) => (infix_lseqgt(c, cqt))));

% sym_circuit_equiv
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2):
  ((infix_lseqgt(c, cqt)) => (infix_lseqgt(cqt, c))));

% transitive_circuit_equiv
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, cqtqt : circuit2):
  ((infix_lseqgt(c, cqt))
  => ((infix_lseqgt(cqt, cqtqt)) => (infix_lseqgt(c, cqtqt)))));

% sequence_assoc
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, cqtqt : circuit2):
  (((width1(c) = width1(cqt)) AND (width1(cqt) = width1(cqtqt)))
  => (infix_lseqgt(infix_mnmn(infix_mnmn(c, cqt), cqtqt), infix_mnmn(c, 
  infix_mnmn(cqt, cqtqt))))));

% parallel_assoc
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, cqtqt : circuit2):
  (((width1(c) = width1(cqt)) AND (width1(cqt) = width1(cqtqt)))
  => (infix_lseqgt(infix_slsl(infix_slsl(c, cqt), cqtqt), infix_slsl(c, 
  infix_slsl(cqt, cqtqt))))));

% sequence_equiv
  ASSERT
  (FORALL (c1 : circuit2, c2 : circuit2, c3 : circuit2, c4 : circuit2):
  ((infix_lseqgt(c1, c2))
  => ((infix_lseqgt(c3, c4))
     => ((width1(c1) = width1(c3)) => (infix_lseqgt(infix_mnmn(c1, c3), 
        infix_mnmn(c2, c4)))))));

% parallel_equiv
  ASSERT
  (FORALL (c1 : circuit2, c2 : circuit2, c3 : circuit2, c4 : circuit2):
  ((infix_lseqgt(c1, c2))
  => ((infix_lseqgt(c3, c4)) => (infix_lseqgt(infix_slsl(c1, c3), 
     infix_slsl(c2, c4))))));

% place_equiv
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, k : INT, n : INT, kqt : INT,
  nqt : INT):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((infix_lseqgt(c, cqt))
        => ((k = kqt)
           => ((n = nqt) => (infix_lseqgt(place1(c, k, n), place1(cqt, kqt,
              nqt)))))))));

% cont_equiv
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2, co : INT, k : INT, n : INT,
  coqt : INT, kqt : INT, nqt : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co))
        => ((infix_lseqgt(c, cqt))
           => ((co = coqt)
              => ((k = kqt)
                 => ((n = nqt) => (infix_lseqgt(cont1(c, co, k, n), 
                    cont1(cqt, coqt, kqt, nqt)))))))))));

remove_parallel: (circuit2, circuit2) -> circuit2;

% remove_parallel'def
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2): (remove_parallel(c, cqt) = 
  infix_mnmn(place1(c, 0, (width1(c) + width1(cqt))), place1(cqt, width1(c),
  (width1(c) + width1(cqt))))));

% remove_parallel'spec
  ASSERT
  (FORALL (c : circuit2, cqt : circuit2): (infix_lseqgt(remove_parallel(c,
  cqt), infix_slsl(c, cqt))));

% par_seq_commut
  ASSERT
  (FORALL (a : circuit2, b : circuit2, c : circuit2, d : circuit2):
  ((width1(a) = width1(c))
  => ((width1(b) = width1(d)) => (infix_lseqgt(infix_mnmn(infix_slsl(a, b), 
     infix_slsl(c, d)), infix_slsl(infix_mnmn(a, c), infix_mnmn(b, d)))))));

% with_permutation_equiv
  ASSERT
  (FORALL (c : circuit2, d : circuit2, f : (ARRAY INT OF INT)):
  ((infix_lseqgt(c, d))
  => ((p_bijective(int, int, t2tb7(f), t2tb6(to_fset(0, width1(c))), t2tb6(
     to_fset(0, width1(c))))) => (infix_lseqgt(with_permutation1(c, f), 
     with_permutation1(d, f))))));

% insert_qbits_equiv
  ASSERT
  (FORALL (c : circuit2, d : circuit2, k : INT, n : INT, i : INT):
  ((width1(c) = n)
  => (((0 <= k) AND (k < n))
     => ((0 < i)
        => ((infix_lseqgt(c, d)) => (infix_lseqgt(insert_qbits1(c, k, n, i), 
           insert_qbits1(d, k, n, i))))))));

seq_flat: (circuit2, circuit2) -> circuit2;

% seq_flat'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((range1(e) = 0) => (seq_flat(d, e) = infix_mnmn(d, e))))));

% seq_flat'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((range1(e) = 0)
        => ((size1(seq_flat(d, e)) = (size1(d) + size1(e)))
           AND ((ancillas1(seq_flat(d, e)) = max(ancillas1(d), ancillas1(e)))
               AND ((pre1(seq_flat(d, e)) = Sequence1(pre1(d), pre1(e)))
                   AND ((FORALL (x : (ARRAY INT OF INT),
                        y : (ARRAY INT OF INT)):
                        (FORALL (i : INT):
                        ((binary_l(x, width1(d)))
                        => (((0 <= i) AND (i < width1(d))) => (basis_ket1(
                           seq_flat(d, e), x, y, i) = basis_ket1(e, tb2t7(
                           infix_at(infix_mngt(int, int), infix_mngt(int,
                           int), infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(int, int)), infix_mngt(int, int), 
                           infix_at(infix_mngt(infix_mngt(int, int), 
                           infix_mngt(infix_mngt(int, int), infix_mngt(int,
                           int))), circuit3, t2tb68(basis_ket_closure1), 
                           t2tb67(d)), t2tb7(x)), t2tb7(y))), y, i))))))
                       AND ((width1(seq_flat(d, e)) = width1(d))
                           AND ((range1(seq_flat(d, e)) = 0)
                               AND (FORALL (x : (ARRAY INT OF INT),
                                   y : (ARRAY INT OF INT)):
                                   ((binary_l(x, width1(d))) => (ang_ind1(
                                   seq_flat(d, e), x, y) = ang_add(
                                   ang_ind1(d, x, y), ang_ind1(e, tb2t7(
                                   infix_at(infix_mngt(int, int), 
                                   infix_mngt(int, int), infix_at(infix_mngt(
                                   infix_mngt(int, int), infix_mngt(int,
                                   int)), infix_mngt(int, int), infix_at(
                                   infix_mngt(infix_mngt(int, int), 
                                   infix_mngt(infix_mngt(int, int), 
                                   infix_mngt(int, int))), circuit3, 
                                   t2tb68(basis_ket_closure1), t2tb67(d)), 
                                   t2tb7(x)), t2tb7(y))), y)))))))))))))));

cont_flat: (circuit2, INT, INT, INT) -> circuit2;

% cont_flat'def
  ASSERT
  (FORALL (c : circuit2, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - width1(c))))
     => (((t1 <= co) => ((t1 + width1(c)) <= co))
        => ((range1(c) = 0) => (cont_flat(c, co, t1, n) = cont1(c, co, t1,
           n)))))));

fc1123: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1124: (INT, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc1123(t1,
  x)[j]) = (x[(j + t1)])));

% fc'def
  ASSERT
  (FORALL (t1 : INT, x : (ARRAY INT OF INT), j : INT): ((fc1124(t1,
  x)[j]) = (x[(j + t1)])));

% cont_flat'spec
  ASSERT
  (FORALL (c : circuit2, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - width1(c))))
     => (((t1 <= co) => ((t1 + width1(c)) <= co))
        => ((range1(c) = 0)
           => ((ancillas1(cont_flat(c, co, t1, n)) = ancillas1(c))
              AND ((size1(cont_flat(c, co, t1, n)) <= (cont_size1 * 
                  size1(c)))
                  AND ((pre1(cont_flat(c, co, t1, n)) = Cont(pre1(c), co, t1,
                      n))
                      AND ((width1(cont_flat(c, co, t1, n)) = n)
                          AND ((FORALL (x : (ARRAY INT OF INT),
                               y : (ARRAY INT OF INT)):
                               (FORALL (i : INT):
                               ((binary_l(x, width1(c)))
                               => (((0 <= i) AND (i < width1(c))) => (
                                  basis_ket1(cont_flat(c, co, t1, n), x, y,
                                  i) = (IF (((x[co]) = 1)
                                           AND ((t1 <= i) AND (i < (t1 + 
                                               width1(c)))))
                                       THEN basis_ket1(c, fc1123(t1, x), y,
                                       (i - t1)) ELSE (x[i]) ENDIF))))))
                              AND (FORALL (x : (ARRAY INT OF INT),
                                  y : (ARRAY INT OF INT)):
                                  ((binary_l(x, width1(c))) => (ang_ind1(
                                  cont_flat(c, co, t1, n), x, y) = 
                                  ang_mult_int(ang_ind1(c, fc1124(t1, x), y),
                                  (x[co])))))))))))))));

seq_flat_right: (circuit2, circuit2) -> circuit2;

% seq_flat_right'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(e) = 0) => (seq_flat_right(d, e) = infix_mnmn(d, e)))));

fc1125: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc1126: (circuit2, (ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc1125(d,
  y)[k]) = (y[(k + range1(d))])));

% fc'def
  ASSERT
  (FORALL (d : circuit2, y : (ARRAY INT OF INT), k : INT): ((fc1126(d,
  y)[k]) = (y[(k + range1(d))])));

% seq_flat_right'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(e) = 0)
     => ((size1(seq_flat_right(d, e)) = (size1(d) + size1(e)))
        AND ((ancillas1(seq_flat_right(d, e)) = max(ancillas1(d), 
            ancillas1(e)))
            AND ((pre1(seq_flat_right(d, e)) = Sequence1(pre1(d), pre1(e)))
                AND ((width1(seq_flat_right(d, e)) = width1(d))
                    AND ((range1(seq_flat_right(d, e)) = range1(d))
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)):
                             (FORALL (i : INT):
                             (((0 <= i) AND (i < width1(d)))
                             => ((binary_l(x, width1(seq_flat_right(d, e))))
                                => (basis_ket1(seq_flat_right(d, e), x, y,
                                i) = basis_ket1(e, tb2t7(infix_at(
                                infix_mngt(int, int), infix_mngt(int, int), 
                                infix_at(infix_mngt(infix_mngt(int, int), 
                                infix_mngt(int, int)), infix_mngt(int, int), 
                                infix_at(infix_mngt(infix_mngt(int, int), 
                                infix_mngt(infix_mngt(int, int), 
                                infix_mngt(int, int))), circuit3, 
                                t2tb68(basis_ket_closure1), t2tb67(d)), 
                                t2tb7(x)), t2tb7(y))), fc1125(d, y), i))))))
                            AND (FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                ((binary_l(x, width1(seq_flat_right(d, e))))
                                => (ang_ind1(seq_flat_right(d, e), x, y) = 
                                ang_add(ang_ind1(d, x, y), ang_ind1(e, tb2t7(
                                infix_at(infix_mngt(int, int), 
                                infix_mngt(int, int), infix_at(infix_mngt(
                                infix_mngt(int, int), infix_mngt(int, int)), 
                                infix_mngt(int, int), infix_at(infix_mngt(
                                infix_mngt(int, int), infix_mngt(
                                infix_mngt(int, int), infix_mngt(int, int))),
                                circuit3, t2tb68(basis_ket_closure1), 
                                t2tb67(d)), t2tb7(x)), t2tb7(y))), fc1126(d,
                                y)))))))))))))));

seq_flat_left: (circuit2, circuit2) -> circuit2;

% seq_flat_left'def
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0) => (seq_flat_left(d, e) = infix_mnmn(d, e)))));

% seq_flat_left'spec
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(d) = 0)
     => ((size1(seq_flat_left(d, e)) = (size1(d) + size1(e)))
        AND ((ancillas1(seq_flat_left(d, e)) = max(ancillas1(d), 
            ancillas1(e)))
            AND ((pre1(seq_flat_left(d, e)) = Sequence1(pre1(d), pre1(e)))
                AND ((width1(seq_flat_left(d, e)) = width1(d))
                    AND ((range1(seq_flat_left(d, e)) = range1(e))
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT)):
                             (FORALL (i : INT):
                             (((0 <= i) AND (i < width1(d)))
                             => ((binary_l(x, width1(d))) => (basis_ket1(
                                seq_flat_left(d, e), x, y, i) = basis_ket1(e, 
                                tb2t7(infix_at(infix_mngt(int, int), 
                                infix_mngt(int, int), infix_at(infix_mngt(
                                infix_mngt(int, int), infix_mngt(int, int)), 
                                infix_mngt(int, int), infix_at(infix_mngt(
                                infix_mngt(int, int), infix_mngt(
                                infix_mngt(int, int), infix_mngt(int, int))),
                                circuit3, t2tb68(basis_ket_closure1), 
                                t2tb67(d)), t2tb7(x)), t2tb7(y))), y, i))))))
                            AND (FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                ((binary_l(x, width1(seq_flat_left(d, e))))
                                => (ang_ind1(seq_flat_left(d, e), x, y) = 
                                ang_add(ang_ind1(d, x, y), ang_ind1(e, tb2t7(
                                infix_at(infix_mngt(int, int), 
                                infix_mngt(int, int), infix_at(infix_mngt(
                                infix_mngt(int, int), infix_mngt(int, int)), 
                                infix_mngt(int, int), infix_at(infix_mngt(
                                infix_mngt(int, int), infix_mngt(
                                infix_mngt(int, int), infix_mngt(int, int))),
                                circuit3, t2tb68(basis_ket_closure1), 
                                t2tb67(d)), t2tb7(x)), t2tb7(y))), y))))))))))))));

% path_sem_flat
  ASSERT
  (FORALL (d : circuit2, x : bitvec):
  ((length(x) = width1(d))
  => ((range1(d) = 0) => (path_sem1(d, bv_to_ket(x)) = infix_asdtdt(ang_exp(
     ang_ind1(d, value(x), identity2)), bv_to_ket(make_bv(tb2t7(infix_at(
     infix_mngt(int, int), infix_mngt(int, int), infix_at(infix_mngt(
     infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int, int), 
     infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(infix_mngt(int,
     int), infix_mngt(int, int))), circuit3, t2tb68(basis_ket_closure1), 
     t2tb67(d)), t2tb7(value(x))), t2tb7(identity2))), width1(d))))))));

% path_sem_flat_gen
  ASSERT
  (FORALL (d : circuit2):
  ((range1(d) = 0)
  => (FORALL (x : bitvec):
     ((length(x) = width1(d)) => (path_sem1(d, bv_to_ket(x)) = infix_asdtdt(
     ang_exp(ang_ind1(d, value(x), identity2)), bv_to_ket(make_bv(tb2t7(
     infix_at(infix_mngt(int, int), infix_mngt(int, int), infix_at(
     infix_mngt(infix_mngt(int, int), infix_mngt(int, int)), infix_mngt(int,
     int), infix_at(infix_mngt(infix_mngt(int, int), infix_mngt(
     infix_mngt(int, int), infix_mngt(int, int))), circuit3, 
     t2tb68(basis_ket_closure1), t2tb67(d)), t2tb7(value(x))), 
     t2tb7(identity2))), width1(d)))))))));

% circuit_equiv_by_unwire
  ASSERT
  (FORALL (c : circuit2, d : circuit2):
  ((unwire(c) = unwire(d)) => (infix_lseqgt(c, d))));

% circuit_equiv_by_unwire_equiv
  ASSERT
  (FORALL (c : circuit2, d : circuit2):
  ((FORALL (x : matrix_complex):
   ((is_a_ket_basis_elt(x))
   => ((is_a_ket_l(x, width1(c))) => (path_sem(unwire(c), x) = path_sem(
      unwire(d), x)))))
  => ((width1(c) = width1(d)) => (infix_lseqgt(c, d)))));

% place_place
  ASSERT
  (FORALL (c : circuit2, k : INT, kqt : INT, n : INT, nqt : INT):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((0 <= kqt)
        => (((n + kqt) <= nqt) => (infix_lseqgt(place1(place1(c, k, n), kqt,
           nqt), place1(c, (k + kqt), nqt))))))));

% place_cont
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, kqt : INT, n : INT, nqt : INT):
  ((0 <= k)
  => (((0 <= co) AND (co < n))
     => (((width1(c) + k) <= n)
        => ((0 <= kqt)
           => (((n + kqt) <= nqt)
              => (((k <= co) => ((k + width1(c)) <= co)) => (infix_lseqgt(
                 place1(cont1(c, co, k, n), kqt, nqt), cont1(c, (co + kqt),
                 (k + kqt), nqt))))))))));

% cont_place
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, kqt : INT, n : INT, nqt : INT):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => (((0 <= co) AND (co < nqt))
        => ((0 <= kqt)
           => (((n + kqt) <= nqt)
              => (((kqt <= co) => ((kqt + n) <= co)) => (infix_lseqgt(cont1(
                 place1(c, k, n), co, kqt, nqt), cont1(c, co, (k + kqt),
                 nqt))))))))));

% cont_sequence_comm
  ASSERT
  (FORALL (co : INT, k : INT, n : INT, c : circuit2, d : circuit2):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => (((k <= co) => ((k + width1(c)) <= co))
        => ((width1(c) = width1(d))
           => (((0 <= co) AND (co < n)) => (infix_lseqgt(cont1(infix_mnmn(c,
              d), co, k, n), infix_mnmn(cont1(c, co, k, n), cont1(d, co, k,
              n))))))))));

% cont_sequence
  ASSERT
  (FORALL (co : INT, k : INT, n : INT, c : circuit2, d : circuit2):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => (((k <= co) => ((k + n) <= co))
        => ((width1(c) = width1(d))
           => (((0 <= co) AND (co < n)) => (infix_lseqgt(infix_mnmn(cont1(c,
              co, k, n), cont1(d, co, k, n)), cont1(infix_mnmn(c, d), co, k,
              n)))))))));

% place_sequence_comm
  ASSERT
  (FORALL (k : INT, n : INT, c : circuit2, d : circuit2):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((width1(c) = width1(d)) => (infix_lseqgt(place1(infix_mnmn(c, d), k,
        n), infix_mnmn(place1(c, k, n), place1(d, k, n))))))));

% place_sequence
  ASSERT
  (FORALL (k : INT, n : INT, c : circuit2, d : circuit2):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((width1(c) = width1(d)) => (infix_lseqgt(infix_mnmn(place1(c, k, n), 
        place1(d, k, n)), place1(infix_mnmn(c, d), k, n)))))));

% hadamard_zero
  ASSERT (path_sem1(hadamard1, ket(1, 0)) = pps_apply(pps_hadamard, ket(1,
  0)));

% hadamard_one
  ASSERT (path_sem1(hadamard1, ket(1, 1)) = pps_apply(pps_hadamard, ket(1,
  1)));

% hadamard_plus
  ASSERT (path_sem1(hadamard1, pps_apply(pps_hadamard, ket(1, 0))) = ket(1,
  0));

% hadamard_minus
  ASSERT (path_sem1(hadamard1, pps_apply(pps_hadamard, ket(1, 1))) = ket(1,
  1));

% xx_zero
  ASSERT (path_sem1(xx1, ket(1, 0)) = ket(1, 1));

% xx_one
  ASSERT (path_sem1(xx1, ket(1, 1)) = ket(1, 0));

% xx_plus
  ASSERT (path_sem1(xx1, pps_apply(pps_hadamard, ket(1, 0))) = 
  pps_apply(pps_hadamard, ket(1, 0)));

% xx_minus
  ASSERT (path_sem1(xx1, pps_apply(pps_hadamard, ket(1, 1))) = infix_asdtdt(
  prefix_mndt(c_one), pps_apply(pps_hadamard, ket(1, 1))));

% xx_invol
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem1(xx1, path_sem1(xx1, x)) = x)));

% zz_zero
  ASSERT (path_sem1(zz1, ket(1, 0)) = ket(1, 0));

% zz_one
  ASSERT (path_sem1(zz1, ket(1, 1)) = infix_asdtdt(prefix_mndt(c_one), ket(1,
  1)));

% zz_invol
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem1(zz1, path_sem1(zz1, x)) = x)));

% zz_plus
  ASSERT (path_sem1(zz1, pps_apply(pps_hadamard, ket(1, 0))) = 
  pps_apply(pps_hadamard, ket(1, 1)));

% zz_minus
  ASSERT (path_sem1(zz1, pps_apply(pps_hadamard, ket(1, 1))) = 
  pps_apply(pps_hadamard, ket(1, 0)));

% ry_zero
  ASSERT (FORALL (k : INT): (path_sem1(ry1(k), ket(1, 0)) = ket_zero_y(k)));

% ry_one
  ASSERT (FORALL (k : INT): (path_sem1(ry1(k), ket(1, 1)) = ket_one_y(k)));

% yy_zero
  ASSERT (path_sem1(yy1, ket(1, 0)) = infix_asdtdt(im, ket_zero_y(1)));

% yy_one
  ASSERT (path_sem1(yy1, ket(1, 1)) = infix_asdtdt(im, ket_one_y(1)));

% ry_add_opp
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem1(ry1((- k)), path_sem1(ry1(k), x)) = x)));

% ry_twice
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem1(ry1(incr_abs(k)), path_sem1(ry1(
  incr_abs(k)), x)) = path_sem1(ry1(k), x))));

% rz_zero
  ASSERT
  (FORALL (k : INT): (path_sem1(rz1(k), ket(1, 0)) = infix_asdtdt(ang_exp(
  infix_sldtsl((- 1), incr_abs(k))), ket(1, 0))));

% rz_one
  ASSERT
  (FORALL (k : INT): (path_sem1(rz1(k), ket(1, 1)) = infix_asdtdt(ang_exp(
  infix_sldtsl(1, incr_abs(k))), ket(1, 1))));

% ry_inv
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem1(xx1, path_sem1(ry1(k), x)) = path_sem1(
  ry1((- k)), path_sem1(xx1, x)))));

% ry_inv_rev
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem1(ry1((- k)), path_sem1(xx1, x)) = 
  path_sem1(xx1, path_sem1(ry1(k), x)))));

% rz_inv
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem1(xx1, path_sem1(rz1(k), x)) = path_sem1(
  rz1((- k)), path_sem1(xx1, x)))));

% rz_inv_rev
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem1(rz1((- k)), path_sem1(xx1, x)) = 
  path_sem1(xx1, path_sem1(rz1(k), x)))));

% rzp_zero
  ASSERT (FORALL (k : INT): (path_sem1(rzp(k), ket(1, 0)) = ket(1, 0)));

% path_sem_phase
  ASSERT
  (FORALL (k : INT, x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem1(phase1(k), x) = infix_asdtdt(ang_exp(
  infix_sldtsl(1, k)), x))));

% rzp_one
  ASSERT
  (FORALL (k : INT): (path_sem1(rzp(k), ket(1, 1)) = infix_asdtdt(ang_exp(
  infix_sldtsl(1, k)), ket(1, 1))));

% rz_twice_
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem1(rz1(incr_abs(k)), path_sem1(rz1(
  incr_abs(k)), x)) = path_sem1(rz1(k), x))));

% rzp_twice_
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem1(rzp(incr_abs(k)), path_sem1(rzp(
  incr_abs(k)), x)) = path_sem1(rzp(k), x))));

% phase_twice_
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem1(phase1(incr_abs(k)), path_sem1(phase1(
  incr_abs(k)), x)) = path_sem1(phase1(k), x))));

% hadamard_twice_
  ASSERT
  (FORALL (x : matrix_complex):
  ((is_a_ket_l(x, 1)) => (path_sem1(hadamard1, path_sem1(hadamard1, x)) = x)));

% phase_comm
  ASSERT
  (FORALL (k : INT, c : circuit2):
  ((width1(c) = 1) => (infix_lseqgt(infix_mnmn(phase1(k), c), infix_mnmn(c, 
  phase1(k))))));

% comm_phase
  ASSERT
  (FORALL (k : INT, c : circuit2):
  ((width1(c) = 1) => (infix_lseqgt(infix_mnmn(c, phase1(k)), infix_mnmn(
  phase1(k), c)))));

rewrite_cnot: (INT, INT, INT) -> circuit2;

% rewrite_cnot'def
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (t1 = co)) => (rewrite_cnot(co, t1, n) = cont1(xx1, co, t1,
        n))))));

% rewrite_cnot'spec
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (t1 = co))
        => ((ancillas1(rewrite_cnot(co, t1, n)) = 0) AND (infix_lseqgt(
           rewrite_cnot(co, t1, n), cnot1(co, t1, n))))))));

rz_not: (INT) -> circuit2;

% rz_not'def
  ASSERT
  (FORALL (k : INT): (rz_not(k) = infix_mnmn(infix_mnmn(xx1, rz1(k)), xx1)));

% rz_not'spec
  ASSERT
  (FORALL (k : INT):
  ((ancillas1(rz_not(k)) = 0) AND (infix_lseqgt(rz_not(k), rz1((- k))))));

ry_not: (INT) -> circuit2;

% ry_not'def
  ASSERT
  (FORALL (k : INT): (ry_not(k) = infix_mnmn(infix_mnmn(xx1, ry1(k)), xx1)));

% ry_not'spec
  ASSERT
  (FORALL (k : INT):
  ((ancillas1(ry_not(k)) = 0) AND (infix_lseqgt(ry_not(k), ry1((- k))))));

rewrite_rz: (INT) -> circuit2;

% rewrite_rz'def
  ASSERT
  (FORALL (k : INT): (rewrite_rz(k) = infix_mnmn(phase1((- incr_abs(k))), 
  rzp(k))));

% rewrite_rz'spec
  ASSERT
  (FORALL (k : INT):
  ((ancillas1(rewrite_rz(k)) = 0) AND (infix_lseqgt(rewrite_rz(k), rz1(k)))));

rewrite_rzp: (INT) -> circuit2;

% rewrite_rzp'def
  ASSERT
  (FORALL (k : INT): (rewrite_rzp(k) = infix_mnmn(phase1(incr_abs(k)), 
  rz1(k))));

% rewrite_rzp'spec
  ASSERT
  (FORALL (k : INT):
  ((ancillas1(rewrite_rzp(k)) = 0) AND (infix_lseqgt(rewrite_rzp(k), 
  rzp(k)))));

rewrite_rx: (INT) -> circuit2;

% rewrite_rx'def
  ASSERT
  (FORALL (k : INT): (rewrite_rx(k) = infix_mnmn(infix_mnmn(hadamard1, 
  rz1(k)), hadamard1)));

% rewrite_rx'spec
  ASSERT
  (FORALL (k : INT):
  ((ancillas1(rewrite_rx(k)) = 0) AND (infix_lseqgt(rewrite_rx(k), rx1(k)))));

rewrite_ry: (INT) -> circuit2;

% rewrite_ry'def
  ASSERT
  (FORALL (k : INT): (rewrite_ry(k) = infix_mnmn(infix_mnmn(rzp((- 2)), 
  rx1(k)), rzp(2))));

% rewrite_ry'spec
  ASSERT
  (FORALL (k : INT):
  ((ancillas1(rewrite_ry(k)) = 0) AND (infix_lseqgt(rewrite_ry(k), ry1(k)))));

rewrite_ry_with_z: (INT) -> circuit2;

% rewrite_ry_with_z'def
  ASSERT
  (FORALL (k : INT): (rewrite_ry_with_z(k) = infix_mnmn(infix_mnmn(
  rzp((- 2)), rewrite_rx(k)), rzp(2))));

% rewrite_ry_with_z'spec
  ASSERT
  (FORALL (k : INT):
  ((ancillas1(rewrite_ry_with_z(k)) = 0) AND (infix_lseqgt(
  rewrite_ry_with_z(k), ry1(k)))));

% rewrite_s'spec
  ASSERT ((ancillas1(rzp(2)) = 0) AND (infix_lseqgt(rzp(2), s)));

% rewrite_t'spec
  ASSERT ((ancillas1(rzp(3)) = 0) AND (infix_lseqgt(rzp(3), t)));

% rewrite_zz'spec
  ASSERT ((ancillas1(rzp(1)) = 0) AND (infix_lseqgt(rzp(1), zz1)));

% rewrite_xx'spec
  ASSERT
  ((ancillas1(infix_mnmn(infix_mnmn(hadamard1, zz1), hadamard1)) = 0)
  AND (infix_lseqgt(infix_mnmn(infix_mnmn(hadamard1, zz1), hadamard1), xx1)));

% rewrite_yy'spec
  ASSERT
  ((ancillas1(infix_mnmn(phase1(2), ry1(1))) = 0) AND (infix_lseqgt(
  infix_mnmn(phase1(2), ry1(1)), yy1)));

% rewrite_hadamard'spec
  ASSERT
  ((ancillas1(infix_mnmn(ry1(2), xx1)) = 0) AND (infix_lseqgt(infix_mnmn(
  ry1(2), xx1), hadamard1)));

place_hadamard_with_ry: (INT, INT) -> circuit2;

% place_hadamard_with_ry'def
  ASSERT
  (FORALL (t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n)) => (place_hadamard_with_ry(t1, n) = infix_mnmn(
  infix_mnmn(place1(ry1(3), t1, n), place1(xx1, t1, n)), place1(ry1((- 3)),
  t1, n)))));

% place_hadamard_with_ry'spec
  ASSERT
  (FORALL (t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => ((ancillas1(place_hadamard_with_ry(t1, n)) = 0) AND (infix_lseqgt(
     place_hadamard_with_ry(t1, n), place1(hadamard1, t1, n))))));

cont_hadamard: (INT, INT, INT) -> circuit2;

% cont_hadamard'def
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (co = t1)) => (cont_hadamard(co, t1, n) = infix_mnmn(
        infix_mnmn(place1(ry1(3), t1, n), cnot1(co, t1, n)), place1(
        ry1((- 3)), t1, n)))))));

% cont_hadamard'spec
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (co = t1))
        => ((ancillas1(cont_hadamard(co, t1, n)) = 0) AND (infix_lseqgt(
           cont_hadamard(co, t1, n), cont1(hadamard1, co, t1, n))))))));

cont_ry: (INT, INT, INT, INT) -> circuit2;

% cont_ry'def
  ASSERT
  (FORALL (k : INT, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (co = t1)) => (cont_ry(k, co, t1, n) = infix_mnmn(infix_mnmn(
        infix_mnmn(place1(ry1(incr_abs(k)), t1, n), cnot1(co, t1, n)), 
        place1(ry1((- incr_abs(k))), t1, n)), cnot1(co, t1, n)))))));

% cont_ry'spec
  ASSERT
  (FORALL (k : INT, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (co = t1))
        => ((ancillas1(cont_ry(k, co, t1, n)) = 0) AND (infix_lseqgt(
           cont_ry(k, co, t1, n), cont1(ry1(k), co, t1, n))))))));

cont_rz: (INT, INT, INT, INT) -> circuit2;

% cont_rz'spec
  ASSERT
  (FORALL (k : INT, co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (t1 = co))
        => ((infix_lseqgt(cont_rz(k, co, t1, n), cont1(rz1(k), co, t1, n)))
           AND ((ancillas1(cont_rz(k, co, t1, n)) = 0)
               AND ((width1(cont_rz(k, co, t1, n)) = n)
                   AND ((range1(cont_rz(k, co, t1, n)) = 0)
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)):
                            (FORALL (i : INT):
                            ((binary_l(x, n))
                            => (((0 <= i) AND (i < n)) => (basis_ket1(
                               cont_rz(k, co, t1, n), x, y, i) = (x[i]))))))
                           AND ((FORALL (x : (ARRAY INT OF INT),
                                y : (ARRAY INT OF INT)):
                                ((binary_l(x, n)) => (ang_ind1(cont_rz(k, co,
                                t1, n), x, y) = phase_inv_(((x[t1]) - 1), 
                                infix_sldtsl((x[co]), incr_abs(k))))))
                               AND (cont_rz(k, co, t1, n) = infix_mnmn(
                               infix_mnmn(infix_mnmn(place1(rz1(incr_abs(k)),
                               t1, n), cnot1(co, t1, n)), place1(rz1((- 
                               incr_abs(k))), t1, n)), cnot1(co, t1, n)))))))))))));

cont_phase: (INT, INT, INT, INT) -> circuit2;

% cont_phase'def
  ASSERT
  (FORALL (k : INT, co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (t1 = co)) => (cont_phase(k, co, t1, n) = place_diag(rzp(k),
        co, n))))));

% cont_phase'spec
  ASSERT
  (FORALL (k : INT, co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (t1 = co))
        => ((ancillas1(cont_phase(k, co, t1, n)) = 0)
           AND ((infix_lseqgt(cont_phase(k, co, t1, n), cont1(phase1(k), co,
               t1, n)))
               AND ((width1(cont_phase(k, co, t1, n)) = n)
                   AND ((range1(cont_phase(k, co, t1, n)) = 0)
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)):
                            (FORALL (i : INT):
                            ((binary_l(x, n))
                            => (((0 <= i) AND (i < n)) => (basis_ket1(
                               cont_phase(k, co, t1, n), x, y, i) = (x[i]))))))
                           AND (FORALL (x : (ARRAY INT OF INT),
                               y : (ARRAY INT OF INT)):
                               ((binary_l(x, n)) => (ang_ind1(cont_phase(k,
                               co, t1, n), x, y) = infix_sldtsl((x[co]), k)))))))))))));

cont_rzp: (INT, INT, INT, INT) -> circuit2;

% cont_rzp'def
  ASSERT
  (FORALL (k : INT, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 < n))
     => (((t1 <= co) => ((t1 + 1) <= co)) => (cont_rzp(k, co, t1, n) = 
        seq_diag(cont_phase(incr_abs(k), co, t1, n), cont_rz(k, co, t1, n)))))));

% cont_rzp'spec
  ASSERT
  (FORALL (k : INT, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 < n))
     => (((t1 <= co) => ((t1 + 1) <= co))
        => ((ancillas1(cont_rzp(k, co, t1, n)) = 0)
           AND ((width1(cont_rzp(k, co, t1, n)) = n)
               AND ((range1(cont_rzp(k, co, t1, n)) = 0)
                   AND ((FORALL (x : (ARRAY INT OF INT),
                        y : (ARRAY INT OF INT)):
                        (FORALL (i : INT):
                        ((binary_l(x, n))
                        => (((0 <= i) AND (i < n)) => (basis_ket1(cont_rzp(k,
                           co, t1, n), x, y, i) = (x[i]))))))
                       AND ((FORALL (x : (ARRAY INT OF INT),
                            y : (ARRAY INT OF INT)):
                            ((binary_l(x, n)) => (ang_ind1(cont_rzp(k, co,
                            t1, n), x, y) = infix_sldtsl(((x[co]) * (x[t1])),
                            k))))
                           AND (infix_lseqgt(cont_rzp(k, co, t1, n), cont1(
                           rzp(k), co, t1, n))))))))))));

cont_xor_rz: (INT, INT, INT, INT, INT) -> circuit2;

% cont_xor_rz'def
  ASSERT
  (FORALL (k : INT, co1 : INT, co2 : INT, t1 : INT, n : INT):
  (((0 <= co1) AND (co1 < n))
  => (((0 <= co2) AND (co2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (co1 = co2))
           => ((NOT (co1 = t1))
              => ((NOT (t1 = co2)) => (cont_xor_rz(k, co1, co2, t1, n) = 
                 seq_flat(seq_flat(cnot1(co1, co2, n), cont_rzp(k, co2, t1,
                 n)), cnot1(co1, co2, n))))))))));

% cont_xor_rz'spec
  ASSERT
  (FORALL (k : INT, co1 : INT, co2 : INT, t1 : INT, n : INT):
  (((0 <= co1) AND (co1 < n))
  => (((0 <= co2) AND (co2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (co1 = co2))
           => ((NOT (co1 = t1))
              => ((NOT (t1 = co2))
                 => ((ancillas1(cont_xor_rz(k, co1, co2, t1, n)) = 0)
                    AND ((width1(cont_xor_rz(k, co1, co2, t1, n)) = n)
                        AND ((range1(cont_xor_rz(k, co1, co2, t1, n)) = 0)
                            AND ((FORALL (x : (ARRAY INT OF INT),
                                 y : (ARRAY INT OF INT)):
                                 ((binary_l(x, n)) => (ang_ind1(
                                 cont_xor_rz(k, co1, co2, t1, n), x, y) = 
                                 infix_sldtsl(((((x[co1]) + (x[co2])) - (2 * ((x[co1]) * (x[co2])))) * (x[t1])),
                                 k))))
                                AND (FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    (FORALL (i : INT):
                                    ((binary_l(x, n))
                                    => (((0 <= i) AND (i < n)) => (
                                       basis_ket1(cont_xor_rz(k, co1, co2,
                                       t1, n), x, y, i) = (x[i])))))))))))))))));

cont_rx: (INT, INT, INT, INT) -> circuit2;

% cont_rx'def
  ASSERT
  (FORALL (k : INT, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - 1)))
     => (((t1 <= co) => ((t1 + 1) <= co)) => (cont_rx(k, co, t1, n) = 
        infix_mnmn(infix_mnmn(cont_hadamard(co, t1, n), cont_rz(k, co, t1,
        n)), cont_hadamard(co, t1, n)))))));

% cont_rx'spec
  ASSERT
  (FORALL (k : INT, co : INT, t1 : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 <= (n - 1)))
     => (((t1 <= co) => ((t1 + 1) <= co))
        => ((ancillas1(cont_rx(k, co, t1, n)) = 0) AND (infix_lseqgt(
           cont_rx(k, co, t1, n), cont1(rx1(k), co, t1, n))))))));

swap_decomp: (INT, INT, INT) -> circuit2;

% swap_decomp'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2)) => (swap_decomp(t1, t2, n) = seq_flat_mute(
        seq_flat_mute(cnot1(t1, t2, n), cnot1(t2, t1, n)), cnot1(t1, t2,
        n)))))));

% swap_decomp'spec
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2))
        => ((width1(swap_decomp(t1, t2, n)) = n)
           AND ((ancillas1(swap_decomp(t1, t2, n)) = 0) AND (infix_lseqgt(
               swap_decomp(t1, t2, n), swap1(t1, t2, n)))))))));

ccz1: (INT, INT, INT, INT) -> circuit2;

% ccz'def
  ASSERT
  (FORALL (t1 : INT, t2 : INT, t3 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= t3) AND (t3 < n))
        => ((NOT (t1 = t2))
           => ((NOT (t1 = t3))
              => ((NOT (t3 = t2)) => (ccz1(t1, t2, t3, n) = seq_diag(
                 seq_diag(cont_rzp(2, t1, t3, n), cont_rzp(2, t2, t3, n)), 
                 cont_xor_rz((- 2), t1, t2, t3, n))))))))));

% ccz'spec
  ASSERT
  (FORALL (t1 : INT, t2 : INT, t3 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= t3) AND (t3 < n))
        => ((NOT (t1 = t2))
           => ((NOT (t1 = t3))
              => ((NOT (t3 = t2))
                 => ((ancillas1(ccz1(t1, t2, t3, n)) = 0)
                    AND ((range1(ccz1(t1, t2, t3, n)) = 0)
                        AND ((FORALL (x : (ARRAY INT OF INT),
                             y : (ARRAY INT OF INT), i : INT):
                             ((binary_l(x, n))
                             => (((0 <= i) AND (i < n)) => (basis_ket1(
                                ccz1(t1, t2, t3, n), x, y, i) = (x[i])))))
                            AND ((width1(ccz1(t1, t2, t3, n)) = n)
                                AND (FORALL (x : (ARRAY INT OF INT),
                                    y : (ARRAY INT OF INT)):
                                    ((binary_l(x, n)) => (ang_ind1(ccz1(t1,
                                    t2, t3, n), x, y) = 
                                    infix_sldtsl((((x[t1]) * (x[t2])) * (x[t3])),
                                    1)))))))))))))));

% path_sem_toffoli
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT, x : bitvec):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (t1 = c2))
                 => ((length(x) = n) => (path_sem1(toffoli1(c1, c2, t1, n), 
                    bv_to_ket(x)) = (IF (((value(x)[c1]) = (value(x)[c2]))
                                        AND ((value(x)[c2]) = 1))
                                    THEN path_sem1(place1(xx1, t1, n), 
                                    bv_to_ket(x)) ELSE bv_to_ket(x) ENDIF))))))))));

% set_equiv_flat_mute
  ASSERT
  (FORALL (d : circuit2, e : circuit2):
  ((width1(d) = width1(e))
  => ((range1(e) = 0)
     => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
         ((binary_l(x, width1(d))) => (ang_ind1(e, x, y) = ang_zero)))
        => ((range1(d) = 0)
           => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT)):
               ((binary_l(x, width1(d))) => (ang_ind1(d, x, y) = ang_zero)))
              => ((FORALL (x : (ARRAY INT OF INT), y : (ARRAY INT OF INT),
                  i : INT):
                  ((binary_l(x, width1(d)))
                  => (((0 <= i) AND (i < width1(d))) => (basis_ket1(d, x, y,
                     i) = basis_ket1(e, x, y, i)))))
                 => (infix_lseqgt(d, e)))))))));

% path_sem_ccz
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT, x : bitvec):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (t1 = c2))
                 => ((length(x) = n) => (path_sem1(ccz1(c1, c2, t1, n), 
                    bv_to_ket(x)) = (IF (((value(x)[c1]) = (value(x)[c2]))
                                        AND ((value(x)[c2]) = 1))
                                    THEN path_sem1(place1(zz1, t1, n), 
                                    bv_to_ket(x)) ELSE bv_to_ket(x) ENDIF))))))))));

% path_sem_ccz_
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT, x : bitvec,
  y : matrix_complex):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (t1 = c2))
                 => ((length(x) = n)
                    => ((is_a_ket_l(y, 1)) => (path_sem1(ccz1(c1, c2, t1, n), 
                       kronecker(kronecker(bv_to_ket(hpart(x, t1)), y), 
                       bv_to_ket(tpart(x,
                       (t1 + 1))))) = (IF (((value(x)[c1]) = (value(x)[c2]))
                                          AND ((value(x)[c2]) = 1))
                                      THEN kronecker(kronecker(bv_to_ket(
                                      hpart(x, t1)), path_sem1(zz1, y)), 
                                      bv_to_ket(tpart(x, (t1 + 1)))) ELSE 
                                      kronecker(kronecker(bv_to_ket(hpart(x,
                                      t1)), y), bv_to_ket(tpart(x,
                                      (t1 + 1)))) ENDIF)))))))))));

% basis_ket_cnot_if
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), i : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= t1) AND (t1 < n))
     => ((NOT (t1 = co))
        => ((binary_l(x, n))
           => (((0 <= i) AND (i < n)) => (basis_ket1(cnot1(co, t1, n), x, y,
              i) = (IF ((i = t1) AND ((x[co]) = 1))
                   THEN (IF ((x[t1]) = 1) THEN 0 ELSE 1 ENDIF)
                   ELSE (x[i]) ENDIF))))))));

% basis_ket_swap_if
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), i : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2))
        => ((binary_l(x, n))
           => (((0 <= i) AND (i < n)) => (basis_ket1(swap1(t1, t2, n), x, y,
              i) = (IF (i = t1) THEN (x[t2])
                   ELSE (IF (i = t2) THEN (x[t1]) ELSE (x[i]) ENDIF) ENDIF))))))));

% basis_ket_toffoli_if
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), i : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (t1 = c1))
           => ((NOT (t1 = c2))
              => ((NOT (c2 = c1))
                 => ((binary_l(x, n))
                    => (((0 <= i) AND (i < n)) => (basis_ket1(toffoli1(c1,
                       c2, t1, n), x, y,
                       i) = (IF ((i = t1)
                                AND (((x[c1]) = 1) AND ((x[c2]) = 1)))
                            THEN (IF ((x[t1]) = 1) THEN 0 ELSE 1 ENDIF)
                            ELSE (x[i]) ENDIF)))))))))));

% basis_ket_fredkin_if
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT, x : (ARRAY INT OF INT),
  y : (ARRAY INT OF INT), i : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (c = t1))
           => ((NOT (c = t2))
              => ((NOT (t2 = t1))
                 => ((binary_l(x, n))
                    => (((0 <= i) AND (i < n)) => (basis_ket1(fredkin1(c, t1,
                       t2, n), x, y,
                       i) = (IF ((i = t1) AND ((x[c]) = 1)) THEN (x[t2])
                            ELSE (IF ((i = t2) AND ((x[c]) = 1)) THEN (x[t1])
                                 ELSE (x[i]) ENDIF) ENDIF)))))))))));

toffoli_decomp: (INT, INT, INT, INT) -> circuit2;

% toffoli_decomp'def
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (t1 = c2)) => (toffoli_decomp(c1, c2, t1, n) = 
                 infix_mnmn(infix_mnmn(place1(hadamard1, t1, n), ccz1(c1, c2,
                 t1, n)), place1(hadamard1, t1, n))))))))));

% toffoli_decomp'spec
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (t1 = c2))
                 => ((ancillas1(toffoli_decomp(c1, c2, t1, n)) = 0)
                    AND ((width1(toffoli_decomp(c1, c2, t1, n)) = n)
                        AND (infix_lseqgt(toffoli_decomp(c1, c2, t1, n), 
                        toffoli1(c1, c2, t1, n))))))))))));

fredkin_as_cont_swap: (INT, INT, INT, INT, INT, INT) -> circuit2;

% fredkin_as_cont_swap'def
  ASSERT
  (FORALL (c : INT, ta1 : INT, ta2 : INT, k : INT, n1 : INT, n2 : INT):
  (((k <= ta1) AND (ta1 < (k + n1)))
  => (((k <= ta2) AND (ta2 < (k + n1)))
     => ((NOT (ta1 = ta2))
        => (((k + n1) <= n2)
           => ((0 <= k)
              => (((k <= c) => ((k + n1) <= c))
                 => (((0 <= c) AND (c < n2)) => (fredkin_as_cont_swap(c, ta1,
                    ta2, k, n1, n2) = cont_flat_mute(swap1((ta1 - k),
                    (ta2 - k), n1), c, k, n2))))))))));

% fredkin_as_cont_swap'spec
  ASSERT
  (FORALL (c : INT, ta1 : INT, ta2 : INT, k : INT, n1 : INT, n2 : INT):
  (((k <= ta1) AND (ta1 < (k + n1)))
  => (((k <= ta2) AND (ta2 < (k + n1)))
     => ((NOT (ta1 = ta2))
        => (((k + n1) <= n2)
           => ((0 <= k)
              => (((k <= c) => ((k + n1) <= c))
                 => (((0 <= c) AND (c < n2))
                    => ((ancillas1(fredkin_as_cont_swap(c, ta1, ta2, k, n1,
                       n2)) = 0) AND (infix_lseqgt(fredkin_as_cont_swap(c,
                       ta1, ta2, k, n1, n2), fredkin1(c, ta1, ta2, n2))))))))))));

toffoli_as_cont_cnot: (INT, INT, INT, INT, INT, INT) -> circuit2;

% toffoli_as_cont_cnot'def
  ASSERT
  (FORALL (c : INT, ta1 : INT, ta2 : INT, k : INT, n1 : INT, n2 : INT):
  (((k <= ta1) AND (ta1 < (k + n1)))
  => (((k <= ta2) AND (ta2 < (k + n1)))
     => ((NOT (ta1 = ta2))
        => (((k + n1) <= n2)
           => ((0 <= k)
              => (((k <= c) => ((k + n1) <= c))
                 => (((0 <= c) AND (c < n2)) => (toffoli_as_cont_cnot(c, ta1,
                    ta2, k, n1, n2) = cont_flat_mute(cnot1((ta1 - k),
                    (ta2 - k), n1), c, k, n2))))))))));

% toffoli_as_cont_cnot'spec
  ASSERT
  (FORALL (c : INT, ta1 : INT, ta2 : INT, k : INT, n1 : INT, n2 : INT):
  (((k <= ta1) AND (ta1 < (k + n1)))
  => (((k <= ta2) AND (ta2 < (k + n1)))
     => ((NOT (ta1 = ta2))
        => (((k + n1) <= n2)
           => ((0 <= k)
              => (((k <= c) => ((k + n1) <= c))
                 => (((0 <= c) AND (c < n2))
                    => ((ancillas1(toffoli_as_cont_cnot(c, ta1, ta2, k, n1,
                       n2)) = 0) AND (infix_lseqgt(toffoli_as_cont_cnot(c,
                       ta1, ta2, k, n1, n2), toffoli1(c, ta1, ta2, n2))))))))))));

fredkin_decomp: (INT, INT, INT, INT) -> circuit2;

% fredkin_decomp'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (t1 = t2))
           => ((NOT (t1 = c))
              => ((NOT (c = t2))
                 => ((width1(fredkin_decomp(c, t1, t2, n)) = n)
                    AND ((ancillas1(fredkin_decomp(c, t1, t2, n)) = 0)
                        AND ((infix_lseqgt(fredkin_decomp(c, t1, t2, n), 
                            fredkin1(c, t1, t2, n))) AND (fredkin_decomp(c,
                            t1, t2, n) = infix_mnmn(infix_mnmn(cnot1(t2, t1,
                            n), toffoli1(c, t1, t2, n)), cnot1(t2, t1, n)))))))))))));

fredkin_decomp_toffoli: (INT, INT, INT, INT) -> circuit2;

% fredkin_decomp_toffoli'def
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (t1 = t2))
           => ((NOT (t1 = c))
              => ((NOT (c = t2)) => (fredkin_decomp_toffoli(c, t1, t2, n) = 
                 infix_mnmn(infix_mnmn(cnot1(t2, t1, n), toffoli_decomp(c,
                 t1, t2, n)), cnot1(t2, t1, n))))))))));

% fredkin_decomp_toffoli'spec
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (t1 = t2))
           => ((NOT (t1 = c))
              => ((NOT (c = t2))
                 => ((ancillas1(fredkin_decomp_toffoli(c, t1, t2, n)) = 0)
                    AND (infix_lseqgt(fredkin_decomp_toffoli(c, t1, t2, n), 
                    fredkin1(c, t1, t2, n)))))))))));

% unbricks_fredkin'spec
  ASSERT (infix_lseqgt(bricks_fredkin, fredkin1(0, 1, 2, 3)));

% unbricks_toffoli'spec
  ASSERT (infix_lseqgt(bricks_toffoli, toffoli1(0, 1, 2, 3)));

% unbricks_swap'spec
  ASSERT (infix_lseqgt(bricks_swap, swap1(0, 1, 2)));

% unbricks_cnot'spec
  ASSERT (infix_lseqgt(bricks_cnot, cnot1(0, 1, 2)));

% ry_twice_equiv
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(infix_mnmn(ry1(kqt), ry1(kqt)), 
  ry1(k)))));

% rz_twice_equiv
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(infix_mnmn(rz1(kqt), rz1(kqt)), 
  rz1(k)))));

% rzp_twice_equiv
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(infix_mnmn(rzp(kqt), rzp(kqt)), 
  rzp(k)))));

% rx_twice_equiv
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(infix_mnmn(rx1(kqt), rx1(kqt)), 
  rx1(k)))));

% rx_twice_
  ASSERT
  (FORALL (x : matrix_complex, k : INT):
  ((is_a_ket_l(x, 1)) => (path_sem1(rx1(incr_abs(k)), path_sem1(rx1(
  incr_abs(k)), x)) = path_sem1(rx1(k), x))));

% phase_twice_equiv
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(infix_mnmn(phase1(kqt), phase1(kqt)), 
  phase1(k)))));

% ry_twice_equiv_rev
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(ry1(k), infix_mnmn(ry1(kqt), 
  ry1(kqt))))));

% rx_twice_equiv_rev
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(rx1(k), infix_mnmn(rx1(kqt), 
  rx1(kqt))))));

% rz_twice_equiv_rev
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(rz1(k), infix_mnmn(rz1(kqt), 
  rz1(kqt))))));

% rzp_twice_equiv_rev
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(rzp(k), infix_mnmn(rzp(kqt), 
  rzp(kqt))))));

% phase_twice_equiv_rev
  ASSERT
  (FORALL (k : INT, kqt : INT):
  ((kqt = incr_abs(k)) => (infix_lseqgt(phase1(k), infix_mnmn(phase1(kqt), 
  phase1(kqt))))));

neutral_circ: (circuit2) -> BOOLEAN;

% neutral_circ'def
  ASSERT
  (FORALL (c : circuit2):
  ((neutral_circ(c)) <=> (infix_lseqgt(c, m_skip(width1(c))))));

% set_neutral_circ
  ASSERT
  (FORALL (c : circuit2):
  ((FORALL (x : matrix_complex):
   ((is_a_ket_l(x, width1(c)))
   => ((is_a_ket_basis_elt(x)) => (path_sem1(c, x) = x))))
  => (neutral_circ(c))));

% set_neutral_circ_bv
  ASSERT
  (FORALL (c : circuit2):
  ((FORALL (x : bitvec):
   ((length(x) = width1(c)) => (path_sem1(c, bv_to_ket(x)) = bv_to_ket(x))))
  => (neutral_circ(c))));

% get_neutral_circ
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((neutral_circ(c))
  => ((is_a_ket_l(x, width1(c))) => (path_sem1(c, x) = x))));

% neutral_skip
  ASSERT (neutral_circ(skip));

% neutral_m_skip
  ASSERT (FORALL (n : INT): ((1 <= n) => (neutral_circ(m_skip(n)))));

% m_skip_path_sem
  ASSERT
  (FORALL (n : INT, x : matrix_complex):
  ((1 <= n) => ((is_a_ket_l(x, n)) => (path_sem1(m_skip(n), x) = x))));

% neutral_equiv
  ASSERT
  (FORALL (c : circuit2, d : circuit2):
  ((neutral_circ(c))
  => ((neutral_circ(d)) => ((width1(c) = width1(d)) => (infix_lseqgt(c, d))))));

% cont_neutral
  ASSERT
  (FORALL (co : INT, k : INT, n : INT, c : circuit2):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => (((k <= co) => ((k + width1(c)) <= co))
        => (((0 <= co) AND (co < n))
           => ((neutral_circ(c)) => (neutral_circ(cont1(c, co, k, n)))))))));

% place_neutral
  ASSERT
  (FORALL (k : INT, n : INT, c : circuit2):
  ((0 <= k)
  => (((width1(c) + k) <= n)
     => ((neutral_circ(c)) => (neutral_circ(place1(c, k, n)))))));

cont_skip_to_place: (INT, INT, INT) -> circuit2;

% cont_skip_to_place'def
  ASSERT
  (FORALL (co : INT, ta : INT, n : INT):
  (((0 <= ta) AND (ta < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (co = ta)) => (cont_skip_to_place(co, ta, n) = place1(skip, ta,
        n))))));

% cont_skip_to_place'spec
  ASSERT
  (FORALL (co : INT, ta : INT, n : INT):
  (((0 <= ta) AND (ta < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (co = ta)) => (infix_lseqgt(cont_skip_to_place(co, ta, n), 
        cont1(skip, co, ta, n)))))));

% neutral_seq_left
  ASSERT
  (FORALL (c : circuit2, d : circuit2):
  ((width1(c) = width1(d))
  => ((neutral_circ(c)) => (infix_lseqgt(infix_mnmn(c, d), d)))));

% neutral_seq_right
  ASSERT
  (FORALL (c : circuit2, d : circuit2):
  ((width1(c) = width1(d))
  => ((neutral_circ(c)) => (infix_lseqgt(infix_mnmn(d, c), d)))));

% neutral_seq_had
  ASSERT (neutral_circ(infix_mnmn(hadamard1, hadamard1)));

% neutral_seq_swap
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2)) => (neutral_circ(infix_mnmn(swap1(t1, t2, n), 
        swap1(t1, t2, n))))))));

% neutral_seq_cnot
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (t1 = co)) => (neutral_circ(infix_mnmn(cnot1(co, t1, n), 
        cnot1(co, t1, n))))))));

% neutral_seq_toffoli
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (t1 = c1))
           => ((NOT (t1 = c2))
              => ((NOT (c2 = c1)) => (neutral_circ(infix_mnmn(toffoli1(c1,
                 c2, t1, n), toffoli1(c1, c2, t1, n)))))))))));

% neutral_seq_fredkin
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= c) AND (c < n))
        => ((NOT (c = t1))
           => ((NOT (c = t2))
              => ((NOT (t2 = t1)) => (neutral_circ(infix_mnmn(fredkin1(c, t1,
                 t2, n), fredkin1(c, t1, t2, n)))))))))));

% neutral_seq_ry
  ASSERT (FORALL (k : INT): (neutral_circ(infix_mnmn(ry1(k), ry1((- k))))));

% neutral_seq_ry_minus
  ASSERT (FORALL (k : INT): (neutral_circ(infix_mnmn(ry1((- k)), ry1(k)))));

% ang_exp_comp_one
  ASSERT
  (FORALL (k : INT): (infix_asdt(ang_exp(infix_sldtsl(1, incr_abs(k))), 
  ang_exp(infix_sldtsl(1, incr_abs((- k))))) = c_one));

% ang_exp_comp_one_minus
  ASSERT
  (FORALL (k : INT): (infix_asdt(ang_exp(infix_sldtsl((- 1), incr_abs(k))), 
  ang_exp(infix_sldtsl((- 1), incr_abs((- k))))) = c_one));

% neutral_seq_rz
  ASSERT (FORALL (k : INT): (neutral_circ(infix_mnmn(rz1(k), rz1((- k))))));

% neutral_seq_rz_minus
  ASSERT (FORALL (k : INT): (neutral_circ(infix_mnmn(rz1((- k)), rz1(k)))));

% neutral_seq_rzp
  ASSERT (FORALL (k : INT): (neutral_circ(infix_mnmn(rzp(k), rzp((- k))))));

% neutral_seq_phase
  ASSERT
  (FORALL (k : INT): (neutral_circ(infix_mnmn(phase1(k), phase1((- k))))));

% neutral_seq_rx
  ASSERT (FORALL (k : INT): (neutral_circ(infix_mnmn(rx1(k), rx1((- k))))));

% neutral_seq_rx_minus
  ASSERT (FORALL (k : INT): (neutral_circ(infix_mnmn(rx1((- k)), rx1(k)))));

% neutral_seq_yy
  ASSERT (neutral_circ(infix_mnmn(yy1, yy1)));

% neutral_seq_xx
  ASSERT (neutral_circ(infix_mnmn(xx1, xx1)));

% neutral_seq_zz
  ASSERT (neutral_circ(infix_mnmn(zz1, zz1)));

% to_qc_place
  ASSERT
  (FORALL (c : wired_circuit, c1 : wired_circuit, k : INT, n : INT):
  ((correct1(c))
  => ((c = Place(c1, k, n))
     => ((0 <= k)
        => (((width_pre1(c1) + k) <= n) => (to_qc1(c) = place1(to_qc1(c1), k,
           n)))))));

% to_qc_cont
  ASSERT
  (FORALL (c : wired_circuit, c1 : wired_circuit, co : INT, k : INT,
  n : INT):
  ((correct1(c))
  => ((c = Cont(c1, co, k, n))
     => (((0 <= co) AND (co < n))
        => (((0 <= k) AND (k <= (n - width_pre1(c1))))
           => (((k <= co) => ((k + width_pre1(c1)) <= co)) => (to_qc1(c) = 
              cont1(to_qc1(c1), co, k, n))))))));

% to_qc_seq
  ASSERT
  (FORALL (c : wired_circuit, c1 : wired_circuit, c2 : wired_circuit):
  ((correct1(c))
  => ((c = Sequence1(c1, c2))
     => ((width_pre1(c1) = width_pre1(c2)) => (to_qc1(c) = infix_mnmn(
        to_qc1(c1), to_qc1(c2)))))));

% to_qc_par
  ASSERT
  (FORALL (c : wired_circuit, c1 : wired_circuit, c2 : wired_circuit):
  ((correct1(c))
  => ((c = Parallel1(c1, c2)) => (to_qc1(c) = infix_slsl(to_qc1(c1), 
     to_qc1(c2))))));

% to_qc_cnot
  ASSERT
  (FORALL (c : wired_circuit, co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (t1 = co))
        => ((c = Cnot1(co, t1, n)) => (to_qc1(c) = cnot1(co, t1, n)))))));

% to_qc_swap
  ASSERT
  (FORALL (c : wired_circuit, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2))
        => ((c = Swap1(t1, t2, n)) => (to_qc1(c) = swap1(t1, t2, n)))))));

% to_qc_toffoli
  ASSERT
  (FORALL (c : wired_circuit, c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (t1 = c2))
                 => ((c = Toffoli(c1, c2, t1, n)) => (to_qc1(c) = 
                    toffoli1(c1, c2, t1, n))))))))));

% to_qc_fredkin
  ASSERT
  (FORALL (c : wired_circuit, co : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= co) AND (co < n))
        => ((NOT (co = t1))
           => ((NOT (co = t2))
              => ((NOT (t2 = t1))
                 => ((c = Fredkin(co, t1, t2, n)) => (to_qc1(c) = 
                    fredkin1(co, t1, t2, n))))))))));

% to_qc_place_
  ASSERT
  (FORALL (c : wired_circuit, k : INT, n : INT):
  ((correct1(c))
  => ((0 <= k)
     => (((width_pre1(c) + k) <= n) => (to_qc1(Place(c, k, n)) = place1(
        to_qc1(c), k, n))))));

% to_qc_cont_
  ASSERT
  (FORALL (c : wired_circuit, co : INT, k : INT, n : INT):
  ((correct1(c))
  => (((0 <= co) AND (co < n))
     => (((0 <= k) AND (k <= (n - width_pre1(c))))
        => (((k <= co) => ((k + width_pre1(c)) <= co)) => (to_qc1(Cont(c, co,
           k, n)) = cont1(to_qc1(c), co, k, n)))))));

% to_qc_seq_
  ASSERT
  (FORALL (c1 : wired_circuit, c2 : wired_circuit):
  ((correct1(c1))
  => ((correct1(c2))
     => ((width_pre1(c1) = width_pre1(c2)) => (to_qc1(Sequence1(c1, c2)) = 
        infix_mnmn(to_qc1(c1), to_qc1(c2)))))));

% to_qc_par_
  ASSERT
  (FORALL (c1 : wired_circuit, c2 : wired_circuit):
  ((correct1(c1))
  => ((correct1(c2)) => (to_qc1(Parallel1(c1, c2)) = infix_slsl(to_qc1(c1), 
     to_qc1(c2))))));

% to_qc_cnot_
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (t1 = co)) => (to_qc1(Cnot1(co, t1, n)) = cnot1(co, t1, n))))));

% to_qc_swap_
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2)) => (to_qc1(Swap1(t1, t2, n)) = swap1(t1, t2, n))))));

% to_qc_toffoli_
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (t1 = c2)) => (to_qc1(Toffoli(c1, c2, t1, n)) = 
                 toffoli1(c1, c2, t1, n)))))))));

% to_qc_fredkin_
  ASSERT
  (FORALL (co : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= co) AND (co < n))
        => ((NOT (co = t1))
           => ((NOT (co = t2))
              => ((NOT (t2 = t1)) => (to_qc1(Fredkin(co, t1, t2, n)) = 
                 fredkin1(co, t1, t2, n)))))))));

% to_qc_rx_
  ASSERT (FORALL (k : INT): (to_qc1(Rx(k)) = rx1(k)));

% to_qc_ry_
  ASSERT (FORALL (k : INT): (to_qc1(Ry(k)) = ry1(k)));

% to_qc_rz_
  ASSERT (FORALL (k : INT): (to_qc1(Rz1(k)) = rz1(k)));

% to_qc_rzp_
  ASSERT (FORALL (k : INT): (to_qc1(Rzp(k)) = rzp(k)));

% pre_place_
  ASSERT
  (FORALL (c : circuit2, k : INT, n : INT):
  ((0 <= k)
  => (((width1(c) + k) <= n) => (pre1(place1(c, k, n)) = Place(pre1(c), k,
     n)))));

% pre_cont_
  ASSERT
  (FORALL (c : circuit2, co : INT, k : INT, n : INT):
  (((0 <= co) AND (co < n))
  => (((0 <= k) AND (k <= (n - width1(c))))
     => (((k <= co) => ((k + width1(c)) <= co)) => (pre1(cont1(c, co, k,
        n)) = Cont(pre1(c), co, k, n))))));

% pre_seq_
  ASSERT
  (FORALL (c1 : circuit2, c2 : circuit2):
  ((width1(c1) = width1(c2)) => (pre1(infix_mnmn(c1, c2)) = Sequence1(
  pre1(c1), pre1(c2)))));

% pre_par_
  ASSERT
  (FORALL (c1 : circuit2, c2 : circuit2): (pre1(infix_slsl(c1, c2)) = 
  Parallel1(pre1(c1), pre1(c2))));

% pre_cnot_
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= co) AND (co < n))
     => ((NOT (t1 = co)) => (pre1(cnot1(co, t1, n)) = Cnot1(co, t1, n))))));

% pre_swap_
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => ((NOT (t1 = t2)) => (pre1(swap1(t1, t2, n)) = Swap1(t1, t2, n))))));

% pre_toffoli_
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
  (((0 <= c1) AND (c1 < n))
  => (((0 <= c2) AND (c2 < n))
     => (((0 <= t1) AND (t1 < n))
        => ((NOT (c1 = c2))
           => ((NOT (c1 = t1))
              => ((NOT (t1 = c2)) => (pre1(toffoli1(c1, c2, t1, n)) = 
                 Toffoli(c1, c2, t1, n)))))))));

% pre_fredkin_
  ASSERT
  (FORALL (co : INT, t1 : INT, t2 : INT, n : INT):
  (((0 <= t1) AND (t1 < n))
  => (((0 <= t2) AND (t2 < n))
     => (((0 <= co) AND (co < n))
        => ((NOT (co = t1))
           => ((NOT (co = t2))
              => ((NOT (t2 = t1)) => (pre1(fredkin1(co, t1, t2, n)) = 
                 Fredkin(co, t1, t2, n)))))))));

% pre_rx_
  ASSERT (FORALL (k : INT): (pre1(rx1(k)) = Rx(k)));

% pre_ry_
  ASSERT (FORALL (k : INT): (pre1(ry1(k)) = Ry(k)));

% pre_rz_
  ASSERT (FORALL (k : INT): (pre1(rz1(k)) = Rz1(k)));

% pre_rzp_
  ASSERT (FORALL (k : INT): (pre1(rzp(k)) = Rzp(k)));

ancilla_free_pre: (wired_circuit) -> BOOLEAN;

% ancilla_free_pre'def
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct1(c))
  => ((((((((((((((((((((((((((c = Skip) => (ancilla_free_pre(c)))
                            AND (FORALL (x : INT):
                                ((c = Phase1(x)) => (ancilla_free_pre(c)))))
                           AND (FORALL (x : INT):
                               ((c = Rx(x)) => (ancilla_free_pre(c)))))
                          AND (FORALL (x : INT):
                              ((c = Ry(x)) => (ancilla_free_pre(c)))))
                         AND (FORALL (x : INT):
                             ((c = Rz1(x)) => (ancilla_free_pre(c)))))
                        AND (FORALL (x : INT):
                            ((c = Rzp(x)) => (ancilla_free_pre(c)))))
                       AND ((c = Hadamard1) => (ancilla_free_pre(c))))
                      AND ((c = S) => (ancilla_free_pre(c))))
                     AND ((c = T) => (ancilla_free_pre(c))))
                    AND ((c = X) => (ancilla_free_pre(c))))
                   AND ((c = Y) => (ancilla_free_pre(c))))
                  AND ((c = Z) => (ancilla_free_pre(c))))
                 AND ((c = Bricks_Cnot) => (ancilla_free_pre(c))))
                AND ((c = Bricks_Toffoli) => (ancilla_free_pre(c))))
               AND ((c = Bricks_Fredkin) => (ancilla_free_pre(c))))
              AND ((c = Bricks_Swap) => (ancilla_free_pre(c))))
             AND (FORALL (x : INT, x1 : INT, x2 : INT):
                 ((c = Swap1(x, x1, x2)) => (ancilla_free_pre(c)))))
            AND (FORALL (x : INT, x1 : INT, x2 : INT):
                ((c = Cnot1(x, x1, x2)) => (ancilla_free_pre(c)))))
           AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT):
               ((c = Toffoli(x, x1, x2, x3)) => (ancilla_free_pre(c)))))
          AND (FORALL (x : INT, x1 : INT, x2 : INT, x3 : INT):
              ((c = Fredkin(x, x1, x2, x3)) => (ancilla_free_pre(c)))))
         AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT):
             ((c = Place(x, x1, x2))
             => ((ancilla_free_pre(c)) <=> (ancilla_free_pre(x))))))
        AND (FORALL (x : wired_circuit, x1 : INT, x2 : INT, x3 : INT):
            ((c = Cont(x, x1, x2, x3))
            => ((ancilla_free_pre(c)) <=> (ancilla_free_pre(x))))))
       AND (FORALL (x : wired_circuit, x1 : wired_circuit):
           ((c = Sequence1(x, x1))
           => ((ancilla_free_pre(c))
              <=> ((ancilla_free_pre(x)) AND (ancilla_free_pre(x1)))))))
      AND (FORALL (x : wired_circuit, x1 : wired_circuit):
          ((c = Parallel1(x, x1))
          => ((ancilla_free_pre(c))
             <=> ((ancilla_free_pre(x)) AND (ancilla_free_pre(x1)))))))
     AND (FORALL (x : wired_circuit, x1 : INT):
         ((c = Ancillas1(x, x1)) => (NOT (ancilla_free_pre(c))))))));

% ancilla_free_pre'spec
  ASSERT
  (FORALL (c : wired_circuit):
  ((build_correct1(c)) => ((ancilla_free_pre(c)) <=> (ancillas_pre(c) = 0))));

ancilla_free: (circuit2) -> BOOLEAN;

% ancilla_free'def
  ASSERT
  (FORALL (c : circuit2):
  ((ancilla_free(c)) <=> (ancilla_free_pre(pre1(c)))));

% ancilla_free'spec
  ASSERT (FORALL (c : circuit2): ((ancilla_free(c)) <=> (ancillas1(c) = 0)));

% set_ancilla_free
  ASSERT (FORALL (c : circuit2): ((ancillas1(c) = 0) => (ancilla_free(c))));

% ancilla_free_seq
  ASSERT
  (FORALL (c : circuit2, d : circuit2):
  ((width1(c) = width1(d))
  => ((ancilla_free(c))
     => ((ancilla_free(d)) => (ancilla_free(infix_mnmn(c, d)))))));

% phase_invol
  ASSERT
  (FORALL (k : INT, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x))
     => ((path_sem1(to_qc1(Phase1(k)), x) = y) => (path_sem1(to_qc1(
        Phase1((- k))), y) = x)))));

% rz_invol
  ASSERT
  (FORALL (k : INT, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x))
     => ((path_sem1(to_qc1(Rz1(k)), x) = y) => (path_sem1(to_qc1(Rz1((- k))),
        y) = x)))));

% ry_invol
  ASSERT
  (FORALL (k : INT, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x))
     => ((path_sem1(to_qc1(Ry(k)), x) = y) => (path_sem1(to_qc1(Ry((- k))),
        y) = x)))));

% rx_invol
  ASSERT
  (FORALL (k : INT, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x))
     => ((path_sem1(to_qc1(Rx(k)), x) = y) => (path_sem1(to_qc1(Rx((- k))),
        y) = x)))));

% rzp_invol
  ASSERT
  (FORALL (k : INT, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x))
     => ((path_sem1(to_qc1(Rzp(k)), x) = y) => (path_sem1(to_qc1(Rzp((- k))),
        y) = x)))));

% yy_invol
  ASSERT
  (FORALL (x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, 1))
  => ((is_a_ket_basis_elt(x))
     => ((path_sem1(to_qc1(Y), x) = y) => (path_sem1(to_qc1(Y), y) = x)))));

% swap_invol
  ASSERT
  (FORALL (t1 : INT, t2 : INT, n : INT, x : matrix_complex,
  y : matrix_complex):
  ((is_a_ket_l(x, n))
  => ((is_a_ket_basis_elt(x))
     => (((0 <= t1) AND (t1 < n))
        => (((0 <= t2) AND (t2 < n))
           => ((NOT (t1 = t2))
              => ((path_sem1(to_qc1(Swap1(t1, t2, n)), x) = y) => (path_sem1(
                 to_qc1(Swap1(t1, t2, n)), y) = x))))))));

% cnot_invol
  ASSERT
  (FORALL (co : INT, t1 : INT, n : INT, x : matrix_complex,
  y : matrix_complex):
  ((is_a_ket_l(x, n))
  => ((is_a_ket_basis_elt(x))
     => (((0 <= t1) AND (t1 < n))
        => (((0 <= co) AND (co < n))
           => ((NOT (t1 = co))
              => ((path_sem1(to_qc1(Cnot1(co, t1, n)), x) = y) => (path_sem1(
                 to_qc1(Cnot1(co, t1, n)), y) = x))))))));

% toffoli_invol
  ASSERT
  (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT, x : matrix_complex,
  y : matrix_complex):
  ((is_a_ket_l(x, n))
  => ((is_a_ket_basis_elt(x))
     => (((0 <= c1) AND (c1 < n))
        => (((0 <= c2) AND (c2 < n))
           => (((0 <= t1) AND (t1 < n))
              => ((NOT (t1 = c1))
                 => ((NOT (t1 = c2))
                    => ((NOT (c2 = c1))
                       => ((path_sem1(to_qc1(Toffoli(c1, c2, t1, n)), x) = y)
                          => (path_sem1(to_qc1(Toffoli(c1, c2, t1, n)),
                          y) = x)))))))))));

% fredkin_invol
  ASSERT
  (FORALL (c : INT, t1 : INT, t2 : INT, n : INT, x : matrix_complex,
  y : matrix_complex):
  ((is_a_ket_l(x, n))
  => ((is_a_ket_basis_elt(x))
     => (((0 <= t1) AND (t1 < n))
        => (((0 <= t2) AND (t2 < n))
           => (((0 <= c) AND (c < n))
              => ((NOT (c = t1))
                 => ((NOT (c = t2))
                    => ((NOT (t2 = t1))
                       => ((path_sem1(to_qc1(Fredkin(c, t1, t2, n)), x) = y)
                          => (path_sem1(to_qc1(Fredkin(c, t1, t2, n)),
                          y) = x)))))))))));

reverse_pre: (wired_circuit) -> wired_circuit;

% reverse_pre'def
  ASSERT
  (FORALL (c : wired_circuit):
  ((ancillas_pre(c) = 0)
  => ((correct1(c))
     => ((((((((((((((((((((((((((c = Skip) => (reverse_pre(c) = Skip))
                               AND (FORALL (k : INT):
                                   ((c = Phase1(k)) => (reverse_pre(c) = 
                                   Phase1((- k))))))
                              AND (FORALL (k : INT):
                                  ((c = Rx(k)) => (reverse_pre(c) = 
                                  Rx((- k))))))
                             AND (FORALL (k : INT):
                                 ((c = Ry(k)) => (reverse_pre(c) = 
                                 Ry((- k))))))
                            AND (FORALL (k : INT):
                                ((c = Rz1(k)) => (reverse_pre(c) = 
                                Rz1((- k))))))
                           AND (FORALL (k : INT):
                               ((c = Rzp(k)) => (reverse_pre(c) = 
                               Rzp((- k))))))
                          AND ((c = Hadamard1) => (
                              reverse_pre(c) = Hadamard1)))
                         AND ((c = S) => (reverse_pre(c) = Rzp((- 2)))))
                        AND ((c = T) => (reverse_pre(c) = Rzp((- 3)))))
                       AND ((c = X) => (reverse_pre(c) = X)))
                      AND ((c = Y) => (reverse_pre(c) = Y)))
                     AND ((c = Z) => (reverse_pre(c) = Z)))
                    AND ((c = Bricks_Cnot) => (reverse_pre(c) = Bricks_Cnot)))
                   AND ((c = Bricks_Toffoli) => (
                       reverse_pre(c) = Bricks_Toffoli)))
                  AND ((c = Bricks_Fredkin) => (
                      reverse_pre(c) = Bricks_Fredkin)))
                 AND ((c = Bricks_Swap) => (reverse_pre(c) = Bricks_Swap)))
                AND (FORALL (t1 : INT, t2 : INT, n : INT):
                    ((c = Swap1(t1, t2, n)) => (reverse_pre(c) = Swap1(t1,
                    t2, n)))))
               AND (FORALL (c1 : INT, t1 : INT, n : INT):
                   ((c = Cnot1(c1, t1, n)) => (reverse_pre(c) = Cnot1(c1, t1,
                   n)))))
              AND (FORALL (c1 : INT, c2 : INT, t1 : INT, n : INT):
                  ((c = Toffoli(c1, c2, t1, n)) => (reverse_pre(c) = 
                  Toffoli(c1, c2, t1, n)))))
             AND (FORALL (c1 : INT, t1 : INT, t2 : INT, n : INT):
                 ((c = Fredkin(c1, t1, t2, n)) => (reverse_pre(c) = 
                 Fredkin(c1, t1, t2, n)))))
            AND (FORALL (c1 : wired_circuit, p : INT, n : INT):
                ((c = Place(c1, p, n)) => (reverse_pre(c) = Place(
                reverse_pre(c1), p, n)))))
           AND (FORALL (c1 : wired_circuit, co : INT, t1 : INT, n : INT):
               ((c = Cont(c1, co, t1, n)) => (reverse_pre(c) = Cont(
               reverse_pre(c1), co, t1, n)))))
          AND (FORALL (d : wired_circuit, e : wired_circuit):
              ((c = Sequence1(d, e)) => (reverse_pre(c) = Sequence1(
              reverse_pre(e), reverse_pre(d))))))
         AND (FORALL (d : wired_circuit, e : wired_circuit):
             ((c = Parallel1(d, e)) => (reverse_pre(c) = Parallel1(
             reverse_pre(d), reverse_pre(e))))))
        AND (FORALL (d : wired_circuit, l : INT):
            ((c = Ancillas1(d, l)) => (reverse_pre(c) = Ancillas1(d, l))))))));

% reverse_pre'spec
  ASSERT
  (FORALL (c : wired_circuit):
  ((ancillas_pre(c) = 0)
  => ((correct1(c))
     => ((correct1(reverse_pre(c)))
        AND ((width_pre1(reverse_pre(c)) = width_pre1(c))
            AND ((size_pre(reverse_pre(c)) = size_pre(c))
                AND ((ancillas_pre(reverse_pre(c)) = 0)
                    AND ((width1(to_qc1(reverse_pre(c))) = width1(to_qc1(c)))
                        AND ((size1(to_qc1(reverse_pre(c))) = size1(
                            to_qc1(c)))
                            AND ((ancilla_free(to_qc1(reverse_pre(c))))
                                AND ((FORALL (x : matrix_complex,
                                     y : matrix_complex):
                                     ((is_a_ket_l(x, width_pre1(c)))
                                     => ((is_a_ket_basis_elt(x))
                                        => ((is_a_ket_l(y, width_pre1(c)))
                                           => (((path_sem1(to_qc1(c), x) = y)
                                               => (path_sem1(to_qc1(
                                               reverse_pre(c)), y) = x))
                                              AND ((path_sem1(to_qc1(
                                                  reverse_pre(c)), x) = y)
                                                  => (path_sem1(to_qc1(c),
                                                  y) = x)))))))
                                    AND (FORALL (x : matrix_complex,
                                        y : matrix_complex):
                                        ((is_a_ket_l(x, width_pre1(c)))
                                        => ((is_a_ket_l(y, width_pre1(c)))
                                           => ((path_sem1(to_qc1(c), x) = y)
                                              <=> (path_sem1(to_qc1(
                                              reverse_pre(c)), y) = x))))))))))))))));

reverse: (circuit2) -> circuit2;

% reverse'def
  ASSERT
  (FORALL (c : circuit2):
  ((ancilla_free(c)) => (reverse(c) = to_qc1(reverse_pre(pre1(c))))));

% reverse'spec
  ASSERT
  (FORALL (c : circuit2):
  ((ancilla_free(c))
  => ((width1(reverse(c)) = width1(c))
     AND ((size1(reverse(c)) = size1(c))
         AND ((ancilla_free(reverse(c)))
             AND (FORALL (x : matrix_complex, y : matrix_complex):
                 ((is_a_ket_l(x, width1(c)))
                 => ((is_a_ket_l(y, width1(c)))
                    => ((path_sem1(c, x) = y) <=> (path_sem1(reverse(c),
                       y) = x))))))))));

% reverse_invol
  ASSERT
  (FORALL (c : circuit2):
  ((ancilla_free(c)) => (infix_lseqgt(reverse(reverse(c)), c))));

% path_sem_reverse_invol
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((ancilla_free(c)) => (path_sem1(reverse(reverse(c)), x) = path_sem1(c,
     x)))));

% path_sem_reverse
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : matrix_complex):
  ((is_a_ket_l(x, width1(c)))
  => ((path_sem1(c, x) = y)
     => ((ancilla_free(c)) => (path_sem1(reverse(c), y) = x)))));

% sem_reverse
  ASSERT
  (FORALL (c : circuit2, x : matrix_complex, y : matrix_complex):
  ((sem1(c, x, y)) => ((ancilla_free(c)) => (sem1(reverse(c), y, x)))));

qft: (INT) -> circuit2;

% qft'def
  ASSERT (FORALL (n : INT): ((0 < n) => (qft(n) = reverse(qft_rev(n)))));

fc1127: (INT, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1127(n, x)), t2tb26(y))) = 
  infix_asdtdt(qft_rev_coeff(x, bv_inversion(y), n), bv_to_ket(y))));

% qft'spec
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => ((size1(qft(n)) <= polysquare(n, cont_size1, 0, 0))
     AND ((ancillas1(qft(n)) = 0)
         AND ((width1(qft(n)) = n)
             AND (FORALL (x : bitvec):
                 ((length(x) = n) => (path_sem1(qft(n), infix_asdtdt(
                 pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(n_bvs(n)), 
                 t2tb29(fc1127(n, x)), n))) = bv_to_ket(x)))))))));

int_qft_coeff: (INT, INT, INT) -> complex;

% int_qft_coeff'def
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_coeff(i, j, n) = ang_exp(infix_sldtsl((i * j), n)))));

% int_qft_coeff'spec
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n)
  => ((modulus(int_qft_coeff(i, j, n)) = c_one) AND (int_qft_coeff(i, j,
     n) = int_qft_rev_coeff((- i), int_bit_inversion(mod(j, power(2, n)), n),
     n)))));

% int_qft_coeff_rev
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_coeff(i, j, n) = int_qft_coeff(j, i, n))));

% int_qft_coeff_minus_to_right
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_coeff((- i), j, n) = int_qft_coeff(i, (- j), n))));

% int_qft_coeff_minus_to_left
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_coeff(i, (- j), n) = int_qft_coeff((- i), j, n))));

% int_qft_coeff_as_real
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_coeff(i, j, n) = ang_exp(real_to_ang(infix_asdt(
  i_to_c((i * j)), pow_inv_2(n)))))));

% int_qft_coeff_expo
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_coeff(i, j, n) = cpower(ang_exp(infix_sldtsl(i, n)),
  j))));

% int_qft_coeff_expo_
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_coeff(i, j, n) = cpower(ang_exp(infix_sldtsl(j, n)),
  i))));

% int_qft_coeff_as_mod
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_coeff(i, j, n) = int_qft_coeff(mod(i, power(2, n)), 
  mod(j, power(2, n)), n))));

% int_qft_rev_coeff_to_qft_coeff
  ASSERT
  (FORALL (i : INT, j : INT, n : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => (((0 <= j) AND (j < power(2, n))) => (int_qft_rev_coeff(i, j, n) = 
        int_qft_coeff(int_bit_inversion(j, n), (- i), n))))));

qft_rev_: (INT) -> circuit2;

% qft_rev_'def
  ASSERT (FORALL (n : INT): ((0 < n) => (qft_rev_(n) = qft_rev(n))));

fc1128: (INT, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc1128(n, x)), t2tb26(y))) = 
  infix_asdtdt(int_qft_coeff((- bv_to_int(y)), bv_to_int(x), n), 
  bv_to_ket(y))));

% qft_rev_'spec
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => ((size1(qft_rev_(n)) <= polysquare(n, cont_size1, 0, 0))
     AND ((ancillas1(qft_rev_(n)) = 0)
         AND ((width1(qft_rev_(n)) = n)
             AND ((FORALL (x : bitvec):
                  ((length(x) = n) => (path_sem1(qft_rev_(n), 
                  bv_to_ket(x)) = infix_asdtdt(pow_inv_sqrt_2(n), 
                  ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc1128(n, x)),
                  n)))))
                 AND ((FORALL (x : bitvec):
                      (FORALL (i : INT):
                      ((length(x) = n)
                      => (((0 <= i) AND (i < power(2, n))) => (tb2t(
                         get(complex1, t2tb18(path_sem1(qft_rev_(n), 
                         bv_to_ket(x))), i, 0)) = infix_asdt(
                         pow_inv_sqrt_2(n), int_qft_coeff((- i), 
                         bv_to_int(x), n)))))))
                     AND (FORALL (x : bitvec):
                         (FORALL (i : INT):
                         ((length(x) = n)
                         => (((0 <= i) AND (i < power(2, n))) => (tb2t(
                            get(complex1, t2tb18(path_sem1(qft_rev_(n), 
                            bv_to_ket(x))), i, 0)) = infix_asdt(
                            pow_inv_sqrt_2(n), int_qft_coeff(i, (- 
                            bv_to_int(x)), n))))))))))))));

fc705: (INT, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc705(n, x)), t2tb26(y))) = infix_asdtdt(
  int_qft_coeff((- ket_to_int(x)), bv_to_int(y), n), bv_to_ket(y))));

% path_sem_rev_qft_unit
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, n))
     => ((is_a_ket_basis_elt(x)) => (path_sem1(qft_rev(n), x) = infix_asdtdt(
        pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(
        fc705(n, x)), n))))))));

fc706: (INT, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, i : INT, y : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(fc706(n, i)), t2tb26(y))) = infix_asdtdt(
  int_qft_coeff((- i), bv_to_int(y), n), bv_to_ket(y))));

% path_sem_rev_qft_unit_int
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (i : INT):
     (((0 <= i) AND (i < power(2, n))) => (path_sem1(qft_rev(n), ket(n,
     i)) = infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(
     n_bvs(n)), t2tb29(fc706(n, i)), n)))))));

fc707: (INT, matrix_complex) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, x : matrix_complex, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc707(n, x)), t2tb26(y))) = infix_asdtdt(
  int_qft_coeff((- ket_to_int(x)), bv_to_int(y), n), bv_to_ket(y))));

% sem_rev_qft_unit
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, n))
     => ((is_a_ket_basis_elt(x)) => (sem1(qft_rev(n), x, infix_asdtdt(
        pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(
        fc707(n, x)), n)))))))));

fc708: (INT, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, i : INT, y : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(fc708(n, i)), t2tb26(y))) = infix_asdtdt(
  int_qft_coeff((- i), bv_to_int(y), n), bv_to_ket(y))));

% sem_rev_qft_unit_int
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (i : INT):
     (((0 <= i) AND (i < power(2, n))) => (sem1(qft_rev(n), ket(n, i), 
     infix_asdtdt(pow_inv_sqrt_2(n), ket_sum_l(bitvec1, t2tb28(n_bvs(n)), 
     t2tb29(fc708(n, i)), n))))))));

% int_qft_coeff_eq
  ASSERT
  (FORALL (i : INT, iqt : INT, j : INT, jqt : INT, n : INT, nqt : INT):
  ((n = nqt)
  => ((0 < n)
     => ((mod(i, power(2, n)) = mod(iqt, power(2, n)))
        => ((mod(j, power(2, n)) = mod(jqt, power(2, n))) => (
           int_qft_coeff(i, j, n) = int_qft_coeff(iqt, jqt, n)))))));

fc709: (INT, INT) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (i : INT, n : INT, y : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(fc709(i, n)), t2tb26(y))) = infix_asdtdt(int_qft_coeff(i, 
  bv_to_int(y), n), bv_to_ket(y))));

% rev_qft_apply_qft
  ASSERT
  (FORALL (i : INT, n : INT):
  ((0 < n) => (path_sem1(qft_rev(n), infix_asdtdt(pow_inv_sqrt_2(n), 
  ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc709(i, n)), n))) = ket(n, 
  mod(i, power(2, n))))));

apply_qft: (INT, INT) -> matrix_complex;

result86: (INT, INT) -> (ARRAY bitvec OF matrix_complex);

% result'def
  ASSERT
  (FORALL (n : INT, i : INT, y : bitvec): (tb2t18(infix_at(matrix(complex1),
  bitvec1, t2tb29(result86(n, i)), t2tb26(y))) = infix_asdtdt(
  int_qft_coeff(i, bv_to_int(y), n), bv_to_ket(y))));

% apply_qft'def
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n) => (apply_qft(n, i) = infix_asdtdt(pow_inv_sqrt_2(n), 
  ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(result86(n, i)), n)))));

% apply_qft'spec
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n)
  => ((is_a_ket_l(apply_qft(n, i), n)) AND (apply_qft(n, i) = path_sem1(
     qft(n), ket(n, mod(i, power(2, n))))))));

fc710: (ARRAY bitvec OF (ARRAY bitvec OF bitvec));

fc711: (INT) -> (ARRAY bitvec OF (ARRAY bitvec OF angle));

% fc'def
  ASSERT
  (FORALL (us : bitvec, y : bitvec): (tb2t26(infix_at(bitvec1, bitvec1, 
  infix_at(infix_mngt(bitvec1, bitvec1), bitvec1, t2tb58(fc710), t2tb26(us)), 
  t2tb26(y))) = y));

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec): (tb2t33(infix_at(angle1,
  bitvec1, infix_at(infix_mngt(bitvec1, angle1), bitvec1, t2tb60(fc711(n)), 
  t2tb26(x)), t2tb26(y))) = infix_sldtsl((bv_to_int(x) * bv_to_int(y)), n)));

% qft_correct_bv
  ASSERT
  (FORALL (n : INT):
  ((0 < n) => (correct_path_sum_bv1(qft(n), n, fc710, fc711(n)))));

fc712: (INT, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc712(n, x)), t2tb26(y))) = infix_asdtdt(
  int_qft_coeff((- bv_to_int(x)), bv_to_int(y), n), bv_to_ket(y))));

% path_sem_qft_pre
  ASSERT
  (FORALL (n : INT, x : bitvec):
  ((0 < n)
  => ((length(x) = n) => (path_sem1(qft(n), infix_asdtdt(pow_inv_sqrt_2(n), 
     ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc712(n, x)), n))) = 
     bv_to_ket(x)))));

fc713: (INT, bitvec) -> (ARRAY bitvec OF matrix_complex);

% fc'def
  ASSERT
  (FORALL (n : INT, x : bitvec, y : bitvec): (tb2t18(infix_at(
  matrix(complex1), bitvec1, t2tb29(fc713(n, x)), t2tb26(y))) = infix_asdtdt(
  int_qft_coeff((- bv_to_int(x)), bv_to_int(y), n), bv_to_ket(y))));

% path_sem_qft
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     ((length(x) = n) => (path_sem1(qft(n), infix_asdtdt(pow_inv_sqrt_2(n), 
     ket_sum_l(bitvec1, t2tb28(n_bvs(n)), t2tb29(fc713(n, x)), n))) = 
     bv_to_ket(x))))));

% get_ket_apply_qft
  ASSERT
  (FORALL (n : INT, i : INT, j : INT):
  ((0 < n)
  => (((0 <= j) AND (j < power(2, n))) => (tb2t(get(complex1, t2tb18(
     apply_qft(n, i)), j, 0)) = infix_asdt(pow_inv_sqrt_2(n), 
     int_qft_coeff(i, j, n))))));

% apply_qft_equiv
  ASSERT
  (FORALL (n : INT, i : INT, j : INT):
  ((0 < n)
  => ((mod(i, power(2, n)) = mod(j, power(2, n))) => (apply_qft(n, i) = 
     apply_qft(n, j)))));

% apply_qft_mod
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n) => (apply_qft(n, mod(i, power(2, n))) = apply_qft(n, i))));

% qft_rev_qft_int
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n) => (path_sem1(qft_rev(n), apply_qft(n, i)) = ket(n, mod(i, 
  power(2, n))))));

% from_qft_basis
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (path_sem1(qft_rev(n), apply_qft(n,
     i)) = ket(n, i)))));

% qft_apply_basis
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n) => (path_sem1(qft(n), ket(n, mod(i, power(2, n)))) = apply_qft(n,
  i))));

% sem_qft_rev_qft_int
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n) => (sem1(qft_rev(n), apply_qft(n, i), ket(n, mod(i, power(2,
  n)))))));

% sem_from_qft_basis
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n))) => (sem1(qft_rev(n), apply_qft(n, i), 
     ket(n, i))))));

% sem_qft_apply_basis
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n) => (sem1(qft(n), ket(n, mod(i, power(2, n))), apply_qft(n, i)))));

% apply_qft_eq
  ASSERT
  (FORALL (n : INT, nqt : INT, i : INT, iqt : INT):
  ((0 < n)
  => ((n = nqt)
     => ((mod(i, power(2, n)) = mod(iqt, power(2, n))) => (apply_qft(n, i) = 
        apply_qft(nqt, iqt))))));

apply_qft_as_mod: (INT, INT) -> tuple0;

% apply_qft_as_mod'def
  ASSERT
  (FORALL (n : INT, i : INT): ((0 < n) => (apply_qft_as_mod(n, i) = Tuple0)));

% apply_qft_as_mod'spec
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n) => (apply_qft(n, i) = apply_qft(n, mod(i, power(2, n))))));

% int_qft_coeff_add
  ASSERT
  (FORALL (i : INT, iqt : INT, j : INT, n : INT):
  ((0 < n) => (int_qft_coeff((i + iqt), j, n) = infix_asdt(int_qft_coeff(i,
  j, n), int_qft_coeff(iqt, j, n)))));

% path_sem_qft_unit
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : matrix_complex):
     ((is_a_ket_l(x, n))
     => ((is_a_ket_basis_elt(x)) => (path_sem1(qft(n), x) = apply_qft(n, 
        ket_to_int(x))))))));

% path_sem_qft_bv
  ASSERT
  (FORALL (n : INT):
  ((0 < n)
  => (FORALL (x : bitvec):
     ((length(x) = n) => (path_sem1(qft(n), bv_to_ket(x)) = apply_qft(n, 
     bv_to_int(x)))))));

% to_qft_basis
  ASSERT
  (FORALL (n : INT, i : INT):
  ((0 < n)
  => (((0 <= i) AND (i < power(2, n)))
     => (FORALL (x : bitvec):
        ((length(x) = n) => (path_sem1(qft(n), ket(n, i)) = apply_qft(n, i)))))));

place_qft_zero: (INT, INT) -> circuit2;

% place_qft_zero'def
  ASSERT
  (FORALL (n : INT, k : INT):
  ((0 < n)
  => ((0 < k) => (place_qft_zero(n, k) = place1(qft(n), 0, (n + k))))));

% place_qft_zero'spec
  ASSERT
  (FORALL (n : INT, k : INT):
  ((0 < n)
  => ((0 < k)
     => ((width1(place_qft_zero(n, k)) = (n + k))
        AND ((size1(place_qft_zero(n, k)) <= polysquare(n, cont_size1, 0, 0))
            AND ((ancillas1(place_qft_zero(n, k)) = 0)
                AND ((FORALL (g : INT):
                     (FORALL (y : matrix_complex):
                     (((0 <= g) AND (g < power(2, n)))
                     => ((is_a_ket_l(y, k)) => (sem1(place_qft_zero(n, k), 
                        kronecker(ket(n, g), y), kronecker(apply_qft(n, g),
                        y)))))))
                    AND (width1(place_qft_zero(n, k)) = (n + k)))))))));

place_rev_qft_zero: (INT, INT) -> circuit2;

% place_rev_qft_zero'def
  ASSERT
  (FORALL (n : INT, k : INT):
  ((0 < n)
  => ((0 < k) => (place_rev_qft_zero(n, k) = reverse(place_qft_zero(n, k))))));

% place_rev_qft_zero'spec
  ASSERT
  (FORALL (n : INT, k : INT):
  ((0 < n)
  => ((0 < k)
     => ((width1(place_rev_qft_zero(n, k)) = (n + k))
        AND ((size1(place_rev_qft_zero(n, k)) <= polysquare(n, cont_size1, 0,
            0))
            AND ((ancillas1(place_rev_qft_zero(n, k)) = 0)
                AND (FORALL (g : INT):
                    (FORALL (y : matrix_complex):
                    (((0 <= g) AND (g < power(2, n)))
                    => ((is_a_ket_l(y, k)) => (sem1(place_rev_qft_zero(n, k), 
                       kronecker(apply_qft(n, g), y), kronecker(ket(n, g),
                       y)))))))))))));

place_qft: (INT, INT, INT) -> circuit2;

% place_qft'def
  ASSERT
  (FORALL (n : INT, k : INT, size_reg : INT):
  ((0 < n)
  => ((0 < k)
     => (((k + n) < size_reg) => (place_qft(n, k, size_reg) = place1(qft(n),
        k, size_reg))))));

% place_qft'spec
  ASSERT
  (FORALL (n : INT, k : INT, size_reg : INT):
  ((0 < n)
  => ((0 < k)
     => (((k + n) < size_reg)
        => ((width1(place_qft(n, k, size_reg)) = size_reg)
           AND ((size1(place_qft(n, k, size_reg)) <= polysquare(n,
               cont_size1, 0, 0))
               AND ((ancillas1(place_qft(n, k, size_reg)) = 0)
                   AND ((FORALL (g : INT):
                        (FORALL (y : matrix_complex, z : matrix_complex):
                        (((0 <= g) AND (g < power(2, n)))
                        => ((is_a_ket_l(y, k))
                           => ((is_a_ket_l(z, ((size_reg - k) - n)))
                              => (sem1(place_qft(n, k, size_reg), 
                              kronecker(y, kronecker(ket(n, g), z)), 
                              kronecker(y, kronecker(apply_qft(n, g), z)))))))))
                       AND (width1(place_qft(n, k, size_reg)) = size_reg)))))))));

place_rev_qft: (INT, INT, INT) -> circuit2;

% place_rev_qft'def
  ASSERT
  (FORALL (n : INT, k : INT, size_reg : INT):
  ((0 < n)
  => ((0 < k)
     => (((k + n) < size_reg) => (place_rev_qft(n, k, size_reg) = reverse(
        place_qft(n, k, size_reg)))))));

% place_rev_qft'spec
  ASSERT
  (FORALL (n : INT, k : INT, size_reg : INT):
  ((0 < n)
  => ((0 < k)
     => (((k + n) < size_reg)
        => ((width1(place_rev_qft(n, k, size_reg)) = size_reg)
           AND ((size1(place_rev_qft(n, k, size_reg)) <= polysquare(n,
               cont_size1, 0, 0))
               AND ((ancillas1(place_rev_qft(n, k, size_reg)) = 0)
                   AND ((FORALL (g : INT):
                        (FORALL (y : matrix_complex, z : matrix_complex):
                        (((0 <= g) AND (g < power(2, n)))
                        => ((is_a_ket_l(y, k))
                           => ((is_a_ket_l(z, ((size_reg - k) - n)))
                              => (sem1(place_rev_qft(n, k, size_reg), 
                              kronecker(y, kronecker(apply_qft(n, g), z)), 
                              kronecker(y, kronecker(ket(n, g), z)))))))))
                       AND (width1(place_rev_qft(n, k,
                       size_reg)) = size_reg)))))))));

apply_function_in_qft_basis: (circuit2, INT, INT, INT,
  (ARRAY INT OF INT)) -> circuit2;

% apply_function_in_qft_basis'spec
  ASSERT
  (FORALL (c : circuit2, n : INT, k : INT, size_reg : INT,
  f : (ARRAY INT OF INT)):
  ((0 < n)
  => ((0 < k)
     => (((k + n) < size_reg)
        => ((width1(c) = size_reg)
           => ((FORALL (i : INT):
               (((0 <= i) AND (i < power(2, n)))
               => ((0 <= (f[i])) AND ((f[i]) < power(2, n)))))
              => ((size1(apply_function_in_qft_basis(c, n, k, size_reg,
                 f)) <= (polysquare(n, (cont_size1 * 2), 0, 0) + size1(c)))
                 AND ((ancillas1(apply_function_in_qft_basis(c, n, k,
                     size_reg, f)) = ancillas1(c))
                     AND ((width1(apply_function_in_qft_basis(c, n, k,
                         size_reg, f)) = size_reg)
                         AND ((FORALL (y : matrix_complex,
                              z : matrix_complex):
                              (FORALL (i : INT):
                              (((0 <= i) AND (i < power(2, n)))
                              => ((is_a_ket_l(y, k))
                                 => ((is_a_ket_l(z, ((size_reg - n) - k)))
                                    => ((path_sem1(c, kronecker(y, kronecker(
                                       apply_qft(n, i), z))) = kronecker(y, 
                                       kronecker(apply_qft(n, (f[i])), z)))
                                       => (path_sem1(
                                       apply_function_in_qft_basis(c, n, k,
                                       size_reg, f), kronecker(y, kronecker(
                                       ket(n, i), z))) = kronecker(y, 
                                       kronecker(ket(n, (f[i])), z)))))))))
                             AND (apply_function_in_qft_basis(c, n, k,
                             size_reg, f) = infix_mnmn(infix_mnmn(
                             place_qft(n, k, size_reg), c), place_rev_qft(n,
                             k, size_reg)))))))))))));

apply_function_in_qft_basis_gen: (circuit2, INT, INT, INT) -> circuit2;

% apply_function_in_qft_basis_gen'def
  ASSERT
  (FORALL (c : circuit2, n : INT, k : INT, size_reg : INT):
  ((0 < n)
  => ((0 < k)
     => (((k + n) < size_reg)
        => ((width1(c) = size_reg) => (apply_function_in_qft_basis_gen(c, n,
           k, size_reg) = infix_mnmn(infix_mnmn(place_qft(n, k, size_reg),
           c), place_rev_qft(n, k, size_reg))))))));

% apply_function_in_qft_basis_gen'spec
  ASSERT
  (FORALL (c : circuit2, n : INT, k : INT, size_reg : INT):
  ((0 < n)
  => ((0 < k)
     => (((k + n) < size_reg)
        => ((width1(c) = size_reg)
           => ((size1(apply_function_in_qft_basis_gen(c, n, k,
              size_reg)) <= (polysquare(n, (cont_size1 * 2), 0, 0) + 
              size1(c)))
              AND ((ancillas1(apply_function_in_qft_basis_gen(c, n, k,
                  size_reg)) = ancillas1(c))
                  AND ((width1(apply_function_in_qft_basis_gen(c, n, k,
                      size_reg)) = size_reg)
                      AND (FORALL (y : matrix_complex, z : matrix_complex):
                          (FORALL (i : INT):
                          (FORALL (f : (ARRAY INT OF INT)):
                          (((0 <= i) AND (i < power(2, n)))
                          => ((is_a_ket_l(y, k))
                             => ((is_a_ket_l(z, ((size_reg - n) - k)))
                                => ((FORALL (iqt : INT):
                                    (((0 <= iqt) AND (iqt < power(2, n)))
                                    => ((0 <= (f[iqt])) AND ((f[iqt]) < 
                                       power(2, n)))))
                                   => ((path_sem1(c, kronecker(y, kronecker(
                                      apply_qft(n, i), z))) = kronecker(y, 
                                      kronecker(apply_qft(n, (f[i])), z)))
                                      => (path_sem1(
                                      apply_function_in_qft_basis_gen(c, n,
                                      k, size_reg), kronecker(y, kronecker(
                                      ket(n, i), z))) = kronecker(y, 
                                      kronecker(ket(n, (f[i])), z)))))))))))))))))));

apply_function_in_qft_basis_zero: (circuit2, INT, INT,
  (ARRAY INT OF INT)) -> circuit2;

% apply_function_in_qft_basis_zero'spec
  ASSERT
  (FORALL (c : circuit2, n : INT, size_reg : INT, f : (ARRAY INT OF INT)):
  ((0 < n)
  => ((n < size_reg)
     => ((width1(c) = size_reg)
        => ((FORALL (i : INT):
            (((0 <= i) AND (i < power(2, n)))
            => ((0 <= (f[i])) AND ((f[i]) < power(2, n)))))
           => ((size1(apply_function_in_qft_basis_zero(c, n, size_reg,
              f)) <= (polysquare(n, (cont_size1 * 2), 0, 0) + size1(c)))
              AND ((ancillas1(apply_function_in_qft_basis_zero(c, n,
                  size_reg, f)) = ancillas1(c))
                  AND ((width1(apply_function_in_qft_basis_zero(c, n,
                      size_reg, f)) = size_reg)
                      AND ((FORALL (z : matrix_complex):
                           (FORALL (i : INT):
                           (((0 <= i) AND (i < power(2, n)))
                           => ((is_a_ket_l(z, (size_reg - n)))
                              => ((sem1(c, kronecker(apply_qft(n, i), z), 
                                 kronecker(apply_qft(n, (f[i])), z)))
                                 => (sem1(apply_function_in_qft_basis_zero(c,
                                 n, size_reg, f), kronecker(ket(n, i), z), 
                                 kronecker(ket(n, (f[i])), z))))))))
                          AND ((FORALL (z : matrix_complex):
                               (FORALL (i : INT):
                               (((0 <= i) AND (i < power(2, n)))
                               => ((is_a_ket_l(z, (size_reg - n)))
                                  => ((path_sem1(c, kronecker(apply_qft(n,
                                     i), z)) = kronecker(apply_qft(n,
                                     (f[i])), z)) => (path_sem1(
                                     apply_function_in_qft_basis_zero(c, n,
                                     size_reg, f), kronecker(ket(n, i),
                                     z)) = kronecker(ket(n, (f[i])), z)))))))
                              AND (apply_function_in_qft_basis_zero(c, n,
                              size_reg, f) = infix_mnmn(infix_mnmn(
                              place_qft_zero(n, (size_reg - n)), c), 
                              place_rev_qft_zero(n, (size_reg - n))))))))))))));

apply_from_qft_zero: (INT, INT, circuit2) -> circuit2;

% apply_from_qft_zero'spec
  ASSERT
  (FORALL (n : INT, k : INT, c : circuit2):
  ((0 < n)
  => ((0 < k)
     => ((width1(c) = (n + k))
        => ((size1(apply_from_qft_zero(n, k, c)) <= (polysquare(n,
           (cont_size1 * 2), 0, 0) + size1(c)))
           AND ((ancillas1(apply_from_qft_zero(n, k, c)) = ancillas1(c))
               AND ((width1(apply_from_qft_zero(n, k, c)) = (n + k))
                   AND (FORALL (y : matrix_complex, z : matrix_complex):
                       (FORALL (i : INT):
                       (((0 <= i) AND (i < power(2, n)))
                       => ((is_a_ket_l(y, k))
                          => ((is_a_ket_l(z, k))
                             => ((sem1(c, kronecker(ket(n, i), y), kronecker(
                                ket(n, i), z))) => (sem1(
                                apply_from_qft_zero(n, k, c), kronecker(
                                apply_qft(n, i), y), kronecker(apply_qft(n,
                                i), z))))))))))))))));

apply_in_qft_zero: (INT, INT, circuit2) -> circuit2;

% apply_in_qft_zero'spec
  ASSERT
  (FORALL (n : INT, k : INT, c : circuit2):
  ((0 < n)
  => ((0 < k)
     => ((width1(c) = (n + k))
        => ((size1(apply_in_qft_zero(n, k, c)) <= (polysquare(n,
           (cont_size1 * 2), 0, 0) + size1(c)))
           AND ((ancillas1(apply_in_qft_zero(n, k, c)) = ancillas1(c))
               AND ((width1(apply_in_qft_zero(n, k, c)) = (n + k))
                   AND (FORALL (y : matrix_complex, z : matrix_complex):
                       (FORALL (i : INT):
                       (((0 <= i) AND (i < power(2, n)))
                       => ((is_a_ket_l(y, k))
                          => ((is_a_ket_l(z, k))
                             => ((sem1(c, kronecker(apply_qft(n, i), y), 
                                kronecker(apply_qft(n, i), z))) => (sem1(
                                apply_in_qft_zero(n, k, c), kronecker(ket(n,
                                i), y), kronecker(ket(n, i), z))))))))))))))));

apply_from_qft_zero_path: (INT, INT, circuit2) -> circuit2;

% apply_from_qft_zero_path'def
  ASSERT
  (FORALL (n : INT, k : INT, c : circuit2):
  ((0 < n)
  => ((0 < k)
     => ((width1(c) = (n + k)) => (apply_from_qft_zero_path(n, k, c) = 
        apply_from_qft_zero(n, k, c))))));

% apply_from_qft_zero_path'spec
  ASSERT
  (FORALL (n : INT, k : INT, c : circuit2):
  ((0 < n)
  => ((0 < k)
     => ((width1(c) = (n + k))
        => ((size1(apply_from_qft_zero_path(n, k, c)) <= (polysquare(n,
           (cont_size1 * 2), 0, 0) + size1(c)))
           AND ((ancillas1(apply_from_qft_zero_path(n, k, c)) = ancillas1(c))
               AND ((width1(apply_from_qft_zero_path(n, k, c)) = (n + k))
                   AND (FORALL (y : matrix_complex, z : matrix_complex):
                       (FORALL (i : INT):
                       ((is_a_ket_l(y, k))
                       => ((is_a_ket_l(z, k))
                          => ((path_sem1(c, kronecker(ket(n, mod(i, power(2,
                             n))), y)) = kronecker(ket(n, mod(i, power(2,
                             n))), z)) => (path_sem1(
                             apply_from_qft_zero_path(n, k, c), kronecker(
                             apply_qft(n, i), y)) = kronecker(apply_qft(n,
                             i), z))))))))))))));

apply_in_qft_zero_path: (INT, INT, circuit2) -> circuit2;

% apply_in_qft_zero_path'def
  ASSERT
  (FORALL (n : INT, k : INT, c : circuit2):
  ((0 < n)
  => ((0 < k)
     => ((width1(c) = (n + k)) => (apply_in_qft_zero_path(n, k, c) = 
        apply_from_qft_zero(n, k, c))))));

% apply_in_qft_zero_path'spec
  ASSERT
  (FORALL (n : INT, k : INT, c : circuit2):
  ((0 < n)
  => ((0 < k)
     => ((width1(c) = (n + k))
        => ((size1(apply_in_qft_zero_path(n, k, c)) <= (polysquare(n,
           (cont_size1 * 2), 0, 0) + size1(c)))
           AND ((ancillas1(apply_in_qft_zero_path(n, k, c)) = ancillas1(c))
               AND ((width1(apply_in_qft_zero_path(n, k, c)) = (n + k))
                   AND (FORALL (y : matrix_complex, z : matrix_complex):
                       (FORALL (i : INT):
                       (((0 <= i) AND (i < power(2, n)))
                       => ((is_a_ket_l(y, k))
                          => ((is_a_ket_l(z, k))
                             => ((path_sem1(c, kronecker(apply_qft(n, i),
                                y)) = kronecker(apply_qft(n, i), z)) => (
                                path_sem1(apply_in_qft_zero_path(n, k, c), 
                                kronecker(ket(n, i), y)) = kronecker(ket(n,
                                i), z)))))))))))))));

divisors: (INT) -> set_int;

result87: (INT) -> (ARRAY INT OF BITVECTOR(1));

% result'def
  ASSERT
  (FORALL (i : INT, j : INT):
  ((tb2t2(infix_at(bool, int, t2tb9(result87(i)), t2tb5(j))) = 0bin1)
  <=> (((1 <= j) AND (j <= i)) AND (mod(i, j) = 0))));

% divisors'def
  ASSERT
  (FORALL (i : INT):
  ((0 < i) => (divisors(i) = tb2t6(my_filter(int, t2tb6(to_fset(1, (i + 1))), 
  t2tb9(result87(i)))))));

% divisors'spec
  ASSERT
  (FORALL (i : INT):
  ((0 < i)
  => ((FORALL (j : INT):
      ((mem(int, t2tb5(j), t2tb6(divisors(i)))) => ((0 < j) AND (j <= i))))
     AND ((FORALL (j : INT):
          ((mem(int, t2tb5(j), t2tb6(divisors(i)))) => (mod(i, j) = 0)))
         AND ((FORALL (j : INT):
              ((mem(int, t2tb5(j), t2tb6(divisors(i))))
              => (EXISTS (k : INT):
                 (((1 <= k) AND (k <= i)) AND (i = (k * j))))))
             AND ((FORALL (j : INT):
                  (((1 <= j) AND (j <= i))
                  => ((mod(i, j) = 0) => (mem(int, t2tb5(j), t2tb6(
                     divisors(i)))))))
                 AND (FORALL (j : INT):
                     (((1 <= j) AND (j <= i))
                     => ((EXISTS (k : INT):
                         (((1 <= k) AND (k <= i)) AND (i = (k * j))))
                        => (mem(int, t2tb5(j), t2tb6(divisors(i)))))))))))));

% set_mem_divisors
  ASSERT
  (FORALL (j : INT, i : INT):
  ((0 < i)
  => (((1 <= j) AND (j <= i))
     => ((mod(i, j) = 0) => (mem(int, t2tb5(j), t2tb6(divisors(i))))))));

% get_mem_divisors_mod
  ASSERT
  (FORALL (j : INT, i : INT):
  ((0 < i) => ((mem(int, t2tb5(j), t2tb6(divisors(i)))) => (mod(i, j) = 0))));

% get_mem_divisors_bounds
  ASSERT
  (FORALL (j : INT, i : INT):
  ((0 < i)
  => ((mem(int, t2tb5(j), t2tb6(divisors(i)))) => ((1 <= j) AND (j <= i)))));

% get_mem_divisors_inf
  ASSERT
  (FORALL (j : INT, i : INT):
  ((0 < i) => ((mem(int, t2tb5(j), t2tb6(divisors(i)))) => (j <= i))));

% get_mem_divisors
  ASSERT
  (FORALL (j : INT, i : INT):
  ((0 < i)
  => ((mem(int, t2tb5(j), t2tb6(divisors(i))))
     => ((mod(i, j) = 0) AND ((1 <= j) AND (j <= i))))));

% in_divisors_mult
  ASSERT
  (FORALL (i : INT, j : INT, k : INT):
  ((1 <= k)
  => ((0 < j)
     => ((mem(int, t2tb5(i), t2tb6(divisors(j)))) => (mem(int, t2tb5(i), 
        t2tb6(divisors((j * k)))))))));

% in_divisors_powers
  ASSERT
  (FORALL (a : INT, b : INT, bqt : INT, i : INT):
  ((1 <= a)
  => ((1 <= i)
     => (((0 <= b) AND (b <= bqt))
        => ((mem(int, t2tb5(i), t2tb6(divisors(power(a, b))))) => (mem(int, 
           t2tb5(i), t2tb6(divisors(power(a, bqt))))))))));

% powers_in_divisors
  ASSERT
  (FORALL (a : INT, b : INT, bqt : INT, i : INT):
  ((1 <= a)
  => ((1 <= i)
     => (((0 <= b) AND (b <= bqt))
        => ((mem(int, t2tb5(power(a, bqt)), t2tb6(divisors(i)))) => (mem(int, 
           t2tb5(power(a, b)), t2tb6(divisors(i)))))))));

% not_powers_in_divisors
  ASSERT
  (FORALL (a : INT, b : INT, bqt : INT, i : INT):
  ((1 <= a)
  => ((1 <= i)
     => (((0 <= b) AND (b <= bqt))
        => ((NOT (mem(int, t2tb5(power(a, b)), t2tb6(divisors(i)))))
           => (NOT (mem(int, t2tb5(power(a, bqt)), t2tb6(divisors(i))))))))));

% itself_divisors
  ASSERT
  (FORALL (i : INT): ((0 < i) => (mem(int, t2tb5(i), t2tb6(divisors(i))))));

% unicity_div_rev
  ASSERT
  (FORALL (i : INT, j : INT, q : INT):
  ((0 < i)
  => ((mem(int, t2tb5(j), t2tb6(divisors(i))))
     => ((q = div(i, j)) => (i = (q * j))))));

% mem_own_divisors
  ASSERT
  (FORALL (i : INT): ((0 < i) => (mem(int, t2tb5(i), t2tb6(divisors(i))))));

% mem_one_divisors
  ASSERT
  (FORALL (i : INT): ((0 < i) => (mem(int, t2tb5(1), t2tb6(divisors(i))))));

% trivial_divisors_left
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 < i) => ((0 < j) => (mem(int, t2tb5(i), t2tb6(divisors((i * j))))))));

% trivial_divisors_right
  ASSERT
  (FORALL (i : INT, j : INT):
  ((0 < i) => ((0 < j) => (mem(int, t2tb5(i), t2tb6(divisors((j * i))))))));

prime: (INT) -> BOOLEAN;

% prime'def
  ASSERT
  (FORALL (a : INT):
  ((prime(a))
  <=> ((0 < a) AND (divisors(a) = tb2t6(add(int, t2tb5(a), add(int, t2tb5(1), 
      empty(int))))))));

% get_not_prime
  ASSERT
  (FORALL (a : INT):
  ((0 < a)
  => ((NOT (prime(a)))
     => (EXISTS (b : INT):
        (((1 < b) AND (b < a)) AND (mem(int, t2tb5(b), t2tb6(divisors(a)))))))));

% set_not_prime
  ASSERT
  (FORALL (a : INT):
  ((0 < a)
  => ((EXISTS (b : INT):
      (((1 < b) AND (b < a)) AND (mem(int, t2tb5(b), t2tb6(divisors(a))))))
     => (NOT (prime(a))))));

% card_prime_divisors
  ASSERT
  (FORALL (a : INT):
  ((1 < a) => ((prime(a)) => (cardinal(int, t2tb6(divisors(a))) = 2))));

co_prime: (INT, INT) -> BOOLEAN;

% co_prime'def
  ASSERT
  (FORALL (a : INT, b : INT):
  ((co_prime(a, b))
  <=> ((0 < a)
      AND ((0 < b) AND (tb2t6(inter(int, t2tb6(divisors(a)), t2tb6(
          divisors(b)))) = tb2t6(add(int, t2tb5(1), empty(int))))))));

% symetric_co_prime
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a) => ((0 < b) => ((co_prime(a, b)) => (co_prime(b, a))))));

% prime_is_co_prime_right
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a)
  => ((prime(b))
     => ((NOT (mem(int, t2tb5(b), t2tb6(divisors(a))))) => (co_prime(a, b))))));

% prime_is_co_prime
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a)
  => ((prime(b))
     => ((NOT (mem(int, t2tb5(b), t2tb6(divisors(a))))) => (co_prime(b, a))))));

% prime_are_co_primes
  ASSERT
  (FORALL (a : INT, b : INT):
  ((NOT (a = b)) => ((prime(b)) => ((prime(a)) => (co_prime(a, b))))));

% one_is_co_prime
  ASSERT (FORALL (a : INT): ((0 < a) => (co_prime(a, 1))));

% mem_divisors_trans
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < c)
  => ((mem(int, t2tb5(b), t2tb6(divisors(c))))
     => ((mem(int, t2tb5(a), t2tb6(divisors(b)))) => (mem(int, t2tb5(a), 
        t2tb6(divisors(c))))))));

% subset_divisors
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < b)
  => ((mem(int, t2tb5(a), t2tb6(divisors(b)))) => (subset(int, t2tb6(
     divisors(a)), t2tb6(divisors(b)))))));

% not_prime_divisors
  ASSERT
  (FORALL (a : INT):
  ((1 < a)
  => ((NOT (prime(a)))
     => ((2 < cardinal(int, t2tb6(divisors(a))))
        AND (EXISTS (i : INT):
            ((mem(int, t2tb5(i), t2tb6(divisors(a))))
            AND ((NOT (i = 1)) AND (NOT (i = a)))))))));

% strict_subset_divisors
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < b)
  => ((NOT (a = b))
     => ((mem(int, t2tb5(a), t2tb6(divisors(b))))
        => ((subset(int, t2tb6(divisors(a)), t2tb6(divisors(b))))
           AND ((NOT (divisors(a) = divisors(b))) AND (cardinal(int, t2tb6(
               divisors(a))) < cardinal(int, t2tb6(divisors(b))))))))));

% divisors_contains_prime
  ASSERT
  (FORALL (i : INT):
  ((1 < i)
  => (EXISTS (j : INT):
     ((prime(j)) AND ((1 < j) AND (mem(int, t2tb5(j), t2tb6(divisors(i)))))))));

% set_not_co_prime
  ASSERT
  (FORALL (a : INT, b : INT, k : INT):
  ((0 < a)
  => ((0 < b)
     => ((NOT (a = b))
        => (((1 < k) AND (k <= a))
           => (((1 < k) AND (k <= b))
              => ((mod(a, k) = 0)
                 => ((mod(b, k) = 0) => (NOT (co_prime(a, b)))))))))));

% set_not_co_prime_
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a)
  => ((0 < b)
     => ((NOT (a = b))
        => ((EXISTS (k : INT):
            (((1 < k) AND (k <= a))
            AND (((1 < k) AND (k <= b))
                AND ((mod(a, k) = 0) AND (mod(b, k) = 0)))))
           => (NOT (co_prime(a, b))))))));

% set_co_prime
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a)
  => ((0 < b)
     => ((NOT (a = b))
        => ((FORALL (c : INT):
            ((mem(int, t2tb5(c), t2tb6(divisors(a))))
            => ((NOT (c = 1))
               => (NOT (mem(int, t2tb5(c), t2tb6(divisors(b))))))))
           => (co_prime(a, b)))))));

% co_prime_to_mod
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a)
  => ((1 < b) => ((NOT (a = b)) => ((co_prime(a, b)) => (0 < mod(a, b)))))));

% co_prime_to_mod_right
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 < a)
  => ((0 < b) => ((NOT (a = b)) => ((co_prime(a, b)) => (0 < mod(b, a)))))));

% inter_div_mod
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a)
  => ((1 < b)
     => ((co_prime(a, b)) => (subset(int, inter(int, t2tb6(divisors(mod(a,
        b))), t2tb6(divisors(b))), inter(int, t2tb6(divisors(a)), t2tb6(
        divisors(b)))))))));

% co_prime_mod
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a) => ((1 < b) => ((co_prime(a, b)) => (co_prime(mod(a, b), b))))));

% co_prime_by_primes
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a)
  => ((1 < b)
     => ((NOT (a = b))
        => ((FORALL (c : INT):
            ((prime(c))
            => ((NOT (c = 1))
               => ((mem(int, t2tb5(c), t2tb6(divisors(a))))
                  => (NOT (mem(int, t2tb5(c), t2tb6(divisors(b)))))))))
           => (co_prime(a, b)))))));

% euclid_lemma_pre
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < a)
  => ((0 < b)
     => ((0 < c)
        => ((prime(c))
           => ((mod((a * b), c) = 0)
              => ((NOT (mod(b, c) = 0)) => (mod(a, c) = 0))))))));

% euclid_lemma
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < a)
  => ((0 < b)
     => ((0 < c)
        => ((prime(c))
           => ((mod((a * b), c) = 0)
              => ((NOT (mod(b, c) = 0)) => (mod(a, c) = 0))))))));

% divisors_euclid_lemma
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < a)
  => ((0 < b)
     => ((0 < c)
        => ((prime(c))
           => ((mem(int, t2tb5(c), t2tb6(divisors((a * b)))))
              => ((NOT (mem(int, t2tb5(c), t2tb6(divisors(b))))) => (mem(int, 
                 t2tb5(c), t2tb6(divisors(a)))))))))));

bounded_primes: (INT) -> set_int;

prime_closure: (ARRAY INT OF BITVECTOR(1));

% prime_closure_def
  ASSERT
  (FORALL (y : INT):
  ((tb2t2(infix_at(bool, int, t2tb9(prime_closure), t2tb5(y))) = 0bin1)
  <=> (prime(y))));

% bounded_primes'def
  ASSERT
  (FORALL (a : INT):
  ((0 <= a) => (bounded_primes(a) = tb2t6(my_filter(int, t2tb6(to_fset(1,
  (a + 1))), t2tb9(prime_closure))))));

% bounded_primes'spec
  ASSERT
  (FORALL (a : INT):
  ((0 <= a)
  => ((FORALL (i : INT):
      ((mem(int, t2tb5(i), t2tb6(bounded_primes(a)))) => (prime(i))))
     AND ((FORALL (i : INT):
          ((mem(int, t2tb5(i), t2tb6(bounded_primes(a))))
          => ((1 <= i) AND (i <= a))))
         AND (FORALL (i : INT):
             (((1 <= i) AND (i <= a))
             => ((prime(i)) => (mem(int, t2tb5(i), t2tb6(
                bounded_primes(a)))))))))));

prime_factors: (INT, INT) -> INT;

result88: (INT, INT) -> (ARRAY INT OF BITVECTOR(1));

% result'def
  ASSERT
  (FORALL (a : INT, b : INT, i : INT):
  ((tb2t2(infix_at(bool, int, t2tb9(result88(a, b)), t2tb5(i))) = 0bin1)
  <=> (mem(int, t2tb5(power(b, i)), t2tb6(divisors(a))))));

% prime_factors'def
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a)
  => (IF ((1 < b) AND (prime(b))) THEN (prime_factors(a, b) = max_filter(
     to_fset(0, (a + 1)), result88(a, b))) ELSE (prime_factors(a,
     b) = 0) ENDIF)));

% prime_factors'spec
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a)
  => ((0 <= prime_factors(a, b))
     AND ((FORALL (j : INT):
          (((0 <= j) AND (j <= prime_factors(a, b))) => (mem(int, t2tb5(
          power(b, j)), t2tb6(divisors(a))))))
         AND ((((1 < b) AND (prime(b))) => (prime_factors(a, b) < a))
             AND ((((1 < b) AND (prime(b)))
                  => (FORALL (j : INT):
                     ((prime_factors(a, b) < j)
                     => (NOT (mem(int, t2tb5(power(b, j)), t2tb6(
                        divisors(a))))))))
                 AND (((1 < b) AND (prime(b)))
                     => (FORALL (j : INT):
                        ((prime_factors(a, b) < j)
                        => (NOT (mem(int, t2tb5(b), t2tb6(divisors(div(a, 
                           power(b, prime_factors(a, b)))))))))))))))));

% set_prime_factors
  ASSERT
  (FORALL (a : INT, b : INT, i : INT):
  ((1 <= a)
  => ((prime(b))
     => ((1 < b)
        => ((mod(a, power(b, i)) = 0)
           => ((NOT (mod(a, power(b, (i + 1))) = 0)) => (prime_factors(a,
              b) = i)))))));

% set_prime_factors_null
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a)
  => ((prime(b))
     => ((1 < b) => ((NOT (mod(a, b) = 0)) => (prime_factors(a, b) = 0))))));

% set_prime_factors_over
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a) => ((a < b) => (prime_factors(a, b) = 0))));

% set_prime_factors_not_prime
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a) => ((NOT (prime(b))) => (prime_factors(a, b) = 0))));

% set_prime_factors_one
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a) => ((b = 1) => (prime_factors(a, b) = 0))));

% set_prime_factors_diff
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a)
  => ((prime(b))
     => ((prime(a)) => ((NOT (a = b)) => (prime_factors(a, b) = 0))))));

% get_prime_factors
  ASSERT
  (FORALL (a : INT, b : INT, i : INT):
  ((1 <= a)
  => ((prime(b))
     => ((1 < b)
        => ((prime_factors(a, b) = i)
           => ((mod(a, power(b, i)) = 0)
              AND (NOT (mod(a, power(b, (i + 1))) = 0))))))));

% prime_factors_itself
  ASSERT
  (FORALL (a : INT): ((1 < a) => ((prime(a)) => (prime_factors(a, a) = 1))));

% prime_factors_one
  ASSERT (FORALL (a : INT): ((1 < a) => (prime_factors(a, 1) = 0)));

fc714: (INT) -> (ARRAY INT OF INT);

fc715: (INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (a : INT, i : INT): ((fc714(a)[i]) = power(i, prime_factors(a,
  i))));

% fc'def
  ASSERT
  (FORALL (a : INT, i : INT): ((fc715(a)[i]) = power(i, prime_factors(a,
  i))));

% prime_factors_up
  ASSERT
  (FORALL (a : INT):
  ((1 <= a)
  => ((FORALL (b : INT): ((a < b) => (prime_factors(a, b) = 0)))
     AND (FORALL (b : INT):
         ((a < b) => (ind_iproduct(fc714(a), 0, (b + 1)) = ind_iproduct(
         fc715(a), 0, (a + 1))))))));

fc716: (INT) -> (ARRAY INT OF INT);

fc717: (INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (a : INT, i : INT): ((fc716(a)[i]) = power(i, prime_factors(a,
  i))));

% fc'def
  ASSERT
  (FORALL (a : INT, i : INT): ((fc717(a)[i]) = power(i, prime_factors(a,
  i))));

% prime_factors_up_set
  ASSERT
  (FORALL (a : INT, b : INT):
  (((1 <= a) AND (a <= b)) => (ind_iproduct(fc716(a), 0, (b + 1)) = 
  ind_iproduct(fc717(a), 0, (a + 1)))));

% prime_factors_mult
  ASSERT
  (FORALL (a : INT, aqt : INT, b : INT):
  ((1 <= a)
  => ((1 <= aqt) => (prime_factors((a * aqt), b) = (prime_factors(a, b) + 
     prime_factors(aqt, b))))));

fc718: (INT, INT) -> (ARRAY INT OF INT);

fc719: (INT) -> (ARRAY INT OF INT);

fc720: (INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (a : INT, aqt : INT, i : INT): ((fc718(a, aqt)[i]) = power(i, 
  prime_factors((a * aqt), i))));

% fc'def
  ASSERT
  (FORALL (a : INT, i : INT): ((fc719(a)[i]) = power(i, prime_factors(a,
  i))));

% fc'def
  ASSERT
  (FORALL (aqt : INT, i : INT): ((fc720(aqt)[i]) = power(i, 
  prime_factors(aqt, i))));

% prime_factors_mult_gen
  ASSERT
  (FORALL (a : INT, aqt : INT):
  ((1 <= a)
  => ((1 <= aqt) => (ind_iproduct(fc718(a, aqt), 0, ((a * aqt) + 1)) = (
     ind_iproduct(fc719(a), 0, ((a * aqt) + 1)) * ind_iproduct(fc720(aqt), 0,
     ((a * aqt) + 1)))))));

proper_divisors: (INT) -> set_int;

% proper_divisors'def
  ASSERT
  (FORALL (a : INT):
  ((1 < a)
  => ((NOT (prime(a))) => (proper_divisors(a) = tb2t6(remove(int, t2tb5(a), 
     remove(int, t2tb5(1), t2tb6(divisors(a)))))))));

% proper_divisors'spec
  ASSERT
  (FORALL (a : INT):
  ((1 < a)
  => ((NOT (prime(a)))
     => ((EXISTS (i : INT): (mem(int, t2tb5(i), t2tb6(proper_divisors(a)))))
        AND ((FORALL (i : INT):
             ((mem(int, t2tb5(i), t2tb6(proper_divisors(a)))) => (mem(int, 
             t2tb5(i), t2tb6(divisors(a))))))
            AND ((FORALL (i : INT):
                 ((mem(int, t2tb5(i), t2tb6(proper_divisors(a))))
                 => ((1 < i) AND (i < a))))
                AND ((FORALL (i : INT):
                     ((((1 < i) AND (i < a)) AND (mod(a, i) = 0))
                     => (mem(int, t2tb5(i), t2tb6(proper_divisors(a))))))
                    AND ((FORALL (i : INT):
                         ((mem(int, t2tb5(i), t2tb6(proper_divisors(a))))
                         => (mem(int, t2tb5(div(a, i)), t2tb6(
                         proper_divisors(a))))))
                        AND (FORALL (i : INT):
                            ((mem(int, t2tb5(i), t2tb6(proper_divisors(a))))
                            => (cardinal(int, t2tb6(divisors(i))) < 
                            cardinal(int, t2tb6(divisors(a))))))))))))));

prime_divisors: (INT) -> set_int;

% prime_divisors'def
  ASSERT
  (FORALL (a : INT):
  ((1 < a)
  => ((NOT (prime(a))) => (prime_divisors(a) = tb2t6(my_filter(int, t2tb6(
     proper_divisors(a)), t2tb9(prime_closure)))))));

% prime_divisors'spec
  ASSERT
  (FORALL (a : INT):
  ((1 < a)
  => ((NOT (prime(a)))
     => ((EXISTS (i : INT): (mem(int, t2tb5(i), t2tb6(prime_divisors(a)))))
        AND ((FORALL (i : INT):
             ((mem(int, t2tb5(i), t2tb6(prime_divisors(a)))) => (mem(int, 
             t2tb5(i), t2tb6(divisors(a))))))
            AND ((FORALL (i : INT):
                 ((mem(int, t2tb5(i), t2tb6(prime_divisors(a))))
                 => (prime(i))))
                AND ((FORALL (i : INT):
                     ((mem(int, t2tb5(i), t2tb6(prime_divisors(a))))
                     => ((1 < i) AND (i < a))))
                    AND ((FORALL (i : INT):
                         ((((1 < i) AND (i < a))
                          AND ((mod(a, i) = 0) AND (prime(i))))
                         => (mem(int, t2tb5(i), t2tb6(prime_divisors(a))))))
                        AND ((FORALL (i : INT):
                             ((mem(int, t2tb5(i), t2tb6(prime_divisors(a))))
                             => (mem(int, t2tb5(div(a, i)), t2tb6(
                             proper_divisors(a))))))
                            AND (FORALL (i : INT):
                                ((mem(int, t2tb5(i), t2tb6(
                                prime_divisors(a)))) => (cardinal(int, t2tb6(
                                divisors(i))) < cardinal(int, t2tb6(
                                divisors(a)))))))))))))));

% unicity_div_rev_
  ASSERT
  (FORALL (i : INT, j : INT, q : INT):
  ((0 < i)
  => ((mem(int, t2tb5(j), t2tb6(divisors(i))))
     => ((q = div(i, j)) => (i = (j * q))))));

fc721: (INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (a : INT, i : INT): ((fc721(a)[i]) = power(i, prime_factors(a,
  i))));

% factors_prod
  ASSERT
  (FORALL (a : INT):
  ((1 <= a)
  => (FORALL (x : INT):
     ((a <= x) => (a = ind_iproduct(fc721(a), 0, (x + 1)))))));

% divisors_by_factor_decomp_pre
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a)
  => ((mem(int, t2tb5(b), t2tb6(divisors(a))))
     => (FORALL (i : INT): (prime_factors(b, i) <= prime_factors(a, i))))));

% divisors_by_factor_decomp_pre_
  ASSERT
  (FORALL (a : INT, b : INT, i : INT):
  ((1 <= a)
  => ((mem(int, t2tb5(b), t2tb6(divisors(a)))) => (prime_factors(b, i) <= 
     prime_factors(a, i)))));

% divisors_by_factor_decomp_pre_rec
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a)
  => (((1 <= b) AND (b <= a))
     => ((FORALL (i : INT): (prime_factors(b, i) <= prime_factors(a, i)))
        => (mem(int, t2tb5(b), t2tb6(divisors(a))))))));

% inf_by_prime_factors
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  (((1 <= a) AND (a <= c))
  => ((1 <= b)
     => ((FORALL (i : INT): (prime_factors(b, i) <= prime_factors(a, i)))
        => (b <= a)))));

% co_prime_to_prod
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((1 < b)
  => ((0 < c)
     => ((co_prime(a, c)) => ((co_prime(b, c)) => (co_prime((a * b), c)))))));

% co_prime_to_prod_rev
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((1 < b)
  => ((0 < c)
     => ((co_prime(a, c)) => ((co_prime(b, c)) => (co_prime(c, (a * b))))))));

% co_prime_pow
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < b) => ((co_prime(a, b)) => ((0 < c) => (co_prime(power(a, c), b))))));

% co_prime_pows
  ASSERT
  (FORALL (a : INT, b : INT, c : INT, d : INT):
  ((0 < b)
  => ((co_prime(a, b))
     => ((0 <= c) => ((0 <= d) => (co_prime(power(a, c), power(b, d))))))));

fc722: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

fc723: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((fc722(f)[i]) = power(i,
  (f[i]))));

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((fc723(f)[i]) = power(i,
  (f[i]))));

% div_iproduct_primes
  ASSERT
  (FORALL (bound : INT, f : (ARRAY INT OF INT)):
  ((0 <= bound)
  => ((FORALL (i : INT): ((1 <= i) => ((NOT (prime(i))) => ((f[i]) = 0))))
     => ((FORALL (i : INT): ((1 <= i) => (0 <= (f[i]))))
        => (((f[0]) = 0)
           => ((FORALL (j : INT):
               ((bound < j)
               => ((prime(j)) => (co_prime(j, ind_iproduct(fc722(f), 0,
                  (bound + 1)))))))
              AND (FORALL (j : INT):
                  (((1 <= j) AND (j <= bound))
                  => ((prime(j))
                     => (((f[j]) = 0) => (co_prime(j, ind_iproduct(fc723(f),
                        0, (bound + 1))))))))))))));

fc724: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((fc724(f)[i]) = power(i,
  (f[i]))));

% unicity_factors_prod_one
  ASSERT
  (FORALL (bound : INT, f : (ARRAY INT OF INT)):
  ((0 <= bound)
  => ((FORALL (i : INT): ((NOT (prime(i))) => ((f[i]) = 0)))
     => (((f[1]) = 0)
        => ((FORALL (i : INT): ((1 <= i) => (0 <= (f[i]))))
           => ((1 = ind_iproduct(fc724(f), 0, (bound + 1)))
              => ((FORALL (i : INT):
                  ((prime(i)) => ((bound < i) => ((f[i]) = 0))))
                 => (FORALL (i : INT): ((prime(i)) => ((f[i]) = 0))))))))));

fc725: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((fc725(f)[i]) = power(i,
  (f[i]))));

% unicity_factors_prod_pre
  ASSERT
  (FORALL (a : INT, bound : INT, f : (ARRAY INT OF INT)):
  ((FORALL (i : INT): ((prime(i)) => ((bound < i) => ((f[i]) = 0))))
  => ((FORALL (i : INT): ((NOT (prime(i))) => ((f[i]) = 0)))
     => (((f[1]) = 0)
        => ((FORALL (i : INT): ((1 <= i) => (0 <= (f[i]))))
           => (((1 <= a) AND (a <= bound))
              => ((a = ind_iproduct(fc725(f), 0, (bound + 1)))
                 => (FORALL (i : INT): (prime_factors(a, i) = (f[i]))))))))));

fc726: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((fc726(f)[i]) = power(i,
  (f[i]))));

% unicity_factors_prod
  ASSERT
  (FORALL (a : INT, c : INT, f : (ARRAY INT OF INT)):
  ((1 <= c)
  => ((FORALL (i : INT): (0 <= (f[i])))
     => ((a = ind_iproduct(fc726(f), 0, (c + 1)))
        => ((FORALL (i : INT): ((f[i]) <= prime_factors(c, i))) => (mem(int, 
           t2tb5(a), t2tb6(divisors(c)))))))));

fc727: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((fc727(f)[i]) = power(i,
  (f[i]))));

% unicity_factors_prod_
  ASSERT
  (FORALL (c : INT, f : (ARRAY INT OF INT)):
  ((1 <= c)
  => ((FORALL (i : INT): (0 <= (f[i])))
     => ((FORALL (i : INT): ((f[i]) <= prime_factors(c, i))) => (mem(int, 
        t2tb5(ind_iproduct(fc727(f), 0, (c + 1))), t2tb6(divisors(c))))))));

fc728: ((ARRAY INT OF INT)) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (f : (ARRAY INT OF INT), i : INT): ((fc728(f)[i]) = power(i,
  (f[i]))));

% unicity_factors_prod_gen
  ASSERT
  (FORALL (bound : INT, c : INT, f : (ARRAY INT OF INT)):
  (((1 <= c) AND (c <= bound))
  => ((FORALL (i : INT): (0 <= (f[i])))
     => ((FORALL (i : INT): ((f[i]) <= prime_factors(c, i))) => (mem(int, 
        t2tb5(ind_iproduct(fc728(f), 0, (bound + 1))), t2tb6(divisors(c))))))));

gcd: (INT, INT) -> INT;

result89: (INT, INT) -> (ARRAY INT OF INT);

% result'def
  ASSERT
  (FORALL (a : INT, b : INT, i : INT): ((result89(a, b)[i]) = power(i, min(
  prime_factors(a, i), prime_factors(b, i)))));

% gcd'def
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a)
  => ((1 <= b) => (gcd(a, b) = ind_iproduct(result89(a, b), 0,
     ((a * b) + 1))))));

% gcd'spec
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a)
  => ((1 <= b)
     => ((FORALL (i : INT): (prime_factors(gcd(a, b), i) = min(
         prime_factors(a, i), prime_factors(b, i))))
        AND ((mem(int, t2tb5(gcd(a, b)), t2tb6(divisors(a))))
            AND ((mem(int, t2tb5(gcd(a, b)), t2tb6(divisors(b))))
                AND (FORALL (j : INT):
                    ((mem(int, t2tb5(j), t2tb6(divisors(a))))
                    => ((mem(int, t2tb5(j), t2tb6(divisors(b)))) => (mem(int, 
                       t2tb5(j), t2tb6(divisors(gcd(a, b))))))))))))));

% gcd_prime_factors
  ASSERT
  (FORALL (a : INT, b : INT, i : INT):
  ((1 <= a)
  => ((1 <= b) => (prime_factors(gcd(a, b), i) = min(prime_factors(a, i), 
     prime_factors(b, i))))));

scm: (INT, INT) -> INT;

% scm'spec
  ASSERT
  (FORALL (a : INT, b : INT):
  ((1 <= a)
  => ((1 <= b)
     => ((FORALL (i : INT): (prime_factors(scm(a, b), i) = max(
         prime_factors(a, i), prime_factors(b, i))))
        AND ((mem(int, t2tb5(a), t2tb6(divisors(scm(a, b)))))
            AND ((mem(int, t2tb5(b), t2tb6(divisors(scm(a, b)))))
                AND (FORALL (j : INT):
                    ((0 < j)
                    => ((mem(int, t2tb5(a), t2tb6(divisors(j))))
                       => ((mem(int, t2tb5(b), t2tb6(divisors(j))))
                          => (mem(int, t2tb5(scm(a, b)), t2tb6(
                          divisors(j))))))))))))));

% divisors_mult
  ASSERT
  (FORALL (a : INT, b : INT, k : INT, i : INT):
  ((0 < a)
  => ((0 < b)
     => ((1 <= k)
        => ((mem(int, t2tb5((a * b)), t2tb6(divisors(k))))
           => ((prime_factors(a, i) <= prime_factors(k, i)) AND (
              prime_factors(b, i) <= prime_factors(k, i))))))));

% prime_factors_to_div
  ASSERT
  (FORALL (a : INT, i : INT):
  ((0 < a)
  => ((0 < prime_factors(a, i)) => (mem(int, t2tb5(i), t2tb6(divisors(a)))))));

% prime_factors_not_prime
  ASSERT
  (FORALL (a : INT, i : INT):
  ((0 < a)
  => ((0 < prime_factors(a, i)) => ((NOT (a = i)) => (NOT (prime(a)))))));

% prime_factors_not_one
  ASSERT
  (FORALL (a : INT, i : INT):
  ((0 < a) => ((0 < prime_factors(a, i)) => (NOT (a = 1)))));

% prime_prime_factors
  ASSERT
  (FORALL (a : INT, i : INT):
  ((NOT (a = 1))
  => ((prime(a)) => (prime_factors(a, i) = (IF (a = i) THEN 1 ELSE 0 ENDIF)))));

% mem_div_by_fact
  ASSERT
  (FORALL (a : INT, c : INT):
  ((1 <= c)
  => ((1 <= a)
     => ((FORALL (i : INT): (prime_factors(a, i) <= prime_factors(c, i)))
        => (mem(int, t2tb5(a), t2tb6(divisors(c))))))));

% div_prime
  ASSERT
  (FORALL (a : INT, i : INT):
  ((0 < a)
  => ((0 < prime_factors(a, i))
     => ((NOT (a = i)) => (mem(int, t2tb5(i), t2tb6(divisors(a))))))));

% not_co_prime_itself
  ASSERT (FORALL (a : INT): ((1 < a) => (NOT (co_prime(a, a)))));

% co_prime_gcd
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a)
  => ((0 < b)
     => ((co_prime(a, b))
        => (FORALL (i : INT): (prime_factors(gcd(a, b), i) = 0))))));

% co_prime_gcd_rev
  ASSERT
  (FORALL (a : INT, b : INT):
  ((0 < a)
  => ((0 < b)
     => ((FORALL (i : INT): (prime_factors(gcd(a, b), i) = 0))
        => (co_prime(a, b))))));

% divisors_euclid_lemma_co_prime
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < a)
  => ((0 < b)
     => ((0 < c)
        => ((mem(int, t2tb5(c), t2tb6(divisors((a * b)))))
           => ((co_prime(b, c))
              => (FORALL (cqt : INT):
                 ((mem(int, t2tb5(cqt), t2tb6(divisors(c)))) => (mem(int, 
                 t2tb5(cqt), t2tb6(divisors(a))))))))))));

% divisors_euclid_lemma_co_prime_itself
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < a)
  => ((0 < b)
     => ((0 < c)
        => ((mem(int, t2tb5(c), t2tb6(divisors((a * b)))))
           => ((co_prime(b, c)) => (mem(int, t2tb5(c), t2tb6(divisors(a))))))))));

% euclid_lemma_co_prime
  ASSERT
  (FORALL (a : INT, b : INT, c : INT):
  ((0 < a)
  => ((0 < b)
     => ((0 < c)
        => ((co_prime(b, c)) => ((co_prime(a, c)) => (co_prime((a * b), c))))))));

% co_prime_odd
  ASSERT
  (FORALL (a : INT, i : INT):
  ((0 < a) => ((0 < i) => ((odd(a) = 0bin1) => (co_prime(power(2, i), a))))));

co_primes: (INT) -> set_int;

co_prime_closure: (ARRAY INT OF (ARRAY INT OF BITVECTOR(1)));

t2tb69: ((ARRAY INT OF (ARRAY INT OF BITVECTOR(1)))) -> uni;

% t2tb_sort
  ASSERT
  (FORALL (x : (ARRAY INT OF (ARRAY INT OF BITVECTOR(1)))): (sort(
  infix_mngt(int, infix_mngt(int, bool)), t2tb69(x))));

tb2t69: (uni) -> (ARRAY INT OF (ARRAY INT OF BITVECTOR(1)));

% BridgeL
  ASSERT
  (FORALL (i : (ARRAY INT OF (ARRAY INT OF BITVECTOR(1)))):PATTERN (
  t2tb69(i)):  (tb2t69(t2tb69(i)) = i));

% BridgeR
  ASSERT
  (FORALL (j : uni):PATTERN (t2tb69(tb2t69(j))): 
  ((sort(infix_mngt(int, infix_mngt(int, bool)), j)) => (t2tb69(
  tb2t69(j)) = j)));

% co_prime_closure_def
  ASSERT
  (FORALL (y : INT, y1 : INT):
  ((tb2t2(infix_at(bool, int, infix_at(infix_mngt(int, bool), int, 
  t2tb69(co_prime_closure), t2tb5(y)), t2tb5(y1))) = 0bin1) <=> (co_prime(y,
  y1))));

% co_primes'def
  ASSERT
  (FORALL (i : INT):
  ((0 < i) => (co_primes(i) = tb2t6(my_filter(int, t2tb6(to_fset(0, i)), 
  infix_at(infix_mngt(int, bool), int, t2tb69(co_prime_closure), 
  t2tb5(i)))))));

% co_primes'spec
  ASSERT
  (FORALL (i : INT):
  ((0 < i)
  => (((1 < i) => (mem(int, t2tb5(1), t2tb6(co_primes(i)))))
     AND (((1 < i) => (mem(int, t2tb5(cardinal(int, t2tb6(co_primes(i)))), 
          t2tb6(to_fset(1, i)))))
         AND ((FORALL (j : INT):
              ((mem(int, t2tb5(j), t2tb6(co_primes(i))))
              => ((0 < j) AND (j < i))))
             AND ((FORALL (j : INT):
                  ((mem(int, t2tb5(j), t2tb6(co_primes(i)))) => (co_prime(i,
                  j))))
                 AND (FORALL (j : INT):
                     (((0 <= j) AND (j < i))
                     => ((co_prime(i, j)) => (mem(int, t2tb5(j), t2tb6(
                        co_primes(i)))))))))))));

% co_prime_iproduct
  ASSERT
  (FORALL (s2 : set_int, f : (ARRAY INT OF INT), bound : INT):
  ((0 < bound)
  => ((FORALL (e : INT): ((mem(int, t2tb5(e), t2tb6(s2))) => (0 < (f[e]))))
     => ((FORALL (e : INT):
         ((mem(int, t2tb5(e), t2tb6(s2))) => (co_prime((f[e]), bound))))
        => (co_prime(iproduct(int, t2tb6(s2), t2tb7(f)), bound))))));

greatest_factor_in_n: (INT, INT, INT) -> INT;

% greatest_factor_in_n'def
  ASSERT
  (FORALL (multi : INT, n : INT, i : INT):
  ((0 < n)
  => (((0 < multi) AND (multi < power(2, n)))
     => (((0 <= i) AND (i < multi))
        => (IF (i < mod(power(2, n), multi)) THEN (
           greatest_factor_in_n(multi, n, i) = (div(power(2, n), multi) + 1))
           ELSE (greatest_factor_in_n(multi, n, i) = div(power(2, n),
           multi)) ENDIF)))));

% greatest_factor_in_n'spec
  ASSERT
  (FORALL (multi : INT, n : INT, i : INT):
  ((0 < n)
  => (((0 < multi) AND (multi < power(2, n)))
     => (((0 <= i) AND (i < multi))
        => ((1 <= greatest_factor_in_n(multi, n, i))
           AND ((FORALL (j : INT):
                (((0 <= j) AND (j < greatest_factor_in_n(multi, n, i)))
                => (((j * multi) + mod(i, multi)) < power(2, n))))
               AND ((FORALL (j : INT):
                    (((0 <= j) AND (j < power(2, n)))
                    => ((mod(j, multi) = i)
                       <=> (EXISTS (k : INT):
                           (((0 <= k) AND (k < greatest_factor_in_n(multi, n,
                            i)))
                           AND (j = ((k * multi) + i)))))))
                   AND (infix_lseqdt(i_to_c((greatest_factor_in_n(multi, n,
                   i) - 1)), infix_sldt(i_to_c((power(2, n) - i)), 
                   i_to_c(multi)))))))))));

fc729: (INT, INT, complex) -> (ARRAY INT OF complex);

fc730: (INT, INT) -> (ARRAY INT OF complex);

% fc'def
  ASSERT
  (FORALL (multi : INT, n : INT, cst : complex, i : INT): (tb2t(
  infix_at(complex1, int, t2tb12(fc729(multi, n, cst)), t2tb5(i))) = 
  infix_asdt(i_to_c(greatest_factor_in_n(multi, n, i)), cst)));

% fc'def
  ASSERT
  (FORALL (multi : INT, n : INT, i : INT): (tb2t(infix_at(complex1, int, 
  t2tb12(fc730(multi, n)), t2tb5(i))) = cpower(i_to_c(
  greatest_factor_in_n(multi, n, i)), 2)));

% greatest_factor_sum_in_n
  ASSERT
  (FORALL (multi : INT, n : INT, cst : complex):
  ((0 < n)
  => (((0 < multi) AND (multi < power(2, n)))
     => ((sum(int, t2tb6(to_fset(0, multi)), t2tb12(fc729(multi, n, cst))) = 
        infix_asdt(i_to_c(power(2, n)), cst)) AND (infix_lseqdt(cpower(
        i_to_c(power(2, n)), 2), infix_asdt(sum(int, t2tb6(to_fset(0,
        multi)), t2tb12(fc730(multi, n))), i_to_c(multi))))))));

% antirefl_co_prime
  ASSERT (FORALL (a : INT): ((1 < a) => (NOT (co_prime(a, a)))));

min_filter_b: (INT, INT, (ARRAY INT OF BITVECTOR(1))) -> INT;

% min_filter_b'def
  ASSERT
  (FORALL (i : INT, j : INT, p : (ARRAY INT OF BITVECTOR(1))):
  ((EXISTS (e : INT):
   (((i <= e) AND (e < j)) AND (tb2t2(infix_at(bool, int, t2tb9(p), 
   t2tb5(e))) = 0bin1)))
  => (IF (tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(i))) = 0bin1) THEN (
     min_filter_b(i, j, p) = i) ELSE (min_filter_b(i, j, p) = 
     min_filter_b((i + 1), j, p)) ENDIF)));

% min_filter_b'spec
  ASSERT
  (FORALL (i : INT, j : INT, p : (ARRAY INT OF BITVECTOR(1))):
  ((EXISTS (e : INT):
   (((i <= e) AND (e < j)) AND (tb2t2(infix_at(bool, int, t2tb9(p), 
   t2tb5(e))) = 0bin1)))
  => ((min_filter_b(i, j, p) = min_filter(to_fset(i, j), p))
     AND ((tb2t2(infix_at(bool, int, t2tb9(p), t2tb5(min_filter_b(i, j,
         p)))) = 0bin1)
         AND (((i <= min_filter_b(i, j, p)) AND (min_filter_b(i, j, p) < j))
             AND ((FORALL (e : INT):
                  (((i <= e) AND (e < j))
                  => ((tb2t2(infix_at(bool, int, t2tb9(p), 
                     t2tb5(e))) = 0bin1) => (min_filter_b(i, j, p) <= e))))
                 AND (FORALL (e : INT):
                     (((i <= e) AND (e < j))
                     => ((e < min_filter_b(i, j, p))
                        => (NOT (tb2t2(infix_at(bool, int, t2tb9(p), 
                           t2tb5(e))) = 0bin1)))))))))));

euler_phi: (INT) -> INT;

% euler_phi'def
  ASSERT
  (FORALL (i : INT):
  ((0 < i) => (euler_phi(i) = cardinal(int, t2tb6(co_primes(i))))));

% euler_phi'spec
  ASSERT
  (FORALL (i : INT):
  ((0 < i)
  => ((1 < i) => (mem(int, t2tb5(euler_phi(i)), t2tb6(to_fset(1, i)))))));

% injec_mult_mod_pre
  ASSERT
  (FORALL (a : INT, i : INT, iqt : INT, bound : INT):
  ((co_prime(a, bound))
  => (((0 <= i) AND ((i < iqt) AND (iqt < bound)))
     => (NOT (mod((i * a), bound) = mod((iqt * a), bound))))));

% injec_mult_mod
  ASSERT
  (FORALL (a : INT, i : INT, iqt : INT, bound : INT):
  ((co_prime(a, bound))
  => (((0 <= i) AND (i < bound))
     => (((0 <= iqt) AND (iqt < bound))
        => ((NOT (i = iqt))
           => (NOT (mod((i * a), bound) = mod((iqt * a), bound))))))));

% co_prime_mod_mult
  ASSERT
  (FORALL (a : INT, e : INT, bound : INT):
  ((0 < a)
  => ((0 < e)
     => ((1 < bound)
        => ((co_prime(a, bound))
           => ((co_prime(e, bound)) => (co_prime(mod((a * e), bound),
              bound))))))));

fc731: (INT, INT) -> (ARRAY INT OF INT);

fc732: (INT, INT) -> (ARRAY INT OF INT);

% fc'def
  ASSERT
  (FORALL (a : INT, bound : INT, i : INT): ((fc731(a, bound)[i]) = 
  mod((a * i), bound)));

% fc'def
  ASSERT
  (FORALL (a : INT, bound : INT, i : INT): ((fc732(a, bound)[i]) = 
  mod((a * i), bound)));

% set_injec_mult_mod
  ASSERT
  (FORALL (a : INT, bound : INT):
  ((1 < bound)
  => ((co_prime(a, bound))
     => ((p_bijective(int, int, t2tb7(fc731(a, bound)), t2tb6(
        co_primes(bound)), t2tb6(co_primes(bound)))) AND (tb2t6(map(int, int, 
        t2tb7(fc732(a, bound)), t2tb6(co_primes(bound)))) = 
        co_primes(bound))))));

% injec_mult_mod_rev
  ASSERT
  (FORALL (a : INT, i : INT, iqt : INT, bound : INT):
  ((1 < bound)
  => ((co_prime(a, bound))
     => (((0 <= i) AND (i < bound))
        => (((0 <= iqt) AND (iqt < bound))
           => ((mod((i * a), bound) = mod((iqt * a), bound)) => (i = iqt)))))));

bezout_pred: (INT, INT, INT) -> BOOLEAN;

% bezout_pred'def
  ASSERT
  (FORALL (pick : INT, bound : INT, k : INT):
  ((bezout_pred(pick, bound, k))
  <=> (EXISTS (a : INT, b : INT): (k = ((a * pick) + (b * bound))))));

bezout_set: (INT, INT) -> set_int;

% bezout_set'spec
  ASSERT
  (FORALL (pick : INT, bound : INT):
  (((0 < pick) AND (pick < bound))
  => ((mem(int, t2tb5(min_set(bezout_set(pick, bound))), t2tb6(
     divisors(pick))))
     AND ((mem(int, t2tb5(min_set(bezout_set(pick, bound))), t2tb6(
         divisors(bound))))
         AND ((0 < cardinal(int, t2tb6(bezout_set(pick, bound))))
             AND (((0 <= min_set(bezout_set(pick, bound))) AND (min_set(
                  bezout_set(pick, bound)) <= pick))
                 AND ((0 <= min_set(bezout_set(pick, bound))) AND (min_set(
                     bezout_set(pick, bound)) < bound))))))));

% euler_theorem
  ASSERT
  (FORALL (pick : INT, bound : INT):
  (((0 < pick) AND (pick < bound))
  => ((co_prime(pick, bound)) => (mod(power(pick, euler_phi(bound)),
     bound) = 1))));

modular_inverse: (INT, INT) -> INT;

result90: (INT, INT) -> (ARRAY INT OF BITVECTOR(1));

% result'def
  ASSERT
  (FORALL (pick : INT, bound : INT, i : INT):
  ((tb2t2(infix_at(bool, int, t2tb9(result90(pick, bound)), 
  t2tb5(i))) = 0bin1) <=> (mod((i * pick), bound) = 1)));

% modular_inverse'def
  ASSERT
  (FORALL (pick : INT, bound : INT):
  (((0 < pick) AND (pick < bound))
  => ((co_prime(pick, bound)) => (modular_inverse(pick, bound) = 
     min_filter_b(0, bound, result90(pick, bound))))));

% modular_inverse'spec
  ASSERT
  (FORALL (pick : INT, bound : INT):
  (((0 < pick) AND (pick < bound))
  => ((co_prime(pick, bound))
     => (((0 <= modular_inverse(pick, bound)) AND (modular_inverse(pick,
         bound) < bound))
        AND (mod((modular_inverse(pick, bound) * pick), bound) = 1)))));

multi_order: (INT, INT) -> INT;

result91: (INT, INT) -> (ARRAY INT OF BITVECTOR(1));

% result'def
  ASSERT
  (FORALL (pick : INT, bound : INT, i : INT):
  ((tb2t2(infix_at(bool, int, t2tb9(result91(pick, bound)), 
  t2tb5(i))) = 0bin1) <=> (mod(power(pick, i), bound) = 1)));

% multi_order'def
  ASSERT
  (FORALL (pick : INT, bound : INT):
  ((co_prime(pick, bound))
  => (((0 < pick) AND (pick < bound)) => (multi_order(pick, bound) = 
     min_filter_b(1, bound, result91(pick, bound))))));

% multi_order'spec
  ASSERT
  (FORALL (pick : INT, bound : INT):
  ((co_prime(pick, bound))
  => (((0 < pick) AND (pick < bound))
     => (((1 <= multi_order(pick, bound)) AND (multi_order(pick,
         bound) < bound))
        AND (mod(power(pick, multi_order(pick, bound)), bound) = 1)))));

% modular_expo
  ASSERT
  (FORALL (a : INT, k : INT, bound : INT, i : INT):
  ((0 <= i)
  => (((0 < a) AND (a < bound))
     => ((0 <= k)
        => ((co_prime(a, bound))
           => ((2 <= bound) => (mod(power(a, i), bound) = mod(power(a, ((k * 
              multi_order(a, bound)) + i)), bound))))))));

% modular_expo_gen
  ASSERT
  (FORALL (a : INT, bound : INT):
  (((0 < a) AND (a < bound))
  => ((co_prime(a, bound))
     => (FORALL (i : INT, k : INT):
        ((0 <= i)
        => ((0 <= k) => (mod(power(a, i), bound) = mod(power(a, ((k * 
           multi_order(a, bound)) + i)), bound))))))));

% modular_expo_rev
  ASSERT
  (FORALL (a : INT, k : INT, bound : INT, i : INT):
  (((0 < a) AND (a < bound))
  => ((0 <= i)
     => ((0 <= k)
        => ((co_prime(a, bound)) => (mod(power(a, ((k * multi_order(a,
           bound)) + i)), bound) = mod(power(a, i), bound)))))));

% modular_expo_gen_rev
  ASSERT
  (FORALL (a : INT, bound : INT):
  (((0 < a) AND (a < bound))
  => ((co_prime(a, bound))
     => (FORALL (i : INT, k : INT):
        ((0 <= i)
        => ((0 <= k) => (mod(power(a, ((k * multi_order(a, bound)) + i)),
           bound) = mod(power(a, i), bound))))))));

% modular_expo_modulo
  ASSERT
  (FORALL (pick : INT, bound : INT, i : INT):
  ((co_prime(pick, bound))
  => (((0 < pick) AND (pick < bound))
     => ((0 <= i) => (mod(power(pick, i), bound) = mod(power(pick, mod(i, 
        multi_order(pick, bound))), bound))))));

% modular_expo_modulo_rev
  ASSERT
  (FORALL (pick : INT, bound : INT, i : INT):
  ((co_prime(pick, bound))
  => (((0 < pick) AND (pick < bound))
     => ((0 <= i) => (mod(power(pick, mod(i, multi_order(pick, bound))),
        bound) = mod(power(pick, i), bound))))));

% injec_mod_prod_multi_order_pre
  ASSERT
  (FORALL (pick : INT, bound : INT, i : INT, iqt : INT):
  ((co_prime(pick, bound))
  => (((0 < pick) AND (pick < bound))
     => ((mem(int, t2tb5(i), t2tb6(to_fset(0, multi_order(pick, bound)))))
        => ((mem(int, t2tb5(iqt), t2tb6(to_fset(0, multi_order(pick,
           bound)))))
           => ((i < iqt)
              => (NOT (mod(power(pick, iqt), bound) = mod(power(pick, i),
                 bound)))))))));

% injec_mod_prod_multi_order
  ASSERT
  (FORALL (pick : INT, bound : INT, i : INT, iqt : INT):
  ((co_prime(pick, bound))
  => (((0 < pick) AND (pick < bound))
     => ((mem(int, t2tb5(i), t2tb6(to_fset(0, multi_order(pick, bound)))))
        => ((mem(int, t2tb5(iqt), t2tb6(to_fset(0, multi_order(pick,
           bound)))))
           => ((NOT (i = iqt))
              => (NOT (mod(power(pick, iqt), bound) = mod(power(pick, i),
                 bound)))))))));

% injec_mod_prod_multi_order_gen
  ASSERT
  (FORALL (pick : INT, bound : INT, i : INT, iqt : INT):
  ((co_prime(pick, bound))
  => (((0 < pick) AND (pick < bound))
     => ((NOT (mod(i, multi_order(pick, bound)) = mod(iqt, multi_order(pick,
         bound))))
        => ((0 <= i)
           => ((0 <= iqt)
              => (NOT (mod(power(pick, iqt), bound) = mod(power(pick, i),
                 bound)))))))));

% mod_eq_power_to_multi_order
  ASSERT
  (FORALL (pick : INT, bound : INT, i : INT, iqt : INT):
  ((co_prime(pick, bound))
  => (((0 < pick) AND (pick < bound))
     => ((0 <= i)
        => ((0 <= iqt)
           => ((mod(power(pick, iqt), bound) = mod(power(pick, i), bound))
              => (mod(i, multi_order(pick, bound)) = mod(iqt, 
              multi_order(pick, bound)))))))));

% mod_eq_multi_order_to_power
  ASSERT
  (FORALL (pick : INT, bound : INT, i : INT, iqt : INT):
  ((co_prime(pick, bound))
  => (((0 < pick) AND (pick < bound))
     => ((0 <= i)
        => ((0 <= iqt)
           => ((mod(i, multi_order(pick, bound)) = mod(iqt, multi_order(pick,
              bound))) => (mod(power(pick, iqt), bound) = mod(power(pick, i),
              bound))))))));

composite: (shor_) -> INT;

compos_log: (shor_) -> INT;

picked: (shor_) -> INT;

% shor_'invariant
  ASSERT
  (FORALL (self : shor_):PATTERN (picked(self)): PATTERN (compos_log(self)):
  PATTERN (composite(self)): 
  ((0 < compos_log(self))
  AND (((1 < picked(self)) AND (picked(self) < composite(self)))
      AND (((power(2, (compos_log(self) - 1)) <= composite(self)) AND (
           composite(self) < power(2, compos_log(self))))
          AND ((co_prime(picked(self), composite(self))) AND (0 < 
              compos_log(self)))))));

s1: (tuple0) -> ref_shor_;

% bound_inf
  ASSERT
  ((0 < composite(contents1(s1(Tuple0)))) AND (1 < composite(contents1(
  s1(Tuple0)))));

fc1129: (bitvec, (ARRAY INT OF INT), INT) -> (ARRAY INT OF angle);

fc1130: (bitvec, (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

fc1131: (bitvec, (ARRAY INT OF INT), INT) -> (ARRAY INT OF angle);

fc1132: (bitvec, (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

fc1133: (bitvec, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

fc1134: (bitvec, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

fc1135: (bitvec, INT, (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

fc1136: (bitvec, (ARRAY INT OF INT), INT) -> (ARRAY INT OF angle);

fc1137: (bitvec, (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

fc1138: (INT, bitvec, bitvec, INT) -> (ARRAY INT OF angle);

fc1139: (INT, bitvec, bitvec) -> (ARRAY INT OF angle);

fc1140: (bitvec, (ARRAY INT OF INT), INT) -> (ARRAY INT OF angle);

fc1141: (bitvec, (ARRAY INT OF INT)) -> (ARRAY INT OF angle);

% fc'def
  ASSERT
  (FORALL (y : bitvec, x : (ARRAY INT OF INT), target : INT, j : INT): ((
  fc1129(y, x, target)[j]) = infix_sldtsl((((value(y)[j]) * (x[target])) * 
  power(2, ((compos_log(contents1(s1(Tuple0))) - j) + (compos_log(contents1(
  s1(Tuple0))) - target)))), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (y : bitvec, x : (ARRAY INT OF INT), target : INT): ((fc1130(y,
  x)[target]) = ang_sum(fc1129(y, x, target), (compos_log(contents1(
  s1(Tuple0))) - target), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (y : bitvec, x : (ARRAY INT OF INT), target : INT, j : INT): ((
  fc1131(y, x, target)[j]) = infix_sldtsl((((value(y)[j]) * (x[target])) * 
  power(2, ((compos_log(contents1(s1(Tuple0))) - j) + (compos_log(contents1(
  s1(Tuple0))) - target)))), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (y : bitvec, x : (ARRAY INT OF INT), target : INT): ((fc1132(y,
  x)[target]) = ang_sum(fc1131(y, x, target), (compos_log(contents1(
  s1(Tuple0))) - target), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (y : bitvec, k : INT, x : (ARRAY INT OF INT), j : INT): ((fc1133(y,
  k, x)[j]) = infix_sldtsl((((value(y)[j]) * (x[k])) * power(2, (((
  compos_log(contents1(s1(Tuple0))) - j) + compos_log(contents1(
  s1(Tuple0)))) - k))), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (y : bitvec, k : INT, x : (ARRAY INT OF INT), j : INT): ((fc1134(y,
  k, x)[j]) = infix_sldtsl((((value(y)[j]) * (x[k])) * power(2, (((
  compos_log(contents1(s1(Tuple0))) - j) + compos_log(contents1(
  s1(Tuple0)))) - k))), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (y : bitvec, k : INT, x : (ARRAY INT OF INT), j : INT): ((fc1135(y,
  k, x)[j]) = infix_sldtsl((((value(y)[j]) * (x[k])) * power(2, (((
  compos_log(contents1(s1(Tuple0))) - j) + compos_log(contents1(
  s1(Tuple0)))) - k))), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (y : bitvec, x : (ARRAY INT OF INT), target : INT, j : INT): ((
  fc1136(y, x, target)[j]) = infix_sldtsl((((value(y)[j]) * (x[target])) * 
  power(2, ((compos_log(contents1(s1(Tuple0))) - j) + (compos_log(contents1(
  s1(Tuple0))) - target)))), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (y : bitvec, x : (ARRAY INT OF INT), target : INT): ((fc1137(y,
  x)[target]) = ang_sum(fc1136(y, x, target), (compos_log(contents1(
  s1(Tuple0))) - target), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (o : INT, x : bitvec, y : bitvec, target : INT, k : INT): ((
  fc1138(o, x, y, target)[k]) = infix_sldtsl((((value(y)[k]) * (
  value(x)[target])) * power(2, (((o - k) - 1) + ((o - target) - 1)))), o)));

% fc'def
  ASSERT
  (FORALL (o : INT, x : bitvec, y : bitvec, target : INT): ((fc1139(o, x,
  y)[target]) = ang_sum(fc1138(o, x, y, target), ((o - target) - 1), o)));

% fc'def
  ASSERT
  (FORALL (y : bitvec, x : (ARRAY INT OF INT), target : INT, k : INT): ((
  fc1140(y, x, target)[k]) = infix_sldtsl((((value(y)[k]) * (x[target])) * 
  power(2, ((compos_log(contents1(s1(Tuple0))) - k) + (compos_log(contents1(
  s1(Tuple0))) - target)))), (compos_log(contents1(s1(Tuple0))) + 1))));

% fc'def
  ASSERT
  (FORALL (y : bitvec, x : (ARRAY INT OF INT), target : INT): ((fc1141(y,
  x)[target]) = ang_sum(fc1140(y, x, target), (compos_log(contents1(
  s1(Tuple0))) - target), (compos_log(contents1(s1(Tuple0))) + 1))));

QUERY
% pre_adder_const_qtvc
 % File "no_anc_shor_circ.mlw", line 76, characters 13-29
  (FORALL (y : bitvec):
  ((length(y) = (compos_log(contents1(s1(Tuple0))) + 1))
  => (LET o = (compos_log(contents1(s1(Tuple0))) + 1) IN
     ((0 < o)
     AND (LET o1 = m_skip(o) IN
         (((size1(o1) = 0)
          AND ((unwire(o1) = ids(o))
              AND ((ancillas1(o1) = 0)
                  AND ((size1(o1) = 0)
                      AND ((range1(o1) = 0)
                          AND ((width1(o1) = o)
                              AND ((FORALL (x : (ARRAY INT OF INT),
                                   y1 : (ARRAY INT OF INT)):
                                   (FORALL (i : INT): (basis_ket1(o1, x, y1,
                                   i) = (x[i]))))
                                  AND ((FORALL (x : (ARRAY INT OF INT),
                                       y1 : (ARRAY INT OF INT)): (
                                       ang_ind1(o1, x, y1) = infix_sldtsl(1,
                                       0)))
                                      AND (FORALL (x : (ARRAY INT OF INT),
                                          y1 : (ARRAY INT OF INT)):
                                          (FORALL (k : INT): (ang_ind1(o1, x,
                                          y1) = infix_sldtsl(0, k))))))))))))
         => (((FORALL (x : (ARRAY INT OF INT), z : (ARRAY INT OF INT)):
              ((binary_l(x, (compos_log(contents1(s1(Tuple0))) + 1))) => (
              ang_ind1(o1, x, z) = ang_sum(fc1130(y, x), 0, 0))))
             AND ((FORALL (x : (ARRAY INT OF INT), z : (ARRAY INT OF INT),
                  i : INT):
                  ((binary_l(x, (compos_log(contents1(s1(Tuple0))) + 1)))
                  => (((0 <= i) AND (i < (compos_log(contents1(
                      s1(Tuple0))) + 1)))
                     => (basis_ket1(o1, x, z, i) = (x[i])))))
                 AND ((range1(o1) = 0)
                     AND ((width1(o1) = (compos_log(contents1(
                         s1(Tuple0))) + 1))
                         AND ((ancillas1(o1) = 0)
                             AND ((0 <= 0) AND (0 <= (compos_log(contents1(
                                 s1(Tuple0))) + 1))))))))
            AND (FORALL (c : circuit2, k : INT):
                (((FORALL (x : (ARRAY INT OF INT), z : (ARRAY INT OF INT)):
                  ((binary_l(x, (compos_log(contents1(s1(Tuple0))) + 1)))
                  => (ang_ind1(c, x, z) = ang_sum(fc1132(y, x), 0, k))))
                 AND ((FORALL (x : (ARRAY INT OF INT),
                      z : (ARRAY INT OF INT), i : INT):
                      ((binary_l(x, (compos_log(contents1(s1(Tuple0))) + 1)))
                      => (((0 <= i) AND (i < (compos_log(contents1(
                          s1(Tuple0))) + 1)))
                         => (basis_ket1(c, x, z, i) = (x[i])))))
                     AND ((range1(c) = 0)
                         AND ((width1(c) = (compos_log(contents1(
                             s1(Tuple0))) + 1))
                             AND ((ancillas1(c) = 0)
                                 AND ((0 <= k) AND (k <= (compos_log(
                                     contents1(s1(Tuple0))) + 1))))))))
                => (IF (k <= compos_log(contents1(s1(Tuple0))))
                   THEN (LET o2 = (compos_log(contents1(s1(Tuple0))) + 1) IN
                        ((0 < o2)
                        AND (LET o3 = m_skip(o2) IN
                            (((size1(o3) = 0)
                             AND ((unwire(o3) = ids(o2))
                                 AND ((ancillas1(o3) = 0)
                                     AND ((size1(o3) = 0)
                                         AND ((range1(o3) = 0)
                                             AND ((width1(o3) = o2)
                                                 AND ((FORALL
                                                      (x : (ARRAY INT OF INT),
                                                      y1 : (ARRAY INT OF INT)):
                                                      (FORALL (i : INT): (
                                                      basis_ket1(o3, x, y1,
                                                      i) = (x[i]))))
                                                     AND ((FORALL
                                                          (x : (ARRAY INT OF INT),
                                                          y1 : (ARRAY INT OF INT)):
                                                          (ang_ind1(o3, x,
                                                          y1) = 
                                                          infix_sldtsl(1,
                                                          0)))
                                                         AND (FORALL
                                                             (x : (ARRAY INT OF INT),
                                                             y1 : (ARRAY INT OF INT)):
                                                             (FORALL
                                                             (k1 : INT): (
                                                             ang_ind1(o3, x,
                                                             y1) = 
                                                             infix_sldtsl(0,
                                                             k1))))))))))))
                            => (((FORALL (x : (ARRAY INT OF INT),
                                 z : (ARRAY INT OF INT)):
                                 ((binary_l(x, (compos_log(contents1(
                                 s1(Tuple0))) + 1))) => (ang_ind1(o3, x,
                                 z) = ang_sum(fc1133(y, k, x), (compos_log(
                                 contents1(s1(Tuple0))) - k), (compos_log(
                                 contents1(s1(Tuple0))) - k)))))
                                AND ((FORALL (x : (ARRAY INT OF INT),
                                     z : (ARRAY INT OF INT), i : INT):
                                     (((0 <= i) AND (i < (compos_log(
                                      contents1(s1(Tuple0))) + 1)))
                                     => ((binary_l(x, (compos_log(contents1(
                                        s1(Tuple0))) + 1))) => (
                                        basis_ket1(o3, x, z, i) = (x[i])))))
                                    AND ((range1(o3) = 0)
                                        AND ((width1(o3) = (compos_log(
                                            contents1(s1(Tuple0))) + 1))
                                            AND ((ancillas1(o3) = 0)
                                                AND (((compos_log(contents1(
                                                    s1(Tuple0))) - k) <= (
                                                    compos_log(contents1(
                                                    s1(Tuple0))) - k)) AND ((
                                                    compos_log(contents1(
                                                    s1(Tuple0))) - k) <= (
                                                    compos_log(contents1(
                                                    s1(Tuple0))) + 1))))))))
                               AND (FORALL (cl : circuit2, i : INT):
                                   (((FORALL (x : (ARRAY INT OF INT),
                                     z : (ARRAY INT OF INT)):
                                     ((binary_l(x, (compos_log(contents1(
                                     s1(Tuple0))) + 1))) => (ang_ind1(cl, x,
                                     z) = ang_sum(fc1134(y, k, x), (
                                     compos_log(contents1(s1(Tuple0))) - k),
                                     i))))
                                    AND ((FORALL (x : (ARRAY INT OF INT),
                                         z : (ARRAY INT OF INT), i1 : INT):
                                         (((0 <= i1) AND (i1 < (compos_log(
                                          contents1(s1(Tuple0))) + 1)))
                                         => ((binary_l(x, (compos_log(
                                            contents1(s1(Tuple0))) + 1)))
                                            => (basis_ket1(cl, x, z,
                                            i1) = (x[i1])))))
                                        AND ((range1(cl) = 0)
                                            AND ((width1(cl) = (compos_log(
                                                contents1(s1(Tuple0))) + 1))
                                                AND ((ancillas1(cl) = 0)
                                                    AND (((compos_log(
                                                        contents1(
                                                        s1(Tuple0))) - k) <= i)
                                                        AND (i <= (
                                                        compos_log(contents1(
                                                        s1(Tuple0))) + 1))))))))
                                   => (IF (i < (compos_log(contents1(
                                      s1(Tuple0))) + 1))
                                      THEN (FORALL (i1 : INT):
                                           ((i1 = (i + 1))
                                           => (LET o4 = (compos_log(
                                              contents1(s1(Tuple0))) + 1) IN
                                              (LET o5 = value(y) IN
                                              (((binary(o5))
                                               AND (FORALL (i2 : INT):
                                                   ((o5[i2]) = (
                                                   value(y)[i2]))))
                                              => (LET o6 =
                                                 ((o5[(i1 - 1)]) * ((k + i1) - 
                                                 compos_log(contents1(
                                                 s1(Tuple0))))) IN
                                                 (((0 <= k) AND (k < o4))
                                                 AND (LET o7 = prz(o6, k,
                                                     o4) IN
                                                     (((width1(o7) = o4)
                                                      AND ((size1(o7) = 1)
                                                          AND ((
                                                              range1(o7) = 0)
                                                              AND ((
                                                                  ancillas1(o7) = 0)
                                                                  AND 
                                                                  ((FORALL
                                                                   (x : (ARRAY INT OF INT),
                                                                   y1 : (ARRAY INT OF INT),
                                                                   i2 : INT):
                                                                   (
                                                                   basis_ket1(o7,
                                                                   x, y1,
                                                                   i2) = (x[i2])))
                                                                  AND 
                                                                  (FORALL
                                                                  (x : (ARRAY INT OF INT),
                                                                  y1 : (ARRAY INT OF INT)):
                                                                  (((0 <= o6)
                                                                   AND (o6 <= o4))
                                                                  => (
                                                                  ang_ind1(o7,
                                                                  x, y1) = 
                                                                  infix_sldtsl(((x[k]) * 
                                                                  power(2,
                                                                  (o4 - o6))),
                                                                  o4)))))))))
                                                     => (((width1(cl) = 
                                                         width1(o7))
                                                         AND ((
                                                             range1(cl) = 0)
                                                             AND ((
                                                                 range1(o7) = 0)
                                                                 AND 
                                                                 ((FORALL
                                                                  (x : (ARRAY INT OF INT),
                                                                  y1 : (ARRAY INT OF INT),
                                                                  i2 : INT):
                                                                  ((binary_l(x,
                                                                  width1(cl)))
                                                                  => 
                                                                  (((0 <= i2)
                                                                   AND (i2 < 
                                                                   width1(cl)))
                                                                  => (
                                                                  basis_ket1(cl,
                                                                  x, y1,
                                                                  i2) = (x[i2])))))
                                                                 AND 
                                                                 (FORALL
                                                                 (x : (ARRAY INT OF INT),
                                                                 y1 : (ARRAY INT OF INT),
                                                                 i2 : INT):
                                                                 ((binary_l(x,
                                                                 width1(o7)))
                                                                 => (
                                                                    ((0 <= i2)
                                                                    AND (i2 < 
                                                                    width1(o7)))
                                                                    => (
                                                                    basis_ket1(o7,
                                                                    x, y1,
                                                                    i2) = (x[i2])))))))))
                                                        AND (LET o8 = 
                                                            seq_diag(cl,
                                                            o7) IN
                                                            (((size1(o8) = (
                                                             size1(cl) + 
                                                             size1(o7)))
                                                             AND ((
                                                                 ancillas1(o8) = 
                                                                 max(
                                                                 ancillas1(cl),
                                                                 ancillas1(o7)))
                                                                 AND 
                                                                 ((
                                                                 pre1(o8) = 
                                                                 Sequence1(
                                                                 pre1(cl), 
                                                                 pre1(o7)))
                                                                 AND 
                                                                 ((FORALL
                                                                  (x : (ARRAY INT OF INT),
                                                                  y1 : (ARRAY INT OF INT),
                                                                  i2 : INT):
                                                                  ((binary_l(x,
                                                                  width1(cl)))
                                                                  => 
                                                                  (((0 <= i2)
                                                                   AND (i2 < 
                                                                   width1(cl)))
                                                                  => (
                                                                  basis_ket1(o8,
                                                                  x, y1,
                                                                  i2) = (x[i2])))))
                                                                 AND 
                                                                 ((
                                                                 width1(o8) = 
                                                                 width1(cl))
                                                                 AND 
                                                                 ((
                                                                 range1(o8) = 0)
                                                                 AND 
                                                                 (FORALL
                                                                 (x : (ARRAY INT OF INT),
                                                                 y1 : (ARRAY INT OF INT)):
                                                                 ((binary_l(x,
                                                                 width1(cl)))
                                                                 => (
                                                                 ang_ind1(o8,
                                                                 x, y1) = 
                                                                 ang_add(
                                                                 ang_ind1(cl,
                                                                 x, y1), 
                                                                 ang_ind1(o7,
                                                                 x, y1)))))))))))
                                                            => (FORALL
                                                               (cl1 : circuit2):
                                                               ((cl1 = o8)
                                                               => (((0 <= ((
                                                                   compos_log(
                                                                   contents1(
                                                                   s1(Tuple0))) + 1) - i))
                                                                   AND (((
                                                                   compos_log(
                                                                   contents1(
                                                                   s1(Tuple0))) + 1) - i1) < ((
                                                                   compos_log(
                                                                   contents1(
                                                                   s1(Tuple0))) + 1) - i)))
                                                                  AND 
                                                                  ((FORALL
                                                                   (x : (ARRAY INT OF INT),
                                                                   z : (ARRAY INT OF INT)):
                                                                   ((binary_l(x,
                                                                   (
                                                                   compos_log(
                                                                   contents1(
                                                                   s1(Tuple0))) + 1)))
                                                                   => (
                                                                   ang_ind1(cl1,
                                                                   x, z) = 
                                                                   ang_sum(
                                                                   fc1135(y,
                                                                   k, x), (
                                                                   compos_log(
                                                                   contents1(
                                                                   s1(Tuple0))) - k),
                                                                   i1))))
                                                                  AND 
                                                                  ((FORALL
                                                                   (x : (ARRAY INT OF INT),
                                                                   z : (ARRAY INT OF INT),
                                                                   i2 : INT):
                                                                   (((0 <= i2)
                                                                    AND (i2 < (
                                                                    compos_log(
                                                                    contents1(
                                                                    s1(Tuple0))) + 1)))
                                                                   => 
                                                                   ((binary_l(x,
                                                                   (
                                                                   compos_log(
                                                                   contents1(
                                                                   s1(Tuple0))) + 1)))
                                                                   => (
                                                                   basis_ket1(cl1,
                                                                   x, z,
                                                                   i2) = (x[i2])))))
                                                                  AND 
                                                                  ((
                                                                  range1(cl1) = 0)
                                                                  AND 
                                                                  ((
                                                                  width1(cl1) = (
                                                                  compos_log(
                                                                  contents1(
                                                                  s1(Tuple0))) + 1))
                                                                  AND 
                                                                  ((
                                                                  ancillas1(cl1) = 0)
                                                                  AND 
                                                                  (((
                                                                  compos_log(
                                                                  contents1(
                                                                  s1(Tuple0))) - k) <= i1)
                                                                  AND (i1 <= (
                                                                  compos_log(
                                                                  contents1(
                                                                  s1(Tuple0))) + 1)))))))))))))))))))))))
                                      ELSE (((width1(c) = width1(cl))
                                            AND ((range1(c) = 0)
                                                AND ((range1(cl) = 0)
                                                    AND ((FORALL
                                                         (x : (ARRAY INT OF INT),
                                                         y1 : (ARRAY INT OF INT),
                                                         i1 : INT):
                                                         ((binary_l(x, 
                                                         width1(c)))
                                                         => (((0 <= i1)
                                                             AND (i1 < 
                                                             width1(c)))
                                                            => (basis_ket1(c,
                                                            x, y1,
                                                            i1) = (x[i1])))))
                                                        AND (FORALL
                                                            (x : (ARRAY INT OF INT),
                                                            y1 : (ARRAY INT OF INT),
                                                            i1 : INT):
                                                            ((binary_l(x, 
                                                            width1(cl)))
                                                            => (((0 <= i1)
                                                                AND (i1 < 
                                                                width1(cl)))
                                                               => (
                                                               basis_ket1(cl,
                                                               x, y1,
                                                               i1) = (x[i1])))))))))
                                           AND (LET o4 = seq_diag(c, cl) IN
                                               (((size1(o4) = (size1(c) + 
                                                size1(cl)))
                                                AND ((ancillas1(o4) = max(
                                                    ancillas1(c), 
                                                    ancillas1(cl)))
                                                    AND ((pre1(o4) = 
                                                        Sequence1(pre1(c), 
                                                        pre1(cl)))
                                                        AND ((FORALL
                                                             (x : (ARRAY INT OF INT),
                                                             y1 : (ARRAY INT OF INT),
                                                             i1 : INT):
                                                             ((binary_l(x, 
                                                             width1(c)))
                                                             => (((0 <= i1)
                                                                 AND (i1 < 
                                                                 width1(c)))
                                                                => (
                                                                basis_ket1(o4,
                                                                x, y1,
                                                                i1) = (x[i1])))))
                                                            AND ((
                                                                width1(o4) = 
                                                                width1(c))
                                                                AND ((
                                                                    range1(o4) = 0)
                                                                    AND 
                                                                    (FORALL
                                                                    (x : (ARRAY INT OF INT),
                                                                    y1 : (ARRAY INT OF INT)):
                                                                    ((binary_l(x,
                                                                    width1(c)))
                                                                    => (
                                                                    ang_ind1(o4,
                                                                    x, y1) = 
                                                                    ang_add(
                                                                    ang_ind1(c,
                                                                    x, y1), 
                                                                    ang_ind1(cl,
                                                                    x, y1)))))))))))
                                               => (FORALL (c1 : circuit2):
                                                  ((c1 = o4)
                                                  => (FORALL (k1 : INT):
                                                     ((k1 = (k + 1))
                                                     => (((0 <= ((compos_log(
                                                         contents1(
                                                         s1(Tuple0))) + 1) - k))
                                                         AND (((compos_log(
                                                         contents1(
                                                         s1(Tuple0))) + 1) - k1) < ((
                                                         compos_log(
                                                         contents1(
                                                         s1(Tuple0))) + 1) - k)))
                                                        AND ((FORALL
                                                             (x : (ARRAY INT OF INT),
                                                             z : (ARRAY INT OF INT)):
                                                             ((binary_l(x, (
                                                             compos_log(
                                                             contents1(
                                                             s1(Tuple0))) + 1)))
                                                             => (ang_ind1(c1,
                                                             x, z) = ang_sum(
                                                             fc1137(y, x), 0,
                                                             k1))))
                                                            AND ((FORALL
                                                                 (x : (ARRAY INT OF INT),
                                                                 z : (ARRAY INT OF INT),
                                                                 i1 : INT):
                                                                 ((binary_l(x,
                                                                 (compos_log(
                                                                 contents1(
                                                                 s1(Tuple0))) + 1)))
                                                                 => (
                                                                    ((0 <= i1)
                                                                    AND (i1 < (
                                                                    compos_log(
                                                                    contents1(
                                                                    s1(Tuple0))) + 1)))
                                                                    => (
                                                                    basis_ket1(c1,
                                                                    x, z,
                                                                    i1) = (x[i1])))))
                                                                AND ((
                                                                    range1(c1) = 0)
                                                                    AND 
                                                                    ((
                                                                    width1(c1) = (
                                                                    compos_log(
                                                                    contents1(
                                                                    s1(Tuple0))) + 1))
                                                                    AND 
                                                                    ((
                                                                    ancillas1(c1) = 0)
                                                                    AND 
                                                                    ((0 <= k1)
                                                                    AND (k1 <= (
                                                                    compos_log(
                                                                    contents1(
                                                                    s1(Tuple0))) + 1)))))))))))))))) ENDIF))))))))
                   ELSE (LET o2 = (compos_log(contents1(s1(Tuple0))) + 1) IN
                        ((0 < o2)
                        AND ((FORALL (x : bitvec, y1 : bitvec):
                             ((length(x) = o2)
                             => ((length(y1) = o2) => (ang_sum(fc1139(o2, x,
                                y1), 0, o2) = infix_sldtsl((bv_to_int(x) * 
                                bv_to_int(y1)), o2)))))
                            => ((width1(c) = (compos_log(contents1(
                               s1(Tuple0))) + 1))
                               AND ((FORALL (x : (ARRAY INT OF INT),
                                    z : (ARRAY INT OF INT)):
                                    ((binary_l(x, (compos_log(contents1(
                                    s1(Tuple0))) + 1))) => (ang_ind1(c, x,
                                    z) = ang_sum(fc1141(y, x), 0, (
                                    compos_log(contents1(s1(Tuple0))) + 1)))))
                                   AND ((FORALL (x : bitvec, z : bitvec):
                                        ((length(x) = (compos_log(contents1(
                                        s1(Tuple0))) + 1)) => (ang_ind1(c, 
                                        value(x), value(z)) = infix_sldtsl((
                                        bv_to_int(x) * bv_to_int(y)), (
                                        compos_log(contents1(
                                        s1(Tuple0))) + 1)))))
                                       AND ((FORALL (x : (ARRAY INT OF INT),
                                            z : (ARRAY INT OF INT), i : INT):
                                            ((binary_l(x, (compos_log(
                                            contents1(s1(Tuple0))) + 1)))
                                            => (((0 <= i) AND (i < (
                                                compos_log(contents1(
                                                s1(Tuple0))) + 1)))
                                               => (basis_ket1(c, x, z,
                                               i) = (x[i])))))
                                           AND ((range1(c) = 0)
                                               AND ((FORALL (x : bitvec):
                                                    ((length(x) = (
                                                    compos_log(contents1(
                                                    s1(Tuple0))) + 1)) => (
                                                    path_sem1(c, 
                                                    bv_to_ket(x)) = 
                                                    infix_asdtdt(
                                                    int_qft_coeff(
                                                    bv_to_int(y), 
                                                    bv_to_int(x), (
                                                    compos_log(contents1(
                                                    s1(Tuple0))) + 1)), 
                                                    bv_to_ket(x)))))
                                                   AND (ancillas1(c) = 0)))))))))) ENDIF))))))))));
